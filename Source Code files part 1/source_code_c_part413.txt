  cbBuffer,  // size of buffer passed-in
                    &cbBuffer  // required buffer size
                    ))
    {
        dwLastError = GetLastError();

        if(dwLastError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto error;
        }

        //
        // try again with the specified buffer size
        //

        ptgUser = (PTOKEN_USER)SSAlloc(cbBuffer);
        if(NULL == ptgUser)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto error;
        }



        if(!GetTokenInformation(
                            pServerContext->hToken,    // identifies access token
                            TokenUser, // TokenUser info type
                            ptgUser,   // retrieved info buffer
                            cbBuffer,  // size of buffer passed-in
                            &cbBuffer  // required buffer size
                            ))
        {
            dwLastError = GetLastError();
            goto error;
        }

    }


    //
    // try querying based on a fast stack based buffer first.
    //

    ptgGroups = (PTOKEN_GROUPS)GroupsFastBuffer;
    cbBuffer = sizeof(GroupsFastBuffer);

    if(!GetTokenInformation(
                    pServerContext->hToken,    // identifies access token
                    TokenGroups, // TokenUser info type
                    ptgGroups,   // retrieved info buffer
                    cbBuffer,  // size of buffer passed-in
                    &cbBuffer  // required buffer size
                    ))
    {
        dwLastError = GetLastError();

        if(dwLastError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto error;
        }
        dwLastError = ERROR_SUCCESS;

        //
        // try again with the specified buffer size
        //

        ptgGroups = (PTOKEN_GROUPS)SSAlloc(cbBuffer);
        if(NULL == ptgGroups)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto error;
        }



        if(!GetTokenInformation(
                            pServerContext->hToken,    // identifies access token
                            TokenGroups, // TokenUser info type
                            ptgGroups,   // retrieved info buffer
                            cbBuffer,  // size of buffer passed-in
                            &cbBuffer  // required buffer size
                            ))
        {
            dwLastError = GetLastError();
            goto error;
        }

    }


    //
    // if we got the token info successfully, copy the
    // relevant element for the caller.
    //

    cbSid = GetLengthSid(ptgUser->User.Sid);
    cSids = 1;

    for(i=0; i < ptgGroups->GroupCount; i++)
    {
        if(0 == (SE_GROUP_ENABLED & ptgGroups->Groups[i].Attributes))
        {
            continue;
        }
        if(0 == ((SE_GROUP_OWNER | SE_GROUP_USE_FOR_DENY_ONLY) & ptgGroups->Groups[i].Attributes))
        {
            continue;
        }
        cbSid += GetLengthSid(ptgGroups->Groups[i].Sid);
        cSids ++;

    }


    *cpsidHistory = cSids;
    *papsidHistory = (PSID *)SSAlloc(cSids*sizeof(PSID) +  cbSid );

    if(*papsidHistory == NULL)
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    else
    {
        pbCurrentSid = (PBYTE)((*papsidHistory)+cSids);

        // Fill in the primary user SID
        (*papsidHistory)[0] = (PSID)pbCurrentSid;
        cbSid = GetLengthSid(ptgUser->User.Sid);
        CopySid(cbSid, pbCurrentSid, ptgUser->User.Sid);
        pbCurrentSid += cbSid;

        cSids = 1;

        // Fill in the rest of the SIDs
        for(i=0; i < ptgGroups->GroupCount; i++)
        {
            if(0 == (SE_GROUP_ENABLED & ptgGroups->Groups[i].Attributes))
            {
                continue;
            }
            if(0 == ((SE_GROUP_OWNER | SE_GROUP_USE_FOR_DENY_ONLY) & ptgGroups->Groups[i].Attributes))
            {
                continue;
            }
            (*papsidHistory)[cSids++] = pbCurrentSid;
            cbSid = GetLengthSid(ptgGroups->Groups[i].Sid);
            CopySid(cbSid, pbCurrentSid,ptgGroups->Groups[i].Sid);
            pbCurrentSid += cbSid;
        }
    }


error:

    if(FastBuffer != (PBYTE)ptgUser)
    {
        SSFree(ptgUser);
    }

    if(GroupsFastBuffer != (PBYTE)ptgGroups)
    {
        SSFree(ptgGroups);
    }


    return dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\crypt32p.cpp ===
/*
    File:       crypt32.cpp

    Title:      CryptProtect APIs
    Author:     Matt Thomlinson
    Date:       8/2/97


    The CryptProtect API set allows an application to secure
    user data for online and offline storage. While the well-known problem
    of data storage is left to the calling application, this solves the
    relatively unsolved problem of how to cryptographically derive strong
    keys for storing the data. These APIs are initially available on NT5 only.

    Very little checking is done at this level to validate the caller. We
    believe that problem should be solved at a different level -- since all
    other system security is granular to the user, it is difficult to create a
    feature that provides something more granular. Instead, any process running
    under the logged-in user has the ability to decrypt any and all items it
    can retrieve. Callers should note that while items are being processed,
    UI may be spawned to notify the user.

    For user confirmation, the NT secure attention sequence is used to
    garner the wishes of the user. This behavior is set by the caller during protection.

*/

#include <pch.cpp>
#pragma hdrstop
#include "msaudite.h"
#include "crypt.h"


#define             ALGID_DERIVEKEY_HASH        CALG_SHA1       // doesn't change


// USEC: can be as long as we want, since we castrate generated key later
#define             KEY_DERIVATION_BUFSIZE      (128/8)
#define             DEFAULT_BLOCKSIZE_OVERRUN   (128/8)     // allow block ciphers to process up to a 128 bits at a time

#define             MS_BASE_CRYPTPROTECT_VERSION    0x01



DWORD
WINAPI
SPCryptProtect(
        PVOID       pvContext,      // server context
        PBYTE*      ppbOut,         // out encr data
        DWORD*      pcbOut,         // out encr cb
        PBYTE       pbIn,           // in ptxt data
        DWORD       cbIn,           // in ptxt cb
        LPCWSTR     szDataDescr,    // in
        PBYTE       pbOptionalEntropy,  // OPTIONAL
        DWORD       cbOptionalEntropy,
        PSSCRYPTPROTECTDATA_PROMPTSTRUCT      psPrompt,       // OPTIONAL prompting struct
        DWORD       dwFlags,
        BYTE*       pbOptionalPassword,
        DWORD       cbOptionalPassword
        )
{
    DWORD       dwRet;
    LPWSTR      szUser = NULL;
    PBYTE       pbWritePtr = NULL;
    GUID        guidMK;

    WCHAR       wszMKGuidString[MAX_GUID_SZ_CHARS];

    HCRYPTPROV  hVerifyProv;
    HCRYPTHASH  hHash = NULL;
    HCRYPTKEY   hKey = NULL;

    PBYTE       pbCrypt = NULL;
    DWORD       cbCrypt = 0;

    DWORD       cbEncrypted; // count of bytes to encrypt

    PBYTE       pbEncrSalt = NULL;
    DWORD       cbEncrSalt = 0;

    BYTE        rgbPwdBuf[A_SHA_DIGEST_LEN];

    DWORD       cbMACSize = A_SHA_DIGEST_LEN;

    BYTE        rgbEncrKey[KEY_DERIVATION_BUFSIZE];
    BYTE        rgbMACKey[KEY_DERIVATION_BUFSIZE];

    LPBYTE      pbMasterKey = NULL;
    DWORD       cbMasterKey = 0;

    PBYTE       pStreamFlagPtr;

    DWORD       dwProtectionFlags = 0;

    DWORD   dwDefaultCryptProvType = 0;
    DWORD   dwAlgID_Encr_Alg = 0;
    DWORD   dwAlgID_Encr_Alg_KeySize = 0; 
    DWORD   dwAlgID_MAC_Alg = 0;
    DWORD   dwAlgID_MAC_Alg_KeySize = 0;

    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;


#if DBG
    D_DebugLog((DEB_TRACE_API,"SPCryptProtect 0x%x called\n", pServerContext));

    if(pServerContext)
    {
        if(pServerContext->cbSize == sizeof(CRYPT_SERVER_CONTEXT))
        {
            D_DebugLog((DEB_TRACE_API, "  pServerContext->hBinding:%d\n", pServerContext->hBinding));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->fOverrideToLocalSystem:%d\n", pServerContext->fOverrideToLocalSystem));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->fImpersonating:%d\n", pServerContext->fImpersonating));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->hToken:%d\n", pServerContext->hToken));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->szUserStorageArea:%ls\n", pServerContext->szUserStorageArea));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->WellKnownAccount:%d\n", pServerContext->WellKnownAccount));
        }
    }
    
    D_DebugLog((DEB_TRACE_API, "  pbInput:0x%x\n", pbIn));
    D_DebugLog((DEB_TRACE_API, "  pszDataDescr:%ls\n", szDataDescr));
    D_DebugLog((DEB_TRACE_API, "  pbOptionalEntropy:0x%x\n", pbOptionalEntropy));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "    ", pbOptionalEntropy, cbOptionalEntropy);
    D_DebugLog((DEB_TRACE_API, "  dwFlags:0x%x\n", dwFlags));
    D_DebugLog((DEB_TRACE_API, "  pbOptionalPassword:0x%x\n", pbOptionalPassword));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "    ", pbOptionalPassword, cbOptionalPassword);
#endif

    ZeroMemory(&guidMK, sizeof(guidMK));
    wszMKGuidString[0] = 0;

    GetDefaultAlgInfo(&dwDefaultCryptProvType,
                      &dwAlgID_Encr_Alg,
                      &dwAlgID_Encr_Alg_KeySize,
                      &dwAlgID_MAC_Alg,
                      &dwAlgID_MAC_Alg_KeySize);

    if( dwFlags & CRYPTPROTECT_LOCAL_MACHINE ) {
        BOOL fOverrideToLocalSystem = TRUE;

        CPSOverrideToLocalSystem(
                pvContext,
                &fOverrideToLocalSystem,
                NULL    // don't care what previous value was
                );

        dwProtectionFlags |= CRYPTPROTECT_LOCAL_MACHINE;
    }


    if( dwFlags & CRYPTPROTECT_CRED_SYNC )
    {
        if(dwFlags != CRYPTPROTECT_CRED_SYNC)
        {
            // If the user is reencrypting master keys, then no other flags 
            // may be specified. Lets do one thing at a time, shall we?
            D_DebugLog((DEB_ERROR, "SPCryptProtect: Invalid flags 0x%x\n", dwFlags));
            return ERROR_INVALID_PARAMETER;
        }
            
        dwRet = CPSImpersonateClient( pvContext );
        if( dwRet == ERROR_SUCCESS )
        {
            dwRet = InitiateSynchronizeMasterKeys( pvContext );

            CPSRevertToSelf( pvContext );
        }

        return dwRet;
    }

    if( dwFlags & CRYPTPROTECT_CRED_REGENERATE )
    {
        if(dwFlags != CRYPTPROTECT_CRED_REGENERATE)
        {
            // If the user is reencrypting master keys, then no other flags 
            // may be specified. Lets do one thing at a time, shall we?
            D_DebugLog((DEB_ERROR, "SPCryptProtect: Invalid flags 0x%x\n", dwFlags));
            return ERROR_INVALID_PARAMETER;
        }

        dwRet = DpapiUpdateLsaSecret( pvContext );
        return dwRet;
    }


    //
    // include additional flags
    //
    dwProtectionFlags |= (dwFlags & (CRYPTPROTECT_SYSTEM | CRYPTPROTECT_AUDIT));

    // else no override; get provider by algs alone
    if (NULL == (hVerifyProv =
        GetCryptProviderHandle(
            dwDefaultCryptProvType,
            dwAlgID_Encr_Alg, &dwAlgID_Encr_Alg_KeySize,
            dwAlgID_MAC_Alg, &dwAlgID_MAC_Alg_KeySize)) )
    {
        dwRet = GetLastError();
        goto Ret;
    }

    dwRet = GetSpecifiedMasterKey(
            pvContext,
            &guidMK,
            &pbMasterKey,
            &cbMasterKey,
            FALSE   // we don't know what master key we want to use - use preferred
            );

    if(dwRet != ERROR_SUCCESS)
        goto Ret;

    MyGuidToStringW(&guidMK, wszMKGuidString);

    //
    // hash pbMasterKey to get rgbPwdBuf
    //

    FMyPrimitiveSHA( pbMasterKey, cbMasterKey, rgbPwdBuf );


    // derive encr key
    {
        if (!RtlGenRandom(
                rgbEncrKey,
                sizeof(rgbEncrKey)))
        {
            dwRet = GetLastError();
            goto Ret;
        }

#if DBG
    // Leave here as regression check
    CheckMACInterop(rgbPwdBuf, sizeof(rgbPwdBuf), rgbEncrKey, sizeof(rgbEncrKey), hVerifyProv, ALGID_DERIVEKEY_HASH);
#endif

        if (!FMyPrimitiveCryptHMAC(
                    rgbPwdBuf,
                    sizeof(rgbPwdBuf),
                    rgbEncrKey,
                    sizeof(rgbEncrKey),
                    hVerifyProv,
                    ALGID_DERIVEKEY_HASH,
                    &hHash))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // add password if exists
        if (NULL != pbOptionalEntropy)
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalEntropy,
                    cbOptionalEntropy,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }
        }

        // add prompted UI based password if exists.
        // will eventually come from SAS
        //

        if ( NULL != pbOptionalPassword && cbOptionalPassword )
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalPassword,
                    cbOptionalPassword,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }

        }

        if (!CryptDeriveKey(
                hVerifyProv,
                dwAlgID_Encr_Alg,
                hHash,
                CRYPT_CREATE_SALT,
                &hKey))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        CryptDestroyHash(hHash);
        hHash = 0;

        // USEC -- (US Export Controls)
        if (ERROR_SUCCESS != (dwRet =
            GetSaltForExportControl(
                hVerifyProv,
                hKey,
                &pbEncrSalt,
                &cbEncrSalt)) )
            goto Ret;
    }

    // derive MAC key
    {
        if (!RtlGenRandom(
                rgbMACKey,
                sizeof(rgbMACKey)))
        {
            dwRet = GetLastError();
            goto Ret;
        }
        if (!FMyPrimitiveCryptHMAC(
                    rgbPwdBuf,
                    sizeof(rgbPwdBuf),
                    rgbMACKey,
                    sizeof(rgbMACKey),
                    hVerifyProv,
                    dwAlgID_MAC_Alg,
                    &hHash))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // add password if exists
        if (NULL != pbOptionalEntropy)
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalEntropy,
                    cbOptionalEntropy,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }
        }

        // add prompted UI based password if exists.
        // will eventually come from SAS
        //

        if ( NULL != pbOptionalPassword && cbOptionalPassword )
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalPassword,
                    cbOptionalPassword,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }

        }

        // USEC -- (US Export Controls)
        // Does not apply to MAC -- use strong key
    }

    // Decrypt the input buffer.
    if((dwFlags & CRYPTPROTECT_IN_PROCESS) == 0)
    {
        DWORD cbPadding;

        if((cbIn < RTL_ENCRYPT_MEMORY_SIZE) || 
           (cbIn % RTL_ENCRYPT_MEMORY_SIZE))
        {
            dwRet = ERROR_INVALID_DATA;
            goto Ret;
        }

        dwRet = RpcImpersonateClient(((PCRYPT_SERVER_CONTEXT)pvContext)->hBinding);

        if(dwRet == ERROR_SUCCESS)
        {
            NTSTATUS Status;

            Status = RtlDecryptMemory(pbIn,
                                      cbIn,
                                      RTL_ENCRYPT_OPTION_SAME_LOGON);
            if(!NT_SUCCESS(Status))
            {
                dwRet = ERROR_DECRYPTION_FAILED;
            }

            RevertToSelf();
        }

        // Remove padding
        if(dwRet == ERROR_SUCCESS)
        {
            cbPadding = pbIn[cbIn - 1];

            if((cbPadding > 0) &&
               (cbPadding <= cbIn) && 
               (cbPadding <= RTL_ENCRYPT_MEMORY_SIZE))
            {
                cbIn -= cbPadding;
            }
            else
            {
                dwRet = ERROR_INVALID_DATA;
            }
        }
    }


    // hash & encrypt the data
    cbCrypt = cbIn + DEFAULT_BLOCKSIZE_OVERRUN;
    if (NULL == (pbCrypt = (PBYTE)SSAlloc(cbCrypt)) )
    {
        dwRet = ERROR_OUTOFMEMORY;
        goto Ret;
    }
    CopyMemory(pbCrypt, pbIn, cbIn);

    // now write data out: size?
    *pcbOut = sizeof(GUID) + 2*sizeof(DWORD);                                   // dwVer + guidMK + dwFlags
    *pcbOut += sizeof(DWORD) + WSZ_BYTECOUNT(szDataDescr);                      // data description
    *pcbOut += 3*sizeof(DWORD) + sizeof(rgbEncrKey);                            // EncrAlgID + AlgIDKeySize + cbEncrKey + EncrKey
    *pcbOut += sizeof(DWORD) + cbEncrSalt;                                      // Encr salt
    *pcbOut += 3*sizeof(DWORD) + sizeof(rgbMACKey);                             // MACAlgID + AlgIDKeySize + cbMACKey + MACKey
    *pcbOut += sizeof(DWORD) + cbCrypt;                                         // size + encrypted data (guess)
    *pcbOut += sizeof(DWORD) + A_SHA_DIGEST_LEN;                                // MAC + MACsize

    *ppbOut = (PBYTE)SSAlloc(*pcbOut);
    if( *ppbOut == NULL ) {
        dwRet = ERROR_OUTOFMEMORY;
        goto Ret;
    }

    ZeroMemory( *ppbOut, *pcbOut );

    pbWritePtr = *ppbOut;

    ////////////////////////////////////////////////////////////////////
    // FYI: Data format
    // (    Version | guidMKid | dwFlags |
    //      cbDataDescr | szDataDescr |
    //
    //      dwEncrAlgID | dwEncrAlgKeySize |
    //      cbEncrKey | EncrKey |
    //      cbEncrSalt | EncrSalt |
    //
    //      dwMACAlgID | dwMACAlgKeySize |
    //      cbMACKey | MACKey |
    //
    //      cbEncrData | EncrData |
    //      cbMAC | MAC )
    //
    // NOTE: entire buffer from Version through EncrData is included in MAC
    ////////////////////////////////////////////////////////////////////

    // dwVersion
    *(DWORD UNALIGNED *)pbWritePtr = MS_BASE_CRYPTPROTECT_VERSION;
    pbWritePtr += sizeof(DWORD);

    // guid MKid
    CopyMemory(pbWritePtr, &guidMK, sizeof(GUID));
    pbWritePtr += sizeof(GUID);

    // dwFlags -- written out later via pStreamFlagPtr
    pStreamFlagPtr = pbWritePtr;
    pbWritePtr += sizeof(DWORD);

    // cbDataDescr
    *(DWORD UNALIGNED *)pbWritePtr = WSZ_BYTECOUNT(szDataDescr);
    pbWritePtr += sizeof(DWORD);

    // szDataDescr
    CopyMemory(pbWritePtr, szDataDescr, WSZ_BYTECOUNT(szDataDescr));
    pbWritePtr += WSZ_BYTECOUNT(szDataDescr);

    // dwEncrAlgID
    *(DWORD UNALIGNED *)pbWritePtr = dwAlgID_Encr_Alg;
    pbWritePtr += sizeof(DWORD);

    // dwEncrAlgKeySize
    *(DWORD UNALIGNED *)pbWritePtr = dwAlgID_Encr_Alg_KeySize;
    pbWritePtr += sizeof(DWORD);

     // cb EncrKey
    *(DWORD UNALIGNED *)pbWritePtr = sizeof(rgbEncrKey);
    pbWritePtr += sizeof(DWORD);

    // Encr Key
    CopyMemory(pbWritePtr, rgbEncrKey, sizeof(rgbEncrKey));
    pbWritePtr += sizeof(rgbEncrKey);

    // cb Encr salt
    *(DWORD UNALIGNED *)pbWritePtr = cbEncrSalt;
    pbWritePtr += sizeof(DWORD);

    // Encr salt
    CopyMemory(pbWritePtr, pbEncrSalt, cbEncrSalt);
    pbWritePtr += cbEncrSalt;

    // dwMACAlgID
    *(DWORD UNALIGNED *)pbWritePtr = dwAlgID_MAC_Alg;
    pbWritePtr += sizeof(DWORD);

    // dwMACAlgKeySize
    *(DWORD UNALIGNED *)pbWritePtr = dwAlgID_MAC_Alg_KeySize;
    pbWritePtr += sizeof(DWORD);

    // cb MAC key
    *(DWORD UNALIGNED *)pbWritePtr = sizeof(rgbMACKey);
    pbWritePtr += sizeof(DWORD);

    // MAC key
    CopyMemory(pbWritePtr, rgbMACKey, sizeof(rgbMACKey));
    pbWritePtr += sizeof(rgbMACKey);

    // USER GATING: only consider if prompt structure specified
    if ( psPrompt )
    {
        if (psPrompt->cbSize != sizeof(SSCRYPTPROTECTDATA_PROMPTSTRUCT))
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if ((psPrompt->dwPromptFlags & ~(CRYPTPROTECT_PROMPT_ON_PROTECT |
                                         CRYPTPROTECT_PROMPT_ON_UNPROTECT | 
                                         CRYPTPROTECT_PROMPT_STRONG |
                                         CRYPTPROTECT_PROMPT_REQUIRE_STRONG)) != 0)
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if ((psPrompt->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG) &&
            (pbOptionalPassword == NULL || cbOptionalPassword == 0)
            )
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        // UI: only if requested by PROMPT_ON_PROTECT
        if ( psPrompt->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_PROTECT )
        {
            if ( dwFlags & CRYPTPROTECT_UI_FORBIDDEN )
            {
                dwRet = ERROR_PASSWORD_RESTRICTION;
                goto Ret;
            }

// UI handled outside service until SAS support added.



            dwProtectionFlags |= CRYPTPROTECT_PROMPT_ON_PROTECT;
        }

        if ( psPrompt->dwPromptFlags & CRYPTPROTECT_PROMPT_ON_UNPROTECT )
            dwProtectionFlags |= CRYPTPROTECT_PROMPT_ON_UNPROTECT;

        if ( psPrompt->dwPromptFlags & CRYPTPROTECT_PROMPT_STRONG )
            dwProtectionFlags |= CRYPTPROTECT_PROMPT_STRONG;

        if ( psPrompt->dwPromptFlags & CRYPTPROTECT_PROMPT_REQUIRE_STRONG )
            dwProtectionFlags |= CRYPTPROTECT_PROMPT_REQUIRE_STRONG;
    }

    // update stored protection flags in the stream
    *(DWORD UNALIGNED *)pStreamFlagPtr = dwProtectionFlags;

    // dansimon recommends that MAC be on encrypted data, such that the
    // MAC has no possibility of revealing info about the plaintext.

    cbEncrypted = cbIn;

    // then Encrypt pbIn
    if (!CryptEncrypt(
            hKey,
            NULL,
            TRUE,
            0,
            pbCrypt,
            &cbEncrypted,
            cbCrypt))
    {
        dwRet = GetLastError();
        goto Ret;
    }
    // now cbCrypt is size of encrypted data
    cbCrypt = cbEncrypted;

    // Encrdata: len
    *(DWORD UNALIGNED *)pbWritePtr = cbCrypt;
    pbWritePtr += sizeof(DWORD);

    // Encrdata: val
    CopyMemory(pbWritePtr, pbCrypt, cbCrypt);
    pbWritePtr += cbCrypt;

    {

        // dansimon recommends that MAC be on encrypted data, such that the
        // MAC has no possibility of revealing info about the plaintext.

        // MAC from start to here
        if (!CryptHashData(
                hHash,
                *ppbOut,
                (DWORD)(pbWritePtr - *ppbOut),
                0))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // cbMAC
        pbWritePtr += sizeof(DWORD);    // skip cb write; retreive hash val first

        // MAC
        if (!CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            pbWritePtr,
            &cbMACSize,
            0))
        {
            dwRet = GetLastError();
            goto Ret;
        }
        // rewrite cbMAC before MAC
        *(DWORD UNALIGNED *)(pbWritePtr - sizeof(DWORD)) = cbMACSize;
        // make sure we didn't overstep
        SS_ASSERT(cbMACSize <= A_SHA_DIGEST_LEN);
        pbWritePtr += cbMACSize;
    }


    // assert allocation size was sufficient
    SS_ASSERT(*ppbOut + *pcbOut >= pbWritePtr);

    // reset output size
    *pcbOut = (DWORD)(pbWritePtr - *ppbOut);

    dwRet = ERROR_SUCCESS;
Ret:


    if((dwProtectionFlags & CRYPTPROTECT_AUDIT) ||
        (ERROR_SUCCESS != dwRet))
    {

        WCHAR wszCryptoAlgs[2*MAX_STRING_ALGID_LENGTH + 2];
        DWORD i;

        i = AlgIDToString(wszCryptoAlgs, dwAlgID_Encr_Alg, dwAlgID_Encr_Alg_KeySize);
        wszCryptoAlgs[i++]= L',';
        wszCryptoAlgs[i++]= L' ';
        AlgIDToString(&wszCryptoAlgs[i], dwAlgID_MAC_Alg, dwAlgID_MAC_Alg_KeySize);

        CPSAudit(pServerContext->hToken,
                SE_AUDITID_DPAPI_PROTECT,
                wszMKGuidString,            // Key Identifier
                szDataDescr,                // Data Description
                dwProtectionFlags,          // Protected Data Flags
                wszCryptoAlgs,              // Protection Algorithms
                dwRet);                     // Failure Reason


    }


    RtlSecureZeroMemory(rgbPwdBuf, sizeof(rgbPwdBuf));
    RtlSecureZeroMemory(rgbEncrKey, sizeof(rgbEncrKey));

    if(pbMasterKey) {
        RtlSecureZeroMemory(pbMasterKey, cbMasterKey);
        SSFree(pbMasterKey);
    }

    if (hKey)
        CryptDestroyKey(hKey);

    if (hHash)
        CryptDestroyHash(hHash);

    if (pbCrypt) 
        SSFree(pbCrypt);

    if (pbEncrSalt)
        SSFree(pbEncrSalt);

    D_DebugLog((DEB_TRACE_API, "SPCryptProtect returned 0x%x\n", dwRet));

    return dwRet;
}



DWORD
WINAPI
SPCryptUnprotect(
        PVOID       pvContext,                          // server context
        PBYTE*      ppbOut,                             // out ptxt data
        DWORD*      pcbOut,                             // out ptxt cb
        PBYTE       pbIn,                               // in encr data
        DWORD       cbIn,                               // in encr cb
        LPWSTR*     ppszDataDescr,                      // OPTIONAL
        PBYTE       pbOptionalEntropy,                  // OPTIONAL
        DWORD       cbOptionalEntropy,
        PSSCRYPTPROTECTDATA_PROMPTSTRUCT  psPrompt,   // OPTIONAL, prompting struct
        DWORD       dwFlags,
        BYTE*       pbOptionalPassword,
        DWORD       cbOptionalPassword
        )
{
    DWORD       dwRet;
    PBYTE       pbReadPtr = pbIn;
    LPWSTR      szUser = NULL;
    GUID        guidMK;
    WCHAR       wszMKGuidString[MAX_GUID_SZ_CHARS];

    HCRYPTPROV  hVerifyProv;
    HCRYPTKEY   hKey = NULL;
    HCRYPTHASH  hHash = NULL;

    BYTE        rgbEncrKey[KEY_DERIVATION_BUFSIZE];
    BYTE        rgbMACKey[KEY_DERIVATION_BUFSIZE];

    DWORD       cbEncr;

    PBYTE       pbEncrSalt = NULL;
    DWORD       cbEncrSalt = 0;

    DWORD       dwEncrAlgID = 0;
    DWORD       dwEncrAlgKeySize = 0;
    DWORD       dwMACAlgID = 0;
    DWORD       dwMACAlgKeySize =0;
    DWORD       cbEncrKeysize, cbMACKeysize;
    DWORD       dwProtectionFlags = 0;

    BYTE        rgbPwdBuf[A_SHA_DIGEST_LEN];

    DWORD       cbDataDescr;
    LPWSTR      szDataDescr = NULL;

    LPBYTE pbMasterKey = NULL;
    DWORD cbMasterKey = 0;
    DWORD cbPlaintext;

#if DBG
    D_DebugLog((DEB_TRACE_API,"SPCryptUnprotect 0x%x called\n", pvContext));

    if(pvContext)
    {
        PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;
        if(pServerContext->cbSize == sizeof(CRYPT_SERVER_CONTEXT))
        {
            D_DebugLog((DEB_TRACE_API, "  pServerContext->hBinding:%d\n", pServerContext->hBinding));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->fOverrideToLocalSystem:%d\n", pServerContext->fOverrideToLocalSystem));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->fImpersonating:%d\n", pServerContext->fImpersonating));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->hToken:%d\n", pServerContext->hToken));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->szUserStorageArea:%ls\n", pServerContext->szUserStorageArea));
            D_DebugLog((DEB_TRACE_API, "  pServerContext->WellKnownAccount:%d\n", pServerContext->WellKnownAccount));
        }
    }
    D_DebugLog((DEB_TRACE_API, "  pbOptionalEntropy:0x%x\n", pbOptionalEntropy));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "    ", pbOptionalEntropy, cbOptionalEntropy);
    D_DebugLog((DEB_TRACE_API, "  dwFlags:0x%x\n", dwFlags));
    D_DebugLog((DEB_TRACE_API, "  pbOptionalPassword:0x%x\n", pbOptionalPassword));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "    ", pbOptionalPassword, cbOptionalPassword);
#endif

    *ppbOut = NULL;
    *pcbOut = 0;

    ZeroMemory(&guidMK, sizeof(guidMK));

    ZeroMemory(rgbPwdBuf, sizeof(rgbPwdBuf));


    DWORD   dwDefaultCryptProvType = 0;
    DWORD   dwAlgID_Encr_Alg = 0;
    DWORD   dwAlgID_Encr_Alg_KeySize = 0; 
    DWORD   dwAlgID_MAC_Alg = 0;
    DWORD   dwAlgID_MAC_Alg_KeySize = 0;

    //
    // If audit is turned on and the following vars are not set with the values
    // passed in, then the following would appear in the audit,
    // "Unknown 0x0 - 0"
    //

    dwEncrAlgID = 0;
    dwEncrAlgKeySize = 0;
    dwMACAlgID = 0;
    dwMACAlgKeySize = 0;


    wszMKGuidString[0] = 0;


    GetDefaultAlgInfo(&dwDefaultCryptProvType,
                      &dwAlgID_Encr_Alg,
                      &dwAlgID_Encr_Alg_KeySize,
                      &dwAlgID_MAC_Alg,
                      &dwAlgID_MAC_Alg_KeySize);

    ////////////////////////////////////////////////////////////////////
    // FYI: Data format
    // (    Version | guidMKid | dwFlags |
    //      cbDataDescr | szDataDescr |
    //
    //      dwEncrAlgID | dwEncrAlgKeySize |
    //      cbEncrKey | EncrKey |
    //      cbEncrSalt | EncrSalt |
    //
    //      dwMACAlgID | dwMACAlgKeySize |
    //      cbMACKey | MACKey |
    //
    //      cbEncrData | EncrData |
    //      cbMAC | MAC )
    //
    // NOTE: entire buffer from ProvHeader through EncrData is included in MAC
    ////////////////////////////////////////////////////////////////////

    // Check for minimum input buffer size.
    if(cbIn < sizeof(DWORD) +           // Version
              sizeof(GUID) +            // guidMKid
              sizeof(DWORD) +           // dwFlags
              sizeof(DWORD))            // cbDataDescr
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // version check
    if (*(DWORD UNALIGNED *)pbReadPtr != MS_BASE_CRYPTPROTECT_VERSION)
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // guidMKid
    CopyMemory(&guidMK, pbReadPtr, sizeof(GUID));
    pbReadPtr += sizeof(GUID);
    cbIn -= sizeof(GUID);

    MyGuidToStringW(&guidMK, wszMKGuidString);
    D_DebugLog((DEB_TRACE, "Master key GUID:%ls\n", wszMKGuidString));


    // dwFlags during protection
    dwProtectionFlags = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);
    D_DebugLog((DEB_TRACE, "Protection flags:0x%x\n", dwProtectionFlags));

    //
    // evaluate original CryptProtectData dwFlags to determine if
    // CRYPT_LOCAL_MACHINE set.
    //

    if( dwProtectionFlags & CRYPTPROTECT_LOCAL_MACHINE ) {
        BOOL fOverrideToLocalSystem = TRUE;

        CPSOverrideToLocalSystem(
                pvContext,
                &fOverrideToLocalSystem,
                NULL    // don't care what previous value was
                );
    }

    if((dwProtectionFlags ^ dwFlags) & CRYPTPROTECT_SYSTEM)
    {
        //
        // Attempted to use decrypt system data as a user, or user data
        // with the system flag
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }


    // cbDataDescr
    cbDataDescr = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // Check for minimum input buffer size.
    if(cbIn < cbDataDescr +             // szDataDescr
              sizeof(DWORD) +           // dwEncrAlgID
              sizeof(DWORD) +           // dwEncrAlgKeySize
              sizeof(DWORD))            // cbEncrKey
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // szDataDescr
    szDataDescr = (LPWSTR)pbReadPtr;
    pbReadPtr += cbDataDescr;
    cbIn -= cbDataDescr;
    D_DebugLog((DEB_TRACE, "Description:%ls\n", szDataDescr));

    // dwEncrAlgID
    dwEncrAlgID = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // dwEncrAlgKeySize
    dwEncrAlgKeySize = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);
    D_DebugLog((DEB_TRACE, "Encrypt alg:0x%x, Size:%d bits\n", dwEncrAlgID, dwEncrAlgKeySize));

    // cb Encr key
    cbEncrKeysize = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);
    if (cbEncrKeysize > sizeof(rgbEncrKey))
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // Check for minimum input buffer size.
    if(cbIn < cbEncrKeysize +           // EncrKey
              sizeof(DWORD))            // cbEncrSalt
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // Encr key
    CopyMemory(rgbEncrKey, pbReadPtr, cbEncrKeysize);
    pbReadPtr += cbEncrKeysize;
    cbIn -= cbEncrKeysize;

    // cb Encr salt
    cbEncrSalt = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // Check for minimum input buffer size.
    if(cbIn < cbEncrSalt +              // EncrSalt
              sizeof(DWORD) +           // dwMACAlgID
              sizeof(DWORD) +           // dwMACAlgKeySize
              sizeof(DWORD))            // cbMACKey
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // Encr salt
    pbEncrSalt = (PBYTE)SSAlloc(cbEncrSalt);
    if( pbEncrSalt == NULL ) {
        dwRet = ERROR_OUTOFMEMORY;
        goto Ret;
    }
    CopyMemory(pbEncrSalt, pbReadPtr, cbEncrSalt);
    pbReadPtr += cbEncrSalt;
    cbIn -= cbEncrSalt;

    // dwMACAlgID
    dwMACAlgID = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // dwMACAlgKeySize
    dwMACAlgKeySize = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    D_DebugLog((DEB_TRACE, "MAC alg:0x%x, Size:%d bits\n", dwMACAlgID, dwMACAlgKeySize));

    // MAC key size
    cbMACKeysize = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);
    if (cbMACKeysize > sizeof(rgbMACKey))
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // Check for minimum input buffer size.
    if(cbIn < cbMACKeysize)            // cbMACKey
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // MAC key
    CopyMemory(rgbMACKey, pbReadPtr, cbMACKeysize);
    pbReadPtr += cbMACKeysize;
    cbIn -= cbMACKeysize;

    if (NULL == (hVerifyProv =
        GetCryptProviderHandle(
            dwDefaultCryptProvType,
            dwEncrAlgID, &dwEncrAlgKeySize,
            dwMACAlgID, &dwMACAlgKeySize)) )
    {
        dwRet = (DWORD)GetLastError();
        goto Ret;
    }

    // USER GATING: when PROMPT_ON_UNPROTECT specified during CryptProtectData
    if ( CRYPTPROTECT_PROMPT_ON_UNPROTECT & dwProtectionFlags )
    {
        if (dwFlags & CRYPTPROTECT_UI_FORBIDDEN)
        {
            dwRet = ERROR_PASSWORD_RESTRICTION;
            goto Ret;
        }

        if (psPrompt == NULL)
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if (psPrompt->cbSize != sizeof(SSCRYPTPROTECTDATA_PROMPTSTRUCT))
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }

        if ((psPrompt->dwPromptFlags & ~(CRYPTPROTECT_PROMPT_ON_PROTECT |
                                         CRYPTPROTECT_PROMPT_ON_UNPROTECT | 
                                         CRYPTPROTECT_PROMPT_STRONG |
                                         CRYPTPROTECT_PROMPT_REQUIRE_STRONG) ) != 0)
        {
            dwRet = ERROR_INVALID_PARAMETER;
            goto Ret;
        }


// UI handled outside service until SAS support added.


    }


    dwRet = GetSpecifiedMasterKey(
                    pvContext,
                    &guidMK,
                    &pbMasterKey,
                    &cbMasterKey,
                    TRUE    // we do know what master key we want to use
                    );

    if(dwRet != ERROR_SUCCESS)
    {
        DWORD dwAccount = 0;

        DebugLog((DEB_ERROR, "Unable to get specified master key:%ls, error 0x%x\n",
            wszMKGuidString, dwRet));

        //
        // Is this call from one of the service accounts? If so, then attempt to 
        // obtain the master key using the legacy method.
        //

        CPSQueryWellKnownAccount(pvContext, &dwAccount);

        if((dwAccount == DP_ACCOUNT_LOCAL_SERVICE) || 
           (dwAccount == DP_ACCOUNT_NETWORK_SERVICE))
        {
            DebugLog((DEB_ERROR, "Attempt service account legacy method.\n"));

            CPSSetWellKnownAccount(pvContext, 0);

            dwRet = GetSpecifiedMasterKey(
                            pvContext,
                            &guidMK,
                            &pbMasterKey,
                            &cbMasterKey,
                            TRUE    // we do know what master key we want to use
                            );

            CPSSetWellKnownAccount(pvContext, dwAccount);

            if(dwRet != ERROR_SUCCESS)
            {
                DebugLog((DEB_ERROR, "Still unable to get specified master key:%ls, error 0x%x\n",
                    wszMKGuidString, dwRet));
                goto Ret;
            }
            else
            {
                DebugLog((DEB_ERROR, "Master key successfully obtained using legacy method.\n"));
            }
        }
        else
        {
            goto Ret;
        }
    }

    //
    // hash pbMasterKey to get rgbPwdBuf
    //

    FMyPrimitiveSHA( pbMasterKey, cbMasterKey, rgbPwdBuf);


    // derive encr key
    {
        if (!FMyPrimitiveCryptHMAC(
                    rgbPwdBuf,
                    sizeof(rgbPwdBuf),
                    rgbEncrKey,
                    cbEncrKeysize,
                    hVerifyProv,
                    ALGID_DERIVEKEY_HASH,
                    &hHash))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // add password if exists
        if (NULL != pbOptionalEntropy)
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalEntropy,
                    cbOptionalEntropy,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }
        }

        // add prompted UI based password if exists.
        // will eventually come from SAS
        //

        if ( NULL != pbOptionalPassword && cbOptionalPassword )
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalPassword,
                    cbOptionalPassword,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }
        }

        if (!CryptDeriveKey(
                hVerifyProv,
                dwEncrAlgID,
                hHash,
                ((dwEncrAlgKeySize << 16) | CRYPT_CREATE_SALT),
                &hKey))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        CryptDestroyHash(hHash);
        hHash = 0;

        // USEC -- (US Export Controls)
        if (ERROR_SUCCESS != (dwRet =
            SetSaltForExportControl(
                hKey,
                pbEncrSalt,
                cbEncrSalt)) )
            goto Ret;
    }

    // derive MAC key
    {
        if (!FMyPrimitiveCryptHMAC(
                    rgbPwdBuf,
                    sizeof(rgbPwdBuf),
                    rgbMACKey,
                    cbMACKeysize,
                    hVerifyProv,
                    dwMACAlgID,
                    &hHash))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // add password if exists
        if (NULL != pbOptionalEntropy)
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalEntropy,
                    cbOptionalEntropy,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }
        }

        // add prompted UI based password if exists.
        // will eventually come from SAS
        //

        if ( NULL != pbOptionalPassword && cbOptionalPassword )
        {
            if (!CryptHashData(
                    hHash,
                    pbOptionalPassword,
                    cbOptionalPassword,
                    0))
            {
                dwRet = GetLastError();
                goto Ret;
            }

        }

        // USEC -- (US Export Controls)
        // does not apply -- use strong key
    }

    // Check for minimum input buffer size.
    if(cbIn < sizeof(DWORD))            // cbEncrData
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // get encr size
    cbEncr = *(DWORD UNALIGNED *)pbReadPtr;
    pbReadPtr += sizeof(DWORD);
    cbIn -= sizeof(DWORD);

    // Check for minimum input buffer size.
    if(cbIn < cbEncr +                  // EncrData
              sizeof(DWORD) +           // cbMAC
              A_SHA_DIGEST_LEN)         // MAC
    {
        dwRet = ERROR_INVALID_DATA;
        goto Ret;
    }

    // dansimon recommends that MAC be on encrypted data, such that the
    // MAC has no possibility of revealing info about the plaintext.

    // MAC is from start thru encrypted data
    if (!CryptHashData(
            hHash,
            pbIn,
            (DWORD) ((pbReadPtr - pbIn) + cbEncr),
            0))
    {
        dwRet = GetLastError();
        goto Ret;
    }

    cbPlaintext = cbEncr;

    if ((dwProtectionFlags & CRYPTPROTECT_NO_ENCRYPTION) == 0)
    {
        if (!CryptDecrypt(
                hKey,
                NULL,   // hHash mattt 9/12/97
                TRUE,
                0,
                pbReadPtr,
                &cbPlaintext))
        {
            dwRet = GetLastError();
            if(NTE_BAD_DATA == dwRet)
			{
                dwRet = ERROR_INVALID_DATA;
			}
            goto Ret;
        }
    }

    {
        BYTE        rgbComputedMAC[A_SHA_DIGEST_LEN];
        // use MACPtr to skip past decr data,
        PBYTE       pbMACPtr = pbReadPtr + cbEncr;
        DWORD       cbMACsize = A_SHA_DIGEST_LEN;

        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                rgbComputedMAC,
                &cbMACsize,
                0))
        {
            dwRet = GetLastError();
            goto Ret;
        }

        // chk MAC size
        if (*(DWORD UNALIGNED *)pbMACPtr != cbMACsize)
        {
            dwRet = ERROR_INVALID_DATA;
            goto Ret;
        }
        pbMACPtr += sizeof(DWORD);

        // chk MAC
        if (0 != memcmp(pbMACPtr, rgbComputedMAC, cbMACsize) )
        {
            dwRet = ERROR_INVALID_DATA;
            goto Ret;
        }
    }


    //
    // Write data out, encrypted so that rpc doesn't leave copies
    // laying around in plaintext.
    //

    *pcbOut = cbPlaintext;

    if((dwFlags & CRYPTPROTECT_IN_PROCESS) == 0)
    {
        DWORD cbPadding;
        NTSTATUS Status;

        cbPadding = RTL_ENCRYPT_MEMORY_SIZE - (*pcbOut) % RTL_ENCRYPT_MEMORY_SIZE;
        if(cbPadding == 0)
        {
            cbPadding += RTL_ENCRYPT_MEMORY_SIZE;
        }

        *ppbOut = (PBYTE)SSAlloc(*pcbOut + cbPadding);
        if(*ppbOut == NULL)
        {
            *pcbOut = 0;
            dwRet = ERROR_OUTOFMEMORY;
            goto Ret;
        }
        CopyMemory(*ppbOut, pbReadPtr, *pcbOut);
        FillMemory((*ppbOut) + (*pcbOut), cbPadding, (BYTE)cbPadding);
        *pcbOut += cbPadding;

        dwRet = RpcImpersonateClient(((PCRYPT_SERVER_CONTEXT)pvContext)->hBinding);
        if( dwRet != ERROR_SUCCESS )
        {
            SSFree(*ppbOut);
            *ppbOut = NULL;
            *pcbOut = 0;
            goto Ret;
        }

        Status = RtlEncryptMemory(*ppbOut,
                                  *pcbOut,
                                  RTL_ENCRYPT_OPTION_SAME_LOGON);

        RevertToSelf();

        if(!NT_SUCCESS(Status))
        {
            SSFree(*ppbOut);
            *ppbOut = NULL;
            *pcbOut = 0;
            dwRet = RtlNtStatusToDosError(Status);
            goto Ret;
        }
    }
    else
    {
        // We're in-process, so don't bother encrypting output buffer.
        *ppbOut = (PBYTE)SSAlloc(*pcbOut);
        if(*ppbOut == NULL)
        {
            *pcbOut = 0;
            dwRet = ERROR_OUTOFMEMORY;
            goto Ret;
        }
        CopyMemory(*ppbOut, pbReadPtr, *pcbOut);
    }


    // optional: caller may want data descr
    if (ppszDataDescr)
    {
        *ppszDataDescr = (LPWSTR)SSAlloc(cbDataDescr);
        if(*ppszDataDescr == NULL)
        {
            SSFree(*ppbOut);
            *ppbOut = NULL;
            *pcbOut = 0;

            dwRet = ERROR_OUTOFMEMORY;
            goto Ret;
        }
        CopyMemory(*ppszDataDescr, szDataDescr, cbDataDescr);
    }

    dwRet = ERROR_SUCCESS;

    if(dwFlags &  CRYPTPROTECT_VERIFY_PROTECTION )
    {
        HCRYPTPROV hTestProv =  GetCryptProviderHandle( dwDefaultCryptProvType,
                                dwAlgID_Encr_Alg, &dwAlgID_Encr_Alg_KeySize,
                                dwAlgID_MAC_Alg, &dwAlgID_MAC_Alg_KeySize);

        if(hTestProv)
        {

            // Verify encryption strengths
            // Never downgrade encryption strength, just check if we need
            // to upgrade
            if((dwAlgID_Encr_Alg_KeySize > dwEncrAlgKeySize) ||
               (dwAlgID_MAC_Alg_KeySize > dwMACAlgKeySize))
            {
                dwRet = CRYPT_I_NEW_PROTECTION_REQUIRED;
            }
        }
    }
    

Ret:
    if((dwProtectionFlags & CRYPTPROTECT_AUDIT) ||
        (ERROR_SUCCESS != dwRet))
    {

        DWORD dwAuditRet = dwRet;
        WCHAR wszCryptoAlgs[2*MAX_STRING_ALGID_LENGTH + 2];
        DWORD i;
        PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;


        i = AlgIDToString(wszCryptoAlgs, dwEncrAlgID, dwEncrAlgKeySize);
        wszCryptoAlgs[i++]= L',';
        wszCryptoAlgs[i++]= L' ';
        AlgIDToString(&wszCryptoAlgs[i], dwMACAlgID, dwMACAlgKeySize);

        if(CRYPT_I_NEW_PROTECTION_REQUIRED == dwAuditRet)
        {
            dwAuditRet = ERROR_SUCCESS;
        }

        CPSAudit(pServerContext->hToken,
                SE_AUDITID_DPAPI_UNPROTECT,
                wszMKGuidString,            // Key Identifier
                szDataDescr,                // Data Description
                0,                          // Protected Data Flags
                wszCryptoAlgs,              // Protection Algorithms
                dwAuditRet);                // Failure Reason


    }

    RtlSecureZeroMemory(rgbPwdBuf, sizeof(rgbPwdBuf));
    RtlSecureZeroMemory(rgbEncrKey, sizeof(rgbEncrKey));

    if(pbMasterKey) {
        RtlSecureZeroMemory(pbMasterKey, cbMasterKey);
        SSFree(pbMasterKey);
    }

    if (hKey)
        CryptDestroyKey(hKey);

    if (hHash)
        CryptDestroyHash(hHash);

    if (pbEncrSalt)
        SSFree(pbEncrSalt);

    D_DebugLog((DEB_TRACE_API, "SPCryptUnprotect returned 0x%x\n", dwRet));

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\keybckup.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    keybckup.cpp

Abstract:

    This module contains routines associated with client side Key Backup
    operations.

Author:

    Scott Field (sfield)    16-Sep-97

--*/
#include <pch.cpp>
#pragma hdrstop

extern "C" {
#include <dsgetdc.h>
#include <msaudite.h>
}

#define DPAPI_SERVICE_NAME L"ProtectedStorage"

typedef struct _WZR_RPC_BINDING_LIST
{
    LPCWSTR pszProtSeq;
    LPCWSTR pszEndpoint;
} WZR_RPC_BINDING_LIST;

WZR_RPC_BINDING_LIST g_awzrBackupBindingList[] =
{
    { DPAPI_LOCAL_PROT_SEQ, DPAPI_LOCAL_ENDPOINT },
    { DPAPI_BACKUP_PROT_SEQ, DPAPI_BACKUP_ENDPOINT},
    { DPAPI_LEGACY_BACKUP_PROT_SEQ,   DPAPI_LEGACY_BACKUP_ENDPOINT}
};

DWORD g_cwzrBackupBindingList = sizeof(g_awzrBackupBindingList)/sizeof(g_awzrBackupBindingList[0]);





DWORD
WINAPI
CPSGetDomainControllerName(
    IN  OUT LPWSTR wszDomainControllerName,
    IN  OUT DWORD *pcchDomainControllerName,
    IN      BOOL   fRediscover
    );

BOOL
GetDomainControllerNameByToken(
    IN      HANDLE hToken,
    IN  OUT LPWSTR wszDomainControllerName,
    IN  OUT PDWORD pcchDomainControllerName,
    IN      BOOL   fRediscover
    );



static const GUID guidRetrieve = BACKUPKEY_RETRIEVE_BACKUP_KEY_GUID;
static const GUID guidRestore = BACKUPKEY_RESTORE_GUID;
static const GUID guidRestoreW2K = BACKUPKEY_RESTORE_GUID_W2K;
static const GUID guidBackup = BACKUPKEY_BACKUP_GUID;

DWORD
BackupRestoreData(
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      PBYTE pbDataIn,
    IN      DWORD cbDataIn,
        OUT PBYTE *ppbDataOut,
        OUT DWORD *pcbDataOut,
    IN      BOOL  fBackup
    )
{
    return LocalBackupRestoreData(hToken,
                                  phMasterKey,
                                  pbDataIn,
                                  cbDataIn,
                                  ppbDataOut, 
                                  pcbDataOut,
                                  fBackup?&guidBackup:&guidRestore);
}


//+---------------------------------------------------------------------------
//
//  Function:   LocalBackupRestoreData
//
//  Synopsis:   Connect to the user's DC and perform a master key backup or 
//              recovery operation.
//
//  Arguments:  [hToken]        -- Handle to user token. This is used when
//                                 generating audits.
//
//              [phMasterKey]   -- Master key that we're operating on.
//
//              [pbDataIn]      -- Input buffer. Only used for recovery
//              [cbDataIn]      -- operations.
//
//              [ppbDataOut]    -- Output buffer.
//              [pcbDataOut]    --
//
//              [pguidAction]   -- GUID describing operation to perform.
//
//  Returns:    ERROR_SUCCESS if the operation was successful, a Windows
//              error code otherwise.
//
//  History:    
//
//  Notes:      The caller of this function MUST be impersonating a client 
//              user.
//
//----------------------------------------------------------------------------
DWORD
LocalBackupRestoreData(
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED   phMasterKey,
    IN      PBYTE               pbDataIn,
    IN      DWORD               cbDataIn,
        OUT PBYTE               *ppbDataOut,
        OUT DWORD               *pcbDataOut,
    IN      const GUID          *pguidAction
    )
{
    WCHAR FastBuffer[ 256 ];
    LPWSTR SlowBuffer = NULL;
    LPWSTR pszAuditComputerName = NULL;
    LPWSTR pszComputerName;
    DWORD cchComputerName;


    static DWORD dwLastFailTickCount; // time for failure on last access
    static LUID luidLastFailAuthId; // LUID associated with failed network

    DWORD dwCandidateTickCount;
    LUID luidCandidateAuthId; // LUID associated with client security context.

    BOOL fRediscoverDC = FALSE;
    DWORD dwLastError = ERROR_NETWORK_BUSY;
    
    D_DebugLog((DEB_TRACE_API, "LocalBackupRestoreData\n"));


    //
    // impersonate the user, so we may
    // 1. check the authentication ID to see if we've failed to hit the
    //    net as this user.
    // 2. determine a domain controller computer name associated with
    //    the user.
    // 3. backup or restore the requested material on behalf of the user.
    //

    if(!GetThreadAuthenticationId( GetCurrentThread(), &luidCandidateAuthId ))
        return ERROR_NO_TOKEN;

    //
    // now, see if the network was previously unavailable (recently)
    // for this user.
    //

    dwCandidateTickCount = GetTickCount();

    if(memcmp(&luidCandidateAuthId, &luidLastFailAuthId, sizeof(LUID)) == 0) {
        if( (dwLastFailTickCount + (5*1000*60)) > dwCandidateTickCount ) {
            //BUGBUG: return ERROR_NETWORK_BUSY;
        }
    }

    //
    // we got far enough along that we update the failed network cache
    // if something goes wrong from here.
    //

network_call:

    //
    // get domain controller computer name associated with current
    // security context.
    // Try with fast static buffer first, fallback on dynamically allocated
    // buffer if not large enough.
    //

    pszComputerName = FastBuffer;
    cchComputerName = sizeof(FastBuffer) / sizeof( WCHAR );

    dwLastError = CPSGetDomainControllerName(
                        pszComputerName,
                        &cchComputerName,
                        fRediscoverDC
                        );

    if( dwLastError != ERROR_SUCCESS  && (cchComputerName > (sizeof(FastBuffer) / sizeof(WCHAR) ))) {

        SlowBuffer = (LPWSTR) SSAlloc( cchComputerName * sizeof(WCHAR) );
        if( SlowBuffer ) {
            pszComputerName = SlowBuffer;

            dwLastError = CPSGetDomainControllerName(
                                pszComputerName,
                                &cchComputerName,
                                fRediscoverDC
                                );
        }

    }


    if( dwLastError == ERROR_SUCCESS ) {

        LPWSTR pszTargetMachine = pszComputerName;

        pszAuditComputerName = pszComputerName;


        // HACKHACK workaround picky RPC/Kerberos name format behavior that
        // would otherwise prevent Kerberos from being used.
        if( pszTargetMachine[ 0 ] == L'\\' && pszTargetMachine[ 1 ] == L'\\' )
            pszTargetMachine += 2;


        dwLastError = BackupKey(
                            pszTargetMachine,   // target computer.
                            pguidAction,
                            pbDataIn,
                            cbDataIn,
                            ppbDataOut,
                            pcbDataOut,
                            0
                            );

    }


    //
    // Audit success or failure
    //
    
    if((memcmp(pguidAction, &guidRestore, sizeof(GUID)) == 0) ||
        (memcmp(pguidAction, &guidRestoreW2K, sizeof(GUID)) == 0))
    {

        // Grab the recovery key id
        WCHAR wszBackupkeyGuid[MAX_GUID_SZ_CHARS];

        PBACKUPKEY_RECOVERY_BLOB pBackupBlob = (PBACKUPKEY_RECOVERY_BLOB)phMasterKey->pbBBK;
        wszBackupkeyGuid[0] = 0;

        if((pBackupBlob) && (phMasterKey->cbBBK > sizeof(BACKUPKEY_RECOVERY_BLOB)))
        {
            MyGuidToStringW(&pBackupBlob->guidKey, wszBackupkeyGuid);
        }


        CPSAudit(hToken,
                SE_AUDITID_DPAPI_RECOVERY,
                phMasterKey->wszguidMasterKey,      // Key Identifier
                pszAuditComputerName,               // Recovery Server
                0,                                  // Recovery Reason
                wszBackupkeyGuid,                   // Recovery Key ID
                dwLastError);                       // Failure Reason
    }
    else if(memcmp(pguidAction, &guidBackup, sizeof(GUID)) == 0)
    {
        // Attempting a remote backup

        // Grab the recovery key id 

        WCHAR wszBackupkeyGuid[MAX_GUID_SZ_CHARS];
        PBACKUPKEY_RECOVERY_BLOB pBackupBlob = (PBACKUPKEY_RECOVERY_BLOB)*ppbDataOut;
        wszBackupkeyGuid[0] = 0;

        if(( dwLastError == ERROR_SUCCESS ) &&
            (pBackupBlob) && 
            (*pcbDataOut > sizeof(BACKUPKEY_RECOVERY_BLOB)))
        {
            MyGuidToStringW(&pBackupBlob->guidKey, wszBackupkeyGuid);
        }

        CPSAudit(hToken,                                           
                SE_AUDITID_DPAPI_BACKUP,
                phMasterKey->wszguidMasterKey,      // Key Identifier
                pszAuditComputerName,               // Recovery Server
                0,
                wszBackupkeyGuid,                   // Recovery Key ID
                dwLastError);                       // Failure Reason
    }


    if( SlowBuffer ) {
        SSFree( SlowBuffer );
        SlowBuffer = NULL;
    }

    //
    // common failure path is ERROR_ACCESS_DENIED for delegation scenarios
    // where target machine isn't trusted for delegation.
    // don't bother retry for this case.
    //

    if( dwLastError != ERROR_SUCCESS && dwLastError != ERROR_ACCESS_DENIED ) {


        //
        // if it failed, try once again and force DC re-discovery.
        //

        if( !fRediscoverDC ) {
            fRediscoverDC = TRUE;
            goto network_call;
        }

        //
        // one of the network operations failed, so update the
        // last failure variables so that we don't bang the network
        // over-and-over.
        //

        dwLastFailTickCount = dwCandidateTickCount;
        CopyMemory( &luidLastFailAuthId, &luidCandidateAuthId, sizeof(LUID));
    }

    D_DebugLog((DEB_TRACE_API, "LocalBackupRestoreData returned 0x%x\n", dwLastError));

    return dwLastError;
}




BOOL
GetDomainControllerNameByToken(
    IN      HANDLE hToken,
    IN  OUT LPWSTR wszDomainControllerName,
    IN  OUT PDWORD pcchDomainControllerName,
    IN      BOOL   fRediscover
    )
/*++

    This routine obtains a domain controller computer name associated with
    the account related to the hToken access token.

    hToken should be opened for TOKEN_QUERY access.
    wszDomainControllerName should be of size (UNCLEN+1)

--*/
{
    PSID pSidUser = NULL;   // sid of client user.
    WCHAR szUserName[ UNLEN + 1 ];
    DWORD cchUserName = sizeof(szUserName) / sizeof(WCHAR);

    WCHAR szDomainName[ DNLEN + 1]; // domain we want a controller for.
    DWORD cchDomainName = sizeof(szDomainName) / sizeof(WCHAR);
    SID_NAME_USE snu;

    PDOMAIN_CONTROLLER_INFOW pDomainInfo = NULL;
    LPWSTR wszQueryResult = NULL;

    NET_API_STATUS nas;
    DWORD dwGetDcFlags = 0;

    BOOL fSuccess = FALSE;

    if(wszDomainControllerName == NULL || pcchDomainControllerName == NULL)
        return FALSE;

    //
    // first, get the sid of the user associated with the specified access
    // token.
    //

    if(!GetTokenUserSid(hToken, &pSidUser))
        return FALSE;

    //
    // next, lookup the domain name associated with the specified account.
    //

    if(!LookupAccountSidW(
            NULL,
            pSidUser,
            szUserName,
            &cchUserName,
            szDomainName,
            &cchDomainName,
            &snu
            )) {

        SSFree(pSidUser);
        return FALSE;
    }


    if( fRediscover )
        dwGetDcFlags |= DS_FORCE_REDISCOVERY;

    nas = DsGetDcNameW(
                NULL,
                szDomainName,
                NULL,
                NULL,
                DS_DIRECTORY_SERVICE_REQUIRED | // make sure backend is NT5
                DS_IS_FLAT_NAME |
                DS_RETURN_DNS_NAME |
                dwGetDcFlags,
                &pDomainInfo
                );

    if( nas == ERROR_SUCCESS )
        wszQueryResult = pDomainInfo->DomainControllerName;

    //
    // if we made a successful query, copy it for the caller and indicate
    // success if appropriate.
    //

    if(wszQueryResult) {
        DWORD cchQueryResult = lstrlenW( wszQueryResult ) + 1;

        if( *pcchDomainControllerName >= cchQueryResult ) {
            CopyMemory(wszDomainControllerName, wszQueryResult, cchQueryResult * sizeof(WCHAR));
            fSuccess = TRUE;
        }

        *pcchDomainControllerName = cchQueryResult;
    }


    if(pDomainInfo)
        NetApiBufferFree(pDomainInfo);

    if(pSidUser)
        SSFree(pSidUser);

    return fSuccess;
}


DWORD
WINAPI
CPSGetDomainControllerName(
    IN  OUT LPWSTR wszDomainControllerName,
    IN  OUT DWORD *pcchDomainControllerName,
    IN      BOOL   fRediscover
    )
/*++

    This routine collects a domain controller computer name associated
    with the current impersonated user (if one is being impersonated), or
    the user associated with the pvContext outstanding client call if the
    thread is not already impersonating a client.

--*/
{
    HANDLE hToken = NULL;
    DWORD dwLastError;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken)) {
        return GetLastError();
    }

    if(!GetDomainControllerNameByToken(
                        hToken,
                        wszDomainControllerName,
                        pcchDomainControllerName,
                        fRediscover
                        )) {

        dwLastError = ERROR_BAD_NET_RESP;
        goto cleanup;
    }

    dwLastError = ERROR_SUCCESS;

cleanup:

    if(hToken)
        CloseHandle(hToken);

    return dwLastError;
}


#define BACKUP_KEY_PREFIX L"BK-"
#define BACKUP_KEY_PREFIX_LEN 3

#define BACKUP_PUBLIC_VERSION 1

typedef struct _BACKUP_PUBLIC_KEY
{
    DWORD dwVersion;
    DWORD cbPublic;
    DWORD cbSignature;
} BACKUP_PUBLIC_KEY, *PBACKUP_PUBLIC_KEY;


//+---------------------------------------------------------------------------
//
//  Function:   RetrieveBackupPublicKeyFromStorage
//
//  Synopsis:   Read in the domain backup public key from user profile.
//
//  Arguments:  [hToken]        -- Handle to user token. 
//
//              [pSidUser]      -- Pointer to user SID.
//
//              [pszFilePath]   -- Path to DPAPI user storage directory.
//                                 This is typically of the form: 
//                                 %userprofile%\Application Data\Microsoft\
//                                 Protect\<user SID>.
//
//              [ppbDataOut]    -- Output buffer. 
//              [pcbDataOut]
//
//  Returns:    ERROR_SUCCESS if the operation was successful, a Windows
//              error code otherwise.
//
//  History:    
//
//  Notes:      When this function completes successfully, the caller is
//              responsible for freeing the output buffer, via a call to
//              the SSFree function.
//
//----------------------------------------------------------------------------
DWORD
RetrieveBackupPublicKeyFromStorage(
    IN     HANDLE hToken, 
    IN     PSID pSidUser,
    IN     LPWSTR pszFilePath,
       OUT PBYTE *ppbDataOut,
       OUT DWORD *pcbDataOut)
{
    DWORD dwLastError = ERROR_SUCCESS;
    WCHAR szUserName[ UNLEN + 1 ];
    DWORD cchUserName = sizeof(szUserName) / sizeof(WCHAR);

    WCHAR szDomainName[ BACKUP_KEY_PREFIX_LEN + DNLEN +1]; // domain we want a controller for.
    DWORD cchDomainName = sizeof(szDomainName) / sizeof(WCHAR);

    HANDLE hFile = NULL;
    HANDLE hMap = NULL;
    PBACKUP_PUBLIC_KEY pBackupPublic = NULL;

    DWORD dwFileSizeLow;
    SID_NAME_USE snu;


    //
    // Lookup the domain name associated with the specified account, and use
    // it to generate the filename, which will be of the form: BK-<domain>.
    //

    wcscpy(szDomainName, BACKUP_KEY_PREFIX);

    cchDomainName -= BACKUP_KEY_PREFIX_LEN;

    if(!LookupAccountSidW(
            NULL,
            pSidUser,
            szUserName,
            &cchUserName,
            szDomainName + BACKUP_KEY_PREFIX_LEN,
            &cchDomainName,
            &snu)) 
    {
        return GetLastError();
    }

    cchDomainName += BACKUP_KEY_PREFIX_LEN;


    //
    // Impersonate the user.
    //

    if(hToken)
    {
        if(!SetThreadToken(NULL, hToken))
        {
            return GetLastError();
        }
    }


    //
    // Attempt open the file.
    //

    dwLastError = OpenFileInStorageArea(
                    NULL,
                    GENERIC_READ,
                    pszFilePath,
                    szDomainName,
                    &hFile
                    );

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }

    dwFileSizeLow = GetFileSize( hFile, NULL );
    if(dwFileSizeLow == INVALID_FILE_SIZE )
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    __try
    {
        hMap = CreateFileMappingU(
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );
    
        if(NULL == hMap)
        {
            dwLastError = GetLastError();
            goto error;
        }
    
    
    
        pBackupPublic = (PBACKUP_PUBLIC_KEY)MapViewOfFile( hMap, FILE_MAP_READ, 0, 0, 0 );
    
        if(NULL == pBackupPublic)
        {
            dwLastError = GetLastError();
            goto error;
        }
    
        if((pBackupPublic->dwVersion != BACKUP_PUBLIC_VERSION) ||
           (dwFileSizeLow < sizeof(BACKUP_PUBLIC_KEY) + pBackupPublic->cbPublic + pBackupPublic->cbSignature))
        {
            dwLastError = ERROR_INVALID_DATA;
            goto error;
        }
    
    
        //
        // Verify the signature
        //
    
        dwLastError = LogonCredVerifySignature( NULL,
                                                (PBYTE)(pBackupPublic + 1) + pBackupPublic->cbSignature,
                                                pBackupPublic->cbPublic,
                                                NULL,
                                                (PBYTE)(pBackupPublic + 1),
                                                pBackupPublic->cbSignature);
        if(ERROR_SUCCESS != dwLastError)
        {
            goto error;
        }
    
    
        *ppbDataOut = (PBYTE)SSAlloc(pBackupPublic->cbPublic);
        if(NULL == ppbDataOut)
        {
            dwLastError = STATUS_OBJECT_NAME_NOT_FOUND;
            goto error;
        }
    
        CopyMemory(*ppbDataOut, 
                   (PBYTE)(pBackupPublic + 1) + pBackupPublic->cbSignature, 
                   pBackupPublic->cbPublic);
        *pcbDataOut = pBackupPublic->cbPublic;

    } __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        dwLastError = GetExceptionCode();
    }

error:


    if(pBackupPublic)
    {
        UnmapViewOfFile(pBackupPublic);
    }

    if(hMap)
    {
        CloseHandle(hMap);
    }

    if(hFile)
    {
        CloseHandle(hFile);
    }

    if(hToken)
    {
        RevertToSelf();
    }

    return dwLastError;
}

DWORD
WriteBackupPublicKeyToStorage(
    IN HANDLE hToken, 
    IN PSID pSidUser,
    IN LPWSTR wszFilePath,
    IN PBYTE pbData,
    IN DWORD cbData)
{
    DWORD dwLastError = ERROR_SUCCESS;
    WCHAR szUserName[ UNLEN + 1 ];
    DWORD cchUserName = sizeof(szUserName) / sizeof(WCHAR);

    WCHAR szDomainName[ BACKUP_KEY_PREFIX_LEN + DNLEN +1]; // domain we want a controller for.
    DWORD cchDomainName = sizeof(szDomainName) / sizeof(WCHAR);

    HANDLE hFile = NULL;
    HANDLE hMap = NULL;
    PBACKUP_PUBLIC_KEY pBackupPublic = NULL;

    DWORD dwFileSizeLow;
    SID_NAME_USE snu;
    PBYTE pbSignature = NULL;
    DWORD cbSignature;

 
    //
    // Lookup the domain name associated with the specified account, and use
    // it to generate the filename, which will be of the form: BK-<domain>.
    //

    wcscpy(szDomainName, BACKUP_KEY_PREFIX);

    cchDomainName -= BACKUP_KEY_PREFIX_LEN;

    if(!LookupAccountSidW(
            NULL,
            pSidUser,
            szUserName,
            &cchUserName,
            szDomainName + BACKUP_KEY_PREFIX_LEN,
            &cchDomainName,
            &snu)) 
    {
        return GetLastError();
    }

    cchDomainName += BACKUP_KEY_PREFIX_LEN;


    //
    // Impersonate the user.
    //

    if(hToken)
    {
        if(!SetThreadToken(NULL, hToken))
        {
            return GetLastError();
        }
    }


    //
    // Sign the public key, so that it can't be
    // spoofed.
    //

    dwLastError = LogonCredGenerateSignature(
                                            hToken,
                                            pbData,
                                            cbData,
                                            NULL,
                                            &pbSignature,
                                            &cbSignature);
    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }


    //
    // Write the public key data and signature out to disk.
    //

    dwFileSizeLow = sizeof(BACKUP_PUBLIC_KEY) + cbData + cbSignature;

    dwLastError = OpenFileInStorageArea(
                    NULL,
                    GENERIC_READ | GENERIC_WRITE,
                    wszFilePath,
                    szDomainName,
                    &hFile
                    );

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }

    __try
    {
        hMap = CreateFileMappingU(
                        hFile,
                        NULL,
                        PAGE_READWRITE,
                        0,
                        dwFileSizeLow,
                        NULL
                        );
    
        if(NULL == hMap)
        {
            dwLastError = GetLastError();
            goto error;
        }
    
    
        pBackupPublic = (PBACKUP_PUBLIC_KEY)MapViewOfFile( hMap, FILE_MAP_WRITE , 0, 0, dwFileSizeLow );
    
        if(NULL == pBackupPublic)
        {
            dwLastError = GetLastError();
            goto error;
        }
    
        pBackupPublic->dwVersion = BACKUP_PUBLIC_VERSION;
    
        pBackupPublic->cbSignature = cbSignature;
    
        pBackupPublic->cbPublic = cbData;
    
        CopyMemory((PBYTE)(pBackupPublic+1), pbSignature, cbSignature);
    
    
        CopyMemory((PBYTE)(pBackupPublic+1) + cbSignature, pbData, cbData);

    } __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        dwLastError = GetExceptionCode();
    }

error:


    if(pBackupPublic)
    {
        UnmapViewOfFile(pBackupPublic);
    }

    if(hMap)
    {
        CloseHandle(hMap);
    }

    if(hFile)
    {
        CloseHandle(hFile);
    }
    if(pbSignature)
    {
        SSFree(pbSignature);
    }
    if(hToken)
    {
        RevertToSelf();
    }

    return dwLastError;
}



//+---------------------------------------------------------------------------
//
//  Function:   AttemptLocalBackup
//
//  Synopsis:   Backup the specified master key using a domain public key.
//              Only connect to the DC if the fRetrieve parameter is set 
//              to TRUE.
//
//  Arguments:  [fRetrieve]   -- Whether to retrieve the domain public key
//                               from the DC before performing the backup.
//
//              [hToken]      -- Handle to user token.
//
//              [phMasterKey] -- Pointer to master key structure. This is
//                               used when obtaining the path to the user 
//                               data directory and also for auditing.
//
//              [pbMasterKey] -- Plaintext master key to backup.
//              [cbMasterKey]
//
//              [pbLocalKey]  -- Plaintext local key to backup. BUGBUG - It's
//              [cbLocalKey]     still a bit of a mystery as to what this
//                               field is used for, given that this is a 
//                               domain user account.
//
//              [ppbBBK]      -- Output buffer.
//              [pcbBBK]
//
//  Returns:    ERROR_SUCCESS if the operation was successful, a Windows
//              error code otherwise.
//
//  History:    
//
//  Notes:      When this function completes successfully, the caller is
//              responsible for freeing the output buffer, via a call to
//              the SSFree function.
//
//----------------------------------------------------------------------------
DWORD
AttemptLocalBackup(
    IN      BOOL                fRetrieve,
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED   phMasterKey,
    IN      PBYTE               pbMasterKey,
    IN      DWORD               cbMasterKey,
    IN      PBYTE               pbLocalKey,
    IN      DWORD               cbLocalKey,
        OUT PBYTE *             ppbBBK,
        OUT DWORD *             pcbBBK)
{

    DWORD dwLastError = ERROR_SUCCESS;
    PCCERT_CONTEXT  pPublic = NULL;
    PBYTE          pbPublic = NULL;
    DWORD          cbPublic = 0;

    HCRYPTPROV     hProv = NULL;
    HCRYPTKEY      hPublicKey = NULL;

    PBYTE                    pbPayloadKey = NULL;;

    PBACKUPKEY_KEY_BLOB     pKeyBlob = NULL;
    DWORD                   cbKeyBlobData = 0;
    DWORD                   cbKeyBlob = 0;


    PBACKUPKEY_INNER_BLOB   pInnerBlob = NULL;
    DWORD                   cbInnerBlob = 0;
    DWORD                   cbInnerBlobData = 0;
    PBYTE                   pbData = NULL;

    DWORD                   cbTemp = 0;


    PBACKUPKEY_RECOVERY_BLOB pOuterBlob = NULL;
    DWORD                   cbOuterBlob = 0;

    PSID pSidUser = NULL;   // sid of client user.

    DWORD  cbSid = 0;

    WCHAR                   wszBackupKeyID[MAX_GUID_SZ_CHARS];
    BYTE                    rgbThumbprint[A_SHA_DIGEST_LEN];
    DWORD                   cbThumbprint;

    wszBackupKeyID[0] = 0;


    if(!GetTokenUserSid(hToken, &pSidUser))
    {
        dwLastError = GetLastError();
        goto error;
    }

    if(fRetrieve)
    {

        // Attempt to retrieve the public from 
        // the DC.

        //
        // We impersonate when we do this
        //

        if (!SetThreadToken(NULL, hToken))
        {
            dwLastError = GetLastError();
            goto error;
        }

        dwLastError = LocalBackupRestoreData(hToken, 
                                             phMasterKey, 
                                             pbMasterKey,
                                             0,
                                             &pbPublic,
                                             &cbPublic,
                                             &guidRetrieve);

        // 
        // Revert back to ourself
        //

        if (!SetThreadToken(NULL, NULL))
        {
            if (ERROR_SUCCESS == dwLastError) 
            {
                dwLastError = GetLastError();
                goto error;
            }
        }


    }
    else
    {
        //
        // We're attempting a backup, so first see if we have a local copy of
        // the public.
        //
    
        dwLastError = RetrieveBackupPublicKeyFromStorage(hToken,
                                                         pSidUser,
                                                         phMasterKey->szFilePath,
                                                        &pbPublic,
                                                        &cbPublic);
    }

    if(ERROR_SUCCESS == dwLastError)
    {
        pPublic = CertCreateCertificateContext(X509_ASN_ENCODING,
                                     pbPublic,
                                     cbPublic);
        if(NULL == pPublic)
        {
            dwLastError = GetLastError();
        }
    }


    if(dwLastError != ERROR_SUCCESS)
    {
        goto error;
    }



    if(sizeof(GUID) == pPublic->pCertInfo->SerialNumber.cbData)
    {
        MyGuidToStringW((GUID *)pPublic->pCertInfo->SerialNumber.pbData, wszBackupKeyID);
    }

    



    if(fRetrieve)
    {
        // Writing the public key to disk is not critical, 
        // so we don't need to check for an error return.
        WriteBackupPublicKeyToStorage(hToken,
                                      pSidUser,
                                      phMasterKey->szFilePath,
                                      pbPublic,
                                      cbPublic);
    }

    if(!CryptAcquireContext(&hProv, 
                            NULL, 
                            NULL, 
                            PROV_RSA_FULL, 
                            CRYPT_VERIFYCONTEXT))
    {
        dwLastError = GetLastError();
        goto error;
    }

    if(!CryptImportPublicKeyInfoEx(hProv,
                               pPublic->dwCertEncodingType,
                               &pPublic->pCertInfo->SubjectPublicKeyInfo,
                               CALG_RSA_KEYX,
                               NULL,
                               NULL,
                               &hPublicKey))
    {
        dwLastError = GetLastError();
        goto error;
    }

    cbSid = GetLengthSid(pSidUser);


    cbInnerBlobData = sizeof(BACKUPKEY_INNER_BLOB) + 
                  cbLocalKey +
                  cbSid +
                  A_SHA_DIGEST_LEN;


    //
    // Round up to blocklen
    //
    cbInnerBlob = (cbInnerBlobData + (DES_BLOCKLEN - 1)) & ~(DES_BLOCKLEN-1);

    cbTemp = sizeof(cbKeyBlob);
    if(!CryptGetKeyParam(hPublicKey, 
                         KP_BLOCKLEN, 
                         (PBYTE)&cbKeyBlob, 
                         &cbTemp, 
                         0))
    {
        dwLastError = GetLastError();
        goto error;
    }

    cbKeyBlob >>= 3;  // convert from bits to bytes


    cbOuterBlob = sizeof(BACKUPKEY_RECOVERY_BLOB) +
                  cbKeyBlob +
                  cbInnerBlob;

    pOuterBlob = (PBACKUPKEY_RECOVERY_BLOB)SSAlloc(cbOuterBlob);
    if(NULL == pOuterBlob)
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    pKeyBlob = (PBACKUPKEY_KEY_BLOB)(pOuterBlob+1);

    pInnerBlob = (PBACKUPKEY_INNER_BLOB)((PBYTE)pKeyBlob + cbKeyBlob);

    // Initialize the payload key

    cbKeyBlobData = sizeof(BACKUPKEY_KEY_BLOB) + cbMasterKey + DES3_KEYSIZE + DES_BLOCKLEN;
    pKeyBlob->cbMasterKey = cbMasterKey;
    pKeyBlob->cbPayloadKey = DES3_KEYSIZE + DES_BLOCKLEN;
    pbPayloadKey = (PBYTE)(pKeyBlob+1) + cbMasterKey;

    CopyMemory((PBYTE)(pKeyBlob+1), pbMasterKey, cbMasterKey);


    //
    // Generate a payload key
    //
    if(!RtlGenRandom(pbPayloadKey, pKeyBlob->cbPayloadKey))
    {
        dwLastError = GetLastError();
        goto error;
    }


    // Populate the payload

    pInnerBlob->dwPayloadVersion = BACKUPKEY_PAYLOAD_VERSION;

    pInnerBlob->cbLocalKey = cbLocalKey;


    pbData = (PBYTE)(pInnerBlob+1);

    CopyMemory(pbData, pbLocalKey, cbLocalKey);

    pbData += cbLocalKey;

    CopyMemory(pbData, pSidUser, cbSid);

    pbData += cbSid;

    // Pad
    if(cbInnerBlob > cbInnerBlobData)
    {
        if(!RtlGenRandom(pbData, cbInnerBlob - cbInnerBlobData))
        {
            dwLastError = GetLastError();
            goto error;
        }
        pbData += cbInnerBlob - cbInnerBlobData;
    }

    // Generate the payload MAC

    FMyPrimitiveSHA( (PBYTE)pInnerBlob, 
                    cbInnerBlob - A_SHA_DIGEST_LEN,
                    pbData);



    //
    // Encrypt with 3DES CBC
    //
    {

        DES3TABLE s3DESKey;
        BYTE InputBlock[DES_BLOCKLEN];
        DWORD iBlock;
        DWORD cBlocks = cbInnerBlob/DES_BLOCKLEN;
        BYTE feedback[ DES_BLOCKLEN ];
        // initialize 3des key
        //

        if(cBlocks*DES_BLOCKLEN != cbInnerBlob)
        {
            // Master key must be a multiple of DES_BLOCKLEN
            dwLastError = NTE_BAD_KEY;
            goto error;

        }
        tripledes3key(&s3DESKey, pbPayloadKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated 
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, pbPayloadKey + DES3_KEYSIZE, DES_BLOCKLEN);


        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {
            CopyMemory(InputBlock, 
                       ((PBYTE)pInnerBlob)+iBlock*DES_BLOCKLEN,
                       DES_BLOCKLEN);
            CBC(tripledes,
                DES_BLOCKLEN,
                ((PBYTE)pInnerBlob)+iBlock*DES_BLOCKLEN,
                InputBlock,
                &s3DESKey,
                ENCRYPT,
                feedback);
        }
    }
    
    //
    // Encrypt master key and payload key to 
    // the public key 


    if(!CryptEncrypt(hPublicKey, 
                 NULL, 
                 TRUE, 
                 0, // CRYPT_OAEP 
                 (PBYTE)pKeyBlob, 
                 &cbKeyBlobData, 
                 cbKeyBlob))
    {
        dwLastError = GetLastError();
        goto error;
    }

    if(cbKeyBlobData != cbKeyBlob)
    {
        CopyMemory((PBYTE)pKeyBlob + cbKeyBlobData, 
                   pInnerBlob,
                   cbInnerBlob);
        cbOuterBlob -= cbKeyBlob - cbKeyBlobData;
    }

    pOuterBlob->dwVersion = BACKUPKEY_RECOVERY_BLOB_VERSION;
    pOuterBlob->cbEncryptedMasterKey  = cbKeyBlobData;
    pOuterBlob->cbEncryptedPayload = cbInnerBlob;
    CopyMemory(&pOuterBlob->guidKey,
               pPublic->pCertInfo->SubjectUniqueId.pbData,
               sizeof(GUID));


    *ppbBBK = (PBYTE)pOuterBlob;
    *pcbBBK = cbOuterBlob;

    pOuterBlob = NULL;
error:


    if((fRetrieve) || (ERROR_SUCCESS == dwLastError))
    {
        // Only audit if we're attempting to do the long backup.
        //SetThreadToken(NULL, hToken);

        CPSAudit(hToken,
                SE_AUDITID_DPAPI_BACKUP,
                phMasterKey->wszguidMasterKey,      // Key Identifier
                L"",                                // Recovery Server
                0,
                wszBackupKeyID,                     // Recovery Key ID
                dwLastError);                       // Failure Reason
        //SetThreadToken(NULL, NULL);
    }

    if(pPublic)
    {
        CertFreeCertificateContext(pPublic);
    }
    if(pbPublic)
    {
        SSFree(pbPublic);
    }
    if(pOuterBlob)
    {
        SSFree(pOuterBlob);
    }
    if (pSidUser) 
    {
        SSFree(pSidUser);
    }
    if(hPublicKey)
    {
        CryptDestroyKey(hPublicKey);
    }
    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    return dwLastError;
}


BOOLEAN
CompareNameToDnsName(
    LPCWSTR pszName,
    LPCWSTR pszDnsName)
{
    WCHAR szLocalName[MAX_COMPUTERNAME_LENGTH + 1];
    UNICODE_STRING LocalName;
    UNICODE_STRING Name;
    PWSTR pszPeriod;

    if(pszName == NULL && pszDnsName == NULL)
    {
        return TRUE;
    }

    if(pszName == NULL || pszDnsName == NULL)
    {
        return FALSE;
    }

    // Extract netbios name from dns name
    wcsncpy(szLocalName, pszDnsName, MAX_COMPUTERNAME_LENGTH);
    szLocalName[MAX_COMPUTERNAME_LENGTH] = L'\0';

    if(pszPeriod = wcschr(szLocalName, L'.'))
    {
        *pszPeriod = L'\0';
    }

    // Compare strings.
    RtlInitUnicodeString(&Name, pszName);
    RtlInitUnicodeString(&LocalName, szLocalName);

    return RtlEqualDomainName(&Name, &LocalName);
}


DWORD
WINAPI
BackupKey(
    IN      LPCWSTR pszComputerName,
    IN      const GUID *pguidActionAgent,
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut,
    IN      DWORD dwParam
    )
{

    RPC_BINDING_HANDLE h = NULL;
    WCHAR *pStringBinding = NULL;
    BOOL  fLocal = FALSE;
    HANDLE hToken = NULL;

    RPC_STATUS RpcStatus = RPC_S_OK;
    DWORD dwRetVal = ERROR_INVALID_PARAMETER;
    DWORD i;

    WCHAR szLocalComputerName[MAX_COMPUTERNAME_LENGTH + 2];
    DWORD BufSize = MAX_COMPUTERNAME_LENGTH + 2;
    LPWSTR pszSPN = NULL;

    #if DBG
    D_DebugLog((DEB_TRACE, "BackupKey called\n"));
    D_DebugLog((DEB_TRACE, "  DC Name:%ls\n", pszComputerName));

    if(memcmp(pguidActionAgent, &guidRetrieve, sizeof(GUID)) == 0)
    {
        D_DebugLog((DEB_TRACE, "  Retrieve domain public key\n"));
    } 
    else if(memcmp(pguidActionAgent, &guidRestore, sizeof(GUID)) == 0)
    {
        D_DebugLog((DEB_TRACE, "  Restore master key\n"));
    } 
    else if(memcmp(pguidActionAgent, &guidRestoreW2K, sizeof(GUID)) == 0)
    {
        D_DebugLog((DEB_TRACE, "  Restore master key (Win2K)\n"));
    } 
    else if(memcmp(pguidActionAgent, &guidBackup, sizeof(GUID)) == 0)
    {
        D_DebugLog((DEB_TRACE, "  Backup master key (Win2K)\n"));
    } 
    else
    {
        D_DebugLog((DEB_TRACE, "  Unknown operation\n"));
    }
    #endif
    
    *ppDataOut = NULL;
    *pcbDataOut = 0;


    //
    // Is the user logged on locally--or alternatively, is this the
    // user's recovery DC?
    //

    if (!(GetComputerNameW(szLocalComputerName, &BufSize)))
    {
        dwRetVal = GetLastError();
        D_DebugLog((DEB_TRACE, "BackupKey returned 0x%x\n", dwRetVal));
        return dwRetVal;
    }


    if(IsLocal())
    {
        // User is logged on locally.
        fLocal = TRUE;
    }
    else
    {
        D_DebugLog((DEB_TRACE, "User is not logged on locally\n"));

        if((pszComputerName == NULL) || CompareNameToDnsName(szLocalComputerName, pszComputerName))
        {
            D_DebugLog((DEB_TRACE, "This is the user's recovery DC\n"));

            fLocal = TRUE;
        }
    }


    //
    // Build the SPN
    //

    pszSPN = (LPWSTR)LocalAlloc(LPTR, ( wcslen(pszComputerName) + 
                                        1 + 
                                        wcslen(DPAPI_SERVICE_NAME) + 
                                        1 ) * sizeof(WCHAR) );

    if(pszSPN == NULL)
    {
        dwRetVal = ERROR_NOT_ENOUGH_MEMORY;
        D_DebugLog((DEB_TRACE, "BackupKey returned 0x%x\n", dwRetVal));
        return dwRetVal;
    }

    wcscpy(pszSPN, DPAPI_SERVICE_NAME);
    wcscat(pszSPN, L"/");
    wcscat(pszSPN, pszComputerName);


    //
    // Try all of the bindings
    //
    for (i = fLocal?0:1; i < g_cwzrBackupBindingList; i++)
    {
        RPC_SECURITY_QOS RpcQos;

        if (RPC_S_OK != RpcNetworkIsProtseqValidW(
                                    (unsigned short *)g_awzrBackupBindingList[i].pszProtSeq))
        {
            continue;
        }

        RpcStatus = RpcStringBindingComposeW(
                              NULL,
                              (unsigned short *)g_awzrBackupBindingList[i].pszProtSeq,
                              (unsigned short *)pszComputerName,
                              (unsigned short *)g_awzrBackupBindingList[i].pszEndpoint,
                              NULL,
                              &pStringBinding);
        if (RPC_S_OK != RpcStatus)
        {
            continue;
        }

        RpcStatus = RpcBindingFromStringBindingW(
                                    pStringBinding,
                                    &h);
        if (NULL != pStringBinding)
        {
            RpcStringFreeW(&pStringBinding);
        }
        if (RPC_S_OK != RpcStatus)
        {
            continue;
        }

        RpcStatus = RpcEpResolveBinding(
                            h,
                            BackupKey_v1_0_c_ifspec);
        if (RPC_S_OK != RpcStatus)
        {
            continue;
        }

        //
        // enable privacy and negotiated re-authentication.
        // a fresh authentication is required in the event an existing connection
        // to the target machine already existed which was made with non-default
        // credentials.
        //


        ZeroMemory( &RpcQos, sizeof(RpcQos) );
        RpcQos.Version = RPC_C_SECURITY_QOS_VERSION;
        RpcQos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
        RpcQos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        RpcQos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

        RpcStatus = RpcBindingSetAuthInfoExW(
                    h,
                    pszSPN,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_AUTHN_GSS_NEGOTIATE,
                    0,
                    0,
                    &RpcQos
                    );
        if (RPC_S_OK != RpcStatus)
        {
            continue;
        }




        __try
        {

            dwRetVal = BackuprKey(
                            h,
                            (GUID*)pguidActionAgent,
                            pDataIn,
                            cbDataIn,
                            ppDataOut,
                            pcbDataOut,
                            dwParam
                            );

        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            RpcStatus = _exception_code();
        }
        if (RPC_S_OK == RpcStatus)
        {
            break;
        }

    }


    if((RPC_S_OK != RpcStatus) && (fLocal == FALSE))
    {
        //
        // If we're going off machine, check to see if delegation is 
        // allowed. If it isn't, then this is probably the reason for the 
        // the failure, so return SEC_E_DELEGATION_REQUIRED. 
        //

        LPUSER_INFO_1 pUserInfo = NULL;

        wcscat(szLocalComputerName, L"$");


        if((OpenThreadToken(GetCurrentThread(), 
                            TOKEN_IMPERSONATE, 
                            TRUE, 
                            &hToken)) &&
            SetThreadToken(NULL, NULL))
        {
            if (NERR_Success == NetUserGetInfo(
                                        pszComputerName,
                                        szLocalComputerName,
                                        1,
                                        (PBYTE *)&pUserInfo
                                        )) {

                if (!(UF_TRUSTED_FOR_DELEGATION & pUserInfo->usri1_flags))
                {
                    D_DebugLog((DEB_TRACE, "Server is not trusted for delegation\n"));
                    RpcStatus = SEC_E_DELEGATION_REQUIRED;
                }

                NetApiBufferFree(pUserInfo);
            }

            //
            // Impersonate again
            // We are going to fail. No need to check the return value of SetThreadToken.
            //

            (void) SetThreadToken(NULL, hToken);
        }
    }


    if(hToken)
    {
        CloseHandle(hToken);
    }
    if(RPC_S_OK != RpcStatus)
    {
        dwRetVal = RpcStatus;
    }

    if(h)
    {
        RpcBindingFree(&h);
    }

    if(pszSPN)
    {
        LocalFree(pszSPN);
    }

    D_DebugLog((DEB_TRACE, "BackupKey returned 0x%x\n", dwRetVal));

    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\keybckup.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    keybckup.h

Abstract:

    This module contains routines associated with client side Key Backup
    operations.

Author:

    Scott Field (sfield)    16-Sep-97

--*/

#ifndef __KEYBCKUP_H__
#define __KEYBCKUP_H__

DWORD
LocalBackupRestoreData(
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED   phMasterKey,
    IN      PBYTE               pbDataIn,
    IN      DWORD               cbDataIn,
        OUT PBYTE               *ppbDataOut,
        OUT DWORD               *pcbDataOut,
    IN      const GUID          *pguidAction
    );

DWORD
BackupRestoreData(
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED   phMasterKey,
    IN      PBYTE               pbDataIn,
    IN      DWORD               cbDataIn,
        OUT PBYTE               *ppbDataOut,
        OUT DWORD               *pcbDataOut,
    IN      BOOL                fBackup
    );

DWORD
AttemptLocalBackup(
    IN      BOOL                fRetrieve,
    IN      HANDLE              hToken,
    IN      PMASTERKEY_STORED   phMasterKey,
    IN      PBYTE               pbMasterKey,
    IN      DWORD               cbMasterKey,
    IN      PBYTE               pbLocalKey,
    IN      DWORD               cbLocalKey,
        OUT PBYTE *             ppbBBK,
        OUT DWORD *             pcbBBK
    );

#endif  // __KEYBCKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\keycache.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    keycache.h

Abstract:

    This module contains routines for accessing cached masterkeys.

Author:

    Scott Field (sfield)    07-Nov-98

Revision History:

--*/

#ifndef __KEYCACHE_H__
#define __KEYCACHE_H__


BOOL
InitializeKeyCache(
    VOID
    );

VOID
DeleteKeyCache(
    VOID
    );

BOOL
SearchMasterKeyCache(
    IN      PLUID pLogonId,
    IN      GUID *pguidMasterKey,
    IN  OUT PBYTE *ppbMasterKey,
        OUT PDWORD pcbMasterKey
    );

BOOL
InsertMasterKeyCache(
    IN      PLUID pLogonId,
    IN      GUID *pguidMasterKey,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey
    );

BOOL
PurgeMasterKeyCache(
    VOID
    );

#endif  // __KEYCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\dpapi.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dpapi.cpp

Abstract:

    This module contains the DPAPI initialization routines, called by the LSA

Author:

    Pete Skelly (petesk)    22-Mar-00
--*/


#include <pch.cpp>
#pragma hdrstop
#include "pasrec.h"

CCryptProvList*     g_pCProvList = NULL;

TOKEN_SOURCE DPAPITokenSource;

PLSA_SECPKG_FUNCTION_TABLE g_pSecpkgTable;


#ifdef RETAIL_LOG_SUPPORT
HANDLE g_hParamEvent = NULL;
HKEY   g_hKeyParams  = NULL;
HANDLE g_hWait       = NULL;

DEFINE_DEBUG2(DPAPI);

DEBUG_KEY DPAPIDebugKeys[] = { 
    {DEB_ERROR,         "Error"},
    {DEB_WARN,          "Warn"},
    {DEB_TRACE,         "Trace"},
    {DEB_TRACE_API,     "API"},
    {DEB_TRACE_CRED,    "Cred"},
    {DEB_TRACE_CTXT,    "Ctxt"},
    {DEB_TRACE_LSESS,   "LSess"},
    {DEB_TRACE_LOGON,   "Logon"},
    {DEB_TRACE_TIME,    "Time"},
    {DEB_TRACE_LOCKS,   "Locks"},
    {DEB_TRACE_LEAKS,   "Leaks"},
    {0,                  NULL},
};

VOID
DPAPIWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus);

VOID
DPAPIInitializeDebugging(
    BOOL fMonitorRegistry)
{
    DPAPIInitDebug(DPAPIDebugKeys);

    if(fMonitorRegistry)
    {
        g_hParamEvent = CreateEvent(NULL,
                               FALSE,
                               FALSE,
                               NULL);

        if (NULL == g_hParamEvent) 
        {
            D_DebugLog((DEB_WARN, "CreateEvent for ParamEvent failed - 0x%x\n", GetLastError()));
        } 
        else 
        {
            DPAPIWatchParamKey(g_hParamEvent, FALSE);
        }
    }
}

////////////////////////////////////////////////////////////////////
//
//  Name:       DPAPIGetRegParams
//
//  Synopsis:   Gets the debug paramaters from the registry 
//
//  Arguments:  HKEY to HKLM/System/CCS/LSA/DPAPI
//
//  Notes:      Sets DPAPIInfolevel for debug spew
//
void
DPAPIGetRegParams(HKEY ParamKey)
{

    DWORD       cbType, tmpInfoLevel = DPAPIInfoLevel, cbSize = sizeof(DWORD);
    DWORD       dwErr;
 
    dwErr = RegQueryValueExW(
        ParamKey,
        WSZ_DPAPIDEBUGLEVEL,
        NULL,
        &cbType,
        (LPBYTE)&tmpInfoLevel,
        &cbSize      
        );
    if (dwErr != ERROR_SUCCESS)
    {
        if (dwErr ==  ERROR_FILE_NOT_FOUND)
        {
            // no registry value is present, don't want info
            // so reset to defaults
#if DBG
            DPAPIInfoLevel = DEB_ERROR;
            
#else // fre
            DPAPIInfoLevel = 0;
#endif
        }
        else
        {
            D_DebugLog((DEB_WARN, "Failed to query DebugLevel: 0x%x\n", dwErr));
        }      
    }

    // TBD:  Validate flags?
    DPAPIInfoLevel = tmpInfoLevel;
    dwErr = RegQueryValueExW(
               ParamKey,
               WSZ_FILELOG,
               NULL,
               &cbType,
               (LPBYTE)&tmpInfoLevel,
               &cbSize      
               );

    if (dwErr == ERROR_SUCCESS)
    {                                                
       DPAPISetLoggingOption((BOOL)tmpInfoLevel);
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
       DPAPISetLoggingOption(FALSE);
    }
    
    return;
}

////////////////////////////////////////////////////////////////////
//
//  Name:       DPAPIWaitCleanup
//
//  Synopsis:   Cleans up wait from DPAPIWatchParamKey()
//
//  Arguments:  <none>
//
//  Notes:      .
//
void
DPAPIWaitCleanup()
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (NULL != g_hWait) 
    {
        Status = RtlDeregisterWait(g_hWait);               
        if (NT_SUCCESS(Status) && NULL != g_hParamEvent ) 
        {
            CloseHandle(g_hParamEvent);
        }      
    }                                  
}



////////////////////////////////////////////////////////////////////
//
//  Name:       DPAPIWatchParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
DPAPIWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus)
{
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;
   
    if (NULL == g_hKeyParams)  // first time we've been called.
    {
        lRes = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    DPAPI_PARAMETER_PATH,
                    0,
                    KEY_READ,
                    &g_hKeyParams);

        if (ERROR_SUCCESS != lRes)
        {
            D_DebugLog((DEB_WARN,"Failed to open DPAPI key: 0x%x\n", lRes));
            goto Reregister;
        }
    }

    if (NULL != g_hWait) 
    {
        Status = RtlDeregisterWait(g_hWait);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
            goto Reregister;
        }

    }
    
    lRes = RegNotifyChangeKeyValue(
                g_hKeyParams,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                (HANDLE) pCtxt,
                TRUE);

    if (ERROR_SUCCESS != lRes) 
    {
        D_DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
        // we're tanked now. No further notifications, so get this one
    }
                   
    DPAPIGetRegParams(g_hKeyParams);
    
Reregister:
    
    Status = RtlRegisterWait(&g_hWait,
                             (HANDLE) pCtxt,
                             DPAPIWatchParamKey,
                             (HANDLE) pCtxt,
                             INFINITE,
                             WT_EXECUTEINPERSISTENTIOTHREAD|
                             WT_EXECUTEONLYONCE);

}                       
                        
#endif // RETAIL_LOG_SUPPORT


RPC_STATUS
RPC_ENTRY
ProtectCallback(
    RPC_IF_HANDLE idIF,
    PVOID pCtx)
{
    RPC_STATUS Status;
    PWSTR pBinding = NULL;
    PWSTR pProtSeq = NULL;

    Status = RpcBindingToStringBinding(pCtx, &pBinding);

    if(Status != RPC_S_OK)
    {
        goto cleanup;
    }

    Status = RpcStringBindingParse(pBinding,
                                   NULL,
                                   &pProtSeq,
                                   NULL,
                                   NULL,
                                   NULL);
    if(Status != RPC_S_OK)
    {
        goto cleanup;
    }

    // Make sure caller is using local RPC
    if(CompareString(LOCALE_INVARIANT,
                     NORM_IGNORECASE, 
                     pProtSeq,
                     -1,
                     DPAPI_LOCAL_PROT_SEQ,
                     -1) != CSTR_EQUAL)
    {
        Status = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    Status = RPC_S_OK;

cleanup:

    if(pProtSeq)
    {
        RpcStringFree(&pProtSeq);
    }

    if(pBinding)
    {
        RpcStringFree(&pBinding);
    }

    return Status;
}


//
//  FUNCTION: DPAPIInitialize
//
//  COMMENTS:
//  

DWORD
NTAPI
DPAPIInitialize(
    LSA_SECPKG_FUNCTION_TABLE *pSecpkgTable)
{
    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fStartedKeyService = FALSE;
    BOOL bListConstruct = FALSE;
    LONG        lRes = ERROR_SUCCESS;

    RPC_STATUS status;

    dwLastError = RtlInitializeCriticalSection(&g_csCredHistoryCache);
    if(!NT_SUCCESS(dwLastError))
    {
        goto cleanup;
    }

    DPAPIInitializeDebugging(TRUE);


    // Initialize stuff necessary to create tokens etc, just as if 
    // we're a security package. 
    g_pSecpkgTable = pSecpkgTable;

    CopyMemory( DPAPITokenSource.SourceName, DPAPI_PACKAGE_NAME_A, strlen(DPAPI_PACKAGE_NAME_A) );
    AllocateLocallyUniqueId( &DPAPITokenSource.SourceIdentifier );



    g_pCProvList = new CCryptProvList;
    if(g_pCProvList)
    {
        if(!g_pCProvList->Initialize())
        {
            delete g_pCProvList;
            g_pCProvList = NULL;
        }
    }

    IntializeGlobals();

    if(!InitializeKeyManagement())
    {
        dwLastError = STATUS_NO_MEMORY;
        goto cleanup;
    }

    status = RpcServerUseProtseqEpW(DPAPI_LOCAL_PROT_SEQ,   //ncalrpc 
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
                                    DPAPI_LOCAL_ENDPOINT,   //protected_storage
                                    NULL);              //Security Descriptor

    if(RPC_S_DUPLICATE_ENDPOINT == status)
    {
        status = RPC_S_OK;
    }

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }
    status = RpcServerUseProtseqEpW(DPAPI_BACKUP_PROT_SEQ,   //ncacn_np 
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
                                    DPAPI_BACKUP_ENDPOINT,   //protected_storage
                                    NULL);              //Security Descriptor

    if(RPC_S_DUPLICATE_ENDPOINT == status)
    {
        status = RPC_S_OK;
    }

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    status = RpcServerRegisterIfEx(s_ICryptProtect_v1_0_s_ifspec, 
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   ProtectCallback);

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }


    status = RpcServerRegisterIfEx(s_PasswordRecovery_v1_0_s_ifspec, 
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                   ProtectCallback);

    if (status)
    {
        dwLastError = status;
        goto cleanup;
    }

    //
    // Start the Backup Key server
    // note: it only starts when the current machine is an domain controller.
    //

    dwLastError = StartBackupKeyServer();
    if(dwLastError != ERROR_SUCCESS) {
        goto cleanup;
    }

    return dwLastError;

cleanup:
    DPAPIShutdown();
    return dwLastError;
}



DWORD
NTAPI
DPAPIShutdown(  )
{
    //
    // ignore errors because we are shutting down
    //

    (void)RpcServerUnregisterIf(s_ICryptProtect_v1_0_s_ifspec, 0, 0);

    //
    // stop backup key server
    // Note:  this function knows internally whether the backup key server
    // really started or not.
    //

    StopBackupKeyServer();


    if(g_pCProvList)
    {
        delete g_pCProvList;
        g_pCProvList = NULL;
    }

    TeardownKeyManagement();
    
    ShutdownGlobals();
    return ERROR_SUCCESS;
}

#ifdef RETAIL_LOG_SUPPORT
VOID
DPAPIDumpHexData(
    DWORD LogLevel,
    PSTR  pszPrefix,
    PBYTE pbData,
    DWORD cbData)
{
    DWORD i,count;
    CHAR digits[]="0123456789abcdef";
    CHAR pbLine[MAX_PATH];
    DWORD cbLine;
    DWORD cbHeader;
    DWORD_PTR address;

    if((DPAPIInfoLevel & LogLevel) == 0)
    {
        return;
    }

    if(pbData == NULL || cbData == 0)
    {
        return;
    }

    if(pszPrefix)
    {
        strcpy(pbLine, pszPrefix);
        cbHeader = strlen(pszPrefix);
    }
    else
    {
        pbLine[0] = '\0';
        cbHeader = 0;
    }

    for(; cbData ; cbData -= count, pbData += count)
    {
        count = (cbData > 16) ? 16:cbData;

        cbLine = cbHeader;

        address = (DWORD_PTR)pbData;

#if defined(_WIN64)
        pbLine[cbLine++] = digits[(address >> 0x3c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x38) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x34) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x30) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x2c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x28) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x24) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x20) & 0x0f];
#endif

        pbLine[cbLine++] = digits[(address >> 0x1c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x18) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x14) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x10) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x0c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x08) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x04) & 0x0f];
        pbLine[cbLine++] = digits[(address        ) & 0x0f];
        pbLine[cbLine++] = ' ';
        pbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
        {
            pbLine[cbLine++] = digits[pbData[i]>>4];
            pbLine[cbLine++] = digits[pbData[i]&0x0f];
            if(i == 7)
            {
                pbLine[cbLine++] = ':';
            }
            else
            {
                pbLine[cbLine++] = ' ';
            }
        }

        for(; i < 16; i++)
        {
            pbLine[cbLine++] = ' ';
            pbLine[cbLine++] = ' ';
            pbLine[cbLine++] = ' ';
        }

        pbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
        {

            //
            //  37 is for %
            //

            if(pbData[i] < 32 || pbData[i] > 126 || pbData[i] == 37)
            {
                pbLine[cbLine++] = '.';
            }
            else
            {
                pbLine[cbLine++] = pbData[i];
            }
        }

        pbLine[cbLine++] = '\n';
        pbLine[cbLine++] = 0;

        D_DebugLog((LogLevel, pbLine));
    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\keycache.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    keycache.h

Abstract:

    This module contains routines for accessing cached masterkeys.

Author:

    Scott Field (sfield)    07-Nov-98

Revision History:

--*/

#include <pch.cpp>
#pragma hdrstop

//
// masterkey cache.
//

typedef struct {
    LIST_ENTRY Next;
    LUID LogonId;
    GUID guidMasterKey;
    FILETIME ftLastAccess;
    DWORD cbMasterKey;
    BYTE pbMasterKey[ 64 ];
} MASTERKEY_CACHE_ENTRY, *PMASTERKEY_CACHE_ENTRY, *LPMASTERKEY_CACHE_ENTRY;

RTL_CRITICAL_SECTION g_MasterKeyCacheCritSect;
LIST_ENTRY g_MasterKeyCacheList;



BOOL
RemoveMasterKeyCache(
    IN      PLUID pLogonId
    );


#if DBG
void
DumpMasterKeyEntry(
    PMASTERKEY_CACHE_ENTRY pCacheEntry)
{
    WCHAR wszguidMasterKey[MAX_GUID_SZ_CHARS];
    #if 0
    BYTE rgbMasterKey[256];
    DWORD cbMasterKey;
    #endif

    D_DebugLog((DEB_TRACE, "LogonId: %d.%d\n", pCacheEntry->LogonId.LowPart, pCacheEntry->LogonId.HighPart));

    if( MyGuidToStringW( &pCacheEntry->guidMasterKey, wszguidMasterKey ) != 0 )
    {
        D_DebugLog((DEB_TRACE, "Invalid GUID:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "    ", (PBYTE)&pCacheEntry->guidMasterKey, sizeof(pCacheEntry->guidMasterKey));
    }
    else
    {
        D_DebugLog((DEB_TRACE, "GUID: %ws\n", wszguidMasterKey));
    }

    #if 0
    cbMasterKey = min(pCacheEntry->cbMasterKey, sizeof(rgbMasterKey));
    CopyMemory(rgbMasterKey, pCacheEntry->pbMasterKey, cbMasterKey);

    LsaProtectMemory(rgbMasterKey, cbMasterKey);

    D_DebugLog((DEB_TRACE, "Master key:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "    ", rgbMasterKey, cbMasterKey);
    #endif
}
#endif

#if DBG
void
DumpMasterKeyCache(void)
{
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PMASTERKEY_CACHE_ENTRY pCacheEntry;
    ULONG i = 0;

    RtlEnterCriticalSection( &g_MasterKeyCacheCritSect );

    D_DebugLog((DEB_TRACE, "Master key cache\n"));

    ListHead = &g_MasterKeyCacheList;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) 
    {
        pCacheEntry = CONTAINING_RECORD( ListEntry, MASTERKEY_CACHE_ENTRY, Next );

        D_DebugLog((DEB_TRACE, "---- %d ----\n", ++i));

        DumpMasterKeyEntry(pCacheEntry);
    }

    RtlLeaveCriticalSection( &g_MasterKeyCacheCritSect );
}
#endif


BOOL
SearchMasterKeyCache(
    IN      PLUID pLogonId,
    IN      GUID *pguidMasterKey,
    IN  OUT PBYTE *ppbMasterKey,
        OUT PDWORD pcbMasterKey
    )
/*++

    Search the masterkey sorted masterkey cache by pLogonId then by
    pguidMasterKey.

    On success, return value is true, and ppbMasterKey will point to a buffer
    allocated on behalf of the caller containing the specified masterkey.
    The caller must free the buffer using SSFree().

--*/
{
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    BOOL fSuccess = FALSE;

#if DBG
    WCHAR wszguidMasterKey[MAX_GUID_SZ_CHARS];
#endif

    RtlEnterCriticalSection( &g_MasterKeyCacheCritSect );

#if DBG
    D_DebugLog((DEB_TRACE, "SearchMasterKeyCache\n"));
    D_DebugLog((DEB_TRACE, "LogonId: %d.%d\n", pLogonId->LowPart, pLogonId->HighPart));

    if( MyGuidToStringW( pguidMasterKey, wszguidMasterKey ) != 0 )
    {
        D_DebugLog((DEB_TRACE, "Invalid GUID:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "    ", (PBYTE)pguidMasterKey, sizeof(GUID));
    }
    else
    {
        D_DebugLog((DEB_TRACE, "GUID: %ws\n", wszguidMasterKey));
    }

    //DumpMasterKeyCache();
#endif

    ListHead = &g_MasterKeyCacheList;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        PMASTERKEY_CACHE_ENTRY pCacheEntry;
        signed int comparator;

        pCacheEntry = CONTAINING_RECORD( ListEntry, MASTERKEY_CACHE_ENTRY, Next );

        //
        // search by LogonId, then by GUID.
        //

        comparator = memcmp(pLogonId, &pCacheEntry->LogonId, sizeof(LUID));

        if( comparator < 0 )
            continue;

        if( comparator > 0 )
            break;

        comparator = memcmp(pguidMasterKey, &pCacheEntry->guidMasterKey, sizeof(GUID));

        if( comparator < 0 )
            continue;

        if( comparator > 0 )
            break;

        //
        // match found.
        //

        *pcbMasterKey = pCacheEntry->cbMasterKey;
        *ppbMasterKey = (PBYTE)SSAlloc( *pcbMasterKey );
        if( *ppbMasterKey != NULL ) {
            CopyMemory( *ppbMasterKey, pCacheEntry->pbMasterKey, *pcbMasterKey );
            fSuccess = TRUE;
        }


        //
        // update last access time.
        //

        GetSystemTimeAsFileTime( &pCacheEntry->ftLastAccess );

        break;
    }


    RtlLeaveCriticalSection( &g_MasterKeyCacheCritSect );

    if( fSuccess ) {

        //
        // decrypt (in-place) the returned encrypted cache entry.
        //

        LsaUnprotectMemory( *ppbMasterKey, *pcbMasterKey );
    }

    D_DebugLog((DEB_TRACE, "SearchMasterKeyCache returned %s\n", fSuccess ? "FOUND" : "NOT FOUND"));

    return fSuccess;
}


BOOL
InsertMasterKeyCache(
    IN      PLUID pLogonId,
    IN      GUID *pguidMasterKey,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey
    )
/*++

    Insert the specified masterkey into the cahce sorted by pLogonId then by
    pguidMasterKey.

    The return value is TRUE on success.

--*/
{
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PMASTERKEY_CACHE_ENTRY pCacheEntry;
    PMASTERKEY_CACHE_ENTRY pThisCacheEntry = NULL;
    BOOL fInserted = FALSE;

    D_DebugLog((DEB_TRACE, "InsertMasterKeyCache\n"));

    if( cbMasterKey > sizeof(pCacheEntry->pbMasterKey) )
        return FALSE;

    pCacheEntry = (PMASTERKEY_CACHE_ENTRY)SSAlloc( sizeof( MASTERKEY_CACHE_ENTRY ) );
    if( pCacheEntry == NULL )
        return FALSE;

    CopyMemory( &pCacheEntry->LogonId, pLogonId, sizeof(LUID) );
    CopyMemory( &pCacheEntry->guidMasterKey, pguidMasterKey, sizeof(GUID) );
    pCacheEntry->cbMasterKey = cbMasterKey;
    CopyMemory( pCacheEntry->pbMasterKey, pbMasterKey, cbMasterKey );

    LsaProtectMemory( pCacheEntry->pbMasterKey, cbMasterKey );

    GetSystemTimeAsFileTime( &pCacheEntry->ftLastAccess );

    RtlEnterCriticalSection( &g_MasterKeyCacheCritSect );

#if DBG
    DumpMasterKeyEntry(pCacheEntry);
#endif

    ListHead = &g_MasterKeyCacheList;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        signed int comparator;

        pThisCacheEntry = CONTAINING_RECORD( ListEntry, MASTERKEY_CACHE_ENTRY, Next );

        //
        // insert into list sorted by LogonId, then sorted by GUID.
        //

        comparator = memcmp(pLogonId, &pThisCacheEntry->LogonId, sizeof(LUID));

        if( comparator < 0 )
            continue;

        if( comparator == 0 ) {
            comparator = memcmp( pguidMasterKey, &pThisCacheEntry->guidMasterKey, sizeof(GUID));

            if( comparator < 0 )
                continue;

            if( comparator == 0 ) {

                //
                // don't insert duplicate records.
                // this would only happen in a race condition with multiple threads.
                //

                RtlSecureZeroMemory( pCacheEntry, sizeof(MASTERKEY_CACHE_ENTRY) );
                SSFree( pCacheEntry );
                fInserted = TRUE;
                break;
            }
        }


        //
        // insert prior to current record.
        //

        InsertHeadList( pThisCacheEntry->Next.Blink, &pCacheEntry->Next );
        fInserted = TRUE;
        break;
    }

    if( !fInserted ) {
        if( pThisCacheEntry == NULL ) {
            InsertHeadList( ListHead, &pCacheEntry->Next );
        } else {
            InsertHeadList( &pThisCacheEntry->Next, &pCacheEntry->Next );
        }
    }

#if DBG
    //DumpMasterKeyCache();
#endif

    RtlLeaveCriticalSection( &g_MasterKeyCacheCritSect );

    return TRUE;
}

BOOL
PurgeMasterKeyCache(
    VOID
    )
/*++

    Purge masterkey cache of timed-out entries, or entries associated with
    terminated logon sessions.

--*/
{
    //
    // build active session table.
    //

    // don't touch entries that have an entry in active session table.
    // assume LUID_SYSTEM in table.
    //

    // entries not in table: discard after 15 minute timeout.
    //


    // if entry in table, find next LUID
    // else, if entry expired, check timeout.  if expired, remove.
    //

    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;


    RtlEnterCriticalSection( &g_MasterKeyCacheCritSect );

    ListHead = &g_MasterKeyCacheList;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        PMASTERKEY_CACHE_ENTRY pCacheEntry;
//        signed int comparator;

        pCacheEntry = CONTAINING_RECORD( ListEntry, MASTERKEY_CACHE_ENTRY, Next );
    }


    RtlLeaveCriticalSection( &g_MasterKeyCacheCritSect );

    return FALSE;
}

BOOL
RemoveMasterKeyCache(
    IN      PLUID pLogonId
    )
/*++

    Remove all entries from the masterkey cache corresponding to the specified
    pLogonId.

    The purpose of this routine is to purge the masterkey cache of entries
    associated with (now) non-existent logon sessions.

--*/
{

    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;

    RtlEnterCriticalSection( &g_MasterKeyCacheCritSect );

    D_DebugLog((DEB_TRACE, "RemoveMasterKeyCache\n"));
    D_DebugLog((DEB_TRACE, "LogonId: %d.%d\n", pLogonId->LowPart, pLogonId->HighPart));

    ListHead = &g_MasterKeyCacheList;

    for( ListEntry = ListHead->Flink;
         ListEntry != ListHead;
         ListEntry = ListEntry->Flink ) {

        PMASTERKEY_CACHE_ENTRY pCacheEntry;
        signed int comparator;

        pCacheEntry = CONTAINING_RECORD( ListEntry, MASTERKEY_CACHE_ENTRY, Next );

        //
        // remove all entries with matching LogonId.
        //

        comparator = memcmp(pLogonId, &pCacheEntry->LogonId, sizeof(LUID));

        if( comparator > 0 )
            break;

        if( comparator < 0 )
            continue;

        //
        // match found.
        //

        RemoveEntryList( &pCacheEntry->Next );

        RtlSecureZeroMemory( pCacheEntry, sizeof(MASTERKEY_CACHE_ENTRY) );
        SSFree( pCacheEntry );
    }


    RtlLeaveCriticalSection( &g_MasterKeyCacheCritSect );

    return TRUE;
}



BOOL
InitializeKeyCache(
    VOID
    )
{
    NTSTATUS Status;
    
    Status = RtlInitializeCriticalSection( &g_MasterKeyCacheCritSect );
    if(!NT_SUCCESS(Status))
    {
        return FALSE;
    }

    InitializeListHead( &g_MasterKeyCacheList );

    return TRUE;
}


VOID
DeleteKeyCache(
    VOID
    )
{

    //
    // remove all list entries.
    //

    RtlEnterCriticalSection( &g_MasterKeyCacheCritSect );

    while ( !IsListEmpty( &g_MasterKeyCacheList ) ) {

        PMASTERKEY_CACHE_ENTRY pCacheEntry;

        pCacheEntry = CONTAINING_RECORD(
                                g_MasterKeyCacheList.Flink,
                                MASTERKEY_CACHE_ENTRY,
                                Next
                                );

        RemoveEntryList( &pCacheEntry->Next );

        RtlSecureZeroMemory( pCacheEntry, sizeof(MASTERKEY_CACHE_ENTRY) );
        SSFree( pCacheEntry );
    }

    RtlLeaveCriticalSection( &g_MasterKeyCacheCritSect );

    RtlDeleteCriticalSection( &g_MasterKeyCacheCritSect );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\keyman.cpp ===
/*++

Copyright (c) 1997, 1998  Microsoft Corporation

Module Name:

    keyman.cpp

Abstract:

    This module contains routines to manage master keys on behalf of the
    client.  This includes retrieval, backup and restore.


Author:

    Scott Field (sfield)    09-Sep-97

Revision History:

    Scott Field (sfield)    01-Mar-98
    Use files as the backing store.
    Storage of all masterkey pieces a single atomic operation.

--*/

#include <pch.cpp>
#pragma hdrstop

#include <msaudite.h>

#define REENCRYPT_MASTER_KEY    1
#define ADD_MASTER_KEY_TO_CACHE 2


//
// preferred masterkey selection query/set
//

NTSTATUS
GetPreferredMasterKeyGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN  OUT GUID *pguidMasterKey
    );

BOOL
SetPreferredMasterKeyGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      GUID *pguidMasterKey
    );

//
// masterkey creation and query
//

DWORD
CreateMasterKey(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
        OUT GUID *pguidMasterKey,
    IN      BOOL fRequireBackup
    );

BOOL
GetMasterKeyByGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      PSID    pSid,
    IN      BOOL    fMigrate, 
    IN      GUID *pguidMasterKey,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
        OUT DWORD *pdwMasterKeyDisposition  // refer to MK_DISP_ constants
    );

BOOL
GetMasterKey(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      PSID    pSid,
    IN      BOOL    fMigrate,
    IN      WCHAR wszMasterKey[MAX_GUID_SZ_CHARS],
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
        OUT DWORD *pdwMasterKeyDisposition
    );

//
// helper functions used during key retrieval and storage.
//

BOOL
ReadMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey
    );

BOOL
WriteMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey
    );

BOOL
CheckToStompMasterKey(
    IN      PMASTERKEY_STORED_ON_DISK   phMasterKeyCandidate,   // masterkey to check if worthy to stomp over existing
    IN      HANDLE                      hFile,                  // file handle to existing masterkey
    IN OUT  BOOL                        *pfStomp                // stomp the existing masterkey?
    );

BOOL
DuplicateMasterKey(
    IN      PMASTERKEY_STORED phMasterKeyIn,
    IN      PMASTERKEY_STORED phMasterKeyOut
    );

BOOL
CloseMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey,
    IN      BOOL fPersist               // persist any changes to storage?
    );

VOID
FreeMasterKey(
    IN      PMASTERKEY_STORED phMasterKey
    );

//
// low-level crypto enabled key persistence query/set
//

DWORD
DecryptMasterKeyFromStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
        OUT BOOL  *pfUpgradeEncryption,
        OUT PBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey
    );

DWORD
DecryptMasterKeyToMemory(
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      PBYTE pbMasterKeyIn,
    IN      DWORD cbMasterKeyIn,
        OUT BOOL *pfUpgradeEncryption, 
        OUT PBYTE *ppbMasterKeyOut,
        OUT DWORD *pcbMasterKeyOut
    );

DWORD
EncryptMasterKeyToStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey
    );

DWORD
EncryptMasterKeyToMemory(
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      DWORD cIterationCount,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
        OUT PBYTE *ppbMasterKeyOut,
        OUT DWORD *pcbMasterKeyOut
    );

DWORD
PersistMasterKeyToStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      PBYTE pbMasterKeyOut,
    IN      DWORD cbMasterKeyOut
    );

DWORD
QueryMasterKeyFromStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN  OUT PBYTE *ppbMasterKeyOut,
    IN  OUT DWORD *pcbMasterKeyOut
    );

//
// per-user credential derivation
//

BOOL
GetMasterKeyUserEncryptionKey(
    IN      PVOID   pvContext,
    IN      GUID    *pCredentialID,
    IN      PSID    pSid,
    IN      DWORD   dwFlags, 
    IN  OUT BYTE    rgbMKEncryptionKey[A_SHA_DIGEST_LEN]
    );

BOOL
GetLocalKeyUserEncryptionKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN  OUT BYTE rgbLKEncrytionKey[A_SHA_DIGEST_LEN]
    );

//
// backup/restore operations.
//

BOOL
IsBackupMasterKeyRequired(
    IN      PMASTERKEY_STORED phMasterKey,
    IN  OUT BOOL *pfPhaseTwo        // is phase two required?
    );

DWORD
BackupMasterKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      LPBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
    IN      BOOL fPhaseTwo,         // is phase two required?
    IN      BOOL fAsynchronous      // asynchronous call?
    );

DWORD
QueueBackupMasterKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      PBYTE pbLocalKey,
    IN      DWORD cbLocalKey,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
    IN      DWORD dwWaitTimeout             // amount of time to wait for operation to complete
    );

DWORD
RestoreMasterKey(
    IN      PVOID   pvContext,
    IN      PSID    pSid,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD   dwReason,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey
    );


//
// asyncrhonous work functions for:
// 1.  Backup operations
// 2.  Masterkey synchronization operations
//

DWORD
WINAPI
QueueBackupMasterKeyThreadFunc(
    IN      LPVOID lpThreadArgument
    );

DWORD
WINAPI
QueueSyncMasterKeysThreadFunc(
    IN      LPVOID lpThreadArgument
    );


//
// backup/restore policy operations
//

BOOL
InitializeMasterKeyPolicy(
    IN      PVOID pvContext,
    IN      MASTERKEY_STORED *phMasterKey,
    OUT     BOOL *fLocalAccount
    );

BOOL
IsDomainBackupRequired(
    IN      PVOID pvContext
    );




DWORD
InitiateSynchronizeMasterKeys(
    IN      PVOID pvContext         // server context
    )
/*++

    Force Synchronization of all masterkeys associated with the caller.

    This can include per-machine keys if the call was made with the per-machine
    flag turned on.  Otherwise, the masterkeys associated with the client
    user security context are synchronized.

    Synchronization is required to support a variety of login credential
    change scenarios:

    1. Domain Administrator assigns new password to user.
    2. User changes password locally.
    3. User changes password from another machine on the network.
    4. User which is primarily disconnected from the network requests new
       password from Domain Administrator, connect to network long enough
       to refresh Netlogon cache with new credential.

--*/
{
    PQUEUED_SYNC pQueuedSync = NULL;
    DWORD cbQueuedSync = sizeof(QUEUED_SYNC);
    DWORD dwLastError = ERROR_SUCCESS;

    D_DebugLog((DEB_TRACE_API, "SynchronizeMasterKeys\n"));

    pQueuedSync = (PQUEUED_SYNC)SSAlloc( cbQueuedSync );
    if( pQueuedSync == NULL ) {
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }

    ZeroMemory( pQueuedSync, cbQueuedSync );
    pQueuedSync->cbSize = cbQueuedSync;

    //
    // duplicate the outstanding server context.
    //

    dwLastError = CPSDuplicateContext(pvContext, &(pQueuedSync->pvContext));

    if( dwLastError != ERROR_SUCCESS )
         goto cleanup;

    #if 1
   
    //
    // create the worker thread to handle the synchronize request.
    //

    if( !QueueUserWorkItem(
            QueueSyncMasterKeysThreadFunc,
            pQueuedSync,
            WT_EXECUTELONGFUNCTION
            )) 
    {
        dwLastError = GetLastError();
    }

    #else
    
    //
    // Perform the synchronization in the current thread.
    //
    
    dwLastError = SynchronizeMasterKeys(pQueuedSync->pvContext, 0);

    if(pQueuedSync->pvContext) 
    {
        CPSFreeContext( pQueuedSync->pvContext );
    }

    if( pQueuedSync )
        SSFree( pQueuedSync );

    dwLastError = ERROR_SUCCESS;

    #endif


cleanup:

    if( dwLastError != ERROR_SUCCESS ) {

        //
        // free resources locally since a thread was not successfully created;
        // normally, the worker thread will free these resources.
        //

        if( pQueuedSync ) {

            if( pQueuedSync->pvContext )
                CPSFreeContext( pQueuedSync->pvContext );

            SSFree( pQueuedSync );
        }
    }

    return dwLastError;
}



DWORD
WINAPI
QueueSyncMasterKeysThreadFunc(
    IN      LPVOID lpThreadArgument
    )
/*++

    This routine performs asyncronous masterkey synchronization associated
    with the client security context that invoked the operation.

    All masterkeys associated with the security context are queried which
    in turn causes a re-encrypt/sync if necessary.

--*/
{
    PQUEUED_SYNC pQueuedSync = (PQUEUED_SYNC)lpThreadArgument;
    PVOID pvContext = NULL;
    DWORD dwLastError = ERROR_SUCCESS;

    if( pQueuedSync == NULL || 
        pQueuedSync->cbSize != sizeof(QUEUED_SYNC) ||
        pQueuedSync->pvContext == NULL ) 
    {
        dwLastError = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    pvContext = pQueuedSync->pvContext;

    dwLastError = SynchronizeMasterKeys(pvContext, 0);

cleanup:

    RevertToSelf();

    if( pvContext ) 
    {
        CPSFreeContext( pvContext );
    }

    if( pQueuedSync )
        SSFree( pQueuedSync );

    return dwLastError;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReencryptMasterKey
//
//  Synopsis:   Read in the specified (machine) master key file, encrypt it 
//              using the current DPAPI LSA secret, and write it back out.
//              This routine is only called when updating the DPAPI LSA 
//              secret (e.g., by sysprep).
//
//  Arguments:  [pvContext]          -- Server context.
//
//              [pLogonId]           -- User logon session.
//
//              [pszUserStorageArea] -- Path to user profile.
//
//              [pszFilename]        -- Filename of the master key file.
//
//  Returns:    ERROR_SUCCESS if the operation was successful, a Windows
//              error code otherwise.
//
//  History:    
//
//  Notes:      This function should only be called for machine master keys,
//              since these are typically the only ones that are encrypted 
//              using the LSA secret.
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ReencryptMasterKey(
    PVOID pvContext,
    PLUID pLogonId,
    LPWSTR pszUserStorageArea,
    LPWSTR pszFilename)
{
    MASTERKEY_STORED hMasterKey;
    DWORD   cbFilePath;
    LPBYTE  pbMasterKey;
    DWORD   cbMasterKey;
    GUID    guidMasterKey;
    BYTE    rgbMKEncryptionKey[A_SHA_DIGEST_LEN];
    BOOL    fUserCredentialValid;
    GUID CredentialID;
    DWORD dwLastError;

    //
    // Validate input parameters.
    //

    if((pszUserStorageArea == NULL) || (pszFilename == NULL))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(WSZ_BYTECOUNT(pszFilename) > sizeof(hMasterKey.wszguidMasterKey))
    {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Initialize master key memory block.
    //

    ZeroMemory( &hMasterKey, sizeof(hMasterKey) );

    hMasterKey.fModified = TRUE;

    cbFilePath = WSZ_BYTECOUNT(pszUserStorageArea);
    hMasterKey.szFilePath = (LPWSTR)SSAlloc( cbFilePath );
    if(hMasterKey.szFilePath == NULL) 
    {
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        return dwLastError;
    }

    CopyMemory(hMasterKey.szFilePath, pszUserStorageArea, cbFilePath);
    CopyMemory(hMasterKey.wszguidMasterKey, pszFilename, WSZ_BYTECOUNT(pszFilename));


    //
    // read the master key components into memory.
    //

    if(!ReadMasterKey( pvContext, &hMasterKey )) 
    {
        D_DebugLog((DEB_WARN, "ReadMasterKey failed: 0x%x\n", GetLastError()));
        CloseMasterKey(pvContext, &hMasterKey, FALSE);
        return ERROR_NOT_FOUND;
    }

    //
    // read the master key from the cache
    //

    dwLastError = MyGuidFromStringW(hMasterKey.wszguidMasterKey, &guidMasterKey);

    if(dwLastError != ERROR_SUCCESS)
    {
        CloseMasterKey(pvContext, &hMasterKey, FALSE);
        return dwLastError;
    }

    pbMasterKey = NULL;

    if(!SearchMasterKeyCache( pLogonId, &guidMasterKey, &pbMasterKey, &cbMasterKey ))
    {
        D_DebugLog((DEB_ERROR, "Master key %ls not found in cache!\n", hMasterKey.wszguidMasterKey));
        CloseMasterKey(pvContext, &hMasterKey, FALSE);
        return ERROR_NOT_FOUND;
    }


    //
    // Get encryption key
    //

    ZeroMemory(&CredentialID, sizeof(CredentialID));

    fUserCredentialValid = GetMasterKeyUserEncryptionKey(pvContext, 
                                                     &CredentialID,
                                                     NULL, 
                                                     USE_DPAPI_OWF | USE_ROOT_CREDENTIAL, 
                                                     rgbMKEncryptionKey);
    if(fUserCredentialValid)
    {
        hMasterKey.dwPolicy |= POLICY_DPAPI_OWF;
    }
    else
    {
        D_DebugLog((DEB_ERROR, "Unable to get user encryption key\n"));
        CloseMasterKey(pvContext, &hMasterKey, FALSE);
        return ERROR_NOT_FOUND;
    }


    //
    // re-encrypt the masterkey.
    //

    dwLastError = EncryptMasterKeyToStorage(
                            &hMasterKey,
                            REGVAL_MASTER_KEY,
                            rgbMKEncryptionKey,
                            pbMasterKey,
                            cbMasterKey
                            );

    SSFree(pbMasterKey);

    if(dwLastError != ERROR_SUCCESS)
    {
        D_DebugLog((DEB_WARN, "Error encrypting master key!\n"));
        CloseMasterKey(pvContext, &hMasterKey, FALSE);
        return dwLastError;
    }


    // 
    // Save the master key to disk.
    //

    if(!CloseMasterKey(pvContext, &hMasterKey, TRUE))
    {
        D_DebugLog((DEB_WARN, "Error saving master key!\n"));
        return ERROR_NOT_FOUND;
    }

    return ERROR_SUCCESS;
}


//+---------------------------------------------------------------------------
//
//  Function:   SynchronizeMasterKeys
//
//  Synopsis:   Enumerate all of the master keys, and update their encryption
//              state as necessary.
//
//  Arguments:  [pvContext]     -- Server context.
//
//              [dwMode]        -- Operation to perform on the master keys.
//
//  Returns:    ERROR_SUCCESS if the operation was successful, a Windows
//              error code otherwise.
//
//  History:    
//
//  Notes:      By default, this function will read in each of the master
//              keys belonging to the specified user. If necessary, a key 
//              recovery operation will be done, and the reencrypted key
//              will be written back out to disk.
//
//              If the dwMode parameter is non-zero, then one of the
//              following operations will be done:
//
//              ADD_MASTER_KEY_TO_CACHE 
//                  Read each master key into the master key cache. Fail
//                  if any of the keys cannot be successfully read. This
//                  operation is done before the DPAPI LSA secret is updated.
//
//              REENCRYPT_MASTER_KEY
//                  Re-encrypt each master key (from the cache), and write
//                  them back out to disk. This operation is performed after
//                  the DPAPI LSA secret is updated.
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SynchronizeMasterKeys(
    IN PVOID pvContext,
    IN DWORD dwMode)
{
    LPWSTR szUserStorageArea = NULL;
    BOOL fImpersonated = FALSE;
    DWORD cbUserStorageArea;
    HANDLE hFindData = INVALID_HANDLE_VALUE;
// note: tis a shame that ? doesn't map to wildcard a single character...
//    const WCHAR szFileName[] = L"????????-????-????-????-????????????";
    const WCHAR szFileName[] = L"*";
    LPWSTR szFileMatch = NULL;
    DWORD cbFileMatch;
    WIN32_FIND_DATAW FindFileData;
    DWORD dwLastError;
    PSID *apsidHistory = NULL;
    DWORD cSids = 0;
    DWORD iSid = 0;
    LUID LogonId;
    BOOL fLogonIdValid = FALSE;
    GUID guidMasterKey;

    D_DebugLog((DEB_TRACE_API, "SynchronizeMasterKeys called\n"));
    D_DebugLog((DEB_TRACE_API, "  dwMode: 0x%x\n", dwMode));


    //
    // get LogonId associated with client security context.
    //

    dwLastError = CPSImpersonateClient( pvContext );
    if( dwLastError == ERROR_SUCCESS )
    {
        if(GetThreadAuthenticationId(GetCurrentThread(), &LogonId))
        {
            fLogonIdValid = TRUE;
        }

        CPSRevertToSelf( pvContext );
    }


    // 
    // Get the sid history for this user, so 
    // we can sync all keys
    //
    dwLastError = CPSGetSidHistory(pvContext,
                                   &apsidHistory,
                                   &cSids);
    if(ERROR_SUCCESS != dwLastError)
    {
        goto cleanup;
    }


    for(iSid=0; iSid < cSids; iSid++)
    {
        //
        // get the path to the per-user master key storage area on disk
        //

        dwLastError = CPSGetUserStorageArea( pvContext, 
                                             (iSid > 0)?apsidHistory[iSid]:NULL, 
                                             FALSE, 
                                             &szUserStorageArea );

        if( dwLastError != ERROR_SUCCESS )
        {
            if(dwLastError == ERROR_PATH_NOT_FOUND || dwLastError == ERROR_FILE_NOT_FOUND)
            { 
                dwLastError = ERROR_SUCCESS;
            }
            goto cleanup;
        }


        //
        // build the wild card search path.
        //

        cbUserStorageArea = lstrlenW( szUserStorageArea ) * sizeof(WCHAR);
        cbFileMatch = cbUserStorageArea + sizeof(szFileName);

        szFileMatch = (LPWSTR)SSAlloc( cbFileMatch );
        if(NULL == szFileMatch)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        CopyMemory( szFileMatch, szUserStorageArea, cbUserStorageArea );
        CopyMemory( ((LPBYTE)szFileMatch)+cbUserStorageArea, szFileName, sizeof(szFileName) );


        //
        // impersonate the client security context via the duplicated context.
        //

        dwLastError = CPSImpersonateClient( pvContext );
        if( dwLastError != ERROR_SUCCESS )
            goto cleanup;

        fImpersonated = TRUE;

        //
        // now enumerate the files looking for ones that look interesting.
        //

        hFindData = FindFirstFileW( szFileMatch, &FindFileData );

        if( hFindData == INVALID_HANDLE_VALUE )
            goto cleanup;

        do {
            LPBYTE pbMasterKey = NULL;
            DWORD cbMasterKey = 0;
            DWORD dwMasterKeyDisposition;

            if( FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                continue;

            //
            // ignore files which don't look like a textual GUID.
            //

            if( lstrlenW( FindFileData.cFileName ) != 36 )
                continue;

            if( FindFileData.cFileName[ 8  ] != L'-' ||
                FindFileData.cFileName[ 13 ] != L'-' ||
                FindFileData.cFileName[ 18 ] != L'-' ||
                FindFileData.cFileName[ 23 ] != L'-' ) {

                continue;
            }

            switch(dwMode)
            {
            case ADD_MASTER_KEY_TO_CACHE:

                //
                // Add this master key to the master key cache. Abort the
                // entire function if the operation is not successful for
                // any reason.
                //

                if(!fLogonIdValid)
                {
                    dwLastError = ERROR_ACCESS_DENIED;
                    goto cleanup;
                }

                dwLastError = MyGuidFromStringW(FindFileData.cFileName, &guidMasterKey);
                if(dwLastError != ERROR_SUCCESS)
                { 
                    goto cleanup;
                }

                // Fetch the specified key.
                if(!GetMasterKey(pvContext,
                                 szUserStorageArea,
                                 apsidHistory[iSid],         
                                 iSid > 0,
                                 FindFileData.cFileName,
                                 &pbMasterKey,
                                 &cbMasterKey,
                                 &dwMasterKeyDisposition))
                {
                    dwLastError = ERROR_ACCESS_DENIED;
                    goto cleanup;
                }

                // Add the key to the cache.
                if(!InsertMasterKeyCache(&LogonId,
                                         &guidMasterKey,
                                         pbMasterKey,
                                         cbMasterKey))
                {
                    if(pbMasterKey) 
                    {
                        RtlSecureZeroMemory( pbMasterKey, cbMasterKey );
                        SSFree( pbMasterKey );
                    }
                    dwLastError = ERROR_ACCESS_DENIED;
                    goto cleanup;
                }

                // Scrub and free the master key.
                if(pbMasterKey) 
                {
                    RtlSecureZeroMemory( pbMasterKey, cbMasterKey );
                    SSFree( pbMasterKey );
                }
                
                break;


            case REENCRYPT_MASTER_KEY:
                //
                // The DPAPI LSA secret has changed, so read the master key 
                // from the cache and reencrypt it to storage. This mode will
                // only be used for the local machine master keys.
                //

                if(!fLogonIdValid)
                {
                    dwLastError = ERROR_ACCESS_DENIED;
                    goto cleanup;
                }

                // Ignore the returned error code, since there's little
                // we can do about it now...
                ReencryptMasterKey(pvContext,
                                   &LogonId,
                                   szUserStorageArea,
                                   FindFileData.cFileName);

                break;


            default:

                //
                // fetch the specified key; this will cause a credential re-sync
                // if necessary.
                //

                if(GetMasterKey(
                            pvContext,
                            szUserStorageArea,
                            apsidHistory[iSid],         
                            iSid > 0,
                            FindFileData.cFileName,
                            &pbMasterKey,
                            &cbMasterKey,
                            &dwMasterKeyDisposition
                            ) )
        
                {
                    // Scrub and free the master key.
                    if( pbMasterKey ) 
                    {
                        RtlSecureZeroMemory( pbMasterKey, cbMasterKey );
                        SSFree( pbMasterKey );
                    }
                }

                break;
            }

        } while( FindNextFileW( hFindData, &FindFileData ) );

        dwLastError = ERROR_SUCCESS;

        SSFree(szUserStorageArea);
        szUserStorageArea = NULL;
    }


cleanup:

    if( pvContext ) 
    {
        if( fImpersonated )
            CPSRevertToSelf( pvContext );
    }

    if( hFindData != INVALID_HANDLE_VALUE )
        FindClose( hFindData );

    if( szUserStorageArea )
        SSFree( szUserStorageArea );

    if( szFileMatch )
        SSFree( szFileMatch );

    if(apsidHistory)
        SSFree( apsidHistory );

    D_DebugLog((DEB_TRACE_API, "SynchronizeMasterKeys returned 0x%x\n", dwLastError));

    return dwLastError;
}


VOID
DPAPISynchronizeMasterKeys(
    IN HANDLE hUserToken)
{
    CRYPT_SERVER_CONTEXT ServerContext;
    BOOL fContextCreated = FALSE;
    HANDLE hOldUser = NULL;
    DWORD dwError;

    D_DebugLog((DEB_TRACE_API, "DPAPISynchronizeMasterKeys\n"));

    //
    // Create a server context.
    //

    if(hUserToken)
    {
        if(!OpenThreadToken(GetCurrentThread(), 
                        TOKEN_IMPERSONATE | TOKEN_READ,
                        TRUE, 
                        &hOldUser)) 
        {
            hOldUser = NULL;
        }

        if(!ImpersonateLoggedOnUser(hUserToken))
        {
            dwError = GetLastError();
            CloseHandle(hOldUser);
            goto cleanup;
        }
    }

    dwError = CPSCreateServerContext(&ServerContext, NULL);

    if(hOldUser)
    {
        if (!SetThreadToken(NULL, hOldUser))
        {
            if (ERROR_SUCCESS == dwError) 
            {
                dwError = GetLastError();
                fContextCreated = TRUE;
            }
        }
        CloseHandle(hOldUser);
        hOldUser = NULL;
    }

    if(dwError != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    fContextCreated = TRUE;

   
    //
    // Synchronize the master keys. 
    //

    dwError = InitiateSynchronizeMasterKeys(&ServerContext);

    if(dwError != ERROR_SUCCESS)
    {
        goto cleanup;
    }


cleanup:

    if(fContextCreated)
    {
        CPSDeleteServerContext( &ServerContext );
    }

    D_DebugLog((DEB_TRACE_API, "DPAPISynchronizeMasterKeys returned 0x%x\n", dwError));
}


DWORD
GetSpecifiedMasterKey(
    IN      PVOID pvContext,        // server context
    IN  OUT GUID *pguidMasterKey,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
    IN      BOOL fSpecified         // get specified pguidMasterKey key ?
    )
/*++

    This function returns the caller a decrypted master key.
    If fSpecified is TRUE, the returned master key is the one specified by
    the GUID pointed to by pguidMasterKey.  Otherwise, the returned master key
    is the preferred master key, and pguidMasterKey is filled with the GUID
    value associated with the preferred master key.

    The proper way to utilize the fSpecified parameter is to specify FALSE
    when obtaining a masterkey associated with an encrypt operation;
    specify TRUE and supply valid GUID in pguidMasterKey when doing a decrypt
    operation.  For an encrypt operation, the caller will store the GUID
    returned in pguidMasterKey alongside any data encrypted with that master
    key.

    On success, the return value is ERROR_SUCCESS.  The caller must free the buffer
    pointed to by ppbMasterKey using SSFree() when finished with it.  The
    caller should keep this buffer around for the shortest possible time, to
    avoid pagefile exposure.

    On failure, the return value is not ERROR_SUCCESS.  The caller need not free the
    buffer pointed to ppbMasterKey.

--*/
{

    LUID LogonId;
    BOOL fCached = FALSE;   // masterkey found in cache?

    LPWSTR szUserStorageArea = NULL;

    DWORD dwMasterKeyDisposition = 0;

    DWORD dwLocalError;
    DWORD dwLastError;
    BOOL fSetPreferred = FALSE; // update preferred guid?
    BOOL fSuccess = FALSE;
    PSID *apsidHistory = NULL;
    DWORD cSids = 0;
    DWORD i;
    NTSTATUS Status;

    D_DebugLog((DEB_TRACE_API, "GetSpecifiedMasterKey called\n"));

    //
    // get LogonId associated with client security context.
    //

    dwLastError = CPSImpersonateClient( pvContext );
    if( dwLastError != ERROR_SUCCESS )
    {
        D_DebugLog((DEB_TRACE_API, "GetSpecifiedMasterKey returned 0x%x\n", dwLastError));
        return dwLastError;
    }

    fSuccess = GetThreadAuthenticationId(GetCurrentThread(), &LogonId);
    if( !fSuccess )
    {
        dwLastError = GetLastError();
    }
    CPSRevertToSelf( pvContext );

    if( !fSuccess )
    {
        D_DebugLog((DEB_TRACE_API, "GetSpecifiedMasterKey returned 0x%x\n", dwLastError));
        return dwLastError;
    }

    fSuccess = FALSE;


    //
    // Get the preferred key GUID if no master key was specified by name.
    //

    if( !fSpecified ) 
    {
        //
        // get the path to the per-user master key storage area on disk
        //

        dwLastError = CPSGetUserStorageArea( pvContext, NULL, TRUE, &szUserStorageArea );

        if(dwLastError != ERROR_SUCCESS)
        {
            D_DebugLog((DEB_WARN, "CPSGetUserStorageArea failed: 0x%x\n", dwLastError));
            goto cleanup;
        }

        D_DebugLog((DEB_TRACE, "Master key user path: %ls\n", szUserStorageArea));


        //
        // determine what is the preferred master key.
        // if none exists, create one, and set it as being preferred.
        //

        Status = GetPreferredMasterKeyGuid( pvContext, szUserStorageArea, pguidMasterKey );
        if(!NT_SUCCESS(Status))
        {
            if(Status == STATUS_PASSWORD_EXPIRED)
            {
                GUID guidNewMasterKey;

                // A preferred master key exists, but it has expired. Attempt to generate
                // a new master key, but fall back to the old one if we're unable to 
                // create a proper backup for the new master key.
                dwLastError = CreateMasterKey( pvContext, szUserStorageArea, &guidNewMasterKey, TRUE );
                if(dwLastError == ERROR_SUCCESS)
                {
                    // Use new key.
                    memcpy(pguidMasterKey, &guidNewMasterKey, sizeof(GUID));

                    // update preferred guid.
                    fSetPreferred = TRUE;
                }
            }
            else
            {
                // No preferred master key currently exists, so generate a new one.
                dwLastError = CreateMasterKey( pvContext, szUserStorageArea, pguidMasterKey, FALSE );
                if(dwLastError != ERROR_SUCCESS)
                {
                    goto cleanup;
                }

                // update preferred guid.
                fSetPreferred = TRUE;
            }
        }
    }


    //
    // search cache for specified masterkey.
    //

    if(SearchMasterKeyCache( &LogonId, pguidMasterKey, ppbMasterKey, pcbMasterKey ))
    {
        D_DebugLog((DEB_TRACE, "Master key found in cache.\n"));

        fCached = TRUE;
        fSuccess = TRUE;
        goto cleanup;
    }


    //
    // get the path to the per-user master key storage area on disk
    //

    if(szUserStorageArea == NULL)
    {
        dwLastError = CPSGetUserStorageArea( pvContext, NULL, TRUE, &szUserStorageArea );

        if(dwLastError != ERROR_SUCCESS)
        {
            D_DebugLog((DEB_WARN, "CPSGetUserStorageArea failed: 0x%x\n", dwLastError));
            goto cleanup;
        }

        D_DebugLog((DEB_TRACE, "Master key user path: %ls\n", szUserStorageArea));
    }


    //
    // If it's not in the cache, we need to load it.  
    // By default, we have the users primary sid
    //
    cSids = 1;

    if(fSpecified)
    {
        //
        // If the GUID was specified, we need to find it, so get
        // the SID History so we can search all SIDS the user has
        // been for this one.
        //
        dwLastError = CPSGetSidHistory(pvContext,
                                       &apsidHistory,
                                       &cSids);
        if(ERROR_SUCCESS != dwLastError)
        {
            D_DebugLog((DEB_WARN, "CPSGetSidHistory failed: 0x%x\n", dwLastError));
            goto cleanup;
        }
    }

    for(i=0; i < cSids; i++)
    {

        if((fSpecified) && (i > 0))
        {
            // for sid's beyond the 0th one (the current user's sid), 
            // we need to grab the new storage area.
            if(szUserStorageArea)
            {
                SSFree(szUserStorageArea);
                szUserStorageArea = NULL;
            }
            dwLocalError = CPSGetUserStorageArea( pvContext, 
                                              apsidHistory[i], 
                                              FALSE, 
                                              &szUserStorageArea );

            if(dwLocalError != ERROR_SUCCESS)
            {
                // There is no storage area for this SID, so try the next
                continue;
            }
        }


        //
        // get the master key.
        //

        fSuccess = GetMasterKeyByGuid(
                        pvContext,
                        szUserStorageArea,
                        (i > 0)?apsidHistory[i]:NULL,
                        i > 0,
                        pguidMasterKey,
                        ppbMasterKey,
                        pcbMasterKey,
                        &dwMasterKeyDisposition);

        D_DebugLog((DEB_TRACE, "GetMasterKeyByGuid disposition: %s\n",
            (dwMasterKeyDisposition == MK_DISP_OK) ? "Normal" :
            (dwMasterKeyDisposition == MK_DISP_BCK_LCL) ? "Local backup" :
            (dwMasterKeyDisposition == MK_DISP_BCK_DC) ? "DC backup" :
            (dwMasterKeyDisposition == MK_DISP_STORAGE_ERR) ? "Storage error" :
            (dwMasterKeyDisposition == MK_DISP_DELEGATION_ERR) ? "Delegation error" :
            "Unknown error"));

        if(!fSuccess)
        {
            if(MK_DISP_STORAGE_ERR != dwMasterKeyDisposition)
            {
                // The disposition was not a storage error, so the key does
                // exist in this area, but there was some other error.
                break;
            }
        }
        else
        {
            break;
        }
    }
    

    //
    // if this was an encrypt operation, and we failed to get at the preferred key,
    // create a new key and set it preferred.
    //

    if(!fSuccess && 
       !fSpecified && 
       ((dwMasterKeyDisposition == MK_DISP_STORAGE_ERR) ||
       (dwMasterKeyDisposition == MK_DISP_DELEGATION_ERR) ))
    {
        dwLastError = CreateMasterKey( pvContext, szUserStorageArea, pguidMasterKey, FALSE );
        if(dwLastError != ERROR_SUCCESS)
            goto cleanup;

        fSuccess = GetMasterKeyByGuid(
                        pvContext,
                        szUserStorageArea,
                        NULL,
                        FALSE,
                        pguidMasterKey,
                        ppbMasterKey,
                        pcbMasterKey,
                        &dwMasterKeyDisposition
                        );

        fSetPreferred = fSuccess;
    }

    if( fSuccess && fSetPreferred ) 
    {

        //
        // masterkey creation succeeded, and usage of the key succeeded.
        // set key as being preferred.
        //

        SetPreferredMasterKeyGuid( pvContext, szUserStorageArea, pguidMasterKey );
    }


cleanup:

    if(szUserStorageArea)
    {
        SSFree(szUserStorageArea);
    }

    if(apsidHistory)
    {
        SSFree(apsidHistory);
    }

    if(fSuccess) 
    {
        //
        // add entry to cache if it wasn't found there.
        //

        if( !fCached )
        {
            InsertMasterKeyCache( &LogonId, pguidMasterKey, *ppbMasterKey, *pcbMasterKey );
        }

        D_DebugLog((DEB_TRACE_API, "GetSpecifiedMasterKey returned 0x%x\n", ERROR_SUCCESS));

        return ERROR_SUCCESS;
    }


    if(dwLastError == ERROR_SUCCESS)
    {
        dwLastError = (DWORD)NTE_BAD_KEY_STATE;
    }

    if(MK_DISP_DELEGATION_ERR == dwMasterKeyDisposition)
    {
        dwLastError = (DWORD)SEC_E_DELEGATION_REQUIRED;
    }

    D_DebugLog((DEB_TRACE_API, "GetSpecifiedMasterKey returned 0x%x\n", dwLastError));

    return dwLastError;
}




DWORD
CreateMasterKey(
    IN  PVOID pvContext,
    IN  LPCWSTR szUserStorageArea,
    OUT GUID *pguidMasterKey,
    IN  BOOL fRequireBackup)
{
    MASTERKEY_STORED hMasterKey;
    DWORD cbFilePath;

    BYTE pbMasterKey[ MASTERKEY_MATERIAL_SIZE ];
    DWORD cbMasterKey = sizeof(pbMasterKey);

    BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN];  // masterkey encryption key

    BYTE pbLocalKey[ LOCALKEY_MATERIAL_SIZE ];
    DWORD cbLocalKey = sizeof(pbLocalKey);
    BYTE rgbLKEncryptionKey[A_SHA_DIGEST_LEN];  // localkey encryption key

    BOOL fUserCredentialValid = FALSE;

    DWORD dwLastError;
    BOOL fSuccess = FALSE;
    BOOL fLocalAccount = FALSE;

    GUID CredentialID;

    D_DebugLog((DEB_TRACE, "CreateMasterKey\n"));

    ZeroMemory(&CredentialID, sizeof(CredentialID));

    //
    // generate new GUID
    //

    dwLastError = UuidCreate( pguidMasterKey );

    if( dwLastError ) {
        if( dwLastError == RPC_S_UUID_LOCAL_ONLY ) {
            dwLastError = ERROR_SUCCESS;
        } else {
            return dwLastError;
        }
    }


    //
    // initialize masterkey
    //


    ZeroMemory( &hMasterKey, sizeof(hMasterKey));
    hMasterKey.dwVersion = MASTERKEY_STORED_VERSION;
    hMasterKey.fModified = TRUE;

    //
    // set initial (default) masterkey policy.
    // Do this whenever we determine a new masterkey is created/selected.
    // This allows us future flexibility if we want to pull policy bits
    // from some admin defined place.
    //

    InitializeMasterKeyPolicy( pvContext, &hMasterKey , &fLocalAccount);

    //
    // copy path to key file into masterkey memory block.
    //

    cbFilePath = (lstrlenW( szUserStorageArea ) + 1) * sizeof(WCHAR);
    hMasterKey.szFilePath = (LPWSTR)SSAlloc( cbFilePath );
    if(hMasterKey.szFilePath == NULL)
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;

    CopyMemory(hMasterKey.szFilePath, szUserStorageArea, cbFilePath);


    if( MyGuidToStringW( pguidMasterKey, hMasterKey.wszguidMasterKey ) != 0 )
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }


    #ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Master key GUID:%ls\n", hMasterKey.wszguidMasterKey));
    #endif

    //
    // generate random masterkey in memory.
    //

    if(!RtlGenRandom(pbMasterKey, cbMasterKey))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    #ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Master key:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", pbMasterKey, cbMasterKey);
    #endif


    //
    // generate random localkey in memory.
    //

    if(!RtlGenRandom(pbLocalKey, cbLocalKey))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    #ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Local key:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", pbLocalKey, cbLocalKey);
    #endif


    //
    // get current masterkey encryption key.
    //

    if(fLocalAccount)
    {
        fUserCredentialValid = GetMasterKeyUserEncryptionKey(pvContext, 
                                                         &CredentialID,
                                                         NULL, 
                                                         USE_DPAPI_OWF | USE_ROOT_CREDENTIAL, 
                                                         rgbMKEncryptionKey);
        if(fUserCredentialValid)
        {
            hMasterKey.dwPolicy |= POLICY_DPAPI_OWF;

            #ifdef COMPILED_BY_DEVELOPER
            D_DebugLog((DEB_TRACE, "MK Encryption key:\n"));
            D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));

            D_DebugLog((DEB_TRACE, "MK Encryption key GUID:\n"));
            D_DPAPIDumpHexData(DEB_TRACE, "  ", (PBYTE)&CredentialID, sizeof(CredentialID));
            #endif
        }
        else
        {
            D_DebugLog((DEB_WARN, "Unable to get SHA OWF user encryption key!\n"));
        }

    }

    if(!fUserCredentialValid)
    {
        //
        // If we couldn't use the DPAPI owf, then do something else
        //
        fUserCredentialValid = GetMasterKeyUserEncryptionKey(pvContext,
                                                             fLocalAccount?(&CredentialID):NULL,
                                                             NULL, 
                                                             USE_ROOT_CREDENTIAL, 
                                                             rgbMKEncryptionKey);

        if(fUserCredentialValid)
        { 
            #ifdef COMPILED_BY_DEVELOPER
            D_DebugLog((DEB_TRACE, "MK Encryption key:\n"));
            D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));

            if(fLocalAccount)
            {
                D_DebugLog((DEB_TRACE, "MK Encryption key GUID:\n"));
                D_DPAPIDumpHexData(DEB_TRACE, "  ", (PBYTE)&CredentialID, sizeof(CredentialID));
            }
            #endif
        }
        else
        {
            D_DebugLog((DEB_WARN, "Unable to get NT OWF user encryption key!\n"));
        }
    }

    //
    // if the user credential is not intact or available, generate a random
    // one for the time being.  When fUserCredentialIntact is FALSE, we also
    // do not attempt to backup/restore the key to phase 1 status.
    // When fUserCredentialIntact eventually becomes TRUE, we will upgrade to
    // phase 2 transparently.
    //

    if( !fUserCredentialValid ) 
    {

        //
        // if no backup was specified in policy, we can't run with an
        // random credential, as it won't be backed up to support temporary
        // credential-less operation (eg: delegation).
        //

        if(fLocalAccount)
        {
            dwLastError = ERROR_ACCESS_DENIED;
            goto cleanup;
        }

        if(hMasterKey.dwPolicy & POLICY_NO_BACKUP)
        {
            dwLastError = ERROR_ACCESS_DENIED;
            goto cleanup;
        }

        RtlGenRandom(rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));

        #ifdef COMPILED_BY_DEVELOPER
        D_DebugLog((DEB_TRACE, "MK Encryption key:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));
        #endif
    }


    if(fLocalAccount)
    {
        //
        // Save the local backup information
        // 

        LOCAL_BACKUP_DATA LocalBackupData;

        LocalBackupData.dwVersion = MASTERKEY_BLOB_LOCALKEY_BACKUP;
        CopyMemory(&LocalBackupData.CredentialID, &CredentialID, sizeof(CredentialID));


        dwLastError = PersistMasterKeyToStorage(
                        &hMasterKey,
                        REGVAL_BACKUP_LCL_KEY,
                        (PBYTE)&LocalBackupData,
                        sizeof(LocalBackupData)
                        );
        if(ERROR_SUCCESS != dwLastError)
        {
            goto cleanup;
        }
    }


    //
    // get localkey user encryption key.
    //

    if(!GetLocalKeyUserEncryptionKey(pvContext, &hMasterKey, rgbLKEncryptionKey))
        goto cleanup;

    #ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "LK Encryption key:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbLKEncryptionKey, sizeof(rgbLKEncryptionKey));
    #endif


    //
    // now, encrypt and store the master key.
    //

    dwLastError = EncryptMasterKeyToStorage(
                    &hMasterKey,
                    REGVAL_MASTER_KEY,
                    rgbMKEncryptionKey,
                    pbMasterKey,
                    cbMasterKey
                    );

    if(dwLastError == ERROR_SUCCESS) 
    {

        //
        // now, encrypt and store the local key.
        //

        dwLastError = EncryptMasterKeyToStorage(
                        &hMasterKey,
                        REGVAL_LOCAL_KEY,
                        rgbLKEncryptionKey,
                        pbLocalKey,
                        cbLocalKey
                        );
    }


    if(dwLastError == ERROR_SUCCESS) 
    {
        BOOL    fPhaseTwo = FALSE;
        fSuccess = TRUE;


        //
        // after creation, do initial backup if necessary.
        //

        if(IsBackupMasterKeyRequired( &hMasterKey, &fPhaseTwo )) 
        {
            DWORD dwBackupError;


            dwBackupError = BackupMasterKey(
                            pvContext,
                            &hMasterKey,
                            pbMasterKey,
                            cbMasterKey,
                            fPhaseTwo,              // phase two backup required?
                            fUserCredentialValid    // async only if cred valid
                            );

            if(dwBackupError != ERROR_SUCCESS)
            {
                if(!fUserCredentialValid || fRequireBackup)
                {
                    //
                    // no valid credential, and backup failed, fail creation of
                    // this key.
                    //

                    dwLastError = SEC_E_DELEGATION_REQUIRED;
                    fSuccess = FALSE;
                }


            }

        }
    }




cleanup:

    RtlSecureZeroMemory(pbMasterKey, sizeof(pbMasterKey));
    RtlSecureZeroMemory(rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));
    RtlSecureZeroMemory(rgbLKEncryptionKey, sizeof(rgbLKEncryptionKey));

    //
    // note: it's possible for a race to occur closing the master key
    // at this point, because the key may be backed up asynchronously.
    // this isn't a problem because when a key is persisted to disk,
    // we will not downgrade the backed up blob to non-backed up, as the
    // CloseMasterKey() code includes logic to prevent that situation from
    // occuring.
    //


    if(!CloseMasterKey(pvContext, &hMasterKey, fSuccess))
        fSuccess = FALSE;

    if(fSuccess)
        return ERROR_SUCCESS;

    if(dwLastError == ERROR_SUCCESS)
        dwLastError = ERROR_INVALID_PARAMETER;

    return dwLastError;
}


BOOL
GetMasterKeyByGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      PSID    pSid,
    IN      BOOL    fMigrate,
    IN      GUID *pguidMasterKey,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
        OUT DWORD *pdwMasterKeyDisposition  // refer to MK_DISP_ constants
    )
{
    WCHAR wszguidMasterKey[MAX_GUID_SZ_CHARS];

    *pdwMasterKeyDisposition = MK_DISP_UNKNOWN_ERR;

    if( MyGuidToStringW( pguidMasterKey, wszguidMasterKey ) != 0 )
        return FALSE;

    return GetMasterKey(
                pvContext,
                szUserStorageArea,
                pSid,
                fMigrate,
                wszguidMasterKey,
                ppbMasterKey,
                pcbMasterKey,
                pdwMasterKeyDisposition
                );
}

BOOL
GetMasterKey(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      PSID    pSid,
    IN      BOOL    fMigrate,
    IN      WCHAR wszMasterKey[MAX_GUID_SZ_CHARS],
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
        OUT DWORD *pdwMasterKeyDisposition
    )
{
    MASTERKEY_STORED hMasterKey;
    DWORD cbFilePath;
    BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN];  // masterkey encryption key
    DWORD dwLastError = (DWORD)NTE_BAD_KEY;
    BOOL fUserCredentialValid;
    BOOL fSuccess = FALSE;
    BOOL fUpgradeEncryption = FALSE;
    LPWSTR wszOldFilePath = NULL;
    GUID CredentialID;

    D_DebugLog((DEB_TRACE_API, "GetMasterKey: %ls\n", wszMasterKey));

    *pdwMasterKeyDisposition = MK_DISP_UNKNOWN_ERR;

    ZeroMemory( &hMasterKey, sizeof(hMasterKey) );

    hMasterKey.fModified = FALSE;

    //
    // copy path to key file into masterkey memory block.
    //

    cbFilePath = (lstrlenW( szUserStorageArea ) + 1) * sizeof(WCHAR);
    hMasterKey.szFilePath = (LPWSTR)SSAlloc( cbFilePath );
    if(hMasterKey.szFilePath == NULL) 
    {
        SetLastError( ERROR_NOT_ENOUGH_SERVER_MEMORY );
        return FALSE;
    }

    CopyMemory(hMasterKey.szFilePath, szUserStorageArea, cbFilePath);
    CopyMemory(hMasterKey.wszguidMasterKey, wszMasterKey, sizeof(hMasterKey.wszguidMasterKey));

    //
    // read the masterkey components into memory.
    //

    if(!ReadMasterKey( pvContext, &hMasterKey )) 
    {
        D_DebugLog((DEB_WARN, "ReadMasterKey failed: 0x%x\n", GetLastError()));
        SetLastError( (DWORD)NTE_BAD_KEY );
        *pdwMasterKeyDisposition = MK_DISP_STORAGE_ERR;
        return FALSE;
    }

    //
    // get current masterkey encryption key.
    //

    ZeroMemory(&CredentialID, sizeof(CredentialID));

    fUserCredentialValid = GetMasterKeyUserEncryptionKey(pvContext,
                                                         &CredentialID,
                                                         pSid,
                                                         USE_ROOT_CREDENTIAL | 
                                                            ((hMasterKey.dwPolicy & POLICY_DPAPI_OWF)?USE_DPAPI_OWF:0),
                                                         rgbMKEncryptionKey);

    if( fUserCredentialValid ) 
    {

        //
        // retrieve and decrypt MK with current credential.
        // if success, see if pending phase one/two backup required [make it so]
        //

        #ifdef COMPILED_BY_DEVELOPER
        D_DebugLog((DEB_TRACE, "MK decryption key:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbMKEncryptionKey, sizeof(rgbMKEncryptionKey));
        #endif

        dwLastError = DecryptMasterKeyFromStorage(
                            &hMasterKey,
                            REGVAL_MASTER_KEY,
                            rgbMKEncryptionKey,
                            &fUpgradeEncryption,
                            ppbMasterKey,
                            pcbMasterKey
                            );

        #if DBG
            if(dwLastError == ERROR_SUCCESS)
            {
                #ifdef COMPILED_BY_DEVELOPER
                D_DebugLog((DEB_TRACE, "Master key:\n"));
                D_DPAPIDumpHexData(DEB_TRACE, "  ", *ppbMasterKey, *pcbMasterKey);
                #endif
            }
            else
            {
                D_DebugLog((DEB_WARN, "Decryption with current user MK failed\n"));
            }
        #endif
    }
    else
    {
        D_DebugLog((DEB_WARN, "GetMasterKeyUserEncryptionKey failed: 0x%x\n", GetLastError()));
    }

    if( fUpgradeEncryption || fMigrate || (dwLastError != ERROR_SUCCESS )) 
    {

        //
        // if the MK fails to decrypt, attempt recovery.
        //  if recovery succeeds, re-encrypt MK with current credential.
        //

        if(dwLastError != ERROR_SUCCESS)
        {


            dwLastError = RestoreMasterKey(
                                pvContext,
                                pSid,
                                &hMasterKey,
                                dwLastError,
                                ppbMasterKey,
                                pcbMasterKey
                                );

            fUpgradeEncryption = TRUE;
        }



        //
        // If this is a migration, we must get the current real user storage
        // area, not the one that the key was retrieved from.
        //

        if((ERROR_SUCCESS == dwLastError) &&
           (fMigrate))
        {
            wszOldFilePath = hMasterKey.szFilePath;
            hMasterKey.szFilePath = NULL;

            dwLastError = CPSGetUserStorageArea( pvContext, 
                                              NULL, 
                                              FALSE, 
                                              &hMasterKey.szFilePath );
        }

        //
        // recovery succeeded, re-encrypt the masterkey if the user credential
        // is valid.
        // Also re-encrypt if fUpgradeEncryption indicates that we're 
        // not meeting current policy with this master key.
        //

        if( fUpgradeEncryption && (dwLastError == ERROR_SUCCESS )) 
        {

            if( fUserCredentialValid ) 
            {
                D_DebugLog((DEB_TRACE, "Update master key encryption.\n"));

                dwLastError = EncryptMasterKeyToStorage(
                                        &hMasterKey,
                                        REGVAL_MASTER_KEY,
                                        rgbMKEncryptionKey,
                                        *ppbMasterKey,
                                        *pcbMasterKey
                                        );
                
                if(dwLastError != ERROR_SUCCESS)
                {
                    D_DebugLog((DEB_WARN, "Error encrypting master key!\n"));
                }


                // Update the local backup information
                if(dwLastError == ERROR_SUCCESS)
                {
                    LOCAL_BACKUP_DATA LocalBackupData;

                    if(hMasterKey.pbBK != NULL && hMasterKey.cbBK >= sizeof(LocalBackupData))
                    {
                        CopyMemory(&LocalBackupData, hMasterKey.pbBK, sizeof(LocalBackupData));

                        if(LocalBackupData.dwVersion == MASTERKEY_BLOB_LOCALKEY_BACKUP)
                        {
                            #ifdef COMPILED_BY_DEVELOPER
                            D_DebugLog((DEB_TRACE, "New MK encryption key GUID:\n"));
                            D_DPAPIDumpHexData(DEB_TRACE, "  ", (PBYTE)&LocalBackupData.CredentialID, sizeof(LocalBackupData.CredentialID));
                            #endif

                            CopyMemory(&LocalBackupData.CredentialID, &CredentialID, sizeof(CredentialID));

                            PersistMasterKeyToStorage(
                                        &hMasterKey,
                                        REGVAL_BACKUP_LCL_KEY,
                                        (PBYTE)&LocalBackupData,
                                        sizeof(LocalBackupData)
                                        );
                        }
                    }
                }
            }
        }
        
        if(ERROR_SUCCESS != dwLastError)
        {

            //
            // treat recovery failure as storage error so that a new key can
            // be created for Protect operations.
            //
            if(dwLastError == SEC_E_DELEGATION_REQUIRED)
            {
                *pdwMasterKeyDisposition = MK_DISP_DELEGATION_ERR;
            }
            else
            {
                *pdwMasterKeyDisposition = MK_DISP_STORAGE_ERR;
            }
        }
    }



    if( dwLastError == ERROR_SUCCESS ) 
    {

        //
        // after access, do backup if necessary.
        // we check this each access to see if deferred backup required.
        // (note: employ a back-off interval so we don't bang the network
        // constantly when it isn't around).
        //

        BOOL fPhaseTwo;

        if(fUserCredentialValid && IsBackupMasterKeyRequired( &hMasterKey, &fPhaseTwo )) 
        {
            if(BackupMasterKey(
                            pvContext,
                            &hMasterKey,
                            *ppbMasterKey,
                            *pcbMasterKey,
                            fPhaseTwo,  // phase two backup required?
                            TRUE        // always asynchronous during key retrieve
                            ) == ERROR_SUCCESS) 
            {

                if(fPhaseTwo)
                    *pdwMasterKeyDisposition = MK_DISP_BCK_DC;
                else
                    *pdwMasterKeyDisposition = MK_DISP_BCK_LCL;
            }
        }

        if( *pdwMasterKeyDisposition == MK_DISP_UNKNOWN_ERR )
        {
            *pdwMasterKeyDisposition = MK_DISP_OK;
        }

        fSuccess = TRUE;
    }

    if(!CloseMasterKey(pvContext, &hMasterKey, fSuccess))
    {
        fSuccess = FALSE;
    }

    if(fSuccess && (NULL != wszOldFilePath))
    {
        LPWSTR wszDeleteFilePath = NULL;
        // Delete the old key, now that the new one has been migrated.

        wszDeleteFilePath = (LPWSTR)SSAlloc((wcslen(wszOldFilePath) +
                                    wcslen(wszMasterKey) +
                                    2) * sizeof(WCHAR));
        if(NULL != wszDeleteFilePath)
        {
            wcscpy(wszDeleteFilePath, wszOldFilePath);
            wcscat(wszDeleteFilePath, L"\\");
            wcscat(wszDeleteFilePath, wszMasterKey);

            DeleteFile(wszDeleteFilePath);
            SSFree(wszDeleteFilePath);
        }
    }
    return fSuccess;
}

BOOL
GetMasterKeyUserEncryptionKey(
    IN      PVOID   pvContext,
    OUT     GUID    *pCredentialID,
    IN      PSID    pSid,
    IN      DWORD   dwFlags,
    IN  OUT BYTE    rgbMKEncryptionKey[A_SHA_DIGEST_LEN]
    )
/*++

    This routine gets the key used to encrypt and decrypt the persisted
    master key MK.  This routine returns a copy of a function of the per-user
    logon credential used during Windows NT logon.

    If the function succeeds, the return value is TRUE, and the buffer
    specified with by the rgbMKEncryptionKey parameter is filled with the
    masterkey encryption key.

    The return value is FALSE if the encryption key could not be obtained.

--*/
{
    BOOL fLocalMachine = FALSE;
    DWORD dwAccount = 0;
    LPWSTR pszUserName = NULL;
    DWORD cchUserName;
    DWORD dwLastError;
    BOOL fSystemCred = FALSE;
    BOOL fSuccess = TRUE;


    //
    // see if the call is for shared, CRYPT_PROTECT_LOCAL_MACHINE
    // disposition.
    //

    CPSOverrideToLocalSystem(
                pvContext,
                NULL,       // don't change current over-ride BOOL
                &fLocalMachine
                );

    CPSQueryWellKnownAccount(
                pvContext,
                &dwAccount);


    //
    // if the context specified per-machine, we know that it's a system credential.
    // also, we don't need to get the user name in this scenario.
    //

    if(fLocalMachine || (dwAccount != 0))
    {
        fSystemCred = TRUE;
    }

    if( !fSystemCred ) 
    {

        if(pSid)
        {
            WCHAR wszTextualSid[MAX_PATH+1];
            cchUserName = MAX_PATH+1;
            if(!GetTextualSid(pSid, wszTextualSid, &cchUserName))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            pszUserName = (LPWSTR)SSAlloc(cchUserName*sizeof(WCHAR));
            if(NULL == pszUserName)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            wcscpy(pszUserName, wszTextualSid);
            cchUserName = wcslen(pszUserName) + 1;
        }
        else
        {
            //
            // use the user name (actually Sid), as the mixing bytes.
            //

            dwLastError = CPSGetUserName(
                                            pvContext,
                                            &pszUserName,
                                            &cchUserName
                                            );

            if( dwLastError != ERROR_SUCCESS ) 
            {
                SetLastError( dwLastError );
                return FALSE;
            }
        }
    }


    //
    // pickup credential for the local system account.
    //

    if( fSystemCred ) 
    {

        dwLastError = CPSGetSystemCredential(
                                        pvContext,
                                        fLocalMachine,
                                        rgbMKEncryptionKey
                                        );
        if(pCredentialID)
        {
            ZeroMemory(pCredentialID, sizeof(GUID));
        }

    } 
    else 
    {

        dwLastError = CPSGetDerivedCredential(
                                        pvContext,
                                        pCredentialID,
                                        dwFlags,
                                        (PBYTE)pszUserName,
                                        cchUserName * sizeof(WCHAR),
                                        rgbMKEncryptionKey
                                        );
    }

    if( pszUserName )
        SSFree( pszUserName );

    if( dwLastError != ERROR_SUCCESS ) 
    {
        SetLastError( dwLastError );
        fSuccess = FALSE;
    }

    return fSuccess;
}

BOOL
GetLocalKeyUserEncryptionKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN  OUT BYTE rgbLKEncryptionKey[A_SHA_DIGEST_LEN]
    )
/*++

    This routine gets the key used to encrypt and decrypt the persisted
    local key MK.  This routine returns a copy of a function of the per-user
    logon name or Sid.  This is a fixed, derivable key which is required in
    order to satisfy minimal stand-alone entropy.

    If the function succeeds, the return value is TRUE, and the buffer
    specified with by the rgbLKEncryptionKey parameter is filled with the
    masterkey encryption key.

    The return value is FALSE if the encryption key could not be obtained.

--*/
{
    A_SHA_CTX shaContext;
    LPWSTR wszUserName;
    DWORD cchUserName;  // includes terminal NULL
    BOOL fSuccess = TRUE;

    if( CPSGetUserName(
                            pvContext,
                            &wszUserName,
                            &cchUserName
                            ) != ERROR_SUCCESS) {
        return FALSE;
    }

    A_SHAInit( &shaContext );
    A_SHAUpdate( &shaContext, (PBYTE)wszUserName, cchUserName * sizeof(WCHAR) );


    //
    // if it's above version 1, and it's local only policy, mix in LSA keys.
    //

    if( phMasterKey->dwVersion > 1 && phMasterKey->dwPolicy & POLICY_LOCAL_BACKUP ) {
        BYTE rgbEncryptionKey[ A_SHA_DIGEST_LEN ];
        DWORD dwLastError;

        dwLastError = CPSGetSystemCredential(
                                        pvContext,
                                        TRUE,
                                        rgbEncryptionKey
                                        );

        if( dwLastError == ERROR_SUCCESS ) {

            A_SHAUpdate( &shaContext, rgbEncryptionKey, sizeof(rgbEncryptionKey) );

            dwLastError = CPSGetSystemCredential(
                                            pvContext,
                                            FALSE,
                                            rgbEncryptionKey
                                            );

            A_SHAUpdate( &shaContext, rgbEncryptionKey, sizeof(rgbEncryptionKey) );

        }

        RtlSecureZeroMemory( rgbEncryptionKey, sizeof(rgbEncryptionKey) );

        if( dwLastError != ERROR_SUCCESS )
            fSuccess = FALSE;
    }


    A_SHAFinal( &shaContext, rgbLKEncryptionKey );

    SSFree(wszUserName);

    return fSuccess;
}

DWORD
DecryptMasterKeyToMemory(
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      PBYTE pbMasterKeyIn,
    IN      DWORD cbMasterKeyIn,
        OUT BOOL *pfUpgradeEncryption, 
        OUT PBYTE *ppbMasterKeyOut,
        OUT DWORD *pcbMasterKeyOut
    )
{
    PMASTERKEY_BLOB pMasterKeyBlob;
    DWORD cbMasterKeyBlob = cbMasterKeyIn;
    PMASTERKEY_INNER_BLOB pMasterKeyInnerBlob;
    DWORD cIterationCount = 0;
    DWORD cbMasterKeyBlobHeader;

    PBYTE pbMasterKey;
    DWORD cbMasterKey;
    ALG_ID EncryptionAlg = CALG_RC4;
    ALG_ID PKCS5Alg      = CALG_HMAC;


    BYTE rgbSymKey[A_SHA_DIGEST_LEN*2]; // big enough to handle 3des keys
    BYTE rgbMacKey[A_SHA_DIGEST_LEN];
    BYTE rgbMacCandidate[A_SHA_DIGEST_LEN];

    DWORD dwLastError = (DWORD)NTE_BAD_KEY;
    DWORD KeyBlocks = 1;

    if(pfUpgradeEncryption)
    {
        *pfUpgradeEncryption = FALSE;
    }
    //
    // Alloc, so we do not modify passed in data
    //
    pMasterKeyBlob = (PMASTERKEY_BLOB)SSAlloc( cbMasterKeyBlob );
    if(pMasterKeyBlob == NULL)
        return (DWORD)NTE_BAD_KEY;

    CopyMemory( pMasterKeyBlob, pbMasterKeyIn, cbMasterKeyBlob );


    if(pMasterKeyBlob->dwVersion > MASTERKEY_BLOB_VERSION)
        goto cleanup;

    if(MASTERKEY_BLOB_VERSION_W2K == pMasterKeyBlob->dwVersion)
    {
        pMasterKeyInnerBlob = 
            (PMASTERKEY_INNER_BLOB)(((PMASTERKEY_BLOB_W2K)pMasterKeyBlob) + 1);
        cIterationCount = 0;
        cbMasterKeyBlobHeader = sizeof(MASTERKEY_BLOB_W2K);
    }
    else
    {
        pMasterKeyInnerBlob = (PMASTERKEY_INNER_BLOB)(pMasterKeyBlob + 1);
        cIterationCount = pMasterKeyBlob->IterationCount;
        cbMasterKeyBlobHeader = sizeof(MASTERKEY_BLOB);
        PKCS5Alg = (ALG_ID)pMasterKeyBlob->KEYGENAlg;
        EncryptionAlg = (ALG_ID)pMasterKeyBlob->EncryptionAlg;
        if(CALG_3DES == EncryptionAlg)
        {
            KeyBlocks = 2;  // enough blocks for 3des
        }
        else
        {
            KeyBlocks = 1;
        }
    }
    if(pfUpgradeEncryption)
    {
        if(!FIsLegacyCompliant())
        {
            // 
            // If we're not in legacy mode, upgrade the master key encryption
            // if we're not using CALG_3DES or enough iterations
            if((cIterationCount < GetIterationCount()) ||
                (CALG_3DES != EncryptionAlg))
            {
                *pfUpgradeEncryption = TRUE;
            }
        }
    }



    if(cIterationCount)
    {
        DWORD j;
        
        //
        // derive symetric key via rgbMKEncryptionKey and random R2
        // using PKCS#5 keying function PBKDF2
        //

        for(j=0; j < KeyBlocks; j++)
        {
            if(!PKCS5DervivePBKDF2( rgbMKEncryptionKey,
                                A_SHA_DIGEST_LEN,
                                pMasterKeyBlob->R2,
                                MASTERKEY_R2_LEN,
                                PKCS5Alg,
                                cIterationCount,
                                j+1,
                                rgbSymKey + j*A_SHA_DIGEST_LEN))
                goto cleanup;
        }

    }
    else
    {
        //
        // derive symetric key via rgbMKEncryptionKey and random R2
        // using the weak W2K mechanism
        //

        if(!FMyPrimitiveHMACParam(
                        rgbMKEncryptionKey,
                        A_SHA_DIGEST_LEN,
                        pMasterKeyBlob->R2,
                        MASTERKEY_R2_LEN,
                        rgbSymKey
                        ))
                goto cleanup;
    }




    //
    // decrypt data R3, MAC, pbMasterKey beyond masterkey blob
    //

    if(CALG_RC4 == EncryptionAlg)
    {

        RC4_KEYSTRUCT sRC4Key;        //
        // initialize rc4 key
        //

        rc4_key(&sRC4Key, A_SHA_DIGEST_LEN, rgbSymKey);

        rc4(&sRC4Key, 
            cbMasterKeyBlob - cbMasterKeyBlobHeader, 
            (PBYTE)pMasterKeyInnerBlob);
    }
    else if (CALG_3DES == EncryptionAlg)
    {

        DES3TABLE s3DESKey;
        BYTE InputBlock[DES_BLOCKLEN];
        DWORD iBlock;
        DWORD cBlocks = (cbMasterKeyBlob - cbMasterKeyBlobHeader)/DES_BLOCKLEN;
        BYTE feedback[ DES_BLOCKLEN ];
        // initialize 3des key
        //

        if(cBlocks*DES_BLOCKLEN != (cbMasterKeyBlob - cbMasterKeyBlobHeader))
        {
            // Master key must be a multiple of DES_BLOCKLEN
            return (DWORD)NTE_BAD_KEY;
        }
        tripledes3key(&s3DESKey, rgbSymKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated 
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, rgbSymKey + DES3_KEYSIZE, DES_BLOCKLEN);

        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {
            CopyMemory(InputBlock, 
                       ((PBYTE)pMasterKeyInnerBlob)+iBlock*DES_BLOCKLEN,
                       DES_BLOCKLEN);
            CBC(tripledes,
                DES_BLOCKLEN,
                ((PBYTE)pMasterKeyInnerBlob)+iBlock*DES_BLOCKLEN,
                InputBlock,
                &s3DESKey,
                DECRYPT,
                feedback);
        }
    }
    else
    {
        // Unknown cipher....
        return (DWORD)NTE_BAD_KEY;
    }
    //
    // adjust cipher start point to include R3 and MAC.
    //
    if(MASTERKEY_BLOB_VERSION_W2K == pMasterKeyBlob->dwVersion)
    {
        pbMasterKey = 
            (PBYTE)(((PMASTERKEY_INNER_BLOB_W2K)pMasterKeyInnerBlob) + 1);
        cbMasterKey = cbMasterKeyBlob - cbMasterKeyBlobHeader - sizeof(MASTERKEY_INNER_BLOB_W2K);

    }
    else
    {
        pbMasterKey = (PBYTE)(pMasterKeyInnerBlob + 1);
        cbMasterKey = cbMasterKeyBlob - cbMasterKeyBlobHeader - sizeof(MASTERKEY_INNER_BLOB);
    }

    //
    // derive MAC key via HMAC from rgbMKEncryptionKey and random R3.
    //


    
    if(!FMyPrimitiveHMACParam(
                    rgbMKEncryptionKey,
                    A_SHA_DIGEST_LEN,
                    pMasterKeyInnerBlob->R3,
                    MASTERKEY_R3_LEN,
                    rgbMacKey
                    ))
    {
        goto cleanup;
    }







    //
    // use MAC key to derive result from pbMasterKey
    //

    if(!FMyPrimitiveHMACParam(
            rgbMacKey,
            sizeof(rgbMacKey),
            pbMasterKey,
            cbMasterKey,
            rgbMacCandidate // resultant MAC for verification.
            ))
        goto cleanup;

    //
    // verify MAC equality
    //

    if(memcmp(pMasterKeyInnerBlob->MAC, rgbMacCandidate, A_SHA_DIGEST_LEN) != 0)
        goto cleanup;

    //
    // give caller results.
    //

    *ppbMasterKeyOut = (LPBYTE)SSAlloc( cbMasterKey );
    if(*ppbMasterKeyOut == NULL) {
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }

    CopyMemory(*ppbMasterKeyOut, pbMasterKey, cbMasterKey);
    *pcbMasterKeyOut = cbMasterKey;

    dwLastError = ERROR_SUCCESS;

cleanup:

    if(pMasterKeyBlob) {
        RtlSecureZeroMemory(pMasterKeyBlob, cbMasterKeyBlob);
        SSFree( pMasterKeyBlob );
    }

    return dwLastError;
}

DWORD
DecryptMasterKeyFromStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
        OUT BOOL  *pfUpgradeEncryption,
        OUT PBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey
    )
{
    PBYTE pbRegData;
    DWORD cbRegData;

    //
    // fetch blob from storage.
    //

    switch( dwMKLoc ) {
        case REGVAL_MASTER_KEY:
            pbRegData = phMasterKey->pbMK;
            cbRegData = phMasterKey->cbMK;
            break;
        case REGVAL_LOCAL_KEY:
            pbRegData = phMasterKey->pbLK;
            cbRegData = phMasterKey->cbLK;
            break;
        case REGVAL_BACKUP_LCL_KEY:
            pbRegData = phMasterKey->pbBK;
            cbRegData = phMasterKey->cbBK;
            break;
        case REGVAL_BACKUP_DC_KEY:
            pbRegData = phMasterKey->pbBBK;
            cbRegData = phMasterKey->cbBBK;
            break;

        default:
            return NTE_BAD_KEY;
    }

    if( cbRegData == 0 || pbRegData == NULL )
        return (DWORD)NTE_BAD_KEY;


    return DecryptMasterKeyToMemory(
                        rgbMKEncryptionKey,
                        pbRegData,
                        cbRegData,
                        pfUpgradeEncryption, 
                        ppbMasterKey,
                        pcbMasterKey
                        );
}


DWORD
EncryptMasterKeyToStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey
    )
/*++

    Encrypt the pbMasterKey using rgbMKEncryptionKey, storing (persisting) the
    result to the registry key and location specified by hMasterKey, wszMKLoc.

--*/
{
    PBYTE pbMasterKeyOut = NULL;
    DWORD cbMasterKeyOut;
    DWORD dwLastError;
    DWORD dwIterationCount = 1;

    D_DebugLog((DEB_TRACE_API, "EncryptMasterKeyToStorage\n"));

    if(dwMKLoc == REGVAL_MASTER_KEY)
    {
        dwIterationCount = GetIterationCount();
    }

    dwLastError = EncryptMasterKeyToMemory(
                    rgbMKEncryptionKey,
                    dwIterationCount,
                    pbMasterKey,
                    cbMasterKey,
                    &pbMasterKeyOut,
                    &cbMasterKeyOut
                    );

    if(dwLastError != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    dwLastError = PersistMasterKeyToStorage(
                    phMasterKey,
                    dwMKLoc,
                    pbMasterKeyOut,
                    cbMasterKeyOut
                    );

    if( pbMasterKeyOut ) {
        RtlSecureZeroMemory(pbMasterKeyOut, cbMasterKeyOut);
        SSFree(pbMasterKeyOut);
    }

cleanup:

    D_DebugLog((DEB_TRACE_API, "EncryptMasterKeyToStorage returned 0x%x\n", dwLastError));

    return dwLastError;
}

DWORD
PersistMasterKeyToStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN      PBYTE pbMasterKeyOut,
    IN      DWORD cbMasterKeyOut
    )
/*++

    Persist the specified key output material to storage.

--*/
{
    PBYTE *ppbData;
    DWORD *pcbData;

    //
    // fetch blob from storage.
    //

    switch( dwMKLoc ) {
        case REGVAL_MASTER_KEY:
            ppbData = &(phMasterKey->pbMK);
            pcbData = &(phMasterKey->cbMK);
            break;
        case REGVAL_LOCAL_KEY:
            ppbData = &(phMasterKey->pbLK);
            pcbData = &(phMasterKey->cbLK);
            break;
        case REGVAL_BACKUP_LCL_KEY:
            ppbData = &(phMasterKey->pbBK);
            pcbData = &(phMasterKey->cbBK);
            break;
        case REGVAL_BACKUP_DC_KEY:
            ppbData = &(phMasterKey->pbBBK);
            pcbData = &(phMasterKey->cbBBK);
            break;

        default:
            return NTE_BAD_KEY;
    }


    if( pbMasterKeyOut == NULL && cbMasterKeyOut == 0 ) {

        //
        // discard existing block if present.
        //

        if( *ppbData ) {
            RtlSecureZeroMemory( *ppbData, *pcbData );
            SSFree( *ppbData );
        }

        *ppbData = NULL;
        *pcbData = 0;

        return ERROR_SUCCESS;
    }


    //
    // free the in-memory buffer associated with this data block if one
    // was allocated previously.
    //

    if( *ppbData ) {
        RtlSecureZeroMemory( *ppbData, *pcbData );

        if( *pcbData < cbMasterKeyOut ) {
            SSFree( *ppbData );
            *ppbData = (LPBYTE)SSAlloc( cbMasterKeyOut );
        }

    } else {
        *ppbData = (LPBYTE)SSAlloc( cbMasterKeyOut );
    }

    *pcbData = 0;

    if( *ppbData == NULL )
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;


    *pcbData = cbMasterKeyOut ;
    CopyMemory( *ppbData, pbMasterKeyOut, cbMasterKeyOut );

    //
    // a change occured in the master key.
    //

    phMasterKey->fModified = TRUE;

    return ERROR_SUCCESS;
}

DWORD
QueryMasterKeyFromStorage(
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD dwMKLoc,
    IN  OUT PBYTE *ppbMasterKeyOut,
    IN  OUT DWORD *pcbMasterKeyOut
    )
/*++

    Query raw masterkey material from storage, returning a pointer to the
    requested element for the caller.

    On Success, the return value is ERROR_SUCCESS.

--*/
{
    PBYTE pbData;
    DWORD cbData;

    //
    // fetch blob from storage.
    //

    switch( dwMKLoc ) {
        case REGVAL_MASTER_KEY:
            pbData = phMasterKey->pbMK;
            cbData = phMasterKey->cbMK;
            break;
        case REGVAL_LOCAL_KEY:
            pbData = phMasterKey->pbLK;
            cbData = phMasterKey->cbLK;
            break;
        case REGVAL_BACKUP_LCL_KEY:
            pbData = phMasterKey->pbBK;
            cbData = phMasterKey->cbBK;
            break;
        case REGVAL_BACKUP_DC_KEY:
            pbData = phMasterKey->pbBBK;
            cbData = phMasterKey->cbBBK;
            break;

        default:
            return (DWORD)NTE_BAD_KEY;
    }


    if(cbData == 0 || pbData == NULL)
        return (DWORD)NTE_BAD_KEY;

    *ppbMasterKeyOut = pbData;
    *pcbMasterKeyOut = cbData;

    return ERROR_SUCCESS;
}

DWORD
EncryptMasterKeyToMemory(
    IN      BYTE rgbMKEncryptionKey[A_SHA_DIGEST_LEN],
    IN      DWORD cIterationCount,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
        OUT PBYTE *ppbMasterKeyOut,
        OUT DWORD *pcbMasterKeyOut
    )
{
    PMASTERKEY_BLOB pMasterKeyBlob;
    DWORD cbMasterKeyBlob;
    DWORD cbMasterInnerKeyBlob;
    PMASTERKEY_INNER_BLOB pMasterKeyInnerBlob;
    PBYTE pbCipherBegin;

    BYTE rgbMacKey[A_SHA_DIGEST_LEN];

    DWORD dwLastError = (DWORD)NTE_BAD_KEY;

    BOOL  fLegacyBlob = (FIsLegacyCompliant() || (0 == cIterationCount));

    ALG_ID EncryptionAlg = CALG_3DES;
    ALG_ID PKCS5Alg      = CALG_HMAC;


    BYTE rgbSymKey[A_SHA_DIGEST_LEN*2]; // big enough to handle 3des keys

    DWORD KeyBlocks = 1;




    if(!fLegacyBlob)
    {

        cbMasterInnerKeyBlob = sizeof(MASTERKEY_INNER_BLOB) +
                        cbMasterKey ;

        cbMasterKeyBlob = sizeof(MASTERKEY_BLOB) +
                        cbMasterInnerKeyBlob;
    }
    else
    {

        EncryptionAlg = CALG_RC4;

        cbMasterInnerKeyBlob = sizeof(MASTERKEY_INNER_BLOB_W2K) +
                        cbMasterKey ;

        cbMasterKeyBlob = sizeof(MASTERKEY_BLOB_W2K) +
                        cbMasterInnerKeyBlob;

    }

    if(CALG_3DES == EncryptionAlg)
    {
        KeyBlocks = 2;

        if(cbMasterInnerKeyBlob%DES_BLOCKLEN)
        {
            return NTE_BAD_KEY;
        }
    }

    pMasterKeyBlob = (PMASTERKEY_BLOB)SSAlloc( cbMasterKeyBlob );
    if(pMasterKeyBlob == NULL)
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;

    if(!fLegacyBlob)
    {
        pMasterKeyBlob->dwVersion = MASTERKEY_BLOB_VERSION;
        pMasterKeyInnerBlob = (PMASTERKEY_INNER_BLOB)(pMasterKeyBlob + 1);
    }
    else
    {
        pMasterKeyBlob->dwVersion = MASTERKEY_BLOB_VERSION_W2K;
        pMasterKeyInnerBlob = 
            (PMASTERKEY_INNER_BLOB)(((PMASTERKEY_BLOB_W2K)pMasterKeyBlob) + 1);
    }


    //
    // generate random R2 for SymKey
    //

    if(!RtlGenRandom(pMasterKeyBlob->R2, MASTERKEY_R2_LEN))
        goto cleanup;

    //
    // generate random R3 for MAC
    //

    if(!RtlGenRandom(pMasterKeyInnerBlob->R3, MASTERKEY_R3_LEN))
        goto cleanup;


    if(!fLegacyBlob)
    {
        DWORD j;
        //
        // derive symetric key via rgbMKEncryptionKey and random R2
        //

        for(j=0; j < KeyBlocks; j++)
        {
            if(!PKCS5DervivePBKDF2(
                            rgbMKEncryptionKey,
                            A_SHA_DIGEST_LEN,
                            pMasterKeyBlob->R2,
                            MASTERKEY_R2_LEN,
                            PKCS5Alg,
                            cIterationCount,
                            j+1,
                            rgbSymKey+j*A_SHA_DIGEST_LEN
                            ))
                goto cleanup;
        }
        pMasterKeyBlob->IterationCount = cIterationCount;
        pMasterKeyBlob->EncryptionAlg = EncryptionAlg;
        pMasterKeyBlob->KEYGENAlg = PKCS5Alg;

        pbCipherBegin = (PBYTE)(pMasterKeyInnerBlob+1);

    }
    else
    {
        //
        // derive symetric key via rgbMKEncryptionKey and random R2
        //

        if(!FMyPrimitiveHMACParam(
                        rgbMKEncryptionKey,
                        A_SHA_DIGEST_LEN,
                        pMasterKeyBlob->R2,
                        MASTERKEY_R2_LEN,
                        rgbSymKey
                        ))
            goto cleanup;

        pbCipherBegin = (PBYTE)(((PMASTERKEY_INNER_BLOB_W2K)pMasterKeyInnerBlob)+1);

    }

    //
    // derive MAC key via HMAC from rgbMKEncryptionKey and random R3.
    //

    if(!FMyPrimitiveHMACParam(
                    rgbMKEncryptionKey,
                    A_SHA_DIGEST_LEN,
                    pMasterKeyInnerBlob->R3,
                    MASTERKEY_R3_LEN,
                    rgbMacKey   // resultant MAC key
                    ))
    {
        goto cleanup;
    }
    

    //
    // copy pbMasterKey following inner MAC'ish blob.
    //


    CopyMemory( pbCipherBegin, pbMasterKey, cbMasterKey );

    //
    // use MAC key to derive result from pbMasterKey
    //

    if(!FMyPrimitiveHMACParam(
                    rgbMacKey,
                    sizeof(rgbMacKey),
                    pbMasterKey,
                    cbMasterKey,
                    pMasterKeyInnerBlob->MAC // resultant MAC for verification.
                    ))
        goto cleanup;



    if(CALG_RC4 == EncryptionAlg)
    {

        RC4_KEYSTRUCT sRC4Key;        //
        // initialize rc4 key
        //

        rc4_key(&sRC4Key, A_SHA_DIGEST_LEN, rgbSymKey);

        rc4(&sRC4Key, 
            cbMasterInnerKeyBlob, 
            (PBYTE)pMasterKeyInnerBlob);
    }
    else if (CALG_3DES == EncryptionAlg)
    {

        DES3TABLE s3DESKey;
        BYTE InputBlock[DES_BLOCKLEN];
        DWORD iBlock;
        DWORD cBlocks = cbMasterInnerKeyBlob/DES_BLOCKLEN;
        BYTE feedback[ DES_BLOCKLEN ];
        // initialize 3des key
        //

        if(cBlocks*DES_BLOCKLEN != cbMasterInnerKeyBlob)
        {
            // Master key must be a multiple of DES_BLOCKLEN
            return (DWORD)NTE_BAD_KEY;
        }
        tripledes3key(&s3DESKey, rgbSymKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated 
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, rgbSymKey + DES3_KEYSIZE, DES_BLOCKLEN);


        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {
            CopyMemory(InputBlock, 
                       ((PBYTE)pMasterKeyInnerBlob)+iBlock*DES_BLOCKLEN,
                       DES_BLOCKLEN);
            CBC(tripledes,
                DES_BLOCKLEN,
                ((PBYTE)pMasterKeyInnerBlob)+iBlock*DES_BLOCKLEN,
                InputBlock,
                &s3DESKey,
                ENCRYPT,
                feedback);
        }
    }
    else
    {
        // Unknown cipher....
        return (DWORD)NTE_BAD_KEY;
    }


    *ppbMasterKeyOut = (PBYTE)pMasterKeyBlob;
    *pcbMasterKeyOut = cbMasterKeyBlob;

    pMasterKeyBlob = NULL; // prevent free of blob on success (caller does it).

    dwLastError = ERROR_SUCCESS;

cleanup:

    if(pMasterKeyBlob) {
        RtlSecureZeroMemory(pMasterKeyBlob, cbMasterKeyBlob);
        SSFree(pMasterKeyBlob);
    }

    return dwLastError;
}

BOOL
IsBackupMasterKeyRequired(
    IN      PMASTERKEY_STORED phMasterKey,
    IN  OUT BOOL *pfPhaseTwo        // is phase two required?
    )
/*++

    Determine if we need to do a phase one or phase two backup.

    Return value is TRUE if phase one or phase two backup required.
     pfPhaseTwo set TRUE if phase two backup required.

    Return value is FALSE when backup not required.

--*/
{
    DWORD dwMasterKeyPolicy;
    PBYTE pbMasterKeyOut;
    DWORD cbMasterKeyOut;
    DWORD dwLastError;


    dwMasterKeyPolicy = phMasterKey->dwPolicy;

    if(dwMasterKeyPolicy & POLICY_NO_BACKUP)
        return FALSE;


    //
    // evaluate what phase backup required based on policy.
    //

    *pfPhaseTwo = FALSE;

    if(!(dwMasterKeyPolicy & POLICY_LOCAL_BACKUP)) {

        dwLastError = QueryMasterKeyFromStorage(
                            phMasterKey,
                            REGVAL_BACKUP_DC_KEY,
                            &pbMasterKeyOut,
                            &cbMasterKeyOut
                            );


        if(dwLastError != ERROR_SUCCESS) {
            *pfPhaseTwo = TRUE;
            return TRUE;
        }

    } else {

        dwLastError = QueryMasterKeyFromStorage(
                            phMasterKey,
                            REGVAL_BACKUP_LCL_KEY,
                            &pbMasterKeyOut,
                            &cbMasterKeyOut
                            );

        if(dwLastError != ERROR_SUCCESS)
            return TRUE;
    }

    return FALSE;
}


BOOL
IsNT4Domain(void)
{
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle = NULL;
    OBJECT_ATTRIBUTES PolicyObjectAttributes;
    PPOLICY_DNS_DOMAIN_INFO pDnsDomainInfo = NULL;
    BOOL fRet = FALSE;

    InitializeObjectAttributes( &PolicyObjectAttributes,
                                NULL,             // Name
                                0,                // Attributes
                                NULL,             // Root
                                NULL);            // Security Descriptor

    Status = LsaOpenPolicy(NULL,
                           &PolicyObjectAttributes,
                           POLICY_VIEW_LOCAL_INFORMATION,
                           &PolicyHandle);
    if(!NT_SUCCESS(Status))
    {
        goto cleanup;
    }

    Status = LsaQueryInformationPolicy(PolicyHandle,
                                       PolicyDnsDomainInformation,
                                       (PVOID *)&pDnsDomainInfo);
    if(!NT_SUCCESS(Status))
    {
        goto cleanup;
    }

    if((pDnsDomainInfo != NULL) &&
       (pDnsDomainInfo->DnsDomainName.Buffer == NULL))
    {
        fRet = TRUE;
    }


cleanup:

    if(pDnsDomainInfo)
        LsaFreeMemory(pDnsDomainInfo);

    if(PolicyHandle)
        LsaClose(PolicyHandle);

    return fRet;
}


DWORD
BackupMasterKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      LPBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
    IN      BOOL fPhaseTwo,         // is phase two required?
    IN      BOOL fAsynchronous      // asynchronous call?
    )
{

    BYTE rgbLKEncryptionKey[ A_SHA_DIGEST_LEN ];
    BYTE rgbBKEncryptionKey[ A_SHA_DIGEST_LEN ];

    PBYTE pbLocalKey = NULL;
    DWORD cbLocalKey = 0;

    PBYTE pbBackupKeyPhaseOne = NULL;
    DWORD cbBackupKeyPhaseOne = 0;

    PBYTE pbBackupKeyPhaseTwo = NULL;
    DWORD cbBackupKeyPhaseTwo = 0;


    DWORD dwLastError = (DWORD)NTE_BAD_KEY;


    BOOL  fLegacy = FIsLegacyCompliant();

    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    //
    // get current localkey encryption key.
    //

    if(!GetLocalKeyUserEncryptionKey(pvContext, phMasterKey, rgbLKEncryptionKey))
        goto cleanup;

    //
    // retrieve and decrypt LK with current credential.
    //

    dwLastError = DecryptMasterKeyFromStorage(
                        phMasterKey,
                        REGVAL_LOCAL_KEY,
                        rgbLKEncryptionKey,
                        NULL,
                        &pbLocalKey,
                        &cbLocalKey
                        );

    if(dwLastError != ERROR_SUCCESS)
        goto cleanup;


    //
    // Are we running in an NT4 domain? If so, then force legacy mode so that 
    // the master key is backed up using the lsa secret scheme. Otherwise, the
    // master key won't be recoverable following a password change.
    // 

    if(FIsLegacyNt4Domain())
    {
        if(IsNT4Domain())
        {
            D_DebugLog((DEB_WARN,"NT4 domain detected, so force legacy backup mode!\n"));
            fLegacy = TRUE;
        }
    }

    if(fLegacy)
    {
        //
        // derive BK encryption key from decrypted Local Key.
        //

        FMyPrimitiveSHA( pbLocalKey, cbLocalKey, rgbBKEncryptionKey );

        //
        // encrypt masterkey to phase one backup key, using encryption key derived
        // from local key.  do it in memory, such that we only commit it to disk if
        // phase two backup key cannot be generated/persisted.
        //

        dwLastError = EncryptMasterKeyToMemory(
                            rgbBKEncryptionKey,
                            0,
                            pbMasterKey,
                            cbMasterKey,
                            &pbBackupKeyPhaseOne,
                            &cbBackupKeyPhaseOne
                            );

        if(dwLastError != ERROR_SUCCESS)
            goto cleanup;

        // Copy this in directly, so we do not set the modified flag

    }


    //
    // attempt phase two backup (if policy permits).
    //

    if( fPhaseTwo ) {
        DWORD dwWaitTimeout;

        dwLastError = ERROR_SUCCESS;

        // 
        // We only attempt a local backup if we
        // have user keying material.  Otherwise,
        // we directly contact the DC
        //
        if(fAsynchronous && (!fLegacy))
        {
            if(ERROR_SUCCESS == dwLastError)
            {

                //
                // Try to do this locally, without going 
                // off machine
                dwLastError = AttemptLocalBackup(
                                                FALSE,
                                                pServerContext->hToken,
                                                phMasterKey,
                                                pbMasterKey,
                                                cbMasterKey,
                                                pbLocalKey,
                                                cbLocalKey,
                                                &pbBackupKeyPhaseTwo,
                                                &cbBackupKeyPhaseTwo
                                                );
            }

            if(ERROR_SUCCESS == dwLastError)
            {
                dwLastError = PersistMasterKeyToStorage(
                                    phMasterKey,
                                    REGVAL_BACKUP_DC_KEY,
                                    pbBackupKeyPhaseTwo,
                                    cbBackupKeyPhaseTwo
                                    );
                if(ERROR_SUCCESS == dwLastError)
                {
                    // Zero out any local backup key that might
                    // be present
                    PersistMasterKeyToStorage(
                                        phMasterKey,
                                        REGVAL_BACKUP_LCL_KEY,
                                        NULL,
                                        0
                                        );

                }

            }
        }



        if(fLegacy || (!fAsynchronous) || (ERROR_SUCCESS != dwLastError))
        {
            // 
            // We couldn't back up locally
            // so we need to go off machine
            //
            if( fAsynchronous )
                dwWaitTimeout = 2000;
            else
                dwWaitTimeout = 20000;

            dwLastError = QueueBackupMasterKey(
                                pvContext,
                                phMasterKey,
                                pbLocalKey,
                                cbLocalKey,
                                pbMasterKey,
                                cbMasterKey,
                                dwWaitTimeout
                                );
        }

    }

    if( !fPhaseTwo || dwLastError != ERROR_SUCCESS ) {

        DWORD dwTempError = ERROR_SUCCESS;

        //
        // couldn't (or policy didn't allow) backup to phase two.
        // persist phase one key, if one was generated
        //

        if(pbBackupKeyPhaseOne)
        {
            // This will overwrite our local backup data indicating which credential
            // will be able to decrypt the master key.  However, since we have a 
            // phase one backup key anyway, it doesn't matter.
            //
            // This should only happen if fLegacy is true
            dwTempError = PersistMasterKeyToStorage(
                            phMasterKey,
                            REGVAL_BACKUP_LCL_KEY,
                            pbBackupKeyPhaseOne,
                            cbBackupKeyPhaseOne
                            );
        }


        //
        // if it was async, prop correct error code back.
        //

        if( fAsynchronous || !fPhaseTwo ) {
            dwLastError = dwTempError;
        } else {
            if( dwLastError == ERROR_SUCCESS && dwTempError != ERROR_SUCCESS )
                dwLastError = dwTempError;
        }
    }


cleanup:

    RtlSecureZeroMemory( rgbLKEncryptionKey, sizeof(rgbLKEncryptionKey) );
    RtlSecureZeroMemory( rgbBKEncryptionKey, sizeof(rgbBKEncryptionKey) );

    if(pbLocalKey) {
        RtlSecureZeroMemory(pbLocalKey, cbLocalKey);
        SSFree(pbLocalKey);
    }

    if(pbBackupKeyPhaseOne) {
        RtlSecureZeroMemory(pbBackupKeyPhaseOne, cbBackupKeyPhaseOne);
        SSFree(pbBackupKeyPhaseOne);
    }

    if(pbBackupKeyPhaseTwo) {
        RtlSecureZeroMemory(pbBackupKeyPhaseTwo, cbBackupKeyPhaseTwo);
        SSFree(pbBackupKeyPhaseTwo);
    }

    return dwLastError;
}

DWORD
QueueBackupMasterKey(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      PBYTE pbLocalKey,
    IN      DWORD cbLocalKey,
    IN      PBYTE pbMasterKey,
    IN      DWORD cbMasterKey,
    IN      DWORD dwWaitTimeout             // amount of time to wait for operation to complete
    )
{

    HANDLE hDuplicateToken = NULL;
    PMASTERKEY_STORED phDuplicatedMasterKey = NULL;
    PQUEUED_BACKUP pQueuedBackup = NULL;
    HANDLE hEventThread = NULL;
    HANDLE hEventSuccess = NULL;
    HANDLE hDuplicateEvent = NULL;
    HANDLE hDuplicateEvent2 = NULL;
    DWORD dwLastError;

    //
    // allocate memory for the structure and any trailing contents.
    //

    pQueuedBackup = (PQUEUED_BACKUP)SSAlloc(
                            sizeof(QUEUED_BACKUP) +
                            cbMasterKey +
                            cbLocalKey
                            );

    if( pQueuedBackup == NULL )
        return ERROR_OUTOFMEMORY;

    pQueuedBackup->cbSize = sizeof(QUEUED_BACKUP);

    //
    // duplicate the phase one backup blob.
    //

    pQueuedBackup->pbLocalKey = (LPBYTE)(pQueuedBackup+1);
    pQueuedBackup->cbLocalKey = cbLocalKey;

    CopyMemory(pQueuedBackup->pbLocalKey, pbLocalKey, cbLocalKey);


    // BUGBUG: pQueueBackup should not be pagable or should be protected.
    pQueuedBackup->pbMasterKey = pQueuedBackup->pbLocalKey + cbLocalKey;
    pQueuedBackup->cbMasterKey = cbMasterKey;

    CopyMemory(pQueuedBackup->pbMasterKey, pbMasterKey, cbMasterKey);

    //
    // make a duplicate of the client access token.
    //

    dwLastError = CPSDuplicateClientAccessToken( pvContext, &hDuplicateToken );

    if( dwLastError != ERROR_SUCCESS )
        goto cleanup;

    //
    // duplicate the open masterkey
    //

    if(!DuplicateMasterKey( phMasterKey, &(pQueuedBackup->hMasterKey) )) {
        dwLastError = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    pQueuedBackup->hToken = hDuplicateToken;
    phDuplicatedMasterKey = &(pQueuedBackup->hMasterKey);


    hEventThread = CreateEventW( NULL, TRUE, FALSE, NULL );

    if( hEventThread ) {

        if( DuplicateHandle(
                    GetCurrentProcess(),
                    hEventThread,
                    GetCurrentProcess(),
                    &hDuplicateEvent,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS
                    )) {

            pQueuedBackup->hEventThread = hDuplicateEvent;
        } else {
            hDuplicateEvent = NULL;
        }

    }

    //
    // create event which indicates success.
    //

    hEventSuccess = CreateEventW( NULL, TRUE, FALSE, NULL );

    if( hEventSuccess ) {

        if( DuplicateHandle(
                    GetCurrentProcess(),
                    hEventSuccess,
                    GetCurrentProcess(),
                    &hDuplicateEvent2,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS
                    )) {

            pQueuedBackup->hEventSuccess = hDuplicateEvent2;
        } else {
            hDuplicateEvent2 = NULL;
        }

    }

    //
    // finally, create the worker thread.
    //

    if( !QueueUserWorkItem(
            QueueBackupMasterKeyThreadFunc,
            pQueuedBackup,
            WT_EXECUTELONGFUNCTION
            )) {

        dwLastError = GetLastError();
        goto cleanup;
    }

    //
    // if the thread is still active, we write the master key out.
    //

    if( hEventThread ) {
        if(WAIT_OBJECT_0 != WaitForSingleObject( hEventThread, dwWaitTimeout ))
            dwLastError = STILL_ACTIVE;
    }

    if( hEventSuccess && dwLastError == ERROR_SUCCESS ) {

        //
        // check if operation succeeded.
        // if not, indicate an error condition.
        //

        if(WAIT_OBJECT_0 != WaitForSingleObject( hEventSuccess, 0 ))
            dwLastError = STILL_ACTIVE;

    }

cleanup:

    //
    // if thread creation failed, we cleanup resources that were handed
    // to the thread, since it cannot possibly clean them up.
    //

    if( dwLastError != ERROR_SUCCESS && dwLastError != STILL_ACTIVE ) {

        if( hDuplicateToken )
            CloseHandle( hDuplicateToken );

        if( hDuplicateEvent )
            CloseHandle( hDuplicateEvent );

        if( hDuplicateEvent2 )
            CloseHandle( hDuplicateEvent2 );

        if( phDuplicatedMasterKey )
            CloseMasterKey( pvContext, phDuplicatedMasterKey, FALSE );

        if( pQueuedBackup )
            SSFree( pQueuedBackup );
    }

    if( hEventThread )
        CloseHandle( hEventThread );

    if( hEventSuccess )
        CloseHandle( hEventSuccess );

    return dwLastError;
}

DWORD
WINAPI
QueueBackupMasterKeyThreadFunc(
    IN      LPVOID lpThreadArgument
    )
{
    PQUEUED_BACKUP pQueuedBackup = (PQUEUED_BACKUP)lpThreadArgument;
    HANDLE hToken = NULL;
    HANDLE hEventThread;
    HANDLE hEventSuccess;
    PMASTERKEY_STORED phMasterKey = NULL;
    PBYTE pbBackupKeyPhaseOne = NULL;
    DWORD cbBackupKeyPhaseOne = 0;

    PBYTE pbBackupKeyPhaseTwo = NULL;
    DWORD cbBackupKeyPhaseTwo = 0;
    BOOL fImpersonated = FALSE;
    DWORD dwLastError = ERROR_SUCCESS;

    BOOL fSuccess = FALSE;
    BOOL fSuccessClose = FALSE;

    BOOL fLegacy = FIsLegacyCompliant();
    //
    // check structure version.
    //

    if(pQueuedBackup == NULL || pQueuedBackup->cbSize != sizeof(QUEUED_BACKUP))
        return ERROR_INVALID_PARAMETER;

    hToken = pQueuedBackup->hToken;
    hEventThread = pQueuedBackup->hEventThread;
    hEventSuccess = pQueuedBackup->hEventSuccess;

    phMasterKey = &(pQueuedBackup->hMasterKey);





    if(!fLegacy)
    {

        //
        // Public was not available, so 
        // we need to try to retrieve it
        // 

        dwLastError = AttemptLocalBackup(TRUE,
                        hToken,
                        phMasterKey,
                        pQueuedBackup->pbMasterKey,
                        pQueuedBackup->cbMasterKey,
                        pQueuedBackup->pbLocalKey,
                        pQueuedBackup->cbLocalKey,
                        &pbBackupKeyPhaseTwo,
                        &cbBackupKeyPhaseTwo
                        );
    }

    //
    // impersonate the client user.
    //

    fImpersonated = SetThreadToken( NULL, hToken );
    if(!fImpersonated) 
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if((ERROR_SUCCESS != dwLastError) || fLegacy)
    {
        BYTE rgbBKEncryptionKey[ A_SHA_DIGEST_LEN ];

        //
        // derive BK encryption key from decrypted Local Key.
        //

        FMyPrimitiveSHA( pQueuedBackup->pbLocalKey, pQueuedBackup->cbLocalKey, rgbBKEncryptionKey );

        //
        // encrypt masterkey to phase one backup key, using encryption key derived
        // from local key.  do it in memory, such that we only commit it to disk if
        // phase two backup key cannot be generated/persisted.
        //

        dwLastError = EncryptMasterKeyToMemory(
                            rgbBKEncryptionKey,
                            0,
                            pQueuedBackup->pbMasterKey,
                            pQueuedBackup->cbMasterKey,
                            &pbBackupKeyPhaseOne,
                            &cbBackupKeyPhaseOne
                            );
        RtlSecureZeroMemory(rgbBKEncryptionKey, sizeof(rgbBKEncryptionKey));


        if(dwLastError != ERROR_SUCCESS)
            goto cleanup;

        // Copy this in directly, so we do not set the modified flag



        // Perform a legacy style backup
        dwLastError = BackupRestoreData(
                        NULL,
                        phMasterKey,
                        pbBackupKeyPhaseOne,
                        cbBackupKeyPhaseOne,
                        &pbBackupKeyPhaseTwo,
                        &cbBackupKeyPhaseTwo,
                        TRUE    // backup data
                        );
    }

    if( dwLastError == ERROR_SUCCESS ) {

        //
        // perist phase two backup key to storage.
        //

        dwLastError = PersistMasterKeyToStorage(
                            phMasterKey,
                            REGVAL_BACKUP_DC_KEY,
                            pbBackupKeyPhaseTwo,
                            cbBackupKeyPhaseTwo
                            );

        if( dwLastError == ERROR_SUCCESS ) {

            //
            // successful phase two backup+persist, nuke phase one backup
            // master key.
            //

            PersistMasterKeyToStorage(
                        phMasterKey,
                        REGVAL_BACKUP_LCL_KEY,
                        NULL,
                        0
                        );

            fSuccess = TRUE;
        }
    }


cleanup:

    //
    // always close/free master key.  Only if impersonation succeeeded
    // do we attempt to flush it out.
    //

    fSuccessClose = CloseMasterKey( NULL, phMasterKey, fSuccess ) ;

    if( hEventSuccess ) {
        if( fSuccess && fSuccessClose )
            SetEvent( hEventSuccess );

        CloseHandle( hEventSuccess );
    }

    if( fImpersonated )
        RevertToSelf();

    if( hToken )
        CloseHandle(hToken);

    if( hEventThread ) {
        SetEvent( hEventThread );
        CloseHandle( hEventThread );
    }
    if(pbBackupKeyPhaseOne) {
        RtlSecureZeroMemory(pbBackupKeyPhaseOne, cbBackupKeyPhaseOne);
        SSFree(pbBackupKeyPhaseOne);
    }
    if(pbBackupKeyPhaseTwo) {
        RtlSecureZeroMemory(pbBackupKeyPhaseTwo, cbBackupKeyPhaseTwo);
        SSFree(pbBackupKeyPhaseTwo);
    }

    if( lpThreadArgument )
        SSFree( lpThreadArgument );

    return dwLastError;
}

DWORD
RestoreMasterKey(
    IN      PVOID   pvContext,
    IN      PSID    pSid,
    IN      PMASTERKEY_STORED phMasterKey,
    IN      DWORD   dwReason,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey
    )
/*++

    Recover the master key associated with the specified master key.

    The current state of the masterkey dictates what level of recovery is
    attempted.

--*/
{
    static const GUID guidRestoreW2K = BACKUPKEY_RESTORE_GUID_W2K;

    BYTE rgbLKEncryptionKey[ A_SHA_DIGEST_LEN ];
    BYTE rgbBKEncryptionKey[ A_SHA_DIGEST_LEN ];

    PBYTE pbLocalKey = NULL;
    DWORD cbLocalKey = 0;

    PBYTE pbBackupKeyPhaseOne = NULL;
    DWORD cbBackupKeyPhaseOne = 0;


    BOOL fAllocatedPhaseOne = FALSE;

    DWORD dwLastError = (DWORD)NTE_BAD_KEY;

    D_DebugLog((DEB_TRACE, "RestoreMasterKey:%ls\n", phMasterKey->wszguidMasterKey));

    if(phMasterKey->pbBK)
    {

        LOCAL_BACKUP_DATA LocalBackupData;

        // First, see if we have any local password-change recovery 
        // information.

        if(phMasterKey->cbBK >= sizeof(LocalBackupData))
        {
            CopyMemory(&LocalBackupData, phMasterKey->pbBK, sizeof(LocalBackupData));
        }
        else
        {
            ZeroMemory(&LocalBackupData, sizeof(LocalBackupData));
        }
        
        if(MASTERKEY_BLOB_LOCALKEY_BACKUP == LocalBackupData.dwVersion)
        {
            D_DebugLog((DEB_TRACE, "Attempt local recovery.\n"));

            #ifdef COMPILED_BY_DEVELOPER
            D_DebugLog((DEB_TRACE, "MK decryption key GUID:\n"));
            D_DPAPIDumpHexData(DEB_TRACE, "  ", (PBYTE)&LocalBackupData.CredentialID, sizeof(LocalBackupData.CredentialID));
            #endif

            if(GetMasterKeyUserEncryptionKey(pvContext,
                                             &LocalBackupData.CredentialID,
                                             pSid,
                                             ((phMasterKey->dwPolicy & POLICY_DPAPI_OWF)?USE_DPAPI_OWF:0),
                                             rgbBKEncryptionKey))
            {

                //
                // retrieve and decrypt MK with current credential.
                //

                #ifdef COMPILED_BY_DEVELOPER
                D_DebugLog((DEB_TRACE, "MK decryption key:\n"));
                D_DPAPIDumpHexData(DEB_TRACE, "  ", rgbBKEncryptionKey, sizeof(rgbBKEncryptionKey));
                #endif

                dwLastError = DecryptMasterKeyFromStorage(
                                    phMasterKey,
                                    REGVAL_MASTER_KEY,
                                    rgbBKEncryptionKey,
                                    NULL,
                                    ppbMasterKey,
                                    pcbMasterKey
                                    );
                if(ERROR_SUCCESS == dwLastError)
                {
                    #ifdef COMPILED_BY_DEVELOPER
                    D_DebugLog((DEB_TRACE, "Master key:\n"));
                    D_DPAPIDumpHexData(DEB_TRACE, "  ", *ppbMasterKey, *pcbMasterKey);
                    #endif

                    goto cleanup;
                }
                else
                {
                    D_DebugLog((DEB_WARN, "Unable to decrypt MK with local decryption key.\n"));
                }
            }
            else
            {
                D_DebugLog((DEB_WARN, "Unable to locate local MK decryption key.\n"));
            }
        }
    }



    if(phMasterKey->pbBBK) {

        //
        // do phase two recovery.
        // undoing phase two backup blob gives us phase one backup blob.
        //

        dwLastError = CPSImpersonateClient( pvContext );

        if( dwLastError == ERROR_SUCCESS ) {

            dwLastError = BackupRestoreData(
                            ((PCRYPT_SERVER_CONTEXT)pvContext)->hToken,
                            phMasterKey,
                            phMasterKey->pbBBK,
                            phMasterKey->cbBBK,
                            &pbBackupKeyPhaseOne,
                            &cbBackupKeyPhaseOne,
                            FALSE    // do not backup data
                            );

            if(ERROR_SUCCESS != dwLastError)
            {
                //
                // Attempt a restore through the w2k restore port
                //
                dwLastError = LocalBackupRestoreData(
                                                    ((PCRYPT_SERVER_CONTEXT)pvContext)->hToken,
                                                    phMasterKey,
                                                    phMasterKey->pbBBK,
                                                    phMasterKey->cbBBK,
                                                    &pbBackupKeyPhaseOne,
                                                    &cbBackupKeyPhaseOne,
                                                    &guidRestoreW2K);
            }
            if(dwLastError == ERROR_SUCCESS)
                fAllocatedPhaseOne = TRUE;



            CPSRevertToSelf( pvContext );
        }

    } else {

        //
        // try phase one blob.
        //

        dwLastError = QueryMasterKeyFromStorage(
                        phMasterKey,
                        REGVAL_BACKUP_LCL_KEY,
                        &pbBackupKeyPhaseOne,
                        &cbBackupKeyPhaseOne
                        );

    }

    if(dwLastError != ERROR_SUCCESS)
        goto cleanup;


    //
    // Check to see if this really is a phase one blob
    //

    if(cbBackupKeyPhaseOne < sizeof(DWORD))
    {
        goto cleanup;
    }
    if(*((DWORD *)pbBackupKeyPhaseOne) != MASTERKEY_BLOB_RAW_VERSION)
    {
        //
        // we successfully got an phase one blob.
        // decrypt it to get the original masterkey.
        //


        //
        // get current localkey encryption key.
        //

        if(!GetLocalKeyUserEncryptionKey(pvContext, phMasterKey, rgbLKEncryptionKey))
            goto cleanup;

        //
        // retrieve and decrypt LK with current credential.
        //

        dwLastError = DecryptMasterKeyFromStorage(
                            phMasterKey,
                            REGVAL_LOCAL_KEY,
                            rgbLKEncryptionKey,
                            NULL, 
                            &pbLocalKey,
                            &cbLocalKey
                            );

        if(dwLastError != ERROR_SUCCESS)
            goto cleanup;

        //
        // derive BK encryption key from decrypted Local Key.
        //

        FMyPrimitiveSHA( pbLocalKey, cbLocalKey, rgbBKEncryptionKey );


        //
        // finally, decrypt BK using derived BKEncryptionKey
        //

        dwLastError = DecryptMasterKeyToMemory(
                            rgbBKEncryptionKey,
                            pbBackupKeyPhaseOne,
                            cbBackupKeyPhaseOne,
                            NULL, 
                            ppbMasterKey,
                            pcbMasterKey
                            );
    }
    else
    {
        *ppbMasterKey = (PBYTE)SSAlloc(cbBackupKeyPhaseOne - sizeof(DWORD));
        if(NULL == *ppbMasterKey)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        CopyMemory(*ppbMasterKey, 
                   pbBackupKeyPhaseOne + sizeof(DWORD),
                   cbBackupKeyPhaseOne - sizeof(DWORD));
        *pcbMasterKey =  cbBackupKeyPhaseOne - sizeof(DWORD);

    }


cleanup:

    RtlSecureZeroMemory( rgbLKEncryptionKey, sizeof(rgbLKEncryptionKey) );
    RtlSecureZeroMemory( rgbBKEncryptionKey, sizeof(rgbBKEncryptionKey) );

    if(pbLocalKey) {
        RtlSecureZeroMemory(pbLocalKey, cbLocalKey);
        SSFree(pbLocalKey);
    }

    if(fAllocatedPhaseOne && pbBackupKeyPhaseOne) {
        RtlSecureZeroMemory(pbBackupKeyPhaseOne, cbBackupKeyPhaseOne);
        SSFree(pbBackupKeyPhaseOne);
    }

    D_DebugLog((DEB_TRACE, "RestoreMasterKey returned 0x%x\n", dwLastError));

    return dwLastError;
}


//
// per-user root level policy query, set
//

BOOL
InitializeMasterKeyPolicy(
    IN      PVOID pvContext,
    IN      PMASTERKEY_STORED phMasterKey,
    OUT     BOOL *fLocalAccount
    )
{
    DWORD dwMasterKeyPolicy = 0;
    DWORD dwAccount = 0;
    BOOL  fLocalMachine = FALSE;


    //
    // get current top-level policy.
    //

    dwMasterKeyPolicy = phMasterKey->dwPolicy | GetMasterKeyDefaultPolicy();

    *fLocalAccount = !IsDomainBackupRequired( pvContext );



    if( !(dwMasterKeyPolicy & POLICY_NO_BACKUP) &&
        !(dwMasterKeyPolicy & POLICY_LOCAL_BACKUP) ) 
    {

        //
        // See if domain controller (phase two) backup is required/appropriate.
        //

        if( !(*fLocalAccount) ) 
        {
            phMasterKey->dwPolicy = dwMasterKeyPolicy;
            return TRUE;
        }

    }



    //
    // see if the call is for shared, CRYPT_PROTECT_LOCAL_MACHINE
    // disposition.
    //

    CPSOverrideToLocalSystem(
                pvContext,
                NULL,       // don't change current over-ride BOOL
                &fLocalMachine
                );

    CPSQueryWellKnownAccount(
                pvContext,
                &dwAccount);


    //
    // if the context specified per-machine, we know that it's a system credential.
    // also, we don't need to get the user name in this scenario.
    //

    if(fLocalMachine || (dwAccount != 0))
    {
        //
        // a SYSTEM (user or per-machine disposition) key is the focus
        // of our attention; never back these up.
        //

        dwMasterKeyPolicy |= POLICY_NO_BACKUP;
        dwMasterKeyPolicy &= ~POLICY_LOCAL_BACKUP;

    } 
    else 
    {

        //
        // otherwise assume it's a key associated with a local account...
        // (local only backup).
        //

        dwMasterKeyPolicy |= POLICY_LOCAL_BACKUP;
    }


    //
    // don't persist a default value as this implies that somebody really
    // specified a policy. (maximum forward compatibility).
    //

    phMasterKey->dwPolicy = dwMasterKeyPolicy;

    return TRUE;
}






BOOL
IsDomainBackupRequired(
    IN      PVOID pvContext
    )
/*++

    Determine if the current security context dictates whether domain controller
    (phase two) based backup is required/appropriate.

--*/
{

    PSID pSidUser = NULL;
    DWORD dwSubauthorityCount;

    PUSER_MODALS_INFO_2 pumi2 = NULL;
    NET_API_STATUS nas;

    BOOL fBackupRequired = FALSE; // assume backup not required.
    BOOL fSuccess;
    PCRYPT_SERVER_CONTEXT pServerContext = (PCRYPT_SERVER_CONTEXT)pvContext;

    //
    // get the Sid associated with the client security context.
    //  see if the Sid only has one subauthority.  If so, no associated DC.
    //  see if current machine a DC.  If so, backup is required.
    //

    fSuccess = GetTokenUserSid(pServerContext->hToken, &pSidUser);

    if(!fSuccess)
        goto cleanup;

    //
    // see if the Sid has only one subauthority.  If so, no associated DC,
    // no DC backup possible.
    //

    dwSubauthorityCount = *GetSidSubAuthorityCount( pSidUser );

    if( dwSubauthorityCount == 1 ) {
        fBackupRequired = FALSE;
        goto cleanup;
    }

    //
    // if current machine is a domain controller, backup is required.
    //

    if(IsDomainController()) {
        fBackupRequired = TRUE;
        goto cleanup;
    }


    //
    // if the Sid contains local machine domain prefix Sid, backup is not
    // required, as no DC is associated with the account.
    //

    nas = NetUserModalsGet( NULL, 2, (LPBYTE*)&pumi2 );

    if(nas != NERR_Success)
        goto cleanup;

    if(!IsUserSidInDomain( pumi2->usrmod2_domain_id, pSidUser )) {
        fBackupRequired = TRUE;
        goto cleanup;
    }

    //
    // defaulted to backup not required.
    //

    fBackupRequired = FALSE;

cleanup:

    if(pumi2)
        NetApiBufferFree(pumi2);

    if(pSidUser)
        SSFree(pSidUser);

    return fBackupRequired;
}

NTSTATUS
GetPreferredMasterKeyGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN  OUT GUID *pguidMasterKey
    )
/*++

    Given a registry handle to the MasterKeys portion of the registry,
    tells the caller what the preferred master key GUID is.

    If a valid preferred key is configured, then the return value is 
    STATUS_SUCCESS, and the pguidMasterKey buffer is filled with the 
    GUID associated with the preferred master key.
    
    If the preferred key is expired, then the return value is 
    STATUS_PASSWORD_EXPIRED, and the pguidMasterKey buffer is filled 
    with the GUID associated with the preferred master key. In this case,
    the caller may not want to use this key, except perhaps if a new
    master key cannot be successfully created.

    On failure, an NTSTATUS error code is returned. The caller can assume
    there is no preferred master key configured in this case, and a new one
    is to be created and subsequently selected via SetPreferredMasterKeyGuid().

--*/
{

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytesRead;

    MASTERKEY_PREFERRED_INFO sMKPreferred;
    SYSTEMTIME stCurrentTime;
    FILETIME ftCurrentTime;
    unsigned __int64 CurrentTime;
    unsigned __int64 ExpiryInterval;

    DWORD dwLastError;
    BOOL fSuccess;

    dwLastError = OpenFileInStorageArea(
                        pvContext,
                        GENERIC_READ,
                        szUserStorageArea,
                        REGVAL_PREFERRED_MK,
                        &hFile
                        );

    if(dwLastError != ERROR_SUCCESS) 
    {
        return STATUS_NOT_FOUND;
    }

    //
    // read the expiration and GUID from file into buffer.
    //

    fSuccess = ReadFile( hFile, &sMKPreferred, sizeof(sMKPreferred), &dwBytesRead, NULL );

    CloseHandle( hFile );

    if( !fSuccess )
    {
        return STATUS_NOT_FOUND;
    }

    //
    // validate data
    //

    if( dwBytesRead != sizeof(sMKPreferred) )
    {
        return STATUS_NOT_FOUND;
    }


    //
    // Copy the GUID of the preferred master key to the output buffer.
    //

    CopyMemory(pguidMasterKey, &(sMKPreferred.guidPreferredKey), sizeof(GUID));


    //
    // see if the key has expired
    //

    GetSystemTime(&stCurrentTime);
    SystemTimeToFileTime(&stCurrentTime, &ftCurrentTime);

    if(CompareFileTime(&ftCurrentTime, &(sMKPreferred.ftPreferredKeyExpires)) >= 0)
    {
        // key has expired
        return STATUS_PASSWORD_EXPIRED;
    }

    ExpiryInterval = MASTERKEY_EXPIRES_DAYS * 24 * 60 * 60;
    ExpiryInterval *= 10000000;

    CurrentTime = ((__int64)ftCurrentTime.dwHighDateTime << 32) + (__int64)ftCurrentTime.dwLowDateTime;
    CurrentTime += ExpiryInterval;

    ftCurrentTime.dwLowDateTime = (DWORD)(CurrentTime & 0xffffffff);
    ftCurrentTime.dwHighDateTime = (DWORD)(CurrentTime >> 32);

    if(CompareFileTime(&ftCurrentTime, &(sMKPreferred.ftPreferredKeyExpires)) < 0)
    {
        // expiry time is too far in the future
        return STATUS_PASSWORD_EXPIRED;
    }


    //
    // The key is current.
    //

    return STATUS_SUCCESS;
}

BOOL
SetPreferredMasterKeyGuid(
    IN      PVOID pvContext,
    IN      LPCWSTR szUserStorageArea,
    IN      GUID *pguidMasterKey
    )
{
    MASTERKEY_PREFERRED_INFO sMKPreferred;
    SYSTEMTIME stCurrentTime;
    FILETIME ftCurrentTime;
    unsigned __int64 uTime;
    unsigned __int64 oTime;

    HANDLE hFile;
    DWORD dwBytesWritten;

    DWORD dwLastError;
    BOOL fSuccess;

    CopyMemory(&sMKPreferred.guidPreferredKey, pguidMasterKey, sizeof(GUID));

    //
    // set key expiration time.
    //

    GetSystemTime(&stCurrentTime);
    SystemTimeToFileTime(&stCurrentTime, &(sMKPreferred.ftPreferredKeyExpires));

    uTime = sMKPreferred.ftPreferredKeyExpires.dwLowDateTime;
    uTime += ((unsigned __int64)sMKPreferred.ftPreferredKeyExpires.dwHighDateTime << 32) ;

    //
    //  the compiler complains about integer constant overflow
    // if we don't break it up..
    //

    oTime = MASTERKEY_EXPIRES_DAYS * 24 * 60 * 60;
    oTime *= 10000000;

    uTime += oTime;

    sMKPreferred.ftPreferredKeyExpires.dwLowDateTime = (DWORD)(uTime & 0xffffffff);
    sMKPreferred.ftPreferredKeyExpires.dwHighDateTime = (DWORD)(uTime >> 32);


    dwLastError = OpenFileInStorageArea(
                        pvContext,
                        GENERIC_WRITE,
                        szUserStorageArea,
                        REGVAL_PREFERRED_MK,
                        &hFile
                        );

    if(dwLastError != ERROR_SUCCESS) {
        SetLastError(dwLastError);
        return FALSE;
    }

    //
    // write the expiration and GUID from buffer into file.
    //

    fSuccess = WriteFile( hFile, &sMKPreferred, sizeof(sMKPreferred), &dwBytesWritten, NULL );

    CloseHandle( hFile );

    return fSuccess;
}



DWORD
OpenFileInStorageArea(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      DWORD   dwDesiredAccess,
    IN      LPCWSTR szUserStorageArea,
    IN      LPCWSTR szFileName,
    IN OUT  HANDLE  *phFile
    )
{
    LPWSTR szFilePath = NULL;
    DWORD cbUserStorageArea;
    DWORD cbFileName;
    DWORD dwShareMode = 0;
    DWORD dwCreationDistribution = OPEN_EXISTING;
    DWORD dwLastError = ERROR_SUCCESS;

    *phFile = INVALID_HANDLE_VALUE;

    if( dwDesiredAccess & GENERIC_READ ) {
        dwShareMode |= FILE_SHARE_READ;
        dwCreationDistribution = OPEN_EXISTING;
    }

    if( dwDesiredAccess & GENERIC_WRITE ) {
        dwShareMode = 0;
        dwCreationDistribution = OPEN_ALWAYS;
    }

    cbUserStorageArea = lstrlenW( szUserStorageArea ) * sizeof(WCHAR);
    cbFileName = lstrlenW( szFileName ) * sizeof(WCHAR);

    szFilePath = (LPWSTR)SSAlloc( cbUserStorageArea + cbFileName + sizeof(WCHAR) );

    if( szFilePath == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    CopyMemory(szFilePath, szUserStorageArea, cbUserStorageArea);
    CopyMemory((LPBYTE)szFilePath+cbUserStorageArea, szFileName, cbFileName + sizeof(WCHAR));

    if( pvContext )
        dwLastError = CPSImpersonateClient( pvContext );

    if( dwLastError == ERROR_SUCCESS ) {

        //
        // TODO:
        // apply security descriptor to file.
        //

        *phFile = CreateFileWithRetries(
                    szFilePath,
                    dwDesiredAccess,
                    dwShareMode,
                    NULL,
                    dwCreationDistribution,
                    FILE_ATTRIBUTE_HIDDEN |
                    FILE_ATTRIBUTE_SYSTEM |
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

        if( *phFile == INVALID_HANDLE_VALUE ) {
            dwLastError = GetLastError();
        }

        if( pvContext )
            CPSRevertToSelf( pvContext );

    }

    if(szFilePath)
        SSFree(szFilePath);

    return dwLastError;
}

HANDLE
CreateFileWithRetries(
    IN      LPCWSTR lpFileName,
    IN      DWORD dwDesiredAccess,
    IN      DWORD dwShareMode,
    IN      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN      DWORD dwCreationDisposition,
    IN      DWORD dwFlagsAndAttributes,
    IN      HANDLE hTemplateFile
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;

    static const DWORD rgReadRetrys[] = { 1, 10, 50, 100, 1000, 0 };
    static const DWORD rgWriteRetrys[] = { 1, 10, 20, 20, 50, 75, 100, 500, 1000, 0 };

    const DWORD *prgRetries;
    DWORD dwRetryIndex;

    DWORD dwLastError = ERROR_SHARING_VIOLATION;

    if( dwDesiredAccess & GENERIC_WRITE ) {
        prgRetries = rgWriteRetrys;
    } else {
        prgRetries = rgReadRetrys;
    }

    for( dwRetryIndex = 0 ; prgRetries[ dwRetryIndex ] ; dwRetryIndex++ ) {

        hFile = CreateFileU(
                    lpFileName,
                    dwDesiredAccess,
                    dwShareMode,
                    lpSecurityAttributes,
                    dwCreationDisposition,
                    dwFlagsAndAttributes,
                    hTemplateFile
                    );

        if( hFile != INVALID_HANDLE_VALUE )
            break;

        dwLastError = GetLastError();

        if( dwLastError == ERROR_SHARING_VIOLATION )
        {
            //
            // sleep around for the designated period of time...
            //

            Sleep( prgRetries[dwRetryIndex] );
            continue;
        }

        break;
    }

    if( hFile == INVALID_HANDLE_VALUE )
        SetLastError( dwLastError );

    return hFile;
}




BOOL
ReadMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey
    )
/*++

    Read the masterkey specified by phMasterKey->wszguidMasterKey into memory.

--*/
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    DWORD dwFileSizeLow;

    PMASTERKEY_STORED_ON_DISK pMasterKeyRead = NULL;
    DWORD cbguidMasterKey, cbguidMasterKey2;
    PBYTE pbCurrentBlock;
    WCHAR szGuidReadMasterKey[MAX_GUID_SZ_CHARS];

    BOOL fSuccess = FALSE;


    if( OpenFileInStorageArea(
                    pvContext,
                    GENERIC_READ,
                    phMasterKey->szFilePath,
                    phMasterKey->wszguidMasterKey,
                    &hFile
                    ) != ERROR_SUCCESS)
            goto cleanup;

    dwFileSizeLow = GetFileSize( hFile, NULL );
    if(dwFileSizeLow == INVALID_FILE_SIZE )
        goto cleanup;


    if( dwFileSizeLow < sizeof(MASTERKEY_STORED_ON_DISK) )
        goto cleanup;

    __try
    {
        hMap = CreateFileMappingU(
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );
    
        if( hMap == NULL )
            goto cleanup;
    
    
        pMasterKeyRead = (PMASTERKEY_STORED_ON_DISK)MapViewOfFile( hMap, FILE_MAP_READ, 0, 0, 0 );
    
        if(pMasterKeyRead == NULL)
            goto cleanup;
    
    
        if(pMasterKeyRead->dwVersion > MASTERKEY_STORED_VERSION)
            goto cleanup;
    
        //
        // do some size validation
        //
    
        if((pMasterKeyRead->cbMK + pMasterKeyRead->cbLK +
            pMasterKeyRead->cbBK + pMasterKeyRead->cbBBK) >
            ( dwFileSizeLow - sizeof(MASTERKEY_STORED_ON_DISK) )
            )
            goto cleanup;
    
        //
        // validate retrieved GUID matches requested GUID.
        //
    
        CopyMemory(szGuidReadMasterKey, pMasterKeyRead->wszguidMasterKey, MAX_GUID_SZ_CHARS * sizeof(WCHAR));
        szGuidReadMasterKey[MAX_GUID_SZ_CHARS - 1] = L'\0';
    
        cbguidMasterKey = (lstrlenW( phMasterKey->wszguidMasterKey ) + 1) * sizeof(WCHAR);
        cbguidMasterKey2 = (lstrlenW( szGuidReadMasterKey ) + 1) * sizeof(WCHAR);
    
        if(cbguidMasterKey != cbguidMasterKey2)
            goto cleanup;
    
        if(memcmp( phMasterKey->wszguidMasterKey, pMasterKeyRead->wszguidMasterKey, cbguidMasterKey) != 0)
            goto cleanup;
    
        phMasterKey->dwVersion = pMasterKeyRead->dwVersion;
    
        //
        // pickup master key policy
        //
    
        phMasterKey->dwPolicy = pMasterKeyRead->dwPolicy;
    
    
        //
        // copy useful components into new block so a single contiguous write
        // can occur.
        //
    
        pbCurrentBlock = (LPBYTE)(pMasterKeyRead + 1);
    
        if( pMasterKeyRead->cbMK ) 
        {
            phMasterKey->pbMK = (LPBYTE)SSAlloc( pMasterKeyRead->cbMK );
            if(phMasterKey->pbMK == NULL)
                goto cleanup;
    
            phMasterKey->cbMK = pMasterKeyRead->cbMK;
    
            CopyMemory(phMasterKey->pbMK, pbCurrentBlock, pMasterKeyRead->cbMK);
            pbCurrentBlock += pMasterKeyRead->cbMK;
        }
    
        if( pMasterKeyRead->cbLK ) 
        {
            phMasterKey->pbLK = (LPBYTE)SSAlloc( pMasterKeyRead->cbLK );
            if(phMasterKey->pbLK == NULL)
                goto cleanup;
    
            phMasterKey->cbLK = pMasterKeyRead->cbLK;
    
            CopyMemory(phMasterKey->pbLK, pbCurrentBlock, pMasterKeyRead->cbLK);
            pbCurrentBlock += pMasterKeyRead->cbLK;
        }
    
        if( pMasterKeyRead->cbBK ) 
        {
            phMasterKey->pbBK = (LPBYTE)SSAlloc( pMasterKeyRead->cbBK );
            if(phMasterKey->pbBK == NULL)
                goto cleanup;
    
            phMasterKey->cbBK = pMasterKeyRead->cbBK;
    
            CopyMemory(phMasterKey->pbBK, pbCurrentBlock, pMasterKeyRead->cbBK);
            pbCurrentBlock += pMasterKeyRead->cbBK;
        }
    
    
        if( pMasterKeyRead->cbBBK ) 
        {
            phMasterKey->pbBBK = (LPBYTE)SSAlloc( pMasterKeyRead->cbBBK );
            if(phMasterKey->pbBBK == NULL)
                goto cleanup;
    
            phMasterKey->cbBBK = pMasterKeyRead->cbBBK;
    
            CopyMemory(phMasterKey->pbBBK, pbCurrentBlock, pMasterKeyRead->cbBBK);
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        goto cleanup;
    }

    fSuccess = TRUE;

cleanup:

    if( pMasterKeyRead )
        UnmapViewOfFile( pMasterKeyRead );

    if( hMap )
        CloseHandle( hMap );

    if( hFile != INVALID_HANDLE_VALUE )
        CloseHandle( hFile );

    if( !fSuccess )
        FreeMasterKey( phMasterKey );

    return fSuccess;
}


BOOL
WriteMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey
    )
/*++

    Persist the specified masterkey to storage.

    if pvContext is NULL, the caller must be impersonating the user associated
    with the masterkey.

--*/
{
    PMASTERKEY_STORED_ON_DISK pMasterKeyToWrite;
    DWORD cbMasterKeyToWrite;

    PBYTE pbCurrentBlock;
    HANDLE hFile;

    BOOL fSuccess = FALSE;

    if(phMasterKey->dwVersion > MASTERKEY_STORED_VERSION)
        return FALSE;


    cbMasterKeyToWrite = sizeof(MASTERKEY_STORED_ON_DISK) +
                            phMasterKey->cbMK +
                            phMasterKey->cbLK +
                            phMasterKey->cbBK +
                            phMasterKey->cbBBK ;

    pMasterKeyToWrite = (PMASTERKEY_STORED_ON_DISK) SSAlloc( cbMasterKeyToWrite );

    if(pMasterKeyToWrite == NULL)
        return FALSE;

    //
    // copy useful components
    //

    pMasterKeyToWrite->dwVersion = phMasterKey->dwVersion;
    CopyMemory(
                pMasterKeyToWrite->wszguidMasterKey,
                phMasterKey->wszguidMasterKey,
                (MAX_GUID_SZ_CHARS * sizeof(WCHAR))
                );

    pMasterKeyToWrite->dwPolicy = phMasterKey->dwPolicy;
    pMasterKeyToWrite->cbMK = phMasterKey->cbMK;
    pMasterKeyToWrite->cbLK = phMasterKey->cbLK;
    pMasterKeyToWrite->cbBK = phMasterKey->cbBK;
    pMasterKeyToWrite->cbBBK = phMasterKey->cbBBK;


    //
    // overwrite non-useful components
    //

    pMasterKeyToWrite->fModified = FALSE;
    pMasterKeyToWrite->szFilePath = 0;
    pMasterKeyToWrite->pbMK = 0;
    pMasterKeyToWrite->pbLK = 0;
    pMasterKeyToWrite->pbBK = 0;
    pMasterKeyToWrite->pbBBK = 0;


    //
    // copy useful components into new block so a single contiguous write
    // can occur.
    //

    pbCurrentBlock = (LPBYTE)(pMasterKeyToWrite + 1);

    if( phMasterKey->pbMK ) {
        CopyMemory(pbCurrentBlock, phMasterKey->pbMK, phMasterKey->cbMK);
        pbCurrentBlock += phMasterKey->cbMK;
    }

    if( phMasterKey->pbLK ) {
        CopyMemory(pbCurrentBlock, phMasterKey->pbLK, phMasterKey->cbLK);
        pbCurrentBlock += phMasterKey->cbLK;
    }


    if( phMasterKey->pbBK ) {
        CopyMemory(pbCurrentBlock, phMasterKey->pbBK, phMasterKey->cbBK);
        pbCurrentBlock += phMasterKey->cbBK;
    }

    if( phMasterKey->pbBBK ) {
        CopyMemory(pbCurrentBlock, phMasterKey->pbBBK, phMasterKey->cbBBK);

    }

    if( OpenFileInStorageArea(
                    pvContext,
                    GENERIC_READ | GENERIC_WRITE,
                    phMasterKey->szFilePath,
                    phMasterKey->wszguidMasterKey,
                    &hFile
                    ) == ERROR_SUCCESS) {


        BOOL fWriteData;
        DWORD dwBytesWritten;

        CheckToStompMasterKey( pMasterKeyToWrite, hFile, &fWriteData );

        if( fWriteData ) {
            fSuccess = WriteFile(
                            hFile,
                            pMasterKeyToWrite,
                            cbMasterKeyToWrite,
                            &dwBytesWritten,
                            NULL
                            );
        } else {
            fSuccess = TRUE; // nothing to do, success
        }

        CloseHandle( hFile );
    }


    RtlSecureZeroMemory( pMasterKeyToWrite, cbMasterKeyToWrite);
    SSFree( pMasterKeyToWrite );

    return fSuccess;
}

BOOL
CheckToStompMasterKey(
    IN      PMASTERKEY_STORED_ON_DISK   phMasterKeyCandidate,   // masterkey to check if worthy to stomp over existing
    IN      HANDLE                      hFile,                  // file handle to existing masterkey
    IN OUT  BOOL                        *pfStomp                // stomp the existing masterkey?
    )
{
    HANDLE hMap = NULL;
    PMASTERKEY_STORED_ON_DISK pMasterKeyRead = NULL;
    BOOL fSuccess = FALSE;

    *pfStomp = TRUE;

    if( phMasterKeyCandidate->dwPolicy & POLICY_NO_BACKUP )
        return TRUE;

    if( phMasterKeyCandidate->dwPolicy & POLICY_LOCAL_BACKUP &&
        phMasterKeyCandidate->cbBK )
        return TRUE;

    if( phMasterKeyCandidate->cbBBK )
        return TRUE;

    __try
    {
        hMap = CreateFileMapping(
                        hFile,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );
    
        if( hMap == NULL )
            goto cleanup;
    
        pMasterKeyRead = (PMASTERKEY_STORED_ON_DISK)MapViewOfFile( hMap, FILE_MAP_READ, 0, 0, 0 );
    
        if(pMasterKeyRead == NULL)
            goto cleanup;
    
        if(pMasterKeyRead->dwVersion > MASTERKEY_STORED_VERSION)
            goto cleanup;
    
        //
        // there's really only two cases where we don't allow stomping:
        // candidate masterkey doesn't contain phase 1 and existing does,
        // candidate masterkey doesn't contain phase 1 and existing one contains phase2.
        // note: we allow stomping over a masterkey that contains a phase 2 with one
        // that only contains a phase 1, because of a race condition that can occur
        // during the backup operation;  In this situation, it is better to have
        // a phase 1 and let it get upgraded to phase 2 at a later time.
        //
    
        if( phMasterKeyCandidate->cbBK == 0 &&
            (pMasterKeyRead->cbBK || pMasterKeyRead->cbBBK))
        {
            *pfStomp = FALSE;
        }
    
    } __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        goto cleanup;
    }

    fSuccess = TRUE;

cleanup:

    if( pMasterKeyRead )
        UnmapViewOfFile( pMasterKeyRead );

    if( hMap )
        CloseHandle( hMap );

    return fSuccess;
}

BOOL
CloseMasterKey(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      PMASTERKEY_STORED phMasterKey,
    IN      BOOL fPersist               // persist any changes to storage?
    )
/*++

    Free the memory an optionally persist any changes associated with a
    master key.

--*/
{
    BOOL fSuccess = TRUE;

    //
    // if we were told to persist any changes, and changes were actually made,
    // persist them out.
    //

    if( fPersist && phMasterKey->fModified )
        fSuccess = WriteMasterKey( pvContext, phMasterKey );

    //
    // free memory.
    //

    FreeMasterKey( phMasterKey );

    return fSuccess;
}

VOID
FreeMasterKey(
    IN      PMASTERKEY_STORED phMasterKey
    )
/*++

    Free allocated memory associated with the specified master key.

--*/
{
    if( phMasterKey->dwVersion > MASTERKEY_STORED_VERSION )
        return;

    if( phMasterKey->szFilePath )
        SSFree( phMasterKey->szFilePath );

    if( phMasterKey->pbMK ) {
        RtlSecureZeroMemory( phMasterKey->pbMK, phMasterKey->cbMK );
        SSFree( phMasterKey->pbMK );
    }

    if( phMasterKey->pbLK ) {
        RtlSecureZeroMemory( phMasterKey->pbLK, phMasterKey->cbLK );
        SSFree( phMasterKey->pbLK );
    }

    if( phMasterKey->pbBK ) {
        RtlSecureZeroMemory( phMasterKey->pbBK, phMasterKey->cbBK );
        SSFree( phMasterKey->pbBK );
    }

    if( phMasterKey->pbBBK ) {
        RtlSecureZeroMemory( phMasterKey->pbBBK, phMasterKey->cbBBK );
        SSFree( phMasterKey->pbBBK );
    }

    RtlSecureZeroMemory( phMasterKey, sizeof(MASTERKEY_STORED) );

    return;
}

BOOL
DuplicateMasterKey(
    IN      PMASTERKEY_STORED phMasterKeyIn,
    IN      PMASTERKEY_STORED phMasterKeyOut
    )
/*++

    Duplicate the input masterkey to a new copy, setting the fModified flag
    on the copy to FALSE.

    This provides a mechanism to allow for deferring operations against a
    master key.

--*/
{
    BOOL fSuccess = FALSE;

    if( phMasterKeyIn->dwVersion > MASTERKEY_STORED_VERSION )
        return FALSE;

    ZeroMemory( phMasterKeyOut, sizeof(MASTERKEY_STORED) );

    phMasterKeyOut->dwVersion = phMasterKeyIn->dwVersion;
    phMasterKeyOut->dwPolicy = phMasterKeyIn->dwPolicy;
    phMasterKeyOut->fModified = FALSE;

    if( lstrlenW( phMasterKeyIn->wszguidMasterKey ) > MAX_GUID_SZ_CHARS )
        return FALSE;

    CopyMemory(phMasterKeyOut->wszguidMasterKey, phMasterKeyIn->wszguidMasterKey, MAX_GUID_SZ_CHARS * sizeof(WCHAR));

    if( phMasterKeyIn->szFilePath ) {
        DWORD cbFilePath = (lstrlenW(phMasterKeyIn->szFilePath) + 1) * sizeof(WCHAR);

        phMasterKeyOut->szFilePath = (LPWSTR)SSAlloc( cbFilePath );
        if(phMasterKeyOut->szFilePath == NULL)
            goto cleanup;

        CopyMemory( phMasterKeyOut->szFilePath, phMasterKeyIn->szFilePath, cbFilePath );
    }

    if( phMasterKeyIn->pbMK ) {
        phMasterKeyOut->cbMK = phMasterKeyIn->cbMK;
        phMasterKeyOut->pbMK = (PBYTE)SSAlloc(phMasterKeyIn->cbMK);
        if(phMasterKeyOut->pbMK == NULL)
            goto cleanup;

        CopyMemory( phMasterKeyOut->pbMK, phMasterKeyIn->pbMK, phMasterKeyIn->cbMK );
    }


    if( phMasterKeyIn->pbLK ) {
        phMasterKeyOut->cbLK = phMasterKeyIn->cbLK;
        phMasterKeyOut->pbLK = (PBYTE)SSAlloc(phMasterKeyIn->cbLK);
        if(phMasterKeyOut->pbLK == NULL)
            goto cleanup;

        CopyMemory( phMasterKeyOut->pbLK, phMasterKeyIn->pbLK, phMasterKeyIn->cbLK );
    }

    if( phMasterKeyIn->pbBK ) {
        phMasterKeyOut->cbBK = phMasterKeyIn->cbBK;
        phMasterKeyOut->pbBK = (PBYTE)SSAlloc(phMasterKeyIn->cbBK);
        if(phMasterKeyOut->pbBK == NULL)
            goto cleanup;

        CopyMemory( phMasterKeyOut->pbBK, phMasterKeyIn->pbBK, phMasterKeyIn->cbBK );
    }

    if( phMasterKeyIn->pbBBK ) {
        phMasterKeyOut->cbBBK = phMasterKeyIn->cbBBK;
        phMasterKeyOut->pbBBK = (PBYTE)SSAlloc(phMasterKeyIn->cbBBK);
        if(phMasterKeyOut->pbBBK == NULL)
            goto cleanup;

        CopyMemory( phMasterKeyOut->pbBBK, phMasterKeyIn->pbBBK, phMasterKeyIn->cbBBK );
    }

    fSuccess = TRUE;

cleanup:

    if( !fSuccess )
        FreeMasterKey( phMasterKeyOut );

    return fSuccess;
}


BOOL
InitializeKeyManagement(
    VOID
    )
{
    if(!InitializeKeyCache())
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
TeardownKeyManagement(
    VOID
    )
{

    DeleteKeyCache();

    return TRUE;
}


DWORD
DpapiUpdateLsaSecret(
    IN PVOID pvContext)
{
    CRYPT_SERVER_CONTEXT SystemContext;
    CRYPT_SERVER_CONTEXT SystemUserContext;
    CRYPT_SERVER_CONTEXT LocalServiceContext;
    CRYPT_SERVER_CONTEXT NetworkServiceContext;
    LPWSTR pszUserStorageArea = NULL;
    BOOL fSystemContextCreated = FALSE;
    BOOL fSystemUserContextCreated = FALSE;
    BOOL fLocalServiceContextCreated = FALSE;
    BOOL fNetworkServiceContextCreated = FALSE;
    BOOL fNewSecretCreated = TRUE;
    GUID guidMasterKey;
    BOOL fOverrideToLocalSystem;
    DWORD dwRet;

    D_DebugLog((DEB_TRACE_API, "DpapiUpdateLsaSecret\n"));


    //
    // TCB privilege must be held by the client in order to
    // make this call.  Verify that before doing anything else
    //

    dwRet = CPSImpersonateClient( pvContext );

    if(dwRet == ERROR_SUCCESS) 
    {
        HANDLE ClientToken;

        dwRet = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &ClientToken
                     );

        if ( NT_SUCCESS( dwRet )) 
        {
            BOOLEAN Result = FALSE;
            PRIVILEGE_SET RequiredPrivileges;
            LUID_AND_ATTRIBUTES PrivilegeArray[1];

            RequiredPrivileges.PrivilegeCount = 1;
            RequiredPrivileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
            RequiredPrivileges.Privilege[0].Luid = RtlConvertLongToLuid( SE_TCB_PRIVILEGE );
            RequiredPrivileges.Privilege[0].Attributes = 0;

            dwRet = NtPrivilegeCheck(
                         ClientToken,
                         &RequiredPrivileges,
                         &Result
                         );

            if ( NT_SUCCESS( dwRet ) &&
                 Result == FALSE ) 
            {
                dwRet = STATUS_PRIVILEGE_NOT_HELD;
            }

            NtClose( ClientToken );
            ClientToken = NULL;
        }

        CPSRevertToSelf( pvContext );
    }

    if(!NT_SUCCESS(dwRet))
    {
        D_DebugLog((DEB_ERROR, "DpapiUpdateLsaSecret: TCB privilege required!\n"));
        goto cleanup;
    }


    //
    // Enumerate through all of the master keys in the Protect\S-1-5-18  
    // directory, and load them all up in the master key cache.
    //

    D_DebugLog((DEB_TRACE, "Load system master keys into cache\n"));

    dwRet = CPSCreateServerContext(&SystemContext, NULL);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    fSystemContextCreated = TRUE;

    fOverrideToLocalSystem = TRUE; 
    CPSOverrideToLocalSystem(&SystemContext, &fOverrideToLocalSystem, NULL);

    dwRet = SynchronizeMasterKeys(&SystemContext, ADD_MASTER_KEY_TO_CACHE);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }


    //
    // Enumerate through all of the master keys in the Protect\S-1-5-18\User 
    // directory, and load them all up in the master key cache.
    //

    dwRet = CPSCreateServerContext(&SystemUserContext, NULL);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    fSystemUserContextCreated = TRUE;

    dwRet = SynchronizeMasterKeys(&SystemUserContext, ADD_MASTER_KEY_TO_CACHE);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }


    //
    // Enumerate through all of the master keys in the Protect\S-1-5-19 
    // directory, and load them all up in the master key cache.
    //

    dwRet = CPSCreateServerContext(&LocalServiceContext, NULL);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    fLocalServiceContextCreated = TRUE;

    CPSSetWellKnownAccount(&LocalServiceContext, DP_ACCOUNT_LOCAL_SERVICE);
    
    dwRet = SynchronizeMasterKeys(&LocalServiceContext, ADD_MASTER_KEY_TO_CACHE);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }


    //
    // Enumerate through all of the master keys in the Protect\S-1-5-20 
    // directory, and load them all up in the master key cache.
    //

    dwRet = CPSCreateServerContext(&NetworkServiceContext, NULL);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    fNetworkServiceContextCreated = TRUE;

    CPSSetWellKnownAccount(&NetworkServiceContext, DP_ACCOUNT_NETWORK_SERVICE);
    
    dwRet = SynchronizeMasterKeys(&NetworkServiceContext, ADD_MASTER_KEY_TO_CACHE);
    if(dwRet != ERROR_SUCCESS)
    {
        goto cleanup;
    }


    //
    // Regenerate the DPAPI_SYSTEM value.
    //

    D_DebugLog((DEB_TRACE, "Reset lsa secret\n"));

    if(!UpdateSystemCredentials())
    {
        fNewSecretCreated = FALSE;
        DebugLog((DEB_ERROR, "Unable to reset DPAPI_SYSTEM secret.\n"));
    }


    //
    // Reencrypt and write back all of the master keys that are in the cache.
    // Note that since this routine should only be called on brand-new machines
    // that have just been setup using SYSPREP, the total number of master keys
    // should always be exactly two. Thus, we shouldn't have to worry about
    // overflowing the master key cache or anything like that.
    //

    D_DebugLog((DEB_TRACE, "Reencrypt system master keys\n"));

    if(fNewSecretCreated)
    {
        SynchronizeMasterKeys(&SystemContext, REENCRYPT_MASTER_KEY);
        SynchronizeMasterKeys(&SystemUserContext, REENCRYPT_MASTER_KEY);
        SynchronizeMasterKeys(&LocalServiceContext, REENCRYPT_MASTER_KEY);
        SynchronizeMasterKeys(&NetworkServiceContext, REENCRYPT_MASTER_KEY);
    }


    //
    // Generate two new master keys, and mark them as preferred.
    //

    D_DebugLog((DEB_TRACE, "Generate new system master keys\n"));

    dwRet = CPSGetUserStorageArea( &SystemContext, 
                                   NULL, 
                                   FALSE, 
                                   &pszUserStorageArea );
    if(dwRet == ERROR_SUCCESS)
    {
        dwRet = CreateMasterKey( &SystemContext, pszUserStorageArea, &guidMasterKey, FALSE );
        if(dwRet == ERROR_SUCCESS)
        {
            SetPreferredMasterKeyGuid( &SystemContext, pszUserStorageArea, &guidMasterKey );
        }

        SSFree(pszUserStorageArea);
        pszUserStorageArea = NULL;
    }
    else if(dwRet == ERROR_PATH_NOT_FOUND)
    {
        dwRet = ERROR_SUCCESS;
    }


    dwRet = CPSGetUserStorageArea( &SystemUserContext, 
                                   NULL, 
                                   FALSE, 
                                   &pszUserStorageArea );
    if(dwRet == ERROR_SUCCESS)
    {
        dwRet = CreateMasterKey( &SystemUserContext, pszUserStorageArea, &guidMasterKey, FALSE );
        if(dwRet == ERROR_SUCCESS)
        {
            SetPreferredMasterKeyGuid( &SystemUserContext, pszUserStorageArea, &guidMasterKey );
        }
    
        SSFree(pszUserStorageArea);
        pszUserStorageArea = NULL;
    }
    else if(dwRet == ERROR_PATH_NOT_FOUND)
    {
        dwRet = ERROR_SUCCESS;
    }


    dwRet = CPSGetUserStorageArea( &LocalServiceContext, 
                                   NULL, 
                                   FALSE, 
                                   &pszUserStorageArea );
    if(dwRet == ERROR_SUCCESS)
    {
        dwRet = CreateMasterKey( &LocalServiceContext, pszUserStorageArea, &guidMasterKey, FALSE );
        if(dwRet == ERROR_SUCCESS)
        {
            SetPreferredMasterKeyGuid( &LocalServiceContext, pszUserStorageArea, &guidMasterKey );
        }
    
        SSFree(pszUserStorageArea);
        pszUserStorageArea = NULL;
    }
    else if(dwRet == ERROR_PATH_NOT_FOUND)
    {
        dwRet = ERROR_SUCCESS;
    }


    dwRet = CPSGetUserStorageArea( &NetworkServiceContext, 
                                   NULL, 
                                   FALSE, 
                                   &pszUserStorageArea );
    if(dwRet == ERROR_SUCCESS)
    {
        dwRet = CreateMasterKey( &NetworkServiceContext, pszUserStorageArea, &guidMasterKey, FALSE );
        if(dwRet == ERROR_SUCCESS)
        {
            SetPreferredMasterKeyGuid( &NetworkServiceContext, pszUserStorageArea, &guidMasterKey );
        }
    
        SSFree(pszUserStorageArea);
        pszUserStorageArea = NULL;
    }
    else if(dwRet == ERROR_PATH_NOT_FOUND)
    {
        dwRet = ERROR_SUCCESS;
    }


    //
    // Cleanup.
    //

cleanup:

    if(fSystemContextCreated)
    {
        CPSDeleteServerContext( &SystemContext );
    }

    if(fSystemUserContextCreated)
    {
        CPSDeleteServerContext( &SystemUserContext );
    }
    
    if(fLocalServiceContextCreated)
    {
        CPSDeleteServerContext( &LocalServiceContext );
    }

    if(fNetworkServiceContextCreated)
    {
        CPSDeleteServerContext( &NetworkServiceContext );
    }

    D_DebugLog((DEB_TRACE_API, "DpapiUpdateLsaSecret returned 0x%x\n", dwRet));

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\keysrv.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    keybckup.cpp

Abstract:

    This module contains routines associated with server side Key Backup
    operations.

    User sends data D2 to remote agent (remote agent is this code)
    Agent uses secret monster key K, random R2, HMACs to derive SymKeyK.
    Use SymKeyK to encrypt {userid, D2}
    Agent returns recovery field E{userid, D2}, R2 to User
    User stores recovery field E{userid, D2}, R2

Author:

    Scott Field (sfield)    16-Aug-97

--*/

#include <pch.cpp>
#pragma hdrstop
#include <ntlsa.h>

//
// functions to backup and restore to/from recoverable blob
//

BOOL
BackupToRecoverableBlobW2K(
    IN      HANDLE hToken,  // client access token opened for TOKEN_QUERY
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut
    );

BOOL
RestoreFromRecoverableBlob(
    IN      HANDLE  hToken,
    IN      BOOL    fWin2kDataOut,
    IN      BYTE  * pDataIn,
    IN      DWORD   cbDataIn,
    IN  OUT BYTE ** ppDataOut,
    IN  OUT DWORD * pcbDataOut
    );


BOOL
RestoreFromRecoverableBlobW2K(
    IN      HANDLE hToken,  // client access token opened for TOKEN_QUERY
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut
    );



BOOL ConvertRecoveredBlobToW2KBlob(
    IN      BYTE *pbMasterKey,
    IN      DWORD cbMaserKey,
    IN      PBYTE pbLocalKey,
    IN      DWORD cbLocalKey,
    IN      PSID pSidCandidate,
    IN  OUT BYTE **ppbDataOut,
    IN  OUT DWORD *pcbDataOut);



//
// functions to get/create/set keys to persistent storage.
//

BOOL
GetBackupKey(
    IN      GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey,
        OUT HCRYPTPROV *phCryptProv,
        OUT HCRYPTKEY  *phCryptKey
    );

BOOL
CreateBackupKeyW2K(
    IN      DWORD dwKeyVersion,
    IN  OUT GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey);

BOOL
CreateBackupKey(
    IN      DWORD dwKeyVersion,
    IN  OUT GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey,
        OUT HCRYPTPROV *phCryptProv,
        OUT HCRYPTKEY  *phCryptKey
    );

BOOL
SaveBackupKey(
    IN      GUID *pguidKey,
    IN      BYTE *pbKey,
    IN      DWORD cbKey
    );

BOOL
DestroyBackupKey(
    IN      GUID guidKey
    );

//
// functions to get/create/set the preferred backup key.
//

BOOL
SetupPreferredBackupKeys(
    VOID
    );



BOOL
FreePreferredBackupKey(
    VOID
    );

//
// helper functions to set/get the GUID associated with the preferred
// backup key.
//

BOOL
GetPreferredBackupKeyGuid(
    IN      DWORD dwVersion,
    IN  OUT GUID *pguidKey
    );

BOOL
SetPreferredBackupKeyGuid(
    IN      DWORD dwVersion,
    IN      GUID *pguidKey
    );

//
// helper functions for managing SYSTEM credentials.
//

BOOL
CreateSystemCredentials(
    VOID
    );

DWORD
QuerySystemCredentials(
    IN  OUT BYTE rgbSystemCredMachine[ A_SHA_DIGEST_LEN ],
    IN  OUT BYTE rgbSystemCredUser [ A_SHA_DIGEST_LEN ]
    );

BOOL
FreeSystemCredentials(
    VOID
    );

BOOL GeneratePublicKeyCert(HCRYPTPROV hCryptProv,
                           HCRYPTKEY hCryptKey,
                           GUID *pguidKey,
                           DWORD *pcbPublicExportLength,
                           PBYTE *ppbPublicExportData);

//
// utility functions for interacting with LSA, etc.
//


NTSTATUS
OpenPolicy(
    LPWSTR ServerName,          // machine to open policy on (Unicode)
    DWORD DesiredAccess,        // desired access to policy
    PLSA_HANDLE PolicyHandle    // resultant policy handle
    );

BOOL
WaitOnSAMDatabase(
    VOID
    );


#define FILETIME_TICKS_PER_SECOND  10000000
#define BACKUPKEY_LIFETIME (60*60*24*365) // 1 Year


//
// private defines and prototypes for the backup and restore
// blob operations.
//

#define BACKUPKEY_VERSION_W2K   1       // legacy version of monster key material
#define BACKUPKEY_MATERIAL_SIZE (256)   // monster key material size, excluding version, etc.


#define BACKUPKEY_VERSION       2       // legacy version of monster key material
//
// LSA secret key name prefix, textual GUID key ID follows
//
#define BACKUPKEY_NAME_PREFIX   L"G$BCKUPKEY_"

//
// LSA secret key name - identifies GUID of legacy preferred key
//
#define BACKUPKEY_PREFERRED_W2K     L"G$BCKUPKEY_P"

//
// LSA secret key name - identifies GUID of preferred key
//
#define BACKUPKEY_PREFERRED         L"G$BCKUPKEY_PREFERRED"

//
// exposed Random R2 used to derive symetric key from monster key
// BACKUPKEY_R2_LEN makes BACKUPKEY_RECOVERY_BLOB size mod 32.
//
#define BACKUPKEY_R2_LEN        (68)        // length of random HMAC data

//
// size of inner Random R3 used to derive MAC key.
//

#define BACKUPKEY_R3_LEN        (32)

typedef struct {
    DWORD dwVersion;            // version of structure (BACKUPKEY_RECOVERY_BLOB_VERSION)
    DWORD cbClearData;          // quantity of clear data, not including Sid
    DWORD cbCipherData;         // quantity of cipher data following structure
    GUID guidKey;               // guid identifying backup key used
    BYTE R2[BACKUPKEY_R2_LEN];  // random data used during HMAC to derive symetric key
} BACKUPKEY_RECOVERY_BLOB_W2K, 
     *PBACKUPKEY_RECOVERY_BLOB_W2K, 
     *LPBACKUPKEY_RECOVERY_BLOB_W2K;

//
// when dwOuterVersion is 1,
// BYTE bCipherData[cbCipherData] follows
//
// in the clear, bCipherData is
// struct BACKUPKEY_INNER_BLOB
// BYTE bUserClearData[cbClearData]
// SID data follows bUserClearData[cbClearData]
// GetLengthSid() yields sid data length, IsValidSid() used to validate
// structural integrity of data.  Further authentication of requesting user
// done when restore requested.
//

typedef struct {
    BYTE R3[BACKUPKEY_R3_LEN];  // random data used to derive MAC key
    BYTE MAC[A_SHA_DIGEST_LEN]; // HMAC(R3, pUserSid | pbClearUserData)
} BACKUPKEY_INNER_BLOB_W2K, 
 *PBACKUPKEY_INNER_BLOB_W2K, 
 *LPBACKUPKEY_INNER_BLOB_W2K;



//
// definitions to support credentials for the SYSTEM account.
// this includes two scenarios:
// 1. Calls originating from the local system account security context.
// 2. Calls with the LOCAL_MACHINE disposition.
//

#define SYSTEM_CREDENTIALS_VERSION  1
#define SYSTEM_CREDENTIALS_SECRET   L"DPAPI_SYSTEM"

typedef struct {
    DWORD dwVersion;
    BYTE rgbSystemCredMachine[ A_SHA_DIGEST_LEN ];
    BYTE rgbSystemCredUser[ A_SHA_DIGEST_LEN ];
} SYSTEM_CREDENTIALS, *PSYSTEM_CREDENTIALS, *LPSYSTEM_CREDENTIALS;



//
//  Counter value and name for memory mapped file.
//  See timer.exe...
//
#ifdef DCSTRESS

LPVOID g_pCounter = NULL;
#define WSZ_MAP_OBJECT      L"rpcnt"

#endif // DCSTRESS



BOOL g_fBackupKeyServerStarted = FALSE;


//
// Legacy system preferred backup key
//

GUID g_guidW2KPreferredKey;
PBYTE g_pbW2KPreferredKey = NULL;
DWORD g_cbW2KPreferredKey = 0;


// Public/Private style preferred key
GUID g_guidPreferredKey;
PBYTE g_pbPreferredKey = NULL;
DWORD g_cbPreferredKey = 0;
HCRYPTPROV g_hProvPreferredKey = NULL;
HCRYPTKEY  g_hKeyPreferredKey = NULL;

RTL_CRITICAL_SECTION g_csInitialization;

BOOL g_fSetupPreferredAttempted = FALSE;



//
// global SYSTEM credentials:
//  One is for calls originating from the Local System account security context
//  at per-user disposition;
//  The other key is for calls originating from any account at the per-machine
//  disposition.
//

BOOL g_fSystemCredsInitialized = FALSE;
BYTE g_rgbSystemCredMachine[ A_SHA_DIGEST_LEN ];
BYTE g_rgbSystemCredUser[ A_SHA_DIGEST_LEN ];


DWORD
s_BackuprKey(
    /* [in] */ handle_t h,
    /* [in] */ GUID __RPC_FAR *pguidActionAgent,
    /* [in] */ BYTE __RPC_FAR *pDataIn,
    /* [in] */ DWORD cbDataIn,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppDataOut,
    /* [out] */ DWORD __RPC_FAR *pcbDataOut,
    /* [in] */ DWORD dwParam
    )
/*++

    Server side implemention of the BackupKey() interface.

--*/
{

    static const GUID guidBackup = BACKUPKEY_BACKUP_GUID;
    static const GUID guidRestoreW2K = BACKUPKEY_RESTORE_GUID_W2K;

    static const GUID guidRestore = BACKUPKEY_RESTORE_GUID;
    static const GUID guidRetrieve = BACKUPKEY_RETRIEVE_BACKUP_KEY_GUID;

    HANDLE hToken = NULL;
    PBYTE pTempDataOut;
    BOOL fEncrypt;
    BOOL fSuccess;
    DWORD dwLastError = ERROR_SUCCESS;
    DWORD rc;

    if( !g_fBackupKeyServerStarted )
        return ERROR_INVALID_PARAMETER;

    __try {

        //
        // insure the preferred key is setup.
        //

        if(!SetupPreferredBackupKeys())
            return ERROR_INVALID_PARAMETER;


        //
        // pickup a copy of an access token representing the client.
        //

        dwLastError = RpcImpersonateClient( h );

        if(dwLastError != RPC_S_OK)
            goto cleanup;

        fSuccess = OpenThreadToken(
                        GetCurrentThread(),
                        TOKEN_QUERY,
                        FALSE,
                        &hToken
                        );

        if(!fSuccess)
            dwLastError = GetLastError();

        if ((RPC_S_OK != (rc = RpcRevertToSelf())) && fSuccess)
        {
            dwLastError = rc;
            goto cleanup;
        }

        if(!fSuccess)
            goto cleanup;


        if(memcmp(pguidActionAgent, &guidRestore, sizeof(GUID)) == 0) 
        {
            if(cbDataIn < sizeof(DWORD))
            {
                // Not enough room for a version 
                dwLastError = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            if(BACKUPKEY_RECOVERY_BLOB_VERSION_W2K == ((DWORD *)pDataIn)[0])
            {
                // The recovery blob is of the legacy style, so simply
                // restore it the old way.
                fSuccess = RestoreFromRecoverableBlobW2K(
                            hToken,
                            pDataIn,
                            cbDataIn,
                            &pTempDataOut,
                            pcbDataOut
                            );
            }
            else if(BACKUPKEY_RECOVERY_BLOB_VERSION == ((DWORD *)pDataIn)[0])
            {
           
                fSuccess = RestoreFromRecoverableBlob(
                            hToken,
                            FALSE,
                            pDataIn,
                            cbDataIn,
                            &pTempDataOut,
                            pcbDataOut
                            );
            }
            else
            {
                dwLastError = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
        } 
        else if(memcmp(pguidActionAgent, &guidBackup, sizeof(GUID)) == 0) 
        {
            // We only use the legacy mechanism for backup when the backup
            // method is called.  The real mechanism of backup 
            // requires backup on the client machine alone.

            fSuccess = BackupToRecoverableBlobW2K(
                        hToken,
                        pDataIn,
                        cbDataIn,
                        &pTempDataOut,
                        pcbDataOut
                        );
        } 
        else if(memcmp(pguidActionAgent, &guidRestoreW2K, sizeof(GUID)) == 0) 
        {
            //
            // A legacy client is calling, and always expects a legacy 
            // pbBK style return blob.

            if(cbDataIn < sizeof(DWORD))
            {
                // Not enough room for a version 
                dwLastError = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            if(BACKUPKEY_RECOVERY_BLOB_VERSION_W2K == ((DWORD *)pDataIn)[0])
            {
                // The recovery blob is of the legacy style, so simply
                // restore it the old way.
                fSuccess = RestoreFromRecoverableBlobW2K(
                            hToken,
                            pDataIn,
                            cbDataIn,
                            &pTempDataOut,
                            pcbDataOut
                            );
            }
            else if(BACKUPKEY_RECOVERY_BLOB_VERSION == ((DWORD *)pDataIn)[0])
            {
                // This is a current recovery blob, so restore it the
                // current way
                fSuccess = RestoreFromRecoverableBlob(
                            hToken,
                            TRUE,
                            pDataIn,
                            cbDataIn,
                            &pTempDataOut,
                            pcbDataOut
                            );
            }
            else
            {
                dwLastError = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

        } 
        else if(memcmp(pguidActionAgent, &guidRetrieve, sizeof(GUID)) == 0) 
        {
            //
            // The client is asking for a copy of the domain backup public key.
            //

            if(FIsLegacyCompliant())
            {
                dwLastError = ERROR_NOT_SUPPORTED;
                goto cleanup;
            }

            if(!FDistributeDomainBackupKey())
            {
                dwLastError = ERROR_NOT_SUPPORTED;
                goto cleanup;
            }

            if((g_cbPreferredKey < 3*sizeof(DWORD)) ||
               (((DWORD *)g_pbPreferredKey)[0] != BACKUPKEY_VERSION) ||
               (((DWORD *)g_pbPreferredKey)[1] + 
                ((DWORD *)g_pbPreferredKey)[2] + 3*sizeof(DWORD) != g_cbPreferredKey))

            {
                dwLastError = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            pTempDataOut = (PBYTE)SSAlloc(((DWORD *)g_pbPreferredKey)[2]);
            if(NULL == pTempDataOut)
            {
                dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            CopyMemory(pTempDataOut, 
                       g_pbPreferredKey + 
                        3*sizeof(DWORD) +
                        ((DWORD *)g_pbPreferredKey)[1],
                       ((DWORD *)g_pbPreferredKey)[2]);

            *pcbDataOut = ((DWORD *)g_pbPreferredKey)[2];
            fSuccess = TRUE;
        } 
        else 
        {
            dwLastError = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }


        if( fSuccess ) {

            //
            // everything went as planned: tell caller about buffer
            //

            *ppDataOut = pTempDataOut;



#ifdef DCSTRESS

            //
            //  Increment RPC counter for timer.exe, if timer
            //  is running.
            //
            if (g_pCounter)
                (*(DWORD*)g_pCounter)++;

#endif // DCSTRESS



        } else {
            dwLastError = GetLastError();
            if(dwLastError == ERROR_SUCCESS) {
                dwLastError = ERROR_FILE_NOT_FOUND;
            }
        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {

        // TODO: convert to Win Error
        dwLastError = GetExceptionCode();
    }

cleanup:

    if(hToken)
        CloseHandle(hToken);

    return dwLastError;
}


///////////////////////////////////////////////////////////////////
// BackupToRecoverableBlobW2K
//
// This functionality is requested by W2K legacy clients, which
// are passing up the pbBK Backup key to be encrypted into a 
// pbBBK.
//
// We encrypt this verbatim, using a version of 
// BACKUPKEY_RECOVERY_BLOB_BK, indicating that 
// BACKUPKEY_RESTORE_GUID_W2K must be used 
// to recover this blob, not BACKUPKEY_RESTORE_GUID.
//
// Post W2K Recovery blobs are created on the clients, so we don't
// need server code to create them.
// 
// The format of the output data is as follows:
//
//      typedef struct {
//          DWORD dwVersion;            // version of structure
//          DWORD cbClearData;          // length of input data
//          DWORD cbCipherData;         // quantity of cipher data following structure
//          GUID guidKey;               // guid identifying backup key used
//          BYTE R2[BACKUPKEY_R2_LEN];  // random data used during HMAC to derive symetric key
//      } BACKUPKEY_RECOVERY_BLOB_W2K;
//
//      typedef struct {
//          BYTE R3[BACKUPKEY_R3_LEN];  // random data used to derive MAC key
//          BYTE MAC[A_SHA_DIGEST_LEN]; // HMAC(R3, pUserSid | pbClearUserData)
//      } BACKUPKEY_INNER_BLOB_W2K;
//
//      <user sid>
//      <input data>
//
// The BACKUPKEY_INNER_BLOB_W2K structure and the data following 
// it are encrypted.
//
///////////////////////////////////////////////////////////////////
BOOL
BackupToRecoverableBlobW2K(
    IN      HANDLE hToken,
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut
    )
{
    PSID pSidUser = NULL;
    DWORD cbSidUser;

    PBACKUPKEY_RECOVERY_BLOB_W2K    pRecoveryBlob;
    DWORD                           cbRecoveryBlob;
    PBACKUPKEY_INNER_BLOB_W2K       pInnerBlob;
    DWORD                           cbInnerBlob;
    PBYTE pbCipherBegin;
    BYTE rgbSymKey[A_SHA_DIGEST_LEN];
    BYTE rgbMacKey[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT sRC4Key;

    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;


    if( pDataIn == NULL || cbDataIn == 0 ||
        ppDataOut == NULL || pcbDataOut == NULL ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *ppDataOut = NULL;

    //
    // get Sid associated with client user.
    //

    if(!GetTokenUserSid( hToken, &pSidUser ))
        return FALSE;

    cbSidUser = GetLengthSid( pSidUser );


    //
    // Calculate the size of the inner blob
    //
    cbInnerBlob = sizeof(BACKUPKEY_INNER_BLOB_W2K) +
                  cbSidUser +
                  cbDataIn;


    //
    // Estimate the size of the encrypted data buffer
    //

    //
    // allocate buffer to contain results
    // RECOVERABLE_BLOB struct + Sid + cbDataIn
    // note that cbDataIn works because we use a stream cipher.
    //

    *pcbDataOut = sizeof(BACKUPKEY_RECOVERY_BLOB_W2K) +
                    sizeof(BACKUPKEY_INNER_BLOB_W2K) +
                    cbSidUser +
                    cbDataIn ;

    *ppDataOut = (LPBYTE)SSAlloc( *pcbDataOut );
    if(*ppDataOut == NULL) {
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }

    pRecoveryBlob = (PBACKUPKEY_RECOVERY_BLOB_W2K)*ppDataOut;
    pRecoveryBlob->dwVersion = BACKUPKEY_RECOVERY_BLOB_VERSION_W2K;
    pRecoveryBlob->cbClearData = cbDataIn; // does not include Sid since not handed back on restore
    pRecoveryBlob->cbCipherData = sizeof(BACKUPKEY_INNER_BLOB_W2K) + cbSidUser + cbDataIn;
    CopyMemory( &(pRecoveryBlob->guidKey), &g_guidW2KPreferredKey, sizeof(GUID));

    pInnerBlob = (PBACKUPKEY_INNER_BLOB_W2K)(pRecoveryBlob+1);

    //
    // generate random R2 for SymKey
    //

    if(!RtlGenRandom(pRecoveryBlob->R2, BACKUPKEY_R2_LEN))
        goto cleanup;

    //
    // generate random R3 for MAC
    //

    if(!RtlGenRandom(pInnerBlob->R3, BACKUPKEY_R3_LEN))
        goto cleanup;


    //
    // check that we are dealing with a persisted key version we
    // understand.
    //

    if( ((DWORD*)g_pbW2KPreferredKey)[0] != BACKUPKEY_VERSION_W2K)
        goto cleanup;

    //
    // derive symetric key via HMAC from preferred backup key and
    // random R2.
    //

    if(!FMyPrimitiveHMACParam(
            (LPBYTE)g_pbW2KPreferredKey + sizeof(DWORD),
            g_cbW2KPreferredKey - sizeof(DWORD),
            pRecoveryBlob->R2,
            BACKUPKEY_R2_LEN,
            rgbSymKey
            ))
        goto cleanup;

    //
    // derive MAC key via HMAC from preferred backup key and
    // random R3.
    //

    if(!FMyPrimitiveHMACParam(
            (LPBYTE)g_pbW2KPreferredKey + sizeof(DWORD),
            g_cbW2KPreferredKey - sizeof(DWORD),
            pInnerBlob->R3,
            BACKUPKEY_R3_LEN,
            rgbMacKey   // resultant MAC key
            ))
        goto cleanup;

    //
    // copy pSidUser and pDataIn following inner MAC'ish blob.
    //

    pbCipherBegin = (PBYTE)(pInnerBlob+1);

    CopyMemory( pbCipherBegin, pSidUser, cbSidUser );
    CopyMemory( pbCipherBegin+cbSidUser, pDataIn, cbDataIn );

    //
    // use MAC key to derive result from pSidUser and pDataIn
    //

    if(!FMyPrimitiveHMACParam(
            rgbMacKey,
            sizeof(rgbMacKey),
            pbCipherBegin,
            cbSidUser + cbDataIn,
            pInnerBlob->MAC // resultant MAC for verification.
            ))
        goto cleanup;

    //
    // adjust cipher start point to include R3 and MAC.
    //

    pbCipherBegin = (PBYTE)(pRecoveryBlob+1);


    //
    // initialize rc4 key
    //

    rc4_key(&sRC4Key, sizeof(rgbSymKey), rgbSymKey);

    //
    // encrypt data R3, MAC, pSidUser, pDataIn beyond recovery blob
    //

    rc4(&sRC4Key, pRecoveryBlob->cbCipherData, pbCipherBegin);

    fSuccess = TRUE;

cleanup:

    RtlSecureZeroMemory( &sRC4Key, sizeof(sRC4Key) );
    RtlSecureZeroMemory( rgbSymKey, sizeof(rgbSymKey) );

    if(pSidUser)
        SSFree(pSidUser);

    if(!fSuccess) {
        if(*ppDataOut) {
            SSFree(*ppDataOut);
            *ppDataOut = NULL;
        }

        if( dwLastError == ERROR_SUCCESS )
            dwLastError = ERROR_INVALID_DATA;

        SetLastError( dwLastError );
    }

    return fSuccess;
}





BOOL
RestoreFromRecoverableBlobW2K(
    IN      HANDLE hToken,
    IN      BYTE *pDataIn,
    IN      DWORD cbDataIn,
    IN  OUT BYTE **ppDataOut,
    IN  OUT DWORD *pcbDataOut
    )
{
    PSID pSidCandidate;
    DWORD cbSidCandidate;
    BOOL fIsMember;

    PBACKUPKEY_RECOVERY_BLOB_W2K pRecoveryBlob;
    PBACKUPKEY_INNER_BLOB_W2K    pInnerBlob;
    PBYTE                        pbCipherBegin;
    BYTE                         rgbSymKey[A_SHA_DIGEST_LEN];
    BYTE                         rgbMacKey[A_SHA_DIGEST_LEN];
    BYTE                         rgbMacCandidate[A_SHA_DIGEST_LEN];
    RC4_KEYSTRUCT                sRC4Key;

    PBYTE pbPersistedKey = NULL;
    DWORD cbPersistedKey = 0;
    BOOL fUsedPreferredKey = TRUE; // did we use preferred backup key?

    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;


    if( pDataIn == NULL || cbDataIn == 0 ||
        ppDataOut == NULL || pcbDataOut == NULL ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *ppDataOut = NULL;

    pRecoveryBlob = (PBACKUPKEY_RECOVERY_BLOB_W2K)pDataIn;

    //
    // check for invalid recovery blob version.
    // also check that input and output size fields aren't out of bounds
    // for a stream cipher (v1 blob).
    // TODO: further size validation against cbClearData and cbCipherData.
    //

    if(
        cbDataIn < (sizeof(BACKUPKEY_RECOVERY_BLOB_W2K) + sizeof(BACKUPKEY_INNER_BLOB_W2K)) ||
        pRecoveryBlob->dwVersion != BACKUPKEY_RECOVERY_BLOB_VERSION_W2K ||
        pRecoveryBlob->cbCipherData != (cbDataIn - sizeof(BACKUPKEY_RECOVERY_BLOB_W2K)) ||
        pRecoveryBlob->cbClearData > pRecoveryBlob->cbCipherData
        ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // determine if we use the preferred key, or some other key.
    // if the specified key is not the preferred one, fetch the
    // proper key.
    //

    if(memcmp(&g_guidW2KPreferredKey, &(pRecoveryBlob->guidKey), sizeof(GUID)) == 0) {

        pbPersistedKey = g_pbW2KPreferredKey;
        cbPersistedKey = g_cbW2KPreferredKey;
        fUsedPreferredKey = TRUE;
    } else {
        if(!GetBackupKey(
                    &(pRecoveryBlob->guidKey),
                    &pbPersistedKey,
                    &cbPersistedKey,
                    NULL,
                    NULL
                    ))
                goto cleanup;

        fUsedPreferredKey = FALSE;
    }

    //
    // check that we are dealing with a persisted key version we
    // understand.
    //

    if(((DWORD*)pbPersistedKey)[0] != BACKUPKEY_VERSION_W2K)
        goto cleanup;

    //
    // derive symetric key via HMAC from backup key and random R2.
    //

    if(!FMyPrimitiveHMACParam(
                    (LPBYTE)pbPersistedKey + sizeof(DWORD),
                    cbPersistedKey - sizeof(DWORD),
                    pRecoveryBlob->R2,
                    BACKUPKEY_R2_LEN,
                    rgbSymKey
                    ))
            goto cleanup;


    //
    // initialize rc4 key
    //

    rc4_key(&sRC4Key, sizeof(rgbSymKey), rgbSymKey);

    //
    // decrypt data R3, MAC, pSidUser, pDataIn beyond recovery blob
    //

    pbCipherBegin = (PBYTE)(pRecoveryBlob+1);

    rc4(&sRC4Key, pRecoveryBlob->cbCipherData, pbCipherBegin);


    pInnerBlob = (PBACKUPKEY_INNER_BLOB_W2K)(pRecoveryBlob+1);

    //
    // derive MAC key via HMAC from backup key and random R3.
    //

    if(!FMyPrimitiveHMACParam(
            (LPBYTE)pbPersistedKey + sizeof(DWORD),
            cbPersistedKey - sizeof(DWORD),
            pInnerBlob->R3,
            BACKUPKEY_R3_LEN,
            rgbMacKey   // resultant MAC key
            ))
        goto cleanup;

    //
    // adjust pbCipherBegin to only include decrypted pUserSid, and pDataIn
    //
    pbCipherBegin = (PBYTE)(pInnerBlob+1);

    //
    // validate user Sid: compare client user to that embedded in
    // decrypted recovery blob.
    //

    pSidCandidate = (PSID)pbCipherBegin;

    if(!IsValidSid(pSidCandidate)) {
        dwLastError = ERROR_INVALID_SID;
        goto cleanup;
    }

    cbSidCandidate = GetLengthSid(pSidCandidate);

    //
    // use MAC key to derive result from pSidUser and pDataIn
    //

    if(!FMyPrimitiveHMACParam(
            rgbMacKey,
            sizeof(rgbMacKey),
            pbCipherBegin,
            pRecoveryBlob->cbCipherData - sizeof(BACKUPKEY_INNER_BLOB_W2K),
            rgbMacCandidate // resultant MAC for verification.
            ))
        goto cleanup;

    //
    // verify MAC equality
    //

    if(memcmp(pInnerBlob->MAC, rgbMacCandidate, A_SHA_DIGEST_LEN) != 0) {
        dwLastError = ERROR_INVALID_ACCESS;
        goto cleanup;
    }


    //
    // check if client passes accesscheck against embedded Sid.
    // TODO: see if we expand to check for ADMINS ?
    //

    if(!CheckTokenMembership( hToken, pSidCandidate, &fIsMember )) {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if( !fIsMember ) {
        dwLastError = ERROR_INVALID_ACCESS;
        goto cleanup;
    }

    //
    // validation against cbClearData for good measure.
    //

    if( pRecoveryBlob->cbClearData != (cbDataIn -
                                        sizeof(BACKUPKEY_RECOVERY_BLOB_W2K) -
                                        sizeof(BACKUPKEY_INNER_BLOB_W2K) -
                                        cbSidCandidate)
        ) {
        dwLastError = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // allocate buffer to contain results
    //

    *pcbDataOut = pRecoveryBlob->cbClearData;

    *ppDataOut = (LPBYTE)SSAlloc( *pcbDataOut );
    if(*ppDataOut == NULL) {
        *pcbDataOut = 0;
        dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }

    //
    // advance past decrypted Sid and copy results to caller.
    //

    CopyMemory(*ppDataOut, pbCipherBegin+cbSidCandidate, *pcbDataOut);

    fSuccess = TRUE;

cleanup:

    RtlSecureZeroMemory( &sRC4Key, sizeof(sRC4Key) );
    RtlSecureZeroMemory( rgbSymKey, sizeof(rgbSymKey) );
    RtlSecureZeroMemory( pDataIn, cbDataIn );

    //
    // free the fetched key if it wasn't the preferred one.
    //

    if(!fUsedPreferredKey && pbPersistedKey) {
        RtlSecureZeroMemory(pbPersistedKey, cbPersistedKey);
        SSFree(pbPersistedKey);
    }

    if(!fSuccess) {
        if(*ppDataOut) {
            SSFree(*ppDataOut);
            *ppDataOut = NULL;
        }

        if( dwLastError == ERROR_SUCCESS )
            dwLastError = ERROR_INVALID_DATA;

        SetLastError( dwLastError );
    }


    return fSuccess;
}

BOOL
RestoreFromRecoverableBlob(
    IN      HANDLE  hToken,
    IN      BOOL    fWin2kDataOut,
    IN      BYTE  * pDataIn,
    IN      DWORD   cbDataIn,
    IN  OUT BYTE ** ppDataOut,
    IN  OUT DWORD * pcbDataOut
    )
{
    PSID pSidCandidate;
    DWORD cbSidCandidate;
    BOOL fIsMember;

    PBACKUPKEY_RECOVERY_BLOB     pRecoveryBlob;
    PBACKUPKEY_KEY_BLOB          pKeyBlob;
    PBACKUPKEY_INNER_BLOB        pInnerBlob;

    DWORD cbKeyBlob = 0;

    PBYTE pbMasterKey = NULL;
    PBYTE pbPayloadKey = NULL;


    PBYTE pbPersistedKey = NULL;
    DWORD cbPersistedKey = 0;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY  hKey = NULL;

    BYTE    rgbPayloadMAC[A_SHA_DIGEST_LEN];


    BOOL fUsedPreferredKey = TRUE; // did we use preferred backup key?

    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fSuccess = FALSE;


    if( pDataIn == NULL || cbDataIn == 0 ||
        ppDataOut == NULL || pcbDataOut == NULL ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *ppDataOut = NULL;
    //
    // Make a copy of pDataIn, so we can decrypt the copy
    // and then destroy it
    //


    pRecoveryBlob = (PBACKUPKEY_RECOVERY_BLOB)SSAlloc(cbDataIn);
    if(NULL == pRecoveryBlob)
    {
        SetLastError(ERROR_NOT_ENOUGH_SERVER_MEMORY);
        return FALSE;
    }
    CopyMemory((PBYTE)pRecoveryBlob, 
               pDataIn,
               cbDataIn);

    //
    // check for invalid recovery blob version.
    // also check that input and output size fields aren't out of bounds
    // for a stream cipher (v1 blob).
    // TODO: further size validation against cbClearData and cbCipherData.
    //

    if(
        (cbDataIn < sizeof(BACKUPKEY_RECOVERY_BLOB)) ||
        (cbDataIn < (sizeof(BACKUPKEY_RECOVERY_BLOB) + pRecoveryBlob->cbEncryptedMasterKey + pRecoveryBlob->cbEncryptedPayload)) ||
        (pRecoveryBlob->dwVersion != BACKUPKEY_RECOVERY_BLOB_VERSION)
        ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // determine if we use the preferred key, or some other key.
    // if the specified key is not the preferred one, fetch the
    // proper key.
    //

    if(memcmp(&g_guidPreferredKey, &(pRecoveryBlob->guidKey), sizeof(GUID)) == 0) {

        pbPersistedKey = g_pbPreferredKey;
        cbPersistedKey = g_cbPreferredKey;
        hProv = g_hProvPreferredKey;
        hKey = g_hKeyPreferredKey;
        fUsedPreferredKey = TRUE;
    } else {
        if(!GetBackupKey(
                    &(pRecoveryBlob->guidKey),
                    &pbPersistedKey,
                    &cbPersistedKey,
                    &hProv,
                    &hKey
                    ))
        {
           dwLastError = GetLastError();
           goto cleanup;
        }

        fUsedPreferredKey = FALSE;
    }

    //
    // check that we are dealing with a persisted key version we
    // understand.
    //

    if(((DWORD*)pbPersistedKey)[0] != BACKUPKEY_VERSION)
    {
        dwLastError = NTE_BAD_KEY;
        goto cleanup;
    }

    pKeyBlob = (PBACKUPKEY_KEY_BLOB)(pRecoveryBlob+1);
    pInnerBlob = (PBACKUPKEY_INNER_BLOB)((PBYTE)pKeyBlob + pRecoveryBlob->cbEncryptedMasterKey);

    cbKeyBlob = pRecoveryBlob->cbEncryptedMasterKey;
    //
    // Decrypt the master key and payload key
    //

    if(!CryptDecrypt(hKey,
                     NULL,
                     TRUE,
                     0, //CRYPT_OAEP,
                     (PBYTE)pKeyBlob,
                     &cbKeyBlob))
    {
       dwLastError = GetLastError();
       goto cleanup;
    }



    //
    // Use the payload key to decrypt the payload
    //
    if(pKeyBlob->cbPayloadKey != DES3_KEYSIZE + DES_BLOCKLEN)
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }
    pbMasterKey= (PBYTE)(pKeyBlob+1);
    pbPayloadKey = pbMasterKey + pKeyBlob->cbMasterKey;

    if(pRecoveryBlob->cbEncryptedPayload < A_SHA_DIGEST_LEN + sizeof(BACKUPKEY_INNER_BLOB))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }



    {

        DES3TABLE s3DESKey;
        BYTE InputBlock[DES_BLOCKLEN];
        DWORD iBlock;
        DWORD cBlocks = pRecoveryBlob->cbEncryptedPayload/DES_BLOCKLEN;
        BYTE feedback[ DES_BLOCKLEN ];
        // initialize 3des key
        //

        if(cBlocks*DES_BLOCKLEN != pRecoveryBlob->cbEncryptedPayload)
        {
            // Master key must be a multiple of DES_BLOCKLEN
            goto cleanup;

        }
        tripledes3key(&s3DESKey, pbPayloadKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated 
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, pbPayloadKey + DES3_KEYSIZE, DES_BLOCKLEN);

        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {
            CopyMemory(InputBlock, 
                       ((PBYTE)pInnerBlob)+iBlock*DES_BLOCKLEN,
                       DES_BLOCKLEN);
            CBC(tripledes,
                DES_BLOCKLEN,
                ((PBYTE)pInnerBlob)+iBlock*DES_BLOCKLEN,
                InputBlock,
                &s3DESKey,
                DECRYPT,
                feedback);
        }
    }
    //
    // Check the MAC
    //

    // Generate the payload MAC

    FMyPrimitiveSHA( (PBYTE)pInnerBlob, 
                    pRecoveryBlob->cbEncryptedPayload  - A_SHA_DIGEST_LEN,
                    rgbPayloadMAC);

    if(0 != memcmp(rgbPayloadMAC, 
              (PBYTE)pInnerBlob + pRecoveryBlob->cbEncryptedPayload  - A_SHA_DIGEST_LEN,
              A_SHA_DIGEST_LEN))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }

    if(pInnerBlob->dwPayloadVersion != BACKUPKEY_PAYLOAD_VERSION)
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }


    pSidCandidate = (PBYTE)(pInnerBlob+1) + pInnerBlob->cbLocalKey;



    //
    // validate user Sid: compare client user to that embedded in
    // decrypted recovery blob.
    //


    if(!IsValidSid(pSidCandidate)) {
        dwLastError = ERROR_INVALID_SID;
        goto cleanup;
    }

    cbSidCandidate = GetLengthSid(pSidCandidate);

    if(cbSidCandidate + 
        pInnerBlob->cbLocalKey + 
        sizeof(BACKUPKEY_INNER_BLOB) +
        A_SHA_DIGEST_LEN > pRecoveryBlob->cbEncryptedPayload)
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }

    //
    // check if client passes accesscheck against embedded Sid.
    // TODO: see if we expand to check for ADMINS ?
    //

    if(!CheckTokenMembership( hToken, pSidCandidate, &fIsMember )) {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if( !fIsMember ) {
        dwLastError = ERROR_INVALID_ACCESS;
        goto cleanup;
    }


    if(fWin2kDataOut)
    {
       if(!ConvertRecoveredBlobToW2KBlob(
                                        pbMasterKey,
                                        pKeyBlob->cbMasterKey,
                                        (PBYTE)(pInnerBlob+1),
                                        pInnerBlob->cbLocalKey,
                                        pSidCandidate,
                                        ppDataOut,
                                        pcbDataOut))
       {
           dwLastError = GetLastError();
           goto cleanup;
       }

    }
    else
    {
        *pcbDataOut = sizeof(DWORD) + pKeyBlob->cbMasterKey;
        *ppDataOut = (LPBYTE)SSAlloc( *pcbDataOut );
        if(*ppDataOut == NULL) {
            *pcbDataOut = 0;
            dwLastError = ERROR_NOT_ENOUGH_SERVER_MEMORY;
            goto cleanup;
        }
        *((DWORD *)*ppDataOut) = MASTERKEY_BLOB_RAW_VERSION;
        CopyMemory((*ppDataOut) + sizeof(DWORD), pbMasterKey, (*pcbDataOut) - sizeof(DWORD));
    }


    fSuccess = TRUE;

cleanup:

    RtlSecureZeroMemory( pDataIn, cbDataIn );

    //
    // free the fetched key if it wasn't the preferred one.
    //

    if(!fUsedPreferredKey && pbPersistedKey) {
        RtlSecureZeroMemory(pbPersistedKey, cbPersistedKey);
        SSFree(pbPersistedKey);
        if(hKey)
        {
            CryptDestroyKey(hKey);
        }
        if(hProv)
        {
            CryptReleaseContext(hProv, 0);
        }
    }



    if(!fSuccess) {
        if(*ppDataOut) {
            SSFree(*ppDataOut);
            *ppDataOut = NULL;
        }

        if( dwLastError == ERROR_SUCCESS )
            dwLastError = ERROR_INVALID_DATA;

        SetLastError( dwLastError );
    }

    if(pRecoveryBlob)
    {
        RtlSecureZeroMemory(pRecoveryBlob, cbDataIn);
        SSFree(pRecoveryBlob);
    }


    return fSuccess;
}


RPC_STATUS
RPC_ENTRY
BackupCallback(
    RPC_IF_HANDLE idIF,
    PVOID pCtx)
{
    RPC_STATUS Status;
    PWSTR pBinding = NULL;
    PWSTR pProtSeq = NULL;

    Status = RpcBindingToStringBinding(pCtx, &pBinding);

    if(Status != RPC_S_OK)
    {
        goto cleanup;
    }

    Status = RpcStringBindingParse(pBinding,
                                   NULL,
                                   &pProtSeq,
                                   NULL,
                                   NULL,
                                   NULL);
    if(Status != RPC_S_OK)
    {
        goto cleanup;
    }

    // Make sure caller is using a supported protocol
    if((CompareString(LOCALE_INVARIANT,
                      NORM_IGNORECASE, 
                      pProtSeq,
                      -1,
                      DPAPI_LOCAL_PROT_SEQ,
                      -1) != CSTR_EQUAL) &&
       (CompareString(LOCALE_INVARIANT,
                      NORM_IGNORECASE, 
                      pProtSeq,
                      -1,
                      DPAPI_BACKUP_PROT_SEQ,
                      -1) != CSTR_EQUAL) &&
       (CompareString(LOCALE_INVARIANT,
                      NORM_IGNORECASE, 
                      pProtSeq,
                      -1,
                      DPAPI_LEGACY_BACKUP_PROT_SEQ,
                      -1) != CSTR_EQUAL))
    {
        Status = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    Status = RPC_S_OK;

cleanup:

    if(pProtSeq)
    {
        RpcStringFree(&pProtSeq);
    }

    if(pBinding)
    {
        RpcStringFree(&pBinding);
    }

    return Status;
}


DWORD 
InitializeBackupKeyServer(VOID)
{
    RPC_STATUS Status;
    LPWSTR pszPrincipalName = NULL;

    //
    // enable SNEGO authentication
    //
    
    Status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE, 
                                          &pszPrincipalName);

    if (RPC_S_OK != Status) 
    {
        return Status;
    }

    SS_ASSERT(0 != wcslen(pszPrincipalName));

    Status = RpcServerRegisterAuthInfoW(
                    pszPrincipalName,
                    RPC_C_AUTHN_GSS_NEGOTIATE,
                    0,
                    0
                    );

    RpcStringFree(&pszPrincipalName);
    pszPrincipalName = NULL;

    if( Status )
    {
        return Status;
    }


    Status = RpcServerRegisterIfEx(s_BackupKey_v1_0_s_ifspec, 
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   BackupCallback);

    if( Status )
    {
        return Status;
    }

    g_fBackupKeyServerStarted = TRUE;

    return ERROR_SUCCESS;
}


DWORD
WINAPI
QueueInitBackupKeyServerThreadFunc(
    IN LPVOID lpThreadArgument
    )
{
    RPC_STATUS Status;
    ULONG i;

    UNREFERENCED_PARAMETER(lpThreadArgument);

    // Loop for 10 minutes, then give up.
    for(i = 0; i < 40; i++)
    {
        // Sleep for 15 seconds.
        Sleep(15000);

        Status = InitializeBackupKeyServer();
        if(Status == RPC_S_OK)
        {
            return RPC_S_OK;
        }
    }

    DebugLog((DEB_ERROR, "InitializeBackupKeyServer failed forever: 0x%x\n", Status));

    return Status;
}


DWORD
StartBackupKeyServer(
    VOID
    )
{
    NTSTATUS Status;

    //
    // initialize critical section that prevents race condition for
    // deferred intitialization activities.
    //

    Status = RtlInitializeCriticalSection( &g_csInitialization );
    if(!NT_SUCCESS(Status))
    {
        return Status;
    }


    //
    // if we aren't a domain controller, don't do anything.
    //

    if(!IsDomainController())
    {
        return ERROR_SUCCESS;
    }


    //
    // Initialize domain recovery rpc endpoints.
    //

    Status = InitializeBackupKeyServer();

    if(Status != RPC_S_OK)
    {
        DebugLog((DEB_WARN, "InitializeBackupKeyServer failed on first attempt: 0x%x\n", Status));

        // First attempt failed, so queue up a worker thread to retry this operation periodically.
        if(!QueueUserWorkItem(
                QueueInitBackupKeyServerThreadFunc,
                NULL,
                WT_EXECUTELONGFUNCTION)) 
        {
            Status = GetLastError();
            DebugLog((DEB_ERROR, "Unable to start InitializeBackupKeyServer worker thread: 0x%x\n", Status));
            return Status;
        }
    }

    return ERROR_SUCCESS;
}


DWORD
StopBackupKeyServer(
    VOID
    )
{
    RPC_STATUS status;

    RtlDeleteCriticalSection( &g_csInitialization );

    //
    // only do something if the server started.
    //

    if(!g_fBackupKeyServerStarted)
        return ERROR_SUCCESS;

    status = RpcServerUnregisterIf(s_BackupKey_v1_0_s_ifspec, 0, 0);


    FreePreferredBackupKey();
    FreeSystemCredentials();

    g_fBackupKeyServerStarted = FALSE;

    return status;
}


BOOL
GetBackupKey(
    IN      GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey,
        OUT HCRYPTPROV *phCryptProv,
        OUT HCRYPTKEY  *phCryptKey
    )
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    WCHAR wszKeyGuid[ (sizeof(BACKUPKEY_NAME_PREFIX) / sizeof(WCHAR)) + MAX_GUID_SZ_CHARS ];
    NTSTATUS Status;
    BOOL fSuccess;

    if(pguidKey == NULL || ppbKey == NULL || pcbKey == NULL)
        return FALSE;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    CopyMemory(wszKeyGuid, BACKUPKEY_NAME_PREFIX, sizeof(BACKUPKEY_NAME_PREFIX));

    if(MyGuidToStringW(pguidKey,
        (LPWSTR)( (LPBYTE)wszKeyGuid + sizeof(BACKUPKEY_NAME_PREFIX) - sizeof(WCHAR) )
        ) != 0) return FALSE;

    InitLsaString(&SecretKeyName, wszKeyGuid);

    Status = OpenPolicy(NULL, POLICY_GET_PRIVATE_INFORMATION, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    Status = LsaRetrievePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &pSecretData
                );

    LsaClose(PolicyHandle);

    if(!NT_SUCCESS(Status) || pSecretData == NULL)
        return FALSE;

    *ppbKey = (LPBYTE)SSAlloc( pSecretData->Length );

    if(*ppbKey) {
        *pcbKey = pSecretData->Length;
        CopyMemory( *ppbKey, pSecretData->Buffer, pSecretData->Length );
        fSuccess = TRUE;
    } else {
        fSuccess = FALSE;
    }

    if(fSuccess && (NULL != phCryptProv))
    {
        if((*pcbKey >= sizeof(DWORD)) &&  // prefix bug 170438
           (*((DWORD *)*ppbKey) == BACKUPKEY_VERSION))
        {

            if(!CryptAcquireContext(phCryptProv,
                                    NULL,
                                    NULL,
                                    PROV_RSA_FULL,
                                    CRYPT_VERIFYCONTEXT))
            {
                fSuccess = FALSE;
            }
            else
            {
                if(phCryptKey)
                {
                    if(!CryptImportKey(*phCryptProv,
                                    (*ppbKey) + 3*sizeof(DWORD),
                                    ((DWORD *)*ppbKey)[1],
                                    NULL,
                                    0,
                                    phCryptKey))
                    {
                        fSuccess = FALSE;
                        CryptReleaseContext(*phCryptProv, 0);
                        *phCryptProv = NULL;
                    }
                }

            }
        }
        else
        {
            *phCryptProv = NULL;
        }
    }

    RtlSecureZeroMemory( pSecretData->Buffer, pSecretData->Length );
    LsaFreeMemory( pSecretData );

    

    return fSuccess;
}

BOOL
CreateBackupKeyW2K(
    IN  OUT GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey
    )
/*++

    This routine creates a new backup key and an identifier for that key.

    The key is then stored as an global LSA secret.

--*/
{
    DWORD RpcStatus;
    BOOL fSuccess = FALSE;;

    if(pguidKey == NULL || ppbKey == NULL || pcbKey == NULL)
        return FALSE;

    *ppbKey = NULL;

    //
    // generate new Guid representing key
    //

    RpcStatus = UuidCreate( pguidKey );
    if( RpcStatus != RPC_S_OK && RpcStatus != RPC_S_UUID_LOCAL_ONLY )
        return FALSE;



    *pcbKey = BACKUPKEY_MATERIAL_SIZE + sizeof(DWORD);
    *ppbKey = (LPBYTE)SSAlloc( *pcbKey );

    if(*ppbKey == NULL)
        return FALSE;

    //
    // generate random key material.
    //

    fSuccess = RtlGenRandom(*ppbKey, *pcbKey);

    if(fSuccess) {

        //
        // version the key material.
        //

        ((DWORD *)*ppbKey)[0] = BACKUPKEY_VERSION_W2K;

        fSuccess = SaveBackupKey(pguidKey, *ppbKey, *pcbKey);

    } else {
        SSFree( *ppbKey );
        *ppbKey = NULL;
    }


    return fSuccess;
}

BOOL
CreateBackupKey(
    IN  OUT GUID *pguidKey,
        OUT PBYTE *ppbKey,
        OUT DWORD *pcbKey,
        OUT HCRYPTPROV *phCryptProv,
        OUT HCRYPTKEY  *phCryptKey
    )
/*++

    This routine creates a new backup key and an identifier for that key.

    The key is then stored as an global LSA secret.

--*/
{
    DWORD RpcStatus;
    BOOL fSuccess = FALSE;;
    HCRYPTPROV hCryptProv = NULL;
    HCRYPTKEY  hCryptKey = NULL;
    DWORD      dwDefaultKeySize = 2048;
    PBYTE      pbPublicExportData = NULL;

    if(pguidKey == NULL || ppbKey == NULL || pcbKey == NULL)
        return FALSE;

    *ppbKey = NULL;

    //
    // generate new Guid representing key
    //

    RpcStatus = UuidCreate( pguidKey );
    if( RpcStatus != RPC_S_OK && RpcStatus != RPC_S_UUID_LOCAL_ONLY )
        return FALSE;


    DWORD      cbPrivateExportLength = 0;
    DWORD      cbPublicExportLength = 0;



    if(!CryptAcquireContext(&hCryptProv,
                            NULL,
                            NULL,
                            PROV_RSA_FULL,
                            CRYPT_VERIFYCONTEXT))
    {
        goto error;
    }
    if(!CryptGenKey(hCryptProv, 
                    AT_KEYEXCHANGE,
                    CRYPT_EXPORTABLE | dwDefaultKeySize << 16, // 2048 bit
                    &hCryptKey))
    {
        goto error;
    }

    // 
    // Get the private key size
    //
    if(!CryptExportKey(hCryptKey,
                       NULL,
                       PRIVATEKEYBLOB,
                       0,
                       NULL,
                       &cbPrivateExportLength))
    {
        goto error;
    }

    if(!GeneratePublicKeyCert(hCryptProv,
                              hCryptKey,
                              pguidKey,
                              &cbPublicExportLength,
                              &pbPublicExportData))
    {
        goto error;
    }

    *pcbKey = sizeof(DWORD) + // version
              sizeof(DWORD) + // cbPrivateExportLength
              sizeof(DWORD) + // cbPublicExportLength
              cbPrivateExportLength + 
              cbPublicExportLength;

    *ppbKey = (LPBYTE)SSAlloc( *pcbKey );

    if(*ppbKey == NULL)
        goto error;

    ((DWORD *)*ppbKey)[0] = BACKUPKEY_VERSION;
    ((DWORD *)*ppbKey)[1] = cbPrivateExportLength;
    ((DWORD *)*ppbKey)[2] = cbPublicExportLength;

    if(!CryptExportKey(hCryptKey,
                       NULL,
                       PRIVATEKEYBLOB,
                       0,
                       (*ppbKey) + 3*sizeof(DWORD),
                       &cbPrivateExportLength))
    {
        goto error;
    }
    CopyMemory((*ppbKey) + 3*sizeof(DWORD) +  cbPrivateExportLength,
               pbPublicExportData,
               cbPublicExportLength);

    *phCryptProv = hCryptProv;
    hCryptProv = NULL;

    *phCryptKey = hCryptKey;
    hCryptKey = NULL;

    fSuccess = SaveBackupKey(pguidKey, *ppbKey, *pcbKey);


error:

    if(hCryptKey)
    {

    }
    if(hCryptProv)
    {
            CryptReleaseContext(hCryptProv,
                                0);
    }
    if(pbPublicExportData)
    {
        SSFree(pbPublicExportData);
    }
    return fSuccess;
}

BOOL
SaveBackupKey(
    IN      GUID *pguidKey,
    IN      BYTE *pbKey,
    IN      DWORD cbKey     // size of pbKey material, not greater than 0xffff
    )
/*++

    Persist the specified key to a global LSA secret.

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    WCHAR wszKeyGuid[ (sizeof(BACKUPKEY_NAME_PREFIX) / sizeof(WCHAR)) + MAX_GUID_SZ_CHARS ];
    NTSTATUS Status;

    if(pguidKey == NULL || pbKey == NULL || cbKey > 0xffff)
        return FALSE;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    CopyMemory(wszKeyGuid, BACKUPKEY_NAME_PREFIX, sizeof(BACKUPKEY_NAME_PREFIX));

    if(MyGuidToStringW(pguidKey,
        (LPWSTR)( (LPBYTE)wszKeyGuid + sizeof(BACKUPKEY_NAME_PREFIX) - sizeof(WCHAR) )
        ) != 0) return FALSE;

    InitLsaString(&SecretKeyName, wszKeyGuid);

    SecretData.Buffer = (LPWSTR)pbKey;
    SecretData.Length = (USHORT)cbKey;
    SecretData.MaximumLength = (USHORT)cbKey;

    Status = OpenPolicy(NULL, POLICY_CREATE_SECRET, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    return TRUE;
}

BOOL
DestroyBackupKey(
    IN      GUID guidKey
    )
{
    //
    // Delete the LSA secret containing the specified key.
    //

    return FALSE;
}


BOOL
SetupPreferredBackupKeys(
    VOID
    )
{
    static BOOL fSetupStatus = FALSE;
    BOOL fLocalStatus = FALSE;


    if( g_fSetupPreferredAttempted )
        return fSetupStatus;

    RtlEnterCriticalSection( &g_csInitialization );

    if( !g_fSetupPreferredAttempted ) {

        //
        // Wait on LSA/SAM to be available.
        //

        fSetupStatus = WaitOnSAMDatabase();

        if( fSetupStatus ) {

            fLocalStatus = FALSE;

            //
            // get the preferred backup key.
            // TODO: if this fails (unlikely), we should probably log an event!
            // check outcome of StartBackupKeyServer() in the main service code
            //

            //
            // Get the legacy backup key
            //

            if(GetPreferredBackupKeyGuid(BACKUPKEY_VERSION_W2K, &g_guidW2KPreferredKey)) {

                //
                // now, pickup the specified key
                //



                fLocalStatus = GetBackupKey(&g_guidW2KPreferredKey, 
                                            &g_pbW2KPreferredKey, 
                                            &g_cbW2KPreferredKey,
                                            NULL,
                                            NULL);
            }


            if(!fLocalStatus)
            {

                //
                // no preferred backup key specified, or we couldn't read one
                // create a new one.
                //

                if(CreateBackupKeyW2K(&g_guidW2KPreferredKey, 
                                    &g_pbW2KPreferredKey, 
                                    &g_cbW2KPreferredKey))
                    fLocalStatus = SetPreferredBackupKeyGuid(BACKUPKEY_VERSION_W2K,
                                                             &g_guidW2KPreferredKey);
                else
                    fLocalStatus  = FALSE;
            }

            fSetupStatus = fLocalStatus;

            fLocalStatus = FALSE;

            //
            // Get the current backup key
            // 

            if(GetPreferredBackupKeyGuid(BACKUPKEY_VERSION, &g_guidPreferredKey)) {

                //
                // now, pickup the specified key
                //



                fLocalStatus = GetBackupKey(&g_guidPreferredKey, 
                                            &g_pbPreferredKey, 
                                            &g_cbPreferredKey,
                                            &g_hProvPreferredKey,
                                            &g_hKeyPreferredKey);

            }

            if(!fLocalStatus)
            {

                //
                // no preferred backup key specified.  create one and specify it
                // as being the preferred one.
                //

                if(CreateBackupKey(&g_guidPreferredKey, 
                                    &g_pbPreferredKey, 
                                    &g_cbPreferredKey,
                                    &g_hProvPreferredKey,
                                    &g_hKeyPreferredKey))
                    fLocalStatus = SetPreferredBackupKeyGuid(BACKUPKEY_VERSION,
                                                             &g_guidPreferredKey);
                else
                    fLocalStatus  = FALSE;
            }
        }

        if(!fLocalStatus)
        {
            fSetupStatus = FALSE;
        }
        g_fSetupPreferredAttempted = TRUE;
    }

    RtlLeaveCriticalSection( &g_csInitialization );

    return fSetupStatus;
}


BOOL
GetPreferredBackupKeyGuid(
    IN      DWORD dwVersion,
    IN  OUT GUID *pguidKey
    )
/*++

    Get the GUID value associated with the key which has been set to be preferred.

    The return value is TRUE, if successful.  The GUID value is copied into the
    buffer specified by the pguidKey parameter.

    The return value is FALSE on failure; if the GUID does not exist, or the
    data could not be retrieved, for instance.

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    USHORT cbData;
    NTSTATUS Status;
    BOOL fSuccess;

    if(pguidKey == NULL)
        return FALSE;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString(&SecretKeyName, 
        (dwVersion == BACKUPKEY_VERSION_W2K)?BACKUPKEY_PREFERRED_W2K:BACKUPKEY_PREFERRED);

    Status = OpenPolicy(NULL, POLICY_GET_PRIVATE_INFORMATION, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    Status = LsaRetrievePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &pSecretData
                );

    LsaClose(PolicyHandle);

    if(!NT_SUCCESS(Status) || pSecretData == NULL)
        return FALSE;

    if(pSecretData->Length == sizeof(GUID)) {
        CopyMemory(pguidKey, pSecretData->Buffer, sizeof(GUID));
        fSuccess = TRUE;
    } else {
        fSuccess = FALSE;
    }

    RtlSecureZeroMemory(pSecretData->Buffer, pSecretData->Length);
    LsaFreeMemory(pSecretData);

    return fSuccess;
}

BOOL
SetPreferredBackupKeyGuid(
    IN      DWORD dwVersion,
    IN      GUID *pguidKey
    )
/*++

    Sets the specified GUID as being the preferred backup key, by reference
    from the GUID to key mapping.

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    NTSTATUS Status;

    if(pguidKey == NULL)
        return FALSE;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString(&SecretKeyName,        
        (dwVersion == BACKUPKEY_VERSION_W2K)?BACKUPKEY_PREFERRED_W2K:BACKUPKEY_PREFERRED);


    SecretData.Buffer = (LPWSTR)pguidKey;
    SecretData.Length = sizeof(GUID);
    SecretData.MaximumLength = sizeof(GUID);

    Status = OpenPolicy(NULL, POLICY_CREATE_SECRET, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    return TRUE;
}

BOOL
FreePreferredBackupKey(
    VOID
    )
{

    g_fSetupPreferredAttempted = FALSE;

    //
    // free allocated key pair.
    //

    if(g_pbPreferredKey) {
        RtlSecureZeroMemory(g_pbPreferredKey, g_cbPreferredKey);
        SSFree(g_pbPreferredKey);
        g_pbPreferredKey = NULL;
    }

    return TRUE;
}


NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle
    )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    if (ServerName != NULL) {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    } else {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    return LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle
                );
}

BOOL
WaitOnSAMDatabase(
    VOID
    )
{
    NTSTATUS Status;
    LSA_UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES EventAttributes;
    HANDLE hEvent;
    BOOL fSuccess = FALSE;

    InitLsaString( &EventName, L"\\SAM_SERVICE_STARTED" );
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtOpenEvent( &hEvent,
                          SYNCHRONIZE|EVENT_MODIFY_STATE,
                          &EventAttributes );
    if ( !NT_SUCCESS(Status))
    {

        if( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            //
            // SAM hasn't created this event yet, let us create it now.
            // SAM opens this event to set it.
            //

            Status = NtCreateEvent(
                           &hEvent,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes,
                           NotificationEvent,
                           FALSE // The event is initially not signaled
                           );

            if( Status == STATUS_OBJECT_NAME_EXISTS ||
                Status == STATUS_OBJECT_NAME_COLLISION )
            {

                //
                // second chance, if the SAM created the event before we
                // do.
                //

                Status = NtOpenEvent( &hEvent,
                                      SYNCHRONIZE|EVENT_MODIFY_STATE,
                                      &EventAttributes );

            }
        }

        if ( !NT_SUCCESS(Status))
        {
            //
            // could not make the event handle
            //
            return FALSE;
        }
    }


    if( WAIT_OBJECT_0 == WaitForSingleObject( hEvent, INFINITE ) )
        fSuccess = TRUE;

    CloseHandle( hEvent );

    return fSuccess;
}









DWORD
GetSystemCredential(
    IN      BOOL fLocalMachine,
    IN OUT  BYTE rgbCredential[ A_SHA_DIGEST_LEN ]
    )
/*++

    This routines returns the credential associated with the SYSTEM account
    based on the fLocalMachine parameter.

    If fLocalMachine is TRUE, the credential returned is suitable for use
    at the LOCAL_MACHINE storage disposition.

    Otherwise, the credential returned is suitable for use when the calling
    user security context is the Local System account.

--*/
{
    PBYTE Credential;

    if(!g_fSystemCredsInitialized) {
        DWORD dwLastError;

        RtlEnterCriticalSection( &g_csInitialization );

        if(!g_fSystemCredsInitialized) {
            dwLastError = QuerySystemCredentials( g_rgbSystemCredMachine, g_rgbSystemCredUser );
            if( dwLastError == ERROR_FILE_NOT_FOUND ) {
                if( CreateSystemCredentials() )
                    dwLastError = QuerySystemCredentials( g_rgbSystemCredMachine, g_rgbSystemCredUser );
            }

            if( dwLastError == ERROR_SUCCESS )
                g_fSystemCredsInitialized = TRUE;
        } else {
            dwLastError = ERROR_SUCCESS;
        }

        RtlLeaveCriticalSection( &g_csInitialization );

        if( dwLastError != ERROR_SUCCESS )
            return dwLastError;
    }


    if( fLocalMachine )
        Credential = g_rgbSystemCredMachine;
    else
        Credential = g_rgbSystemCredUser;

    CopyMemory( rgbCredential, Credential, A_SHA_DIGEST_LEN );

    return ERROR_SUCCESS;
}

BOOL
UpdateSystemCredentials(
    VOID
    )
{
    BOOL fSuccess;

    RtlEnterCriticalSection( &g_csInitialization );

    g_fSystemCredsInitialized = FALSE;

    fSuccess = CreateSystemCredentials();

    RtlLeaveCriticalSection( &g_csInitialization );

    return fSuccess;
}

BOOL
CreateSystemCredentials(
    VOID
    )
{
    SYSTEM_CREDENTIALS SystemCredentials;

    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    NTSTATUS Status;

    //
    // create random key material.
    //

    if(!RtlGenRandom( (PBYTE)&SystemCredentials, sizeof(SystemCredentials) ))
    {
        return FALSE;
    }
    SystemCredentials.dwVersion = SYSTEM_CREDENTIALS_VERSION;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString(&SecretKeyName, SYSTEM_CREDENTIALS_SECRET);

    SecretData.Buffer = (LPWSTR)&SystemCredentials;
    SecretData.Length = sizeof( SystemCredentials );
    SecretData.MaximumLength = sizeof( SystemCredentials );

    Status = OpenPolicy(NULL, POLICY_CREATE_SECRET, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    if(!NT_SUCCESS(Status))
        return FALSE;

    return TRUE;
}

DWORD
QuerySystemCredentials(
    IN  OUT BYTE rgbSystemCredMachine[ A_SHA_DIGEST_LEN ],
    IN  OUT BYTE rgbSystemCredUser [ A_SHA_DIGEST_LEN ]
    )
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    USHORT cbData;
    NTSTATUS Status;
    DWORD dwLastError = ERROR_INVALID_PARAMETER;
    BOOL fSuccess;

    if( !WaitOnSAMDatabase() )
        return WAIT_TIMEOUT;

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString(&SecretKeyName, SYSTEM_CREDENTIALS_SECRET);

    Status = OpenPolicy(NULL, POLICY_GET_PRIVATE_INFORMATION, &PolicyHandle);

    if(!NT_SUCCESS(Status))
        return dwLastError;

    Status = LsaRetrievePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &pSecretData
                );

    LsaClose(PolicyHandle);

    if(Status == STATUS_OBJECT_NAME_NOT_FOUND)
        return ERROR_FILE_NOT_FOUND;

    if(!NT_SUCCESS(Status) || pSecretData == NULL)
        return dwLastError;

    if( pSecretData->Length == 0)
        return ERROR_FILE_NOT_FOUND;

    if( pSecretData->Length == sizeof(SYSTEM_CREDENTIALS) ) {
        PSYSTEM_CREDENTIALS pSystemCredentials = (PSYSTEM_CREDENTIALS)pSecretData->Buffer;

        if( pSystemCredentials->dwVersion == SYSTEM_CREDENTIALS_VERSION ) {
            CopyMemory( rgbSystemCredMachine, pSystemCredentials->rgbSystemCredMachine, A_SHA_DIGEST_LEN );
            CopyMemory( rgbSystemCredUser, pSystemCredentials->rgbSystemCredUser, A_SHA_DIGEST_LEN );

            dwLastError = ERROR_SUCCESS;
        }
    }

    RtlSecureZeroMemory(pSecretData->Buffer, pSecretData->Length);
    LsaFreeMemory(pSecretData);

    return dwLastError;
}


BOOL
FreeSystemCredentials(
    VOID
    )
{
    RtlSecureZeroMemory( g_rgbSystemCredMachine, sizeof(g_rgbSystemCredMachine) );
    RtlSecureZeroMemory( g_rgbSystemCredUser, sizeof(g_rgbSystemCredUser) );

    g_fSystemCredsInitialized = FALSE;

    return TRUE;
}


BOOL GeneratePublicKeyCert(HCRYPTPROV hCryptProv,
                           HCRYPTKEY hCryptKey,
                           GUID *pguidKey,
                           DWORD *pcbPublicExportLength,
                           PBYTE *ppbPublicExportData)
{

    BOOL            fRet = FALSE;
    CERT_INFO       CertInfo;
    CERT_PUBLIC_KEY_INFO *pKeyInfo = NULL;
    DWORD                 cbKeyInfo = 0;
    CERT_NAME_BLOB  CertName;
    CERT_RDN_ATTR   RDNAttributes[1];
    CERT_RDN        CertRDN[] = {1, RDNAttributes} ;
    CERT_NAME_INFO  NameInfo = {1, CertRDN};

    CertName.pbData = NULL;
    CertName.cbData = 0;

    RDNAttributes[0].Value.pbData = NULL;
    RDNAttributes[0].Value.cbData = 0;

    DWORD cbCertSize = 0;
    PBYTE pbCert = NULL;
    DWORD cSize = 0;

    // Generate a self-signed cert structure

    RDNAttributes[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    RDNAttributes[0].pszObjId =    szOID_COMMON_NAME;

    if(!GetComputerNameEx(ComputerNameDnsDomain,
                       NULL,
                       &cSize))
    {
        DWORD dwError = GetLastError();

        if((dwError != ERROR_MORE_DATA) &&
           (dwError != ERROR_BUFFER_OVERFLOW))
        {
            goto error;
        }
    }
    RDNAttributes[0].Value.cbData = cSize * sizeof(WCHAR);

    RDNAttributes[0].Value.pbData = (PBYTE)SSAlloc(RDNAttributes[0].Value.cbData);
    if(NULL == RDNAttributes[0].Value.pbData)
    {
        goto error;
    }

    if(!GetComputerNameEx(ComputerNameDnsDomain,
                       (LPWSTR)RDNAttributes[0].Value.pbData,
                       &cSize))
    {
        goto error;
    }


    //
    // Get the actual public key info from the key
    //
    if(!CryptExportPublicKeyInfo(hCryptProv, 
                             AT_KEYEXCHANGE,
                             X509_ASN_ENCODING,
                             NULL,
                             &cbKeyInfo))
    {
        goto error;
    }
    pKeyInfo = (CERT_PUBLIC_KEY_INFO *)SSAlloc(cbKeyInfo);
    if(NULL == pKeyInfo)
    {
        goto error;
    }
    if(!CryptExportPublicKeyInfo(hCryptProv, 
                             AT_KEYEXCHANGE,
                             X509_ASN_ENCODING,
                             pKeyInfo,
                             &cbKeyInfo))
    {
        goto error;
    }

    // 
    // Generate the certificate name
    //

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_NAME,
                          &NameInfo,
                          NULL,
                          &CertName.cbData))
    {
        goto error;
    }

    CertName.pbData = (PBYTE)SSAlloc(CertName.cbData);
    if(NULL == CertName.pbData)
    {
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_NAME,
                          &NameInfo,
                          CertName.pbData,
                          &CertName.cbData))
    {
        goto error;
    }



    CertInfo.dwVersion = CERT_V3;
    CertInfo.SerialNumber.pbData = (PBYTE)pguidKey;
    CertInfo.SerialNumber.cbData =  sizeof(GUID);
    CertInfo.SignatureAlgorithm.pszObjId = szOID_OIWSEC_sha1RSASign;
    CertInfo.SignatureAlgorithm.Parameters.cbData = 0;
    CertInfo.SignatureAlgorithm.Parameters.pbData = NULL;
    CertInfo.Issuer.pbData = CertName.pbData;
    CertInfo.Issuer.cbData = CertName.cbData;

    GetSystemTimeAsFileTime(&CertInfo.NotBefore);
    CertInfo.NotAfter = CertInfo.NotBefore;
    ((LARGE_INTEGER * )&CertInfo.NotAfter)->QuadPart += 
           Int32x32To64(FILETIME_TICKS_PER_SECOND, BACKUPKEY_LIFETIME);



    CertInfo.Subject.pbData = CertName.pbData;
    CertInfo.Subject.cbData = CertName.cbData;
    CertInfo.SubjectPublicKeyInfo = *pKeyInfo;
    CertInfo.SubjectUniqueId.pbData = (PBYTE)pguidKey;
    CertInfo.SubjectUniqueId.cbData = sizeof(GUID);
    CertInfo.SubjectUniqueId.cUnusedBits = 0;
    CertInfo.IssuerUniqueId.pbData = (PBYTE)pguidKey;
    CertInfo.IssuerUniqueId.cbData = sizeof(GUID);
    CertInfo.IssuerUniqueId.cUnusedBits = 0;
    CertInfo.cExtension = 0;
    CertInfo.rgExtension = NULL;

    if(!CryptSignAndEncodeCertificate(hCryptProv, 
                                      AT_KEYEXCHANGE,
                                      X509_ASN_ENCODING,
                                      X509_CERT_TO_BE_SIGNED,
                                      &CertInfo,
                                      &CertInfo.SignatureAlgorithm,
                                      NULL,
                                      NULL,
                                      &cbCertSize))
    {
        goto error;
    }

    pbCert = (PBYTE)SSAlloc(cbCertSize);
    if(NULL == pbCert)
    {
        goto error;
    }

    if(!CryptSignAndEncodeCertificate(hCryptProv, 
                                      AT_KEYEXCHANGE,
                                      X509_ASN_ENCODING,
                                      X509_CERT_TO_BE_SIGNED,
                                      &CertInfo,
                                      &CertInfo.SignatureAlgorithm,
                                      NULL,
                                      pbCert,
                                      &cbCertSize))
    {
        goto error;
    }

    *pcbPublicExportLength = cbCertSize;
  
    *ppbPublicExportData = pbCert;

    if(!CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, cbCertSize))
    {
        GetLastError();
    }

    pbCert = NULL;

    fRet = TRUE;

error:
    if(pbCert)
    {
        SSFree(pbCert);
    }
    if(pKeyInfo)
    {
        SSFree(pKeyInfo);
    }
    if(CertName.pbData)
    {
        SSFree(CertName.pbData);
    }

    if(RDNAttributes[0].Value.pbData)
    {
        SSFree(RDNAttributes[0].Value.pbData);
    }

    return fRet;
}

BOOL ConvertRecoveredBlobToW2KBlob(
    IN      BYTE *pbMasterKey,
    IN      DWORD cbMasterKey,
    IN      PBYTE pbLocalKey,
    IN      DWORD cbLocalKey,
    IN      PSID pSidCandidate,
    IN  OUT BYTE **ppbDataOut,
    IN  OUT DWORD *pcbDataOut)
{

    BYTE rgbBKEncryptionKey[ A_SHA_DIGEST_LEN ];

    DWORD cbSidCandidate=0;

    PMASTERKEY_BLOB_W2K pMasterKeyBlob = NULL;
    DWORD cbMasterKeyBlob = 0;
    DWORD cbMasterInnerKeyBlob;
    PMASTERKEY_INNER_BLOB_W2K pMasterKeyInnerBlob = NULL;

    PBYTE pbCipherBegin;

    RC4_KEYSTRUCT sRC4Key;
    BYTE rgbMacKey[A_SHA_DIGEST_LEN];

    DWORD dwLastError = (DWORD)NTE_BAD_KEY;


    BYTE rgbSymKey[A_SHA_DIGEST_LEN*2]; // big enough to handle 3des keys



    if(!IsValidSid(pSidCandidate)) {
        goto cleanup;
    }

    cbSidCandidate = GetLengthSid(pSidCandidate);
       

    //
    // derive BK encryption key from decrypted Local Key.
    //

    FMyPrimitiveSHA( pbLocalKey, cbLocalKey, rgbBKEncryptionKey );


    cbMasterInnerKeyBlob = sizeof(MASTERKEY_INNER_BLOB_W2K) +
                    cbMasterKey ;

    cbMasterKeyBlob = sizeof(MASTERKEY_BLOB_W2K) +
                    cbMasterInnerKeyBlob;


    pMasterKeyBlob = (PMASTERKEY_BLOB_W2K)SSAlloc( cbMasterKeyBlob );
    if(pMasterKeyBlob == NULL)
    {
        dwLastError =  ERROR_NOT_ENOUGH_SERVER_MEMORY;
        goto cleanup;
    }


    pMasterKeyBlob->dwVersion = MASTERKEY_BLOB_VERSION_W2K;
    pMasterKeyInnerBlob = 
        (PMASTERKEY_INNER_BLOB_W2K)(pMasterKeyBlob + 1);
    

    //
    // generate random R2 for SymKey
    //

    if(!RtlGenRandom(pMasterKeyBlob->R2, MASTERKEY_R2_LEN_W2K))
        goto cleanup;

    //
    // generate random R3 for MAC
    //

    if(!RtlGenRandom(pMasterKeyInnerBlob->R3, MASTERKEY_R3_LEN_W2K))
        goto cleanup;


    //
    // derive symetric key via rgbMKEncryptionKey and random R2
    //

    if(!FMyPrimitiveHMACParam(
                    rgbBKEncryptionKey,
                    A_SHA_DIGEST_LEN,
                    pMasterKeyBlob->R2,
                    MASTERKEY_R2_LEN_W2K,
                    rgbSymKey
                    ))
        goto cleanup;

        //
        // derive MAC key via HMAC from rgbMKEncryptionKey and random R3.
        //

    if(!FMyPrimitiveHMACParam(
                    rgbBKEncryptionKey,
                    A_SHA_DIGEST_LEN,
                    pMasterKeyInnerBlob->R3,
                    MASTERKEY_R3_LEN_W2K,
                    rgbMacKey   // resultant MAC key
                    ))
        goto cleanup;
    pbCipherBegin = (PBYTE)(pMasterKeyInnerBlob+1);


    //
    // copy pbMasterKey following inner MAC'ish blob.
    //


    CopyMemory( pbCipherBegin, pbMasterKey, cbMasterKey );

    //
    // use MAC key to derive result from pbMasterKey
    //

    if(!FMyPrimitiveHMACParam(
                    rgbMacKey,
                    sizeof(rgbMacKey),
                    pbMasterKey,
                    cbMasterKey,
                    pMasterKeyInnerBlob->MAC // resultant MAC for verification.
                    ))
        goto cleanup;







    rc4_key(&sRC4Key, A_SHA_DIGEST_LEN, rgbSymKey);

    rc4(&sRC4Key, 
        cbMasterInnerKeyBlob, 
        (PBYTE)pMasterKeyInnerBlob);


    *ppbDataOut = (PBYTE)pMasterKeyBlob;
    *pcbDataOut = cbMasterKeyBlob;

    pMasterKeyBlob = NULL; // prevent free of blob on success (caller does it).

    dwLastError = ERROR_SUCCESS;

cleanup:

    if(pMasterKeyBlob) {
        RtlSecureZeroMemory(pMasterKeyBlob, cbMasterKeyBlob);
        SSFree(pMasterKeyBlob);
    }

    SetLastError(dwLastError);
    return (dwLastError == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\keyman.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    keyman.h

Abstract:

    This module contains routines to manage master keys in the cliet.  This
    includes retrieval, backup and restore.

Author:

    Scott Field (sfield)    09-Sep-97

--*/

#ifndef __KEYMAN_H__
#define __KEYMAN_H__


#if 0

    The layout of the registry is as follows:

    HKEY_CURRENT_LUSER\...\Cryptography\Protect\<UserId>\

    note:  Protect key and all subkeys Acl'd for Local System access

    MasterKeys\

    Policy = (REG_DWORD value), policy bits of master keys; eg, don't backup, local only backup, local + DC recovery)
    Preferred = (REG_BINARY value containing MASTERKEY_PREFERRED_INFO),
                Indicates the GUID of the preferred master key, and
                when the key expires.
    <GUID> = (Subkey) Textual form of a master key, identified by GUID.
        LK = (REG_BINARY data), randomly generated local backup key, created if policy permits. [obfuscated]
        MK = (REG_BINARY data), master key data, encrypted with logon credential (WinNT) or obfuscated (Win95)
        BK = (REG_BINARY data), master key data, encrypted with LK, if policy permits.
        BBK = (REG_BINARY data), master key data, encrypted with LK and DC recovery key, if policy permits.
    <GUID...> = any number of additional subkeys representing master keys and associated data.

#endif // 0


#define REGVAL_PREFERRED_MK                 L"Preferred"
#define REGVAL_POLICY_MK                    L"ProtectionPolicy"

#define REGVAL_MK_DEFAULT_ITERATION_COUNT   L"MasterKeyIterationCount"
#define REGVAL_MK_LEGACY_COMPLIANCE         L"MasterKeyLegacyCompliance"
#define REGVAL_MK_LEGACY_NT4_DOMAIN         L"MasterKeyLegacyNt4Domain"
#define REGVAL_DISTRIBUTE_BACKUP_KEY        L"DistributeBackupKey"

// MasterKeys\<GUID>\<value>
#define REGVAL_MASTER_KEY       0 // L"MK"   // masterkey, encrypted with user credential
#define REGVAL_LOCAL_KEY        1 // L"LK"   // phase one backup blob encryption key
#define REGVAL_BACKUP_LCL_KEY   2 // L"BK"   // phase one backup blob
#define REGVAL_BACKUP_DC_KEY    3 // L"BBK"  // phase two backup blob

#define MK_DISP_OK              0 // normal disposition, no backup/restore occured
#define MK_DISP_BCK_LCL         1 // local backup/restore took place
#define MK_DISP_BCK_DC          2 // DC based backup/restore took place
#define MK_DISP_STORAGE_ERR     3 // error retrieving key from storage
#define MK_DISP_DELEGATION_ERR  4 // Recovery failure because delegation disabled
#define MK_DISP_UNKNOWN_ERR     5 // unknown error


// Policy bit for local only (no DC) backup
#define POLICY_LOCAL_BACKUP     0x1

// Policy bit for NO backup (Win95)
#define POLICY_NO_BACKUP        0x2

// Use the DPAPI One way function of the password (SHA_1(pw))
#define POLICY_DPAPI_OWF        0x4

#define MASTERKEY_MATERIAL_SIZE (64)    // size of the masterkey key material
#define LOCALKEY_MATERIAL_SIZE  (32)    // size of the localkey key material


#define MASTERKEY_R2_LEN            (16)
#define MASTERKEY_R3_LEN            (16)

#define DEFAULT_MASTERKEY_ITERATION_COUNT (4000)    // 4000 == ~100ms on 400 MHz machine

//
// the MASTERKEY_STORED structure depicts all the data that may be associated
// with a single master key entity.
//

typedef struct {
    DWORD dwVersion;
    BOOL fModified;             // have contents been modified, deeming a persist operation?
    LPWSTR szFilePath;          // path (not including filename) to the file for persist operation
    WCHAR wszguidMasterKey[MAX_GUID_SZ_CHARS]; // filename (GUID based)

    DWORD dwPolicy;             // policy bits on this key

    DWORD cbMK;                 // count of bytes associated with pbMK (Zero if not present)
    PBYTE pbMK;                 // MasterKey data.  NULL if not present

    DWORD cbLK;                 // count of bytes associated with pbLK (Zero if not present)
    PBYTE pbLK;                 // LocalKey data.  NULL if not present

    DWORD cbBK;                 // count of bytes associated with pbBK (Zero if not present)
    PBYTE pbBK;                 // BackupLocalKey data.  NULL if not present

    DWORD cbBBK;                // count of bytes associated with pbBBK (Zero if not present)
    PBYTE pbBBK;                // BackupDCKey data.  NULL if not present

} MASTERKEY_STORED, *PMASTERKEY_STORED, *LPMASTERKEY_STORED;

//
// the on-disk version of the structure is neccessary to allow 64bit and 32bit
// platform interop with upgraded systems or roaming files.
// pointers are changed to 32bit offsets
//

typedef struct {
    DWORD dwVersion;
    BOOL fModified;             // have contents been modified, deeming a persist operation?
    DWORD szFilePath;           // invalid on disk
    WCHAR wszguidMasterKey[MAX_GUID_SZ_CHARS]; // filename (GUID based)

    DWORD dwPolicy;             // policy bits on this key

    DWORD cbMK;                 // count of bytes associated with pbMK (Zero if not present)
    DWORD pbMK;                 // invalid on disk

    DWORD cbLK;                 // count of bytes associated with pbLK (Zero if not present)
    DWORD pbLK;                 // invalid on disk

    DWORD cbBK;                 // count of bytes associated with pbBK (Zero if not present)
    DWORD pbBK;                 // invalid on disk

    DWORD cbBBK;                // count of bytes associated with pbBBK (Zero if not present)
    DWORD pbBBK;                // invalid on disk

} MASTERKEY_STORED_ON_DISK, *PMASTERKEY_STORED_ON_DISK, *LPMASTERKEY_STORED_ON_DISK;

//
// VERSION1: LK is not encrypted with LSA Secret when POLICY_LOCAL_BACKUP is set
// VERSION2: LK is encrypted with LSA Secret when POLICY_LOCAL_BACKUP is set
//#define MASTERKEY_STORED_VERSION 1
#define MASTERKEY_STORED_VERSION 2

typedef struct {
    DWORD dwVersion;            // version of structure (MASTERKEY_BLOB_VERSION)
    BYTE R2[MASTERKEY_R2_LEN];  // random data used during HMAC to derive symetric key
    DWORD IterationCount;       // PKCS5 iteration count
    DWORD KEYGENAlg;            // PKCS5 Key Generation Alg, in CAPI ALG_ID form
    DWORD EncryptionAlg;        // Encryption Alg, in CAPI ALG_ID form
} MASTERKEY_BLOB, *PMASTERKEY_BLOB, *LPMASTERKEY_BLOB;


typedef struct {
    BYTE R3[MASTERKEY_R3_LEN];  // random data used to derive MAC key
    BYTE MAC[A_SHA_DIGEST_LEN]; // MAC(R3, pbMasterKey)
    DWORD Padding;              // Padding to make masterkey inner blob divisable by
                                // 3DES_BLOCKLEN
} MASTERKEY_INNER_BLOB, *PMASTERKEY_INNER_BLOB, *LPMASTERKEY_INNER_BLOB;




typedef struct {
    DWORD   dwVersion;            // version of structure MASTERKEY_BLOB_LOCALKEY_BACKUP 
    GUID    CredentialID;         // indicates the credential id used to protect the
                                  // master key.
} LOCAL_BACKUP_DATA, *PLOCAL_BACKUP_DATA, *LPLOCAL_BACKUP_DATA;


//
// 90 day masterkey expiration
//

#define MASTERKEY_EXPIRES_DAYS  (90)

typedef struct {
    GUID guidPreferredKey;
    FILETIME ftPreferredKeyExpires;
} MASTERKEY_PREFERRED_INFO, *PMASTERKEY_PREFERRED_INFO, *LPMASTERKEY_PREFERRED_INFO;

//
// deferred backup structure.
//

typedef struct {
    DWORD cbSize;           // sizeof(QUEUED_BACKUP)
    MASTERKEY_STORED hMasterKey;
    HANDLE hToken;          // client access token
    PBYTE pbLocalKey;
    DWORD cbLocalKey;
    PBYTE pbMasterKey;
    DWORD cbMasterKey;
    HANDLE hEventThread;    // Event that signals thread finished processing
    HANDLE hEventSuccess;   // Event signalled indicates thread did successful backup
} QUEUED_BACKUP, *PQUEUED_BACKUP, *LPQUEUED_BACKUP;

//
// deferred key sync structure.
//

typedef struct {
    DWORD cbSize;           // sizeof(QUEUED_SYNC)
    PVOID pvContext;        // duplicated server context
} QUEUED_SYNC, *PQUEUED_SYNC, *LPQUEUED_SYNC;


DWORD
GetSpecifiedMasterKey(
    IN      PVOID pvContext,        // server context
    IN  OUT GUID *pguidMasterKey,
        OUT LPBYTE *ppbMasterKey,
        OUT DWORD *pcbMasterKey,
    IN      BOOL fSpecified         // get specified pguidMasterKey key ?
    );

DWORD
InitiateSynchronizeMasterKeys(
    IN      PVOID pvContext         // server context
    );

DWORD
WINAPI
SynchronizeMasterKeys(
    IN PVOID pvContext,
    IN DWORD dwFlags);

VOID
DPAPISynchronizeMasterKeys(
    IN HANDLE hUserToken);

BOOL
InitializeKeyManagement(
    VOID
    );

BOOL
TeardownKeyManagement(
    VOID
    );

DWORD
DpapiUpdateLsaSecret(
    IN PVOID pvContext);

DWORD
OpenFileInStorageArea(
    IN      PVOID pvContext,            // if NULL, caller is assumed to be impersonating
    IN      DWORD   dwDesiredAccess,
    IN      LPCWSTR szUserStorageArea,
    IN      LPCWSTR szFileName,
    IN OUT  HANDLE  *phFile
    );

HANDLE
CreateFileWithRetries(
    IN      LPCWSTR lpFileName,
    IN      DWORD dwDesiredAccess,
    IN      DWORD dwShareMode,
    IN      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    IN      DWORD dwCreationDisposition,
    IN      DWORD dwFlagsAndAttributes,
    IN      HANDLE hTemplateFile
    );

#endif  // __KEYMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\memprot.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    memprot.h

Abstract:

    This module contains routines for accessing sensitive data stored in
    memory in encrypted form.

Author:

    Scott Field (sfield)    07-Nov-98

Revision History:

--*/

#ifndef __MEMPROT_H__
#define __MEMPROT_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


VOID
LsaProtectMemory(
    VOID        *pData,
    ULONG       cbData
    );

extern "C"
VOID
LsaUnprotectMemory(
    VOID        *pData,
    ULONG       cbData
    );

#ifdef __cplusplus
}
#endif // __cplusplus


#endif  // __MEMPROT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\keysrv.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    keybckup.h

Abstract:

    This module contains routines associated with server side Key Backup
    operations.

Author:

    Scott Field (sfield)    16-Aug-97

--*/

#ifndef __KEYSRV_H__
#define __KEYSRV_H__


DWORD
StartBackupKeyServer(
    VOID
    );

DWORD
StopBackupKeyServer(
    VOID
    );

DWORD
GetSystemCredential(
    IN      BOOL fLocalMachine,
    IN OUT  BYTE rgbCredential[ A_SHA_DIGEST_LEN ]
    );

BOOL
UpdateSystemCredentials(
    VOID
    );

BOOL
GetDomainControllerName(
    IN      HANDLE hToken,
    IN  OUT LPWSTR wszDomainControllerName,
    IN  OUT PDWORD pcchDomainControllerName,
    IN      BOOL   fRediscover
    );

#endif  // __KEYSRV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\lnklist.h ===
#ifndef __LNKLIST_H__
#define __LNKLIST_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "pstypes.h"
#include "listbase.h"
#include <sha.h>



//////////////////////////////
// CryptProv list

// item list element
typedef struct _CRYPTPROV_LIST_ITEM
{
    // internal to list
    struct _CRYPTPROV_LIST_ITEM *      pNext;

    // Lookup device
//    DWORD                   dwProvID;
    DWORD                   dwAlgId1;
    DWORD                   dwKeySize1;

    DWORD                   dwAlgId2;
    DWORD                   dwKeySize2;

    // item data
    HCRYPTPROV              hProv;

} CRYPTPROV_LIST_ITEM, *PCRYPTPROV_LIST_ITEM;

class CCryptProvList : public CLinkedList
{

public:
    CCryptProvList();

    BOOL                AddToList(PCRYPTPROV_LIST_ITEM pli)
    {   return CLinkedList::AddToList((ELT*)pli);   }

    BOOL    DelFromList(PCRYPTPROV_LIST_ITEM pli)
    {   return CLinkedList::DelFromList((ELT*)pli);  }

    PCRYPTPROV_LIST_ITEM   SearchList(PCRYPTPROV_LIST_ITEM pli)
    {   return (PCRYPTPROV_LIST_ITEM)  CLinkedList::SearchList((ELT*)pli);  }

};


///////////////////////////
// Associated functions
void CreateCryptProvListItem(CRYPTPROV_LIST_ITEM* pli,
                        DWORD       dwAlgId1,
                        DWORD       dwKeySize1,
                        DWORD       dwAlgId2,
                        DWORD       dwKeySize2,
                        HCRYPTPROV  hCryptProv);

BOOL CryptProvIsMatch(
        ELT* pCandidate,
        ELT* pTemplate);

void CryptProvFreeElt(
        ELT* p);





#ifdef __cplusplus
}
#endif

#endif // __LNKLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\lnklist.cpp ===
#include <pch.cpp>
#pragma hdrstop

#include "crtem.h"











////////////////////////
// Cryptographic Provider handle list

CCryptProvList::CCryptProvList()
{
    m_pfnIsMatch = CryptProvIsMatch;
    m_pfnFreeElt = CryptProvFreeElt;
}

void CreateCryptProvListItem(CRYPTPROV_LIST_ITEM* pli,
                        DWORD       dwAlgId1,
                        DWORD       dwKeySize1,
                        DWORD       dwAlgId2,
                        DWORD       dwKeySize2,
                        HCRYPTPROV  hProvider)
{
    pli->pNext = NULL;

    pli->dwAlgId1 = dwAlgId1;
    pli->dwKeySize1 = dwKeySize1;

    pli->dwAlgId2 = dwAlgId2;
    pli->dwKeySize2 = dwKeySize2;

    pli->hProv = hProvider;
}

BOOL CryptProvIsMatch(
        ELT* pCandidate,
        ELT* pTemplate)
{
    PCRYPTPROV_LIST_ITEM pliCandidate = (PCRYPTPROV_LIST_ITEM) pCandidate;
    PCRYPTPROV_LIST_ITEM pliTemplate = (PCRYPTPROV_LIST_ITEM) pTemplate;

    // if both algids match
    if ((pliCandidate->dwAlgId1 == pliTemplate->dwAlgId1) &&
        (pliCandidate->dwAlgId2 == pliTemplate->dwAlgId2))
    {
        // if both sizes match
        if ((pliCandidate->dwKeySize1 == -1) ||
            (pliTemplate->dwKeySize1 == -1) ||
            (pliCandidate->dwKeySize1 == pliTemplate->dwKeySize1))
        {
            if ((pliCandidate->dwKeySize2 == -1) ||
                (pliTemplate->dwKeySize2 == -1) ||
                (pliCandidate->dwKeySize2 == pliTemplate->dwKeySize2))
               return TRUE;
        }
    }

    return FALSE;
}

void CryptProvFreeElt(
        ELT* p)
{
    if (NULL == p)
        return;

    PCRYPTPROV_LIST_ITEM pli = (PCRYPTPROV_LIST_ITEM) p;

    // do all necessary freeing
    if (pli->hProv != 0)
        CryptReleaseContext((HCRYPTPROV)pli->hProv, 0);

    ZeroMemory(pli, sizeof(CRYPTPROV_LIST_ITEM)); // make sure contents invalid

    SSFree(pli);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\misc.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    misc.cpp

Abstract:

    Functionality in this module:

       Globals management   

Author:

    Pete Skelly (petesk) 23-Mar-00

--*/


#include <pch.cpp>
#pragma hdrstop



//
// Registry Setable Globals, and handlign goo
//

// Must access key via api's
static HKEY g_hProtectedStorageKey = NULL;

static HANDLE g_hProtectedStorageChangeEvent = NULL;

static RTL_CRITICAL_SECTION g_csGlobals;

static BOOL g_fcsGlobalsInitialized = FALSE;

// key management globals
static DWORD   g_IterationCount = DEFAULT_MASTERKEY_ITERATION_COUNT;
static BOOL    g_LegacyMode = FALSE;
static BOOL    g_LegacyModeNt4Domain = FALSE;
static BOOL    g_DistributeDomainBackupKey = FALSE;
static DWORD   g_dwMasterKeyDefaultPolicy = 0;


// define softcoded constants we use
static DWORD        g_dwDefaultCryptProvType    = PROV_RSA_FULL;

static DWORD        g_dwAlgID_Encr_Alg          = CALG_3DES;
static DWORD        g_dwAlgID_Encr_Alg_KeySize  = -1;           // any size

static DWORD        g_dwAlgID_MAC_Alg           = CALG_SHA1;
static DWORD        g_dwAlgID_MAC_Alg_KeySize   = -1;           // any size

typedef struct _ALG_TO_STRING
{
    DWORD   AlgId;
    LPCWSTR  wszString;
} ALG_TO_STRING;


ALG_TO_STRING g_AlgToString[] =
{
    { CALG_MD2, L"MD2-%d " },
    { CALG_MD4, L"MD4-%d " },
    { CALG_MD5, L"MD5-%d " },
    { CALG_SHA1, L"SHA1-%d " },
    { CALG_DES, L"DES-%d " },
    { CALG_3DES_112, L"3DES-%d " },
    { CALG_3DES, L"3DES-%d " },
    { CALG_DESX, L"DESX-%d " },
    { CALG_RC2, L"RC2-%d " },
    { CALG_RC4, L"RC4-%d " },
    { CALG_SEAL, L"SEAL-%d " },
    { CALG_RSA_SIGN, L"RSA Signature-%d " },
    { CALG_RSA_KEYX, L"RSA Exchange-%d " },
    { CALG_DSS_SIGN, L"DSS-%d " },
    { CALG_DH_SF, L"DH-%d " },
    { CALG_DH_EPHEM, L"DH Ephemeral-%d " },
    { CALG_KEA_KEYX, L"KEA Exchange-%d " },
    { CALG_SKIPJACK, L"SKIPJACK-%d " },
    { CALG_TEK, L"TEK-%d " },
    { CALG_RC5, L"RC5-%d " },
    { CALG_HMAC, L"HMAC-%d " }
};

DWORD   g_cAlgToString = sizeof(g_AlgToString)/sizeof(g_AlgToString[0]);


// supply a new, delete operator
void * __cdecl operator new(size_t cb)
{
    return SSAlloc( cb );
}

void __cdecl operator delete(void * pv)
{
    SSFree( pv );
}




DWORD AlgIDToString(LPWSTR wszString, DWORD dwAlgID, DWORD dwStrength)
{
    DWORD i;
    for(i=0; i < g_cAlgToString; i++)
    {
        if(dwAlgID == g_AlgToString[i].AlgId)
        {
            return wsprintf(wszString, g_AlgToString[i].wszString, dwStrength);
        }
    }
    return wsprintf(wszString, L"Unknown 0x%lx - %d", dwAlgID, dwStrength);
}


DWORD UpdateGlobals(BOOL fForce)
{
    DWORD lRet = ERROR_SUCCESS;
    DWORD dwDisposition;

    if(NULL == g_fcsGlobalsInitialized ||
       NULL == g_hProtectedStorageKey ||
       NULL == g_hProtectedStorageChangeEvent)
    {
        return ERROR_SUCCESS;
    }

    if(WAIT_OBJECT_0 == WaitForSingleObject(g_hProtectedStorageChangeEvent, 0))
    {
        // Update the globals, as they have changed

        DWORD dwParameterValue;
        DWORD cbParameter = sizeof(dwParameterValue);
        DWORD dwValueType;

        RtlEnterCriticalSection(&g_csGlobals);

        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        REGVAL_MK_DEFAULT_ITERATION_COUNT,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) 
        {
            //
            // Only allow policy to increase the iteration
            // count, never decrease it.
            // 
            if( dwParameterValue > g_IterationCount) 
            {
                g_IterationCount = dwParameterValue;
            }
        }

        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        REGVAL_MK_LEGACY_COMPLIANCE,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) 
        {
            if( dwParameterValue != 0) 
            {
                g_LegacyMode = TRUE;
            }
        }

        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        REGVAL_MK_LEGACY_NT4_DOMAIN,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if((lRet == ERROR_SUCCESS) && 
           (dwValueType == REG_DWORD) &&
           (dwParameterValue != 0))
        {
            g_LegacyModeNt4Domain = TRUE;
        }
        else
        {
            g_LegacyModeNt4Domain = FALSE;
        }

        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        REGVAL_DISTRIBUTE_BACKUP_KEY,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) 
        {
            // User specified registry value, so do what it says.
            g_DistributeDomainBackupKey = (dwParameterValue != 0);

            D_DebugLog((DEB_TRACE, "Registry: distribute whistler domain backup key: %s\n",
                g_DistributeDomainBackupKey ? "TRUE" : "FALSE"));
        }
        else
        {
            // Registry entry does not exist, so check to see if 
            // the domain is in "Whistler native mode" and if so
            // then distribute the whistler domain backup key.
            g_DistributeDomainBackupKey = LsaINoMoreWin2KDomain();

            D_DebugLog((DEB_TRACE, "Policy: distribute whistler domain backup key: %s\n",
                g_DistributeDomainBackupKey ? "TRUE" : "FALSE"));
        }


        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        REGVAL_POLICY_MK,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwParameterValue,
                        &cbParameter
                        );

        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) 
        {
            if( dwParameterValue == 1 ) 
            {
                g_dwMasterKeyDefaultPolicy = POLICY_LOCAL_BACKUP;
            }
        }


        cbParameter = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            g_dwAlgID_Encr_Alg = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_ENCR_ALG_KEYSIZE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            g_dwAlgID_Encr_Alg_KeySize = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            g_dwAlgID_MAC_Alg = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_MAC_ALG_KEYSIZE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            g_dwAlgID_MAC_Alg_KeySize = dwParameterValue;
        }

        cbParameter = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        g_hProtectedStorageKey,
                        CRYPTPROTECT_DEFAULT_PROVIDER_CRYPT_PROV_TYPE,
                        NULL,
                        &dwValueType,
                        (PBYTE)&dwParameterValue,
                        &cbParameter
                        );
        if( lRet == ERROR_SUCCESS && dwValueType == REG_DWORD ) {
            // if successful, commit
            g_dwDefaultCryptProvType = dwParameterValue;
        }


        // Register to be notified of future registry changes.
        lRet = RegNotifyChangeKeyValue(g_hProtectedStorageKey,
                            TRUE,  // bWatchSubtree
                            REG_NOTIFY_CHANGE_LAST_SET |
                            REG_NOTIFY_CHANGE_NAME,
                            g_hProtectedStorageChangeEvent,
                            TRUE);

        if(ERROR_SUCCESS != lRet)
        {
            //
            // If notify failed, we no longer notify, so we don't need to handle anymore
            CloseHandle(g_hProtectedStorageChangeEvent);
            g_hProtectedStorageChangeEvent = NULL;
        }

        RtlLeaveCriticalSection(&g_csGlobals);
    }

    return lRet;
}

DWORD IntializeGlobals()
{
    DWORD lRet = ERROR_SUCCESS;
    DWORD dwDisposition;
    static const WCHAR szProviderKeyName[] = REG_CRYPTPROTECT_LOC L"\\" REG_CRYPTPROTECT_PROVIDERS_SUBKEYLOC L"\\" CRYPTPROTECT_DEFAULT_PROVIDER_GUIDSZ ;

    lRet = RtlInitializeCriticalSection(&g_csGlobals);
    if(!NT_SUCCESS(lRet))
    {
        return lRet;
    }
    g_fcsGlobalsInitialized = TRUE;

    lRet = RegCreateKeyExU(
                HKEY_LOCAL_MACHINE,
                szProviderKeyName,
                0,
                NULL,
                0,
                KEY_QUERY_VALUE | KEY_NOTIFY,
                NULL,
                &g_hProtectedStorageKey,
                &dwDisposition
                );

    if(lRet != ERROR_SUCCESS)
    {
        goto error;
    }
    g_hProtectedStorageChangeEvent = CreateEvent(NULL, 
                                                 FALSE,
                                                 TRUE,
                                                 NULL);


    lRet = UpdateGlobals(TRUE);


error:

    return lRet;
}




DWORD ShutdownGlobals()
{

    DWORD lRet = ERROR_SUCCESS;
    DWORD dwDisposition;


    if(g_hProtectedStorageKey)
    {
        RegCloseKey(g_hProtectedStorageKey);
        g_hProtectedStorageKey = NULL;
    }

    if(g_hProtectedStorageChangeEvent)
    {
        CloseHandle(g_hProtectedStorageChangeEvent);
        g_hProtectedStorageChangeEvent = NULL;
    }

    if(g_fcsGlobalsInitialized)
    {
        RtlDeleteCriticalSection(&g_csGlobals);
    }

    return lRet;
}


DWORD GetIterationCount()
{
    UpdateGlobals(FALSE);
    return g_IterationCount;
}

BOOL FIsLegacyCompliant()
{
    UpdateGlobals(FALSE);
    return g_LegacyMode;
}

BOOL FIsLegacyNt4Domain()
{
    UpdateGlobals(FALSE);
    return g_LegacyModeNt4Domain;
}

BOOL FDistributeDomainBackupKey()
{
    UpdateGlobals(FALSE);
    return g_DistributeDomainBackupKey;
}


DWORD GetMasterKeyDefaultPolicy()
{
    UpdateGlobals(FALSE);
    return g_dwMasterKeyDefaultPolicy;
}


DWORD GetDefaultAlgInfo(DWORD *pdwProvType,
                        DWORD *pdwEncryptionAlg,
                        DWORD *pdwEncryptionAlgSize,
                        DWORD *pdwMACAlg,
                        DWORD *pdwMACAlgSize)
{
    BOOL fCritSec = FALSE;

    UpdateGlobals(FALSE);

    if(g_fcsGlobalsInitialized)
    {
        RtlEnterCriticalSection(&g_csGlobals);
        fCritSec = TRUE;
    }

    if(pdwProvType)
    {
        *pdwProvType = g_dwDefaultCryptProvType;
    }
    if(pdwEncryptionAlg)
    {
        *pdwEncryptionAlg = g_dwAlgID_Encr_Alg;
    }
    if(pdwEncryptionAlgSize)
    {
        *pdwEncryptionAlgSize = g_dwAlgID_Encr_Alg_KeySize;
    }
    if(pdwMACAlg)
    {
        *pdwMACAlg = g_dwAlgID_MAC_Alg;
    }
    if(pdwMACAlgSize)
    {
        *pdwMACAlgSize = g_dwAlgID_MAC_Alg_KeySize;
    }
    if(fCritSec)
    {
        RtlLeaveCriticalSection(&g_csGlobals);
    }
    return ERROR_SUCCESS;
}


void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String
    )
{
    DWORD StringLength;

    if(String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\misc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    misc.h

Abstract:

    This module contains various DPAPI declarations.

Author:

    jbanes      10-11-2000

--*/

#define DPAPI_PACKAGE_NAME_A  "DPAPI"

extern TOKEN_SOURCE DPAPITokenSource;

extern PLSA_SECPKG_FUNCTION_TABLE g_pSecpkgTable;

extern RTL_CRITICAL_SECTION g_csCredHistoryCache;


DWORD IntializeGlobals();

DWORD ShutdownGlobals();

DWORD GetIterationCount();
BOOL  FIsLegacyCompliant();
BOOL  FIsLegacyNt4Domain();
BOOL FDistributeDomainBackupKey();
DWORD GetMasterKeyDefaultPolicy();

#define MAX_STRING_ALGID_LENGTH 30
DWORD AlgIDToString(LPWSTR wszString, DWORD dwAlgID, DWORD dwStrength );


DWORD GetDefaultAlgInfo(DWORD *pdwProvType,
                        DWORD *pdwEncryptionAlg,
                        DWORD *pdwEncryptionAlgSize,
                        DWORD *pdwMACAlg,
                        DWORD *pdwMACAlgSize);

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString, // destination
    LPWSTR String                  // source (Unicode)
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\recovery.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    recovery.c

Abstract:

    This module contains code to handle the local key recovery case.

Author:

    Pete Skelly (petesk)    May 9, 2000

--*/

#include <pch.cpp>
#pragma hdrstop
#include <ntmsv1_0.h>
#include <crypt.h>
#include <userenv.h>
#include <userenvp.h>
#include "debug.h"
#include "passrec.h"
#include "passrecp.h"
#include "pasrec.h"
#include <kerberos.h>

#define RECOVERY_KEY_BASE       L"Security\\Recovery\\"
#define RECOVERY_FILENAME       L""
#define RECOVERY_STORE_NAME     L"Recovery"


DWORD
CPSCreateServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext,
    handle_t hBinding
    );

DWORD
CPSDeleteServerContext(
    PCRYPT_SERVER_CONTEXT pServerContext
    );


DWORD
DecryptRecoveryPassword(
    IN PSID pUserSid,
    IN PBYTE pbRecoveryPrivate,
    IN DWORD cbRecoveryPrivate,
    OUT LPWSTR *ppszPassword);

DWORD
ResetLocalUserPassword(
    LPWSTR pszDomain,
    LPWSTR pszUsername,
    LPWSTR pszOldPassword,
    LPWSTR pszNewPassword);

NTSTATUS
PRCreateLocalToken(
    PUNICODE_STRING Username,
    PUNICODE_STRING Domain,
    HANDLE *Token);


DWORD 
EncryptRecoveryPassword(
    IN HANDLE hUserToken,
    IN PCCERT_CONTEXT pCertContext,
    IN PUNICODE_STRING pNewPassword)
{
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hkRecoveryPublic = 0;

    PRECOVERY_SUPPLEMENTAL_CREDENTIAL pNewCred = NULL;
    DWORD                             cbNewCred = 0;

    BYTE  NewPasswordOWF[A_SHA_DIGEST_LEN];

    PBYTE pbPasswordBuffer = NULL;
    DWORD cbPasswordBuffer = 0;
    PBYTE pbSignature = NULL;
    DWORD cbSignature = 0;

    DWORD      cbTemp = 0;
    DWORD      cbKeySize = 0;
    PSID pUserSid = NULL;

    D_DebugLog((DEB_TRACE_API, "EncryptRecoveryPassword\n"));

    //
    // We have a cert with a good signature, so
    // go ahead and encrypt to it
    //
    if(!CryptAcquireContext(&hProv, 
                            NULL, 
                            MS_STRONG_PROV, 
                            PROV_RSA_FULL, 
                            CRYPT_VERIFYCONTEXT))
    {
        dwError = GetLastError();
        goto error;
    }

    if(!CryptImportPublicKeyInfoEx(hProv,
                               pCertContext->dwCertEncodingType,
                               &pCertContext->pCertInfo->SubjectPublicKeyInfo,
                               CALG_RSA_KEYX,
                               NULL,
                               NULL,
                               &hkRecoveryPublic))
    {
        dwError = GetLastError();
        goto error;
    }

    cbTemp = sizeof(cbKeySize);
    if(!CryptGetKeyParam(hkRecoveryPublic, 
                         KP_BLOCKLEN, 
                         (PBYTE)&cbKeySize, 
                         &cbTemp, 
                         0))
    {
        dwError = GetLastError();
        goto error;
    }

    cbKeySize >>= 3;  // convert from bits to bytes

    if((DWORD)pNewPassword->Length + 20 > cbKeySize)
    {
        dwError = ERROR_INVALID_DATA;
        goto error;
    }
    
    FMyPrimitiveSHA(
            (PBYTE)pNewPassword->Buffer,
            pNewPassword->Length,
            NewPasswordOWF);

#ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Password:%ls\n", pNewPassword->Buffer));

    D_DebugLog((DEB_TRACE, "Signature OWF:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", NewPasswordOWF, sizeof(NewPasswordOWF));
#endif

    dwError = LogonCredGenerateSignature(
                  hUserToken,
                  pCertContext->pbCertEncoded,
                  pCertContext->cbCertEncoded,
                  NewPasswordOWF,
                  &pbSignature,
                  &cbSignature);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }

#ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Signature:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", pbSignature, cbSignature);
#endif

    cbNewCred = sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) +
                A_SHA_DIGEST_LEN +
                cbSignature +
                cbKeySize;




    pNewCred = (PRECOVERY_SUPPLEMENTAL_CREDENTIAL)LocalAlloc(LMEM_FIXED, cbNewCred);
    if(NULL == pNewCred)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    
    pNewCred->dwVersion = RECOVERY_SUPPLEMENTAL_CREDENTIAL_VERSION;
    pNewCred->cbRecoveryCertHashSize = A_SHA_DIGEST_LEN;
    pNewCred->cbRecoveryCertSignatureSize = cbSignature;
    pNewCred->cbEncryptedPassword = 0;

    CopyMemory((PBYTE)(pNewCred+1)+A_SHA_DIGEST_LEN,
               pbSignature,
               cbSignature);



    if(!CertGetCertificateContextProperty(pCertContext, 
                                      CERT_HASH_PROP_ID,
                                      (PBYTE)(pNewCred+1),
                                      &pNewCred->cbRecoveryCertHashSize))
    {
        dwError = GetLastError();
        goto error;
    }


    CopyMemory((PBYTE)(pNewCred+1) + 
                        pNewCred->cbRecoveryCertHashSize +
                        pNewCred->cbRecoveryCertSignatureSize,
                        pNewPassword->Buffer,
                        pNewPassword->Length);

    pNewCred->cbEncryptedPassword = pNewPassword->Length;

        
    if(!CryptEncrypt(hkRecoveryPublic,
                     0,
                     TRUE,
                     0, //CRYPT_OAEP,
                     (PBYTE)(pNewCred+1) + 
                        pNewCred->cbRecoveryCertHashSize +
                        pNewCred->cbRecoveryCertSignatureSize,
                     &pNewCred->cbEncryptedPassword,
                     cbKeySize))
    {
        dwError = GetLastError();
        goto error;
    }


    //
    // Save the recovery data to the registry.
    //

    if(!GetTokenUserSid(hUserToken, &pUserSid))
    {
        dwError = GetLastError();
        goto error;
    }


    dwError = RecoverySetSupplementalCredential(
                                    pUserSid,
                                    pNewCred, 
                                    cbNewCred);


error:

    if(pUserSid)
    {
        SSFree(pUserSid);
    }

    RtlSecureZeroMemory(NewPasswordOWF, sizeof(NewPasswordOWF));

    if(pbSignature)
    {
        LocalFree(pbSignature);
    }

    if(pNewCred)
    {
        RtlSecureZeroMemory(pNewCred, cbNewCred);
        LocalFree(pNewCred);
    }


    if(hkRecoveryPublic)
    {
        CryptDestroyKey(hkRecoveryPublic);
    }

    if(hProv)
    {
        CryptReleaseContext(hProv,0);
    }

    D_DebugLog((DEB_TRACE_API, "EncryptRecoveryPassword returned 0x%x\n", dwError));

    return dwError;
}


DWORD 
RecoverFindRecoveryPublic(            
    HANDLE hUserToken,
    PSID pUserSid,
    PCCERT_CONTEXT *ppRecoveryPublic,
    PBYTE pbVerifyOWF,
    BOOL fVerifySignature)
{
    DWORD dwError = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext = NULL;
    PRECOVERY_SUPPLEMENTAL_CREDENTIAL pCred = NULL;
    DWORD                             cbCred = 0;

    HCERTSTORE hStore = NULL;
    PSID pLocalSid = NULL;

    CRYPT_HASH_BLOB HashBlob;

    D_DebugLog((DEB_TRACE_API, "RecoverFindRecoveryPublic\n"));

    if(NULL == ppRecoveryPublic)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    if(NULL == hUserToken && fVerifySignature)
    {
        // We need the user token to verify the signature.
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

#ifdef COMPILED_BY_DEVELOPER
    D_DebugLog((DEB_TRACE, "Verify OWF:\n"));
    D_DPAPIDumpHexData(DEB_TRACE, "  ", pbVerifyOWF, A_SHA_DIGEST_LEN);
#endif

    if(pUserSid == NULL)
    {
        if(!GetTokenUserSid(hUserToken, &pLocalSid))
        {
            dwError = GetLastError();
            goto error;
        }
        pUserSid = pLocalSid;
    }

    dwError = RecoveryRetrieveSupplementalCredential(pUserSid, &pCred, &cbCred);
    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }


    // 
    // Validate cbCred
    //
    if((NULL == pCred) ||
       (sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) > cbCred) ||
       ( sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) + 
         pCred->cbRecoveryCertHashSize + 
         pCred->cbRecoveryCertSignatureSize + 
         pCred->cbEncryptedPassword > cbCred) ||
         (pCred->dwVersion != RECOVERY_SUPPLEMENTAL_CREDENTIAL_VERSION))
    {
        dwError = ERROR_INVALID_DATA;
        goto error;
    }

    // 
    // Attempt to find the recovery public
    //

    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                  X509_ASN_ENCODING,
                  NULL,
                  CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_LOCAL_MACHINE,
                  RECOVERY_STORE_NAME);

    if(NULL == hStore)
    {
        dwError = GetLastError();
        goto error;
    }

    HashBlob.cbData = pCred->cbRecoveryCertHashSize;
    HashBlob.pbData = (PBYTE)(pCred + 1);


    while(pCertContext = CertFindCertificateInStore(hStore, 
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_HASH,
                                              &HashBlob,
                                              pCertContext))
    {
        // we found one, verify it's signature
        // The signature verification will use the 'old password'
        // which will either be the current logon credential, or
        // will be in the password history

        if(fVerifySignature)
        {
            dwError = LogonCredVerifySignature( hUserToken,
                                                pCertContext->pbCertEncoded,
                                                pCertContext->cbCertEncoded,
                                                pbVerifyOWF,
                                                (PBYTE)(pCred + 1) + pCred->cbRecoveryCertHashSize,
                                                pCred->cbRecoveryCertSignatureSize);

            if(ERROR_SUCCESS == dwError)
            {
                break;
            }
        }
        else
        {
            dwError = ERROR_SUCCESS;
            break;
        }
    }


    if(NULL == pCertContext)
    {
        dwError = GetLastError();
        goto error;
    }

    *ppRecoveryPublic = pCertContext;
    pCertContext = NULL;

error:

    if(pLocalSid)
    {
        SSFree(pLocalSid);
    }

    if (pCred)
    {
        RtlSecureZeroMemory((PBYTE)pCred, cbCred);
        LocalFree(pCred);
    }

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    D_DebugLog((DEB_TRACE_API, "RecoverFindRecoveryPublic returned 0x%x\n", dwError));

    return dwError;
}


DWORD 
RecoverChangePasswordNotify(
    HANDLE UserToken,
    BYTE OldPasswordOWF[A_SHA_DIGEST_LEN], 
    PUNICODE_STRING NewPassword)
{
    DWORD dwError = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext = NULL;

    D_DebugLog((DEB_TRACE_API, "RecoverChangePasswordNotify\n"));

    // 
    // Validate cbCred
    //
    if(NULL == NewPassword)
    {
        dwError = ERROR_INVALID_DATA;
        goto error;
    }
    

    dwError = RecoverFindRecoveryPublic(UserToken,
                                        NULL,
                                        &pCertContext, 
                                        OldPasswordOWF,
                                        TRUE);          // verify signature 

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }



    dwError = EncryptRecoveryPassword(UserToken,
                                      pCertContext,
                                      NewPassword);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }


error:


    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    D_DebugLog((DEB_TRACE_API, "RecoverChangePasswordNotify returned 0x%x\n", dwError));

    return dwError;
}


DWORD 
s_SSRecoverQueryStatus(
    handle_t h,
    PBYTE pbUserName,
    DWORD cbUserName,
    DWORD *pdwStatus)
{
    DWORD dwError;
    LPWSTR pszUserName = (LPWSTR)pbUserName;
    CRYPT_SERVER_CONTEXT ServerContext;

    // Make sure username is zero terminated.
    if(pbUserName == NULL || cbUserName < sizeof(WCHAR))
    {
        return ERROR_INVALID_PARAMETER;
    }
    if(pszUserName[(cbUserName - 1) / sizeof(WCHAR)] != L'\0')
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Check for zero length username.
    if(wcslen(pszUserName) == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Validate output parameter.
    if(pdwStatus == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }


    dwError = CPSCreateServerContext(&ServerContext, h);
    if(dwError != ERROR_SUCCESS)
    {
        return dwError;
    }

    dwError = SPRecoverQueryStatus(&ServerContext,
                                   pszUserName,
                                   pdwStatus);

    CPSDeleteServerContext( &ServerContext );

    return dwError;
}


DWORD 
SPRecoverQueryStatus(
    PVOID pvContext,                // server context
    LPWSTR pszUserName,             // user name
    DWORD *pdwStatus)               // recovery status
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwDisp = RECOVERY_STATUS_OK;
    PCCERT_CONTEXT pCertContext = NULL;
    WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cchMachineName;
    PSID pUserSid = NULL;
    DWORD cbSid = 0;
    SID_NAME_USE SidType; 
    PWSTR pszDomainName = NULL;
    DWORD cchDomainName = 0;
    HANDLE hToken = 0;
    UNICODE_STRING UserName;
    UNICODE_STRING Domain;
    BOOL fImpersonated = FALSE;

    D_DebugLog((DEB_TRACE_API, "SPRecoverQueryStatus\n"));
    D_DebugLog((DEB_TRACE_API, "User name:%ls\n", pszUserName));

    //
    // Attempt to obtain the SID for the specified user.
    //

    // Determine the (local user) domain.
    cchMachineName = sizeof(szMachineName) / sizeof(WCHAR);
    if(!GetComputerName(szMachineName, &cchMachineName))
    {
        dwError = GetLastError();
        goto cleanup;
    }

    if(!LookupAccountName(szMachineName,
                          pszUserName,
                          NULL,
                          &cbSid,
                          NULL,
                          &cchDomainName,
                          &SidType))
    {
        dwError = GetLastError();

        if(dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            dwDisp = RECOVERY_STATUS_USER_NOT_FOUND;
            dwError = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    pUserSid = (PBYTE)LocalAlloc(LPTR, cbSid);
    if(pUserSid == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    pszDomainName = (PWSTR)LocalAlloc(LPTR, cchDomainName * sizeof(WCHAR));
    if(pszDomainName == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if(!LookupAccountName(szMachineName,
                          pszUserName,
                          pUserSid,
                          &cbSid,
                          pszDomainName,
                          &cchDomainName,
                          &SidType))
    {
        dwDisp = RECOVERY_STATUS_USER_NOT_FOUND;
        dwError = ERROR_SUCCESS;
        goto cleanup;
    }

    if(SidType != SidTypeUser)
    {
        dwDisp = RECOVERY_STATUS_USER_NOT_FOUND;
        dwError = ERROR_SUCCESS;
        goto cleanup;
    }


    // 
    // Attempt to find the recovery public
    //

    dwError = RecoverFindRecoveryPublic(NULL,
                                        pUserSid,
                                        &pCertContext, 
                                        NULL,       // current OWF
                                        FALSE);     // verify signature 
    if(ERROR_FILE_NOT_FOUND == dwError)
    {
        dwDisp = RECOVERY_STATUS_FILE_NOT_FOUND;
        dwError = ERROR_SUCCESS;
    } 
    else if(CRYPT_E_NOT_FOUND == dwError)
    {
        dwDisp = RECOVERY_STATUS_NO_PUBLIC_EXISTS;
        dwError = ERROR_SUCCESS;
    }
    else if(ERROR_INVALID_ACCESS == dwError)
    {
        dwDisp = RECOVERY_STATUS_PUBLIC_SIGNATURE_INVALID;
        dwError = ERROR_SUCCESS;
    }

cleanup:

    if(ERROR_SUCCESS == dwError)
    {
        D_DebugLog((DEB_TRACE_API, "Disposition: %d\n", dwDisp));
        *pdwStatus = dwDisp;
    }

    if(hToken)
    {
        CloseHandle(hToken);
    }

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(pUserSid) LocalFree(pUserSid);
    if(pszDomainName) LocalFree(pszDomainName);

    if(fImpersonated)
    {
        CPSRevertToSelf(pvContext);
    }

    D_DebugLog((DEB_TRACE_API, "SPRecoverQueryStatus returned 0x%x\n", dwError));

    return dwError;
}


NTSTATUS
VerifyCredentials(
    IN PWSTR UserName,
    IN PWSTR DomainName,
    IN PWSTR Password
    )
{
    PKERB_VERIFY_CREDENTIALS_REQUEST pVerifyRequest;
    KERB_VERIFY_CREDENTIALS_REQUEST VerifyRequest;

    ULONG cbVerifyRequest;

    PVOID pResponse = NULL;
    ULONG cbResponse;

    USHORT cbUserName;
    USHORT cbDomainName;
    USHORT cbPassword;

    NTSTATUS ProtocolStatus = STATUS_LOGON_FAILURE;
    NTSTATUS Status;

    UNICODE_STRING AuthenticationPackage;

    RtlInitUnicodeString(&AuthenticationPackage, MICROSOFT_KERBEROS_NAME_W);

    cbUserName = (USHORT)(lstrlenW(UserName) * sizeof(WCHAR)) ;
    cbDomainName = (USHORT)(lstrlenW(DomainName) * sizeof(WCHAR)) ;
    cbPassword = (USHORT)(lstrlenW(Password) * sizeof(WCHAR)) ;


    cbVerifyRequest = sizeof(VerifyRequest) +
                        cbUserName +
                        cbDomainName +
                        cbPassword ;

    pVerifyRequest = &VerifyRequest;
    ZeroMemory( &VerifyRequest, sizeof(VerifyRequest) );


    pVerifyRequest->MessageType = KerbVerifyCredentialsMessage ;

    //
    // do the length, buffers, copy,  marshall dance.
    //

    pVerifyRequest->UserName.Length = cbUserName;
    pVerifyRequest->UserName.MaximumLength = cbUserName;
    pVerifyRequest->UserName.Buffer = UserName;

    pVerifyRequest->DomainName.Length = cbDomainName;
    pVerifyRequest->DomainName.MaximumLength = cbDomainName;
    pVerifyRequest->DomainName.Buffer = DomainName;

    pVerifyRequest->Password.Length = cbPassword;
    pVerifyRequest->Password.MaximumLength = cbPassword;
    pVerifyRequest->Password.Buffer = Password;

    pVerifyRequest->VerifyFlags = 0;

    Status = LsaICallPackage(
                &AuthenticationPackage,
                pVerifyRequest,
                cbVerifyRequest,
                &pResponse,
                &cbResponse,
                &ProtocolStatus
                );

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = ProtocolStatus;

Cleanup:

    return Status;
}


DWORD
s_SSRecoverImportRecoveryKey(
    handle_t h,
    BYTE* pbUsername,
    DWORD cbUsername,
    BYTE* pbCurrentPassword,
    DWORD cbCurrentPassword,
    BYTE* pbRecoveryPublic,
    DWORD cbRecoveryPublic)
                           
{
    DWORD dwError = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext = NULL;
    HANDLE hUserToken = NULL;
    HCERTSTORE hStore = NULL;
    WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cchMachineName;
    LPWSTR pszUsername = (LPWSTR)pbUsername;
    LPWSTR pszCurrentPassword = (LPWSTR)pbCurrentPassword;
    UNICODE_STRING Domain;
    UNICODE_STRING Username;
    UNICODE_STRING Password;

    D_DebugLog((DEB_TRACE_API, "s_SSRecoverImportRecoveryKey\n"));

    //
    // Validate input parameters.
    //

    if(pbUsername == NULL || cbUsername < sizeof(WCHAR) ||
       pbCurrentPassword == NULL || cbCurrentPassword < sizeof(WCHAR) ||
       pbRecoveryPublic == NULL || cbRecoveryPublic == 0)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    // Make sure strings are zero terminated.
    if((pszUsername[(cbUsername - 1) / sizeof(WCHAR)] != L'\0') ||
       (pszCurrentPassword[(cbCurrentPassword - 1) / sizeof(WCHAR)] != L'\0'))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    // Check for zero length username.
    if(wcslen(pszUsername) == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }


    // Perform this operation as local system.
    RevertToSelf();
    

    // 
    // Verify the supplied password. 
    // This ensures that we're being called by the actual user, and
    // that we're not being spoofed into creating a non-authorized
    // recovery certificate. 
    //

    cchMachineName = MAX_COMPUTERNAME_LENGTH + 1;

    if(!GetComputerName(szMachineName, &cchMachineName))
    {
        dwError = GetLastError();
        goto error;
    }

    dwError = VerifyCredentials(pszUsername,
                                szMachineName,
                                pszCurrentPassword);

    if(!NT_SUCCESS(dwError))
    {
        D_DebugLog((DEB_ERROR, "s_SSRecoverImportRecoveryKey: password did not verify (0x%x)\n", dwError));
        goto error;
    }

    
    //
    // Create a token for the user. This will be used when signing the
    // recovery file. It almost makes sense to call LogonUser in order to do
    // this (since we have the password and everything), but that function 
    // fails on Whistler when the user has a blank password.
    //

    RtlInitUnicodeString(&Domain, szMachineName);
    RtlInitUnicodeString(&Username, pszUsername);
    RtlInitUnicodeString(&Password, pszCurrentPassword);

    dwError = PRCreateLocalToken(&Username, &Domain, &hUserToken);

    if(!NT_SUCCESS(dwError))
    {
        D_DebugLog((DEB_ERROR, "s_SSRecoverImportRecoveryKey: could not create local token (0x%x)\n", dwError));
        goto error;
    }


    //
    // Add the recovery certificate to the recovery store.
    //
  
    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                 pbRecoveryPublic,
                                                 cbRecoveryPublic);
    if(NULL == pCertContext)
    {
        dwError = GetLastError();
        goto error;
    }



    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                  X509_ASN_ENCODING,
                  NULL,
                  CERT_SYSTEM_STORE_LOCAL_MACHINE,
                  RECOVERY_STORE_NAME);

    if(NULL == hStore)
    {
        dwError = GetLastError();
        goto error;
    }

    if(!CertAddCertificateContextToStore(hStore, 
                                     pCertContext,
                                     CERT_STORE_ADD_REPLACE_EXISTING,
                                     NULL))
    {
        dwError = GetLastError();
        goto error;
    }


    dwError = EncryptRecoveryPassword(hUserToken,
                                      pCertContext,
                                      &Password);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }

error:

    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hUserToken)
    {
        CloseHandle(hUserToken);
    }

    D_DebugLog((DEB_TRACE_API, "s_SSRecoverImportRecoveryKey returned 0x%x\n", dwError));

    return dwError;
}


NTSTATUS
PRCreateLocalToken(
    PUNICODE_STRING Username,
    PUNICODE_STRING Domain,
    HANDLE *Token)
{
    NTSTATUS Status;
    NTSTATUS SubStatus;
    LUID LogonId;
    PUCHAR AuthData;
    DWORD AuthDataLen;
    SECURITY_STRING PacUserName;


    //
    // Obtain a PAC for the user.
    //

    Status = g_pSecpkgTable->GetAuthDataForUser( 
                                    Username,
                                    SecNameSamCompatible,
                                    NULL,
                                    &AuthData,
                                    &AuthDataLen,
                                    NULL );
    if (!NT_SUCCESS(Status))
    {
        goto cleanup;
    }


    //
    // Convert the PAC into a user token.
    //

    PacUserName.Buffer = NULL;

    Status = g_pSecpkgTable->ConvertAuthDataToToken(
                                    AuthData,
                                    AuthDataLen,
                                    SecurityImpersonation,
                                    &DPAPITokenSource,
                                    Network,
                                    Domain,
                                    Token,
                                    &LogonId,
                                    &PacUserName,
                                    &SubStatus );

cleanup:

    return Status;
}

//+---------------------------------------------------------------------------
//
//  Function:   PRGetProfilePath
//
//  Synopsis:   Returns the path for user's application data.
//
//
//  Arguments:  [hUserToken] -- An access token representing a particular 
//                              user. The token must have TOKEN_IMPERSONATE 
//                              and TOKEN_QUERY priviledge. 
//
//              [pszPath]    -- Pointer to a buffer of length MAX_PATH to 
//                              receive the path. If error occurs then the 
//                              string will be empty.
//
//----------------------------------------------------------------------------
DWORD               
PRGetProfilePath(
    IN HANDLE hUserToken OPTIONAL,
    OUT PWSTR pszPath)
{
    DWORD Status;
    HANDLE hToken = NULL;
    HANDLE hLocalToken = NULL;

    //
    // Default to empty string.
    //

    *pszPath = L'\0';


    //
    // If a user token is explicitly specified, then use it.
    // Otherwise, use the current thread token.
    //

    if(hUserToken)
    {
        hToken = hUserToken;
    }
    else 
    {
        if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hLocalToken))
        {
            Status = GetLastError();
            goto cleanup;
        }

        hToken = hLocalToken;
    }


    //
    // Get path to user's profile data. This will typically look something
    // like "c:\Documents and Settings\<user>\Application Data".
    //

    Status = GetUserAppDataPath(hToken, FALSE, pszPath);

    if(Status != ERROR_SUCCESS)
    {
        D_DebugLog((DEB_ERROR, "GetUserAppDataPath returned: %d\n", Status));
        goto cleanup;
    }

    D_DebugLog((DEB_TRACE, "Profile path:%ls\n", pszPath));


cleanup:

    if(hLocalToken)
    {
        CloseHandle(hLocalToken);
    }

    return Status;
}


DWORD 
RecoverySetSupplementalCredential(
    IN PSID pUserSid,
    IN PRECOVERY_SUPPLEMENTAL_CREDENTIAL pSupplementalCred, 
    IN DWORD cbSupplementalCred)
{
    WCHAR szPath[MAX_PATH + 1];
    LPWSTR pszTextualSid;
    DWORD cchTextualSid;
    HKEY hRecovery = NULL;
    DWORD Disp;
    DWORD dwError;
    HANDLE hOldUser = NULL;

    D_DebugLog((DEB_TRACE_API, "RecoverySetSupplementalCredential\n"));

    //
    // Build path to recovery data.
    //

    wcscpy(szPath, RECOVERY_KEY_BASE);

    pszTextualSid = szPath + wcslen(szPath);
    cchTextualSid = (sizeof(szPath) / sizeof(WCHAR)) - wcslen(szPath);

    if(!GetTextualSid(pUserSid, pszTextualSid, &cchTextualSid))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }


    //
    // Write data to registry as local system.
    //

    if(!OpenThreadToken(GetCurrentThread(), 
                    TOKEN_IMPERSONATE | TOKEN_READ,
                    TRUE, 
                    &hOldUser)) 
    {
        hOldUser = NULL;
    }
    RevertToSelf();


    //
    // Write recovery data to the registry.
    //

    dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             szPath,
                             0,
                             TEXT(""),
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             NULL,
                             &hRecovery,
                             &Disp);

    if(dwError != ERROR_SUCCESS)
    {
        goto error;
    }

    dwError = RegSetValueEx(hRecovery,
                            RECOVERY_FILENAME,
                            NULL,
                            REG_BINARY,
                            (PBYTE)pSupplementalCred,
                            cbSupplementalCred);

    if(dwError != ERROR_SUCCESS)
    {
        goto error;
    }

   
    dwError = ERROR_SUCCESS;


error:

    if(hRecovery)
    {
        RegCloseKey(hRecovery);
    }

    if(hOldUser)
    {

        //
        // We can do nothing about the failure of SetThreadToken here.
        //

        (void) SetThreadToken(NULL, hOldUser);
        CloseHandle(hOldUser);
    }

    D_DebugLog((DEB_TRACE_API, "RecoverySetSupplementalCredential returned 0x%x\n", dwError));

    return dwError;
}


DWORD 
RecoveryRetrieveSupplementalCredential(
    IN  PSID pUserSid,
    OUT PRECOVERY_SUPPLEMENTAL_CREDENTIAL *ppSupplementalCred, 
    OUT DWORD *pcbSupplementalCred)
{
    WCHAR szPath[MAX_PATH + 1];
    LPWSTR pszTextualSid;
    DWORD cchTextualSid;
    HKEY hRecovery = NULL;
    DWORD Type;
    PBYTE pbData = NULL;
    DWORD cbData;
    DWORD dwError;
    HANDLE hOldUser = NULL;

    D_DebugLog((DEB_TRACE_API, "RecoveryRetrieveSupplementalCredential\n"));


    //
    // Build path to recovery data.
    //

    wcscpy(szPath, RECOVERY_KEY_BASE);

    pszTextualSid = szPath + wcslen(szPath);
    cchTextualSid = (sizeof(szPath) / sizeof(WCHAR)) - wcslen(szPath);

    if(!GetTextualSid(pUserSid, pszTextualSid, &cchTextualSid))
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }


    //
    // Read data from registry as local system.
    //

    if(!OpenThreadToken(GetCurrentThread(), 
                    TOKEN_IMPERSONATE | TOKEN_READ,
                    TRUE, 
                    &hOldUser)) 
    {
        hOldUser = NULL;
    }
    RevertToSelf();


    //
    // Read recovery data blob out of the registry.
    //

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szPath,
                           0,
                           KEY_READ,
                           &hRecovery);

    if(dwError != ERROR_SUCCESS)
    {
        goto error;
    }


    dwError = RegQueryValueEx(hRecovery,
                              RECOVERY_FILENAME,
                              NULL,
                              &Type,
                              NULL,
                              &cbData);

    if(dwError != ERROR_SUCCESS)
    {
        if(dwError != ERROR_MORE_DATA)
        {
            goto error;
        }
    }

    pbData = (PBYTE)LocalAlloc(LPTR, cbData);
    if(pbData == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    dwError = RegQueryValueEx(hRecovery,
                              RECOVERY_FILENAME,
                              NULL,
                              &Type,
                              pbData,
                              &cbData);

    if(dwError != ERROR_SUCCESS)
    {
        if(dwError != ERROR_MORE_DATA)
        {
            goto error;
        }
    }

    if(Type != REG_BINARY)
    {
        dwError = ERROR_INVALID_DATA;
        goto error;
    }


    //
    // Set output parameters.
    //

    *ppSupplementalCred = (PRECOVERY_SUPPLEMENTAL_CREDENTIAL)pbData;
    *pcbSupplementalCred = cbData;

    pbData = NULL;
    
    dwError = ERROR_SUCCESS;


error:

    if(hRecovery)
    {
        RegCloseKey(hRecovery);
    }

    if(hOldUser)
    {
        //
        // We can do nothing if SetThreadTOken fails here
        //

        (void)SetThreadToken(NULL, hOldUser);
        CloseHandle(hOldUser);
    }

    if(pbData)
    {
        LocalFree(pbData);
    }

    D_DebugLog((DEB_TRACE_API, "RecoveryRetrieveSupplementalCredential returned 0x%x\n", dwError));

    return dwError;
}



DWORD 
s_SSRecoverPassword(
    handle_t h,
    PBYTE pbUsername,
    DWORD cbUsername,
    PBYTE pbRecoveryPrivate,
    DWORD cbRecoveryPrivate,
    PBYTE pbNewPassword,
    DWORD cbNewPassword)
{
    DWORD dwError = ERROR_SUCCESS;
    PWSTR pszUsername = (PWSTR)pbUsername;
    PWSTR pszNewPassword = (PWSTR)pbNewPassword;
    PWSTR pszOldPassword = NULL;
    CRYPT_SERVER_CONTEXT ServerContext;
    PSID pSid = NULL;
    DWORD cbSid;
    WCHAR szDomain[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cchDomain;
    SID_NAME_USE AcctType;


    D_DebugLog((DEB_TRACE_API, "s_SSRecoverPassword\n"));

    dwError = CPSCreateServerContext(&ServerContext, h);
    if(dwError != ERROR_SUCCESS)
    {
        return dwError;
    }

    //
    // Validate input parameters.
    //

    if(pbUsername == NULL || cbUsername < sizeof(WCHAR) ||
       pbRecoveryPrivate == NULL || cbRecoveryPrivate == 0 ||
       pbNewPassword == NULL || cbNewPassword < sizeof(WCHAR))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    // Make sure strings are zero terminated.
    if((pszUsername[(cbUsername - 1) / sizeof(WCHAR)] != L'\0') ||
       (pszNewPassword[(cbNewPassword - 1) / sizeof(WCHAR)] != L'\0'))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    // Check for zero length username.
    if(wcslen(pszUsername) == 0)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    //
    // Lookup the user SID.
    //

    cchDomain = MAX_COMPUTERNAME_LENGTH + 1;
    if(!GetComputerNameW(szDomain, &cchDomain))
    {
        dwError = GetLastError();
        goto error;
    }

    if(!LookupAccountNameW(szDomain,
                           pszUsername,
                           NULL,
                           &cbSid,
                           NULL,
                           &cchDomain,
                           &AcctType)) 
    {
        dwError = GetLastError();

        if(dwError != ERROR_INSUFFICIENT_BUFFER)
        {
            goto error;
        }
    }

    pSid = (PBYTE)LocalAlloc(LPTR, cbSid);
    if(pSid == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    if(cchDomain > MAX_COMPUTERNAME_LENGTH + 1)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    if(!LookupAccountNameW(szDomain,
                           pszUsername,
                           pSid,
                           &cbSid,
                           szDomain,
                           &cchDomain,
                           &AcctType)) 
    {
        dwError = GetLastError();
        goto error;
    }



    //
    // Import the recovery private
    //
    // The private comes in the form of a version DWORD, followed by a certificate, 
    // followed directly by a pvk import blob, so skip past the certificate
    //
   
    if((cbRecoveryPrivate < 2*sizeof(DWORD)) ||
        ( *((DWORD *)pbRecoveryPrivate) != RECOVERY_BLOB_MAGIC) ||
        ( *((DWORD *)(pbRecoveryPrivate + sizeof(DWORD))) != RECOVERY_BLOB_VERSION))
    {
        dwError = ERROR_INVALID_DATA;
        goto error;
    }

    //
    // Decrypt the recovery file in order to obtain the user's
    // old password. Shazam!
    //

    dwError = DecryptRecoveryPassword(pSid,
                                      pbRecoveryPrivate,
                                      cbRecoveryPrivate,
                                      &pszOldPassword);

    if(dwError != ERROR_SUCCESS)
    {
        CPSImpersonateClient(&ServerContext);
        goto error;
    }


    //
    // Set the user's password to the new value.
    //

    dwError = ResetLocalUserPassword(szDomain,
                                     pszUsername,
                                     pszOldPassword,
                                     pszNewPassword);
    if(dwError != STATUS_SUCCESS)
    {
        D_DebugLog((DEB_ERROR, "Error changing user's password (0x%x)\n", dwError));
        goto error;
    }


error:

    if(pSid)
    {
        LocalFree(pSid);
    }

    if(pszOldPassword)
    {
        RtlSecureZeroMemory(pszOldPassword, wcslen(pszOldPassword) * sizeof(WCHAR));
        LocalFree(pszOldPassword);
        pszOldPassword = NULL;
    }

    if(pbNewPassword && cbNewPassword)
    {
        RtlSecureZeroMemory(pbNewPassword, cbNewPassword);
    }

    CPSDeleteServerContext(&ServerContext);

    D_DebugLog((DEB_TRACE_API, "s_SSRecoverPassword returned 0x%x\n", dwError));

    return dwError;
}


DWORD
DecryptRecoveryPassword(
    IN PSID pUserSid,
    IN PBYTE pbRecoveryPrivate,
    IN DWORD cbRecoveryPrivate,
    OUT LPWSTR *ppszPassword)
{
    PRECOVERY_SUPPLEMENTAL_CREDENTIAL pCred = NULL;
    DWORD cbCred = 0;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hkRecoveryPrivate = 0;
    PBYTE pbPasswordBuffer = NULL;
    DWORD cbPasswordBuffer = 0;
    DWORD dwError;

    D_DebugLog((DEB_TRACE, "DecryptRecoveryPassword\n"));


    //
    // Read the recovery data.
    //

    dwError = RecoveryRetrieveSupplementalCredential(pUserSid,
                                                     &pCred, 
                                                     &cbCred);
    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }

    if((NULL == pCred) ||
       (sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) > cbCred) ||
       ( sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) + 
         pCred->cbRecoveryCertHashSize + 
         pCred->cbRecoveryCertSignatureSize + 
         pCred->cbEncryptedPassword > cbCred) ||
         (pCred->dwVersion != RECOVERY_SUPPLEMENTAL_CREDENTIAL_VERSION))
    {
        dwError =  ERROR_INVALID_DATA;
        goto error;
    }



    //
    // Import the recovery private key into CryptoAPI.
    //

    if(!CryptAcquireContext(&hProv, NULL, MS_STRONG_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        dwError = GetLastError();
        goto error;
    }


    if(!CryptImportKey(hProv, 
                       pbRecoveryPrivate + 2*sizeof(DWORD), 
                       cbRecoveryPrivate - 2*sizeof(DWORD),
                       0, 
                       0, 
                       &hkRecoveryPrivate))
    {
        dwError = GetLastError();
        goto error;
    }

    cbPasswordBuffer = cbCred - (sizeof(RECOVERY_SUPPLEMENTAL_CREDENTIAL) + 
                                 pCred->cbRecoveryCertHashSize + 
                                 pCred->cbRecoveryCertSignatureSize);

    pbPasswordBuffer = (PBYTE)LocalAlloc(LPTR, cbPasswordBuffer);

    if(NULL == pbPasswordBuffer)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    CopyMemory(pbPasswordBuffer,  
               (PBYTE)(pCred + 1) + 
               pCred->cbRecoveryCertHashSize + 
               pCred->cbRecoveryCertSignatureSize,
               cbPasswordBuffer);


    //
    // OAEP padding includes random data, as well as a
    // verification mechanism, so we don't need to worry about
    // salting the password.
    //

    if(!CryptDecrypt(hkRecoveryPrivate,
                 0,
                 TRUE,
                 0, //CRYPT_OAEP,
                 pbPasswordBuffer,
                 &cbPasswordBuffer))
    {
        dwError = GetLastError();
        D_DebugLog((DEB_ERROR, "Error 0x%x decrypting user's password\n", dwError));
        goto error;
    }

    //
    // Zero terminate the password.
    //

    *((LPWSTR)pbPasswordBuffer + cbPasswordBuffer/sizeof(WCHAR)) = L'\0';

    *ppszPassword = (LPWSTR)pbPasswordBuffer;
    pbPasswordBuffer = NULL;

    dwError = ERROR_SUCCESS;

error:

    if(pbPasswordBuffer)
    {
        LocalFree(pbPasswordBuffer);
    }

    if(pCred)
    {
        RtlSecureZeroMemory((PBYTE)pCred, cbCred);
        LocalFree(pCred);
    }

    if(hkRecoveryPrivate)
    {
        CryptDestroyKey(hkRecoveryPrivate);
    }

    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

    D_DebugLog((DEB_TRACE, "DecryptRecoveryPassword returned 0x%x\n", dwError));

    return dwError;
}


DWORD
ResetLocalUserPassword(
    LPWSTR pszDomain,
    LPWSTR pszUsername,
    LPWSTR pszOldPassword,
    LPWSTR pszNewPassword)
{
    UNICODE_STRING Domain;
    UNICODE_STRING Username;
    UNICODE_STRING OldPassword;
    UNICODE_STRING NewPassword;
    NTSTATUS Status;
    HANDLE hToken = NULL;

    D_DebugLog((DEB_TRACE, "ResetLocalUserPassword\n"));


    //
    // Cruft up a local token for the user.
    //

    RtlInitUnicodeString(&Domain, pszDomain);
    RtlInitUnicodeString(&Username, pszUsername);
    RtlInitUnicodeString(&OldPassword, pszOldPassword);
    RtlInitUnicodeString(&NewPassword, pszNewPassword);

    Status = PRCreateLocalToken(&Username, &Domain, &hToken);

    if(!NT_SUCCESS(Status))
    {
        goto cleanup;
    }


    // 
    // Set the password on the user account to the new value.
    //

    Status = SamIChangePasswordForeignUser2(NULL,
                                            &Username,
                                            &NewPassword,
                                            hToken,
                                            USER_CHANGE_PASSWORD);

    if(!NT_SUCCESS(Status))
    {
        goto cleanup;
    }


    //
    // Notify DPAPI of the password change. This will cause the CREDHIST
    // and RECOVERY files to be updated, and the master key files to be
    // re-encrypted with the new password.
    //

    LsaINotifyPasswordChanged(&Domain,
                              &Username,
                              NULL,
                              NULL,
                              &OldPassword,
                              &NewPassword,
                              TRUE);

cleanup:

    if(hToken)
    {
        CloseHandle(hToken);
    }

    D_DebugLog((DEB_TRACE, "ResetLocalUserPassword returned 0x%x\n", Status));

    return Status;
}

NTSTATUS 
CreateSystemDirectory(
    LPCWSTR lpPathName)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;

    if(!RtlDosPathNameToRelativeNtPathName_U( lpPathName,
                                              &FileName,
                                              NULL,
                                              &RelativeName))
    {
        return STATUS_OBJECT_PATH_NOT_FOUND;
    }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) 
    {
        FileName = RelativeName.RelativeName;
    }
    else 
    {
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes( &Obja,
                                &FileName,
                                OBJ_CASE_INSENSITIVE,
                                RelativeName.ContainingDirectory,
                                NULL );

    // Creating the directory with attribute FILE_ATTRIBUTE_SYSTEM to avoid inheriting encryption 
    // property from parent directory

    Status = NtCreateFile( &Handle,
                           FILE_LIST_DIRECTORY | SYNCHRONIZE,
                           &Obja,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_SYSTEM,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_CREATE,
                           FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT,
                           NULL,
                           0L );

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    if(NT_SUCCESS(Status))
    {
        NtClose(Handle);
        return STATUS_SUCCESS;
    }
    else 
    {
        return Status;
    }
}


/*++

    Create all subdirectories if they do not exists starting at
    szCreationStartPoint.

    szCreationStartPoint must point to a character within the null terminated
    buffer specified by the szFullPath parameter.

    Note that szCreationStartPoint should not point at the first character
    of a drive root, eg:

    d:\foo\bar\bilge\water
    \\server\share\foo\bar
    \\?\d:\big\path\bilge\water

    Instead, szCreationStartPoint should point beyond these components, eg:

    bar\bilge\water
    foo\bar
    big\path\bilge\water

    This function does not implement logic for adjusting to compensate for these
    inputs because the environment it was design to be used in causes the input
    szCreationStartPoint to point well into the szFullPath input buffer.


--*/
DWORD
DPAPICreateNestedDirectories(
    IN      LPWSTR szFullPath,
    IN      LPWSTR szCreationStartPoint // must point in null-terminated range of szFullPath
    )
{
    DWORD i;
    DWORD cchRemaining;
    DWORD dwLastError = STATUS_SUCCESS;

    BOOL fSuccess = FALSE;


    if( szCreationStartPoint < szFullPath ||
        szCreationStartPoint  > (lstrlenW(szFullPath) + szFullPath)
        )
    {
        return STATUS_INVALID_PARAMETER;
    }

    cchRemaining = lstrlenW( szCreationStartPoint );

    //
    // scan from left to right in the szCreationStartPoint string
    // looking for directory delimiter.
    //

    for ( i = 0 ; i < cchRemaining ; i++ ) 
    {
        WCHAR charReplaced = szCreationStartPoint[ i ];

        if( charReplaced == L'\\' || charReplaced == L'/' ) 
        {

            szCreationStartPoint[ i ] = L'\0';

            dwLastError = CreateSystemDirectory(szFullPath);

            szCreationStartPoint[ i ] = charReplaced;

            if(dwLastError == STATUS_OBJECT_NAME_COLLISION)
            {
                dwLastError = STATUS_SUCCESS;
            }

            //
            // Continue onwards regardless of errors, trying to create the
            // specified subdirectories. This is done to address the obscure 
            // scenario where the Bypass Traverse Checking Privilege allows 
            // the caller to create directories below an existing path where 
            // one component denies the user access. We just keep trying 
            // and the last CreateSystemDirectory() result is returned to 
            // the caller.
            //
        }
    }

    return dwLastError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\pch.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pch.cpp

Abstract:

    pch header files


Author:

    petesk 2/2/2000

Revision History:

    

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>
#include <rpc.h>

// crypto headers
#include <shlobj.h>
#include <wincrypt.h>
#include <sha.h>
#include <rc4.h>
#include <des.h>
#include <tripldes.h>
#include <modes.h>
#include <crypt.h>


extern "C"
{
// Private LSA functionality
#include <ntsam.h>
#include <ntlsa.h>
#include <samrpc.h>
#include <samisrv.h>
#include <lsarpc.h>
#include <lsaisrv.h> 
}


#include "lnklist.h"
#include "crypt32.h"

#include "guidcnvt.h"
#include "dpapiprv.h"
#include "passrecp.h"
#include "dprpc.h" 
#include "keyrpc.h"
#include "keyback.h"
#include "keysrv.h"
#include "memprot.h"
#include "keyman.h"
#include "keycache.h"
#include "keybckup.h"
#include "crtem.h"
#include "crypt32p.h"
#include "capiprim.h"
#include "unicode.h"
#include "unicode5.h"
#include "secmisc.h"
#include "filemisc.h"
#include "primitiv.h"

#include "pmacros.h"

#include "debug.h"
#include "misc.h"

#include "dsysdbg.h"
#include "dpapidbg.h"

#include "resource.h"
#include "session.h"
#include "recovery.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\recovery.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    recovery.h

Abstract:

    This module contains prototypes to support local account password recovery.

Author:

    Pete Skelly (petesk)    09-May-00

--*/

#ifndef __RECOVERY_H__
#define __RECOVERY_H__

#ifdef __cplusplus
extern "C" {
#endif

DWORD 
SPRecoverQueryStatus(
    PVOID pvContext,
    LPWSTR pszUserName,
    DWORD *pdwStatus);

DWORD
PRCreateDummyToken(
    PUNICODE_STRING Username,
    PUNICODE_STRING Domain,
    HANDLE *Token);

DWORD               
PRGetProfilePath(
    HANDLE hUserToken,
    PWSTR pszPath);

DWORD 
RecoverChangePasswordNotify(
    HANDLE UserToken,
    BYTE OldPasswordOWF[A_SHA_DIGEST_LEN], 
    PUNICODE_STRING NewPassword);


#ifdef __cplusplus
}
#endif


#endif // __RECOVERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\session.cpp ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    session.c

Abstract:

    This module contains routines to support communication with the LSA
    (Local Security Authority) to permit querying of active sessions.

    This module also supports calling into the LSA to retrieve a credential
    derived from a logged on user specified by Logon Identifier.

Author:

    Scott Field (sfield)    02-Mar-97

    Pete Skelly (petesk)    09-May-00 - added credential history and signature code

--*/


#include <pch.cpp>
#pragma hdrstop
#include <ntmsv1_0.h>
#include <crypt.h>
#include <userenv.h>
#include <userenvp.h>
#include "debug.h"
#include "passrec.h"

#define HMAC_K_PADSIZE      (64)

#define CREDENTIAL_HISTORY_VERSION 1

#define CREDENTIAL_HISTORY_SALT_SIZE  16    // 128 bits

#define DEFAULT_KEY_GEN_ALG  CALG_HMAC
#define DEFAULT_ENCRYPTION_ALG CALG_3DES


typedef struct _CREDENTIAL_HISTORY_HEADER
{
    DWORD dwVersion;
    GUID  CredentialID;
    DWORD dwPreviousCredOffset;
} CREDENTIAL_HISTORY_HEADER, *PCREDENTIAL_HISTORY_HEADER;

typedef struct _CREDENTIAL_HISTORY
{
    CREDENTIAL_HISTORY_HEADER Header;
    DWORD dwFlags;
    DWORD KeyGenAlg;
    DWORD cIterationCount;                  // pbkdf2 iteration count
    DWORD cbSid;                            // sid is used as mixing bytes
    DWORD KeyEncrAlg;
    DWORD cbShaOwf;
    DWORD cbNtOwf;
    BYTE  Salt[CREDENTIAL_HISTORY_SALT_SIZE];
} CREDENTIAL_HISTORY, *PCREDENTIAL_HISTORY;


typedef struct _CREDENTIAL_HISTORY_MAP
{
    PSID    pUserSid;
    WCHAR   wszFilePath[MAX_PATH+1];
    HANDLE  hHistoryFile;
    HANDLE  hMapping;
    DWORD   dwMapSize;
    PBYTE   pMapping;
    struct _CREDENTIAL_HISTORY_MAP *pNext;

} CREDENTIAL_HISTORY_MAP, *PCREDENTIAL_HISTORY_MAP;


RTL_CRITICAL_SECTION g_csCredHistoryCache;


DWORD
OpenCredentialHistoryMap(
    HANDLE hUserToken,
    LPWSTR pszProfilePath,
    PCREDENTIAL_HISTORY_MAP *ppMap,
    PCREDENTIAL_HISTORY *ppCurrent);

PCREDENTIAL_HISTORY
GetPreviousCredentialHistory(
                             PCREDENTIAL_HISTORY_MAP pMap,
                             PCREDENTIAL_HISTORY pCurrent
                             );

DWORD
CloseCredentialHistoryMap(PCREDENTIAL_HISTORY_MAP pMap,
                          BOOL fReader);

DWORD
DestroyCredentialHistoryMap(PCREDENTIAL_HISTORY_MAP pMap);

VOID
DeriveWithHMAC_SHA1(
    IN      PBYTE   pbKeyMaterial,              // input key material
    IN      DWORD   cbKeyMaterial,
    IN      PBYTE   pbData,                     // input mixing data
    IN      DWORD   cbData,
    IN OUT  BYTE    rgbHMAC[A_SHA_DIGEST_LEN]   // output buffer
    );

DWORD
DecryptCredentialHistory(PCREDENTIAL_HISTORY pCredential,
                         BYTE rgbDecryptingCredential[A_SHA_DIGEST_LEN],
                         BYTE rgbShaOwf[A_SHA_DIGEST_LEN],
                         BYTE rgbNTOwf[A_SHA_DIGEST_LEN]);




DWORD
RetrieveCurrentDerivedCredential(
    IN      LUID *pLogonId,
    IN      BOOL fDPOWF,
    IN      PBYTE pbMixingBytes,
    IN      DWORD cbMixingBytes,
    IN OUT  BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN]
    )
{
    NTSTATUS ntstatus;
    DWORD    rc = ERROR_SUCCESS;
    NTSTATUS AuthPackageStatus;

    PMSV1_0_DERIVECRED_REQUEST pDeriveCredentialRequest;
    DWORD cbDeriveCredentialRequest;
    PMSV1_0_DERIVECRED_RESPONSE pDeriveCredentialResponse;
    ULONG DeriveCredentialResponseLength;
    UNICODE_STRING PackageName;
    HANDLE hToken = NULL;





    RtlInitUnicodeString(&PackageName, L"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");


    //
    // must specify mixing bytes.
    //

    if( cbMixingBytes == 0 || pbMixingBytes == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Ask authentication package to provide derived credential associated
    // with the specified logon identifier.
    // note: submit buffer must be a single contiguous block.
    //

    cbDeriveCredentialRequest = sizeof(MSV1_0_DERIVECRED_REQUEST) + cbMixingBytes;
    pDeriveCredentialRequest = (MSV1_0_DERIVECRED_REQUEST *)SSAlloc( cbDeriveCredentialRequest );
    if( pDeriveCredentialRequest == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pDeriveCredentialRequest->MessageType = MsV1_0DeriveCredential;
    CopyMemory( &(pDeriveCredentialRequest->LogonId), pLogonId, sizeof(LUID) );
    pDeriveCredentialRequest->DeriveCredType = fDPOWF?MSV1_0_DERIVECRED_TYPE_SHA1_V2:MSV1_0_DERIVECRED_TYPE_SHA1;
    pDeriveCredentialRequest->DeriveCredInfoLength = cbMixingBytes;

    CopyMemory(pDeriveCredentialRequest->DeriveCredSubmitBuffer, pbMixingBytes, cbMixingBytes);

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE, TRUE, &hToken))
    {
        return GetLastError();
    }


    RevertToSelf();

    // Make this call as local system

    ntstatus = LsaICallPackage(
                                &PackageName,
                                pDeriveCredentialRequest,
                                cbDeriveCredentialRequest,
                                (PVOID *)&pDeriveCredentialResponse,
                                &DeriveCredentialResponseLength,
                                &AuthPackageStatus
                                );

    SSFree( pDeriveCredentialRequest );

    if (!SetThreadToken(NULL, hToken))
    {
        rc = GetLastError();
    }
    CloseHandle(hToken);

    if(!NT_SUCCESS(ntstatus))
    {
        return RtlNtStatusToDosError(ntstatus);
    }

    if (ERROR_SUCCESS == rc) 
    {

        CopyMemory( rgbDerivedCredential,
                    pDeriveCredentialResponse->DeriveCredReturnBuffer,
                    pDeriveCredentialResponse->DeriveCredInfoLength
                    );

    }


    RtlSecureZeroMemory( pDeriveCredentialResponse->DeriveCredReturnBuffer,
                         pDeriveCredentialResponse->DeriveCredInfoLength
                         );

    LsaIFreeReturnBuffer( pDeriveCredentialResponse );

    return rc;
}


DWORD
QueryDerivedCredential(
    IN OUT  GUID *CredentialID,
    IN      LUID *pLogonId,
    IN      DWORD dwFlags,
    IN      PBYTE pbMixingBytes,
    IN      DWORD cbMixingBytes,
    IN OUT  BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN]
    )
{

    DWORD dwLastError = ERROR_SUCCESS;
    PCREDENTIAL_HISTORY pCurrent = NULL;
    PCREDENTIAL_HISTORY pNext = NULL;
    BYTE rgbCurrentDerivedCredential[A_SHA_DIGEST_LEN];
    BYTE rgbCurrentShaOWF[A_SHA_DIGEST_LEN];
    BYTE rgbCurrentNTOWF[A_SHA_DIGEST_LEN];

    PCREDENTIAL_HISTORY_MAP pHistoryMap= NULL;
    WCHAR wszTextualSid[MAX_PATH + 1];
    WCHAR szProfilePath[MAX_PATH + 1];
    DWORD cchTextualSid = 0;
    BOOL fIsRoot = TRUE;

    //
    // Get path to user's profile data. This will typically look something
    // like "c:\Documents and Settings\<user>\Application Data".
    //

    dwLastError = PRGetProfilePath(NULL,
                                   szProfilePath);

    if( dwLastError != ERROR_SUCCESS )
    {
        D_DebugLog((DEB_TRACE_API, "DPAPIChangePassword returned 0x%x\n", dwLastError));
        return dwLastError;
    }


    //
    // work-around the fact that much of this (new) code is not thread-safe.
    //

    RtlEnterCriticalSection(&g_csCredHistoryCache);

    //
    // Open history file
    //

    dwLastError = OpenCredentialHistoryMap(NULL, szProfilePath, &pHistoryMap, &pCurrent);


    while((ERROR_SUCCESS == dwLastError) &&
          (pCurrent) &&
          (0 == (dwFlags & USE_ROOT_CREDENTIAL)))
    {

        //
        // We're looking for a specific credential ID
        //
        if((NULL != CredentialID) &&
           (0 == memcmp(&pCurrent->Header.CredentialID, CredentialID, sizeof(GUID))))
        {
            // found it,
            break;
        }


        pNext = GetPreviousCredentialHistory(pHistoryMap, pCurrent);

        if(NULL == pNext)
        {
            if(NULL != CredentialID)
            {
                // If we're looking for a specific credential, but
                // couldn't find it, then return an error
                dwLastError = NTE_BAD_KEY;
            }
            else
            {
                // no credential id was specified, so default to the oldest one.
                dwLastError = ERROR_SUCCESS;
            }
            break;
        }


        //
        // get the textual sid
        //
        cchTextualSid = MAX_PATH;

        if(!GetTextualSid((PBYTE)(pNext + 1), wszTextualSid, &cchTextualSid))
        {
            dwLastError = ERROR_INVALID_PARAMETER;
            break;
        }




        if(fIsRoot)
        {
            //
            // crack the next credential using the current
            // credentials
            //
            dwLastError = RetrieveCurrentDerivedCredential(pLogonId,
                                            (0 != (pNext->dwFlags & USE_DPAPI_OWF)), // always use
                                            (PBYTE)wszTextualSid,
                                            cchTextualSid*sizeof(WCHAR),
                                            rgbCurrentDerivedCredential);

            fIsRoot = FALSE;
        }
        else
        {
            //
            // calculate the current derived credential used to decrypt the
            // next credential history structure by using the decrypted OWF
            // from the previous pass

            DeriveWithHMAC_SHA1((0 != (pNext->dwFlags & USE_DPAPI_OWF))?rgbCurrentShaOWF:rgbCurrentNTOWF,
                                A_SHA_DIGEST_LEN,
                                (PBYTE)wszTextualSid,
                                cchTextualSid*sizeof(WCHAR),
                                rgbCurrentDerivedCredential);

            //
            // we don't need the OWF anymore, so zap it.
            //
            RtlSecureZeroMemory(rgbCurrentShaOWF, A_SHA_DIGEST_LEN);
            RtlSecureZeroMemory(rgbCurrentNTOWF, A_SHA_DIGEST_LEN);
        }

        if(ERROR_SUCCESS != dwLastError)
        {
            break;
        }


        //
        // used the derived credential to decrypt
        // the data blob of pNext
        //

        dwLastError = DecryptCredentialHistory(pNext,
                                 rgbCurrentDerivedCredential,
                                 rgbCurrentShaOWF,
                                 rgbCurrentNTOWF);

        if(ERROR_SUCCESS != dwLastError)
        {
            break;
        }

        pCurrent = pNext;
        pNext = NULL;

    }

    if(ERROR_SUCCESS == dwLastError)
    {
        if(fIsRoot)
        {
            //
            // crack the next credential using the current
            // credentials
            //
            dwLastError = RetrieveCurrentDerivedCredential(pLogonId,
                                            (0 != (dwFlags & USE_DPAPI_OWF)),
                                            pbMixingBytes,
                                            cbMixingBytes,
                                            rgbDerivedCredential);

            if(ERROR_SUCCESS == dwLastError)
            {
                if((CredentialID != NULL) &&
                (0 != (dwFlags & USE_ROOT_CREDENTIAL)))
                {
                    CopyMemory(CredentialID, &pCurrent->Header.CredentialID, sizeof(GUID));
                }
            }


        }
        else
        {
            //
            // calculate the current derived credential used to decrypt the
            // next credential history structure by using the decrypted OWF
            // from the previous pass

            DeriveWithHMAC_SHA1((0 != (dwFlags & USE_DPAPI_OWF))?rgbCurrentShaOWF:rgbCurrentNTOWF,
                                A_SHA_DIGEST_LEN,
                                pbMixingBytes,
                                cbMixingBytes,
                                rgbDerivedCredential);
        }
    }


    //
    // Clear out any owf's we may have lying around
    //
    RtlSecureZeroMemory(rgbCurrentShaOWF, A_SHA_DIGEST_LEN);
    RtlSecureZeroMemory(rgbCurrentNTOWF, A_SHA_DIGEST_LEN);


    if(pHistoryMap)
    {
        CloseCredentialHistoryMap(pHistoryMap, TRUE);
    }

    RtlLeaveCriticalSection(&g_csCredHistoryCache);

    return dwLastError;

}


VOID
DeriveWithHMAC_SHA1(
    IN      PBYTE   pbKeyMaterial,              // input key material
    IN      DWORD   cbKeyMaterial,
    IN      PBYTE   pbData,                     // input mixing data
    IN      DWORD   cbData,
    IN OUT  BYTE    rgbHMAC[A_SHA_DIGEST_LEN]   // output buffer
    )
{
    unsigned __int64 rgbKipad[ HMAC_K_PADSIZE/sizeof(unsigned __int64) ];
    unsigned __int64 rgbKopad[ HMAC_K_PADSIZE/sizeof(unsigned __int64) ];
    A_SHA_CTX sSHAHash;
    DWORD dwBlock;

    // truncate
    if( cbKeyMaterial > HMAC_K_PADSIZE )
    {
        cbKeyMaterial = HMAC_K_PADSIZE;
    }

    ZeroMemory(rgbKipad, sizeof(rgbKipad));
    ZeroMemory(rgbKopad, sizeof(rgbKopad));

    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for( dwBlock = 0; dwBlock < (HMAC_K_PADSIZE/sizeof(unsigned __int64)) ; dwBlock++ )
    {
        rgbKipad[dwBlock] ^= 0x3636363636363636;
        rgbKopad[dwBlock] ^= 0x5C5C5C5C5C5C5C5C;
    }

    // prepend Kipad to data, Hash to get H1
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (PBYTE)rgbKipad, sizeof(rgbKipad));
    A_SHAUpdate(&sSHAHash, pbData, cbData);


    // Finish off the hash
    A_SHAFinal(&sSHAHash, rgbHMAC);

    // prepend Kopad to H1, hash to get HMAC
    // note: done in place to avoid buffer copies

    // final hash: output value into passed-in buffer
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (PBYTE)rgbKopad, sizeof(rgbKopad));
    A_SHAUpdate(&sSHAHash, rgbHMAC, A_SHA_DIGEST_LEN);
    A_SHAFinal(&sSHAHash, rgbHMAC);


    RtlSecureZeroMemory( rgbKipad, sizeof(rgbKipad) );
    RtlSecureZeroMemory( rgbKopad, sizeof(rgbKopad) );
    RtlSecureZeroMemory( &sSHAHash, sizeof(sSHAHash) );

    return;
}


DWORD
DecryptCredentialHistory(PCREDENTIAL_HISTORY pCredential,
                         BYTE rgbDecryptingCredential[A_SHA_DIGEST_LEN],
                         BYTE rgbShaOwf[A_SHA_DIGEST_LEN],
                         BYTE rgbNTOwf[A_SHA_DIGEST_LEN])
{

    DWORD   dwLastError = ERROR_SUCCESS;
    DWORD j;
    BYTE rgbSymKey[A_SHA_DIGEST_LEN*2]; // big enough to handle 3des keys

    //
    // Derive the protection key
    //

    for(j=0; j < 2; j++)
    {
        if(!PKCS5DervivePBKDF2( rgbDecryptingCredential,
                            A_SHA_DIGEST_LEN,
                            pCredential->Salt,
                            CREDENTIAL_HISTORY_SALT_SIZE,
                            pCredential->KeyGenAlg,
                            pCredential->cIterationCount,
                            j+1,
                            rgbSymKey + j*A_SHA_DIGEST_LEN))
        {
            dwLastError = ERROR_INVALID_DATA;
            goto cleanup;
        }
    }
    if (CALG_3DES == pCredential->KeyEncrAlg)
    {

        DES3TABLE s3DESKey;
        DWORD iBlock;
        BYTE  ResultBlock[2*A_SHA_DIGEST_LEN+DES_BLOCKLEN ];

        //
        // Round up blocks.  it's assumed that the total block size was verified
        // earlier
        //
        DWORD cBlocks = (pCredential->cbShaOwf + pCredential->cbNtOwf + DES_BLOCKLEN - 1)/DES_BLOCKLEN;
        BYTE feedback[ DES_BLOCKLEN ];
        // initialize 3des key
        //
        if((pCredential->cbShaOwf != A_SHA_DIGEST_LEN) ||
           (pCredential->cbNtOwf != A_SHA_DIGEST_LEN))
        {
            return ERROR_INVALID_PARAMETER;
        }

        tripledes3key(&s3DESKey, rgbSymKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, rgbSymKey + DES3_KEYSIZE, DES_BLOCKLEN);

        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {
            CBC(tripledes,
                DES_BLOCKLEN,
                ResultBlock+iBlock*DES_BLOCKLEN,
                ((PBYTE)(pCredential + 1) + pCredential->cbSid)+iBlock*DES_BLOCKLEN,
                &s3DESKey,
                DECRYPT,
                feedback);
        }
        CopyMemory(rgbShaOwf, ResultBlock, A_SHA_DIGEST_LEN);
        CopyMemory(rgbNTOwf, ResultBlock + A_SHA_DIGEST_LEN, A_SHA_DIGEST_LEN);
        RtlSecureZeroMemory(ResultBlock, sizeof(ResultBlock));

    }
    else
    {
        dwLastError = ERROR_INVALID_DATA;
        goto cleanup;
    }

cleanup:
    return dwLastError;
}



DWORD
EncryptCredentialHistory(BYTE rgbEncryptingCredential[A_SHA_DIGEST_LEN],
                         DWORD dwFlags,
                         BYTE SHAOwfToEncrypt[A_SHA_DIGEST_LEN],
                         BYTE NTOwfToEncrypt[A_SHA_DIGEST_LEN],
                         PCREDENTIAL_HISTORY *ppCredential,
                         DWORD *pcbCredential)
{

    DWORD   dwLastError = ERROR_SUCCESS;
    DWORD j;
    BYTE rgbSymKey[A_SHA_DIGEST_LEN*2]; // big enough to handle 3des keys
    PCREDENTIAL_HISTORY pCred = NULL;
    DWORD               cbCred = 0;
    HANDLE hToken = NULL;
    PSID pSidUser = NULL;
    BYTE ResultBuffer[A_SHA_DIGEST_LEN * 2]; // 2 * A_SHA_DIGEST_LEN

    DWORD cBlocks = 0;
    DWORD cbBlock = 0;



    cbBlock = DES_BLOCKLEN;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
    {
        dwLastError = GetLastError();
        goto error;
    }

    if(!GetTokenUserSid(hToken, &pSidUser))
    {
        dwLastError = GetLastError();
        goto error;
    }


    cBlocks = sizeof(ResultBuffer)/DES_BLOCKLEN;  // this should be 5


    cbCred= sizeof(CREDENTIAL_HISTORY) +
           GetLengthSid(pSidUser) +
           cBlocks*cbBlock;



    pCred = (PCREDENTIAL_HISTORY)LocalAlloc(LMEM_ZEROINIT, cbCred);

    if(NULL == pCred)
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    pCred->dwFlags = dwFlags;



    pCred->KeyGenAlg = DEFAULT_KEY_GEN_ALG;
    pCred->cIterationCount = GetIterationCount();
    pCred->KeyEncrAlg = DEFAULT_ENCRYPTION_ALG;

    pCred->cbShaOwf = A_SHA_DIGEST_LEN;
    pCred->cbNtOwf = A_SHA_DIGEST_LEN;


    pCred->cbSid = GetLengthSid(pSidUser);

    CopyMemory((PBYTE)(pCred+1), (PBYTE)pSidUser, pCred->cbSid);

    if(!RtlGenRandom(pCred->Salt, CREDENTIAL_HISTORY_SALT_SIZE))
    {
        dwLastError = GetLastError();
        goto error;
    }


    for(j=0; j < 2; j++)
    {
        if(!PKCS5DervivePBKDF2( rgbEncryptingCredential,
                            A_SHA_DIGEST_LEN,
                            pCred->Salt,
                            CREDENTIAL_HISTORY_SALT_SIZE,
                            pCred->KeyGenAlg,
                            pCred->cIterationCount,
                            j+1,
                            rgbSymKey + j*A_SHA_DIGEST_LEN))
        {
            dwLastError = ERROR_INVALID_DATA;
            goto error;
        }
    }
    if (CALG_3DES == pCred->KeyEncrAlg)
    {

        DES3TABLE s3DESKey;
        DWORD iBlock;
        BYTE feedback[ DES_BLOCKLEN ];

        // initialize 3des key
        tripledes3key(&s3DESKey, rgbSymKey);

        //
        // IV is derived from the DES_BLOCKLEN bytes of the calculated
        // rgbSymKey, after the 3des key
        CopyMemory(feedback, rgbSymKey + DES3_KEYSIZE, DES_BLOCKLEN);



        CopyMemory(ResultBuffer, SHAOwfToEncrypt, A_SHA_DIGEST_LEN);
        CopyMemory(ResultBuffer+A_SHA_DIGEST_LEN, NTOwfToEncrypt, A_SHA_DIGEST_LEN);

        for(iBlock=0; iBlock < cBlocks; iBlock++)
        {

            CBC(tripledes,
                DES_BLOCKLEN,
                ((PBYTE)(pCred + 1) + pCred->cbSid)+iBlock*DES_BLOCKLEN,
                ResultBuffer + iBlock*DES_BLOCKLEN,
                &s3DESKey,
                ENCRYPT,
                feedback);
        }


        RtlSecureZeroMemory(ResultBuffer, sizeof(ResultBuffer));
    }
    else
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    *ppCredential = pCred;
    *pcbCredential = cbCred;

    pCred = NULL;
error:

    if(pCred)
    {
        LocalFree(pCred);
    }

    if(hToken)
    {
        CloseHandle(hToken);
    }

    if(pSidUser)
    {
        SSFree(pSidUser);
    }

    return dwLastError;
}


#define PRODUCT_ROOT_STRING     L"\\Microsoft\\Protect\\"

#define HISTORY_FILENAME        L"CREDHIST"

DWORD
CreateCredentialHistoryMap(
    HANDLE hUserToken,
    LPWSTR pszProfilePath,
    PCREDENTIAL_HISTORY_MAP *ppMap,
    BOOL fRead)
{
    PCREDENTIAL_HISTORY_MAP pMap = NULL;

    PCREDENTIAL_HISTORY_MAP pCached = NULL;

    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwHighFileSize = 0;

    DWORD cbUserStorageRoot;
    HANDLE hTemporaryMapping = NULL;

    WCHAR szFilePath[MAX_PATH + 1];
    PWSTR pszCreationStartPoint;

    NTSTATUS Status;

    if(NULL == ppMap)
    {
        return ERROR_INVALID_PARAMETER;
    }


    pMap = (PCREDENTIAL_HISTORY_MAP)LocalAlloc(LPTR, sizeof(CREDENTIAL_HISTORY_MAP));
    if(NULL == pMap)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Obtain the user's SID.
    //

    if(hUserToken)
    {
        if(!GetTokenUserSid(hUserToken, &pMap->pUserSid))
        {
            dwError = GetLastError();
            goto error;
        }
    }
    else
    {
        HANDLE hToken;

        if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
        {
            dwError = ERROR_NO_TOKEN;
            goto error;
        }

        if(!GetTokenUserSid(hToken, &pMap->pUserSid))
        {
            dwError = GetLastError();
            CloseHandle(hToken);
            goto error;
        }

        CloseHandle(hToken);
    }


    //
    // Open map file
    //

    if(wcslen(pszProfilePath) + wcslen(PRODUCT_ROOT_STRING) + wcslen(HISTORY_FILENAME) > MAX_PATH)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    wcscpy(szFilePath, pszProfilePath);


    // Build the path in a separate buffer just in case we have to create
    // the directory.
    pszCreationStartPoint = szFilePath + wcslen(szFilePath) + sizeof(WCHAR);
    wcscat(szFilePath, PRODUCT_ROOT_STRING);

    // Copy the path plus the filename over to the map structure.
    wcscpy(pMap->wszFilePath, szFilePath);
    wcscat(pMap->wszFilePath, HISTORY_FILENAME);


    //
    // Create the history file.
    //

    dwError = ERROR_SUCCESS;

    while(TRUE)
    {
        pMap->hHistoryFile = CreateFileWithRetries(
                    pMap->wszFilePath,
                    GENERIC_READ | GENERIC_WRITE,
                    0,  // cannot share this file when open
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_HIDDEN |
                    FILE_ATTRIBUTE_SYSTEM |
                    FILE_FLAG_RANDOM_ACCESS,
                    NULL
                    );

        if(INVALID_HANDLE_VALUE == pMap->hHistoryFile)
        {
            dwError = GetLastError();

            if(dwError == ERROR_PATH_NOT_FOUND)
            {
                // Create the DPAPI directory, and then try to create the file
                // again.
                Status = DPAPICreateNestedDirectories(szFilePath,
                                                      pszCreationStartPoint);

                if(!NT_SUCCESS(Status))
                {
                    goto error;
                }

                dwError = ERROR_SUCCESS;
                continue;
            }
            else
            {
                goto error;
            }
        }

        break;
    }

    

    pMap->dwMapSize = GetFileSize(pMap->hHistoryFile, &dwHighFileSize);

    if((-1 == pMap->dwMapSize) ||
       (dwHighFileSize != 0))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }


    //
    // If this map is too small, we need to create a new header
    //
    if(pMap->dwMapSize < sizeof(CREDENTIAL_HISTORY_HEADER))
    {

        PCREDENTIAL_HISTORY_HEADER pHeader = NULL;

        pMap->dwMapSize = sizeof(CREDENTIAL_HISTORY_HEADER);

        hTemporaryMapping = CreateFileMapping(pMap->hHistoryFile,
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       pMap->dwMapSize,
                                       NULL);

        if(NULL == hTemporaryMapping)
        {
            dwError = GetLastError();
            goto error;
        }

        pHeader = (PCREDENTIAL_HISTORY_HEADER)(PBYTE)MapViewOfFile(hTemporaryMapping,
                                   FILE_MAP_WRITE,
                                   0,
                                   0,
                                   0);

        if(NULL == pHeader)
        {
            dwError = GetLastError();
            goto error;
        }


        //
        // Write a fresh header into the cred history file
        //
        pHeader->dwPreviousCredOffset = 0;
        pHeader->dwVersion = CREDENTIAL_HISTORY_VERSION;
        dwError = UuidCreate( &pHeader->CredentialID );

        FlushViewOfFile(pHeader, pMap->dwMapSize);

        UnmapViewOfFile(pHeader);

        if(ERROR_SUCCESS != dwError)
        {
            goto error;
        }
    }

    *ppMap = pMap;
    pMap = NULL;


error:

    if(pMap)
    {
        DestroyCredentialHistoryMap(pMap);
    }

    if(hTemporaryMapping)
    {
        CloseHandle(hTemporaryMapping);
    }

    return dwError;
}


DWORD
OpenCredentialHistoryMap(
    HANDLE hUserToken,
    LPWSTR pszProfilePath,
    PCREDENTIAL_HISTORY_MAP *ppMap,
    PCREDENTIAL_HISTORY *ppCurrent)
{
    PCREDENTIAL_HISTORY_MAP pMap = NULL;
    PCREDENTIAL_HISTORY pCurrent = NULL;
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   dwHighFileSize = 0;

    WCHAR szFilePath[MAX_PATH+1];
    DWORD cbUserStorageRoot;
    HANDLE hTemporaryMapping = NULL;



    if((NULL == ppMap) ||
       (NULL == ppCurrent))
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwError = CreateCredentialHistoryMap(
                        hUserToken,
                        pszProfilePath,
                        &pMap,
                        TRUE);

    if(ERROR_SUCCESS != dwError)
    {
        goto error;
    }

    if(NULL == pMap->hMapping)
    {
        //
        // Open a read-only mapping of the file
        //
        pMap->hMapping = CreateFileMapping(pMap->hHistoryFile,
                                           NULL,
                                           PAGE_READONLY,
                                           dwHighFileSize,
                                           pMap->dwMapSize,
                                           NULL);

        if(NULL == pMap->hMapping)
        {
            dwError = GetLastError();
            goto error;
        }
    }


    if(NULL == pMap->pMapping)
    {

        pMap->pMapping = (PBYTE)MapViewOfFile(pMap->hMapping,
                                       FILE_MAP_READ,
                                       0,
                                       0,
                                       0);

        if(NULL == pMap->pMapping)
        {
            dwError = GetLastError();
            goto error;
        }
    }

    pCurrent = GetPreviousCredentialHistory(pMap, NULL);

    if(NULL == pCurrent)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto error;
    }

    *ppMap = pMap;
    pMap = NULL;

    *ppCurrent = pCurrent;


error:


    if(pMap)
    {
        CloseCredentialHistoryMap(pMap, TRUE);
    }

    return dwError;
}

PCREDENTIAL_HISTORY
GetPreviousCredentialHistory(
                             PCREDENTIAL_HISTORY_MAP pMap,
                             PCREDENTIAL_HISTORY pCurrent
                             )
{
    PCREDENTIAL_HISTORY pPrevious = NULL;
    DWORD cbSize = 0;

    if((NULL == pMap) ||
       (NULL == pMap->pMapping))
    {
        return NULL;
    }

    if(pMap->dwMapSize < sizeof(CREDENTIAL_HISTORY_HEADER))
    {
        return NULL;
    }

    if(NULL == pCurrent)
    {
        pPrevious = (PCREDENTIAL_HISTORY)((PBYTE)pMap->pMapping +
                                         pMap->dwMapSize - sizeof(CREDENTIAL_HISTORY_HEADER));
    }
    else
    {
        if(((PBYTE)pCurrent < pMap->pMapping) ||
            ((PBYTE)pCurrent - pMap->pMapping >= (__int64)pMap->dwMapSize) ||
           ((PBYTE)pCurrent - pMap->pMapping < (__int64)pCurrent->Header.dwPreviousCredOffset))
        {
            return NULL;
        }

        pPrevious = (PCREDENTIAL_HISTORY)((PBYTE)pCurrent - pCurrent->Header.dwPreviousCredOffset);

        cbSize = sizeof(CREDENTIAL_HISTORY) + pPrevious->cbSid;

        if(cbSize > pCurrent->Header.dwPreviousCredOffset)
        {
            return NULL;
        }
        cbSize = pCurrent->Header.dwPreviousCredOffset - cbSize;
        if(cbSize < pPrevious->cbShaOwf + pPrevious->cbNtOwf)
        {
            return NULL;
        }
        if(cbSize % DES_BLOCKLEN)
        {
            return NULL;
        }
        if(!IsValidSid((PSID)(pPrevious+1)))
        {
            return NULL;
        }
        if(GetLengthSid((PSID)(pPrevious+1)) != pPrevious->cbSid)
        {
            return NULL;
        }
    }

    // validate found credential history
    if(pPrevious->Header.dwVersion != CREDENTIAL_HISTORY_VERSION)
    {
        return NULL;
    }

    return pPrevious;
}

DWORD
DestroyCredentialHistoryMap(PCREDENTIAL_HISTORY_MAP pMap)
{
    if(NULL == pMap)
    {
        return ERROR_SUCCESS;
    }

    if (pMap->pUserSid) 
    {
        SSFree(pMap->pUserSid);
        pMap->pUserSid = NULL;
    }

    if(pMap->pMapping)
    {
        UnmapViewOfFile(pMap->pMapping);
        pMap->pMapping = NULL;
    }

    if(pMap->hMapping)
    {
        CloseHandle(pMap->hMapping);
        pMap->hMapping = NULL;
    }


    if(pMap->hHistoryFile)
    {
        CloseHandle(pMap->hHistoryFile);
        pMap->hHistoryFile = NULL;
    }
    LocalFree(pMap);

    return ERROR_SUCCESS;
}


DWORD
CloseCredentialHistoryMap(PCREDENTIAL_HISTORY_MAP pMap, BOOL fReader)
{
    if(NULL == pMap)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(pMap->pMapping)
    {
        UnmapViewOfFile(pMap->pMapping);
        pMap->pMapping = NULL;
    }

    if(pMap->hMapping)
    {
        CloseHandle(pMap->hMapping);
        pMap->hMapping = NULL;
    }


    if(pMap->hHistoryFile)
    {
        CloseHandle(pMap->hHistoryFile);
        pMap->hHistoryFile = NULL;
    }
    return DestroyCredentialHistoryMap(pMap);
}



DWORD
AppendCredentialHistoryMap(
                         PCREDENTIAL_HISTORY_MAP pMap,
                         PCREDENTIAL_HISTORY pCredHistory,
                         DWORD               cbCredHistory
                         )
{
    DWORD   dwLastError = ERROR_SUCCESS;
    DWORD   dwHighFileSize = 0;
    DWORD   dwLowFileSize = 0;

    HANDLE  hWriteMapping = NULL;
    LPVOID  pWriteMapping = NULL;
    PCREDENTIAL_HISTORY_HEADER pHeader = NULL;



    if((NULL == pCredHistory) ||
       (NULL == pMap))
    {
        return ERROR_INVALID_PARAMETER;
    }


    dwLowFileSize = pMap->dwMapSize + cbCredHistory;

    if(dwLowFileSize < pMap->dwMapSize)
    {
        //we wrapped, so fail.

        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    // Create a new mapping


    hWriteMapping = CreateFileMapping(pMap->hHistoryFile,
                                   NULL,
                                   PAGE_READWRITE,
                                   0,
                                   dwLowFileSize,
                                   NULL);
    if(NULL == hWriteMapping)
    {
        dwLastError = GetLastError();
        goto error;
    }

    pWriteMapping = (PCREDENTIAL_HISTORY_HEADER)(PBYTE)MapViewOfFile(hWriteMapping,
                               FILE_MAP_WRITE,
                               0,
                               0,
                               dwLowFileSize);

    if(NULL == pWriteMapping)
    {
        dwLastError = GetLastError();
        goto error;
    }

    //
    // Append the rest of the current entry
    //
    CopyMemory((PBYTE)pWriteMapping + pMap->dwMapSize,
               (PBYTE)pCredHistory + sizeof(CREDENTIAL_HISTORY_HEADER),
               cbCredHistory - sizeof(CREDENTIAL_HISTORY_HEADER));


    pHeader = (PCREDENTIAL_HISTORY_HEADER)((PBYTE)pWriteMapping +
                                                   pMap->dwMapSize +
                                                   cbCredHistory -
                                                   sizeof(CREDENTIAL_HISTORY_HEADER));


    //
    // Write a fresh header into the cred history file
    //
    pHeader->dwPreviousCredOffset = cbCredHistory;
    pHeader->dwVersion = CREDENTIAL_HISTORY_VERSION;
    dwLastError = UuidCreate( &pHeader->CredentialID );

    pMap->dwMapSize = dwLowFileSize;

    //
    // Flush and close write mapping
    //

    if(ERROR_SUCCESS == dwLastError)
    {
        if(!FlushViewOfFile(pWriteMapping, pMap->dwMapSize))
        {
            dwLastError = GetLastError();
        }
    }

    UnmapViewOfFile(pWriteMapping);

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }

    CloseHandle(hWriteMapping);
    hWriteMapping = NULL;






    // Remap the read mapping to bump up the size

    if(pMap->pMapping)
    {
        UnmapViewOfFile(pMap->pMapping);
        pMap->pMapping = NULL;
    }



    if(pMap->hMapping)
    {
        CloseHandle(pMap->hMapping);
        pMap->hMapping = NULL;
    }



    pMap->hMapping = CreateFileMapping(pMap->hHistoryFile,
                                       NULL,
                                       PAGE_READONLY,
                                       dwHighFileSize,
                                       pMap->dwMapSize,
                                       NULL);

    if(NULL == pMap->hMapping)
    {
        dwLastError = GetLastError();
        goto error;
    }

    pMap->pMapping = (PBYTE)MapViewOfFile(pMap->hMapping,
                                   FILE_MAP_READ,
                                   0,
                                   0,
                                   0);

    if(NULL == pMap->pMapping)
    {
        dwLastError = GetLastError();
        goto error;
    }


error:

    if(hWriteMapping)
    {
        CloseHandle(hWriteMapping);
    }

    return dwLastError;
}


DWORD
DPAPIChangePassword(
    HANDLE hUserToken,
    BYTE OldPasswordShaOWF[A_SHA_DIGEST_LEN],
    BYTE OldPasswordNTOWF[A_SHA_DIGEST_LEN],
    BYTE NewPasswordOWF[A_SHA_DIGEST_LEN])
{
    DWORD   dwLastError = ERROR_SUCCESS;

    PCREDENTIAL_HISTORY_MAP pMap = NULL;
    PCREDENTIAL_HISTORY pHistory = NULL;

    DWORD cbHistory = 0;
    WCHAR wszUserSid[MAX_PATH+1];
    DWORD cchUserSid = 0;
    BYTE NewEncryptingCred[A_SHA_DIGEST_LEN];
    WCHAR szProfilePath[MAX_PATH + 1];

    HANDLE hOldUser = NULL;

    D_DebugLog((DEB_TRACE_API, "DPAPIChangePassword\n"));


    //
    // Get path to user's profile data. This will typically look something
    // like "c:\Documents and Settings\<user>\Application Data".
    //

    dwLastError = PRGetProfilePath(hUserToken,
                                   szProfilePath);

    if( dwLastError != ERROR_SUCCESS )
    {
        D_DebugLog((DEB_TRACE_API, "DPAPIChangePassword returned 0x%x\n", dwLastError));
        return dwLastError;
    }


    //
    // work-around the fact that much of this (new) code is not thread-safe.
    //

    RtlEnterCriticalSection(&g_csCredHistoryCache);


    dwLastError = CreateCredentialHistoryMap(
                     hUserToken,
                     szProfilePath,
                     &pMap,
                     FALSE);

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }


    //
    // Get textual SID of user.
    //

    cchUserSid = MAX_PATH;

    if(!GetUserTextualSid(hUserToken,
                          wszUserSid,
                          &cchUserSid))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }


    //
    // Encrypt the credential history goo.
    //

    if(hUserToken)
    {
        if(!OpenThreadToken(GetCurrentThread(), 
                        TOKEN_IMPERSONATE | TOKEN_READ,
                        TRUE, 
                        &hOldUser)) 
        {
            hOldUser = NULL;
        }

        if(!ImpersonateLoggedOnUser(hUserToken))
        {
            dwLastError = GetLastError();
            goto error;
        }
    }

    DeriveWithHMAC_SHA1(NewPasswordOWF,
                        A_SHA_DIGEST_LEN,
                        (PBYTE)wszUserSid,
                        cchUserSid*sizeof(WCHAR),
                        NewEncryptingCred);


    dwLastError = EncryptCredentialHistory(NewEncryptingCred,
                                           USE_DPAPI_OWF,
                                           OldPasswordShaOWF,
                                           OldPasswordNTOWF,
                                           &pHistory,
                                           &cbHistory);

    if(hOldUser)
    {
        //
        // This code probably never gets executed. hOldUser should be NULL, as this routine
        // looks like called in the SYSTEM context.
        // Even if the hOldUser is not NULL, the failure of SetThreadToken should no prevent
        // continue execution of this routine. Let's ignore the return value of SetThreadToken
        // here.
        //

        (void) SetThreadToken(NULL, hOldUser);
    }

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }


    //
    // Update the CREDHIST file.
    //

    dwLastError = AppendCredentialHistoryMap(pMap, pHistory, cbHistory);
    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }


error:

    if(hOldUser)
    {
        CloseHandle(hOldUser);
        hOldUser = NULL;
    }

    if(pMap)
    {
        CloseCredentialHistoryMap(pMap, FALSE);
    }

    RtlLeaveCriticalSection(&g_csCredHistoryCache);

    if(pHistory)
    {
        RtlSecureZeroMemory(pHistory, cbHistory);
        LocalFree(pHistory);
    }
    RtlSecureZeroMemory(NewEncryptingCred, A_SHA_DIGEST_LEN);

    D_DebugLog((DEB_TRACE_API, "DPAPIChangePassword returned 0x%x\n", dwLastError));

    return dwLastError;
}






#define SIGNATURE_SALT_SIZE (16)
#define CRED_SIGNATURE_VERSION 1


typedef struct _CRED_SIGNATURE
{
    DWORD dwVersion;
    GUID  CredentialID;
    DWORD cIterations;
    BYTE  Salt[SIGNATURE_SALT_SIZE];
    DWORD cbSid;
    DWORD cbSignature;
} CRED_SIGNATURE, *PCRED_SIGNATURE;


DWORD
LogonCredGenerateSignatureKey(
                  IN LUID  *pLogonId,
                  IN DWORD dwFlags,
                  IN PBYTE pbCurrentOWF,
                  IN PCRED_SIGNATURE pSignature,
                  OUT BYTE rgbSignatureKey[A_SHA_DIGEST_LEN])
{
    DWORD dwLastError = ERROR_SUCCESS;
    BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN];

    D_DebugLog((DEB_TRACE_API, "LogonCredGenerateSignatureKey\n"));

    if(NULL == pbCurrentOWF)
    {
        dwLastError = QueryDerivedCredential(&pSignature->CredentialID,
                                            pLogonId,
                                            dwFlags,
                                            (PBYTE)(pSignature+1),
                                            pSignature->cbSid,
                                            rgbDerivedCredential);

        if(ERROR_SUCCESS != dwLastError)
        {
            goto error;
        }
    }
    else
    {
//        D_DebugLog((DEB_TRACE_BUFFERS, "Input CurrentOWF:\n"));
//        D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", pbCurrentOWF, A_SHA_DIGEST_LEN);

        DeriveWithHMAC_SHA1(pbCurrentOWF,
                            A_SHA_DIGEST_LEN,
                            (PBYTE)(pSignature+1),
                            pSignature->cbSid,
                            rgbDerivedCredential);


        if(dwFlags & USE_ROOT_CREDENTIAL)
        {
            ZeroMemory(&pSignature->CredentialID, sizeof(GUID));
        }

    }

//    D_DebugLog((DEB_TRACE_BUFFERS, "Computed DerivedCredential:\n"));
//    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", rgbDerivedCredential, sizeof(rgbDerivedCredential));

    if(!PKCS5DervivePBKDF2( rgbDerivedCredential,
                        A_SHA_DIGEST_LEN,
                        pSignature->Salt,
                        SIGNATURE_SALT_SIZE,
                        CALG_HMAC,
                        pSignature->cIterations,
                        1,
                        rgbSignatureKey))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

//    D_DebugLog((DEB_TRACE_BUFFERS, "Computed SignatureKey:\n"));
//    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", rgbSignatureKey, A_SHA_DIGEST_LEN);

error:

    RtlSecureZeroMemory(rgbDerivedCredential, A_SHA_DIGEST_LEN);

    D_DebugLog((DEB_TRACE_API, "LogonCredGenerateSignatureKey returned 0x%x\n", dwLastError));

    return dwLastError;
}


DWORD
LogonCredGenerateSignature(
    IN HANDLE hUserToken,
    IN PBYTE pbData,
    IN DWORD cbData,
    IN  PBYTE pbCurrentOWF,
    OUT PBYTE *ppbSignature,
    OUT DWORD *pcbSignature)
{

    DWORD dwLastError = ERROR_SUCCESS;
    LUID LogonId;

    PCRED_SIGNATURE pSignature = NULL;
    DWORD           cbSignature = 0;
    BYTE            rgbSignatureKey[A_SHA_DIGEST_LEN];
    PSID            pUserSid = NULL;

    D_DebugLog((DEB_TRACE_API, "LogonCredGenerateSignature\n"));

    cbSignature = sizeof(CRED_SIGNATURE);

    if(!GetTokenAuthenticationId(hUserToken, &LogonId))
    {
        dwLastError = GetLastError();
        goto error;
    }

    if(!GetTokenUserSid(hUserToken, &pUserSid))
    {
        dwLastError = GetLastError();
        goto error;
    }

    D_DebugLog((DEB_TRACE_BUFFERS, "User SID:\n"));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", (PBYTE)pUserSid, GetLengthSid(pUserSid));

    cbSignature += GetLengthSid(pUserSid);

    cbSignature += A_SHA_DIGEST_LEN;

    pSignature = (PCRED_SIGNATURE)LocalAlloc(LMEM_ZEROINIT, cbSignature);

    if(NULL == pSignature)
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    pSignature->cIterations = GetIterationCount();


    pSignature->dwVersion = CRED_SIGNATURE_VERSION;

    pSignature->cbSid = GetLengthSid(pUserSid);


    pSignature->cbSignature = A_SHA_DIGEST_LEN;

    CopyMemory((PBYTE)(pSignature+1),
                      pUserSid,
                      pSignature->cbSid);

    if(!RtlGenRandom(pSignature->Salt, SIGNATURE_SALT_SIZE))
    {
        dwLastError = GetLastError();
        goto error;
    }

//    D_DebugLog((DEB_TRACE_BUFFERS, "Generated Salt:\n"));
//    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", pSignature->Salt, SIGNATURE_SALT_SIZE);


    dwLastError = LogonCredGenerateSignatureKey(&LogonId,
                                                USE_ROOT_CREDENTIAL | USE_DPAPI_OWF,
                                                pbCurrentOWF,
                                                pSignature,
                                                rgbSignatureKey);

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }

    if(!FMyPrimitiveHMACParam(
                              rgbSignatureKey,
                              A_SHA_DIGEST_LEN,
                              pbData,
                              cbData,
                              (PBYTE)(pSignature+1) + pSignature->cbSid))
    {
        dwLastError = ERROR_INVALID_DATA;
    }
    else
    {
        D_DebugLog((DEB_TRACE_BUFFERS, "Computed Signature:\n"));
        D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", (PBYTE)(pSignature+1) + pSignature->cbSid, A_SHA_DIGEST_LEN);

        *ppbSignature = (PBYTE)pSignature;
        *pcbSignature = cbSignature;
        pSignature = NULL;

    }

error:

    if(pSignature)
    {
        RtlSecureZeroMemory(pSignature, cbSignature);
        LocalFree(pSignature);
    }

    if(pUserSid)
    {
        SSFree(pUserSid);
    }

    D_DebugLog((DEB_TRACE_API, "LogonCredGenerateSignature returned 0x%x\n", dwLastError));

    return dwLastError;
}


DWORD
LogonCredVerifySignature(
    IN HANDLE hUserToken,       // optional
    IN PBYTE pbData,
    IN DWORD cbData,
    IN PBYTE pbCurrentOWF,
    IN PBYTE pbSignature,
    IN DWORD cbSignature)
{
    DWORD dwLastError = ERROR_SUCCESS;
    LUID LogonId;
    HANDLE hOldUser = NULL;
    BOOL fIsMember = FALSE;

    PCRED_SIGNATURE pSignature = (PCRED_SIGNATURE)pbSignature;

    BYTE            rgbSignatureKey[A_SHA_DIGEST_LEN];
    BYTE            rgbSignatureHash[A_SHA_DIGEST_LEN];
    PSID            pUserSid = NULL;

    D_DebugLog((DEB_TRACE_API, "LogonCredVerifySignature\n"));

    if(hUserToken)
    {
        if(!OpenThreadToken(GetCurrentThread(), 
                        TOKEN_IMPERSONATE | TOKEN_READ,
                        TRUE, 
                        &hOldUser)) 
        {
            hOldUser = NULL;
        }

        if(!ImpersonateLoggedOnUser(hUserToken))
        {
            dwLastError = GetLastError();
            goto error;
        }
    }


    if(!GetThreadAuthenticationId(GetCurrentThread(), &LogonId))
    {
        dwLastError = GetLastError();
        goto error;
    }



    //
    // Verify passed in credential
    //
    if((NULL == pSignature) ||
       (sizeof(CRED_SIGNATURE) > cbSignature) ||
       (pSignature->dwVersion != CRED_SIGNATURE_VERSION) ||
       (pSignature->cbSid + pSignature->cbSignature + sizeof(CRED_SIGNATURE) > cbSignature) ||
       (pSignature->cbSignature != A_SHA_DIGEST_LEN))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    if(!IsValidSid((PSID)(pSignature+1)))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    if(pSignature->cbSid != GetLengthSid((PSID)(pSignature+1)))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    D_DebugLog((DEB_TRACE_BUFFERS, "User SID:\n"));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", (PBYTE)(pSignature+1), pSignature->cbSid);

    if(!CheckTokenMembership( NULL,
                              (PSID)(pSignature+1),
                              &fIsMember ))
    {
        dwLastError = GetLastError();
        goto error;
    }


    if(!fIsMember)
    {
        dwLastError = ERROR_INVALID_ACCESS;
        goto error;
    }

    dwLastError = LogonCredGenerateSignatureKey(&LogonId,
                                                USE_DPAPI_OWF,
                                                pbCurrentOWF,
                                                pSignature,
                                                rgbSignatureKey);

    if(ERROR_SUCCESS != dwLastError)
    {
        goto error;
    }

    if(!FMyPrimitiveHMACParam(
                              rgbSignatureKey,
                              A_SHA_DIGEST_LEN,
                              pbData,
                              cbData,
                              rgbSignatureHash))
    {
        dwLastError = ERROR_INVALID_DATA;
        goto error;
    }

    D_DebugLog((DEB_TRACE_BUFFERS, "Computed Signature:\n"));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", rgbSignatureHash, A_SHA_DIGEST_LEN);

    D_DebugLog((DEB_TRACE_BUFFERS, "Input Signature:\n"));
    D_DPAPIDumpHexData(DEB_TRACE_BUFFERS, "  ", (PBYTE)(pSignature+1) + pSignature->cbSid, pSignature->cbSignature);

    if(0 != memcmp(rgbSignatureHash, (PBYTE)(pSignature+1) + pSignature->cbSid, pSignature->cbSignature))
    {
        D_DebugLog((DEB_ERROR, "LogonCredVerifySignature: signature did not verify!\n"));
        dwLastError = ERROR_INVALID_ACCESS;
        goto error;
    }


error:

    if(hOldUser)
    {
        //
        // We have already done our job. SetThreadToken failure should be ignored here.
        // Further, this code might never been executed. LogonCredVerifySignature() is called
        // from two places. If hUserToken==NULL, -> hOldUser = NULL (the thread was impersonating)
        // If hUserToken != NULL, the caller is in SYSTEM, OpenThreadToken would fail -> hOldUser == NULL.
        // Either way, hOldUser should be NULL.
        //

        (void) SetThreadToken(NULL, hOldUser);
        CloseHandle(hOldUser);
    }

    D_DebugLog((DEB_TRACE_API, "LogonCredVerifySignature returned 0x%x\n", dwLastError));

    return dwLastError;
}


DWORD
DPAPINotifyPasswordChange(
    IN PUNICODE_STRING NetbiosDomainName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword)
{
    DWORD Status = ERROR_SUCCESS;
    BYTE OldPasswordShaOWF[A_SHA_DIGEST_LEN];
    BYTE OldPasswordNTOWF[A_SHA_DIGEST_LEN];
    BYTE NewPasswordOWF[A_SHA_DIGEST_LEN];
    HANDLE hThreadToken = NULL;
    HANDLE hUserToken = NULL;

    PWSTR pszTargetName = NULL;
    PWSTR pszCurrentName = NULL;
    DWORD cchCurrentName;

    PSID pUserSid = NULL;
    PSID pCurrentSid = NULL;
    DWORD cbSid;
    SID_NAME_USE SidType; 
    PWSTR pszDomainName = NULL;
    DWORD cchDomainName;
    BOOL fSameUser = FALSE;
    BOOL fLocalAccount = FALSE;
    PROFILEINFOW ProfileInfo;
    BOOL fProfileLoaded = FALSE;

    D_DebugLog((DEB_TRACE_API, "DPAPINotifyPasswordChange\n"));

    //
    // Validate input parameters.
    //

    if((NetbiosDomainName == NULL) ||
       (UserName    == NULL) ||
       (NewPassword == NULL))
    {
        Status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if(NetbiosDomainName->Buffer)
    {
        D_DebugLog((DEB_TRACE_API, "  Domain:%ls\n", NetbiosDomainName->Buffer));
    }
    if(UserName->Buffer)
    {
        D_DebugLog((DEB_TRACE_API, "  Username:%ls\n", UserName->Buffer));
    }

#ifdef COMPILED_BY_DEVELOPER
    if(OldPassword)
    {
        D_DebugLog((DEB_TRACE_API, "  Old password:%ls\n", OldPassword->Buffer));
    }
    D_DebugLog((DEB_TRACE_API, "  New password:%ls\n", NewPassword->Buffer));
#endif


    //
    // Save off the token for the current thread, and revert back to the 
    // local system account.
    // 

    if(!OpenThreadToken(GetCurrentThread(), 
                        TOKEN_QUERY | TOKEN_IMPERSONATE, 
                        FALSE, 
                        &hThreadToken))
    {
        hThreadToken = NULL;
    }

    RevertToSelf();


    //
    // Get SID of user whose password is being changed.
    //

    cbSid = 0;

    if(!LookupAccountName(NetbiosDomainName->Buffer,
                          UserName->Buffer,
                          NULL,
                          &cbSid,
                          NULL,
                          &cchDomainName,
                          &SidType))
    {
        Status = GetLastError();

        if(Status != ERROR_INSUFFICIENT_BUFFER)
        {
            goto cleanup;
        }
    }

    pUserSid = LocalAlloc(LPTR, cbSid);
    if(pUserSid == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    pszDomainName = (PWSTR)LocalAlloc(LPTR, cchDomainName * sizeof(WCHAR));
    if(pszDomainName == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if(!LookupAccountName(NetbiosDomainName->Buffer,
                          UserName->Buffer,
                          pUserSid,
                          &cbSid,
                          pszDomainName,
                          &cchDomainName,
                          &SidType))
    {
        Status = GetLastError();

        if(Status != ERROR_INSUFFICIENT_BUFFER)
        {
            goto cleanup;
        }
    }


    //
    // Determine if we're already logged on as the user whose password
    // is being changed. If we are, then we can skip loading the user
    // profile, etc.
    //

    if(hThreadToken != NULL)
    {
        if(!GetTokenUserSid(hThreadToken, &pCurrentSid))
        {
            Status = GetLastError();
            goto cleanup;
        }

        if(EqualSid(pCurrentSid, pUserSid))
        {
            fSameUser = TRUE;
        }
    }


    //
    // Create logon token for user whose password is being changed.
    //

    if(fSameUser)
    {
        hUserToken = hThreadToken;
    }
    else
    {
        D_DebugLog((DEB_TRACE, "Logging on as user whose password is being changed.\n"));

        if(!LogonUser(UserName->Buffer, 
                      NetbiosDomainName->Buffer, 
                      NewPassword->Buffer, 
                      LOGON32_LOGON_INTERACTIVE,
                      LOGON32_PROVIDER_DEFAULT, 
                      &hUserToken))
        {
            Status = GetLastError();
            D_DebugLog((DEB_ERROR, "Unable to log on as user whose password is being changed (0x%x).\n", Status));
            goto cleanup;
        }

        memset(&ProfileInfo, 0, sizeof(ProfileInfo));
        ProfileInfo.dwSize = sizeof(ProfileInfo);
        ProfileInfo.dwFlags = PI_NOUI;
        ProfileInfo.lpUserName = UserName->Buffer;

        if(!LoadUserProfileW(hUserToken, &ProfileInfo))
        {
            Status = GetLastError();
            D_DebugLog((DEB_ERROR, "Error loading user profile (0x%x).\n", Status));
            goto cleanup;
        }

        fProfileLoaded = TRUE;
    }
    

    //
    // Is this a local account?
    //

    if(NetbiosDomainName->Buffer)
    {
        WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD cchMachineName;

        cchMachineName = MAX_COMPUTERNAME_LENGTH + 1;

        if(!GetComputerName(szMachineName, &cchMachineName))
        {
            Status = GetLastError();
            goto cleanup;
        }

        if (CSTR_EQUAL == CompareString(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                NetbiosDomainName->Buffer,
                -1,             // cchCount1
                szMachineName,
                -1              // cchCount2
                ))
        {
            fLocalAccount = TRUE;
        }
    }


    if(fLocalAccount)
    {
        D_DebugLog((DEB_TRACE, "Local account\n"));

        if(OldPassword == NULL)
        {
            Status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        //
        // Compute hashes of old and new passwords.
        //

        ZeroMemory(OldPasswordShaOWF, A_SHA_DIGEST_LEN);
        ZeroMemory(OldPasswordNTOWF,  A_SHA_DIGEST_LEN);
        ZeroMemory(NewPasswordOWF,    A_SHA_DIGEST_LEN);

        FMyPrimitiveSHA(
                (PBYTE)OldPassword->Buffer,
                OldPassword->Length,
                OldPasswordShaOWF);

        Status = RtlCalculateNtOwfPassword( 
                        OldPassword,
                        (PLM_OWF_PASSWORD)OldPasswordNTOWF);

        if(Status != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        FMyPrimitiveSHA(
                (PBYTE)NewPassword->Buffer,
                NewPassword->Length,
                NewPasswordOWF);

        #ifdef COMPILED_BY_DEVELOPER
        D_DebugLog((DEB_TRACE, "  Old password SHA OWF:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "  ", OldPasswordShaOWF, A_SHA_DIGEST_LEN);
        D_DebugLog((DEB_TRACE, "  Old password NT OWF:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "  ", OldPasswordNTOWF, A_SHA_DIGEST_LEN);
        D_DebugLog((DEB_TRACE, "  New password SHA OWF:\n"));
        D_DPAPIDumpHexData(DEB_TRACE, "  ", NewPasswordOWF, A_SHA_DIGEST_LEN);
        #endif


        //
        // Encrypt the CREDHIST file with the new password and append the new password to
        // the end of the file.
        //
    
        Status = DPAPIChangePassword(hUserToken,
                                     OldPasswordShaOWF, 
                                     OldPasswordNTOWF, 
                                     NewPasswordOWF);

        if(Status != ERROR_SUCCESS)
        {
            goto cleanup;
        }


        //
        // Re-synchronize the master keys.
        //

        DPAPISynchronizeMasterKeys(hUserToken);


        //
        // Encrypt the new password with the recovery public key, and store it
        // in the RECOVERY file. This will allow us to recover the password using the
        // recovery floppy, should the user forget it.
        //

        Status = RecoverChangePasswordNotify(hUserToken,
                                             OldPasswordShaOWF,
                                             NewPassword);
        if(Status != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
    else
    {
        D_DebugLog((DEB_TRACE, "Domain account\n"));

        //
        // Re-synchronize the master keys.
        //

        DPAPISynchronizeMasterKeys(hUserToken);
    }


cleanup:

    if(pUserSid) LocalFree(pUserSid);
    if(pCurrentSid) LocalFree(pCurrentSid);
    if(pszDomainName) LocalFree(pszDomainName);

    if(pszTargetName) LocalFree(pszTargetName);
    if(pszCurrentName) LocalFree(pszCurrentName);

    if(hUserToken && fProfileLoaded)
    {
        UnloadUserProfile(hUserToken, ProfileInfo.hProfile);
    }

    if(hUserToken && (hUserToken != hThreadToken))
    {
        CloseHandle(hUserToken);
    }

    if(hThreadToken)
    {
        if(!ImpersonateLoggedOnUser(hThreadToken))
        {
            // Unable to impersonate user.
            if(Status == ERROR_SUCCESS)
            {
                Status = GetLastError();
            }
        }
        CloseHandle(hThreadToken);
    }

    D_DebugLog((DEB_TRACE_API, "DPAPINotifyPasswordChange returned 0x%x\n", Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\debug.h ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* Snipped from SChannel sources
*
* 1/23/96
*----------------------------------------------------------------------------*/ 

#ifndef __DEBUG_H__
#define __DEBUG_H__


#ifdef __cplusplus
extern "C" {
#endif


#define SECSTOR_INVALID_MAGIC       *(DWORD *)"eerF"


/* Event Logging Definitions */
#define SS_LOG_ERROR                0x0001
#define SS_LOG_WARNING              0x0002
#define SS_LOG_TRACE                0x0004
#define SS_LOG_ALLOC                0x0008
#define SS_LOG_RES                  0x0010

// assert 
#if DBG
void SSAssert(
    void *FailedAssertion, 
    void *FileName, 
    unsigned long LineNumber,
    char * Message);

#define SS_ASSERT(x) \
	    if (!(x)) \
		SSAssert(#x, __FILE__, __LINE__, NULL); else

#else   // DBG
#define SS_ASSERT(x)
#endif  // DBG

// verify
#if DBG
#define SS_VERIFY(x) SS_ASSERT(x)
#else   // DBG
#define SS_VERIFY(x) (x)
#endif  // DBG


// alloc/free
#if DBG
VOID *SSAlloc(DWORD cb);
VOID *SSReAlloc(VOID *pv, DWORD cb);
VOID SSFree(VOID *pv);
SIZE_T SSSize(VOID *pv);
#else   // DBG
#define SSAlloc(cb)         LocalAlloc(LMEM_FIXED, cb)
#define SSReAlloc(pv, cb)   LocalReAlloc(pv, cb, LMEM_MOVEABLE)	  // allow ReAlloc to move
#define SSFree(pv)          LocalFree(pv)
#define SSSize(pv)          LocalSize(pv)
#endif  // DBG


// Error logging routines

#if DBG
long    
SSPrintErrorCode(
    long err, 
    const char *szFile, 
    long lLine);

#else   // DBG
#define SSPrintErrorCode(err, szFile, lLine)
#endif  // DBG


#undef RtlMoveMemory


NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );



#ifdef __cplusplus
}
#endif

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\dpapisvc\session.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    session.h

Abstract:

    This module contains prototypes to support communication with the LSA
    (Local Security Authority) to permit querying of active sessions.

Author:

    Scott Field (sfield)    02-Mar-97

--*/

#ifndef __SESSION_H__
#define __SESSION_H__

#ifdef __cplusplus
extern "C" {
#endif


DWORD 
QueryDerivedCredential(
    IN OUT  GUID *CredentialID, 
    IN      LUID *pLogonId,
    IN      DWORD dwFlags,
    IN      PBYTE pbMixingBytes,
    IN      DWORD cbMixingBytes,
    IN OUT  BYTE rgbDerivedCredential[A_SHA_DIGEST_LEN]
    );

DWORD               
DeleteCredentialHistoryMap();

DWORD
LogonCredGenerateSignature(
    IN  HANDLE hUserToken,
    IN  PBYTE pbData,
    IN  DWORD cbData,
    IN  PBYTE pbCurrentOWF,
    OUT PBYTE *ppbSignature,
    OUT DWORD *pcbSignature);

DWORD
LogonCredVerifySignature(
                        IN HANDLE hUserToken,   // optional
                        IN PBYTE pbData,
                        IN DWORD cbData,
                        IN  PBYTE pbCurrentOWF,
                        IN PBYTE pbSignature,
                        IN DWORD cbSignature);

#ifdef __cplusplus
}
#endif


#endif // __SESSION_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\dpapidbg.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        dpapidbg.h
//
// Contents:    Debug information for DPAPI
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __DPAPIDBG_H__
#define __DPAPIDBG_H__

//
//  NOTE:  DO not remove RETAIL_LOG_SUPPORT from sources,
//  or you'll be busted in DBG builds.
//

#ifdef RETAIL_LOG_SUPPORT

DECLARE_DEBUG2(DPAPI);
#undef DebugLog
#define DebugLog(_x_) DPAPIDebugPrint _x_

#define DPAPI_PARAMETER_PATH    L"System\\CurrentControlSet\\Control\\Lsa\\DPAPI"

#define WSZ_DPAPIDEBUGLEVEL     L"LogLevel"
#define WSZ_FILELOG             L"LogToFile"


#define DEB_TRACE_API           0x0008
#undef  DEB_TRACE_CRED
#define DEB_TRACE_CRED          0x0010
#define DEB_TRACE_CTXT          0x0020
#define DEB_TRACE_LSESS         0x0040
#define DEB_TRACE_TCACHE        0x0080
#define DEB_TRACE_LOGON         0x0100
#define DEB_TRACE_KDC           0x0200
#define DEB_TRACE_CTXT2         0x0400
#define DEB_TRACE_TIME          0x0800
#define DEB_TRACE_USER          0x1000
#define DEB_TRACE_LEAKS         0x2000
#define DEB_TRACE_BUFFERS       0x4000
#undef DEB_TRACE_LOCKS
#define DEB_TRACE_LOCKS         0x01000000
#define DEB_USE_LOG_FILE        0x2000000

//  For extended errors
#define DEB_USE_EXT_ERRORS      0x10000000
 
#define EXT_ERROR_ON(s)         (s & DEB_USE_EXT_ERRORS)            


#define SSAlloc(cb)         LocalAlloc(LMEM_FIXED, cb)
#define SSReAlloc(pv, cb)   LocalReAlloc(pv, cb, LMEM_MOVEABLE)	  // allow ReAlloc to move
#define SSFree(pv)          LocalFree(pv)
#define SSSize(pv)          LocalSize(pv)


VOID
DPAPIInitializeDebugging(VOID);

VOID
DPAPIDumpHexData(
    DWORD LogLevel,
    PSTR  pszPrefix,
    PBYTE pbData,
    DWORD cbData);

#else // RETAIL_LOG_SUPPORT

#define DebugLog(_x_)
#define DPAPIInitializeDebugging()
#define EXT_ERROR_ON(s)                 FALSE


#endif // RETAIL_LOG_SUPPORT  
    
#if DBG
#define D_DebugLog(_x_) DebugLog(_x_) // don't use all debug spew in retail builds
#define D_DPAPIDumpHexData(level, prefix, buffer, count) DPAPIDumpHexData((level), (prefix), (buffer), (count))
#else 
#define D_DebugLog(_x_)
#define D_DPAPIDumpHexData(level, prefix, buffer, count) 
#endif



#endif // __DPAPIDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\filemisc.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    filemisc.h

Abstract:

    This module contains routines to perform miscellaneous file related
    operations in the protected store.

Author:

    Scott Field (sfield)    27-Nov-96

--*/

#ifndef __FILEMISC_H__
#define __FILEMISC_H__

#ifdef __cplusplus
extern "C" {
#endif


BOOL
GetFileNameFromPath(
    IN      LPCWSTR FullPath,
    IN  OUT LPCWSTR *FileName   // points to filename component in FullPath
    );

BOOL
GetFileNameFromPathA(
    IN      LPCSTR FullPath,
    IN  OUT LPCSTR *FileName    // points to filename component in FullPath
    );

BOOL
TranslateFromSlash(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput
    );

BOOL
TranslateToSlash(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput
    );

BOOL
TranslateString(
    IN      LPWSTR szInput,
    IN  OUT LPWSTR *pszOutput,  // optional
    IN      WCHAR From,
    IN      WCHAR To
    );

BOOL
FindAndOpenFile(
    IN      LPCWSTR szFileName,     // file to search for + open
    IN  OUT LPWSTR  pszFullPath,    // file to fill fullpath with
    IN      DWORD   cchFullPath,    // size of full path buffer, including NULL
    IN  OUT PHANDLE phFile          // resultant open file handle
    );

BOOL
HashEntireDiskImage(
    IN  HANDLE hFile,       // handle of file to hash
    IN  LPBYTE FileHash     // on success, buffer contains file hash
    );

BOOL
HashDiskImage(
    IN  HANDLE hFile,       // handle of file to hash
    IN  LPBYTE FileHash     // on success, buffer contains file hash
    );

HINSTANCE
LoadAndOpenResourceDll(
    IN      LPCWSTR szFileName,     // file name to load + open
    IN  OUT LPWSTR  pszFullPath,    // buffer to fill file fullpath with
    IN      DWORD   cchFullPath,    // size of full path buffer (chars), including NULL
    IN  OUT PHANDLE phFile
    );

#ifdef __cplusplus
}
#endif


#endif // __FILEMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\dispif.h ===
// dispatcher interface file

#ifndef _DISPIF_H_
#define _DISPIF_H_

#ifdef __cplusplus
extern "C" {
#endif


typedef
BOOL FIMPERSONATECLIENT(
    PST_PROVIDER_HANDLE *hPSTProv
    );

FIMPERSONATECLIENT FImpersonateClient;

typedef
BOOL FREVERTTOSELF(
    PST_PROVIDER_HANDLE *hPSTProv
    );

FREVERTTOSELF FRevertToSelf;


typedef
BOOL
FISACLSATISFIED(
    PST_PROVIDER_HANDLE     *hPSTProv,
    PST_ACCESSRULESET       *psRules,
    DWORD                   dwAccess,
    LPVOID      // coming soon: fill a status structure with data about access attempt
    );

FISACLSATISFIED FIsACLSatisfied;

typedef
BOOL FGETCALLERNAME(
        PST_PROVIDER_HANDLE     *hPSTProv,
        LPWSTR*                 ppszCallerName,
        DWORD_PTR               *lpdwBaseAddress
        );

FGETCALLERNAME  FGetCallerName;


typedef
BOOL FGETUSER(
    PST_PROVIDER_HANDLE *hPSTProv,
    LPWSTR* pszUser
    );

FGETUSER        FGetUser;

typedef
BOOL FGETSERVERPARAM(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      DWORD  dwParam,
    IN      LPVOID pData,
    IN  OUT DWORD *pcbData
    );

FGETSERVERPARAM FGetServerParam;


typedef
BOOL FSETSERVERPARAM(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      DWORD  dwParam,
    IN      LPVOID pData,
    IN      DWORD pcbData
    );

FSETSERVERPARAM FSetServerParam;


// HACKHACK HACKHACK HACKHACK
typedef
BOOL FGETPASSWORD95LOWERCASE(
    LPBYTE rgbPwd
    );

FGETPASSWORD95LOWERCASE FGetPassword95LowerCase;

// a single structure to hold all of these callbacks
typedef struct _DISPIF_CALLBACKS
{
    DWORD                   cbSize; // sizeof(DISPIF_CALLBACKS)
    FISACLSATISFIED*        pfnFIsACLSatisfied;

    FGETUSER*               pfnFGetUser;
    FGETCALLERNAME*         pfnFGetCallerName;

    FIMPERSONATECLIENT*     pfnFImpersonateClient;
    FREVERTTOSELF*          pfnFRevertToSelf;

    FGETSERVERPARAM*        pfnFGetServerParam;
    FSETSERVERPARAM*        pfnFSetServerParam;

} DISPIF_CALLBACKS, *PDISPIF_CALLBACKS;


//
// private interfaces in the server which are not exported for provider use
//

BOOL
FInternalCreateType(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    PPST_TYPEINFO pinfoType,
    DWORD dwFlags
    );

BOOL
FInternalCreateSubtype(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    const GUID *pguidSubtype,
    PPST_TYPEINFO pinfoSubtype,
    DWORD dwFlags
    );

BOOL
FInternalWriteAccessRuleset(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    const GUID *pguidSubtype,
    PPST_ACCESSRULESET psRules,
    DWORD dwFlags
    );


#ifdef __cplusplus
}
#endif


#endif // _DISPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\guidcnvt.h ===
#define MAX_GUID_SZ_CHARS  40

#ifdef __cplusplus
extern "C" {
#endif

// guid -> string conversion
DWORD MyGuidToStringA(
    const GUID* pguid, 
    CHAR rgsz[]);

// guid -> string conversion
DWORD MyGuidToStringW(
    const GUID* pguid, 
    WCHAR rgsz[]);


// string -> guid conversion
DWORD MyGuidFromStringA(
    LPSTR sz, 
    GUID* pguid);

// string -> guid conversion
DWORD MyGuidFromStringW(
    LPWSTR szW, 
    GUID* pguid);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\pmacros.h ===
#include "pstdef.h"

// count the number of bytes needed to fully store the WSZ
#define WSZ_BYTECOUNT(__z__)   \
    ( (__z__ == NULL) ? 0 : (wcslen(__z__)+1)*sizeof(WCHAR) )

// count the number of elements in the static array
#define ARRAY_COUNT(__z__)     \
    ( (__z__ == NULL) ? 0 : (sizeof( __z__ ) / sizeof( __z__[0] )) )


// if in range of PST_E errors, pass through unmodified
// otherwise, convert HRESULT to a Win32 error
#define PSTERR_TO_HRESULT(__z__)    \
    ( ((__z__ >= MIN_PST_ERROR) && (__z__ <= MAX_PST_ERROR)) ? __z__ : HRESULT_FROM_WIN32(__z__) )

#define HRESULT_TO_PSTERR(__z__)    \
    ( ((__z__ >= MIN_PST_ERROR) && (__z__ <= MAX_PST_ERROR)) ? __z__ : HRESULT_CODE(__z__) )


// map exceptions to win32 errors (used internally)
#define  PSTMAP_EXCEPTION_TO_ERROR(__x__) \
    ((__x__ == 0xC0000005) ? 998 : PST_E_UNKNOWN_EXCEPTION)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\primitiv.h ===
typedef struct _DESKey
{
    BYTE        rgbKey[DES_BLOCKLEN];
    DESTable    sKeyTable;
} DESKEY, *PDESKEY;


// assumes pbKeyMaterial is at least DES_BLOCKLEN bytes
BOOL FMyMakeDESKey(
            PDESKEY     pDESKey,            // out 
            BYTE*       pbKeyMaterial);     // in

BOOL FMyPrimitiveSHA(
			PBYTE       pbData,             // in
			DWORD       cbData,             // in
            BYTE        rgbHash[A_SHA_DIGEST_LEN]); // out


BOOL FMyPrimitiveDESDecrypt(
            PBYTE       pbBlock,            // in out
            DWORD       *pcbBlock,          // in out
            DESKEY      sDESKey);           // in

BOOL FMyPrimitiveDESEncrypt(
            PBYTE*      ppbBlock,           // in out
            DWORD*      pcbBlock,           // in out
            DESKEY      sDESKey);           // in


BOOL FMyPrimitiveDeriveKey(
			PBYTE       pbSalt,             // in
			DWORD       cbSalt,             // in
            PBYTE       pbOtherData,        // in [optional]
            DWORD       cbOtherData,        // in
            DESKEY*     pDesKey);           // out 


BOOL FMyOldPrimitiveHMAC(
            DESKEY      sMacKey,            // in
            PBYTE       pbData,             // in
            DWORD       cbData,             // in
            BYTE        rgbHMAC[A_SHA_DIGEST_LEN]); // out

BOOL FMyPrimitiveHMAC(
            DESKEY      sMacKey,            // in
            PBYTE       pbData,             // in
            DWORD       cbData,             // in
            BYTE        rgbHMAC[A_SHA_DIGEST_LEN]); // out

BOOL FMyPrimitiveHMACParam(
            PBYTE       pbKeyMaterial,      // in
            DWORD       cbKeyMaterial,      // in
            PBYTE       pbData,             // in
            DWORD       cbData,             // in
            BYTE        rgbHMAC[A_SHA_DIGEST_LEN]);  // out


#define PBKDF2_MAX_SALT_SIZE (16)

BOOL PKCS5DervivePBKDF2(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbSalt,
        DWORD       cbSalt,
        DWORD       KeyGenAlg,
        DWORD       cIterationCount,
        DWORD       iBlockIndex,
        BYTE        rgbPKCS5Key[A_SHA_DIGEST_LEN]  // output buffer
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\listbase.h ===
#ifndef __LISTBASE_H__
#define __LISTBASE_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <sha.h>



// minimal elt data structure
typedef struct _ELT
{
    struct _ELT* pNext;
} ELT;


typedef
BOOL    FISMATCH(ELT* pCandidate, ELT* pTemplate);

typedef
void    FREEELT(ELT* pElt);


class CLinkedList
{
public:
    CLinkedList();
    ~CLinkedList();


    BOOL Initialize();
    BOOL Reset();

private:
    ELT*                m_pHead;
public:
    BOOL                m_fInitialized;
    CRITICAL_SECTION    m_critsecListBusy;
    FISMATCH*           m_pfnIsMatch;
    FREEELT*            m_pfnFreeElt;

public:
    BOOL                AddToList(ELT*);
    BOOL                DelFromList(ELT*);
    ELT*                SearchList(ELT*);

    BOOL                LockList();
    BOOL                UnlockList();

    ELT*                GetHead()
        {   return m_pHead;   }

};

#ifdef __cplusplus
}       // extern "C" {
#endif

#endif // __LISTBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\rules.h ===
#ifndef __RULES_H__
#define __RULES_H__

//
// externally provides allocation/free services.
//

LPVOID
RulesAlloc(
    IN      DWORD cb
    );

VOID
RulesFree(
    IN      LPVOID pv
    );

// get the length of the entire rules structure
BOOL
GetLengthOfRuleset(
    IN PPST_ACCESSRULESET pRules,
    OUT DWORD *pcbRules
    );

// set up the rules to be output
BOOL
MyCopyOfRuleset(
    IN PPST_ACCESSRULESET pRulesIn,
    OUT PPST_ACCESSRULESET pRulesOut
    );

BOOL
RulesRelativeToAbsolute(
    IN PPST_ACCESSRULESET pRules
    );

BOOL
RulesAbsoluteToRelative(
    IN PPST_ACCESSRULESET NewRules
    );

// free allocated clause data in relative format
void
FreeClauseDataRelative(
    IN PPST_ACCESSRULESET NewRules
    );

#endif // __RULES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\provif.h ===
// Provider interface header file
//
// all secure provider calls are prefixed by "SP" 
// providers must implement all of these interfaces!
//

#ifdef __cplusplus
extern "C"{
#endif 

// note: we typedef here because it is convenient and needed for 
// filling struct by GetProcAddress() later. After defining the types, 
// we simply instantiate the actual call as an implementation of that type.


// load notification, register callbacks
typedef
HRESULT        SPPROVIDERINITIALIZE(
                DISPIF_CALLBACKS *psCallbacks);

SPPROVIDERINITIALIZE SPProviderInitialize;


// Acquire Context notification
typedef 
HRESULT        SPACQUIRECONTEXT(
                PST_PROVIDER_HANDLE* phPSTProv,
                DWORD           dwFlags);

SPACQUIRECONTEXT SPAcquireContext;


// Release Context notification
typedef 
HRESULT        SPRELEASECONTEXT(
                PST_PROVIDER_HANDLE* phPSTProv,
                DWORD           dwFlags);

SPRELEASECONTEXT SPReleaseContext;


// GetProvInfo
typedef 
HRESULT        SPGETPROVINFO(
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppPSTInfo,
    /* [in] */  DWORD dwFlags);

SPGETPROVINFO SPGetProvInfo;


// GetProvParam
typedef
HRESULT     SPGETPROVPARAM(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD           dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ 
                BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */  DWORD           dwFlags);

SPGETPROVPARAM SPGetProvParam;

// SetProvParam
typedef
HRESULT     SPSETPROVPARAM(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD           dwParam,
    /* [in] */  DWORD           cbData,
    /* [in] */  BYTE*           pbData,
    /* [in] */  DWORD           dwFlags);

SPSETPROVPARAM SPSetProvParam;


// EnumTypes
typedef 
HRESULT        SPENUMTYPES(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [out] */ GUID *pguidType,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags);

SPENUMTYPES SPEnumTypes;

// GetTypeInfo
typedef
HRESULT         SPGETTYPEINFO( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ PPST_TYPEINFO *ppinfoType,
    /* [in] */ DWORD dwFlags);

SPGETTYPEINFO SPGetTypeInfo;

// EnumSubtypes
typedef 
HRESULT        SPENUMSUBTYPES(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [out] */ GUID *pguidSubtype,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags);

SPENUMSUBTYPES SPEnumSubtypes;


// GetSubtypeInfo
typedef
HRESULT         SPGETSUBTYPEINFO( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ PPST_TYPEINFO *ppinfoSubtype,
    /* [in] */ DWORD dwFlags);

SPGETSUBTYPEINFO SPGetSubtypeInfo;

// EnumItems
typedef
HRESULT        SPENUMITEMS(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [out] */ LPWSTR *ppszItemName,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags);

SPENUMITEMS SPEnumItems;

// CreateType
typedef
HRESULT        SPCREATETYPE(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ PPST_TYPEINFO pinfoType,
    /* [in] */ DWORD dwFlags);

SPCREATETYPE SPCreateType;

// DeleteType
typedef
HRESULT SPDELETETYPE( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ DWORD dwFlags);

SPDELETETYPE SPDeleteType;

// CreateSubtype
typedef
HRESULT        SPCREATESUBTYPE(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ PPST_TYPEINFO pinfoSubtype,
    /* [in] */ PPST_ACCESSRULESET psRules,
    /* [in] */ DWORD dwFlags);

SPCREATESUBTYPE SPCreateSubtype;


// DeleteSubtype
typedef
HRESULT SPDELETESUBTYPE( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ DWORD dwFlags);

SPDELETESUBTYPE SPDeleteSubtype;

// WriteItem
typedef
HRESULT        SPWRITEITEM(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID  *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE *pbData,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags);
    
SPWRITEITEM SPWriteItem;

// ReadItem
typedef
HRESULT		SPREADITEM(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out] */ DWORD *pcbData,
    /* [size_is][size_is][out] */ BYTE **ppbData,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags);

SPREADITEM SPReadItem;

// OpenItem
typedef 
HRESULT SPOPENITEM( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwModeFlags,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags);

// CloseItem
typedef
HRESULT SPCLOSEITEM( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags);

// DeleteItem
typedef
HRESULT		SPDELETEITEM(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags);

SPDELETEITEM SPDeleteItem;


// ReadAccessRuleset
typedef 
HRESULT        SPREADACCESSRULESET( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [out] */ PPST_ACCESSRULESET *ppsRules,
    /* [in] */ DWORD dwFlags);

SPREADACCESSRULESET SPReadAccessRuleset;

// WriteAccessRuleset
typedef
HRESULT SPWRITEACCESSRULESET( 
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ PPST_ACCESSRULESET psRules,
    /* [in] */ DWORD dwFlags);

SPWRITEACCESSRULESET SPWriteAccessRuleset;
                                      

////////////////////////////////////////////////////
// side door interfaces: dispatcher/provider only

// PasswordChangeNotify
typedef
BOOL FPASSWORDCHANGENOTIFY(
    /* [in] */  LPWSTR  szUser,
    /* [in] */  LPWSTR  szPasswordName,
    /* [in] */  BYTE    rgbOldPwd[],
    /* [in] */  DWORD   cbOldPwd,
    /* [in] */  BYTE    rgbNewPwd[],
    /* [in] */  DWORD   cbNewPwd);

FPASSWORDCHANGENOTIFY FPasswordChangeNotify;


#ifdef __cplusplus
}   // extern C
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by script1.rc
//
#define IDS_PASSWORD_CREATE_MESSAGE     1
#define IDS_PASSWORD_NOMATCH            2
#define IDS_PASSWORD_CHANGE_MESSAGE     5
#define IDS_PASSWORD_MUSTNAME           7
#define IDS_PASSWORD_SOLICIT_OLD_MESSAGE 8
#define IDS_PASSWORD_DUPLICATE          9
#define IDS_PASSWORD_ADD_ERROR          10
#define IDS_PASSWORD_ERROR_DLGTITLE     11
#define IDS_PROMPT_READITEM             12
#define IDS_PROMPT_WRITEITEM            13
#define IDS_PROMPT_DELETEITEM           14
#define IDS_PASSWORD_CHANGE_ERROR       15
#define IDS_PW_PROMPT                   18
#define IDS_PASSWORD_PROMPT_PREFIX      18
#define IDS_PASSWORD_PROMPT_SUFFIX      19
#define IDS_PASSWORD_BANNER             23
#define IDS_ITEM_DETAILS_BANNER         23
#define IDS_PROMPT_OPENITEM             24
#define IDS_WIN95_PASSWORDS_AREGARBAGE  25
#define IDS_SIMPLIFIED_DLG_MSG          26
#define IDS_PROMPT_HIGH_SECURITY        40
#define IDS_PROMPT_MED_SECURITY         41
#define IDS_PROMPT_LOW_SECURITY         42
#define IDS_GET_WINDOWS_PASSWORD_95     51
#define IDS_GET_WINDOWS_PASSWORD_NT     52
#define IDS_PASSWORD_NOVERIFY           53
#define IDS_PASSWORD_WIN_NOVERIFY       54
#define IDS_PASSWORD_CHANGE_REQ         55
#define IDS_TITLE_CONTAINER_MAPPING     56
#define IDS_WINDOWS_NT_SECURITY_ALERT   57
#define IDI_ICON1                       104
#define IDD_SecDetail                   104
#define IDD_SIMPLIFIED_PASSWD           105
#define IDD_PASSWORD_SOLICIT_OLD        106
#define IDD_SecWiz1                     107
#define IDD_PASSWORD_SOLICIT            108
#define IDD_ADVANCED_CONFIRM            109
#define IDD_ITEM_DETAILS                110
#define IDD_PASSWORD_CREATE             111
#define IDD_PASSWORD_CHANGE             114
#define IDD_GET_WINDOWS_PASSWORD        115
#define IDC_MAIN_CAPTION                120
#define IDC_MAIN_CAPTION2               122
#define IDC_MAIN_CAPTION3               123
#define IDC_MAIN_CAPTION4               124
#define IDC_PASSWORD_LABEL              124
#define IDB_BITMAP_BLANK                125
#define IDC_PASSWORD_LABEL2             125
#define IDC_MAIN_CAPTION5               125
#define IDC_PASSWORD_LABEL3             126
#define IDC_PASSWORD_LABEL4             127
#define IDD_SecPass_WinNT               127
#define IDC_PASSWORD_LABEL5             128
#define IDB_BITMAP_LOCKKEY              129
#define IDD_SIMPLIFIED_PASSWORD         131
#define IDD_SecAddMed2                  133
#define IDD_SecPass_Win95               134
#define IDD_SecWiz2a                    135
#define IDD_ADVANCED_CONFIRM_H          135
#define IDB_BITMAP_ALERT                136
#define IDD_SecWiz2b                    137
#define IDD_ADVANCED_CONFIRM_M          137
#define IDD_SecWiz2c                    138
#define IDD_ADVANCED_CONFIRM_L          138
#define IDR_PSTORE_SERVER               666
#define IDR_PSTORE_PROVIDER             777
#define IDC_EDIT1                       1000
#define IDC_EDIT2                       1001
#define IDC_BUTTON2                     1002
#define IDC_MESSAGE                     1003
#define IDC_BUTTON3                     1003
#define IDC_BUTTON5                     1004
#define IDC_MESSAGE2                    1005
#define IDC_ACCESS_TYPE                 1006
#define IDC_ITEM_NAME                   1007
#define IDC_ITEM_TYPE                   1008
#define IDC_APP_MSG                     1009
#define IDC_RADIO1                      1009
#define IDC_RADIO_SELEXISTING           1009
#define IDC_EDIT0                       1010
#define IDC_RADIO2                      1010
#define IDC_RADIO_DEFINENEW             1010
#define IDC_RADIO3                      1011
#define IDC_APP_NAME                    1012
#define IDC_COMBO1                      1012
#define IDC_APP_PATH                    1013
#define IDC_COMBO2                      1013
#define IDC_LABEL_EDIT1                 1014
#define IDC_RADIO_WINPW                 1015
#define IDC_RADIO_NOCONFIRM             1015
#define IDC_LABEL_EDIT2                 1015
#define IDC_COMBO3                      1015
#define IDC_RADIO_ASSIGNPW              1016
#define IDC_COMBO4                      1016
#define IDC_RADIO_OKCANCEL              1017
#define IDC_MYICON                      1019
#define IDC_NEW_PW_BUTTON               1020
#define IDC_ICONBOX                     1021
#define IDC_ADVANCED                    1022
#define IDC_PW_MESSAGE                  1023
#define IDC_CACHEPW                     1024
#define IDC_ST_NEWPW                    1025
#define IDC_SEC_LEVEL                   1026
#define IDC_BUTTON1                     1027
#define IDC_MYTXT                       1028
#define IDC_APPTXT                      1029
#define IDC_EDIT_PASSWD                 1030
#define IDC_PASSWD_NAME                 1031
#define IDC_CHECK_NOASK                 1032
#define IDC_CHANGE_SECURITY             1033
#define IDC_CHANGE_SECURITY2            1034
#define IDC_BACK                        1037
#define IDC_NEXT                        1038
#define IDC_PW_NAME                     1038
#define IDC_PW_NEWNAME                  1039
#define IDC_EDIT1_LABEL                 1040
#define IDC_EDIT2_LABEL                 1041
#define DLG_UPDATE_DATA                 1500
#define OLD_IDD_GET_WINDOWS_PASSWORD    2000
#define OLD_IDD_SIMPLIFIED_PASSWD       2001
#define OLD_IDD_ITEM_DETAILS            2002
#define OLD_IDD_ADVANCED_CONFIRM        2003
#define IDC_STATIC1                     34465
#define IDC_STATIC2                     34466
#define IDC_STATIC3                     34467
#define IDC_STATIC4                     34468
#define IDC_STATIC5                     34469
#define IDC_STATIC6                     34470
#define IDC_STATIC7                     34471
#define IDC_STATIC8                     34472
#define IDC_STATIC9                     34473
#define IDC_SEC_PREFIX                  65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1042
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\secmisc.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    secmisc.h

Abstract:

    This module contains miscellaneous security routines for the Protected
    Storage.


Author:

    Scott Field (sfield)    25-Mar-97

--*/

#ifndef __SECMISC_H__
#define __SECMISC_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Textual Sids of interesting accounts on WinNT
//

#define TEXTUAL_SID_LOCAL_SYSTEM    L"S-1-5-18"
#define TEXTUAL_SID_LOCAL_SERVICE   L"S-1-5-19"
#define TEXTUAL_SID_NETWORK_SERVICE L"S-1-5-20"


BOOL
GetUserHKEYEx(
    IN      LPCWSTR szUser,
    IN      DWORD   dwDesiredAccess,
    IN  OUT HKEY    *hKeyUser,
    IN      BOOL    fCheckDefault       // check .Default registry hive ?
    );

BOOL
GetUserHKEY(
    IN      LPCWSTR szUser,
    IN      DWORD   dwDesiredAccess,
    IN  OUT HKEY    *hKeyUser
    );

BOOL
GetUserTextualSid(
    IN      HANDLE  hUserToken,     // optional
    IN  OUT LPWSTR  lpBuffer,
    IN  OUT LPDWORD nSize
    );

BOOL
GetTextualSid(
    IN      PSID    pSid,          // binary Sid
    IN  OUT LPWSTR  TextualSid,  // buffer for Textual representaion of Sid
    IN  OUT LPDWORD dwBufferLen // required/provided TextualSid buffersize
    );

BOOL
GetThreadAuthenticationId(
    IN      HANDLE  hThread,
    IN  OUT PLUID   AuthenticationId
    );

BOOL
GetTokenAuthenticationId(
    IN      HANDLE  hToken,
    IN  OUT PLUID   AuthenticationId
    );

BOOL
GetTokenUserSid(
    IN      HANDLE  hToken,     // token to query
    IN  OUT PSID    *ppUserSid  // resultant user sid
    );

BOOL
SetRegistrySecurity(
    IN      HKEY    hKey
    );

BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCWSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    );

BOOL
SetCurrentPrivilege(
    LPCWSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    );

BOOL
IsAdministrator(
    VOID
    );

BOOL
IsLocal(
    VOID
    );

BOOL
IsDelegating(
    IN      HANDLE hToken   // token to query, open for at least TOKEN_QUERY access
    );

BOOL
IsUserSidInDomain(
    IN      PSID pSidDomain,    // domain Sid
    IN      PSID pSidUser       // user Sid
    );

BOOL
IsDomainController(
    VOID
    );

LONG
SecureRegDeleteValueU(
    IN      HKEY hKey,          // handle of key
    IN      LPCWSTR lpValueName // address of value name
    );

#ifdef __cplusplus
}
#endif


#endif // __SECMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\lnklist.cpp ===
#include <pch.cpp>
#pragma hdrstop

#include "crtem.h"






//////////////////////////
// OpenItem list
COpenItemList::COpenItemList()
{
    m_pfnIsMatch = OpenItemIsMatch;
    m_pfnFreeElt = OpenItemFreeElt;
}

void CreateOpenListItem(OPENITEM_LIST_ITEM* pli,
                        PST_PROVIDER_HANDLE* phPSTProv,
                        PST_KEY     Key,
                        const GUID* pguidType,
                        const GUID* pguidSubtype,
                        LPCWSTR     szItemName)
{
    pli->pNext = NULL;
    CopyMemory(&pli->hPSTProv, phPSTProv, sizeof(PST_PROVIDER_HANDLE));
    pli->Key = Key;
    CopyMemory(&pli->guidType, pguidType, sizeof(GUID));
    CopyMemory(&pli->guidSubtype, pguidSubtype, sizeof(GUID));
    pli->szItemName = (LPWSTR)szItemName;
}


BOOL OpenItemIsMatch(
        ELT* pCandidate,
        ELT* pTemplate)
{
    POPENITEM_LIST_ITEM pliCandidate = (POPENITEM_LIST_ITEM) pCandidate;
    POPENITEM_LIST_ITEM pliTemplate = (POPENITEM_LIST_ITEM) pTemplate;

    if (
        (0 == memcmp(&pliCandidate->hPSTProv, &pliTemplate->hPSTProv, sizeof(PST_PROVIDER_HANDLE))) &&
        (pliCandidate->Key == pliTemplate->Key) &&
        (0 == memcmp(&pliCandidate->guidType, &pliTemplate->guidType, sizeof(GUID))) &&
        (0 == memcmp(&pliCandidate->guidSubtype, &pliTemplate->guidSubtype, sizeof(GUID))) &&
        (0 == wcscmp(pliCandidate->szItemName, pliTemplate->szItemName))
       )
       return TRUE;

    return FALSE;
}

void OpenItemFreeElt(
        ELT* p)
{
    if (NULL == p)
        return;

    POPENITEM_LIST_ITEM pli = (POPENITEM_LIST_ITEM) p;

    // do all necessary freeing
    if (pli->szItemName != NULL)
        SSFree(pli->szItemName);

    if (pli->szMasterKey != NULL)
        SSFree(pli->szMasterKey);

    RtlSecureZeroMemory(pli, sizeof(OPENITEM_LIST_ITEM)); // make sure contents invalid

    SSFree(pli);
}




//////////////////////////
// UACache list
CUAList::CUAList()
{
    m_pfnIsMatch = UACacheIsMatch;
    m_pfnFreeElt = UACacheFreeElt;
}

void CreateUACacheListItem(UACACHE_LIST_ITEM* pli,
                        LPCWSTR     szUserName,
                        LPCWSTR     szMKName,
                        LUID        *pluidAuthID)
{
    pli->pNext = NULL;
    pli->szUserName = (LPWSTR)szUserName;
    pli->szMKName = (LPWSTR)szMKName;

    CopyMemory( &(pli->luidAuthID), pluidAuthID, sizeof(LUID) );
}

BOOL UACacheIsMatch(
        ELT* pCandidate,
        ELT* pTemplate)
{
    PUACACHE_LIST_ITEM pliCandidate = (PUACACHE_LIST_ITEM) pCandidate;
    PUACACHE_LIST_ITEM pliTemplate = (PUACACHE_LIST_ITEM) pTemplate;

    if (
        (0 == wcscmp(pliCandidate->szUserName, pliTemplate->szUserName)) &&
        (0 == wcscmp(pliCandidate->szMKName, pliTemplate->szMKName))
       ) {

        //
        // sfield:
        // on WinNT, expand cache matching based on authentication ID.
        //

        if(FIsWinNT()) {
            if(memcmp(&(pliCandidate->luidAuthID), &(pliTemplate->luidAuthID), sizeof(LUID)) != 0)
                return FALSE;
        }

        return TRUE;
    }

    return FALSE;
}

void UACacheFreeElt(
        ELT* p)
{
    if (NULL == p)
        return;

    PUACACHE_LIST_ITEM pli = (PUACACHE_LIST_ITEM) p;

    // do all necessary freeing
    if (pli->szUserName != NULL)
        SSFree(pli->szUserName);

    if (pli->szMKName != NULL)
        SSFree(pli->szMKName);

    RtlSecureZeroMemory(pli, sizeof(UACACHE_LIST_ITEM)); // make sure contents invalid

    SSFree(pli);
}




////////////////////////
// Cryptographic Provider handle list

CCryptProvList::CCryptProvList()
{
    m_pfnIsMatch = CryptProvIsMatch;
    m_pfnFreeElt = CryptProvFreeElt;
}

void CreateCryptProvListItem(CRYPTPROV_LIST_ITEM* pli,
                        DWORD       dwAlgId1,
                        DWORD       dwKeySize1,
                        DWORD       dwAlgId2,
                        DWORD       dwKeySize2,
                        HCRYPTPROV  hProvider)
{
    pli->pNext = NULL;

    pli->dwAlgId1 = dwAlgId1;
    pli->dwKeySize1 = dwKeySize1;

    pli->dwAlgId2 = dwAlgId2;
    pli->dwKeySize2 = dwKeySize2;

    pli->hProv = hProvider;
}

BOOL CryptProvIsMatch(
        ELT* pCandidate,
        ELT* pTemplate)
{
    PCRYPTPROV_LIST_ITEM pliCandidate = (PCRYPTPROV_LIST_ITEM) pCandidate;
    PCRYPTPROV_LIST_ITEM pliTemplate = (PCRYPTPROV_LIST_ITEM) pTemplate;

    // if both algids match
    if ((pliCandidate->dwAlgId1 == pliTemplate->dwAlgId1) &&
        (pliCandidate->dwAlgId2 == pliTemplate->dwAlgId2))
    {
        // if both sizes match
        if ((pliCandidate->dwKeySize1 == -1) ||
            (pliTemplate->dwKeySize1 == -1) ||
            (pliCandidate->dwKeySize1 == pliTemplate->dwKeySize1))
        {
            if ((pliCandidate->dwKeySize2 == -1) ||
                (pliTemplate->dwKeySize2 == -1) ||
                (pliCandidate->dwKeySize2 == pliTemplate->dwKeySize2))
               return TRUE;
        }
    }

    return FALSE;
}

void CryptProvFreeElt(
        ELT* p)
{
    if (NULL == p)
        return;

    PCRYPTPROV_LIST_ITEM pli = (PCRYPTPROV_LIST_ITEM) p;

    // do all necessary freeing
    if (pli->hProv != 0)
        CryptReleaseContext((HCRYPTPROV)pli->hProv, 0);

    RtlSecureZeroMemory(pli, sizeof(CRYPTPROV_LIST_ITEM)); // make sure contents invalid

    SSFree(pli);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\include\service.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: service.h
//
//  AUTHOR: Craig Link
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and 
//  implement the ServiceStart() and ServiceStop() functions.
//  
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            L"pstores"
// internal name of the service
#define SZSERVICENAME        L"ProtectedStorage"
// displayed name of the service
#define SZSERVICEDISPLAYNAME L"Protected Storage"
#define SZSERVICEDISPLAYNAMEA "Protected Storage"
// list of service dependencies - "dep1\0dep2\0\0"
// RPC must be running for us to work!
#define SZDEPENDENCIES       L"RpcSs\0" // doubly null terminated
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
DWORD ServiceStart (HINSTANCE hInstance, int nCmdShow);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPWSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
void AddToMessageLog(LPWSTR lpszMsg);
//////////////////////////////////////////////////////////////////////////////

void StopRPCServer();


// entry point to start the service from install stub.

DWORD WINAPI Start( LPVOID lpV );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\lnklist.h ===
#ifndef __LNKLIST_H__
#define __LNKLIST_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "pstypes.h"
#include "listbase.h"
#include <sha.h>


//////////////////////
// OpenItem list

// item list element
typedef struct _OPENITEM_LIST_ITEM
{
    // internal to list
    struct _OPENITEM_LIST_ITEM *      pNext;

    // Lookup devices: set by creator before adding to list
    PST_PROVIDER_HANDLE     hPSTProv;
    PST_KEY                 Key;
    GUID                    guidType;
    GUID                    guidSubtype;
    LPWSTR                  szItemName;

    // item data
    BYTE                    rgbPwd[A_SHA_DIGEST_LEN];
    BYTE                    rgbPwdLowerCase[A_SHA_DIGEST_LEN];
    LPWSTR                  szMasterKey;
    PST_ACCESSMODE          ModeFlags;

} OPENITEM_LIST_ITEM, *POPENITEM_LIST_ITEM;

class COpenItemList : public CLinkedList
{
//    CLinkedList list;

public:
    COpenItemList();


    BOOL             AddToList(POPENITEM_LIST_ITEM pli)
    {   return CLinkedList::AddToList((ELT*)pli);   }

    BOOL    DelFromList(POPENITEM_LIST_ITEM pli)
    {   return CLinkedList::DelFromList((ELT*)pli);  }

    POPENITEM_LIST_ITEM  SearchList(POPENITEM_LIST_ITEM pli)
    {   return (POPENITEM_LIST_ITEM)  CLinkedList::SearchList((ELT*)pli);  }
};


//////////////////////////
// Associated functions
void CreateOpenListItem(
        OPENITEM_LIST_ITEM* pli,
        PST_PROVIDER_HANDLE* phPSTProv,
        PST_KEY     Key,
        const GUID* pguidType,
        const GUID* pguidSubtype,
        LPCWSTR     szItemName);

BOOL OpenItemIsMatch(
        ELT* pCandidate,
        ELT* pTemplate);

void OpenItemFreeElt(
        ELT* pli);




//////////////////////
// User Authentication Cache list

// item list element
typedef struct _UACACHE_LIST_ITEM
{
    // internal to list
    struct _UACACHE_LIST_ITEM *      pNext;

    // Lookup devices: set by creator before adding to list
    LPWSTR                  szUserName;
    LPWSTR                  szMKName;
    LUID                    luidAuthID; // NT authentication ID

    // item data
    BYTE                    rgbPwd[A_SHA_DIGEST_LEN];
    BYTE                    rgbPwdLowerCase[A_SHA_DIGEST_LEN];

} UACACHE_LIST_ITEM, *PUACACHE_LIST_ITEM;

class CUAList : public CLinkedList
{

public:
    CUAList();

    BOOL                 AddToList(PUACACHE_LIST_ITEM pli)
    {   return CLinkedList::AddToList((ELT*)pli);   }

    BOOL    DelFromList(PUACACHE_LIST_ITEM pli)
    {   return CLinkedList::DelFromList((ELT*)pli);  }

    PUACACHE_LIST_ITEM   SearchList(PUACACHE_LIST_ITEM pli)
    {   return (PUACACHE_LIST_ITEM)  CLinkedList::SearchList((ELT*)pli);  }

};

///////////////////////////
// Associated functions
void CreateUACacheListItem(
        UACACHE_LIST_ITEM* pli,
        LPCWSTR     szUserName,
        LPCWSTR     szMKName,
        LUID        *pluidAuthID);

BOOL UACacheIsMatch(
        ELT* pCandidate,
        ELT* pTemplate);

void UACacheFreeElt(
        ELT* pli);



//////////////////////////////
// CryptProv list

// item list element
typedef struct _CRYPTPROV_LIST_ITEM
{
    // internal to list
    struct _CRYPTPROV_LIST_ITEM *      pNext;

    // Lookup device
//    DWORD                   dwProvID;
    DWORD                   dwAlgId1;
    DWORD                   dwKeySize1;

    DWORD                   dwAlgId2;
    DWORD                   dwKeySize2;

    // item data
    HCRYPTPROV              hProv;

} CRYPTPROV_LIST_ITEM, *PCRYPTPROV_LIST_ITEM;

class CCryptProvList : public CLinkedList
{

public:
    CCryptProvList();

    BOOL                AddToList(PCRYPTPROV_LIST_ITEM pli)
    {   return CLinkedList::AddToList((ELT*)pli);   }

    BOOL    DelFromList(PCRYPTPROV_LIST_ITEM pli)
    {   return CLinkedList::DelFromList((ELT*)pli);  }

    PCRYPTPROV_LIST_ITEM   SearchList(PCRYPTPROV_LIST_ITEM pli)
    {   return (PCRYPTPROV_LIST_ITEM)  CLinkedList::SearchList((ELT*)pli);  }

};


///////////////////////////
// Associated functions
void CreateCryptProvListItem(CRYPTPROV_LIST_ITEM* pli,
                        DWORD       dwAlgId1,
                        DWORD       dwKeySize1,
                        DWORD       dwAlgId2,
                        DWORD       dwKeySize2,
                        HCRYPTPROV  hCryptProv);

BOOL CryptProvIsMatch(
        ELT* pCandidate,
        ELT* pTemplate);

void CryptProvFreeElt(
        ELT* p);





#ifdef __cplusplus
}
#endif

#endif // __LNKLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\migrate.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    migrate.h

Abstract:

    This module contains routines to support migration of protected storage
    data from beta1 to beta2.

    Hopefully this code will be pitched after beta2, prior to final release.

Author:

    Scott Field (sfield)    15-Apr-97

--*/

#ifndef __MIGRATE_H__
#define __MIGRATE_H__

BOOL
MigrateData(
    PST_PROVIDER_HANDLE *phPSTProv,
    BOOL                fMigrationNeeded
    );

#endif // __MIGRATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\misc.h ===
void MyToUpper(LPWSTR wsrc);

BOOL FStringIsValidItemName(LPCWSTR szTrialString);

// allocing wrapper for g_Callback->FGetUser
BOOL FGetCurrentUser(
    PST_PROVIDER_HANDLE* phPSTProv,
    LPWSTR* ppszUser,
    PST_KEY Key);


// GET registry wrapper
DWORD RegGetValue(
    HKEY hItemKey,
    LPWSTR szItem,
    PBYTE* ppb,
    DWORD* pcb);

DWORD RegGetStringValue(
    HKEY hItemKey,
    LPWSTR szItem,
    PBYTE* ppb,
    DWORD* pcb);

#if 0
void FreeRuleset(
    PST_ACCESSRULESET *psRules
    );
#endif

BOOL
GetFileDescription(
    LPCWSTR szFile,
    LPWSTR *FileDescription // on success, allocated description
    );


BOOL FIsCachedPassword(
    LPCWSTR szUser,
    LPCWSTR szPassword,
    LUID*   pluidAuthID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\migrate.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    migrate.cpp

Abstract:

    This module contains routines to support migration of protected storage
    data from beta1 to beta2.

    Hopefully this code will be pitched after beta2, prior to final release.

Author:

    Scott Field (sfield)    15-Apr-97

--*/

#include <pch.cpp>
#pragma hdrstop

#include <lmcons.h>

#include "provif.h"
#include "storage.h"
#include "secure.h"

#include "secmisc.h"
#include "passwd.h"



#include "migrate.h"

//#define MIGRATE_FLAG    1 // indicates whether beta1 -> beta2 migration done.
#define MIGRATE_FLAG    2 // indicates whether beta2 -> RTW migration done.


extern      DISPIF_CALLBACKS g_sCallbacks;



BOOL
IsMigrationComplete(
    HKEY hKey
    );

BOOL
SetMigrationComplete(
    HKEY hKey
    );

BOOL
MigrateWin9xData(
    PST_PROVIDER_HANDLE *phPSTProv,
    HKEY hKeySource,
    HKEY hKeyDestination,
    LPWSTR szUserName9x,
    LPWSTR szUserNameNT     // Windows NT username
    );

BOOL
MigrateWin9xDataRetry(
    PST_PROVIDER_HANDLE *phPSTProv,
    HKEY hKeyDestination,
    LPWSTR szUserName9x,
    LPWSTR szUserNameNT
    );


BOOL
SetRegistrySecurityEnumerated(
    HKEY hKey,
    PSECURITY_DESCRIPTOR pSD
    );

BOOL
SetRegistrySecuritySingle(
    HKEY hKey,
    PSECURITY_DESCRIPTOR pSD
    );


BOOL
MigrateData(
    PST_PROVIDER_HANDLE *phPSTProv,
    BOOL                fMigrationNeeded
    )
{
    LPWSTR szUser = NULL;
    HKEY hKeyUsers = NULL;
    HKEY hKeyUserKey = NULL;
    HKEY hKey = NULL;
    BYTE rgbPwd[A_SHA_DIGEST_LEN];
    LONG lRet;
    DWORD dwDisposition;

    BOOL bUpdateMigrationStatus = FALSE;
    BOOL bSuccess = FALSE;


    // get current user
    if (!g_sCallbacks.pfnFGetUser(
            phPSTProv,
            &szUser))
        goto cleanup;

    //
    // open up the registry key associated with the protected storage
    // note: this opens the old registry location.
    //


    // HKEY_USERS\<Name>

    if(!GetUserHKEY(
                    szUser,
                    KEY_QUERY_VALUE,
                    &hKeyUsers
                    )) {

        if(FIsWinNT())
            goto cleanup;

        //
        // Win95, profiles may be disabled, so go to
        // HKEY_LOCAL_MACHINE\xxx\szContainer
        // see secstor\prov\storage.cpp for details
        //

        hKeyUsers = HKEY_LOCAL_MACHINE;

    }

    // SOFTWARE\Microsoft\...
    // Here, CreateKeyEx is used, because win9x profiles may have been
    // disabled, which leads to a non-existent HKCU ProtectedStorageKey.
    //

    lRet = RegCreateKeyExU(
                    hKeyUsers,
                    REG_PSTTREE_LOC,
                    0,
                    NULL,
                    0,
                    KEY_QUERY_VALUE,
                    NULL,
                    &hKeyUserKey,
                    &dwDisposition
                    );


    //
    // close the intermediate key
    //

    RegCloseKey(hKeyUsers);

    if( lRet != ERROR_SUCCESS ) {
        goto cleanup;
    }


    // ...\<Name>

    lRet = RegOpenKeyExU(
                    hKeyUserKey,
                    szUser,
                    0,
                    KEY_SET_VALUE | KEY_QUERY_VALUE |
                    DELETE | KEY_ENUMERATE_SUB_KEYS, // for failed migration
                    &hKey
                    );

    if(FIsWinNT() && lRet != ERROR_SUCCESS) {
        WCHAR szUserName[ UNLEN + 1 ];
        WCHAR szUserName9x[ UNLEN + 1 ];
        DWORD cch;
        BOOL fRet;

        //
        // get win9x form of username.
        //
        if(!g_sCallbacks.pfnFImpersonateClient( phPSTProv ))
            goto tried_migration;

        cch = sizeof(szUserName) / sizeof( szUserName[0] );
        fRet = GetUserNameW(szUserName, &cch);

        g_sCallbacks.pfnFRevertToSelf( phPSTProv );

        if( !fRet )
            goto tried_migration;

        if(LCMapStringW(
                        LOCALE_SYSTEM_DEFAULT,
                        LCMAP_LOWERCASE,
                        szUserName,
                        cch,
                        szUserName9x,
                        cch) == 0)
            goto tried_migration;


        //
        // failed to open the key:
        // check if win9x migration is necessary.
        //

        if(!MigrateWin9xData( phPSTProv, hKeyUserKey, hKeyUserKey, szUserName9x, szUser )) {
            MigrateWin9xDataRetry( phPSTProv, hKeyUserKey, szUserName9x, szUser );
        }

tried_migration:

        //
        // tried moving any win9x data, so proceed with any other
        // migration activities.
        //

        lRet = RegOpenKeyExU(
                        hKeyUserKey,
                        szUser,
                        0,
                        KEY_SET_VALUE | KEY_QUERY_VALUE |
                        DELETE | KEY_ENUMERATE_SUB_KEYS, // for failed migration
                        &hKey
                        );

    }

    RegCloseKey( hKeyUserKey );

    if( lRet != ERROR_SUCCESS ) {
        goto cleanup;
    }


    //
    // see if migration has already been done.  If so, get out with SUCCESS.
    //

    if( IsMigrationComplete( hKey ) ) {
        bSuccess = TRUE;
        goto cleanup;
    }


    if(fMigrationNeeded) {

        //
        // do the migration
        //

        if(BPVerifyPwd(
            phPSTProv,
            szUser,
            WSZ_PASSWORD_WINDOWS,
            rgbPwd,
            BP_CONFIRM_NONE
            ) == PST_E_WRONG_PASSWORD) {

            //
            // if password could not be changed/verified correctly, nuke existing
            // data.
            //

            DeleteAllUserData( hKey );

        }

    }


    //
    // set the flag to update migration status, regardless of whether migration
    // succeeds.  If it doesn't succeed the first time, it isn't likely to
    // ever succeed, so get on with life.
    //

    bUpdateMigrationStatus = TRUE;

cleanup:

    if(bUpdateMigrationStatus && hKey) {
        SetMigrationComplete( hKey );
    }

    if(szUser != NULL)
        SSFree(szUser);

    if(hKey != NULL)
        RegCloseKey(hKey);

    return bSuccess;
}



BOOL
IsMigrationComplete(
    HKEY hKey
    )
/*++

    This function determines if migration has been performed for the user
    specified by the supplied hKey registry key.

--*/
{
    DWORD dwType;

    DWORD dwMigrationStatus;
    DWORD cbMigrationStatus = sizeof(dwMigrationStatus);
    LONG lRet;

    lRet = RegQueryValueExU(
        hKey,
        L"Migrate",
        NULL,
        &dwType,
        (LPBYTE)&dwMigrationStatus,
        &cbMigrationStatus
        );

    if(lRet != ERROR_SUCCESS)
        return FALSE;

    if(dwType == REG_DWORD && dwMigrationStatus >= MIGRATE_FLAG)
        return TRUE;

    return FALSE;
}


BOOL
SetMigrationComplete(
    HKEY hKey
    )
/*++

    This function sets the data migration flag associated with the user
    specified by the supplied hKey registry key.

    The flag is set to indicate that migration has been completed and no
    future processing is required for this user.

--*/
{
    DWORD dwMigrationStatus = MIGRATE_FLAG;
    DWORD cbMigrationStatus = sizeof(dwMigrationStatus);
    LONG lRet;

    lRet = RegSetValueExU(
        hKey,
        L"Migrate",
        0,
        REG_DWORD,
        (LPBYTE)&dwMigrationStatus,
        cbMigrationStatus
        );

    if(lRet != ERROR_SUCCESS)
        return FALSE;

    return TRUE;
}

BOOL
MigrateWin9xData(
    PST_PROVIDER_HANDLE *phPSTProv,
    HKEY hKeySource,
    HKEY hKeyDestination,
    LPWSTR szUserName9x,
    LPWSTR szUserNameNT     // Windows NT username
    )
{
    HKEY hKeyOldData = NULL;
    HKEY hKeyNewData = NULL;
    DWORD dwDisposition;


    WCHAR szTempPath[ MAX_PATH + 1 ];
    DWORD cchTempPath;
    DWORD cch;

    WCHAR szTempFile[ MAX_PATH + 1 ];
    BOOL fTempFile = FALSE;

    HANDLE hThreadToken = NULL;
    BOOL fRevertToSelf = FALSE;

    BYTE rgbOldPwd[ A_SHA_DIGEST_LEN ];
    BYTE rgbNewPwd[ A_SHA_DIGEST_LEN ];
    BYTE rgbSalt[PASSWORD_SALT_LEN];
    BYTE rgbConfirm[A_SHA_DIGEST_LEN];

    PBYTE   pbMK = NULL;
    DWORD   cbMK;
    BOOL fRemoveImported = FALSE;
    HKEY hKeyMasterKey = NULL;
    HKEY hKeyIntermediate = NULL;

    BOOL fProfilesDisabled = FALSE;

    PSID pLocalSystemSid = NULL;
    PACL pDacl = NULL;


    LONG lRet;
    BOOL fSuccess = FALSE;

    //
    // see if win9x data present.
    //

    lRet = RegOpenKeyExW(
                    hKeySource,
                    szUserName9x,
                    0,
                    KEY_ALL_ACCESS,
                    &hKeyOldData
                    );

    if( lRet != ERROR_SUCCESS )
        return FALSE;


    //
    // attempt decrypt with computed win9x style pwd.
    //

    if( hKeySource != hKeyDestination && lstrcmpW(szUserName9x, L"*Default*") == 0) {

        //
        // win9x profiles were disabled, don't nuke old data either.
        //

        fProfilesDisabled = TRUE;
        if(!FMyGetWinPassword( phPSTProv, L"", rgbOldPwd ))
            goto cleanup;
    } else {

        if(!FMyGetWinPassword( phPSTProv, szUserName9x, rgbOldPwd ))
            goto cleanup;
    }

    lRet = RegOpenKeyExW(
            hKeyOldData,
            L"Data 2",
            0,
            KEY_QUERY_VALUE,
            &hKeyIntermediate
            );

    if( lRet != ERROR_SUCCESS )
        goto cleanup;

    lRet = RegOpenKeyExW(
            hKeyIntermediate,
            WSZ_PASSWORD_WINDOWS,
            0,
            KEY_QUERY_VALUE,
            &hKeyMasterKey
            );

    RegCloseKey( hKeyIntermediate );
    hKeyIntermediate = NULL;

    if( lRet != ERROR_SUCCESS )
        goto cleanup;


    // confirm is just get state and attempt MK decrypt
    if (!FBPGetSecurityStateFromHKEY(
            hKeyMasterKey,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            &pbMK,
            &cbMK
            ))
    {
        goto cleanup;
    }

    RegCloseKey( hKeyMasterKey );
    hKeyMasterKey = NULL;

    // found state; is pwd correct?
    if (!FMyDecryptMK(
                rgbSalt,
                sizeof(rgbSalt),
                rgbOldPwd,
                rgbConfirm,
                &pbMK,
                &cbMK
                ))
    {
        goto cleanup;
    }



    //
    // masterkey is now decrypted.
    //



    //
    // construct temporary file path to hold registry branch.
    //

    cchTempPath = sizeof(szTempPath) / sizeof( szTempPath[0] );
    cch = GetTempPathW(cchTempPath, szTempPath);
    if( cch == 0 || cch > cchTempPath )
        goto cleanup;

    if( GetTempFileNameW( szTempPath, L"PST", 0, szTempFile ) == 0 )
        goto cleanup;

    if(!DeleteFileW( szTempFile ))
        goto cleanup;


    //
    // impersonate self, so we can enable and use backup&restore privs
    // in a thread safe fashion.
    //

    if(!ImpersonateSelf( SecurityImpersonation ))
        goto cleanup;

    fRevertToSelf = TRUE;


    if(!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
                FALSE,
                &hThreadToken
                )) {

        goto cleanup;
    }

    if(!SetPrivilege( hThreadToken, L"SeRestorePrivilege", TRUE ))
        goto cleanup;

    if(!SetPrivilege( hThreadToken, L"SeBackupPrivilege", TRUE ))
        goto cleanup;

    //
    // save registry branch as file.
    //

    lRet = RegSaveKeyW( hKeyOldData, szTempFile, NULL );

    if( lRet != ERROR_SUCCESS )
        goto cleanup;

    fTempFile = TRUE;

    //
    // import branch into new location.
    //

    lRet = RegCreateKeyExW(
                    hKeyDestination,
                    szUserNameNT,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKeyNewData,
                    &dwDisposition
                    );

    if( lRet != ERROR_SUCCESS )
        goto cleanup;


    lRet = RegRestoreKeyW( hKeyNewData, szTempFile, 0 );

    if( lRet != ERROR_SUCCESS )
        goto cleanup;


    //
    // update acls on imported data, since none were present on win9x.
    // note that sebackup & serestore privileges enabled above, which
    // allows REG_OPTION_BACKUP_RESTORE to work.
    //


    while (TRUE) {
        SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
        SECURITY_DESCRIPTOR sd;
        DWORD dwAclSize;

        if(!AllocateAndInitializeSid(
            &sia,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pLocalSystemSid
            )) break;

        //
        // compute size of new acl
        //

        dwAclSize = sizeof(ACL) +
            1 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
            GetLengthSid(pLocalSystemSid) ;

        //
        // allocate storage for Acl
        //

        pDacl = (PACL)SSAlloc(dwAclSize);
        if(pDacl == NULL)
            break;

        if(!InitializeAcl(pDacl, dwAclSize, ACL_REVISION))
            break;

        if(!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            KEY_ALL_ACCESS,
            pLocalSystemSid
            )) break;

        if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
            break;

        if(!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE))
            break;

        SetRegistrySecurityEnumerated(hKeyNewData, &sd);

        // add SYSTEM inherit Ace to base
        SetRegistrySecurity( hKeyNewData );

        break;
    }



    //
    // change existing password data.
    // assume worst case: we fail to change the state, in which case we
    // cleanup the restored registry key.
    //

    if(!FMyGetWinPassword( phPSTProv, szUserNameNT, rgbNewPwd ))
        goto cleanup;

    fRemoveImported = TRUE;

    if (!FMyEncryptMK(
                rgbSalt,
                sizeof(rgbSalt),
                rgbNewPwd,
                rgbConfirm,
                &pbMK,
                &cbMK))
    {
        goto cleanup;
    }

    if (!FBPSetSecurityState(
                szUserNameNT,
                WSZ_PASSWORD_WINDOWS,
                rgbSalt,
                PASSWORD_SALT_LEN,
                rgbConfirm,
                sizeof(rgbConfirm),
                pbMK,
                cbMK))
    {

        goto cleanup;
    }

    fRemoveImported = FALSE;


    //
    // everything went ok: nuke the old data.
    //

    // NTBUG 413234: do not delete old user data, because, user may not
    // have joined domain during Win9x upgrade.  so allow data to migrate
    // again to domain user once joined.
    //

#if 0
    if(!fProfilesDisabled && DeleteAllUserData( hKeyOldData )) {
        RegCloseKey( hKeyOldData );
        hKeyOldData = NULL;
        RegDeleteKeyW( hKeySource, szUserName9x );
    }
#endif

    fSuccess = TRUE;

cleanup:

    if( fTempFile ) {
        DeleteFileW( szTempFile );
    }

    if( fRevertToSelf )
        RevertToSelf();

    if( fRemoveImported ) {
        DeleteAllUserData( hKeyNewData );
        // but leave parent key alone, since it will contain an indicator
        // of a failed attempt, which prevents futile retries.
    }

    if( hThreadToken )
        CloseHandle( hThreadToken );

    if( hKeyOldData )
        RegCloseKey( hKeyOldData );

    if( hKeyNewData )
        RegCloseKey( hKeyNewData );

    if( hKeyMasterKey )
        RegCloseKey( hKeyMasterKey );

    if( hKeyIntermediate )
        RegCloseKey( hKeyIntermediate );

    if ( pbMK ) {
        RtlSecureZeroMemory( pbMK, cbMK );
        SSFree( pbMK );
    }

    if( pLocalSystemSid )
        FreeSid( pLocalSystemSid );

    if( pDacl )
        SSFree( pDacl );

    return fSuccess;
}


BOOL
MigrateWin9xDataRetry(
    PST_PROVIDER_HANDLE *phPSTProv,
    HKEY hKeyDestination,
    LPWSTR szUserName9x,
    LPWSTR szUserNameNT
    )
{
    HKEY hKeyBaseLM = NULL;
    BOOL fSuccess = FALSE;

    // HKLM\SOFTWARE\Microsoft\...

    if(RegOpenKeyExU(
                    HKEY_LOCAL_MACHINE,
                    REG_PSTTREE_LOC,
                    0,
                    KEY_QUERY_VALUE,
                    &hKeyBaseLM
                    ) != ERROR_SUCCESS )
    {
        return FALSE;
    }


    //
    // try HKLM\Username
    // (profiles disabled on win9x)
    //

    fSuccess = MigrateWin9xData( phPSTProv, hKeyBaseLM, hKeyDestination, szUserName9x, szUserNameNT );

    if( !fSuccess ) {

        //
        // try HKLM\*Default*
        // (escape from logon)
        //

        fSuccess = MigrateWin9xData( phPSTProv, hKeyBaseLM, hKeyDestination, L"*Default*", szUserNameNT );
    }

    if( hKeyBaseLM )
        RegCloseKey( hKeyBaseLM );

    return fSuccess;
}


BOOL
SetRegistrySecurityEnumerated(
    HKEY hKey,
    PSECURITY_DESCRIPTOR pSD
    )
{
    LONG rc;

    WCHAR szSubKey[MAX_PATH];
    DWORD dwSubKeyLength;
    DWORD dwSubKeyIndex;
    DWORD dwDisposition;

    dwSubKeyIndex = 0;
    dwSubKeyLength = MAX_PATH;

    //
    // update security on specified key
    //

    if(!SetRegistrySecuritySingle(hKey, pSD))
        return FALSE;

    while((rc=RegEnumKeyExU(
                        hKey,
                        dwSubKeyIndex,
                        szSubKey,
                        &dwSubKeyLength,
                        NULL,
                        NULL,
                        NULL,
                        NULL)
                        ) != ERROR_NO_MORE_ITEMS) { // are we done?

        if(rc == ERROR_SUCCESS)
        {
            HKEY hSubKey;
            LONG lRet;

            lRet = RegCreateKeyExU(
                            hKey,
                            szSubKey,
                            0,
                            NULL,
                            REG_OPTION_BACKUP_RESTORE, // in winnt.h
                            KEY_ENUMERATE_SUB_KEYS | WRITE_DAC,
                            NULL,
                            &hSubKey,
                            &dwDisposition
                            );

            if(lRet != ERROR_SUCCESS)
                return FALSE;


            //
            // recurse
            //
            SetRegistrySecurityEnumerated(hSubKey, pSD);

            RegCloseKey(hSubKey);


            // increment index into the key
            dwSubKeyIndex++;

            // reset buffer size
            dwSubKeyLength=MAX_PATH;

            // Continue the festivities
            continue;
        }
        else
        {
           //
           // note: we need to watch for ERROR_MORE_DATA
           // this indicates we need a bigger szSubKey buffer
           //
            return FALSE;
        }

    } // while


    return TRUE;
}


BOOL
SetRegistrySecuritySingle(
    HKEY hKey,
    PSECURITY_DESCRIPTOR pSD
    )
{
    LONG lRetCode;

    //
    // apply the security descriptor to the registry key
    //

    lRetCode = RegSetKeySecurity(
        hKey,
        (SECURITY_INFORMATION)DACL_SECURITY_INFORMATION,
        pSD
        );

    if(lRetCode != ERROR_SUCCESS)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\misc.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    misc.cpp

Abstract:

    Functionality in this module:

        GetCurrentUser allocating wrapper
        RegQueryValueEx allocating wrapper
        Rule free logic
        pulling the file description from file

Author:

    Matt Thomlinson (mattt) 22-Oct-96
    Scott Field (sfield)    01-Jan-97

--*/


#include <pch.cpp>
#pragma hdrstop


extern DISPIF_CALLBACKS         g_sCallbacks;

//
// Registry Setable Globals, and handlign goo
//

// Must access key via api's
static HKEY g_hProtectedStorageKey = NULL;

static HANDLE g_hProtectedStorageChangeEvent = NULL;

static CRITICAL_SECTION g_csGlobals;

static BOOL g_fcsGlobalsInitialized = FALSE;





// supply a new, delete operator
void * __cdecl operator new(size_t cb)
{
    return SSAlloc( cb );
}

void __cdecl operator delete(void * pv)
{
    SSFree( pv );
}


BOOL FGetCurrentUser(
    PST_PROVIDER_HANDLE* phPSTProv,
    LPWSTR* ppszUser,
    PST_KEY Key)
{
    BOOL fRet = FALSE;

    if (Key == PST_KEY_LOCAL_MACHINE)
    {
        *ppszUser = (LPWSTR)SSAlloc(sizeof(WSZ_LOCAL_MACHINE));
        if( *ppszUser == NULL )
        {
            return FALSE;
        }

        wcscpy(*ppszUser, WSZ_LOCAL_MACHINE);
    }
    else
    {
        // get current user
        if (!g_sCallbacks.pfnFGetUser(
                phPSTProv,
                ppszUser))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    return fRet;
}


BOOL FStringIsValidItemName(LPCWSTR szTrialString)
{
    // local define
    #define WCH_INVALID_CHAR1 L'\\'

    while(  *szTrialString &&
            (*szTrialString != WCH_INVALID_CHAR1)          )
        szTrialString++;

    // valid=TRUE if we're at the end of the string
    return (*szTrialString == L'\0');
}

// get registry wrapper
DWORD RegGetValue(HKEY hItemKey,
                 LPWSTR szItem,
                 PBYTE* ppb,
                 DWORD* pcb)
{
    // local define
    #define FASTBUFSIZE 64
/*
FASTBUFSIZE from purely empirical testing (2 tpstorec.exe, 1 perform.exe)
    bytes       num requests

    16          1437
    18          22
    20          928
    22          18
    24          2
    32          9
    40          106
    42          700
    48          500
    56          928
    64          718
->
    72          100
    256         500

set cache size at 64. (mattt, 2/3/97)
*/

    DWORD dwRet;
    DWORD dwType;

    BYTE rgbFastBuf[FASTBUFSIZE];   // try using a static buffer

    BOOL fAllocated = FALSE;
    *pcb = FASTBUFSIZE;

    dwRet =
        RegQueryValueExU(
            hItemKey,
            szItem,
            0,
            &dwType,
            rgbFastBuf,
            pcb);

    if (dwRet == ERROR_SUCCESS)
    {
        // fastbuf was large enough
        *ppb = (PBYTE)SSAlloc(*pcb);
        if(*ppb == NULL)
        {
            dwRet = (DWORD)PST_E_FAIL;
            goto Ret;
        }

        CopyMemory(*ppb, rgbFastBuf, *pcb);
    }
    else if (dwRet == ERROR_MORE_DATA)
    {
        // didn't fit into fastbuf -- alloc exact size, query
        *ppb = (PBYTE)SSAlloc(*pcb);
        if(*ppb == NULL)
        {
            dwRet = (DWORD)PST_E_FAIL;
            goto Ret;
        }

        fAllocated = TRUE;

        if (ERROR_SUCCESS != (dwRet =
            RegQueryValueExU(
                hItemKey,
                szItem,
                0,
                &dwType,
                *ppb,
                pcb)) )
            goto Ret;
    }
    else
        goto Ret;


    dwRet = PST_E_OK;
Ret:

    if( dwRet != PST_E_OK && fAllocated ) {
        SSFree( *ppb );
        *ppb = NULL;
    }

    return dwRet;
}


// get registry wrapper
DWORD RegGetStringValue(
                 HKEY hItemKey,
                 LPWSTR szItem,
                 PBYTE* ppb,
                 DWORD* pcb)
{
    DWORD dwRet;
    DWORD dwType;

    BYTE rgbFastBuf[FASTBUFSIZE];   // try using a static buffer

    BOOL fAllocated = FALSE;
    *pcb = FASTBUFSIZE;

    dwRet =
        RegQueryValueExU(
            hItemKey,
            szItem,
            0,
            &dwType,
            rgbFastBuf,
            pcb);

    if (dwRet == ERROR_SUCCESS)
    {
        // fastbuf was large enough
        *ppb = (PBYTE)SSAlloc(*pcb);
        if(*ppb == NULL)
        {
            dwRet = (DWORD)PST_E_FAIL;
            goto Ret;
        }

        CopyMemory(*ppb, rgbFastBuf, *pcb);
    }
    else if (dwRet == ERROR_MORE_DATA)
    {
        // didn't fit into fastbuf -- alloc exact size, query
        *ppb = (PBYTE)SSAlloc(*pcb);
        if(*ppb == NULL)
        {
            dwRet = (DWORD)PST_E_FAIL;
            goto Ret;
        }

        fAllocated = TRUE;

        if (ERROR_SUCCESS != (dwRet =
            RegQueryValueExU(
                hItemKey,
                szItem,
                0,
                &dwType,
                *ppb,
                pcb)) )
            goto Ret;
    }
    else
        goto Ret;

    // Make sure that the data type is a zero-terminated one.
    if((dwType != REG_SZ) &&
       (dwType != REG_MULTI_SZ) && 
       (dwType != REG_EXPAND_SZ))
    {
        dwRet = (DWORD)PST_E_INVALID_STRING;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:

    if( dwRet != PST_E_OK && fAllocated ) {
        SSFree( *ppb );
        *ppb = NULL;
    }

    return dwRet;
}


#if 0

void FreeRuleset(
        PST_ACCESSRULESET *psRules)
{
    PST_ACCESSCLAUSE* pClause;

    if (psRules == NULL)
        return;

    for (DWORD cRule=0; cRule<psRules->cRules; cRule++)
    {
        // for each Rule in Ruleset, walk all clauses and free assoc pb
        for (DWORD cClause=0; cClause<psRules->rgRules[cRule].cClauses; cClause++)
        {
            pClause = &psRules->rgRules[cRule].rgClauses[cClause];

            if (NULL != pClause->pbClauseData)
                SSFree(pClause->pbClauseData);
        }

        // now free rgClause
        SSFree(psRules->rgRules[cRule].rgClauses);
    }

    // now free rgRules
    SSFree(psRules->rgRules);
}

#endif

BOOL
GetFileDescription(
    LPCWSTR szFile,
    LPWSTR *FileDescription
    )
/*++

Routine Description:

    This function obtains the localized version resource, file description
    string from a specified file.  The input and output parameters are
    both Unicode, and as a result, this requires some "thunking" magic
    for Win95.

Arguments:

    szFile - Pointer to file name (full path if appropriate) to obtain
        the localized file description string from.

    FileDescription - Returns a pointer to an allocated, localized file
        description string associated with the specified file.

Return Value:

    TRUE - success.  Caller must free buffer specified by the FileDescription
        parameter.
    FALSE - error.

Author:

    Scott Field (sfield)    02-Jan-97

--*/
{

    LPCVOID FileName;
    CHAR FileNameA[MAX_PATH];

    DWORD dwVerInfoSize;
    DWORD dwHandle;
    LPVOID VerInfo;

    LPVOID lpBuffer;
    UINT puLen;

    DWORD dwLanguageId;

    LPVOID Trans;
    LPVOID StringFileInfo;
    LPVOID Language;

    CHAR StringFileInfoA[] = "\\StringFileInfo\\%04X%04X\\FileDescription";
    WCHAR StringFileInfoW[] = L"\\StringFileInfo\\%04X%04X\\FileDescription";

    CHAR LanguageA[sizeof(StringFileInfoA)/sizeof(CHAR)];
    WCHAR LanguageW[sizeof(StringFileInfoW)/sizeof(WCHAR)];

    LANGID LangDefault;
    BOOL bSuccess = FALSE;

    typedef BOOL (WINAPI GETFILEVERSIONINFOSIZE)(LPCVOID, LPDWORD);
    typedef BOOL (WINAPI GETFILEVERSIONINFO)(LPCVOID, DWORD, DWORD, LPVOID);
    typedef int (cdecl WSPRINTF)(LPVOID, LPVOID, ...);
    typedef BOOL (WINAPI VERQUERYVALUE)(LPVOID, LPVOID, LPVOID *, PUINT);

    GETFILEVERSIONINFOSIZE *_GetFileVersionInfoSize;
    GETFILEVERSIONINFO *_GetFileVersionInfo;
    WSPRINTF *_wsprintf;
    VERQUERYVALUE *_VerQueryValue;

    static BOOL fLoadedVersionDll = FALSE;
    static FARPROC _GetFileVersionInfoSizeW;
    static FARPROC _GetFileVersionInfoW;
    static FARPROC _VerQueryValueW;
    static FARPROC _GetFileVersionInfoSizeA;
    static FARPROC _GetFileVersionInfoA;
    static FARPROC _VerQueryValueA;


    *FileDescription = NULL;

    if( !fLoadedVersionDll ) {
        HMODULE hVersionDll = LoadLibraryU(L"version.dll");

        if( hVersionDll == NULL )
            return FALSE;

        if(FIsWinNT()) {

            _GetFileVersionInfoSizeW = GetProcAddress(hVersionDll, "GetFileVersionInfoSizeW");
            if(_GetFileVersionInfoSizeW == NULL)
                return FALSE;

            _GetFileVersionInfoW = GetProcAddress(hVersionDll, "GetFileVersionInfoW");
            if(_GetFileVersionInfoW == NULL)
                return FALSE;

            _VerQueryValueW = GetProcAddress(hVersionDll, "VerQueryValueW");
            if(_VerQueryValueW == NULL)
                return FALSE;

        } else {
            _GetFileVersionInfoSizeA = GetProcAddress(hVersionDll, "GetFileVersionInfoSizeA");
            if(_GetFileVersionInfoSizeA == NULL)
                return FALSE;

            _GetFileVersionInfoA = GetProcAddress(hVersionDll, "GetFileVersionInfoA");
            if(_GetFileVersionInfoA == NULL)
                return FALSE;

            _VerQueryValueA = GetProcAddress(hVersionDll, "VerQueryValueA");
            if(_VerQueryValueA == NULL)
                return FALSE;
        }

        fLoadedVersionDll = TRUE;
    }

    //
    // could win95 be any more annoying?
    //

    if(FIsWinNT()) {
        _GetFileVersionInfoSize = (GETFILEVERSIONINFOSIZE*)_GetFileVersionInfoSizeW;
        _GetFileVersionInfo = (GETFILEVERSIONINFO*)_GetFileVersionInfoW;
        _wsprintf = (WSPRINTF *)wsprintfW;
        _VerQueryValue = (VERQUERYVALUE*)_VerQueryValueW;
        Trans = L"\\VarFileInfo\\Translation";
        StringFileInfo = StringFileInfoW;
        Language = LanguageW;
        FileName = szFile; // use unicode input
    } else {
        _GetFileVersionInfoSize = (GETFILEVERSIONINFOSIZE*)_GetFileVersionInfoSizeA;
        _GetFileVersionInfo = (GETFILEVERSIONINFO*)_GetFileVersionInfoA;
        _wsprintf = (WSPRINTF *)wsprintfA;
        _VerQueryValue = (VERQUERYVALUE*)_VerQueryValueA;
        Trans = "\\VarFileInfo\\Translation";
        StringFileInfo = StringFileInfoA;
        Language = LanguageA;
        FileName = FileNameA;

        // convert unicode input to ANSI
        if(WideCharToMultiByte(
                    CP_ACP,
                    0,
                    szFile,
                    -1,
                    (LPSTR)FileName,
                    MAX_PATH,
                    NULL,
                    NULL
                    ) == 0) {

                return FALSE;
            }
    }

    dwVerInfoSize = _GetFileVersionInfoSize(FileName, &dwHandle);
    if(dwVerInfoSize == 0)
        return FALSE;

    VerInfo = SSAlloc(dwVerInfoSize);
    if(VerInfo == NULL)
        return FALSE;

    if(!_GetFileVersionInfo(FileName, dwHandle, dwVerInfoSize, VerInfo))
        goto cleanup;

    //
    // first, try current language
    //

    LangDefault = GetUserDefaultLangID();

    _wsprintf( Language, StringFileInfo, LangDefault, 1200);

    if(_VerQueryValue(VerInfo, Language, &lpBuffer, &puLen)) {
        goto success;
    }

    //
    // try languages in translation table
    //

    if(_VerQueryValue(VerInfo, Trans, &lpBuffer, &puLen)) {
        DWORD dwTranslationCount = puLen / sizeof(DWORD);
        DWORD dwIndexTranslation;

        for(dwIndexTranslation = 0 ;
            dwIndexTranslation < dwTranslationCount ;
            dwIndexTranslation++ ) {

            DWORD LangID, CharSetID;

            LangID = LOWORD( ((DWORD*)lpBuffer)[dwIndexTranslation] );
            CharSetID = HIWORD( ((DWORD*)lpBuffer)[dwIndexTranslation] );

            _wsprintf(Language, StringFileInfo, LangID, CharSetID);

            if(_VerQueryValue(VerInfo, Language, &lpBuffer, &puLen)) {
                goto success;
            }
        } // for
    }

    //
    // try english, Unicode if we didn't already
    //

    if(LangDefault != MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)) {
        _wsprintf(Language, StringFileInfo,
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
            1200);

        if(_VerQueryValue(VerInfo, Language, &lpBuffer, &puLen)) {
            goto success;
        }
    }

    //
    // try english, code page 1252
    //

    _wsprintf(Language, StringFileInfo,
        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
        1252);

    if(_VerQueryValue(VerInfo, Language, &lpBuffer, &puLen)) {
        goto success;
    }

    //
    // try english, code page 0000
    //

    _wsprintf(Language, StringFileInfo,
        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
        0);

    if(_VerQueryValue(VerInfo, Language, &lpBuffer, &puLen)) {
        goto success;
    }



    //
    // failed! skip to cleanup
    //

    goto cleanup;

success:

    *FileDescription = (LPWSTR)SSAlloc((puLen + 1) * sizeof(WCHAR));
    if(*FileDescription == NULL)
        goto cleanup;

    bSuccess = TRUE; // assume success

    if(FIsWinNT()) {
        wcscpy(*FileDescription, (LPWSTR)lpBuffer);
    } else {

        if(MultiByteToWideChar(
                CP_ACP,
                0,
                (LPSTR)lpBuffer,
                puLen,
                *FileDescription,
                puLen
                ) == 0) {

            bSuccess = FALSE;
        }
    }

cleanup:

    if(!bSuccess && *FileDescription) {
        SSFree(*FileDescription);
        *FileDescription = NULL;
    }

    SSFree(VerInfo);

    return bSuccess;
}

void MyToUpper(LPWSTR szInBuf)
{
    DWORD cch = WSZ_BYTECOUNT(szInBuf);
    LPWSTR szUpperCase = (LPWSTR)LocalAlloc(LMEM_FIXED, cch);

    LCMapStringU(
        LOCALE_SYSTEM_DEFAULT,
        LCMAP_UPPERCASE,
        szInBuf,
        -1,
        szUpperCase,
        cch);

    // no growth or shrinkage
    SS_ASSERT(wcslen(szInBuf) == wcslen(szUpperCase));

    // mash back into passed-in buffer
    wcscpy(szInBuf, szUpperCase);
    LocalFree(szUpperCase);
}


// cached authentication list
extern              CUAList*            g_pCUAList;

BOOL
FIsCachedPassword(
    LPCWSTR     szUser,
    LPCWSTR     szPassword,
    LUID*       pluidAuthID
    )
{
    // see if this MK has been cached
    UACACHE_LIST_ITEM li;
    if(NULL == g_pCUAList)
    {
        return FALSE;
    }

    CreateUACacheListItem(
            &li,
            szUser,
            szPassword,
            pluidAuthID
            );

    // TRUE if cached
    return (NULL != g_pCUAList->SearchList(&li));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\pch.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pch.cpp

Abstract:

    pch header files


Author:

    petesk 2/2/2000

Revision History:

    

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>

#include <shlobj.h>


// crypto headers
#include <sha.h>
#include <rc4.h>
#include <des.h>
#include <tripldes.h>
#include <modes.h>
#include <crypt.h>
#include <wincrypt.h>


#include "pstypes.h"
#include "dpapiprv.h"     // for registry entries
#include "pstprv.h"     // for registry entries
#include "pmacros.h"
#include "pstdef.h"

#include "unicode.h"
#include "unicode5.h"
#include "guidcnvt.h"
#include "secmisc.h"
#include "debug.h"
#include "primitiv.h"

#include "lnklist.h"
#include "misc.h"
#include "prov.h"
#include "secure.h"
#include "resource.h"
#include "dispif.h"

#pragma hdrstop


//#include "keyrpc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\prov.h ===
///////////////////////////////////////////////////////////////////////////////
// Base provider defines

#define WSZ_NULLSTRING          L""

// UI behavior types
#define BP_CONFIRM_NONE            0x00000002   // never ask for pwd 
#define BP_CONFIRM_PASSWORDUI      0x00000004   // password
#define BP_CONFIRM_OKCANCEL        0x00000008   // ok / cancel box


#define WSZ_PASSWORD_WINDOWS    L"Windows"

#define WSZ_LOCAL_MACHINE       L"*Local Machine*"
// #define WSZ_LOCALMACHINE_MKNAME L"Machine Default"

static 
BYTE RGB_LOCALMACHINE_KEY[] = 
    {  0x12, 0x60, 0xBF, 0x5C, 0x0B, 
       0x36, 0x7E, 0x1B, 0xFE, 0xF9,
       0xFC, 0x6B, 0x25, 0x36, 0x99,
       0x98, 0x5A, 0xCB, 0xB2, 0x8C };


// UNDONE UNDONE:
// make this live in general protected storage config area

#define PST_BASEPROV_SUBTYPE_STRING     L"MS Base Provider"
// 7F019FC0-AAC0-11d0-8C68-00C04FC297EB 
#define PST_BASEPROV_SUBTYPE_GUID                       \
{                                                       \
    0x7f019fc0,                                         \
    0xaac0,                                             \
    0x11d0,                                             \
    { 0x8c, 0x68, 0x0, 0xc0, 0x4f, 0xc2, 0x97, 0xeb }   \
}

// items that live in the base provider config area
#define WSZ_CONFIG_USERCONFIRM_DEFAULTS    L"User Confirmation Defaults"



//////////////////
// Protect APIs

// stored at base protect key
#define     REGSZ_DEFAULT_ALLOW_CACHEPW         L"AllowCachePW"

// stored at provider subkey
#define     REGSZ_DEFAULT_ENCR_ALG              L"Encr Alg"
#define     REGSZ_DEFAULT_MAC_ALG               L"MAC Alg"
#define     REGSZ_DEFAULT_ENCR_ALG_KEYSIZE      L"Encr Alg Key Size"
#define     REGSZ_DEFAULT_MAC_ALG_KEYSIZE       L"MAC Alg Key Size"
#define     REGSZ_DEFAULT_CRYPT_PROV_TYPE       L"Default CSP Type"

BOOL FInitProtectAPIGlobals();
BOOL FDeleteProtectAPIGlobals();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\prov.cpp ===
/*
    File:       Prov.cpp

    Title:      Protected Storage Base Provider
    Author:     Matt Thomlinson
    Date:       10/22/96

    Protected storage is an area to safely store user belongings.
    This storage is available on both NT and Win95, and offers finer
    granularity over access than do NT ACLs.

    The PStore architecture resembles the CryptoAPI provider architecture.
    The PStore server, PStoreS, takes requests and forwards them to any one
    of a number of providers, of which PSBase is a single instance. (The
    server exports some basic functionality to ease the pain of provider
    writers, like impersonating the caller and checking access rules.) The
    server gets requests through LPC from a client (PStoreC.dll),
    which wraps a number of operations into a COM object.

    The base provider supports user storage, where items are stored under
    the namespace of which user called protected storage, and local machine
    storage, a global area that can be accessed by everyone.

    Rules can be set on subtypes describing under what conditions accesses
    are allowed. Rules can specify callers be Authenticode signed, callers
    simply be unmodified from access to access, and normal (arbitrary) NT Acls
    be satisfied.

    In addition, items stored in the user namespace have user authentication
    by default, where the user gets to specify what type of user
    confirmation they want to see appear. This confirmation could be
    no confirmation, an ok/cancel dialog, a password, a retinal scan, a
    fingerprint, etc.

    The base provider stores items in the registry, DES-encrypted with a
    key derived from the user password. Items are also integrity-protected
    by a keyed MAC.

    Interoperability and transport issues are solved by adding a provider
    supporting the PFX interchange format.

    The base provider is slightly more special than all other providers, since
    the server stores bootstrap configuration data here. (The base provider
    is guaranteed to always be present). The configuration data includes
    what other providers are ok to be loaded.

*/

#include <pch.cpp>
#pragma hdrstop


#include "provif.h"
#include "provui.h"
#include "storage.h"

#include "passwd.h"


// sfield: legacy migration hack
#include "migrate.h"


BOOL                g_fAllowCachePW = TRUE;

// fwd (secure.cpp)
BOOL FIsEncryptionPermitted();


HINSTANCE           g_hInst = NULL;
BOOL                g_fImagesIntegrid = FALSE;

DISPIF_CALLBACKS    g_sCallbacks;
BOOL                g_fCallbacksInitialized = FALSE;

PRIVATE_CALLBACKS   g_sPrivateCallbacks;

CUAList*            g_pCUAList = NULL;
COpenItemList*      g_pCOpenItemList = NULL;
CCryptProvList*     g_pCProvList = NULL;

extern CRITICAL_SECTION g_csUIInitialized;


/////////////////////////////////////////////////////////////////////////
// Very important to hook DllMain, do caller authentication



BOOL   WINAPI   DllMain (HMODULE hInst,
                        ULONG ul_reason_for_call,
                        LPVOID lpReserved)
{
    switch( ul_reason_for_call )
    {
    case DLL_PROCESS_ATTACH:
        {

        g_hInst = hInst;
        InitializeCriticalSection( &g_csUIInitialized );

        //
        // just hard-code image verification succeeded.
        //

        g_fImagesIntegrid = TRUE;


        // set up global lists
        g_pCUAList = new CUAList;
        if(g_pCUAList)
        {
            if(!g_pCUAList->Initialize())
            {
                delete g_pCUAList;
                g_pCUAList = NULL;
            }
        }

        g_pCOpenItemList = new COpenItemList;
        if(g_pCOpenItemList)
        {
            if(!g_pCOpenItemList->Initialize())
            {
                delete g_pCOpenItemList;
                g_pCOpenItemList = NULL;
            }
        }

        g_pCProvList = new CCryptProvList;
        if(g_pCProvList)
        {
            if(!g_pCProvList->Initialize())
            {
                delete g_pCProvList;
                g_pCProvList = NULL;
            }
        }




        DisableThreadLibraryCalls(hInst);

        // call EncryptionPermitted routine once to initialize globals
        FIsEncryptionPermitted();
        FInitProtectAPIGlobals();


        break;
        }

    case DLL_PROCESS_DETACH:

        // tear down global lists
        if(g_pCUAList)
        {
            delete g_pCUAList;
            g_pCUAList = NULL;
        }

        if(g_pCOpenItemList)
        {
            delete g_pCOpenItemList;
            g_pCOpenItemList = NULL;
        }

        if(g_pCProvList)
        {
            delete g_pCProvList;
            g_pCProvList = NULL;
        }

        ReleaseUI();



        DeleteCriticalSection( &g_csUIInitialized );

        break;

    default:
        break;
    }

    return TRUE;
}


HRESULT        SPProviderInitialize(
        DISPIF_CALLBACKS *psCallbacks)
{
    // only allow one initialization (security check)
    if (g_fCallbacksInitialized)
        return PST_E_FAIL;

    if( psCallbacks->cbSize < sizeof(DISPIF_CALLBACKS) )
        return PST_E_FAIL;

    // tuck these callback fxns for later use
    CopyMemory(&g_sCallbacks, psCallbacks, sizeof(DISPIF_CALLBACKS));

    // now, get the private callbacks from the server
    DWORD cbPrivateCallbacks = sizeof(g_sPrivateCallbacks);

    if(!g_sCallbacks.pfnFGetServerParam(
            NULL,
            SS_SERVERPARAM_CALLBACKS,
            &g_sPrivateCallbacks,
            &cbPrivateCallbacks
            ))
            return PST_E_FAIL;

    if(g_sPrivateCallbacks.cbSize != sizeof(g_sPrivateCallbacks))
        return PST_E_FAIL;

    g_fCallbacksInitialized = TRUE;

    return PST_E_OK;
}


HRESULT        SPAcquireContext(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD   dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    BOOL fExisted = FALSE;
    LPWSTR szUser = NULL;

    HKEY hUserKey = NULL;
    BOOL fUserExisted;

    if(!InitUI())
        return FALSE;


    if (0 != dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!g_sCallbacks.pfnFGetUser(
            phPSTProv,
            &szUser))
        goto Ret;

    //
    // migrate password data.  This doesn't do anything internally if migration
    // already took place.
    //

    MigrateData(phPSTProv, TRUE);

    // One-Time WinPW Init Code
    if (!BPMasterKeyExists(
            szUser,
            WSZ_PASSWORD_WINDOWS))
    {
        BYTE rgbPwd[A_SHA_DIGEST_LEN];

        // Init the Users' Windows password entry
        if (!FMyGetWinPassword(
                phPSTProv,
                szUser,
                rgbPwd
                ))
            goto Ret;

        if (!FCheckPWConfirm(
                szUser,
                WSZ_PASSWORD_WINDOWS,
                rgbPwd))
            goto Ret;

        //
        // newly created key: data migration is not necessary.
        // specify that only the migration flag need be updated
        //

        MigrateData(phPSTProv, FALSE);
    }


    dwRet = PST_E_OK;
Ret:
    if (hUserKey)
        RegCloseKey(hUserKey);

    if (szUser)
        SSFree(szUser);

    return dwRet;

}

HRESULT        SPReleaseContext(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD   dwFlags)
{
    return PST_E_OK;
}

HRESULT        SPGetProvInfo(
        PPST_PROVIDERINFO*   ppPSTInfo,
        DWORD           dwFlags)
{
    HRESULT hr = PST_E_FAIL;

    if (0 != dwFlags)
        return PST_E_BAD_FLAGS;

    // Note: not linked to a specific context (hPSTProv)
    // Note: caller not verified -- give this info to anyone

    PPST_PROVIDERINFO pPSTInfo;
    if (NULL == (pPSTInfo = (PST_PROVIDERINFO*)SSAlloc(sizeof(PST_PROVIDERINFO))) )
        return PST_E_FAIL;
    ZeroMemory(pPSTInfo, sizeof(PST_PROVIDERINFO));


    pPSTInfo->cbSize = sizeof(PST_PROVIDERINFO);
    GUID guidBaseProvider = MS_BASE_PSTPROVIDER_ID;
    CopyMemory(&pPSTInfo->ID, &guidBaseProvider, sizeof(pPSTInfo->ID));

    pPSTInfo->Capabilities = PST_PC_ROAMABLE;

    if (NULL == (pPSTInfo->szProviderName = (LPWSTR)SSAlloc(sizeof(MS_BASE_PSTPROVIDER_NAME))) )
        goto Ret;
    wcscpy(pPSTInfo->szProviderName, MS_BASE_PSTPROVIDER_NAME);

    hr = PST_E_OK;
Ret:
    if (hr != PST_E_OK)
    {
        if (pPSTInfo->szProviderName)
            SSFree(pPSTInfo->szProviderName);

        SSFree(pPSTInfo);
        pPSTInfo = NULL;
    }

    // in either case, return pPSTInfo
    *ppPSTInfo = pPSTInfo;

    return hr;
}


HRESULT     SPGetProvParam(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD           dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */
                BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */  DWORD           dwFlags)
{

    if( pcbData )
        *pcbData = 0;

    switch(dwParam)
    {

        case PST_PP_FLUSH_PW_CACHE:
        {
            return PST_E_OK;
        }

        default:
        {
            return PST_E_NYI;
        }

    }
}


HRESULT     SPSetProvParam(
    /* [in] */  PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */  DWORD           dwParam,
    /* [in] */  DWORD           cbData,
    /* [in] */  BYTE*           pbData,
    /* [in] */  DWORD           dwFlags)
{
    HRESULT hr = PST_E_OK;

    switch(dwParam)
    {
    case PST_PP_FLUSH_PW_CACHE:
        {
            if(g_pCUAList)
            {
                g_pCUAList->Reset();
                hr = PST_E_OK;
            }
            else
                hr = PST_E_FAIL;
            break;
        }

    default:
        {
            hr = PST_E_NYI;
            break;
        }
    }

    return hr;
}



HRESULT        SPEnumTypes(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [out] */ GUID *pguidType,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        BPEnumTypes(
            szUser,
            dwIndex,
            pguidType)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT         SPGetTypeInfo(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ PPST_TYPEINFO *ppinfoType,
    /* [in] */ DWORD dwFlags)
{
    PST_TYPEINFO infoType = {sizeof(PST_TYPEINFO)};
    *ppinfoType = NULL;

    LPWSTR szUser = NULL;
    HRESULT dwRet = PST_E_FAIL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        BPGetTypeName(
            szUser,
            pguidType,
            &infoType.szDisplayName)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (dwRet == PST_E_OK)
    {
        *ppinfoType = (PPST_TYPEINFO)SSAlloc(sizeof(PST_TYPEINFO));
        if(NULL != *ppinfoType)
        {
            CopyMemory(*ppinfoType, &infoType, sizeof(PST_TYPEINFO));
        }
    }

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT        SPEnumSubtypes(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [out] */ GUID *pguidSubtype,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        BPEnumSubtypes(
            szUser,
            dwIndex,
            pguidType,
            pguidSubtype)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT         SPGetSubtypeInfo(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ PPST_TYPEINFO *ppinfoSubtype,
    /* [in] */ DWORD dwFlags)
{
    *ppinfoSubtype = NULL;
    PST_TYPEINFO infoSubtype = {sizeof(PST_TYPEINFO)};

    LPWSTR szUser = NULL;
    HRESULT dwRet = PST_E_FAIL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        BPGetSubtypeName(
            szUser,
            pguidType,
            pguidSubtype,
            &infoSubtype.szDisplayName)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (dwRet == PST_E_OK)
    {
        *ppinfoSubtype = (PPST_TYPEINFO)SSAlloc(sizeof(PST_TYPEINFO));
        if(NULL != *ppinfoSubtype)
        {
            CopyMemory(*ppinfoSubtype, &infoSubtype, sizeof(PST_TYPEINFO));
        }
    }

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT        SPEnumItems(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [out] */ LPWSTR *ppszItemName,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }


    if (PST_E_OK != (dwRet =
        BPEnumItems(
            szUser,
            pguidType,
            pguidSubtype,
            dwIndex,
            ppszItemName)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT        SPCreateType(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ PPST_TYPEINFO pinfoType,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // Check for invalid "" input
    if (pinfoType == NULL ||
        pinfoType->szDisplayName == NULL ||
        (wcslen(pinfoType->szDisplayName) == 0)
        )
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // if fail or already exist, fail!
    if (PST_E_OK != (dwRet =
        BPCreateType(
            szUser,
            pguidType,
            pinfoType)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:

    // if creation didn't happen, item shouldn't exist
    if ((dwRet != PST_E_OK) && (dwRet != PST_E_TYPE_EXISTS))
        BPDeleteType(szUser, pguidType);

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT SPDeleteType(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // if fail or not empty, fail!
    if (PST_E_OK != (dwRet =
        BPDeleteType(
            szUser,
            pguidType)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT        SPCreateSubtype(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ PPST_TYPEINFO pinfoSubtype,
    /* [in] */ PPST_ACCESSRULESET psRules,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR  szUser = NULL;


    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags != 0)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // NULL Rules
    if (psRules == NULL)
    {
        dwRet = PST_E_INVALID_RULESET;
        goto Ret;
    }

    if (pinfoSubtype == NULL)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // Check for invalid "" input
    if (pinfoSubtype->szDisplayName == NULL || wcslen(pinfoSubtype->szDisplayName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // if fail or already exist, fail!
    if (PST_E_OK != (dwRet =
        BPCreateSubtype(
            szUser,
            pguidType,
            pguidSubtype,
            pinfoSubtype)) )
        goto Ret;


    dwRet = PST_E_OK;
Ret:
    // if creation didn't happen, item shouldn't exist
    if ((dwRet != PST_E_OK) && (dwRet != PST_E_TYPE_EXISTS))
        BPDeleteSubtype(szUser, pguidType, pguidSubtype);

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT SPDeleteSubtype(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    LPWSTR szUser = NULL;

    PST_ACCESSRULESET sRules = {sizeof(sRules), 0, NULL};

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }


    // if fail or not empty, fail!
    if (PST_E_OK != (dwRet =
        BPDeleteSubtype(
            szUser,
            pguidType,
            pguidSubtype)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:

    if (szUser)
        SSFree(szUser);

    return dwRet;
}

HRESULT     SPWriteItem(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID  *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE *pbData,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;

    // assume we've made no change
    BOOL    fExisted = TRUE;
    LPWSTR  szUser = NULL;

    PST_ACCESSRULESET sRules = {sizeof(sRules), 0, NULL};

    BYTE rgbPwd[A_SHA_DIGEST_LEN];
    LPWSTR szMasterKey = NULL;

    LPWSTR szType=NULL, szSubtype=NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if ((dwFlags & ~(PST_UNRESTRICTED_ITEMDATA | PST_NO_OVERWRITE
        )) != 0)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    if ((dwDefaultConfirmationStyle & ~( PST_CF_DEFAULT |
                                    PST_CF_NONE
        )) != 0)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    if (psPrompt == NULL)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // Disable UI on write item.
    dwDefaultConfirmationStyle = PST_CF_NONE;
    if(psPrompt != NULL)
    {
        psPrompt->dwPromptFlags = 0;
    }

    // Check for invalid "" input
    if (wcslen(szItemName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (dwFlags & PST_UNRESTRICTED_ITEMDATA)
    {
        // store insecure data stream
        if (PST_E_OK != (dwRet =
            BPSetInsecureItemData(
                szUser,
                pguidType,
                pguidSubtype,
                szItemName,
                pbData,
                cbData)) )
            goto Ret;

        dwRet = PST_E_OK;
        goto Ret;
    }

    // ELSE: secure stream

    {
        POPENITEM_LIST_ITEM pli;

        OPENITEM_LIST_ITEM li;
        if(NULL == g_pCOpenItemList)
        {
            dwRet = PST_E_FAIL;
            goto Ret;
        }
        CreateOpenListItem(&li, phPSTProv, Key, pguidType, pguidSubtype, szItemName);

        g_pCOpenItemList->LockList();

        // get opened (cached) item
        pli = g_pCOpenItemList->SearchList(&li);

        if ((pli != NULL) && (pli->ModeFlags & PST_WRITE) )
        {
            // Error if cached (it must exist) and "No Overwrite" specified
            if (dwFlags & PST_NO_OVERWRITE)
            {
                g_pCOpenItemList->UnlockList();
                dwRet = PST_E_ITEM_EXISTS;
                goto Ret;
            }

            // found cached item; pull real pwd
            CopyMemory(rgbPwd, pli->rgbPwd, A_SHA_DIGEST_LEN);
            szMasterKey = (LPWSTR) SSAlloc(WSZ_BYTECOUNT(pli->szMasterKey));

            if( szMasterKey )
                wcscpy(szMasterKey, pli->szMasterKey);

            //
            // unlock list.
            //

            g_pCOpenItemList->UnlockList();

            if( szMasterKey == NULL ) {
                dwRet = E_OUTOFMEMORY;
                goto Ret;
            }

            // PST_PF_ALWAYS_SHOW always forces UI
            if (PST_PF_ALWAYS_SHOW == psPrompt->dwPromptFlags)
            {
                // retrieve names of type, subtype
                if (PST_E_OK != (dwRet =
                    BPGetTypeName(
                        szUser,
                        pguidType,
                        &szType)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    BPGetSubtypeName(
                        szUser,
                        pguidType,
                        pguidSubtype,
                        &szSubtype)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    ShowOKCancelUI(
                        phPSTProv,
                        szUser,
                        Key,
                        szType,
                        szSubtype,
                        szItemName,
                        psPrompt,
                        g_PromptWriteItem)) )
                    goto Ret;
            }
        }
        else
        {
            //
            // unlock list.
            //

            g_pCOpenItemList->UnlockList();

            // not cached; do actual work

            // if fail or already exist
            if (PST_E_OK != (dwRet =
                BPCreateItem(
                    szUser,
                    pguidType,
                    pguidSubtype,
                    szItemName)) )
            {

                // on "No Overwrite", hr has right error code
                if (dwFlags & PST_NO_OVERWRITE)
                    goto Ret;

                // else swallow overwrite error
                if (dwRet != PST_E_ITEM_EXISTS)
                    goto Ret;
            }

            fExisted = (dwRet == PST_E_ITEM_EXISTS);

            // retrieve names of type, subtype
            if (PST_E_OK != (dwRet =
                BPGetTypeName(
                    szUser,
                    pguidType,
                    &szType)) )
                goto Ret;

            if (PST_E_OK != (dwRet =
                BPGetSubtypeName(
                    szUser,
                    pguidType,
                    pguidSubtype,
                    &szSubtype)) )
                goto Ret;

            // does ALL user confirm work
            if (PST_E_OK != (dwRet =
                GetUserConfirmBuf(
                    phPSTProv,
                    szUser,
                    Key,
                    szType,
                    pguidType,
                    szSubtype,
                    pguidSubtype,
                    szItemName,
                    psPrompt,
                    g_PromptWriteItem,
                    dwDefaultConfirmationStyle,
                    &szMasterKey,
                    rgbPwd,
                    0)) )
                goto Ret;
        }
    }

    // store the data itself
    if (!FBPSetSecuredItemData(
            szUser,
            szMasterKey,
            rgbPwd,
            pguidType,
            pguidSubtype,
            szItemName,
            pbData,
            cbData))
    {
        dwRet = PST_E_STORAGE_ERROR;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:

    // if creation didn't happen, item shouldn't exist
    if ((dwRet != PST_E_OK) && (!fExisted))
        BPDeleteItem(szUser, pguidType, pguidSubtype, szItemName);


    if (szMasterKey)
        SSFree(szMasterKey);

    if (szUser)
        SSFree(szUser);

    if (szType)
        SSFree(szType);

    if (szSubtype)
        SSFree(szSubtype);

    return dwRet;
}

HRESULT     SPReadItem(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out] */ DWORD *pcbData,
    /* [size_is][size_is][out] */ BYTE **ppbData,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    PST_ACCESSRULESET sRules = {sizeof(sRules), 0, NULL};

    LPWSTR  szUser = NULL;
    LPWSTR  szMasterKey = NULL;
    LPWSTR  szCallerName = NULL;

    BYTE    rgbPwd[A_SHA_DIGEST_LEN];
    LPWSTR szType=NULL, szSubtype=NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if ((dwFlags & ~(PST_UNRESTRICTED_ITEMDATA | PST_PROMPT_QUERY |
                    PST_NO_UI_MIGRATION
        )) != 0)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // Disable unnecessary UI.
    dwFlags |= PST_NO_UI_MIGRATION;

    if (psPrompt == NULL)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // Check for invalid "" input
    if (wcslen(szItemName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (dwFlags & PST_UNRESTRICTED_ITEMDATA)
    {
        // read insecure data stream
        if (PST_E_OK != (dwRet =
            BPGetInsecureItemData(
                szUser,
                pguidType,
                pguidSubtype,
                szItemName,
                ppbData,
                pcbData)) )
            goto Ret;

        dwRet = PST_E_OK;
        goto Ret;
    }
    // ELSE: secure stream

    {
        POPENITEM_LIST_ITEM pli;

        OPENITEM_LIST_ITEM li;
        if(NULL == g_pCOpenItemList)
        {
            dwRet = PST_E_FAIL;
            goto Ret;
        }
        CreateOpenListItem(&li, phPSTProv, Key, pguidType, pguidSubtype, szItemName);

        g_pCOpenItemList->LockList();

        // get opened (cached) item
        pli = g_pCOpenItemList->SearchList(&li);

        if ((pli != NULL) && (pli->ModeFlags & PST_READ))
        {
            // found cached item; pull pwd
            CopyMemory(rgbPwd, pli->rgbPwd, A_SHA_DIGEST_LEN);
            szMasterKey = (LPWSTR) SSAlloc(WSZ_BYTECOUNT(pli->szMasterKey));
            if( szMasterKey )
                wcscpy(szMasterKey, pli->szMasterKey);

            //
            // unlock list.
            //

            g_pCOpenItemList->UnlockList();

            if( szMasterKey == NULL ) {
                dwRet = E_OUTOFMEMORY;
                goto Ret;
            }

            // PST_PF_ALWAYS_SHOW always forces UI
            if (PST_PF_ALWAYS_SHOW == psPrompt->dwPromptFlags)
            {
                // retrieve names of type, subtype
                if (PST_E_OK != (dwRet =
                    BPGetTypeName(
                        szUser,
                        pguidType,
                        &szType)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    BPGetSubtypeName(
                        szUser,
                        pguidType,
                        pguidSubtype,
                        &szSubtype)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    ShowOKCancelUI(
                        phPSTProv,
                        szUser,
                        Key,
                        szType,
                        szSubtype,
                        szItemName,
                        psPrompt,
                        g_PromptReadItem)) )
                    goto Ret;
            }
        }
        else
        {

            //
            // unlock list.
            //

            g_pCOpenItemList->UnlockList();

            // not cached; do actual work

            // retrieve names of type, subtype
            if (PST_E_OK != (dwRet =
                BPGetTypeName(
                    szUser,
                    pguidType,
                    &szType)) )
                goto Ret;

            if (PST_E_OK != (dwRet =
                BPGetSubtypeName(
                    szUser,
                    pguidType,
                    pguidSubtype,
                    &szSubtype)) )
                goto Ret;

            // does ALL user confirm work
            if (PST_E_OK != (dwRet =
                GetUserConfirmBuf(
                    phPSTProv,
                    szUser,
                    Key,
                    szType,
                    pguidType,
                    szSubtype,
                    pguidSubtype,
                    szItemName,
                    psPrompt,
                    g_PromptReadItem,
                    &szMasterKey,
                    rgbPwd,
                    dwFlags)) )
                goto Ret;

        }
    }

    // if checked out, then actually retrieve item
    if (!FBPGetSecuredItemData(
            szUser,
            szMasterKey,
            rgbPwd,
            pguidType,
            pguidSubtype,
            szItemName,
            ppbData,
            pcbData))
    {
        dwRet = PST_E_STORAGE_ERROR;
        goto Ret;
    }

    dwRet = PST_E_OK;

Ret:

    //
    // see if caller requested UI disposition on item.
    //

    if( dwRet == PST_E_OK && dwFlags & PST_PROMPT_QUERY ) {
        DWORD dwStoredConfirm;
        LPWSTR pszMasterKey;
        DWORD dwRetVal;

        dwRetVal = BPGetItemConfirm(
                        phPSTProv,
                        szUser,
                        pguidType,
                        pguidSubtype,
                        szItemName,
                        &dwStoredConfirm,
                        &pszMasterKey
                        );

        if( dwRetVal == PST_E_OK ) {

            SSFree( pszMasterKey );

            if( !(dwStoredConfirm & BP_CONFIRM_NONE) ) {
                if(FIsProviderUIAllowed( szUser ))
                    dwRet = PST_E_ITEM_EXISTS;
            }
        }
    }


    if (szUser)
        SSFree(szUser);

    if (szMasterKey)
        SSFree(szMasterKey);

    if (szType)
        SSFree(szType);

    if (szSubtype)
        SSFree(szSubtype);

    if (szCallerName)
        SSFree(szCallerName);

    return dwRet;
}

HRESULT     SPDeleteItem(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    PST_ACCESSRULESET sRules = {sizeof(sRules), 0, NULL};

    LPWSTR  szUser = NULL;
    LPWSTR  szMasterKey = NULL;
    LPWSTR  szCallerName = NULL;

    BYTE    rgbPwd[A_SHA_DIGEST_LEN];
    LPWSTR szType=NULL, szSubtype=NULL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags & ~(PST_NO_UI_MIGRATION))
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // Disable unnecessary UI.
    dwFlags |= PST_NO_UI_MIGRATION;

    if (psPrompt == NULL)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }


    // Check for invalid "" input
    if (wcslen(szItemName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }



    {
        POPENITEM_LIST_ITEM pli;

        OPENITEM_LIST_ITEM li;

        if(NULL == g_pCOpenItemList)
        {
            dwRet = PST_E_FAIL;
            goto Ret;
        }
        CreateOpenListItem(&li, phPSTProv, Key, pguidType, pguidSubtype, szItemName);

        g_pCOpenItemList->LockList();

        // get opened (cached) item
        pli = g_pCOpenItemList->SearchList(&li);

        if ((pli != NULL) && (pli->ModeFlags & PST_WRITE))
        {
            // found cached item; pull pwd
            CopyMemory(rgbPwd, pli->rgbPwd, A_SHA_DIGEST_LEN);
            szMasterKey = (LPWSTR) SSAlloc(WSZ_BYTECOUNT(pli->szMasterKey));
            if( szMasterKey )
                wcscpy(szMasterKey, pli->szMasterKey);

            g_pCOpenItemList->UnlockList();

            if( szMasterKey == NULL ) {
                dwRet = E_OUTOFMEMORY;
                goto Ret;
            }

            // PST_PF_ALWAYS_SHOW always forces UI
            if (PST_PF_ALWAYS_SHOW == psPrompt->dwPromptFlags)
            {
                // retrieve names of type, subtype
                if (PST_E_OK != (dwRet =
                    BPGetTypeName(
                        szUser,
                        pguidType,
                        &szType)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    BPGetSubtypeName(
                        szUser,
                        pguidType,
                        pguidSubtype,
                        &szSubtype)) )
                    goto Ret;

                if (PST_E_OK != (dwRet =
                    ShowOKCancelUI(
                        phPSTProv,
                        szUser,
                        Key,
                        szType,
                        szSubtype,
                        szItemName,
                        psPrompt,
                        g_PromptDeleteItem)) )
                    goto Ret;
            }
        }
        else
        {
            //
            // unlock list.
            //

            g_pCOpenItemList->UnlockList();


            // retrieve names of type, subtype
            if (PST_E_OK != (dwRet =
                BPGetTypeName(
                    szUser,
                    pguidType,
                    &szType)) )
                goto Ret;

            if (PST_E_OK != (dwRet =
                BPGetSubtypeName(
                    szUser,
                    pguidType,
                    pguidSubtype,
                    &szSubtype)) )
                goto Ret;

            // does ALL user confirm work
            if (PST_E_OK != (dwRet =
                GetUserConfirmBuf(
                    phPSTProv,
                    szUser,
                    Key,
                    szType,
                    pguidType,
                    szSubtype,
                    pguidSubtype,
                    szItemName,
                    psPrompt,
                    g_PromptDeleteItem,
                    &szMasterKey,
                    rgbPwd,
                    dwFlags)) )
                goto Ret;
        }
    }

    // if checked out, then actually remove item
    if (PST_E_OK != (dwRet =
        BPDeleteItem(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName)) )
        goto Ret;

    dwRet = PST_E_OK;

Ret:


    if (szUser)
        SSFree(szUser);

    if (szMasterKey)
        SSFree(szMasterKey);

    if (szType)
        SSFree(szType);

    if (szSubtype)
        SSFree(szSubtype);

    if (szCallerName)
        SSFree(szCallerName);

    return dwRet;
}



HRESULT     SPOpenItem(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO psPrompt,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;
    PST_ACCESSRULESET sRules = {sizeof(sRules), 0, NULL};

    LPWSTR  szUser = NULL;
    LPWSTR  szMasterKey = NULL;
    LPWSTR  szCallerName = NULL;

    BYTE    rgbPwd[A_SHA_DIGEST_LEN];
    LPWSTR szType=NULL, szSubtype=NULL;

    POPENITEM_LIST_ITEM pli = NULL;


    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    if(psPrompt == NULL)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }


    // Check for invalid "" input
    if (wcslen(szItemName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // check for item already open
    {
        OPENITEM_LIST_ITEM li;
        if(NULL == g_pCOpenItemList)
        {
            dwRet = PST_E_FAIL;
            goto Ret;
        }
        CreateOpenListItem(&li, phPSTProv, Key, pguidType, pguidSubtype, szItemName);

        // get opened (cached) item
        pli = g_pCOpenItemList->SearchList(&li);

        if (pli != NULL)
        {
            // item already cached; error!
            dwRet = (DWORD)PST_E_ALREADY_OPEN;
            goto Ret;
        }
    }


    // get current user
    if (!FGetCurrentUser(
            phPSTProv,
            &szUser,
            Key))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // retrieve names of type, subtype
    if (PST_E_OK != (dwRet =
        BPGetTypeName(
            szUser,
            pguidType,
            &szType)) )
        goto Ret;

    if (PST_E_OK != (dwRet =
        BPGetSubtypeName(
            szUser,
            pguidType,
            pguidSubtype,
            &szSubtype)) )
        goto Ret;


    // does ALL user confirm work
    if (PST_E_OK != (dwRet =
        GetUserConfirmBuf(
            phPSTProv,
            szUser,
            Key,
            szType,
            pguidType,
            szSubtype,
            pguidSubtype,
            szItemName,
            psPrompt,
            g_PromptOpenItem,
            &szMasterKey,
            rgbPwd,
            0)) )
        goto Ret;

    // if checked out, then add to open item list
    pli = (POPENITEM_LIST_ITEM) SSAlloc(sizeof(OPENITEM_LIST_ITEM));
    if(NULL == pli)
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }


    // fill in contents
    CreateOpenListItem(pli, phPSTProv, Key, pguidType, pguidSubtype, NULL);

    pli->szItemName = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(szItemName));
    wcscpy(pli->szItemName, szItemName);

    pli->szMasterKey = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(szMasterKey));
    wcscpy(pli->szMasterKey, szMasterKey);

    CopyMemory(pli->rgbPwd, rgbPwd, A_SHA_DIGEST_LEN);
    pli->ModeFlags = ModeFlags;

    // add to the open list
    g_pCOpenItemList->AddToList(pli);

    dwRet = PST_E_OK;
Ret:


    if (szUser)
        SSFree(szUser);

    if (szMasterKey)
        SSFree(szMasterKey);

    if (szType)
        SSFree(szType);

    if (szSubtype)
        SSFree(szSubtype);

    if (szCallerName)
        SSFree(szCallerName);

    return dwRet;
}


HRESULT     SPCloseItem(
    /* [in] */ PST_PROVIDER_HANDLE *phPSTProv,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID *pguidType,
    /* [in] */ const GUID *pguidSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags)
{
    HRESULT dwRet = PST_E_FAIL;

    if (Key & ~(PST_KEY_CURRENT_USER | PST_KEY_LOCAL_MACHINE))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    if (dwFlags)
    {
        dwRet = PST_E_BAD_FLAGS;
        goto Ret;
    }

    // Check for invalid "" input
    if (wcslen(szItemName) == 0)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto Ret;
    }

    // if item found in list, remove it
    OPENITEM_LIST_ITEM li;
    if(NULL == g_pCOpenItemList)
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }
    CreateOpenListItem(&li, phPSTProv, Key, pguidType, pguidSubtype, szItemName);

    if (!g_pCOpenItemList->DelFromList(&li))
    {
        dwRet = PST_E_NOT_OPEN;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:

    return dwRet;
}


///////////////////////////////////////////////////
// FInitProtectAPIGlobals
//
// Checks for registry overrides for some default values
// registry entries can change what algs are being used,
// as well as what provider is used.
BOOL FInitProtectAPIGlobals()
{
    HKEY    hProtectKey = NULL;
    HKEY    hProviderKey = NULL;
    DWORD   dwTemp, dwType, cbSize;
    DWORD   dwCreate;
    static const WCHAR szProtectKeyName[] = REG_CRYPTPROTECT_LOC;
    static const WCHAR szProviderKeyName[] = L"\\" REG_CRYPTPROTECT_PROVIDERS_SUBKEYLOC L"\\" CRYPTPROTECT_DEFAULT_PROVIDER_GUIDSZ ;

    LONG    lRet;





    //
    // get password cache policy setting.
    //


    lRet = RegOpenKeyExU(
                    HKEY_LOCAL_MACHINE,
                    L"Software\\Policies\\Microsoft\\Cryptography\\Protect",
                    0,
                    KEY_QUERY_VALUE,
                    &hProtectKey
                    );

    if( lRet == ERROR_SUCCESS ) {

        DWORD cbSize;
        DWORD dwTemp;
        DWORD dwType;

        //
        // query EnableCachePW value.
        //


        cbSize = sizeof(DWORD);
        lRet = RegQueryValueExU(
                        hProtectKey,
                        REG_CRYPTPROTECT_ALLOW_CACHEPW,
                        NULL,
                        &dwType,
                        (PBYTE)&dwTemp,
                        &cbSize
                        );

        if( lRet == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            dwTemp == 0 // 0 == disablePW cache
            ) {
            g_fAllowCachePW = FALSE;
        } else {
            g_fAllowCachePW = TRUE;
        }


        RegCloseKey( hProtectKey );
        hProtectKey = NULL;
    } else {

        g_fAllowCachePW = TRUE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\provui.cpp ===
/*
    File:       ProvUI.cpp

    Title:      Base provider user interface
    Author:     Matt Thomlinson
    Date:       12/13/96

    ProvUI houses all user interface for the provider. During
    startup, InitUI() fetches all user strings from the resource
    string table. During shutdown, ReleaseUI() frees them.

    The other miscellaneous functions gather passwords,
    define new password groups and retrieve the windows password
    if it has changed.

*/
#include <pch.cpp>
#pragma hdrstop


#include <commctrl.h>


#include "provui.h"


#include "storage.h"

#include "passwd.h"
#include "filemisc.h"

extern DISPIF_CALLBACKS     g_sCallbacks;
extern PRIVATE_CALLBACKS    g_sPrivateCallbacks;
extern HINSTANCE            g_hInst;
extern BOOL                 g_fAllowCachePW;

// cached authentication list
extern              CUAList*            g_pCUAList;

HICON g_DefaultIcon = NULL;


BOOL g_fUIInitialized = FALSE;
CRITICAL_SECTION g_csUIInitialized;


// string resources

LPWSTR g_StringBlock = NULL; // single allocated block containing all sz strings

LPWSTR g_ItemDetailsBannerMessage;
LPWSTR g_PasswordDuplicate;
LPWSTR g_PasswordAddError;
LPWSTR g_PasswordChangeError;
LPWSTR g_PasswordCreate;
LPWSTR g_PasswordNoMatch;
LPWSTR g_PasswordMustName;
LPWSTR g_PasswordChange;
LPWSTR g_PasswordSolicitOld;
LPWSTR g_PasswordErrorDlgTitle;

LPWSTR g_PasswordWin95Garbage;
LPWSTR g_PasswordNoVerify;
LPWSTR g_PasswordWinNoVerify;

LPWSTR g_PWPromptPrefix;
LPWSTR g_PWPromptSuffix;
LPWSTR g_SimplifiedDlgMessageFormat;

LPWSTR g_PromptReadItem;
LPWSTR g_PromptOpenItem;
LPWSTR g_PromptWriteItem;
LPWSTR g_PromptDeleteItem;

LPWSTR g_PromptHighSecurity;
LPWSTR g_PromptMedSecurity;
LPWSTR g_PromptLowSecurity;

LPWSTR g_TitleContainerMapping;


#define MAX_PW_LEN  160
#define MAX_STRING_RSC_SIZE 512

// define something not likely to be entered by a user
#define WSZ_PASSWORD_CHANGE_DETECT_TOKEN L"[]{}9d1Dq"

//
// this one comes and goes only when needed
//

typedef DWORD (WINAPI *WNETVERIFYPASSWORD)(
    LPCSTR lpszPassword,
    BOOL *pfMatch
    );


///////////////////////////////////////////////////////////////////////////
// Forwards
INT_PTR CALLBACK DialogAdvancedConfirmH(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);

INT_PTR CALLBACK DialogAccessDetails(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);

INT_PTR CALLBACK DialogSetSecurityLevel(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);

INT_PTR CALLBACK DialogSimplifiedPasswordConfirm(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);

INT_PTR CALLBACK DialogWaitForOKCancel(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
);

int
ServicesDialogBoxParam(
    HINSTANCE hInstance,    // handle to application instance
    LPCTSTR lpTemplateName, // identifies dialog box template
    HWND hWndParent,    // handle to owner window
    DLGPROC lpDialogFunc,   // pointer to dialog box procedure
    LPARAM dwInitParam  // initialization value
);



BOOL
FetchString(
    HMODULE hModule,                // module to get string from
    UINT ResourceId,                // resource identifier
    LPWSTR *String,                 // target buffer for string
    LPWSTR *StringBlock,            // string buffer block
    DWORD *dwBufferSize,            // size of string buffer block
    DWORD *dwRemainingBufferSize    // remaining size of string buffer block
    );

BOOL
CALLBACK
FMyLoadIcon(
    HINSTANCE hModule,  // resource-module handle
    LPCTSTR lpszType,    // pointer to resource type
    LPWSTR lpszName,     // pointer to resource name
    LONG_PTR lParam      // application-defined parameter
    );

///////////////////////////////////////////////////////////////////////////
// Exposed functions

#define GLOBAL_STRING_BUFFERSIZE 3800

BOOL InitUI()
{
    DWORD dwBufferSize;
    DWORD dwRemainingBufferSize;
    BOOL bSuccess = FALSE;

    if( g_fUIInitialized )
        return TRUE;

    //
    // take crit sec
    //

    EnterCriticalSection( &g_csUIInitialized );

    //
    // check the global to prevent a race condition that would cause
    // re-init to occur.
    //

    if( g_fUIInitialized ) {
        bSuccess = TRUE;
        goto cleanup;
    }


    g_DefaultIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_ICON1));
    if(g_DefaultIcon == NULL)
        goto cleanup;

    //
    // get size of all string resources, and then allocate a single block
    // of memory to contain all the strings.  This way, we only have to
    // free one block and we benefit memory wise due to locality of reference.
    //

    dwBufferSize = dwRemainingBufferSize = GLOBAL_STRING_BUFFERSIZE;

    g_StringBlock = (LPWSTR)SSAlloc(dwBufferSize);
    if(g_StringBlock == NULL)
        goto cleanup;


    if(!FetchString(g_hInst, IDS_ITEM_DETAILS_BANNER, &g_ItemDetailsBannerMessage, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_CREATE_MESSAGE, &g_PasswordCreate, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_NOMATCH, &g_PasswordNoMatch, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_CHANGE_MESSAGE, &g_PasswordChange, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_MUSTNAME, &g_PasswordMustName, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_SOLICIT_OLD_MESSAGE, &g_PasswordSolicitOld, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_DUPLICATE, &g_PasswordDuplicate, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_ADD_ERROR, &g_PasswordAddError, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_CHANGE_ERROR, &g_PasswordChangeError, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_ERROR_DLGTITLE, &g_PasswordErrorDlgTitle, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;


    if(!FetchString(g_hInst, IDS_WIN95_PASSWORDS_AREGARBAGE, &g_PasswordWin95Garbage, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_NOVERIFY, &g_PasswordNoVerify, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_WIN_NOVERIFY, &g_PasswordWinNoVerify, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;



    if(!FetchString(g_hInst, IDS_PASSWORD_PROMPT_PREFIX, &g_PWPromptPrefix, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PASSWORD_PROMPT_SUFFIX, &g_PWPromptSuffix, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;


    if(!FetchString(g_hInst, IDS_SIMPLIFIED_DLG_MSG, &g_SimplifiedDlgMessageFormat, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_READITEM, &g_PromptReadItem, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_OPENITEM, &g_PromptOpenItem, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_WRITEITEM, &g_PromptWriteItem, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_DELETEITEM, &g_PromptDeleteItem, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;


    if(!FetchString(g_hInst, IDS_PROMPT_HIGH_SECURITY, &g_PromptHighSecurity, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_MED_SECURITY, &g_PromptMedSecurity, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_PROMPT_LOW_SECURITY, &g_PromptLowSecurity, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    if(!FetchString(g_hInst, IDS_TITLE_CONTAINER_MAPPING, &g_TitleContainerMapping, &g_StringBlock, &dwBufferSize, &dwRemainingBufferSize))
        goto cleanup;

    //
    // if the block was realloc'ed to a different location, re-fetch strings
    // very unlikely to ever happen
    //

#if DBG
    if(GLOBAL_STRING_BUFFERSIZE != dwBufferSize)
        OutputDebugString(TEXT("Forced to realloc global string area in provui.cpp:InitUI()\n"));
#endif

    bSuccess = TRUE;

cleanup:

    if(!bSuccess) {
        if(g_StringBlock) {
            SSFree(g_StringBlock);
            g_StringBlock = NULL;
        }
    } else {
        g_fUIInitialized = TRUE;
    }

    LeaveCriticalSection( &g_csUIInitialized );

    return bSuccess;
}



BOOL ReleaseUI()
{
    g_DefaultIcon = NULL;

    if(g_StringBlock) {
        SSFree(g_StringBlock);
        g_StringBlock = NULL;
    }

#if 0
    g_PasswordDuplicate = g_PasswordAddError = g_PasswordChangeError =
    g_PasswordCreate = g_PasswordNoMatch = g_PasswordMustName = g_PasswordChange =
    g_PasswordSolicitOld = g_PasswordErrorDlgTitle = g_PasswordWin95Garbage =
    g_PasswordNoVerify = g_PasswordWinNoVerify =

    g_PWPromptPrefix = g_PWPromptSuffix = g_SimplifiedDlgMessageFormat =

    g_PromptReadItem = g_PromptOpenItem = g_PromptWriteItem =
    g_PromptDeleteItem = g_PromptHighSecurity = g_PromptMedSecurity =
    g_PromptLowSecurity =

    NULL;

#endif

    return TRUE;
}


BOOL
FIsProviderUIAllowed(
    LPCWSTR szUser
    )
{
    //
    // UI always allowed under Win95.
    //

    if(!FIsWinNT())
        return TRUE;

    //
    // UI is not allowed on NT when running as local system.
    //

    if(lstrcmpiW(szUser, TEXTUAL_SID_LOCAL_SYSTEM) == 0)
        return FALSE;

    return TRUE;
}


LPWSTR SZMakeDisplayableType(LPCWSTR szType,LPCWSTR szSubtype)
{
    // create a nice UI string
    LPWSTR szUIType = (LPWSTR)SSAlloc((
        wcslen(szType)+
        3 + // L" ()"
        wcslen(szSubtype) +
        1   // L"\0"
        ) * sizeof(WCHAR));


    if(szUIType == NULL)
        return FALSE;

    // sprintf: Subtype(Type)
    wcscpy(szUIType, szSubtype);
    wcscat(szUIType, L" (");
    wcscat(szUIType, szType);
    wcscat(szUIType, L")");

    return szUIType;
}


BOOL
MyGetPwdHashEx(
    LPWSTR szPW,
    BYTE rgbPasswordDerivedBytes[A_SHA_DIGEST_LEN],
    BOOL fLowerCase
    )
{
    A_SHA_CTX   sSHAHash;
    DWORD       cbPassword;
    LPWSTR TemporaryPassword = NULL;

    LPWSTR PasswordToHash;

    // don't include NULL termination
    cbPassword = WSZ_BYTECOUNT(szPW) - sizeof(WCHAR);

    if ( fLowerCase )
    {
        TemporaryPassword = (LPWSTR) SSAlloc( cbPassword + sizeof(WCHAR) );

        if( TemporaryPassword == NULL )
            return FALSE;

        CopyMemory(TemporaryPassword, szPW, cbPassword + sizeof(WCHAR) );

        //
        // Win95: inconsistent handling of pwds
        // forces inplace convert to uppercase
        //

        MyToUpper(TemporaryPassword);

        PasswordToHash = TemporaryPassword;
    } else {

        PasswordToHash = szPW;
    }

    // hash pwd, copy out
    A_SHAInit(&sSHAHash);

    // Hash password
    A_SHAUpdate(&sSHAHash, (BYTE *) PasswordToHash, cbPassword);
    A_SHAFinal(&sSHAHash, rgbPasswordDerivedBytes);

    if( TemporaryPassword )
        SSFree( TemporaryPassword );

    return TRUE;
}

BOOL
MyGetPwdHash(
    LPWSTR szPW,
    BYTE rgbPasswordDerivedBytes[A_SHA_DIGEST_LEN]
    )
{

    if (!FIsWinNT())
    {
        // Win95: inconsistent handling of pwds
        // forces inplace convert to uppercase
        MyGetPwdHashEx( szPW, rgbPasswordDerivedBytes, TRUE );
    } else {
        MyGetPwdHashEx( szPW, rgbPasswordDerivedBytes, FALSE );
    }

    return TRUE;
}


BOOL
FetchString(
    HMODULE hModule,                // module to get string from
    UINT ResourceId,                // resource identifier
    LPWSTR *String,                 // target buffer for string
    LPWSTR *StringBlock,            // string buffer block
    DWORD *dwBufferSize,            // size of string buffer block
    DWORD *dwRemainingBufferSize    // remaining size of string buffer block
    )
{
    WCHAR szMessage[MAX_STRING_RSC_SIZE];
    DWORD cchMessage;

    if(StringBlock == NULL || *StringBlock == NULL || String == NULL)
        return FALSE;

    cchMessage = LoadStringU(
            hModule,
            ResourceId,
            szMessage,
            MAX_STRING_RSC_SIZE);

    if(cchMessage == 0)
        return FALSE;

    if(*dwRemainingBufferSize < (cchMessage+1) * sizeof(WCHAR)) {

        //
        // realloc buffer and update size
        //

        LPWSTR TempStr = NULL;
        DWORD dwOldSize = *dwBufferSize;
        DWORD dwNewSize = dwOldSize + ((cchMessage + 1) * sizeof(WCHAR)) ;

        TempStr = (LPWSTR)SSReAlloc( *StringBlock, dwNewSize );
        if(TempStr == NULL) {

                //
                // dwNewSize will never be 0. *StringBlock should not be freed when NULL is returned.
                // The caller should take care of *StringBlock.
                //

             return FALSE;
        }

        *StringBlock = TempStr;

        *dwBufferSize = dwNewSize;
        *dwRemainingBufferSize += dwNewSize - dwOldSize;
    }

    *String = (LPWSTR)((LPBYTE)*StringBlock + *dwBufferSize - *dwRemainingBufferSize);
    wcscpy(*String, szMessage);
    *dwRemainingBufferSize -= (cchMessage + 1) * sizeof(WCHAR);

    return TRUE;
}



int
ServicesDialogBoxParam(
    HINSTANCE hInstance,    // handle to application instance
    LPCTSTR lpTemplateName, // identifies dialog box template
    HWND hWndParent,    // handle to owner window
    DLGPROC lpDialogFunc,   // pointer to dialog box procedure
    LPARAM dwInitParam  // initialization value
    )
/*++

    This function is implemented to allow UI to originate from the
    Protected Storage service on Windows NT 5.0 installations.

    This UI will go to the user desktop, rather than an invisible desktop
    which would otherwise cause DialogBoxParam() calls to fail.

--*/
{
    HWINSTA hOldWinsta = NULL;
    HWINSTA hNewWinsta = NULL;
    HDESK hOldDesk = NULL;
    HDESK hNewDesk = NULL;
    int iRet = -1;

    if( FIsWinNT5() ) {

        hOldWinsta = GetProcessWindowStation();
        if(hOldWinsta == NULL)
            goto cleanup;

        hOldDesk = GetThreadDesktop( GetCurrentThreadId() );
        if(hOldDesk == NULL)
            goto cleanup;

        hNewWinsta = OpenWindowStationW( L"WinSta0", FALSE, MAXIMUM_ALLOWED );
        if(hNewWinsta == NULL)
            goto cleanup;

        if(!SetProcessWindowStation( hNewWinsta ))
            goto cleanup;

        hNewDesk = OpenDesktopW( L"default", 0, FALSE, MAXIMUM_ALLOWED );
        if(hNewDesk == NULL)
            goto cleanup;

        if(!SetThreadDesktop( hNewDesk )) {
            if( GetLastError() != ERROR_BUSY )
                goto cleanup;

            //
            // the desktop object is locked/in-use.  Most likely explanation
            // is nested dialog box calls.  Just put the process windowstation
            // back and continue..
            //

            SetProcessWindowStation( hOldWinsta );
        }

    }
    
    INITCOMMONCONTROLSEX        initcomm;
    initcomm.dwSize = sizeof(initcomm);
    initcomm.dwICC = ICC_STANDARD_CLASSES | ICC_WIN95_CLASSES;

    InitCommonControlsEx(&initcomm);

    iRet = (int)DialogBoxParam(
                hInstance,      // handle to application instance
                lpTemplateName, // identifies dialog box template
                hWndParent,     // handle to owner window
                lpDialogFunc,   // pointer to dialog box procedure
                dwInitParam     // initialization value
                );

cleanup:

    if( hOldWinsta ) {
        SetProcessWindowStation( hOldWinsta );
    }

    if( hOldDesk ) {
        SetThreadDesktop( hOldDesk );
    }

    if( hNewWinsta ) {
        CloseWindowStation( hNewWinsta );
    }

    if( hNewDesk ) {
        CloseDesktop( hNewDesk );
    }

    return iRet;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// exposed Dialog setup functions





BOOL FSimplifiedPasswordConfirm(
        PST_PROVIDER_HANDLE*    phPSTProv,
        LPCWSTR                 szUserName,
        LPCWSTR                 szCallerName,
        LPCWSTR                 szType,
        LPCWSTR                 szSubtype,
        LPCWSTR                 szItemName,
        PPST_PROMPTINFO         psPrompt,
        LPCWSTR                 szAccessType,
        LPWSTR*                 ppszPWName,
        DWORD*                  pdwPasswordOptions,
        BOOL                    fAllowUserFreedom,
        BYTE                    rgbPasswordDerivedBytes[],
        DWORD                   cbPasswordDerivedBytes,
        BYTE                    rgbPasswordDerivedBytesLowerCase[],
        DWORD                   cbPasswordDerivedBytesLowerCase,
        DWORD                   dwFlags
        )
{
    if ((rgbPasswordDerivedBytes == NULL) || (cbPasswordDerivedBytes < A_SHA_DIGEST_LEN))
        return FALSE;

    if ((rgbPasswordDerivedBytesLowerCase == NULL) || (cbPasswordDerivedBytesLowerCase < A_SHA_DIGEST_LEN))
        return FALSE;

    BOOL    fRet = FALSE;
    LPWSTR  pszUIPassword = NULL;   // actual pwd
    LPWSTR  szUIType = NULL;

    BOOL    fCacheThisPasswd;         // unDONE UNDONE going away

    DWORD cchItemName;
    LPCWSTR szTitle = szItemName;   // default titlebar to itemname.


    //
    // check if szItemName is a GUID, if so, map the title to something legible.
    //

    cchItemName = lstrlenW( szItemName );

    if( cchItemName == 36 ) {

        if( szItemName[ 8  ] == L'-' &&
            szItemName[ 13 ] == L'-' &&
            szItemName[ 18 ] == L'-' &&
            szItemName[ 23 ] == L'-' ) {

            szTitle = g_TitleContainerMapping;
        }
    } else if( cchItemName == 38 ) {

        if( szItemName[ 0  ] == L'{' &&
            szItemName[ 9  ] == L'-' &&
            szItemName[ 14 ] == L'-' &&
            szItemName[ 19 ] == L'-' &&
            szItemName[ 24 ] == L'-' &&
            szItemName[ 37 ] == L'}' ) {

            szTitle = g_TitleContainerMapping;
        }
    }


    if (NULL == (szUIType =
        SZMakeDisplayableType(
            szType,
            szSubtype)) )
        return FALSE;

    int iRet;

    // PST_ flags go in..

    // okay, take the hit
    PW_DIALOG_ARGS DialogArgs =
        {
            phPSTProv,
            szCallerName,
            szAccessType,
            psPrompt->szPrompt,
            szUIType,
            szTitle,
            szUserName,
            ppszPWName,
            &pszUIPassword,
            pdwPasswordOptions,
            fAllowUserFreedom,           // allow user to change protection?
            &fCacheThisPasswd,
            rgbPasswordDerivedBytes,
            rgbPasswordDerivedBytesLowerCase
        };



    if(FIsWinNT()) {
        BOOL fAuthID;

        if (!g_sCallbacks.pfnFImpersonateClient( phPSTProv )) {
            goto Ret;
        }

        fAuthID = GetThreadAuthenticationId(GetCurrentThread(), &(DialogArgs.luidAuthID));

        g_sCallbacks.pfnFRevertToSelf( phPSTProv );

        if( !fAuthID ) {
            goto Ret;
        }
    }

    DialogArgs.dwFlags = dwFlags;


    iRet = ServicesDialogBoxParam(
                g_hInst,
                MAKEINTRESOURCE(IDD_SIMPLIFIED_PASSWD),
                (HWND)psPrompt->hwndApp,
                DialogSimplifiedPasswordConfirm,
                (LPARAM)&DialogArgs);


    if(iRet != IDOK) goto Ret;

    // BP_ flags, derived bytes come out

    fRet = TRUE;
Ret:

    if (pszUIPassword)
        SSFree(pszUIPassword);

    if (szUIType)
        SSFree(szUIType);

    return fRet;
}


BOOL FInternal_CreateNewPasswordEntry(
        HWND        hParentWnd,
        LPCWSTR     szUserName,
        LPWSTR      szPWName,
        LPWSTR      szPW)
{
    BOOL fRet = FALSE;

    BYTE rgbPasswordDerivedBytes[A_SHA_DIGEST_LEN];

    // and check response
    if ((szPW == NULL) || (szPWName == NULL))
        goto Ret;

    // everything went fine, now derive the password bits!
    if (!MyGetPwdHash(szPW, rgbPasswordDerivedBytes))
        goto Ret;

    // and now commit change
    if (!FPasswordChangeNotify(
                        szUserName,
                        szPWName,
                        NULL,
                        0,
                        rgbPasswordDerivedBytes,
                        A_SHA_DIGEST_LEN ))
    {
        LPWSTR szMessage;

        if (PST_E_ITEM_EXISTS == GetLastError())
        {
            szMessage = g_PasswordDuplicate;
        }
        else
        {
            szMessage = g_PasswordAddError;
        }

        // this W implemented in both Win95 & NT!
        MessageBoxW(
            NULL, //hParentWnd,
            szMessage,
            g_PasswordErrorDlgTitle,
            MB_OK | MB_ICONEXCLAMATION | MB_SERVICE_NOTIFICATION);

        goto Ret;
    }

    fRet = TRUE;
Ret:

    return fRet;
}

BOOL
ChooseSecurityWizard(HWND hDlg, ADVANCEDCONFIRM_DIALOGARGS* pDialogArgs)
{
    // make copy of pDialogArgs so we don't change original
    // unless everything goes ok


    LPWSTR      szPWName_Stack = NULL;
    LPWSTR      szPW_Stack = NULL; // no need to pull original password out
    DWORD       dwPasswordOptions_Stack;
    DWORD       dwReturnStatus;

    ADVANCEDCONFIRM_DIALOGARGS DlgArgs_Stack = {
            pDialogArgs->szUserName,
            &szPWName_Stack,
            &szPW_Stack,
            &dwPasswordOptions_Stack,
            pDialogArgs->szItemName};

    if(*(pDialogArgs->ppszPWName) != NULL)
    {
        szPWName_Stack = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(*(pDialogArgs->ppszPWName)));
        if(szPWName_Stack == NULL)
        {
            goto Ret;
        }
        wcscpy(szPWName_Stack, *(pDialogArgs->ppszPWName));
    }

    dwPasswordOptions_Stack = *(pDialogArgs->pdwPasswordOptions);


Choose_Step1:

    dwReturnStatus = ServicesDialogBoxParam(
            g_hInst,
            MAKEINTRESOURCE(IDD_ADVANCED_CONFIRM),
            (HWND)hDlg,
            DialogSetSecurityLevel,
            (LPARAM)&DlgArgs_Stack);

    // if user decides not to choose, bail
    if (IDOK != dwReturnStatus)
        goto Ret;

    // else, switch on his decision

    switch (*(DlgArgs_Stack.pdwPasswordOptions))
    {
    case (BP_CONFIRM_PASSWORDUI):
        {
            dwReturnStatus =
                ServicesDialogBoxParam(
                    g_hInst,
                    MAKEINTRESOURCE(IDD_ADVANCED_CONFIRM_H),
                    (HWND)hDlg,
                    DialogAdvancedConfirmH,
                    (LPARAM)&DlgArgs_Stack);

            // if user hits okay, execute
            if (IDOK == dwReturnStatus)
                goto ExecuteChange;

            // if user wants back, go back
            if (IDC_BACK == dwReturnStatus)
                goto Choose_Step1;

            // else, bail
            break;
        }
    case (BP_CONFIRM_OKCANCEL):
        {
            dwReturnStatus =
                ServicesDialogBoxParam(
                    g_hInst,
                    MAKEINTRESOURCE(IDD_ADVANCED_CONFIRM_M),
                    (HWND)hDlg,
                    DialogWaitForOKCancel,
                    (LPARAM)pDialogArgs);

            // if user hits okay, execute
            if (IDOK == dwReturnStatus)
                goto ExecuteChange;

            // if user wants back, go back
            if (IDC_BACK == dwReturnStatus)
                goto Choose_Step1;

            // else, bail
            break;
        }
    case (BP_CONFIRM_NONE):
        {
            dwReturnStatus =
                ServicesDialogBoxParam(
                    g_hInst,
                    MAKEINTRESOURCE(IDD_ADVANCED_CONFIRM_L),
                    (HWND)hDlg,
                    DialogWaitForOKCancel,
                    (LPARAM)pDialogArgs);

            // if user hits okay, execute
            if (IDOK == dwReturnStatus)
                goto ExecuteChange;

            // if user wants back, go back
            if (IDC_BACK == dwReturnStatus)
                goto Choose_Step1;

            // else, bail
            break;
        }
    default:
        break;
    }


Ret:
    // free dyn alloced DialogArgs we aren't returning
    if (*(DlgArgs_Stack.ppszPWName))
        SSFree(*(DlgArgs_Stack.ppszPWName));
    if (*(DlgArgs_Stack.ppszPW))
        SSFree(*(DlgArgs_Stack.ppszPW));

    return FALSE;

ExecuteChange:
    // free what we already know, point to newly alloc'ed pointers
    if (*(pDialogArgs->ppszPWName))
        SSFree(*(pDialogArgs->ppszPWName));
    *(pDialogArgs->ppszPWName) = szPWName_Stack;

    if (*(pDialogArgs->ppszPW))
        SSFree(*(pDialogArgs->ppszPW));
    *(pDialogArgs->ppszPW) = szPW_Stack;

    *(pDialogArgs->pdwPasswordOptions) = dwPasswordOptions_Stack;

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// Actual Dialog Callbacks

INT_PTR CALLBACK DialogAdvancedConfirmH(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
{
    BOOL bSuccess = FALSE; // assume error
    PADVANCEDCONFIRM_DIALOGARGS pDialogArgs;
    BYTE rgb1[_MAX_PATH];
    LPWSTR  pszMasterKey=NULL;
    char *  szBuffer = NULL;
    DWORD dwCount;
    DWORD dwStatus;

    switch (message)
    {
        case WM_INITDIALOG:

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }
            // lParam is struct
            pDialogArgs = (PADVANCEDCONFIRM_DIALOGARGS)lParam;

            // set dialog title
            SetWindowTextU(hDlg, pDialogArgs->szItemName);

            SetWindowTextU(GetDlgItem(hDlg, IDC_MESSAGE), g_PasswordCreate);

            // clear pwds
            SendDlgItemMessage(hDlg, IDC_PW_NAME, CB_RESETCONTENT, 0, 0);

            // Add known pwds
            for (dwCount=0; ;dwCount++)
            {

                if (PST_E_OK !=
                    BPEnumMasterKeys(
                        pDialogArgs->szUserName,
                        dwCount,
                        &pszMasterKey))
                    break;

                // don't add non-editable passwords
                if (!FIsUserMasterKey(pszMasterKey))
                    continue;

                // add this to the list and continue
                if (FIsWinNT())
                {
                    SendDlgItemMessageW(hDlg, IDC_PW_NAME, CB_ADDSTRING, 0, (LPARAM) pszMasterKey);
                }
#ifdef _M_IX86
                else
                {
                    // only add if (! (NULL username && Windows password))
                    if (
                       (0 != wcscmp(pDialogArgs->szUserName, L"")) ||
                       (0 != wcscmp(pszMasterKey, WSZ_PASSWORD_WINDOWS))
                       )
                    {
                        MkMBStr(rgb1, _MAX_PATH, pszMasterKey, &szBuffer);
                        SendDlgItemMessageA(hDlg, IDC_PW_NAME, CB_ADDSTRING, 0, (LPARAM) szBuffer);
                        FreeMBStr(rgb1, szBuffer);
                    }
                }
#endif // _M_IX86
                SSFree(pszMasterKey);
            }


            // check to see if there are any items in listbox
            dwStatus = (DWORD) SendDlgItemMessageW(hDlg, IDC_PW_NAME, CB_GETCOUNT, 0, 0);
            if ((dwStatus == CB_ERR) || (dwStatus == 0))
            {
                // Listbox empty!
                // set default dialog selection to be "new password"
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_SELEXISTING), FALSE);
                SendMessage(hDlg, WM_COMMAND, IDC_RADIO_DEFINENEW, 0);      // as if user clicked NEW
                SendDlgItemMessage(hDlg, IDC_RADIO_DEFINENEW, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
            }
            else
            {
                // Items do exist!

                // set default in dropdown
                if (FIsWinNT())
                    dwStatus = (DWORD) SendDlgItemMessageW(hDlg, IDC_PW_NAME, CB_SELECTSTRING, (WORD)-1, (LPARAM) *(pDialogArgs->ppszPWName));
#ifdef _M_IX86
                else
                {
                    MkMBStr(rgb1, _MAX_PATH, (*pDialogArgs->ppszPWName), &szBuffer);
                    dwStatus = SendDlgItemMessageA(hDlg, IDC_PW_NAME, CB_SELECTSTRING, (WORD)-1, (LONG) szBuffer);
                    FreeMBStr(rgb1, szBuffer);
                }
#endif // _M_IX86
                // if search failed, select first item in listbox
                if (dwStatus == CB_ERR)
                    SendDlgItemMessage(hDlg, IDC_PW_NAME, CB_SETCURSEL, 0, 0);


                // set default dialog selection to be "existing pw"
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO_SELEXISTING), TRUE);
                SendMessage(hDlg, WM_COMMAND, IDC_RADIO_SELEXISTING, 0);    // as if user clicked EXISTING
                SendDlgItemMessage(hDlg, IDC_RADIO_SELEXISTING, BM_SETCHECK, (WPARAM)BST_CHECKED, 0);
            }

            return TRUE;

        case WM_COMMAND:
        {
            pDialogArgs = (PADVANCEDCONFIRM_DIALOGARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if(pDialogArgs == 0) break; // TODO: bail out

            switch (LOWORD(wParam))
            {
                case (IDOK):
                {
                    if( *(pDialogArgs->ppszPWName) ) {
                        SSFree(*(pDialogArgs->ppszPWName));
                        *(pDialogArgs->ppszPWName) = NULL;
                    }

                    if(BST_CHECKED == SendDlgItemMessage(hDlg, IDC_RADIO_SELEXISTING, BM_GETCHECK, 0, 0))
                    {
                        WCHAR sz1[MAX_PW_LEN];
                        DWORD cch1;

                        // and get password name
                        cch1 = GetDlgItemTextU(
                            hDlg,
                            IDC_PW_NAME,
                            sz1,
                            MAX_PW_LEN);

                        *(pDialogArgs->ppszPWName) = (LPWSTR)SSAlloc((cch1+1)*sizeof(WCHAR));
                        if(NULL != *(pDialogArgs->ppszPWName))

                        {
                            wcscpy(*(pDialogArgs->ppszPWName), sz1);
                        }
                    }
                    else
                    {
                        LPWSTR* ppszPW;
                        LPWSTR* ppszPWName;
                        WCHAR sz1[MAX_PW_LEN];
                        WCHAR sz2[MAX_PW_LEN];
                        WCHAR szPWName[MAX_PW_LEN];

                        DWORD cch1 = 0, cch2 = 0, cchPWName = 0;

                        ppszPW = pDialogArgs->ppszPW;
                        ppszPWName = pDialogArgs->ppszPWName;

                        // don't stomp existing ppszPW/ppszPWName until we know we're okay

                        cch1 = GetDlgItemTextU(
                            hDlg,
                            IDC_EDIT1,
                            sz1,
                            MAX_PW_LEN);

                        cch2 = GetDlgItemTextU(
                            hDlg,
                            IDC_EDIT2,
                            sz2,
                            MAX_PW_LEN);

                        if ( (cch1 != cch2) || (0 != wcscmp(sz1, sz2)) )
                        {
                            // this W implemented in both Win95 & NT!
                            MessageBoxW(
                                    NULL, // hDlg,
                                    g_PasswordNoMatch,
                                    g_PasswordErrorDlgTitle,
                                    MB_OK | MB_ICONEXCLAMATION | MB_SERVICE_NOTIFICATION);

                            SetWindowTextU(GetDlgItem(hDlg, IDC_EDIT1), WSZ_NULLSTRING);
                            SetWindowTextU(GetDlgItem(hDlg, IDC_EDIT2), WSZ_NULLSTRING);

                            goto cleanup;
                        }

                        cchPWName = GetDlgItemTextU(
                            hDlg,
                            IDC_PW_NEWNAME,
                            szPWName,
                            MAX_PW_LEN);

                        if (cchPWName == 0)
                        {
                            // this W implemented in both Win95 & NT!
                            MessageBoxW(
                                    NULL, // hDlg,
                                    g_PasswordMustName,
                                    g_PasswordErrorDlgTitle,
                                    MB_OK | MB_ICONEXCLAMATION | MB_SERVICE_NOTIFICATION);
                            goto cleanup;
                        }

                        // trim spaces off rhs
                        while(0 == memcmp(&szPWName[cchPWName-1], L" ", sizeof(WCHAR)))
                            cchPWName--;
                        szPWName[cchPWName] = L'\0';

                        // try and create the pw entry
                        if (!FInternal_CreateNewPasswordEntry(
                                hDlg,
                                pDialogArgs->szUserName,
                                szPWName,
                                sz1) )
                            goto cleanup;

                        // now bite it: save both
                        SS_ASSERT(ppszPW != NULL);
                        *ppszPW = (LPWSTR)SSAlloc( (cch1+1) * sizeof(WCHAR) );
                        if(*ppszPW == NULL) goto cleanup;

                        SS_ASSERT(ppszPWName != NULL);
                        *ppszPWName = (LPWSTR)SSAlloc( (cchPWName + 1) * sizeof(WCHAR));
                        if(*ppszPWName == NULL) goto cleanup;

                        //
                        // sfield: defer copying strings until we know everything succeeded.
                        // this way, we don't have to zero these buffers if some
                        // allocs + copies succeed, and others fail.
                        //
                        wcscpy(*ppszPW, sz1);
                        wcscpy(*ppszPWName, szPWName);

                        bSuccess = TRUE;
        cleanup:

                        if(cch1) RtlSecureZeroMemory(sz1, cch1 * sizeof(WCHAR));
                        if(cch2) RtlSecureZeroMemory(sz2, cch2 * sizeof(WCHAR));
                        if(cchPWName) RtlSecureZeroMemory(szPWName, cchPWName * sizeof(WCHAR));

                        if(!bSuccess)
                        {
                            // UNDONE: investigate freeing ppsz's on error here
                            return FALSE;
                        }

                        break; // things went OK, just bail to EndDialog
                    }
                } // IDOK

                // gray out options
                case IDC_RADIO_SELEXISTING:
                    // set default selection to be "existing pw"
                    EnableWindow(GetDlgItem(hDlg, IDC_PW_NAME), TRUE);

                    EnableWindow(GetDlgItem(hDlg, IDC_PW_NEWNAME), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT2), FALSE);

                    // set focus to first box under button
                    SetFocus(GetDlgItem(hDlg, IDC_PW_NAME));
                    break;
                case IDC_RADIO_DEFINENEW:
                    // set default selection to be "existing pw"
                    EnableWindow(GetDlgItem(hDlg, IDC_PW_NAME), FALSE);

                    EnableWindow(GetDlgItem(hDlg, IDC_PW_NEWNAME), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT2), TRUE);

                    // set focus to first box under button
                    SetFocus(GetDlgItem(hDlg, IDC_PW_NEWNAME));
                    break;

                default:
                    break;
            }

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL) ||
               (LOWORD(wParam) == IDC_BACK)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

            break;
        }
    }

    return FALSE;
}

INT_PTR CALLBACK DialogWaitForOKCancel(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
{
    PADVANCEDCONFIRM_DIALOGARGS pDialogArgs;

    switch (message)
    {
        case WM_INITDIALOG:
            {
                pDialogArgs = (PADVANCEDCONFIRM_DIALOGARGS)lParam;

                // set dialog title
                SetWindowTextU(hDlg, pDialogArgs->szItemName);
            }
            return TRUE;

        case WM_COMMAND:
        {
            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL) ||
               (LOWORD(wParam) == IDC_BACK)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

            break;
        }
        default:
            break;
    }

    return FALSE;
}

//
// make string LPTSTR types due to the way that the call back is prototyped
// when file is not compiled with #define UNICODE
// we should look at compiling everything with #define UNICODE later
//


BOOL
CALLBACK
FMyLoadIcon(
    HINSTANCE hModule,  // resource-module handle
    LPCWSTR lpszType,    // pointer to resource type
    LPWSTR lpszName,     // pointer to resource name
    LONG_PTR lParam      // application-defined parameter
    )
{
    if ((LPCWSTR)RT_GROUP_ICON != lpszType)
        return TRUE;    // keep looking, you fool!

    //
    // LoadIcon _may_ not work on Win95 if LOAD_LIBRARY_AS_DATAFILE was
    // specified to LoadLibraryEx.
    // We want to avoid calling DLL_PROCESS_ATTACH code for anything
    // because that's a way to get arbitrary code to run in our address space
    //

    if(FIsWinNT()) {
        //
        // load the image via LoadImage, instead of LoadIcon, because
        // LoadIcon does erroneous caching in some scenarios.
        //

        *(HICON*)lParam = (HICON)LoadImageW(
                hModule,
                lpszName,
                IMAGE_ICON,
                0,
                0,
                LR_DEFAULTCOLOR | LR_DEFAULTSIZE
                );
        return FALSE;       // we've got at least one icon; stop!
    } else {

        //
        // this more convoluted approach doesn't seem to work on NT, due
        // to a limitation in CreateIconFromResource()
        // This approach is good for Win95 because it allows us to use all
        // Unicode API calls.
        //

        HRSRC   hRsrc = NULL;
        HGLOBAL hGlobal = NULL;
        LPVOID  lpRes = NULL;
        int     nID;

        *(HICON*)lParam = NULL;

        hRsrc = FindResourceW(hModule, lpszName, lpszType);

        if(hRsrc == NULL)
            return FALSE;

        hGlobal = LoadResource(hModule, hRsrc);
        if(hGlobal == NULL)
            return FALSE;

        lpRes = LockResource(hGlobal);
        if(lpRes == NULL)
            return FALSE;

        nID = LookupIconIdFromDirectory( (PBYTE)lpRes, TRUE );
        hRsrc = FindResourceW( hModule, MAKEINTRESOURCEW(nID), (LPCWSTR)RT_ICON );
        if(hRsrc == NULL)
            return FALSE;

        hGlobal = LoadResource( hModule, hRsrc );
        if(hGlobal == NULL)
            return FALSE;

        lpRes = LockResource(hGlobal);
        if(lpRes == NULL)
            return FALSE;

        // Let the OS make us an icon
        *(HICON*)lParam = CreateIconFromResource( (PBYTE)lpRes, SizeofResource(hModule, hRsrc), TRUE, 0x00030000 );

        return FALSE;

    }
}



INT_PTR CALLBACK DialogAccessDetails(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
/*++

    NOTENOTE

    Anybody calling this dialog box routine should be imperonsating the client
    associated with the call.  This allows access to icon and any on-disk
    resources to occur in the security context of the client.

--*/
{
    BOOL    fDlgEnterPassword;
    PPW_DIALOG_ARGS pDialogArgs;

    // TODO this function needs more cleanup


    switch (message)
    {
        case WM_INITDIALOG:
        {
            BOOL fImpersonated;

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is struct
            pDialogArgs = (PPW_DIALOG_ARGS)lParam;

            // init static vars
            pDialogArgs->hMyDC = GetDC(hDlg);


            // set dialog title
            SetWindowTextU(hDlg, pDialogArgs->szItemName);


            //
            // set application name, path
            //

            SetWindowTextU(GetDlgItem(hDlg,IDC_APP_PATH), pDialogArgs->szAppName);
            SetWindowTextU(GetDlgItem(hDlg, IDC_APP_NAME), L"");


            // set item name, type
            SetWindowTextU(GetDlgItem(hDlg, IDC_ITEM_NAME), pDialogArgs->szItemName);
            SetWindowTextU(GetDlgItem(hDlg, IDC_ITEM_TYPE), pDialogArgs->szItemType);

            // set messages
            SetWindowTextU(GetDlgItem(hDlg, IDC_MESSAGE), g_ItemDetailsBannerMessage);

            // set access description
            SetWindowTextU(GetDlgItem(hDlg, IDC_ACCESS_TYPE), pDialogArgs->szAccess);


            HWND hIconBox;
            RECT rect;
            POINT point;
            hIconBox = GetDlgItem(hDlg, IDC_ICONBOX);
            if ((NULL != pDialogArgs) &&
                GetWindowRect(hIconBox, &rect) && 
                (pDialogArgs->hMyDC != NULL) && 
                GetDCOrgEx(pDialogArgs->hMyDC, &point) )       // rect on window, window on screen
            {
                // need pos of icon on DC: subtract GetWindowRect()-GetDCOrgEx()
                pDialogArgs->xIconPos = rect.left - point.x;
                pDialogArgs->yIconPos = rect.top - point.y;
            }


            // update the changable data view
            SendMessage(hDlg, WM_COMMAND, (WORD)DLG_UPDATE_DATA, 0);

            return (TRUE);
        } // WM_INITDIALOG
        case WM_PAINT:
        {
            HDC hMyDC;
            HICON hIcon;

            int xIconPos, yIconPos;

            pDialogArgs = (PPW_DIALOG_ARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if(pDialogArgs == 0) break; // TODO:   bail out

            hMyDC = pDialogArgs->hMyDC;
            hIcon = pDialogArgs->hIcon;
            xIconPos = pDialogArgs->xIconPos;
            yIconPos = pDialogArgs->yIconPos;

            if ((hMyDC != NULL) && (hIcon != NULL) && (xIconPos != 0) && (yIconPos != 0))
                DrawIcon(hMyDC, xIconPos, yIconPos, hIcon);

            return (0);
        } // WM_PAINT

        case WM_COMMAND:

            pDialogArgs = (PPW_DIALOG_ARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if(pDialogArgs == 0) break; // TODO:   bail out

            switch (LOWORD(wParam))
            {
            case IDOK:
                break;

            default:
                break;
            } // switch

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL)
               )
            {
                ReleaseDC(hDlg, pDialogArgs->hMyDC);
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

            break;
    } // switch (message)

    return FALSE;
}

INT_PTR CALLBACK DialogSimplifiedPasswordConfirm(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
/*++

    NOTENOTE

    Anybody calling this dialog box routine should be imperonsating the client
    associated with the call.  This allows access to icon and any on-disk
    resources to occur in the security context of the client.

--*/
{
    BOOL    fDlgEnterPassword;
    PPW_DIALOG_ARGS pDialogArgs;

    // TODO this function needs more cleanup


    switch (message)
    {
        case WM_INITDIALOG:
        {
            BOOL fImpersonated;

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is struct
            pDialogArgs = (PPW_DIALOG_ARGS)lParam;

            // init static vars
            pDialogArgs->hMyDC = GetDC(hDlg);

            // Messages to User

            // Dialog Bar = item name
            SetWindowTextU(hDlg, pDialogArgs->szItemName);

            // application friendly name
            SetWindowTextU(GetDlgItem(hDlg, IDC_MESSAGE), L"");

            // app msg
            SetWindowTextU(GetDlgItem(hDlg, IDC_APP_MSG), pDialogArgs->szPrompt);


            // update the changable data view
            SendMessage(hDlg, WM_COMMAND, (WORD)DLG_UPDATE_DATA, 0);

            //
            // if migration disposition, bail out of UI now for OK-Cancel style.
            //

            if( (pDialogArgs->dwFlags & PST_NO_UI_MIGRATION) &&
                ((*pDialogArgs->pdwPasswordOptions) & BP_CONFIRM_OKCANCEL)
                )
            {
                SendMessage(hDlg, WM_COMMAND, IDOK, 0);
            }

            return (TRUE);
        } // WM_INITDIALOG

        case WM_PAINT:
        {
            HDC hMyDC;
            HICON hIcon;

            int xIconPos, yIconPos;

            pDialogArgs = (PPW_DIALOG_ARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if(pDialogArgs == 0) break; // TODO:  bail out

            hMyDC = pDialogArgs->hMyDC;
            hIcon = pDialogArgs->hIcon;
            xIconPos = pDialogArgs->xIconPos;
            yIconPos = pDialogArgs->yIconPos;

            if ((hMyDC != NULL) && (hIcon != NULL) && (xIconPos != 0) && (yIconPos != 0))
                DrawIcon(hMyDC, xIconPos, yIconPos, hIcon);

            return (0);

        } // WM_PAINT

        case WM_COMMAND:
            PLUID pluidAuthID;

            pDialogArgs = (PPW_DIALOG_ARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if(pDialogArgs == 0) break; // TODO:  bail out

            pluidAuthID = &(pDialogArgs->luidAuthID);

            switch (LOWORD(wParam))
            {
            case IDOK:

                if(NULL == g_pCUAList)
                {
                    return FALSE;
                }
                if (*(pDialogArgs->pdwPasswordOptions) == BP_CONFIRM_PASSWORDUI)
                {
                    WCHAR sz1[MAX_PW_LEN];
                    DWORD cch1;

                    BOOL fUserSaysCache;

                    if( g_fAllowCachePW )
                    {
                        fUserSaysCache = (BST_CHECKED == SendMessage(GetDlgItem(hDlg, IDC_CACHEPW), BM_GETCHECK, 0, 0));
                    } else {
                        fUserSaysCache = FALSE;
                    }

                    // get password
                    cch1 = GetDlgItemTextU(
                        hDlg,
                        IDC_EDIT1,
                        sz1,
                        MAX_PW_LEN);

                    //
                    // compute hashs from scratch
                    //

                    if (!MyGetPwdHash(sz1, pDialogArgs->rgbPwd))
                        break;

                    if (!MyGetPwdHashEx(sz1, pDialogArgs->rgbPwdLowerCase, TRUE))
                        break;

                    // query cache for password
                    if (FIsCachedPassword(pDialogArgs->szUserName, *pDialogArgs->ppszPWName, pluidAuthID))
                    {
                        // find cached pwd
                        UACACHE_LIST_ITEM li, *pli;
                        CreateUACacheListItem(
                                &li,
                                pDialogArgs->szUserName,
                                *pDialogArgs->ppszPWName,
                                pluidAuthID);


                        g_pCUAList->LockList();

                        // find in list
                        if (NULL == (pli = g_pCUAList->SearchList(&li))) {
                            g_pCUAList->UnlockList();
                            break;
                        }

                        // change behavior based on if user tampered with pwd
                        if (0 == wcscmp(WSZ_PASSWORD_CHANGE_DETECT_TOKEN, sz1))
                        {
                            // no; copy cached password to outbuf
                            CopyMemory(pDialogArgs->rgbPwd, pli->rgbPwd, A_SHA_DIGEST_LEN);

                            // no; copy cached password to outbuf
                            CopyMemory(pDialogArgs->rgbPwdLowerCase, pli->rgbPwdLowerCase, A_SHA_DIGEST_LEN);
                        }
                        else
                        {
                            // yes: overwrite cached entry with user-entered
                            CopyMemory(pli->rgbPwd, pDialogArgs->rgbPwd, A_SHA_DIGEST_LEN);

                            // yes: overwrite cached entry with user-entered
                            CopyMemory(pli->rgbPwdLowerCase, pDialogArgs->rgbPwdLowerCase, A_SHA_DIGEST_LEN);
                        }

                        g_pCUAList->UnlockList();


                        if (!fUserSaysCache)
                        {
                            // is already cached, and don't want it to be used

                            // remove from cache
                            g_pCUAList->DelFromList(&li);
                        }

                    }
                    else
                    {
                        if (fUserSaysCache)
                        {
                            // isn't already cached, and want it to be used

                            // create element
                            UACACHE_LIST_ITEM* pli = (UACACHE_LIST_ITEM*) SSAlloc(sizeof(UACACHE_LIST_ITEM));
                            CreateUACacheListItem(
                                    pli,
                                    NULL,
                                    NULL,
                                    pluidAuthID);

                            pli->szUserName = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(pDialogArgs->szUserName));
                            wcscpy(pli->szUserName, pDialogArgs->szUserName);

                            pli->szMKName = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(*pDialogArgs->ppszPWName));
                            wcscpy(pli->szMKName, *pDialogArgs->ppszPWName);

                            CopyMemory(pli->rgbPwd, pDialogArgs->rgbPwd, A_SHA_DIGEST_LEN);
                            CopyMemory(pli->rgbPwdLowerCase, pDialogArgs->rgbPwdLowerCase, A_SHA_DIGEST_LEN);

                            // add to list
                            g_pCUAList->AddToList(pli);
                        }
                        else
                        {
                            // isn't already cached, and don't want it to be used
                        }
                    }

                    RtlSecureZeroMemory(sz1, WSZ_BYTECOUNT(sz1));
                }

                // else

                break;

            case IDC_ADVANCED:
                {
                    // make copy so static members (x, y, hIcon) don't get stomped
                    PW_DIALOG_ARGS DetailDlgParms;
                    CopyMemory(&DetailDlgParms, pDialogArgs, sizeof(PW_DIALOG_ARGS));

                    ServicesDialogBoxParam(
                        g_hInst,
                        MAKEINTRESOURCE(IDD_ITEM_DETAILS),
                        (HWND)hDlg,
                        DialogAccessDetails,
                        (LPARAM)&DetailDlgParms);

                    // update the changable data view
                    SendMessage(hDlg, WM_COMMAND, (WORD)DLG_UPDATE_DATA, 0);
                }

                break;

            case IDC_CHANGE_SECURITY:
                {
                    ADVANCEDCONFIRM_DIALOGARGS DialogArgs = {pDialogArgs->szUserName, pDialogArgs->ppszPWName, pDialogArgs->ppszPW, pDialogArgs->pdwPasswordOptions, pDialogArgs->szItemName};

                    ChooseSecurityWizard(hDlg, &DialogArgs);

                    // commit changes
                    SendMessage(hDlg, WM_COMMAND, (WORD)DLG_UPDATE_DATA, 0);

                    break;
                }

            case DLG_UPDATE_DATA:
                {
                    WCHAR szDialogMessage[MAX_STRING_RSC_SIZE] = L"\0"; 

                    // show or hide pwd entry box?
                    fDlgEnterPassword = (*(pDialogArgs->pdwPasswordOptions) == BP_CONFIRM_PASSWORDUI);
                    if (fDlgEnterPassword)
                    {
//
// comment out the following because we don't use %ls format string at the moment.
//
                        wcscpy(szDialogMessage, g_PWPromptPrefix);
                        wcscat(szDialogMessage, *(pDialogArgs->ppszPWName));
                        wcscat(szDialogMessage, g_PWPromptSuffix);

                        SetWindowTextU(GetDlgItem(hDlg, IDC_LABEL_EDIT1), szDialogMessage);


                        // we should not hide these windows
                        ShowWindow(GetDlgItem(hDlg, IDC_EDIT1), SW_SHOW);
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), TRUE);

                        ShowWindow(GetDlgItem(hDlg, IDC_LABEL_EDIT1), SW_SHOW);
                        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_EDIT1), TRUE);




                        if( pDialogArgs->fAllowConfirmChange &&
                            g_fAllowCachePW )
                        {
                            // show or hide "cache this password" button
                            ShowWindow(GetDlgItem(hDlg, IDC_CACHEPW), SW_SHOW );
                            EnableWindow(GetDlgItem(hDlg, IDC_CACHEPW), TRUE );
                        } else {
                            ShowWindow(GetDlgItem(hDlg, IDC_CACHEPW), SW_HIDE );
                            EnableWindow(GetDlgItem(hDlg, IDC_CACHEPW), FALSE );

                        }

                        // put untypable token into pwd field
                        if (FIsCachedPassword(pDialogArgs->szUserName, *pDialogArgs->ppszPWName, pluidAuthID))
                            SetWindowTextU(GetDlgItem(hDlg, IDC_EDIT1), WSZ_PASSWORD_CHANGE_DETECT_TOKEN);

                        // show if this password is cached
                        SendMessage(GetDlgItem(hDlg, IDC_CACHEPW), BM_SETCHECK, (WPARAM)(FIsCachedPassword(pDialogArgs->szUserName, *pDialogArgs->ppszPWName, pluidAuthID)), 0);


                        SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
                    }
                    else
                    {
                        // hide pw
                        ShowWindow(GetDlgItem(hDlg, IDC_EDIT1), SW_HIDE);
                        ShowWindow(GetDlgItem(hDlg, IDC_LABEL_EDIT1), SW_HIDE);
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_LABEL_EDIT1), FALSE);

                        ShowWindow(GetDlgItem(hDlg, IDC_CACHEPW), SW_HIDE);
                        EnableWindow(GetDlgItem(hDlg, IDC_CACHEPW), FALSE);
                    }

                    // show or hide "change security" button
                    ShowWindow(GetDlgItem(hDlg, IDC_CHANGE_SECURITY), ((pDialogArgs->fAllowConfirmChange) ? SW_SHOW : SW_HIDE));
                    EnableWindow(GetDlgItem(hDlg, IDC_CHANGE_SECURITY), ((pDialogArgs->fAllowConfirmChange) ? TRUE : FALSE));

                    // show or hide "details" button
                    ShowWindow(GetDlgItem(hDlg, IDC_ADVANCED), ((pDialogArgs->fAllowConfirmChange) ? SW_SHOW : SW_HIDE));
                    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED), ((pDialogArgs->fAllowConfirmChange) ? TRUE : FALSE));

                    // show or hide "level currently set to *"
                    ShowWindow(GetDlgItem(hDlg, IDC_SEC_PREFIX), ((pDialogArgs->fAllowConfirmChange) ? SW_SHOW : SW_HIDE));
                    ShowWindow(GetDlgItem(hDlg, IDC_SEC_LEVEL), ((pDialogArgs->fAllowConfirmChange) ? SW_SHOW : SW_HIDE));


                    // jam the current security setting
                    switch(*pDialogArgs->pdwPasswordOptions)
                    {
                    case BP_CONFIRM_PASSWORDUI:
                        SetWindowTextU(GetDlgItem(hDlg, IDC_SEC_LEVEL), g_PromptHighSecurity);
                        break;
                    case BP_CONFIRM_OKCANCEL:
                        SetWindowTextU(GetDlgItem(hDlg, IDC_SEC_LEVEL), g_PromptMedSecurity);
                        break;
                    case BP_CONFIRM_NONE:
                        SetWindowTextU(GetDlgItem(hDlg, IDC_SEC_LEVEL), g_PromptLowSecurity);
                        break;
                    }

                }
                break;

            default:
                break;
            } // switch

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL)
               )
            {
                ReleaseDC(hDlg, pDialogArgs->hMyDC);
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

            break;
    } // switch (message)

    return FALSE;
}

INT_PTR CALLBACK DialogSetSecurityLevel(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
{
    PADVANCEDCONFIRM_DIALOGARGS pDialogArgs;

    BYTE        rgb1[_MAX_PATH];
    LPWSTR      pszMasterKey=NULL;
    char *      szBuffer = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            // lParam is PADVANCEDCONFIRM_DIALOGARGS
            pDialogArgs = (PADVANCEDCONFIRM_DIALOGARGS)lParam;

            // set the dialog title
            SetWindowTextU(hDlg, pDialogArgs->szItemName);

            switch(*(pDialogArgs->pdwPasswordOptions))
            {
            case BP_CONFIRM_NONE:
                SendDlgItemMessage(hDlg, IDC_RADIO_NOCONFIRM, BM_SETCHECK, BST_CHECKED, 0);
                SendMessage(hDlg, WM_COMMAND, (WORD)IDC_RADIO_NOCONFIRM, 0);
                break;

            case BP_CONFIRM_OKCANCEL:
                SendDlgItemMessage(hDlg, IDC_RADIO_OKCANCEL, BM_SETCHECK, BST_CHECKED, 0);
                SendMessage(hDlg, WM_COMMAND, (WORD)IDC_RADIO_OKCANCEL, 0);
                break;

            case BP_CONFIRM_PASSWORDUI:
            default:
                SendDlgItemMessage(hDlg, IDC_RADIO_ASSIGNPW, BM_SETCHECK, BST_CHECKED, 0);
                SendMessage(hDlg, WM_COMMAND, (WORD)IDC_RADIO_ASSIGNPW, 0);
                break;
            }


            return TRUE;
        } // WM_INITDIALOG

        case WM_COMMAND:
        {
            LPWSTR*   ppszPW;
            BOOL bSuccess = FALSE;

            switch (LOWORD(wParam))
            {
            case IDC_NEXT:
            case IDOK:
                {
                    pDialogArgs = (PADVANCEDCONFIRM_DIALOGARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                    if(pDialogArgs == 0) break; // TODO:  bail out

                    // modify *(pDialogArgs->pdwPasswordOptions);
                    if (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_RADIO_ASSIGNPW, BM_GETCHECK, 0, 0))
                    {
                        *(pDialogArgs->pdwPasswordOptions) = BP_CONFIRM_PASSWORDUI;
                    }
                    else
                        if (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_RADIO_NOCONFIRM, BM_GETCHECK, 0, 0))
                            *(pDialogArgs->pdwPasswordOptions) = BP_CONFIRM_NONE;
                        else
                            *(pDialogArgs->pdwPasswordOptions) = BP_CONFIRM_OKCANCEL;

                    if (BP_CONFIRM_PASSWORDUI != *(pDialogArgs->pdwPasswordOptions))
                    {
                        *(pDialogArgs->ppszPWName) = (LPWSTR)SSAlloc(sizeof(WSZ_PASSWORD_WINDOWS));
                        if(*(pDialogArgs->ppszPWName) != NULL)
                        {
                            wcscpy(*(pDialogArgs->ppszPWName), WSZ_PASSWORD_WINDOWS);
                        }
                    }

                    break;
                }

                default:
                    break;
            }

            if (
               (LOWORD(wParam) == IDOK) ||
               (LOWORD(wParam) == IDCANCEL) ||
               (LOWORD(wParam) == IDC_NEXT)
               )
            {
                EndDialog(hDlg, LOWORD(wParam));
                return bSuccess;
            }
        } // WM_COMMAND

        default:
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\passwd.h ===
// is this a user key or not? 
BOOL    FIsUserMasterKey(
    LPCWSTR                 szMasterKey);


// retreive the users' windows password buffer
BOOL    FMyGetWinPassword(
    PST_PROVIDER_HANDLE* phPSTProv, 
    LPCWSTR szUser,
    BYTE rgbPwd[A_SHA_DIGEST_LEN]);

DWORD BPVerifyPwd(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    LPCWSTR                 szMasterKey,
    BYTE                    rgbPwd[],
    DWORD                   dwPasswordOption);

// retrieves user defaults
HRESULT GetUserConfirmDefaults(
    PST_PROVIDER_HANDLE*    phPSTProv,
    DWORD*                  pdwDefaultConfirmationStyle,
    LPWSTR*                 ppszMasterKey);

// Be-all, end-all of user confirmation APIs
// gets whatever confirmation is necessary
HRESULT GetUserConfirmBuf(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    const GUID*             pguidType,
    LPCWSTR                 szSubtype,
    const GUID*             pguidSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction,
    DWORD                   dwDefaultConfirmationStyle,
    LPWSTR*                 ppszMasterKey,
    BYTE                    rgbPwd[A_SHA_DIGEST_LEN],
    DWORD                   dwFlags);

// Calls above API with PST_CF_DEFAULT as dwDefaultConfirmationStyle
HRESULT GetUserConfirmBuf(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    const GUID*             pguidType,
    LPCWSTR                 szSubtype,
    const GUID*             pguidSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction,
    LPWSTR*                 ppszMasterKey,
    BYTE                    rgbPwd[A_SHA_DIGEST_LEN],
    DWORD                   dwFlags);

// forces UI with OK/Cancel behavior
HRESULT ShowOKCancelUI(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    LPCWSTR                 szSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\passwd.cpp ===
/*
    File:       Passwd.cpp

    Title:      Protected Storage User Confirm wrappers
    Author:     Matt Thomlinson
    Date:       2/25/97

    Passwd.cpp simply houses a few of the password-management
    functions. These functions are called on to return the
    user-confirmation derived buffer, and check synchronization
    in certain cases.

    As the Authentication provider interface gets defined, this
    could end up getting moved into a seperate provider.



*/

#include <pch.cpp>
#pragma hdrstop




#include "provui.h"
#include "storage.h"

#include "passwd.h"



extern              DISPIF_CALLBACKS    g_sCallbacks;
extern              PRIVATE_CALLBACKS   g_sPrivateCallbacks;
extern              CUAList*            g_pCUAList;


///////////////////////////////////////////////////////////////////////
// non-user editable passwords

BOOL FIsUserMasterKey(LPCWSTR szMasterKey)
{
    if (0 == wcscmp(szMasterKey, WSZ_PASSWORD_WINDOWS))
        return FALSE;

    return TRUE;
}

BOOL    FMyGetWinPassword(
    PST_PROVIDER_HANDLE* phPSTProv,
    LPCWSTR szUser,
    BYTE rgbPwd[A_SHA_DIGEST_LEN] )
{
    // nab pwd
    if (0 == wcscmp(szUser, WSZ_LOCAL_MACHINE))
    {
        CopyMemory(rgbPwd, RGB_LOCALMACHINE_KEY, A_SHA_DIGEST_LEN);
    }
    else
    {
 /*
        if (! g_sPrivateCallbacks.pfnFGetWindowsPassword(
                phPSTProv,
                rgbPwd,
                A_SHA_DIGEST_LEN))
            return FALSE;
  */
        A_SHA_CTX context;
        DWORD cb = lstrlenW(szUser) * sizeof(WCHAR);
        BYTE Magic1[] = {0x66, 0x41, 0xa3, 0x29};
        BYTE Magic2[] = {0x14, 0x9a, 0xef, 0x82};

        A_SHAInit(&context);
        // note: the three Update calls get buffered up internally to
        // multiples of 64 bytes.
        //
        A_SHAUpdate(&context, Magic1, sizeof(Magic1));
        A_SHAUpdate(&context, (LPBYTE)szUser, cb);
        A_SHAUpdate(&context, Magic2, (cb+sizeof(Magic2)) % sizeof(Magic2));
        A_SHAFinal(&context, rgbPwd);
    }

    return TRUE;
}

// Base Provider specific fxn: check the password
DWORD BPVerifyPwd(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    LPCWSTR                 szMasterKey,
    BYTE                    rgbPwd[],
    DWORD                   dwPasswordOption)
{
    DWORD dwRet = (DWORD)PST_E_WRONG_PASSWORD;

    if (dwPasswordOption != BP_CONFIRM_PASSWORDUI)
    {
        // only non-user keys can be silent (WinPWs only, to be exact)
        if (FIsUserMasterKey(szMasterKey))
            goto Ret;

        // get the Windows pwd
        if (!FMyGetWinPassword(phPSTProv, szUser, rgbPwd))
            goto Ret;

        // check
        if (!FCheckPWConfirm(
                szUser,
                szMasterKey,
                rgbPwd))
        {
            dwRet = (DWORD)PST_E_WRONG_PASSWORD;
            goto Ret;
        }
    }
    else    // UI wanted
    {
        // is it the windows password?
        if (0 == wcscmp(szMasterKey, WSZ_PASSWORD_WINDOWS))
        {
            BYTE rgbWinPwd[A_SHA_DIGEST_LEN];

            // we need to keep user, WinPW in sync
            if(!FMyGetWinPassword(
                    phPSTProv,
                    szUser,
                    rgbWinPwd
                    ))
            {
                dwRet = (DWORD)PST_E_WRONG_PASSWORD;
                goto Ret;
            }

            if (0 != memcmp(rgbWinPwd, rgbPwd, sizeof(rgbWinPwd) ))
            {
                // no match: user entered old password?
                if (FCheckPWConfirm(
                        szUser,
                        szMasterKey,
                        rgbPwd))
                {
                    // err: user entered neither old nor new password
                    dwRet = (DWORD)PST_E_WRONG_PASSWORD;
                    goto Ret;
                }
            }
            else
            {
                // matched: user entered password we consider good
                if (!FCheckPWConfirm(
                        szUser,
                        szMasterKey,
                        rgbPwd))
                {
                    dwRet = (DWORD)PST_E_WRONG_PASSWORD;
                    goto Ret;
                }
            }

        }
        else
        {
            // else: not win pw, just do pw correctness check
            if (!FCheckPWConfirm(
                    szUser,
                    szMasterKey,
                    rgbPwd))
            {
                dwRet = (DWORD)PST_E_WRONG_PASSWORD;
                goto Ret;
            }
        }
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    return dwRet;
}


HRESULT GetUserConfirmDefaults(
    PST_PROVIDER_HANDLE*    phPSTProv,
    DWORD*                  pdwDefaultConfirmationStyle,
    LPWSTR*                 ppszMasterKey)
{
    SS_ASSERT(ppszMasterKey != NULL);
    SS_ASSERT(pdwDefaultConfirmationStyle != NULL);

    PBYTE pbData = NULL;
    DWORD cbData;
    HRESULT hr = PST_E_FAIL;

    // if not found, restore the machine defaults

    // alloc sizeof string + dword
    cbData = sizeof(WSZ_PASSWORD_WINDOWS) + sizeof(DWORD);
    pbData = (PBYTE)SSAlloc(cbData);
    if(pbData == NULL)
        return PST_E_FAIL;

    // copy string, DWORD confirmation type
    *(DWORD*)pbData = BP_CONFIRM_OKCANCEL;
    CopyMemory(pbData+sizeof(DWORD), WSZ_PASSWORD_WINDOWS, sizeof(WSZ_PASSWORD_WINDOWS));

    // format: confirmation style DWORD, sz
    *pdwDefaultConfirmationStyle = *(DWORD*)pbData;
    *ppszMasterKey = (LPWSTR)SSAlloc(WSZ_BYTECOUNT((LPWSTR)(pbData+sizeof(DWORD))));

    if(*ppszMasterKey != NULL) {
        wcscpy(*ppszMasterKey, (LPWSTR) (pbData+sizeof(DWORD)) );
        hr = PST_E_OK;
    }

    // free what ConfigData returned
    if (pbData)
        SSFree(pbData);

    return hr;
}


void NotifyOfWrongPassword(
            HWND hwnd,
            LPCWSTR szItemName,
            LPCWSTR szPasswordName)
{
    LPWSTR szMessage;

    if (0 == wcscmp(szPasswordName, WSZ_PASSWORD_WINDOWS))
        szMessage = g_PasswordWinNoVerify;
    else
        szMessage = g_PasswordNoVerify;     // error doesn't deal with win pw

    MessageBoxW(hwnd, szMessage, szItemName, MB_OK | MB_SERVICE_NOTIFICATION);
}

// #define to force an unreadable confirmation to bail from read proc
#define PST_CF_STORED_ONLY  0xcf000001

HRESULT GetUserConfirmBuf(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    const GUID*             pguidType,
    LPCWSTR                 szSubtype,
    const GUID*             pguidSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction,
    LPWSTR*                 ppszMasterKey,
    BYTE                    rgbPwd[A_SHA_DIGEST_LEN],
    DWORD                   dwFlags)
{
    return GetUserConfirmBuf(
        phPSTProv,
        szUser,
        Key,
        szType,
        pguidType,
        szSubtype,
        pguidSubtype,
        szItemName,
        psPrompt,
        szAction,
        PST_CF_STORED_ONLY,        // hardcoded: must be able to retreive in order to show ui
        ppszMasterKey,
        rgbPwd,
        dwFlags);
}

#define MAX_PASSWD_TRIALS 3

HRESULT GetUserConfirmBuf(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    const GUID*             pguidType,
    LPCWSTR                 szSubtype,
    const GUID*             pguidSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction,
    DWORD                   dwDefaultConfirmationStyle,
    LPWSTR*                 ppszMasterKey,
    BYTE                    rgbOutPwd[A_SHA_DIGEST_LEN],
    DWORD                   dwFlags)
{
    HRESULT     hr;
    DWORD       dwStoredConfirm, dwChosenConfirm;
    LPWSTR      szCallerName = NULL;
    BOOL        fPromptedUser = FALSE;

    BOOL        fIsCached = FALSE;
    BOOL        fCacheItNow = FALSE;

    BOOL        fPwdVerified = FALSE;

    SS_ASSERT(*ppszMasterKey == NULL);   // don't whack existing memory


    if (Key == PST_KEY_LOCAL_MACHINE)
    {
        // short-circuit password gathering, setting
        *ppszMasterKey = (LPWSTR) SSAlloc(sizeof(WSZ_PASSWORD_WINDOWS));
        if( *ppszMasterKey == NULL )
        {
            hr = PST_E_FAIL;
            goto Ret;
        }

        wcscpy(*ppszMasterKey, WSZ_PASSWORD_WINDOWS);

        CopyMemory(rgbOutPwd, RGB_LOCALMACHINE_KEY, A_SHA_DIGEST_LEN);

        // done
        hr = PST_E_OK;
        goto Ret;
    }


    if (!g_sCallbacks.pfnFGetCallerName(phPSTProv, &szCallerName, NULL)) {
        hr = PST_E_FAIL;
        goto Ret;
    }

    // Which is this: item creation, item access?
    // item access does user authentication
    SS_ASSERT(szItemName != NULL);

    // per-item key
    if (PST_E_OK != (hr =
        BPGetItemConfirm(
            phPSTProv,
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &dwStoredConfirm,
            ppszMasterKey)) )
    {
        // this could be a failure in
        // * confirmation: tampering detected!!
        // * password: couldn't grab user pwd
        if (dwDefaultConfirmationStyle == PST_CF_STORED_ONLY)
            goto Ret;

        //
        // if UI is not allowed (eg, Local System account), over-ride
        // confirmation style.
        //
        if (dwDefaultConfirmationStyle != PST_CF_NONE)
        {
            if(!FIsProviderUIAllowed( szUser ))
                dwDefaultConfirmationStyle = PST_CF_NONE;
        }

        // if app asked to have no confirm, set item that way
        if (dwDefaultConfirmationStyle == PST_CF_NONE)
        {
            dwChosenConfirm = BP_CONFIRM_NONE;

            // short-circuit password gathering, setting
            *ppszMasterKey = (LPWSTR) SSAlloc(sizeof(WSZ_PASSWORD_WINDOWS));
            if(*ppszMasterKey == NULL)
            {
                hr = PST_E_FAIL;
                goto Ret;
            }
            wcscpy(*ppszMasterKey, WSZ_PASSWORD_WINDOWS);
        }
        else    // app allows user to decide
        {
            // get user default
            if (PST_E_OK != (hr = GetUserConfirmDefaults(
                    phPSTProv,
                    &dwChosenConfirm,
                    ppszMasterKey)) )
                goto Ret;
        }

        // if user default is silent, don't bother user
        switch(dwChosenConfirm)
        {
            // if no confirm
            case BP_CONFIRM_NONE:
                break;

            // if we know the confirm type
            case BP_CONFIRM_PASSWORDUI:
            {
                // make sure we're not asking the user for a password he can't satisfy
                if (!FIsUserMasterKey(*ppszMasterKey))
                {
                    hr = PST_E_NO_PERMISSIONS;
                    goto Ret;
                }

                // else fall through to prompting case
            }

            case BP_CONFIRM_OKCANCEL:
            {
                int i;
                fPromptedUser = TRUE;

                for(i=1;  ; i++)
                {
                    BYTE rgbOutPwdLowerCase[A_SHA_DIGEST_LEN];

                    // Request the user apply a new password
                    if (!FSimplifiedPasswordConfirm(
                            phPSTProv,
                            szUser,
                            szCallerName,
                            szType,
                            szSubtype,
                            szItemName,
                            psPrompt,
                            szAction,
                            ppszMasterKey,
                            &dwChosenConfirm,
                            TRUE,           // user select which pwd
                            rgbOutPwd,
                            A_SHA_DIGEST_LEN,
                            rgbOutPwdLowerCase,
                            A_SHA_DIGEST_LEN,
                            dwFlags
                            ))
                    {
                        hr = PST_E_NO_PERMISSIONS;
                        goto Ret;
                    }

                    // verify whatever password we got
                    if (PST_E_OK != (hr =
                        BPVerifyPwd(
                            phPSTProv,
                            szUser,
                            *ppszMasterKey,
                            rgbOutPwd,
                            dwChosenConfirm)) )
                    {

                        //
                        // try lower-case form to handle Win9x migration case.
                        //

                        if (PST_E_OK != (hr =
                            BPVerifyPwd(
                                phPSTProv,
                                szUser,
                                *ppszMasterKey,
                                rgbOutPwdLowerCase,
                                dwChosenConfirm)) )
                        {
                            // too many trials? break out of loop
                            if (i < MAX_PASSWD_TRIALS)
                            {
                                // notify user, give them another chance
                                NotifyOfWrongPassword((HWND)psPrompt->hwndApp, szItemName, *ppszMasterKey);

                                continue;
                            } else {
                                break;  // break out
                            }
                        } else {

                            CopyMemory( rgbOutPwd, rgbOutPwdLowerCase, A_SHA_DIGEST_LEN );

                        }
                    }

                    // passed verify password test: break out of loop!
                    fPwdVerified = TRUE;
                    break;
                }

                if (!fPwdVerified)
                {
                    hr = PST_E_NO_PERMISSIONS;
                    goto Ret;
                }
            }
        }


        // and remember the selections made
        if (PST_E_OK != (hr =
            BPSetItemConfirm(
                phPSTProv,
                szUser,
                pguidType,
                pguidSubtype,
                szItemName,
                dwChosenConfirm,
                *ppszMasterKey)) )
            goto Ret;

        // now, _this_ is the stored confirm
        dwStoredConfirm = dwChosenConfirm;
    }
    else
    {
        // keep a copy of the stored key
        LPWSTR szStoredMasterKey = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(*ppszMasterKey));
        if(NULL != szStoredMasterKey)
        {
            CopyMemory(szStoredMasterKey, *ppszMasterKey, WSZ_BYTECOUNT(*ppszMasterKey));
        }

        // we retrieved confirmation behavior
        dwChosenConfirm = dwStoredConfirm;  // already chosen for you

        switch (dwStoredConfirm)
        {
            // if no confirm
            case BP_CONFIRM_NONE:
                break;

            // if we know the confirm type
            case BP_CONFIRM_PASSWORDUI:
            {
                // else fall through to prompting case
            }

            case BP_CONFIRM_OKCANCEL:
            {
                // retrieved item, must show ui, but not allowed to show ui
                if (psPrompt->dwPromptFlags & PST_PF_NEVER_SHOW)
                {
                    hr = ERROR_PASSWORD_RESTRICTION;
                    goto Ret;
                }

                // found that a pwd is req'd
                fPromptedUser = TRUE;
                fCacheItNow = fIsCached;

                int i;

                for(i=1;  ; i++)
                {
                    BYTE rgbOutPwdLowerCase[A_SHA_DIGEST_LEN];

                    // ask the user for it
                    if (!FSimplifiedPasswordConfirm(
                            phPSTProv,
                            szUser,
                            szCallerName,
                            szType,
                            szSubtype,
                            szItemName,
                            psPrompt,
                            szAction,
                            ppszMasterKey,
                            &dwChosenConfirm,
                            TRUE,           // allow user to select pwd
                            rgbOutPwd,
                            A_SHA_DIGEST_LEN,
                            rgbOutPwdLowerCase,
                            A_SHA_DIGEST_LEN,
                            dwFlags
                            ))
                    {
                        hr = PST_E_NO_PERMISSIONS;
                        goto Ret;
                    }

                    // if we got it from the cache and user left it alone
                    {
                        // verify whatever password we got
                        if (PST_E_OK != (hr =
                            BPVerifyPwd(
                                phPSTProv,
                                szUser,
                                *ppszMasterKey,
                                rgbOutPwd,
                                dwChosenConfirm)) )
                        {
                            //
                            // check lower case form.
                            //

                            if (PST_E_OK != (hr =
                                BPVerifyPwd(
                                    phPSTProv,
                                    szUser,
                                    *ppszMasterKey,
                                    rgbOutPwdLowerCase,
                                    dwChosenConfirm)) )
                            {

                                // too many trials? break out of loop
                                if (i < MAX_PASSWD_TRIALS)
                                {
                                    // notify user, give them another chance
                                    NotifyOfWrongPassword((HWND)psPrompt->hwndApp, szItemName, *ppszMasterKey);

                                    continue;
                                }
                                else
                                {
                                    hr = PST_E_NO_PERMISSIONS;
                                    goto Ret;
                                }
                            } else {

                                CopyMemory( rgbOutPwd, rgbOutPwdLowerCase, A_SHA_DIGEST_LEN );
                            }
                        }

                        fPwdVerified = TRUE;
                    }

                    // passed verify password test: break out of loop!
                    break;
                }

                break;
            }

        } // end switch


        // have we received all data we need from the user?
        // user may choose to change the way items are encrypted;
        // if stored under password, we must make them enter the old pwd
        if ((dwStoredConfirm != dwChosenConfirm) ||                     // confirm type changed  OR
            (NULL == szStoredMasterKey) || 
            (0 != wcscmp(*ppszMasterKey, szStoredMasterKey)) )          // difft master key

        {
            BYTE rgbOldPwd[A_SHA_DIGEST_LEN];
            BOOL fDontAllowCache = FALSE;
            BOOL fOldPwdVerified = FALSE;

            PST_PROMPTINFO         sGetOldPWPrompt = {sizeof(PST_PROMPTINFO), psPrompt->dwPromptFlags, psPrompt->hwndApp, g_PasswordSolicitOld};

            // only re-display if originally passworded
            if (dwStoredConfirm == BP_CONFIRM_PASSWORDUI)
            {
                for(int i=1;  ; i++)
                {
                    BYTE rgbOldPwdLowerCase[A_SHA_DIGEST_LEN];

                    // ask the user for it
                    if (!FSimplifiedPasswordConfirm(
                            phPSTProv,
                            szUser,
                            szCallerName,
                            szType,
                            szSubtype,
                            szItemName,
                            &sGetOldPWPrompt,
                            szAction,
                            &szStoredMasterKey,
                            &dwStoredConfirm,
                            FALSE,           // don't allow user to get around this one
                            rgbOldPwd,
                            sizeof(rgbOldPwd),
                            rgbOldPwdLowerCase,
                            sizeof(rgbOldPwdLowerCase),
                            dwFlags
                            ))
                    {
                        hr = PST_E_NO_PERMISSIONS;
                        goto Ret;
                    }

                    // verify whatever password we got
                    if (PST_E_OK != (hr =
                        BPVerifyPwd(
                            phPSTProv,
                            szUser,
                            szStoredMasterKey,
                            rgbOldPwd,
                            dwStoredConfirm)) )
                    {
                        if (PST_E_OK != (hr =
                            BPVerifyPwd(
                                phPSTProv,
                                szUser,
                                szStoredMasterKey,
                                rgbOldPwdLowerCase,
                                dwStoredConfirm)) )
                        {
                            // too many trials? break out of loop
                            if (i < MAX_PASSWD_TRIALS)
                            {
                                // notify user, give them another chance
                                NotifyOfWrongPassword((HWND)sGetOldPWPrompt.hwndApp, szItemName, szStoredMasterKey);

                                continue;
                            } else {
                                break;  // break out
                            }
                        } else {
                            CopyMemory( rgbOldPwd, rgbOldPwdLowerCase, A_SHA_DIGEST_LEN );
                        }
                    }

                    // passed verify password test: break out of loop!
                    fOldPwdVerified = TRUE;
                    break;
                }

                if (!fOldPwdVerified)
                {
                    hr = PST_E_NO_PERMISSIONS;
                    goto Ret;
                }
            }
            else
            {
                // ok/cancel; silent pwd usage

                // use VerifyPwd fxn to retrieve the pwd
                if (PST_E_OK != (hr =
                    BPVerifyPwd(
                        phPSTProv,
                        szUser,
                        szStoredMasterKey,
                        rgbOldPwd,
                        dwStoredConfirm)) )
                {
                    hr = PST_E_NO_PERMISSIONS;
                    goto Ret;
                }
            }

            //////
            // execute pwd change HERE
            {
                PBYTE pbData = NULL;
                DWORD cbData;

                // FBPGetSecuredItemData        // decrypt data with old
                if (!FBPGetSecuredItemData(
                        szUser,
                        szStoredMasterKey,
                        rgbOldPwd,
                        pguidType,
                        pguidSubtype,
                        szItemName,
                        &pbData,
                        &cbData))
                {
                    hr = PST_E_STORAGE_ERROR;
                    goto Ret;
                }

                // FBPSetSecuredItemData        // encrypt data with new
                if (!FBPSetSecuredItemData(
                        szUser,
                        *ppszMasterKey,
                        rgbOutPwd,
                        pguidType,
                        pguidSubtype,
                        szItemName,
                        pbData,
                        cbData))
                {
                    hr = PST_E_STORAGE_ERROR;
                    goto Ret;
                }

                if (pbData)
                    SSFree(pbData);

                // BPSetItemConfirm             // store new confirm type
                if (PST_E_OK !=
                    BPSetItemConfirm(
                        phPSTProv,
                        szUser,
                        pguidType,
                        pguidSubtype,
                        szItemName,
                        dwChosenConfirm,
                        *ppszMasterKey))
                {
                    hr = PST_E_STORAGE_ERROR;
                    goto Ret;
                }
            }

        }


        if (szStoredMasterKey)
        {
            SSFree(szStoredMasterKey);
            szStoredMasterKey = NULL;
        }
    }



    // verify whatever password we got if not yet verified
    if (!fPwdVerified)
    {
        if (PST_E_OK != (hr =
            BPVerifyPwd(
                phPSTProv,
                szUser,
                *ppszMasterKey,
                rgbOutPwd,
                dwChosenConfirm)) )
            goto Ret;
    }

    // Now correct pwd is in rgbOutPwd ALWAYS

    // if we haven't prompted user and were supposed to
    if (!fPromptedUser && (psPrompt->dwPromptFlags == PST_PF_ALWAYS_SHOW))
    {
        // we must've retrieved from cache OR Automagic WinPW
        SS_ASSERT(fIsCached || (BP_CONFIRM_NONE == dwStoredConfirm));

        BYTE rgbBarfPwd[A_SHA_DIGEST_LEN*2];
        BYTE rgbBarfPwdLowerCase[A_SHA_DIGEST_LEN];

        // haven't prompted user but must confirm
        if (!FSimplifiedPasswordConfirm(
                phPSTProv,
                szUser,
                szCallerName,
                szType,
                szSubtype,
                szItemName,
                psPrompt,
                szAction,
                ppszMasterKey,
                &dwChosenConfirm,
                FALSE,
                rgbBarfPwd,
                sizeof(rgbBarfPwd),
                rgbBarfPwdLowerCase,
                sizeof(rgbBarfPwdLowerCase),
                dwFlags
                ) )
        {
            hr = PST_E_NO_PERMISSIONS;
            goto Ret;
        }

    }

    hr = PST_E_OK;
Ret:

    if (szCallerName)
        SSFree(szCallerName);

    return hr;
}



HRESULT ShowOKCancelUI(
    PST_PROVIDER_HANDLE*    phPSTProv,
    LPCWSTR                 szUser,
    PST_KEY                 Key,
    LPCWSTR                 szType,
    LPCWSTR                 szSubtype,
    LPCWSTR                 szItemName,
    PPST_PROMPTINFO         psPrompt,
    LPCWSTR                 szAction)
{
    BOOL fCache = FALSE;
    BYTE rgbTrash[A_SHA_DIGEST_LEN*2];
    BYTE rgbTrashLowerCase[A_SHA_DIGEST_LEN];
    DWORD dwConfirmOptions = BP_CONFIRM_OKCANCEL;

    LPWSTR szMasterKey = NULL;
    LPWSTR szCallerName = NULL;

    DWORD dwRet = PST_E_FAIL;

    if (Key == PST_KEY_LOCAL_MACHINE)
    {
        // done
        dwRet = PST_E_OK;
        goto Ret;
    }

    szMasterKey = (LPWSTR)SSAlloc(sizeof(WSZ_NULLSTRING));

    if(szMasterKey)
    {
        wcscpy(szMasterKey, WSZ_NULLSTRING);
    }

    if (!g_sCallbacks.pfnFGetCallerName(phPSTProv, &szCallerName, NULL))
        goto Ret;

    if (!FSimplifiedPasswordConfirm(
            phPSTProv,
            szUser,
            szCallerName,
            szType,
            szSubtype,
            szItemName,
            psPrompt,
            szAction,
            &szMasterKey,
            &dwConfirmOptions,
            FALSE,
            rgbTrash,
            sizeof(rgbTrash),
            rgbTrashLowerCase,
            sizeof(rgbTrashLowerCase),
            0
            ) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (szCallerName)
        SSFree(szCallerName);

    if (szMasterKey)
        SSFree(szMasterKey);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\provui.h ===
#ifndef _PROVUI_H_
#define _PROVUI_H_

#include "pstypes.h"
#include "dispif.h"

//////////////////////////////
// string resources we load 
extern LPWSTR g_PromptReadItem;
extern LPWSTR g_PromptOpenItem;
extern LPWSTR g_PromptWriteItem;
extern LPWSTR g_PromptDeleteItem;

extern LPWSTR g_PasswordNoVerify;
extern LPWSTR g_PasswordWinNoVerify;
extern LPWSTR g_PasswordSolicitOld;

//////////////////////////////
// String load/unload routines
BOOL InitUI();
BOOL ReleaseUI();

//////////////////////////////
// Miscellaneous support

BOOL
FIsProviderUIAllowed(
    LPCWSTR szUser
    );


//////////////////////////////
// Dialogs

BOOL FSimplifiedPasswordConfirm(
        PST_PROVIDER_HANDLE*    phPSTProv,
        LPCWSTR                 szUserName,        
        LPCWSTR                 szCallerName, 
        LPCWSTR                 szType,
        LPCWSTR                 szSubtype,
        LPCWSTR                 szItemName,
        PPST_PROMPTINFO         psPrompt,   
        LPCWSTR                 szAccessType,
        LPWSTR*                 ppszPWName,
        DWORD*                  pdwPasswordOptions,
        BOOL                    fAllowUserFreedom,
//        BOOL*                   pfCacheThisPasswd,
        BYTE                    rgbPasswordDerivedBytes[], 
        DWORD                   cbPasswordDerivedBytes,
        BYTE                    rgbPasswordDerivedBytesLowerCase[],
        DWORD                   cbPasswordDerivedBytesLowerCase,
        DWORD                   dwFlags);

BOOL FChangePassword(
        HWND                    hParentWnd,
        LPCWSTR                 szUserName);

BOOL FGetChangedPassword(
        PST_PROVIDER_HANDLE*    phPSTProv,
        HWND                    hParentWnd,
        LPCWSTR                 szUserName,
        LPCWSTR                 szPasswordName,
        BYTE                    rgbNewPasswordDerivedBytes[]);

//////////////////////////////
// Dialog box args

typedef struct _PW_DIALOG_ARGS
{
    PST_PROVIDER_HANDLE*    phPSTProv;
    LPCWSTR     szAppName;
    LPCWSTR     szAccess;
    LPCWSTR     szPrompt;
    LPCWSTR     szItemType;
    LPCWSTR     szItemName;
    LPCWSTR     szUserName;
    LPWSTR*     ppszPWName;
    LPWSTR*     ppszPW;
    DWORD*      pdwPasswordOptions;

    BOOL        fAllowConfirmChange;    // defining subtype
    BOOL*       pfCacheThisPasswd;      

    BYTE*       rgbPwd;             // A_SHA_DIGEST_LEN
    BYTE*       rgbPwdLowerCase;    // A_SHA_DIGEST_LEN
    LUID        luidAuthID;         // Windows NT authentication ID
    DWORD       dwFlags;            // dwFlags to SP calls.

    HDC hMyDC;
    HICON hIcon;
    int xIconPos;
    int yIconPos;
} PW_DIALOG_ARGS, *PPW_DIALOG_ARGS;

/*
typedef struct _NEWPW_DIALOGARGS
{
    LPCWSTR     szUserName;
    LPWSTR*     ppszPWName;
    LPWSTR*     ppszPW;
} NEWPW_DIALOGARGS, *PNEWPW_DIALOGARGS;
*/

typedef struct _OLDNEWPW_DIALOGARGS
{
    LPCWSTR     szUserName;
    LPWSTR*     ppszPWName;
    LPWSTR*     ppszOldPW;
    LPWSTR*     ppszNewPW;
} OLDNEWPW_DIALOGARGS, *POLDNEWPW_DIALOGARGS; 

typedef struct _SOLICITOLDPW_DIALOGARGS
{
    LPCWSTR     szPWName;
    LPWSTR*     ppszOldPW;
    LPWSTR*     ppszNewPW;
} SOLICITOLDPW_DIALOGARGS, *PSOLICITOLDPW_DIALOGARGS; 


typedef struct _ADVANCEDCONFIRM_DIALOGARGS
{
    LPCWSTR     szUserName;
    LPWSTR*     ppszPWName;
    LPWSTR*     ppszPW;
    DWORD*      pdwPasswordOptions;
    LPCWSTR     szItemName;
} ADVANCEDCONFIRM_DIALOGARGS, *PADVANCEDCONFIRM_DIALOGARGS; 


#endif // _PROVUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\secure.cpp ===
/*
    File:       Secure.cpp

    Title:      Cryptographic Funcs for Protected Storage
    Author:     Matt Thomlinson
    Date:       11/18/96

    Builds up usable cryptographic functionality and exports for
    usage by storage module. Since CryptoAPI base provider may call
    us, we can't use CryptXXX primitives (circular dependencies
    may result). Instead, we build up functions from SHA-1
    hash and DES-CBC primitives to Encrypt/Decrypt key blocks, MAC
    items, and check password confirmation blocks.


    **Master Key Usage**

    Encryption is done in a strange way to ease password management
    headaches.

        // derive a key from the user password, and the password-unique salt
        // Salt foils certain (dictionary) attacks on the password

        // PWSalt is PASSWORD_SALT_LEN
        // UserPW is SHA-1 hash of password excluding zt
        // DerivedKey1 is 56-bit DES key

            DerivedKey1 = DeriveKey(UserPW | PWSalt);


        // using the derived key, decrypt the encrypted master keys

        // encrypted master keys are E(master key bits | pwd confirm bits)

            MasterBits | PwdConfirmBits = Decrypt( (MasterKey|PwdConfirmKey), DerivedKey1);


        // Now we have recovered keys
        // MasterKey, PwdConfirmKey are 56-bit DES keys

            MasterKey
            PwdConfirmKey


        // check to make sure this is correct MasterKey by MACing
        // the global confirmation string and checking against stored MAC

            PwdConfirmMAC = HMAC(g_ConfirmBuf, PwdConfirmKey)
            if (0 != memcmp(PwdConfirmMac, rgbStoredMAC, 20)
                // wrong pwd!!


    We've derived a master key that we can create reproducibly and
    be changed without touching every item encrypted by it. That is,
    If the user changes the password, we simply need to keep the
    MasterBits constant and Encrypt with the new DerivedKey1 to find
    the EncryptedMasterBits to write to disk. In this way, we can change
    the password without changing the (exceedingly long) master key.

    We also have an immediate indication of whether or not the password
    used to decrypt the master key is correct.


    **Encrypting/MACing a single item**

        // assume we have 56-bit DES MasterKey from above
        // use master key to decrypt the encrypted item keyblock
        // key block holds two keys: Item key and MAC key

            ItemKeyBits | MACKeyBits = Decrypt( (ItemKey|MACKey), MasterKey);

        // Recovered two DES keys
        // ItemKey is 56 bits
        // MACKey is 56 bits

            ItemKey
            MACKey

        // MAC the item

            ItemMAC = HMAC(pbItemData, MACKey);

        // Tack the items' MAC onto the item, and encrypt

            EncryptedItem = ENCRYPTED_DATA_VER | Encrypt(pbItemData | ItemMAC, ItemKey);

    We've succeeded in encrypting and MACing an item using the single DES
    MasterKey from above. The item is both privacy and integrity protected.


  **Derive Key**
  **HMAC**

    Above we've skimmed over the definition of key derivation and HMAC.
    See primitiv.cpp for a description of how this primitive
    functionality is implemented.


    //  Format of the encrypted item data stream:
    //  version | size(keyblk) | keyblk | size(encryptedblk) | Encrypted{ size(data) | data | size(MAC) | MAC}



*/

#include <pch.cpp>
#pragma hdrstop
#include "storage.h"




// from des.h
#define DES_KEYLEN 8


// MAC buffer we use to check correct decryption
static      BYTE g_rgbConfirmBuf[] = "(c) 1996 Microsoft, All Rights Reserved";



// Data Version
//
// #define     ENCRYPTED_DATA_VER     0x01
// 6-12-97: version incremented. Previous versions
// should use MyOldPrimitiveHMAC -- different MAC attached to items
#define     ENCRYPTED_DATA_VER          0x02

// MK Version
//
// #define     ENCRYPTED_MASTERKEY_VER     0x01
// 6-12-97: version incremented. Previous versions
// should use MyOldPrimitiveHMAC -- different MAC attached to items
// #define     ENCRYPTED_MASTERKEY_VER     0x02
// 5-3-99: version incremented. Previous versions
// should use sizeof(rgbpwd)
#define     ENCRYPTED_MASTERKEY_VER     0x03


// given pwd, salt, and ptr to master key buffer,
// decrypts and checks MAC on master key
BOOL FMyDecryptMK(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK)
{

    BOOL fResetSecurityState;

    return FMyDecryptMKEx(
            rgbSalt,
            cbSalt,
            rgbPwd,
            rgbConfirm,
            ppbMK,
            pcbMK,
            &fResetSecurityState
            );

}

BOOL
FMyDecryptMKEx(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK,
            BOOL    *pfResetSecurityState
            )
{
    BOOL fRet = FALSE;
    DESKEY  sDerivedKey1;
    DESKEY  sConfirmKey;
    DWORD   dwMKVersion;
    PBYTE   pTemp;

    BYTE    rgbHMACResult[A_SHA_DIGEST_LEN];


    // version check!!
    dwMKVersion = *(DWORD*)*ppbMK;
    if (ENCRYPTED_MASTERKEY_VER < dwMKVersion)
        goto Ret;


    if( dwMKVersion < 0x03 ) {

        *pfResetSecurityState = TRUE;

        // DK1 = DeriveKey(SHA(pw), Salt)
        if (!FMyPrimitiveDeriveKey(
                rgbSalt,
                cbSalt,
                rgbPwd,
                sizeof(rgbPwd),
                &sDerivedKey1))
            goto Ret;

    } else {

        *pfResetSecurityState = FALSE;

        // DK1 = DeriveKey(SHA(pw), Salt)
        if (!FMyPrimitiveDeriveKey(
                rgbSalt,
                cbSalt,
                rgbPwd,
                A_SHA_DIGEST_LEN,
                &sDerivedKey1))
            goto Ret;
    }



    *pcbMK -= sizeof(DWORD);
    if (!(*pcbMK)) {

        // Paranoid

        goto Ret;
    }
    MoveMemory(*ppbMK, *ppbMK + sizeof(DWORD), *pcbMK); // shift data left 1 dw, splat version
    pTemp = (PBYTE)SSReAlloc(*ppbMK, *pcbMK);
    if (pTemp == NULL) {    // check allocation
        goto Ret;
    }

    *ppbMK = pTemp;


    // Decrypt MK bits
    if (!FMyPrimitiveDESDecrypt(
            *ppbMK,
            pcbMK,
            sDerivedKey1))
        goto Ret;

    // assumes is at least 2*DES_KEYLEN bytes
    if (*pcbMK != 2*DES_KEYLEN)
        goto Ret;

    if (!FMyMakeDESKey(
            &sConfirmKey,               // out
            *ppbMK + DES_KEYLEN))       // in
        goto Ret;

    if (dwMKVersion == 0x01)
    {
        // items created with tag 0x01 used different HMACing algorithm
        if (!FMyOldPrimitiveHMAC(
                sConfirmKey,
                g_rgbConfirmBuf,
                sizeof(g_rgbConfirmBuf),
                rgbHMACResult))
            goto Ret;
    }
    else
    {
        if (!FMyPrimitiveHMAC(
                sConfirmKey,
                g_rgbConfirmBuf,
                sizeof(g_rgbConfirmBuf),
                rgbHMACResult))
            goto Ret;
    }

    if (0 != memcmp(rgbHMACResult, rgbConfirm, A_SHA_DIGEST_LEN))
        goto Ret;

    fRet = TRUE;
Ret:

    return fRet;
}

// retrieve key block and derive Item/MAC keys using MK
BOOL FMyDecryptKeyBlock(
            LPCWSTR szUser,
            LPCWSTR szMasterKey,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            PBYTE   pbKeyBlock,
            DWORD   cbKeyBlock,
            DESKEY* psItemKey,
            DESKEY* psMacKey)
{
    BOOL    fRet = FALSE;

    DESKEY  sMK;

    BYTE    rgbSalt[PASSWORD_SALT_LEN];
    BYTE    rgbConfirm[A_SHA_DIGEST_LEN];

    PBYTE   pbMK = NULL;
    DWORD   cbMK;

    if (!FBPGetSecurityState(
            szUser,
            szMasterKey,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            &pbMK,
            &cbMK))
        return FALSE;

    // unwrap master key
    if (!FMyDecryptMK(
            rgbSalt,
            sizeof(rgbSalt),
            rgbPwd,
            rgbConfirm,
            &pbMK,
            &cbMK
            ))
        goto Ret;


    // assumes pbMK is at least 2*DES_KEYLEN bytes
    if (cbMK != 2*DES_KEYLEN)
        goto Ret;

    if (!FMyMakeDESKey(
            &sMK,            // out
            pbMK))           // in
        goto Ret;

    // use MK to decrypt key block
    if (!FMyPrimitiveDESDecrypt(
            pbKeyBlock,
            &cbKeyBlock,
            sMK))
        goto Ret;

    // fill in ItemKey, MacKey from decrypted key block
    if (cbKeyBlock != 2*DES_KEYLEN)
        goto Ret;

    // assumes pbKeyBlock is at least 2*DES_KEYLEN bytes
    if (!FMyMakeDESKey(
            psItemKey,       // out
            pbKeyBlock))     // in
        goto Ret;
    if (!FMyMakeDESKey(
            psMacKey,        // out
            pbKeyBlock + DES_KEYLEN)) // in
        goto Ret;

    fRet = TRUE;
Ret:

    if(pbMK != NULL) {
        RtlSecureZeroMemory(pbMK, cbMK); // sfield: zero it
        SSFree(pbMK);   // sfield: fix illusive memory leak
    }

    return fRet;
}

// given encrypted data and password, decrypt and check MAC on data
BOOL FProvDecryptData(
            LPCWSTR szUser,         // in
            LPCWSTR szMasterKey,    // in
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],       // in
            PBYTE*  ppbMyData,      // in out
            DWORD*  pcbMyData)      // in out
{
    BOOL fRet = FALSE;

    DESKEY  sItemKey;
    DESKEY  sMacKey;

    BYTE    rgbHMAC[A_SHA_DIGEST_LEN];

    DWORD   dwDataVer;

    PBYTE   pTemp;


    // pointers to teardown stream
    PBYTE   pbCurPtr = *ppbMyData;

    PBYTE   pbSecureData;
    DWORD   cbSecureData;

    PBYTE   pbInlineKeyBlock;
    DWORD   cbInlineKeyBlock;

    PBYTE   pbDecrypted;
    DWORD   cbDecrypted;

    PBYTE   pbMAC;
    DWORD   cbMAC;

//  ENCRYPTED ITEM DATA FORMAT:
//  version | size(keyblk) | keyblk | size(encryptedblk) | Encrypted{ size(data) | data | size(MAC) | MAC}

    // version check -- only handle V1 data for now
    dwDataVer = *(DWORD*)pbCurPtr;
    if (ENCRYPTED_DATA_VER < dwDataVer)
        goto Ret;
    pbCurPtr += sizeof(DWORD);

    // pointers to key block
    cbInlineKeyBlock = *(DWORD UNALIGNED *)pbCurPtr;       // keyblock size
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    pbInlineKeyBlock = pbCurPtr;                // points to key block
    pbCurPtr += cbInlineKeyBlock;               // fwd past data

    // pointers to secure data
    cbSecureData = *(DWORD UNALIGNED *)pbCurPtr;           // secure data size member
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    pbSecureData = pbCurPtr;                    // points to secure data

    // retrieve key block using MK, etc
    if (!FMyDecryptKeyBlock(
            szUser,
            szMasterKey,
            rgbPwd,
            pbInlineKeyBlock,
            cbInlineKeyBlock,
            &sItemKey,
            &sMacKey))
        goto Ret;

    // keys derived, now recover data inplace
    if (!FMyPrimitiveDESDecrypt(
            pbSecureData,
            &cbSecureData,
            sItemKey))
        goto Ret;

    cbDecrypted = *(DWORD UNALIGNED *)pbCurPtr;            // plaintext size
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    pbDecrypted = pbCurPtr;                     // points to plaintext
    pbCurPtr += cbDecrypted;                    // fwd past data

    // pointers to HMAC
    cbMAC = *(DWORD UNALIGNED *)pbCurPtr;                  // MAC size member
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    pbMAC = pbCurPtr;                           // points to MAC
    pbCurPtr += cbMAC;                          // fwd past data

    if (A_SHA_DIGEST_LEN != cbMAC)              // verify HMAC size member
        goto Ret;


    // chk MAC

    // Compute HMAC over plaintext data

    if (dwDataVer == 0x01)
    {
        // version 0x1 used different HMAC code
        if (!FMyOldPrimitiveHMAC(
                sMacKey,
                pbDecrypted,
                cbDecrypted,
                rgbHMAC))
            goto Ret;
    }
    else
    {
        if (!FMyPrimitiveHMAC(
                sMacKey,
                pbDecrypted,
                cbDecrypted,
                rgbHMAC))
            goto Ret;
    }

    // now compare against HMAC in tail of msg
    if (0 != memcmp(pbMAC, rgbHMAC, A_SHA_DIGEST_LEN))
        goto Ret;

    // if everything went well, return secure data (shift to far left, realloc)
    MoveMemory(*ppbMyData, pbDecrypted, cbDecrypted);

    pTemp = (PBYTE)SSReAlloc(*ppbMyData, cbDecrypted);
    if (pTemp == NULL)     // check allocation, Caller will free *ppbMyData
        goto Ret;

    *ppbMyData = pTemp;

    *pcbMyData = cbDecrypted;


    fRet = TRUE;
Ret:
    // TODO free ppbMyData on failure?
    return fRet;
}

// given pwd, salt, and Master Key buffer, MACs and Encrypts Master Key buffer
BOOL FMyEncryptMK(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK)
{
    BOOL fRet = FALSE;
    DESKEY  sDerivedKey1;
    DESKEY  sConfirmKey;
    PBYTE   pTemp;

    // assumes pbKeyBlock is at least 2*DES_KEYLEN bytes
    if (*pcbMK != 2*DES_KEYLEN)
        goto Ret;

    // confirmation key is 2nd in buffer
    if (!FMyMakeDESKey(
            &sConfirmKey,    // out
            *ppbMK + DES_KEYLEN))     // in
        goto Ret;


    if (!FMyPrimitiveHMAC(
            sConfirmKey,
            g_rgbConfirmBuf,
            sizeof(g_rgbConfirmBuf),
            rgbConfirm))
        goto Ret;

    // DK1 = DeriveKey(SHA(pw), Salt)
    if (!FMyPrimitiveDeriveKey(
            rgbSalt,
            cbSalt,
            rgbPwd,
            A_SHA_DIGEST_LEN, ///sizeof(rgbPwd),
            &sDerivedKey1))
        goto Ret;

    // Encrypt MK w/ DK1, return
    if (!FMyPrimitiveDESEncrypt(
            ppbMK,
            pcbMK,
            sDerivedKey1))
        goto Ret;

    // Mash version onto front!!
    pTemp = (PBYTE)SSReAlloc(*ppbMK, *pcbMK+sizeof(DWORD));   // realloc bigger for ver
    if (pTemp == NULL)     // check allocation
        goto Ret;
    *ppbMK = pTemp;

    MoveMemory(*ppbMK+sizeof(DWORD), *ppbMK, *pcbMK);   // move data 1 dw right
    *pcbMK += sizeof(DWORD);                            // inc size
    *(DWORD*)(*ppbMK) = (DWORD)ENCRYPTED_MASTERKEY_VER; // whack version in there!


    fRet = TRUE;
Ret:
    return fRet;
}


// returns a new key block encrypted with master key
// creates and stores master key state if none exists
BOOL FMyEncryptKeyBlock(
            LPCWSTR szUser,
            LPCWSTR szMasterKey,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            PBYTE*  ppbKeyBlock,
            DWORD*  pcbKeyBlock,
            DESKEY* psItemKey,
            DESKEY* psMacKey)
{
    BOOL    fRet = FALSE;
    *ppbKeyBlock = NULL;

    BYTE    rgbSalt[PASSWORD_SALT_LEN];
    BYTE    rgbConfirm[A_SHA_DIGEST_LEN];

    PBYTE   pbMK = NULL;
    DWORD   cbMK;

    PBYTE   pbTmp = NULL;
    DWORD   cbTmp;

    DESKEY  sMK;

    // gen a random key block: 2 keys
    *pcbKeyBlock = 2*DES_KEYLEN;
    *ppbKeyBlock = (PBYTE) SSAlloc(*pcbKeyBlock + DES_BLOCKLEN);    // performance fudge factor (realloc)
    if (*ppbKeyBlock == NULL)     // check allocation
        goto Ret;

    if (!RtlGenRandom(*ppbKeyBlock, *pcbKeyBlock))
        goto Ret;

    // INSERT: FRENCH GOVT. THOUGHT CONTROL CODE
    if (! FIsEncryptionPermitted())
    {
        // Protected Storage addition, 5/27/97
        // If encryption is not allowed, pretend faulty
        // RNG generated encryption key { 6d 8a 88 6a   4e aa 37 a8 }

        SS_ASSERT(DES_KEYLEN == sizeof(DWORD)*2);

        *(DWORD*)(*ppbKeyBlock) = 0x6d8a886a;
        *(DWORD*)(*ppbKeyBlock + sizeof(DWORD)) = 0x4eaa37a8;


        // PS: Remind me not to move to FRANCE
    }


    // assumes pbKeyBlock is at least 2*DES_KEYLEN bytes
    SS_ASSERT(*pcbKeyBlock == 2*DES_KEYLEN);

    if (!FMyMakeDESKey(
            psItemKey,                  // out
            *ppbKeyBlock))     // in
        goto Ret;

    if (!FMyMakeDESKey(
            psMacKey,          // out
            *ppbKeyBlock + DES_KEYLEN))     // in
        goto Ret;

    // first derive a key from PW
    if (FBPGetSecurityState(
            szUser,
            szMasterKey,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            &pbMK,
            &cbMK))
    {
        // unwrap master key
        if (!FMyDecryptMK(
                rgbSalt,
                sizeof(rgbSalt),
                rgbPwd,
                rgbConfirm,
                &pbMK,
                &cbMK))
            goto Ret;

        // done, have MK unwrapped.
    }
    else
    {
        // if we couldn't retrieve state, assume we must generate it
        if (!RtlGenRandom(rgbSalt, PASSWORD_SALT_LEN))
            goto Ret;

        cbMK = 2*DES_KEYSIZE;
        pbMK = (PBYTE)SSAlloc(cbMK + DES_BLOCKLEN);     // performance fudge factor (realloc)
        if (pbMK == NULL)     // check allocation
            goto Ret;

        if (!RtlGenRandom(pbMK, cbMK))
            goto Ret;

        // this is final MK: encrypt a copy
        cbTmp = cbMK;
        pbTmp = (PBYTE)SSAlloc(cbTmp);
        if (pbTmp == NULL)     // check allocation
            goto Ret;

        CopyMemory(pbTmp, pbMK, cbMK);


        // now wrap MK up and stuff in registry
        if (!FMyEncryptMK(
                rgbSalt,
                sizeof(rgbSalt),
                rgbPwd,
                rgbConfirm,
                &pbTmp,
                &cbTmp))
            goto Ret;

        if (!FBPSetSecurityState(
                szUser,
                szMasterKey,
                rgbSalt,
                PASSWORD_SALT_LEN,
                rgbConfirm,
                sizeof(rgbConfirm),
                pbTmp,
                cbTmp))
            goto Ret;

    }

    if (cbMK != 2*DES_KEYSIZE)
        goto Ret;

    if (!FMyMakeDESKey(
            &sMK,           // out
            pbMK))          // in
        goto Ret;

    if (*pcbKeyBlock != 2*DES_KEYLEN)
        goto Ret;

    if (!FMyPrimitiveDESEncrypt(
            ppbKeyBlock,
            pcbKeyBlock,
            sMK))
        goto Ret;

    fRet = TRUE;
Ret:
    if (!fRet)
    {
        if (*ppbKeyBlock) {
            SSFree(*ppbKeyBlock);
            *ppbKeyBlock = NULL;
        }
    }

    if (pbMK) {
        RtlSecureZeroMemory(pbMK, cbMK);
        SSFree(pbMK);
    }

    if (pbTmp) {
        RtlSecureZeroMemory(pbTmp, cbTmp); // sfield: zero memory
        SSFree(pbTmp);
    }

    return fRet;
}

// given data, will generate a key block and
// return encrypt/mac'd data
BOOL FProvEncryptData(
            LPCWSTR szUser,         // in
            LPCWSTR szMasterKey,    // in
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],       // in
            PBYTE*  ppbMyData,      // in out
            DWORD*  pcbMyData)      // in out
{
    BOOL fRet = FALSE;

    DESKEY  sItemKey;
    DESKEY  sMacKey;

    BYTE    rgbHMAC[A_SHA_DIGEST_LEN];

    // helpful pointers
    PBYTE   pbCurPtr = *ppbMyData;

    PBYTE   pbKeyBlock = NULL;
    DWORD   cbKeyBlock = 0;

    DWORD   cbDataSize;

    // return an item key, mac key
    // store in an encrypted key block using MK, etc.
    if (!FMyEncryptKeyBlock(
            szUser,
            szMasterKey,
            rgbPwd,
            &pbKeyBlock,
            &cbKeyBlock,
            &sItemKey,
            &sMacKey))
        goto Ret;

    // now secure data

    // Compute HMAC
    if (!FMyPrimitiveHMAC(sMacKey, *ppbMyData, *pcbMyData, rgbHMAC))
        goto Ret;

//  DATA FORMAT:
//  version | size(keyblk) | keyblk | size(encryptedblk) | Encrypted{ size(data) | data | size(MAC) | MAC}

    // lengthen data seg by data size member, MAC and MAC size member
    cbDataSize = *pcbMyData;                            // save current size
    *pcbMyData += A_SHA_DIGEST_LEN + 2*sizeof(DWORD);   // sizeof(data), MAC, sizeof(MAC)
    pbCurPtr = (PBYTE)SSReAlloc(*ppbMyData, *pcbMyData);
    if (pbCurPtr == NULL)     // check allocation
        goto Ret;
    *ppbMyData = pbCurPtr;

    // size, data
    MoveMemory(pbCurPtr+sizeof(DWORD), pbCurPtr, cbDataSize); // shift right data for size insertion
    *(DWORD UNALIGNED *)pbCurPtr = cbDataSize;                     // size of data
    pbCurPtr += sizeof(DWORD);                          // fwd past size
    pbCurPtr += cbDataSize;                             // fwd past data

    // size, MAC
    *(DWORD UNALIGNED *)pbCurPtr = A_SHA_DIGEST_LEN;               // size of MAC
    pbCurPtr += sizeof(DWORD);                          // fwd past size
    CopyMemory(pbCurPtr, rgbHMAC, A_SHA_DIGEST_LEN);    // MAC
    pbCurPtr += A_SHA_DIGEST_LEN;                       // fwd past MAC

    if (!FMyPrimitiveDESEncrypt(
            ppbMyData,      // in out
            pcbMyData,      // in out
            sItemKey))
        goto Ret;

    cbDataSize = *pcbMyData;                            // save current size
    *pcbMyData += 3*sizeof(DWORD) + cbKeyBlock;         // ver, sizeof(keyblk), keyblk, sizeof(encrdata)
    pbCurPtr = (PBYTE)SSReAlloc(*ppbMyData, *pcbMyData);
    if (pbCurPtr == NULL)     // check allocation
        goto Ret;

    *ppbMyData = pbCurPtr;

    // shift right data for size, keyblk insertions
    MoveMemory(pbCurPtr + 3*sizeof(DWORD) + cbKeyBlock, pbCurPtr, cbDataSize);

    // throw version tag in front
    *(DWORD UNALIGNED *)pbCurPtr = (DWORD)ENCRYPTED_DATA_VER;
    pbCurPtr += sizeof(DWORD);

    // insert keyblock
    *(DWORD UNALIGNED *)pbCurPtr = cbKeyBlock;                     // size of data
    pbCurPtr += sizeof(DWORD);                          // fwd past size
    CopyMemory(pbCurPtr, pbKeyBlock, cbKeyBlock);       // data
    pbCurPtr += cbKeyBlock;                             // fwd past data

    // insert sizeof encrypted blob
    *(DWORD UNALIGNED *)pbCurPtr = cbDataSize;                     // size of data


    fRet = TRUE;
Ret:
    RtlSecureZeroMemory(&sItemKey, sizeof(DESKEY));
    RtlSecureZeroMemory(&sMacKey, sizeof(DESKEY));

    if (pbKeyBlock)
        SSFree(pbKeyBlock);

    return fRet;
}

// given password, and master key, will decrypt and
// verify MAC on master key
BOOL FCheckPWConfirm(
        LPCWSTR szUser,         // in
        LPCWSTR szMasterKey,    // in
        BYTE    rgbPwd[A_SHA_DIGEST_LEN])       // in
{
    BOOL fRet = FALSE;

    BYTE    rgbSalt[PASSWORD_SALT_LEN];
    BYTE    rgbConfirm[A_SHA_DIGEST_LEN];

    PBYTE   pbMK = NULL;
    DWORD   cbMK;

    // confirm is just get state and attempt MK decrypt
    if (FBPGetSecurityState(
            szUser,
            szMasterKey,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            &pbMK,
            &cbMK))
    {
        BOOL fResetSecurityState;

        // found state; is pwd correct?
        if (!FMyDecryptMKEx(
                rgbSalt,
                sizeof(rgbSalt),
                rgbPwd,
                rgbConfirm,
                &pbMK,
                &cbMK,
                &fResetSecurityState
                ))
            goto Ret;


        if( fResetSecurityState )
        {

            // now wrap MK up and stuff in registry

            if(FMyEncryptMK(
                    rgbSalt,
                    sizeof(rgbSalt),
                    rgbPwd,
                    rgbConfirm,
                    &pbMK,
                    &cbMK
                    )) {

                if (FBPSetSecurityState(
                        szUser,
                        szMasterKey,
                        rgbSalt,
                        sizeof(rgbSalt),
                        rgbConfirm,
                        sizeof(rgbConfirm),
                        pbMK,
                        cbMK
                        ))
                {

                    // found state; is pwd correct?
                    if (!FMyDecryptMKEx(
                            rgbSalt,
                            sizeof(rgbSalt),
                            rgbPwd,
                            rgbConfirm,
                            &pbMK,
                            &cbMK,
                            &fResetSecurityState
                            )) {
                        OutputDebugString(TEXT("fail to dec\n"));
                        goto Ret;
                    }
                }

            }
        }   // reset security state.
    }
    else
    {
        // didn't find state; create it
        // if we couldn't retrieve state, assume we must generate it
        if (!RtlGenRandom(rgbSalt, PASSWORD_SALT_LEN))
            goto Ret;

        cbMK = 2*DES_KEYLEN;
        pbMK = (PBYTE)SSAlloc(cbMK);
        if (pbMK == NULL)     // check allocation
            goto Ret;

        if (!RtlGenRandom(pbMK, cbMK))
            goto Ret;

        // now wrap MK up and stuff in registry
        if (!FMyEncryptMK(
                rgbSalt,
                sizeof(rgbSalt),
                rgbPwd,
                rgbConfirm,
                &pbMK,
                &cbMK))
            goto Ret;

        if (!FBPSetSecurityState(
                szUser,
                szMasterKey,
                rgbSalt,
                PASSWORD_SALT_LEN,
                rgbConfirm,
                sizeof(rgbConfirm),
                pbMK,
                cbMK))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    if (pbMK) {
        RtlSecureZeroMemory(pbMK, cbMK); // sfield: zero memory
        SSFree(pbMK);
    }

    return fRet;
}


// callback for changing a password. On password change,
// MasterKey is decrypted and re-encrypted
BOOL FPasswordChangeNotify(
        LPCWSTR szUser,                         // in
        LPCWSTR szPasswordName,                 // in
        BYTE    rgbOldPwd[A_SHA_DIGEST_LEN],    // in
        DWORD   cbOldPwd,                       // in
        BYTE    rgbNewPwd[A_SHA_DIGEST_LEN],    // in
        DWORD   cbNewPwd)                       // in
{
    // allows unattended pw change (callback from svr)

    BOOL fRet = FALSE;
    BYTE    rgbSalt[PASSWORD_SALT_LEN];
    BYTE    rgbConfirm[A_SHA_DIGEST_LEN];

    PBYTE pbMK = NULL;
    DWORD cbMK;

    BOOL fNewPassword = (cbOldPwd == 0);

    // can't modify a non-user changable pw
//    if (!FIsUserMasterKey(szPasswordName))
//        goto Ret;

    if (cbNewPwd != A_SHA_DIGEST_LEN)
        goto Ret;

    // ensure old pwd exists
    if (!FBPGetSecurityState(
            szUser,
            szPasswordName,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            &pbMK,
            &cbMK))
    {
        // couldn't retreive old PW, create a new one
        if (!FCheckPWConfirm(
                szUser,
                szPasswordName,
                rgbNewPwd))
            goto Ret;

        fRet = TRUE;
        goto Ret;
    }
    else
    {
        // state was retrieved
        if (fNewPassword)
        {
            SetLastError((DWORD)PST_E_ITEM_EXISTS);
            goto Ret;
        }
    }

    // old pwd retrieved -- time to update
    if (!FMyDecryptMK(
            rgbSalt,
            sizeof(rgbSalt),
            rgbOldPwd,
            rgbConfirm,
            &pbMK,
            &cbMK))
    {
        SetLastError((DWORD)PST_E_WRONG_PASSWORD);
        goto Ret;
    }

    // MK is naked here

    // rewrap and save state
    if (!FMyEncryptMK(
            rgbSalt,
            sizeof(rgbSalt),
            rgbNewPwd,
            rgbConfirm,
            &pbMK,
            &cbMK))
        goto Ret;
    if (!FBPSetSecurityState(
            szUser,
            szPasswordName,
            rgbSalt,
            sizeof(rgbSalt),
            rgbConfirm,
            sizeof(rgbConfirm),
            pbMK,
            cbMK))
        goto Ret;

    fRet = TRUE;
Ret:
    if (pbMK) {
        RtlSecureZeroMemory(pbMK, cbMK);
        SSFree(pbMK);
    }

    return fRet;
}



BOOL FHMACGeographicallySensitiveData(
            LPCWSTR szUser,                         // in
            LPCWSTR szPasswordName,                 // in
            DWORD   dwHMACVersion,                  // in
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],       // in
            const GUID* pguidType,                  // in
            const GUID* pguidSubtype,               // in
            LPCWSTR szItem,                         // in: may be NULL
            PBYTE pbBuf,                            // in
            DWORD cbBuf,                            // in
            BYTE rgbHMAC[A_SHA_DIGEST_LEN])         // out
{
    BOOL fRet = FALSE;

    // helpful pointer
    PBYTE pbCurrent;

    PBYTE   pbKeyBlock = NULL;
    DWORD   cbKeyBlock;
    DESKEY  sBogusKey;
    DESKEY  sMacKey;

    DWORD cbTmp = (DWORD)(cbBuf + 2*sizeof(GUID) + WSZ_BYTECOUNT(szItem));
    PBYTE pbTmp = (PBYTE)SSAlloc(cbTmp);
    if (pbTmp == NULL)     // check allocation
        goto Ret;

    // helpful pointer
    pbCurrent = pbTmp;

    // snag the MAC key
    if (!FGetInternalMACKey(szUser, &pbKeyBlock, &cbKeyBlock))
    {
        // create a key block
        if (!FMyEncryptKeyBlock(
                    szUser,
                    szPasswordName,
                    rgbPwd,
                    &pbKeyBlock,
                    &cbKeyBlock,
                    &sBogusKey,
                    &sMacKey))
                goto Ret;

        if (!FSetInternalMACKey(szUser, pbKeyBlock, cbKeyBlock))
            goto Ret;
    }
    else
    {
        // key already exists; get it
        if (!FMyDecryptKeyBlock(
                szUser,
                szPasswordName,
                rgbPwd,
                pbKeyBlock,
                cbKeyBlock,
                &sBogusKey,
                &sMacKey))
            goto Ret;
    }


    // HMAC format:
    // HMAC( guidType | guidSubtype | szItemName | pbData )

    // copy type
    CopyMemory(pbCurrent, pguidType, sizeof(GUID));
    pbCurrent += sizeof(GUID);

    // copy subtype
    CopyMemory(pbCurrent, pguidSubtype, sizeof(GUID));
    pbCurrent += sizeof(GUID);

    // copy item name
    CopyMemory(pbCurrent, szItem, WSZ_BYTECOUNT(szItem));
    pbCurrent += WSZ_BYTECOUNT(szItem);

    // copy actual data
    CopyMemory(pbCurrent, pbBuf, cbBuf);

    if (dwHMACVersion == OLD_HMAC_VERSION)
    {
        // now do HMAC on this
        if (!FMyOldPrimitiveHMAC(
                sMacKey,
                pbTmp,
                cbTmp,
                rgbHMAC))
            goto Ret;
    }
    else
    {
        // now do HMAC on this
        if (!FMyPrimitiveHMAC(
                sMacKey,
                pbTmp,
                cbTmp,
                rgbHMAC))
            goto Ret;
    }

    fRet = TRUE;

Ret:
    if (pbTmp)
        SSFree(pbTmp);

    if (pbKeyBlock)
        SSFree(pbKeyBlock);

    return fRet;
}


// lifted (nearly) directly from RSABase ntagum.c

// do locale check once
static BOOL g_fEncryptionIsPermitted;
static BOOL g_fIKnowEncryptionPermitted = FALSE;

BOOL FIsEncryptionPermitted()
/*++

Routine Description:

    This routine checks whether encryption is getting the system default
    LCID and checking whether the country code is CTRY_FRANCE.

Arguments:

    none


Return Value:

    TRUE - encryption is permitted
    FALSE - encryption is not permitted


--*/
{
    LCID DefaultLcid;
    CHAR CountryCode[10];
    ULONG CountryValue;

    if (!g_fIKnowEncryptionPermitted)
    {
        // assume okay (unless found otherwise)
        g_fEncryptionIsPermitted = TRUE;

        DefaultLcid = GetSystemDefaultLCID();
        //
        // Check if the default language is Standard French
        //
        if (LANGIDFROMLCID(DefaultLcid) == 0x40c)
            g_fEncryptionIsPermitted = FALSE;

        //
        // Check if the users's country is set to FRANCE
        //
        if (GetLocaleInfoA(DefaultLcid,LOCALE_ICOUNTRY,CountryCode,10) == 0)
            g_fEncryptionIsPermitted = FALSE;

        /*
        CountryValue = (ULONG) atol(CountryCode);
        if (CountryValue == CTRY_FRANCE)
            return(FALSE);
        */

        //
        // begin    remove dependency on atol and msvcrt
        //
        // from winnls.h:
        //    #define CTRY_FRANCE               33          // France
        SS_ASSERT(CTRY_FRANCE == 33);
        if (0 == lstrcmpA(CountryCode, "33"))
            g_fEncryptionIsPermitted = FALSE;
        //
        //  end     remove dependency on atol and msvcrt
        //

        g_fIKnowEncryptionPermitted = TRUE;
    }

    return g_fEncryptionIsPermitted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\secure.h ===
// length of the salt to append to password
#define     PASSWORD_SALT_LEN       16

// Primitive functions not shown 
#define OLD_HMAC_VERSION    0x01
#define NEW_HMAC_VERSION    0x02

// externally used functions
BOOL FProvEncryptData(
            LPCWSTR  szUser,        // in
            LPCWSTR  szMasterKey,   // in
            BYTE    rgbPwd[],       // in, must be A_SHA_DIGEST_LEN
            PBYTE*	ppbMyData,      // in out
            DWORD*	pcbMyData);     // in out

BOOL FProvDecryptData(
            LPCWSTR  szUser,        // in
            LPCWSTR  szMasterKey,   // in
            BYTE    rgbPwd[],       // in, must be A_SHA_DIGEST_LEN
            PBYTE*  ppbData,        // in out
            DWORD*  pcbData);       // in out

BOOL FCheckPWConfirm(
            LPCWSTR  szUser,        // in
            LPCWSTR  szMasterKey,   // in
		    BYTE    rgbPwd[]);  	// in

BOOL FPasswordChangeNotify(
            LPCWSTR  szUser,        // in
            LPCWSTR  szPasswordName,// in
            BYTE    rgbOldPwd[],    // in, must be A_SHA_DIGEST_LEN
            DWORD   cbOldPwd,       // in
            BYTE    rgbNewPwd[],    // in, must be A_SHA_DIGEST_LEN
            DWORD   cbNewPwd);      // in


// performs MAC with location data, making data immovable
BOOL FHMACGeographicallySensitiveData(
            LPCWSTR szUser,                         // in
            LPCWSTR szPasswordName,                 // in
            DWORD   dwMACVersion,                   // handle old, new MACs
            BYTE    rgbPwd[],	                    // in, must be A_SHA_DIGEST_LEN
            const GUID* pguidType,                  // in
            const GUID* pguidSubtype,               // in
            LPCWSTR szItem,                         // in, may be NULL
            PBYTE pbBuf,                            // in
            DWORD cbBuf,                            // in
            BYTE rgbHMAC[]);                        // out, must be A_SHA_DIGEST_LEN

// given pwd, salt, and ptr to master key buffer,
// decrypts and checks MAC on master key
BOOL FMyDecryptMK(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK);

BOOL
FMyDecryptMKEx(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK,
            BOOL    *pfResetSecurityState
            );

// given pwd, salt, and Master Key buffer, MACs and Encrypts Master Key buffer
BOOL FMyEncryptMK(
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbPwd[A_SHA_DIGEST_LEN],
            BYTE    rgbConfirm[A_SHA_DIGEST_LEN],
            PBYTE*  ppbMK,
            DWORD*  pcbMK);


// France check
BOOL FIsEncryptionPermitted();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\acl.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    acl.h

Abstract:

    This module contains routines to support core security operations in
    the Protected Storage Server.

Author:

    Scott Field (sfield)    25-Nov-96

--*/

#include "pstypes.h"
#include "dispif.h"


// allows server service and providers to impersonate calling client
BOOL
FImpersonateClient(
    IN  PST_PROVIDER_HANDLE *hPSTProv
    );

BOOL
FRevertToSelf(
    IN  PST_PROVIDER_HANDLE *hPSTProv
    );

// gets the user that made the call
BOOL
FGetUserName(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR*             ppszUser
    );

// gets the image name for the process
BOOL
FGetParentFileName(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR*             ppszName,
    OUT DWORD_PTR               *lpdwBaseAddress
    );

// gets hash of specified filename
BOOL
FGetDiskHash(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  LPWSTR              szImageName,
    IN  BYTE                Hash[A_SHA_DIGEST_LEN]
    );

// check if specified file matches authenticode criteria
BOOL
FIsSignedBinary(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  LPWSTR              szFileName,     // File name (path) to validate against
    IN  LPWSTR              szRootCA,       // Root CA
    IN  LPWSTR              szIssuer,       // Issuer
    IN  LPWSTR              szPublisher,    // publisher
    IN  LPWSTR              szProgramName,  // Program name (opus info)
    IN  BOOL                fPartialMatch   // partial or full field matching
    );

// determines if memory image matches expected value
BOOL
FCheckMemoryImage(
    IN  PST_PROVIDER_HANDLE *hPSTProv,      // handle to identify "owner"
    IN  LPWSTR              szImagePath,    // file to compute+check memory hash
    IN  DWORD               dwBaseAddress   // base address where module loaded
    );

// gets the direct caller to pstore COM interface module path + base address
BOOL
FGetDirectCaller(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR              *pszDirectCaller,
    OUT LPVOID              *BaseAddress
    );
#if 0

BOOL
FCheckSecurityDescriptor(
    IN  PST_PROVIDER_HANDLE     *hPSTProv,
    IN  PSECURITY_DESCRIPTOR    pSD,
    IN  DWORD                   dwDesiredAccess
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\acl.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    acl.cpp

Abstract:

    This module contains routines to support core security operations in
    the Protected Storage Server.

Author:

    Scott Field (sfield)    25-Nov-96

--*/

#include <pch.cpp>
#pragma hdrstop






BOOL
FImpersonateClient(
    IN  PST_PROVIDER_HANDLE *hPSTProv
    )
{
    handle_t hBinding = ((PCALL_STATE)hPSTProv)->hBinding;
    RPC_STATUS RpcStatus;

    if(!FIsWinNT())
        return TRUE;

    if(hPSTProv == NULL)
        return FALSE;

    if (hBinding == NULL)
    {
        if ((hPSTProv->LowPart == 0) && (hPSTProv->HighPart == 0) )
            return ImpersonateSelf(SecurityImpersonation);
        else
            return FALSE;
    }

    RpcStatus = RpcImpersonateClient(hBinding);

    if(RpcStatus != RPC_S_OK) {
        SetLastError(RpcStatus);
        return FALSE;
    }

    return TRUE;
}

BOOL
FRevertToSelf(
    IN  PST_PROVIDER_HANDLE *hPSTProv
    )
{
    handle_t hBinding = ((PCALL_STATE)hPSTProv)->hBinding;
    RPC_STATUS RpcStatus;

    if(!FIsWinNT())
        return TRUE;

    if(hPSTProv == NULL)
        return FALSE;

    if (hBinding == NULL)
    {
        if ((hPSTProv->LowPart == 0) && (hPSTProv->HighPart == 0) )
            return RevertToSelf();
        else
            return FALSE;
    }

    RpcStatus = RpcRevertToSelfEx(hBinding);

    if(RpcStatus != RPC_S_OK) {
        SetLastError(RpcStatus);
        return FALSE;
    }

    return TRUE;
}


// dispatch module callback interface given to providers to ask about callers

BOOL
FGetUserName(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR*             ppszUser
    )
/*++
    This routine obtains the username (Win95) or Textual Sid (WinNT)
    associated with the calling thread.  If the cached entry is not present,
    the cached entry is initialized with the current user name, and for WinNT,
    the authentication Id associated with the username.  For WinNT, on
    subsequent calls, the calling threads authentication Id is checked to see
    if it matches the cached authentication Id - if true, the cached user
    string is released, otherwise, the current thread is evaluated and the
    result released to the client (note this is unlikely to happen unless
    the client process is impersonating multiple users and using the same
    context handle).

    If ppszUser parameter is set to NULL, the function does not allocate
    and copy user string to caller.  This is useful to initialize the cached
    entry or to determine if the user string is valid and available.

--*/
{
    DWORD cch = MAX_PATH;
    WCHAR szBuf[MAX_PATH];
    BOOL f = FALSE; // assume failure.  indicates if we inited OK, too.

    if (FIsWinNT())
    {
        // impersonating client should be easy way of nabbing this info
        if(!FImpersonateClient(hPSTProv))
            return FALSE;

        f = GetUserTextualSid(
                NULL,
                szBuf,
                &cch);

        if(!FRevertToSelf(hPSTProv))
            return FALSE;
    } else {
        f = GetUserNameU(
                szBuf,
                &cch);

        if(!f) {
            // for Win95, if nobody is logged on, empty user name
            if(GetLastError() == ERROR_NOT_LOGGED_ON) {
                szBuf[ 0 ] = L'\0';
                cch = 1;
                f = TRUE;
            }
        }
    }

    if (!f)
        return FALSE;

    if( ppszUser ) {
        *ppszUser = (LPWSTR)SSAlloc( cch * sizeof(WCHAR) );
        if (*ppszUser == NULL)
            return FALSE;
        CopyMemory(*ppszUser, szBuf, cch * sizeof(WCHAR) );
    }

    return TRUE;
}

// gets the image name for the process
BOOL
FGetParentFileName(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR*             ppszName,
    OUT DWORD_PTR               *lpdwBaseAddress
    )
/*++

    If ppszName parameter is set to NULL, the function does not allocate
    and copy string to caller.  This is useful to initialize the cached
    entry or to determine if the string is valid and available.

    If lpdwBaseAddress is NULL, the caller is not provided the base address
    associated with the process image.

--*/
{
    CALL_STATE *pCallState = (CALL_STATE *)hPSTProv;

    if(pCallState->hProcess == NULL)
        return FALSE;

    if( ppszName ) {
        *ppszName = (LPWSTR)SSAlloc( sizeof(WCHAR) );
        if(*ppszName == NULL)
            return FALSE;

        ZeroMemory( *ppszName, sizeof(WCHAR) );
    }

    if(lpdwBaseAddress) {
        *lpdwBaseAddress = 0;
    }

    return TRUE;
}

#if 0
BOOL
FGetDiskHash(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  LPWSTR              szImageName,
    IN  BYTE                Hash[A_SHA_DIGEST_LEN]
    )
{
    BOOL bImpersonated = FALSE;
    HANDLE hFile;
    BOOL bSuccess = FALSE;

    if (FIsWinNT())
    {
        //
        // impersonate around hashing disk image since file may be on network
        // if impersonation fails, just try it anyway
        //

        bImpersonated = FImpersonateClient(hPSTProv);
    }


    hFile = CreateFileU(
                szImageName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
                );

    if( hFile != INVALID_HANDLE_VALUE ) {

        bSuccess = HashDiskImage( hFile, Hash );
        CloseHandle( hFile );
    }

    if(bImpersonated)
        FRevertToSelf(hPSTProv);

    return bSuccess;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\storage.cpp ===
#include <pch.cpp>
#pragma hdrstop


#include "guidcnvt.h"

#include "passwd.h"
#include "storage.h"




extern DISPIF_CALLBACKS    g_sCallbacks;


// note: REG_PSTTREE_LOC moved to pstprv.h

#define REG_DATA_LOC                L"Data"
#define REG_MK_LOC                  L"Data 2"

#define REG_ACCESSRULE_LOC          L"Access Rules"
#define REG_DISPLAYSTRING_VALNAME   L"Display String"

#define REG_USER_INTERNAL_MAC_KEY   L"Blocking"

#define REG_ITEM_SECURE_DATA_VALNAME   L"Item Data"
#define REG_ITEM_INSECURE_DATA_VALNAME L"Insecure Data"
#define REG_ITEM_MK_VALNAME         L"Behavior"

#define REG_SECURITY_SALT_VALNAME   L"Value"



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// PRIMITIVIES for snagging registry keys

DWORD GetPSTUserHKEY(LPCWSTR szUser, HKEY* phUserKey, BOOL* pfExisted)
{
    HKEY hKeyBase = NULL;
    DWORD dwRet = (DWORD)PST_E_STORAGE_ERROR;

    DWORD dwCreate;
    DWORD cbKeyName;
    LPWSTR szKeyName = NULL;
    WCHAR FastBuffer[(sizeof(REG_PSTTREE_LOC) / sizeof(WCHAR)) + 64];
    LPWSTR SlowBuffer = NULL;
    LPCWSTR szContainer = szUser;
    DWORD dwDesiredAccess = KEY_READ | KEY_WRITE;

    cbKeyName = sizeof(REG_PSTTREE_LOC) ;

    //
    // For Win95, we may have an empty or NULL container
    // name (szUser), so use a default storage area for
    // that scenario
    //

    if(szContainer == NULL || szContainer[0] == L'\0') {
        // "*" is an invalid LM username character
        szContainer = L"*Default*";
        hKeyBase = HKEY_LOCAL_MACHINE;
    } else {

        //
        // see if we should go to HKEY_LOCAL_MACHINE or
        // HKEY_CURRENT_USER
        //

        if( _wcsicmp(WSZ_LOCAL_MACHINE, szContainer) == 0 ) {
            // HKEY_LOCAL_MACHINE
            hKeyBase = HKEY_LOCAL_MACHINE;
        } else {
            // HKEY_CURRENT_USER
            if(!GetUserHKEY(szContainer, dwDesiredAccess, &hKeyBase)) {
                if(FIsWinNT()) {
                    goto Ret;
                }

                //
                // Win95, profiles may be disabled, so go to
                // HKEY_LOCAL_MACHINE\xxx\szContainer
                //

                hKeyBase = HKEY_LOCAL_MACHINE;

            } else {

                //
                // no container name when going to HKEY_CURRENT_USER
                //

                //
                // sfield: continue to use a container name for HKEY_CURRENT_USER
                // because the configuration may be shared, roamable hives
                // (mandatators profiles, etc, which we are telling people not
                //  to use anymore, but never-the-less, this could come up
                //

    //            szContainer = L"\0";
            }
        }
    }

    cbKeyName += (lstrlenW(szContainer) * sizeof(WCHAR)) +
                 sizeof(WCHAR) + // L'\\'
                 sizeof(WCHAR) ; // terminal NULL

    //
    // use faster stack based buffer if the material fits
    //

    if(cbKeyName > sizeof(FastBuffer)) {
        SlowBuffer = (LPWSTR)SSAlloc( cbKeyName );

        if (SlowBuffer == NULL)
        {
            dwRet = (DWORD)PST_E_FAIL;
            goto Ret;
        }
        szKeyName = SlowBuffer;
    } else {
        szKeyName = FastBuffer;
    }

    wcscpy(szKeyName, REG_PSTTREE_LOC);

    //
    // work-around bug in RegCreateKeyEx that returns the wrong
    // creation disposition if a trailing "\" is in the key name
    //

    if(szContainer && szContainer[0] != L'\0') {
        wcscat(szKeyName, L"\\");
        wcscat(szKeyName, szContainer);
    }

    // Open Base Key //
    // get current user, open (REG_PSTTREE_LOC\\CurrentUser)
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            hKeyBase,
            szKeyName,
            0,
            NULL,                       // address of class string
            0,
            dwDesiredAccess,
            NULL,
            phUserKey,
            &dwCreate))
    {
        goto Ret;
    }

    if (pfExisted) {
        *pfExisted = (dwCreate == REG_OPENED_EXISTING_KEY);
    }

    if(dwCreate == REG_CREATED_NEW_KEY && FIsWinNT()) {

        //
        // WinNT: restrict access to Local System on newly created key.
        //

        HKEY hKeyWriteDac;

        //
        // duplicate to WRITE_DAC access key and use that
        //

        if(ERROR_SUCCESS == RegOpenKeyExW(*phUserKey, NULL, 0, WRITE_DAC, &hKeyWriteDac)) {
            SetRegistrySecurity(hKeyWriteDac);
            RegCloseKey(hKeyWriteDac);
        }
    }

    dwRet = PST_E_OK;
Ret:

    if (SlowBuffer)
        SSFree(SlowBuffer);

    //
    // close the per-user "root" key
    //

    if(hKeyBase != NULL && hKeyBase != HKEY_LOCAL_MACHINE)
        RegCloseKey(hKeyBase);

    return dwRet;
}


DWORD GetPSTTypeHKEY(LPCWSTR szUser, const GUID* pguidType, HKEY* phTypeKey)
{
    DWORD dwRet;
    HKEY hBaseKey = NULL;
    HKEY hDataKey = NULL;

    CHAR rgszTypeGuid[MAX_GUID_SZ_CHARS];

    // Open User Key //
    if (PST_E_OK != (dwRet =
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL)) )
        goto Ret;

    // Open Data Key //
    if (ERROR_SUCCESS !=
        RegOpenKeyExU(
            hBaseKey,
            REG_DATA_LOC,
            0,
            KEY_READ | KEY_WRITE,
            &hDataKey))
    {
        dwRet = (DWORD)PST_E_TYPE_NO_EXISTS;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidType,
            rgszTypeGuid)) )
        goto Ret;

    // Open Category Key //
    if (ERROR_SUCCESS !=
        RegOpenKeyExA(
            hDataKey,
            rgszTypeGuid,
            0,
            KEY_READ | KEY_WRITE,
            phTypeKey))
    {
        dwRet = (DWORD)PST_E_TYPE_NO_EXISTS;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return dwRet;
}


DWORD CreatePSTTypeHKEY(LPCWSTR szUser, const GUID* pguidType, HKEY* phTypeKey, BOOL* pfExisted)
{
    DWORD dwRet;
    DWORD dwCreate;
    HKEY hBaseKey = NULL;
    HKEY hDataKey = NULL;

    CHAR rgszTypeGuid[MAX_GUID_SZ_CHARS];

    // Open User Key //
    if (PST_E_OK != (dwRet =
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL)) )
        goto Ret;

    // Open Data Key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            hBaseKey,
            REG_DATA_LOC,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            &hDataKey,
            &dwCreate))
    {
        dwRet = (DWORD)PST_E_STORAGE_ERROR;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidType,
            rgszTypeGuid)) )
        goto Ret;

    // Open Category Key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExA(
            hDataKey,
            rgszTypeGuid,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            phTypeKey,
            &dwCreate))
    {
        dwRet = (DWORD)PST_E_STORAGE_ERROR;
        goto Ret;
    }

    if (pfExisted)
        *pfExisted = (dwCreate == REG_OPENED_EXISTING_KEY);

    dwRet = PST_E_OK;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return dwRet;
}

DWORD GetPSTMasterKeyHKEY(LPCWSTR szUser, LPCWSTR szMasterKey, HKEY* phMyKey)
{
    DWORD dwRet;
    DWORD dwCreate;
    HKEY hBaseKey = NULL;
    HKEY hMKKey = NULL;

    // Open User Key //
    if (PST_E_OK != (dwRet =
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL)) )
        goto Ret;

    // Open Master Key section //
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            hBaseKey,
            REG_MK_LOC,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            &hMKKey,
            &dwCreate))
    {
        dwRet = (DWORD)PST_E_STORAGE_ERROR;
        goto Ret;
    }

    if (szMasterKey)
    {
        // Open specific Master Key //
        if (ERROR_SUCCESS !=
            RegCreateKeyExU(
                hMKKey,
                szMasterKey,
                0,
                NULL,                       // address of class string
                0,
                KEY_READ | KEY_WRITE,
                NULL,
                phMyKey,
                &dwCreate))
        {
            dwRet = (DWORD)PST_E_STORAGE_ERROR;
            goto Ret;
        }
    }
    else
    {
        // wanted master parent, not specific MK
        *phMyKey = hMKKey;
    }

    dwRet = PST_E_OK;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    // wanted parent, not specific MK
    if ((*phMyKey != hMKKey) && (hMKKey))
        RegCloseKey(hMKKey);

    return dwRet;
}

DWORD GetPSTSubtypeHKEY(LPCWSTR szUser, const GUID* pguidType, const GUID* pguidSubtype, HKEY* phSubTypeKey)
{
    DWORD dwRet;
    DWORD dwCreate;
    HKEY hTypeKey = NULL;
    CHAR rgszSubtypeGuid[MAX_GUID_SZ_CHARS];

    // Open User Key //
    if (PST_E_OK != (dwRet =
        GetPSTTypeHKEY(
            szUser,
            pguidType,
            &hTypeKey)) )
        goto Ret;

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidSubtype,
            rgszSubtypeGuid)) )
        goto Ret;

    // Open SubType Key //
    if (ERROR_SUCCESS !=
        RegOpenKeyExA(
            hTypeKey,
            rgszSubtypeGuid,
            0,
            KEY_READ | KEY_WRITE,
            phSubTypeKey))
    {
        dwRet = (DWORD)PST_E_TYPE_NO_EXISTS;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:
    if (hTypeKey)
        RegCloseKey(hTypeKey);

    return dwRet;
}


DWORD CreatePSTSubtypeHKEY(LPCWSTR szUser, const GUID* pguidType, const GUID* pguidSubtype, HKEY* phSubTypeKey, BOOL* pfExisted)
{
    DWORD dwRet;
    DWORD dwCreate;
    HKEY hTypeKey = NULL;
    CHAR rgszSubtypeGuid[MAX_GUID_SZ_CHARS];

    // Open Type Key //
    if (PST_E_OK != (dwRet =
        GetPSTTypeHKEY(
            szUser,
            pguidType,
            &hTypeKey)) )
        goto Ret;

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidSubtype,
            rgszSubtypeGuid)) )
        goto Ret;

    // Open SubType Key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExA(
            hTypeKey,
            rgszSubtypeGuid,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            phSubTypeKey,
            &dwCreate))
    {
        dwRet = (DWORD)PST_E_STORAGE_ERROR;
        goto Ret;
    }

    if (pfExisted)
        *pfExisted = (dwCreate == REG_OPENED_EXISTING_KEY);

    dwRet = PST_E_OK;
Ret:
    if (hTypeKey)
        RegCloseKey(hTypeKey);

    return dwRet;
}

DWORD CreatePSTItemHKEY(LPCWSTR szUser, const GUID* pguidType, const GUID* pguidSubtype, LPCWSTR szItemName, HKEY* phItemKey, BOOL* pfExisted)
{
    BOOL dwRet;
    DWORD dwCreate;
    HKEY hSubTypeKey = NULL;

    // Open SubType key //
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hSubTypeKey)) )
        goto Ret;

    // Open name key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            hSubTypeKey,
            szItemName,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            phItemKey,
            &dwCreate))
    {
        dwRet = (DWORD)PST_E_STORAGE_ERROR;
        goto Ret;
    }

    if (pfExisted)
        *pfExisted = (dwCreate == REG_OPENED_EXISTING_KEY);

    dwRet = PST_E_OK;
Ret:
    if (hSubTypeKey)
        RegCloseKey(hSubTypeKey);

    return dwRet;
}

DWORD GetPSTItemHKEY(LPCWSTR szUser, const GUID* pguidType, const GUID* pguidSubtype, LPCWSTR szItemName, HKEY* phItemKey)
{
    DWORD dwRet;
    DWORD dwCreate;
    HKEY hSubtypeKey = NULL;

    // Open SubType key //
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hSubtypeKey)) )
        goto Ret;

    // Open name key //
    if (ERROR_SUCCESS !=
        RegOpenKeyExU(
            hSubtypeKey,
            szItemName,
            0,
            KEY_READ | KEY_WRITE,
            phItemKey))
    {
        dwRet = (DWORD)PST_E_ITEM_NO_EXISTS;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:
    if (hSubtypeKey)
        RegCloseKey(hSubtypeKey);

    return dwRet;
}

// end PRIMITIVES
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// PICKLE routines

#if 0

BOOL FAccessRulesPickle(
            PST_ACCESSRULESET *psRules,
            PBYTE* ppbPickled,
            DWORD* pcbPickled)
{
    BOOL fRet = FALSE;
    DWORD cbTotal = 0;
    DWORD dwRule;
    
    // ease-of-use write pointer
    PBYTE pbCurrentWrite;

    // init out params
    *ppbPickled = NULL;
    *pcbPickled = 0;

    // ASSERT new size member was initialized
    SS_ASSERT(psRules->cbSize == sizeof(PST_ACCESSRULESET));
    if (psRules->cbSize != sizeof(PST_ACCESSRULESET))
        goto Ret;

    cbTotal += sizeof(DWORD);               // Ruleset struct versioning

    cbTotal += sizeof(DWORD);               // # Rules in Ruleset

    // walk through each Rule in Ruleset
    for (dwRule=0; dwRule<psRules->cRules; dwRule++)
    {
        DWORD cClause;
        
        // ASSERT new size member was initialized
        SS_ASSERT(psRules->rgRules[dwRule].cbSize == sizeof(PST_ACCESSRULE));
        if (psRules->rgRules[dwRule].cbSize != sizeof(PST_ACCESSRULE))
            goto Ret;

        cbTotal += sizeof(DWORD);           // Rule struct versioning

        cbTotal += sizeof(PST_ACCESSMODE);  // mode in each Rule
        cbTotal += sizeof(DWORD);           // # Clauses in Rule

        // for each Rule, we'll have array of clauses
        for (cClause=0; cClause<psRules->rgRules[dwRule].cClauses; cClause++)
        {
            // ASSERT new size member was initialized
            SS_ASSERT(psRules->rgRules[dwRule].rgClauses[cClause].cbSize == sizeof(PST_ACCESSCLAUSE));
            if (psRules->rgRules[dwRule].rgClauses[cClause].cbSize != sizeof(PST_ACCESSCLAUSE))
                goto Ret;

            cbTotal += sizeof(DWORD);           // Clause struct versioning

            // we'll see every clause here
            cbTotal += sizeof(PST_ACCESSCLAUSETYPE);    // type in each clause
            cbTotal += sizeof(DWORD);       // # bytes in clause buffer
            cbTotal += psRules->rgRules[dwRule].rgClauses[cClause].cbClauseData; // buffer itself
        }
    }

    *ppbPickled = (BYTE*)SSAlloc(cbTotal);
    if(*ppbPickled == NULL)
        goto Ret;

    pbCurrentWrite = *ppbPickled;

    *pcbPickled = cbTotal;


    // copy Ruleset struct version
    *(DWORD*)pbCurrentWrite = psRules->cbSize;
    pbCurrentWrite += sizeof(DWORD);

    // copy # rules in ruleset
    *(DWORD*)pbCurrentWrite = psRules->cRules;
    pbCurrentWrite += sizeof(DWORD);

    // walk through each Rule in Ruleset
    for (dwRule=0; dwRule<psRules->cRules; dwRule++)
    {
        // copy Rule struct version
        *(DWORD*)pbCurrentWrite = psRules->rgRules[dwRule].cbSize;
        pbCurrentWrite += sizeof(DWORD);

        // copy # clauses in rule
        *(DWORD*)pbCurrentWrite = psRules->rgRules[dwRule].cClauses;
        pbCurrentWrite += sizeof(DWORD);

        // copy rule accessmode
        CopyMemory(pbCurrentWrite, &psRules->rgRules[dwRule].AccessModeFlags, sizeof(PST_ACCESSMODE));
        pbCurrentWrite += sizeof(PST_ACCESSMODE);

        // now for each Rule, we'll have array of clauses
        for (DWORD cClause=0; cClause<psRules->rgRules[dwRule].cClauses; cClause++)
        {
            PST_ACCESSCLAUSE* pTmp = &psRules->rgRules[dwRule].rgClauses[cClause];

            // copy clause struct version
            *(DWORD*)pbCurrentWrite = pTmp->cbSize;
            pbCurrentWrite += sizeof(DWORD);

            // clause type
            CopyMemory(pbCurrentWrite, &pTmp->ClauseType, sizeof(PST_ACCESSCLAUSETYPE));
            pbCurrentWrite += sizeof(PST_ACCESSCLAUSETYPE);

            // clause data buffer len
            *(DWORD*)pbCurrentWrite = pTmp->cbClauseData;
            pbCurrentWrite += sizeof(DWORD);

            // buffer itself
            CopyMemory(pbCurrentWrite, pTmp->pbClauseData, pTmp->cbClauseData);
            pbCurrentWrite += pTmp->cbClauseData;
        }
    }

#if DBG
    {
        // ASSERT!
        DWORD dwWroteBytes = (DWORD) (((DWORD_PTR)pbCurrentWrite) - ((DWORD_PTR)*ppbPickled));
        SS_ASSERT(dwWroteBytes == cbTotal);
        SS_ASSERT(cbTotal == *pcbPickled);
    }
#endif


    fRet = TRUE;
Ret:

    // on error and alloc, free
    if ((!fRet) && (*ppbPickled != NULL))
    {
        SSFree(*ppbPickled);
        *ppbPickled = NULL;
    }

    return fRet;
}



BOOL FAccessRulesUnPickle(
            PPST_ACCESSRULESET psRules,   // out
            PBYTE pbPickled,
            DWORD cbPickled)
{
    BOOL fRet = FALSE;

    PBYTE pbCurrentRead = pbPickled;
    DWORD cRule;

    // Ruleset struct version
    psRules->cbSize = *(DWORD*)pbCurrentRead;
    pbCurrentRead += sizeof(DWORD);

    // currently only one version known
    if (psRules->cbSize != sizeof(PST_ACCESSRULESET))
        goto Ret;

    // get # rules in ruleset
    cRule = *(DWORD*)pbCurrentRead;
    pbCurrentRead += sizeof(DWORD);

    // now we know how many Rule in Ruleset
    psRules->rgRules = (PST_ACCESSRULE*)SSAlloc(sizeof(PST_ACCESSRULE)*cRule);
    if(psRules->rgRules == NULL)
        goto Ret;

    psRules->cRules = cRule;

    // now unpack each Rule
    for (cRule=0; cRule<psRules->cRules; cRule++)
    {
        DWORD cClauses;

        // Ruleset struct version
        psRules->rgRules[cRule].cbSize = *(DWORD*)pbCurrentRead;
        // currently only one version known
        if (psRules->rgRules[cRule].cbSize != sizeof(PST_ACCESSRULE))
            goto Ret;

        pbCurrentRead += sizeof(DWORD);

        // get # clauses in rule
        cClauses = *(DWORD*)pbCurrentRead;
        pbCurrentRead += sizeof(DWORD);

        // now we know how many Clauses in Rule
        psRules->rgRules[cRule].rgClauses = (PST_ACCESSCLAUSE*)SSAlloc(sizeof(PST_ACCESSCLAUSE)*cClauses);
        if (psRules->rgRules[cRule].rgClauses == NULL)  // check allocation
            goto Ret;
        psRules->rgRules[cRule].cClauses = cClauses;

        // copy rule accessmode flags
        CopyMemory(&psRules->rgRules[cRule].AccessModeFlags, pbCurrentRead, sizeof(PST_ACCESSMODE));
        pbCurrentRead += sizeof(PST_ACCESSMODE);

        // now load each Clause
        for (DWORD cClause=0; cClause<psRules->rgRules[cRule].cClauses; cClause++)
        {
            PST_ACCESSCLAUSE* pTmp = &psRules->rgRules[cRule].rgClauses[cClause];

            // Clause struct version
            pTmp->cbSize = *(DWORD*)pbCurrentRead;
            // currently only one version known
            if (pTmp->cbSize != sizeof(PST_ACCESSCLAUSE))
                goto Ret;
            pbCurrentRead += sizeof(DWORD);


            CopyMemory(&pTmp->ClauseType, pbCurrentRead, sizeof(PST_ACCESSCLAUSETYPE));
            pbCurrentRead += sizeof(PST_ACCESSCLAUSETYPE);

            // clause data buffer len
            pTmp->cbClauseData = *(DWORD*)pbCurrentRead;
            pbCurrentRead += sizeof(DWORD);

            // buffer itself
            pTmp->pbClauseData = (PBYTE) SSAlloc(pTmp->cbClauseData);
            if (pTmp->pbClauseData == NULL)     // check allocation
                goto Ret;
            CopyMemory(pTmp->pbClauseData, pbCurrentRead, pTmp->cbClauseData);
            pbCurrentRead += pTmp->cbClauseData;
        }
    }

#if DBG
    {
        // ASSERT!
        DWORD dwReadBytes = (DWORD) (((DWORD_PTR)pbCurrentRead) - ((DWORD_PTR)pbPickled));
        SS_ASSERT(dwReadBytes == cbPickled);
    }
#endif

    fRet = TRUE;
Ret:
    if (!fRet)
        FreeRuleset(psRules);
    

    return fRet;
}


#endif

// end PICKLE routines
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// TYPE management

DWORD BPCreateType(
        LPCWSTR  szUser,            // in
        const GUID*   pguidType,          // in
        PST_TYPEINFO* pinfoType)    // in
{
    DWORD dwRet;
    BOOL fExisted;
    HKEY    hKey = NULL;

    // now we need to create entries in hierarchy
    if (PST_E_OK != (dwRet =
        CreatePSTTypeHKEY(
            szUser,
            pguidType,
            &hKey,
            &fExisted)) )
        goto Ret;

    // if we didn't create it, setting is an error
    if (fExisted)
    {
        dwRet = (DWORD)PST_E_TYPE_EXISTS;
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hKey,
            REG_DISPLAYSTRING_VALNAME,
            0,
            REG_SZ,
            (PBYTE)pinfoType->szDisplayName,
            WSZ_BYTECOUNT(pinfoType->szDisplayName))) )
        goto Ret;


    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

DWORD BPDeleteType(
        LPCWSTR  szUser,         // in
        const GUID*   pguidType)      // in
{
    DWORD dwRet;
    CHAR rgszTypeGuid[MAX_GUID_SZ_CHARS];

    // now remove the entry in hierarchy
    HKEY hBaseKey = NULL;
    HKEY hDataKey = NULL;

    if (PST_E_OK != (dwRet =
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL)) )
        goto Ret;

    // Open Data Key //
    if (ERROR_SUCCESS != (dwRet =
        RegOpenKeyExU(
            hBaseKey,
            REG_DATA_LOC,
            0,
            KEY_READ | KEY_WRITE,
            &hDataKey)) )
        goto Ret;

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidType,
            rgszTypeGuid)) )
        goto Ret;

    if (!FIsWinNT())
    {
        CHAR rgszTmp[MAX_GUID_SZ_CHARS];
        DWORD cbTmp = MAX_GUID_SZ_CHARS;
        FILETIME ft;
        HKEY hTestEmptyKey = NULL;

        // open the type
        if (ERROR_SUCCESS != (dwRet =
            RegOpenKeyExA(
                hDataKey,
                rgszTypeGuid,
                0,
                KEY_ALL_ACCESS,
                &hTestEmptyKey)) )
            goto Ret;

        // check for emptiness
        if (ERROR_NO_MORE_ITEMS !=
            RegEnumKeyExA(
                hTestEmptyKey,
                0,
                rgszTmp, // address of buffer for subkey name
                &cbTmp, // address for size of subkey buffer
                NULL,       // reserved
                NULL,       // pbclass
                NULL,       // cbclass
                &ft))
        {
            RegCloseKey(hTestEmptyKey);
            dwRet = (DWORD)PST_E_NOTEMPTY;
            goto Ret;
        }

        // close key before deletion
        RegCloseKey(hTestEmptyKey);
    }

    // now, remove the friendly name
    if (ERROR_SUCCESS != (dwRet =
        RegDeleteKeyA(
            hDataKey,
            rgszTypeGuid)) )
    {
        if (dwRet == ERROR_ACCESS_DENIED)
            dwRet = (DWORD)PST_E_NOTEMPTY;

        goto Ret;
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return dwRet;
}

DWORD BPEnumTypes(
        LPCWSTR  szUser,         // in
        DWORD   dwIndex,        // in
        GUID*   pguidType)      // out
{
    DWORD dwRet;

    CHAR rgszGuidType[MAX_GUID_SZ_CHARS];
    DWORD cbName = MAX_GUID_SZ_CHARS;

    FILETIME ft;

    // now walk through types, returning them one by one
    HKEY hKey=NULL, hDataKey=NULL;

    if (PST_E_OK != (dwRet =
        GetPSTUserHKEY(
            szUser,
            &hKey,
            NULL)) )
        goto Ret;

    // Open Data Key //
    if (ERROR_SUCCESS != (dwRet =
        RegOpenKeyExU(
            hKey,
            REG_DATA_LOC,
            0,
            KEY_READ | KEY_WRITE,
            &hDataKey)) )
        goto Ret;

    // enum the dwIndex'th item, alloc & return
    if (ERROR_SUCCESS != (dwRet =
        RegEnumKeyExA(
            hDataKey,
            dwIndex,
            rgszGuidType, // address of buffer for subkey name
            &cbName,    // address for size of subkey buffer
            NULL,       // reserved
            NULL,       // pbclass
            NULL,       // cbclass
            &ft)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        MyGuidFromStringA(
            rgszGuidType,
            pguidType)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return dwRet;
}

DWORD BPGetTypeName(
        LPCWSTR  szUser,            // in
        const GUID*   pguidType,          // in
        LPWSTR* ppszType)           // out
{
    HKEY hKey = NULL;
    DWORD cbName = 0;
    DWORD dwRet;

    if (PST_E_OK != (dwRet =
        GetPSTTypeHKEY(
            szUser,
            pguidType,
            &hKey)) )
    {
        dwRet = (DWORD)PST_E_TYPE_NO_EXISTS;
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwRet =
        RegGetStringValue(
            hKey,
            REG_DISPLAYSTRING_VALNAME,
            (PBYTE*)ppszType,
            &cbName)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

// end TYPE management
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// SUBTYPE management

DWORD BPCreateSubtype(
        LPCWSTR  szUser,            // in
        const GUID*   pguidType,          // in
        const GUID*   pguidSubtype,       // in
        PST_TYPEINFO* pinfoSubtype) // in
{
    DWORD dwRet;
    BOOL fExisted;

    // now we need to create entries in hierarchy
    HKEY    hKey = NULL;
    if (PST_E_OK != (dwRet =
        CreatePSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hKey,
            &fExisted)) )
        goto Ret;

    // if we didn't create it, setting is an error
    if (fExisted)
    {
        dwRet = (DWORD)PST_E_TYPE_EXISTS;
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hKey,
            REG_DISPLAYSTRING_VALNAME,
            0,
            REG_SZ,
            (PBYTE)pinfoSubtype->szDisplayName,
            WSZ_BYTECOUNT(pinfoSubtype->szDisplayName) )) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

DWORD BPDeleteSubtype(
        LPCWSTR  szUser,         // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype)   // in
{
    DWORD dwRet;
    CHAR rgszSubtypeGuid[MAX_GUID_SZ_CHARS];

    // now remove the entry in hierarchy
    HKEY hKey = NULL;
    if (PST_E_OK != (dwRet =
        GetPSTTypeHKEY(
            szUser,
            pguidType,
            &hKey)) )
    {
        dwRet = (DWORD)PST_E_TYPE_NO_EXISTS;
        goto Ret;
    }

    if (PST_E_OK != (dwRet =
        MyGuidToStringA(
            pguidSubtype,
            rgszSubtypeGuid)) )
        goto Ret;

    if (!FIsWinNT())
    {
        CHAR rgszTmp[MAX_GUID_SZ_CHARS];
        DWORD cbTmp = MAX_GUID_SZ_CHARS;
        FILETIME ft;
        HKEY hTestEmptyKey = NULL;

        // open the subtype
        if (ERROR_SUCCESS != (dwRet =
            RegOpenKeyExA(
                hKey,
                rgszSubtypeGuid,
                0,
                KEY_ALL_ACCESS,
                &hTestEmptyKey)) )
            goto Ret;

        // check for emptiness
        if (ERROR_NO_MORE_ITEMS !=
            RegEnumKeyExA(
                hTestEmptyKey,
                0,
                rgszTmp, // address of buffer for subkey name
                &cbTmp, // address for size of subkey buffer
                NULL,       // reserved
                NULL,       // pbclass
                NULL,       // cbclass
                &ft))
        {
            RegCloseKey(hTestEmptyKey);
            dwRet = (DWORD)PST_E_NOTEMPTY;
            goto Ret;
        }

        // close key before deletion
        RegCloseKey(hTestEmptyKey);
    }

    // now, remove the friendly name
    if (ERROR_SUCCESS != (dwRet =
        RegDeleteKeyA(
            hKey,
            rgszSubtypeGuid)) )
    {
        if (dwRet == ERROR_ACCESS_DENIED)
            dwRet = (DWORD)PST_E_NOTEMPTY;

        goto Ret;
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

DWORD BPEnumSubtypes(
        LPCWSTR  szUser,         // in
        DWORD   dwIndex,        // in
        const GUID*   pguidType,      // in
        GUID*   pguidSubtype)   // out
{
    DWORD dwRet;

    CHAR rgszGuidSubtype[MAX_GUID_SZ_CHARS];
    DWORD cbName = MAX_GUID_SZ_CHARS;

    FILETIME ft;

    // now walk through types, returning them one by one
    HKEY hTypeKey=NULL, hSubtypeKey=NULL;

    if (PST_E_OK != (dwRet =
        GetPSTTypeHKEY(
            szUser,
            pguidType,
            &hTypeKey)) )
        goto Ret;

    // enum the dwIndex'th item, alloc & return
    if (ERROR_SUCCESS != (dwRet =
        RegEnumKeyExA(
            hTypeKey,
            dwIndex,
            rgszGuidSubtype, // address of buffer for subkey name
            &cbName,    // address for size of subkey buffer
            NULL,       // reserved
            NULL,       // pbclass
            NULL,       // cbclass
            &ft)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        MyGuidFromStringA(
            rgszGuidSubtype,
            pguidSubtype)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegOpenKeyExA(
            hTypeKey,
            rgszGuidSubtype,
            0,
            KEY_READ | KEY_WRITE,
            &hSubtypeKey)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hTypeKey)
        RegCloseKey(hTypeKey);

    if (hSubtypeKey)
        RegCloseKey(hSubtypeKey);

    return dwRet;
}

DWORD BPGetSubtypeName(
        LPCWSTR  szUser,             // in
        const GUID*   pguidType,          // in
        const GUID*   pguidSubtype,       // in
        LPWSTR* ppszSubtype)        // out
{
    HKEY hKey = NULL;
    DWORD cbName = 0;
    DWORD dwRet;

    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegGetStringValue(
            hKey,
            REG_DISPLAYSTRING_VALNAME,
            (PBYTE*)ppszSubtype,
            &cbName)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

// end SUBTYPE management
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// ITEM management

// given uuid, push entries into storage
DWORD BPCreateItem(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName)    // in
{
    DWORD dwRet;
    BOOL fExisted;
    HKEY    hKey = NULL;


    //
    // mattt 2/5/97: allow items with \ in them to be created. Urgh!
    //
    // mattt 4/28/97: begin restricting strings. 
    // Cert request code has been changed to not create this type of key name
    //
/*
    if (!FStringIsValidItemName(szItemName))
    {
        dwRet = (DWORD)PST_E_INVALID_STRING;
        goto Ret;
    }
*/
    // now we need to create entries in hierarchy
    if (PST_E_OK != (dwRet =
        CreatePSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hKey,
            &fExisted)) )
        goto Ret;

    if (fExisted)
    {
        dwRet = (DWORD)PST_E_ITEM_EXISTS;
        goto Ret;
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}


DWORD BPDeleteItem(
        LPCWSTR  szUser,         // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName)     // in
{
    DWORD dwRet;
    HKEY    hSubTypeKey = NULL;

    // now we need to remove entries in hierarchy
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hSubTypeKey)) )
        goto Ret;

    // now, remove the friendly name
    if (ERROR_SUCCESS != (dwRet =
        RegDeleteKeyU(
            hSubTypeKey,
            szItemName)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hSubTypeKey)
        RegCloseKey(hSubTypeKey);

    return dwRet;
}

// Warning: Item path must be fully specified.. szName returned
DWORD BPEnumItems(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        DWORD   dwIndex,        // in
        LPWSTR* ppszName)       // out
{
    DWORD dwRet;

    WCHAR szName[MAX_PATH];
    DWORD cchName = MAX_PATH;
    FILETIME ft;

    // now walk through types, returning them one by one
    HKEY hKey = NULL;

    // Open SubType key //
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hKey)) )
        goto Ret;

    // enum the dwIndex'th item, alloc & return
    if (ERROR_SUCCESS != (dwRet =
        RegEnumKeyExU(
            hKey,
            dwIndex,
            szName,     // address of buffer for subkey name
            &cchName,   // address for size of subkey buffer
            NULL,       // reserved
            NULL,       // pbclass
            NULL,       // cbclass
            &ft)) )
        goto Ret;

    *ppszName = (LPWSTR)SSAlloc((cchName+1)*sizeof(WCHAR));
    if(*ppszName == NULL)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    wcscpy(*ppszName, szName);

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hKey)
        RegCloseKey(hKey);

    return dwRet;
}

// end ITEM management
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// SECURED DATA

BOOL FBPGetSecuredItemData(
        LPCWSTR  szUser,         // in
        LPCWSTR  szMasterKey,    // in
        BYTE    rgbPwd[A_SHA_DIGEST_LEN],       // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,     // in
        PBYTE*  ppbData,        // out
        DWORD*  pcbData)        // out
{
    DWORD dwRet;

    *ppbData = NULL;    // on err return NULL
    *pcbData = 0;

    HKEY    hItemKey = NULL;

    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    // Version | Key Block | Secure Data [...]
    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hItemKey,
            REG_ITEM_SECURE_DATA_VALNAME,
            ppbData,
            pcbData)) )
        goto Ret;

    if (!FProvDecryptData(
            szUser,
            szMasterKey,
            rgbPwd,         // in
            ppbData,        // in out
            pcbData))       // in out
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    dwRet = PST_E_OK;
Ret:
    if ((dwRet != PST_E_OK) && (*ppbData != NULL))
    {
        SSFree(*ppbData);
        *ppbData = NULL;
        *pcbData = 0;
    }

    if (hItemKey)
        RegCloseKey(hItemKey);

    return (dwRet == PST_E_OK);
}

BOOL FBPSetSecuredItemData(
        LPCWSTR  szUser,         // in
        LPCWSTR  szMasterKey,    // in
        BYTE    rgbPwd[A_SHA_DIGEST_LEN],       // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,     // in
        PBYTE   pbData,         // in
        DWORD   cbData)         // in
{
#define REALLOC_FUDGESIZE   96  // 5dw + SHA_LEN + KeyBlock + DES_BLOCKLEN (block encr expansion)

    DWORD dwRet;

    HKEY    hItemKey = NULL;

    PBYTE   pbMyData = NULL;
    DWORD   cbMyData;

    // make whackable copy
    cbMyData = cbData;
    pbMyData = (PBYTE)SSAlloc(cbMyData + REALLOC_FUDGESIZE);
    if (pbMyData == NULL)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    CopyMemory(pbMyData, pbData, cbData);


    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    if (!FProvEncryptData(
            szUser,
            szMasterKey,
            rgbPwd,             // in
            &pbMyData,          // in out
            &cbMyData))         // in out
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hItemKey,
            REG_ITEM_SECURE_DATA_VALNAME,
            0,
            REG_BINARY,
            pbMyData,
            cbMyData)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (hItemKey)
        RegCloseKey(hItemKey);

    if (pbMyData)
        SSFree(pbMyData);

    return (dwRet == PST_E_OK);
}

// end SECURED DATA
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// INSECURE DATA

DWORD BPGetInsecureItemData(
        LPCWSTR  szUser,         // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,     // in
        PBYTE*  ppbData,        // out
        DWORD*  pcbData)        // out
{
    DWORD dwRet;
    *ppbData = NULL;

    HKEY    hItemKey = NULL;

    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hItemKey,
            REG_ITEM_INSECURE_DATA_VALNAME,
            ppbData,
            pcbData)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:

    if (hItemKey)
        RegCloseKey(hItemKey);

    return dwRet;
}

DWORD BPSetInsecureItemData(
        LPCWSTR  szUser,         // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,     // in
        PBYTE   pbData,         // in
        DWORD   cbData)         // in
{
    DWORD dwRet;

    HKEY    hItemKey = NULL;

    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hItemKey,
            REG_ITEM_INSECURE_DATA_VALNAME,
            0,
            REG_BINARY,
            pbData,
            cbData)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (hItemKey)
        RegCloseKey(hItemKey);

    return dwRet;
}

// end INSECURE DATA
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// RULESETS

// #define RULESET_VERSION 0x1
// 6-12-97 incremented version; version 0x1 contains old HMAC
#define RULESET_VERSION 0x2


#if 0

DWORD BPGetSubtypeRuleset(
        PST_PROVIDER_HANDLE*    phPSTProv, // in
        LPCWSTR  szUser,                // in
        const GUID*   pguidType,        // in
        const GUID*   pguidSubtype,     // in
        PST_ACCESSRULESET* psRules)     // out
{
    DWORD dwRet;
    HKEY hSubtypeKey = NULL;

    BYTE rgbHMAC[A_SHA_DIGEST_LEN];
    BYTE rgbPwd[A_SHA_DIGEST_LEN];

    PBYTE pbBuf = NULL;
    DWORD cbBuf;

    PBYTE pbCurrent;
    DWORD cbRuleSize;
    PBYTE pbRuleSet;

    DWORD dwVersion;

    // Open Subtype //
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hSubtypeKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hSubtypeKey,
            REG_ACCESSRULE_LOC,
            &pbBuf,
            &cbBuf)) )
        goto Ret;


//  RULESET DATA FORMAT:
//  version | size(ruleset) | ruleset | size(MAC) | MAC {of type, subtype, ruleset}
    pbCurrent = pbBuf;

    if( cbBuf < (sizeof(DWORD)*2) ) {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    // version check
    dwVersion = *(DWORD*)pbCurrent;
    if (dwVersion > RULESET_VERSION)
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    pbCurrent += sizeof(DWORD);


    cbRuleSize = *(DWORD*)pbCurrent;

    // get WinPW
	if (PST_E_OK != 
		BPVerifyPwd(
			phPSTProv,
			szUser,
			WSZ_PASSWORD_WINDOWS,
			rgbPwd,
			BP_CONFIRM_NONE))
	{
        dwRet = (DWORD)PST_E_WRONG_PASSWORD;
        goto Ret;
	}

    // check MAC

    // Compute Geographically sensitive (can't move) HMAC on { size(ruleset), ruleset }
    if (!FHMACGeographicallySensitiveData(
            szUser,
            WSZ_PASSWORD_WINDOWS,
            (dwVersion == 0x01) ? OLD_HMAC_VERSION : NEW_HMAC_VERSION, 
            rgbPwd,
            pguidType,
            pguidSubtype,
            NULL,
            pbCurrent,
            cbRuleSize + sizeof(DWORD),     // include the rulesize
            rgbHMAC))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    pbCurrent += sizeof(DWORD); // skip past cbRuleSize (already snarfed)
    pbRuleSet = pbCurrent;      // point to rules
    pbCurrent += cbRuleSize;    // skip past rules

    // check MAC len
    if (*(DWORD*)pbCurrent != A_SHA_DIGEST_LEN)
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }
    pbCurrent += sizeof(DWORD); // skip past sizeof(MAC)

    // check MAC
    if (0 != memcmp(rgbHMAC, pbCurrent, A_SHA_DIGEST_LEN))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    // MAC okay! shrink to rulesize
    MoveMemory(pbBuf, pbRuleSet, cbRuleSize);
    cbBuf = cbRuleSize;
    pbBuf = (PBYTE)SSReAlloc(pbBuf, cbBuf); 
    if (pbBuf == NULL)      // check allocation
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }


    // serialize rules out of the buffer
    if (!FAccessRulesUnPickle(
            psRules,
            pbBuf,
            cbBuf))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (pbBuf)
        SSFree(pbBuf);

    if (hSubtypeKey)
        RegCloseKey(hSubtypeKey);

    return dwRet;
}



DWORD BPSetSubtypeRuleset(
        PST_PROVIDER_HANDLE*    phPSTProv,              // in
        LPCWSTR  szUser,                                // in
        const GUID*   pguidType,                        // in
        const GUID*   pguidSubtype,                     // in
        PST_ACCESSRULESET *psRules)                     // in
{
    DWORD dwRet;
    HKEY hSubtypeKey = NULL;

    BYTE rgbHMAC[A_SHA_DIGEST_LEN];
    BYTE rgbPwd[A_SHA_DIGEST_LEN];

    PBYTE pbBuf = NULL;
    DWORD cbBuf;

    PBYTE pbCurPtr;
    DWORD cbNewSize;

    // serialize rules into a buffer
    if (!FAccessRulesPickle(
            psRules,
            &pbBuf,
            &cbBuf))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

//  RULESET DATA FORMAT:
//  version | size(ruleset) | ruleset | size(MAC) | Geographical MAC {size(ruleset), ruleset}
    cbNewSize = cbBuf + 3*sizeof(DWORD) + A_SHA_DIGEST_LEN;
    pbBuf = (PBYTE)SSReAlloc(pbBuf, cbNewSize);
    if (pbBuf == NULL)      // check allocation
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }
    MoveMemory(pbBuf + 2*sizeof(DWORD), pbBuf, cbBuf);

    // helpful pointer
    pbCurPtr = pbBuf;

    // version
    *(DWORD*)pbCurPtr = (DWORD)RULESET_VERSION;
    pbCurPtr += sizeof(DWORD);

    // size(ruleset)
    *(DWORD*)pbCurPtr = (DWORD)cbBuf;
    pbCurPtr += sizeof(DWORD);

    // ruleset previously moved by MoveMemory call
    pbCurPtr += cbBuf;  // fwd past ruleset

    // get WinPW
	if (PST_E_OK != 
		BPVerifyPwd(
			phPSTProv,
			szUser,
			WSZ_PASSWORD_WINDOWS,
			rgbPwd,
			BP_CONFIRM_NONE))
	{
        dwRet = (DWORD)PST_E_WRONG_PASSWORD;
        goto Ret;
	}

    // check MAC
    // Compute Geographically sensitive (can't move) HMAC on { size(ruleset), ruleset }
    if (!FHMACGeographicallySensitiveData(
            szUser,
            WSZ_PASSWORD_WINDOWS,
            NEW_HMAC_VERSION,
            rgbPwd,
            pguidType,
            pguidSubtype,
            NULL,
            pbBuf + sizeof(DWORD),
            cbBuf + sizeof(DWORD),
            rgbHMAC))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    // HMAC size
    *(DWORD*)pbCurPtr = (DWORD) sizeof(rgbHMAC);
    pbCurPtr += sizeof(DWORD);

    // HMAC
    CopyMemory(pbCurPtr, rgbHMAC, sizeof(rgbHMAC));

    // done; set cbBuf = new size
    cbBuf = cbNewSize;


    // Open Subtype //
    if (PST_E_OK != (dwRet =
        GetPSTSubtypeHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            &hSubtypeKey)) )
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    // now write item
    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hSubtypeKey,
            REG_ACCESSRULE_LOC,
            0,
            REG_BINARY,
            pbBuf,
            cbBuf)) )
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (pbBuf)
        SSFree(pbBuf);

    if (hSubtypeKey)
        RegCloseKey(hSubtypeKey);

    return dwRet;
}


DWORD BPGetItemRuleset(
        PST_PROVIDER_HANDLE* phPSTProv,                 // in
        LPCWSTR  szUser,                                // in
        const GUID*   pguidType,                        // in
        const GUID*   pguidSubtype,                     // in
        LPCWSTR  szItemName,                            // in
        PST_ACCESSRULESET* psRules)                     // out
{
    DWORD dwRet;
    HKEY hItemKey = NULL;

    PBYTE pbBuf = NULL;
    DWORD cbBuf;

    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;           // item doesn't exist -- ouch!!

    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hItemKey,
            REG_ACCESSRULE_LOC,
            &pbBuf,
            &cbBuf)) )
    {
        // item exists, rules don't
        // fall back on subtype ruleset
        if (PST_E_OK != (dwRet =
            BPGetSubtypeRuleset(
                phPSTProv,
                szUser,
                pguidType,
                pguidSubtype,
                psRules)) )
            goto Ret;
    }
    else
    {
        // serialize rules into a buffer
        if (!FAccessRulesUnPickle(
                psRules,
                pbBuf,
                cbBuf))
        {
            dwRet = (DWORD)PST_E_INVALID_RULESET;
            goto Ret;
        }
    }

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (pbBuf)
        SSFree(pbBuf);

    if (hItemKey)
        RegCloseKey(hItemKey);

    return dwRet;
}


DWORD BPSetItemRuleset(
        PST_PROVIDER_HANDLE* phPSTProv,                 // in
        LPCWSTR  szUser,                                // in
        const GUID*   pguidType,                        // in
        const GUID*   pguidSubtype,                     // in
        LPCWSTR  szItemName,                            // in
        PST_ACCESSRULESET *psRules)                     // in
{
    DWORD dwRet;

    HKEY hItemKey = NULL;

    PBYTE pbBuf = NULL;
    DWORD cbBuf;

    // serialize rules into a buffer
    if (!FAccessRulesPickle(
            psRules,
            &pbBuf,
            &cbBuf))
    {
        dwRet = (DWORD)PST_E_INVALID_RULESET;
        goto Ret;
    }

    // Open Subtype //
    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    // now write item
    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hItemKey,
            REG_ACCESSRULE_LOC,
            0,
            REG_BINARY,
            pbBuf,
            cbBuf)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (pbBuf)
        SSFree(pbBuf);

    if (hItemKey)
        RegCloseKey(hItemKey);

    return dwRet;
}

#endif

// end RULESETS
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// ITEM CONFIRM INFO
// #define CONFIRMATION_VERSION    0x01
// 6-12-97 incremented version: version 0x1 contains old HMAC
#define CONFIRMATION_VERSION    0x02

DWORD BPGetItemConfirm(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        DWORD*  pdwConfirm,     // in
        LPWSTR* pszMK)          // in
{
    DWORD dwRet;
    HKEY hItemKey = NULL;


    PBYTE pbBuf = NULL;
    DWORD cbBuf = 0;

    BYTE rgbHMAC[A_SHA_DIGEST_LEN];
    BYTE rgbPwd[A_SHA_DIGEST_LEN];

    // helpful pointers
    PBYTE pbCurPtr = NULL;

    PBYTE pbString;
    DWORD cbString;

    DWORD dwVersion;

    // Open nonexistent item master key
    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hItemKey,
            REG_ITEM_MK_VALNAME,
            &pbBuf,
            &cbBuf)) )
        goto Ret;

    // Confirmation data format
    // Version | dwConfirm | size(szMasterKey) | szMasterKey | size(MAC) | Geographical MAC { dwConfirm | size(szMasterKey) | szMasterKey }

    // version check
    dwVersion = *(DWORD*)pbBuf;
    if (CONFIRMATION_VERSION < dwVersion)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }
    pbCurPtr = pbBuf + sizeof(DWORD);   // fwd past vers


    // get WinPW
	if (PST_E_OK != 
		BPVerifyPwd(
			phPSTProv,
			szUser,
			WSZ_PASSWORD_WINDOWS,
			rgbPwd,
			BP_CONFIRM_NONE))
	{
        dwRet = (DWORD)PST_E_WRONG_PASSWORD;
        goto Ret;
	}

    // check MAC
    // Compute Geographically sensitive (can't move) HMAC on { dwConfirm | size(szMasterKey) | szMasterKey }
    if (!FHMACGeographicallySensitiveData(
            szUser,
            WSZ_PASSWORD_WINDOWS,
            (dwVersion == 0x01) ? OLD_HMAC_VERSION : NEW_HMAC_VERSION,
            rgbPwd,
            pguidType,
            pguidSubtype,
            szItemName,
            pbBuf + sizeof(DWORD),   // fwd past Version
            cbBuf - 2*sizeof(DWORD) - A_SHA_DIGEST_LEN, // Version, size(MAC), MAC
            rgbHMAC))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // dwConfirm
    *pdwConfirm = *(DWORD*)pbCurPtr;    // dwConfirm
    pbCurPtr += sizeof(DWORD);          // fwd past dwConfirm

    // szMasterKey
    cbString = *(DWORD*)pbCurPtr;       // strlen
    pbCurPtr += sizeof(DWORD);          // fwd past len
    pbString = pbCurPtr;                // save ptr to string
    pbCurPtr += cbString;            // skip string

    if (*(DWORD*)pbCurPtr != A_SHA_DIGEST_LEN)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }
    pbCurPtr += sizeof(DWORD);

    if (0 != memcmp(pbCurPtr, rgbHMAC, A_SHA_DIGEST_LEN))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }


    MoveMemory(pbBuf, pbString, cbString);   // shift left string
    pbCurPtr = (PBYTE)SSReAlloc(pbBuf, cbString);      // shorten to strlen
    if (pbCurPtr == NULL)      // check allocation
    {
        dwRet = PST_E_FAIL;
        if (pbBuf) {
            SSFree(pbBuf);
            pbBuf = NULL;
        }
        goto Ret;
    }

    pbBuf = pbCurPtr; 

    dwRet = (DWORD)PST_E_OK;
Ret:
    *pszMK = (LPWSTR)pbBuf;             // assign to out param

    if (hItemKey)
        RegCloseKey(hItemKey);

    return dwRet;
}

DWORD BPSetItemConfirm(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,         // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,     // in
        DWORD   dwConfirm,      // in
        LPCWSTR  szMK)           // in
{
    DWORD dwRet;
    HKEY hItemKey = NULL;

    BYTE rgbHMAC[A_SHA_DIGEST_LEN];
    BYTE rgbPwd[A_SHA_DIGEST_LEN];

    // helpful pointer
    PBYTE pbCurPtr;

    // Confirmation data format
    // Version | dwConfirm | size(szMasterKey) | szMasterKey | size(MAC) | Geographical MAC { dwConfirm | size(szMasterKey) | szMasterKey }
    DWORD cbBuf = WSZ_BYTECOUNT(szMK)+ 4*sizeof(DWORD) + A_SHA_DIGEST_LEN;
    PBYTE pbBuf = (PBYTE)SSAlloc(cbBuf);
    if (pbBuf == NULL)      // check allocation
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }

    pbCurPtr = pbBuf;

    // version
    *(DWORD*)pbCurPtr = (DWORD)CONFIRMATION_VERSION;
    pbCurPtr += sizeof(DWORD);

    // dwConfirm
    *(DWORD*)pbCurPtr = dwConfirm;
    pbCurPtr += sizeof(DWORD);

    // szMasterKey size
    *(DWORD*)pbCurPtr = (DWORD)WSZ_BYTECOUNT(szMK);
    pbCurPtr += sizeof(DWORD);

    // szMasterKey
    wcscpy((LPWSTR)pbCurPtr, szMK);
    pbCurPtr += WSZ_BYTECOUNT(szMK);    // fwd past szMK


    // get WinPW
	if (PST_E_OK != 
		BPVerifyPwd(
			phPSTProv,
			szUser,
			WSZ_PASSWORD_WINDOWS,
			rgbPwd,
			BP_CONFIRM_NONE))
	{
        dwRet = (DWORD)PST_E_WRONG_PASSWORD;
        goto Ret;
	}

    // check MAC
    // Compute Geographically sensitive (can't move) HMAC on { dwConfirm | size(szMasterKey) | szMasterKey }
    if (!FHMACGeographicallySensitiveData(
            szUser,
            WSZ_PASSWORD_WINDOWS,
            NEW_HMAC_VERSION,
            rgbPwd,
            pguidType,
            pguidSubtype,
            szItemName,
            pbBuf + sizeof(DWORD), // fwd past Version
            cbBuf - 2*sizeof(DWORD) - A_SHA_DIGEST_LEN, // Version, size(MAC), MAC
            rgbHMAC))
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    // HMAC size
    *(DWORD*)pbCurPtr = (DWORD) sizeof(rgbHMAC);
    pbCurPtr += sizeof(DWORD);

    // HMAC
    CopyMemory(pbCurPtr, rgbHMAC, sizeof(rgbHMAC));


    // Open Item //
    if (PST_E_OK != (dwRet =
        GetPSTItemHKEY(
            szUser,
            pguidType,
            pguidSubtype,
            szItemName,
            &hItemKey)) )
        goto Ret;

    // now write item
    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hItemKey,
            REG_ITEM_MK_VALNAME,
            0,
            REG_BINARY,
            pbBuf,
            cbBuf)) )
        goto Ret;

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hItemKey)
        RegCloseKey(hItemKey);

    if (pbBuf)
        SSFree(pbBuf);

    return dwRet;
}

// ITEM CONFIRM INFO
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// MASTER KEYS
BOOL BPMasterKeyExists(
        LPCWSTR  szUser,            // in
        LPWSTR   szMasterKey)       // in
{
    BOOL fRet = FALSE;
    HKEY hMyKey = NULL;
    HKEY hMasterKey = NULL;

    // Open Master parent key //
    if (PST_E_OK !=
        GetPSTMasterKeyHKEY(
            szUser,
            NULL,
            &hMyKey))
        goto Ret;

    // attempt to open the master key location
    if (ERROR_SUCCESS !=
        RegOpenKeyExU(
            hMyKey,
            szMasterKey,
            0,
            KEY_QUERY_VALUE,
            &hMasterKey))
        goto Ret;

    // key does exist
    fRet = TRUE;
Ret:
    if (hMyKey)
        RegCloseKey(hMyKey);

    if (hMasterKey)
        RegCloseKey(hMasterKey);

    return fRet;
}

DWORD BPEnumMasterKeys(
        LPCWSTR  szUser,            // in
        DWORD   dwIndex,            // in
        LPWSTR* ppszMasterKey)      // out
{
    DWORD dwRet;
    HKEY hMyKey = NULL;

    WCHAR szName[MAX_PATH];
    DWORD cchName = MAX_PATH;
    FILETIME ft;

    // Open Master parent key //
    if (PST_E_OK != (dwRet =
        GetPSTMasterKeyHKEY(
            szUser,
            NULL,
            &hMyKey)) )
        goto Ret;

    // enum the dwIndex'th item, alloc & return
    if (ERROR_SUCCESS != (dwRet =
        RegEnumKeyExU(
            hMyKey,
            dwIndex,
            szName,     // address of buffer for subkey name
            &cchName,   // address for size of subkey buffer
            NULL,       // reserved
            NULL,       // pbclass
            NULL,       // cbclass
            &ft)) )
        goto Ret;

    *ppszMasterKey = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(szName));
    if(*ppszMasterKey == NULL)
    {
        dwRet = (DWORD)PST_E_FAIL;
        goto Ret;
    }

    wcscpy(*ppszMasterKey, szName);

    dwRet = (DWORD)PST_E_OK;
Ret:
    if (hMyKey)
        RegCloseKey(hMyKey);

    return dwRet;
}

DWORD BPGetMasterKeys(
        LPCWSTR  szUser,
        LPWSTR  rgszMasterKeys[],
        DWORD*  pcbMasterKeys,
        BOOL    fUserFilter)
{
    DWORD dwRet;
    DWORD cKeys=0;

    for (DWORD cntEnum=0; cntEnum<*pcbMasterKeys; cntEnum++)
    {
        if (PST_E_OK != (dwRet =
            BPEnumMasterKeys(
                szUser,
                cntEnum,
                &rgszMasterKeys[cKeys])) )
            break;

        cKeys++;

        // filter out non-user keys
        if (fUserFilter)
        {
            if (!FIsUserMasterKey(rgszMasterKeys[cKeys-1]))
                SSFree(rgszMasterKeys[--cKeys]);
        }
    }

    *pcbMasterKeys = cKeys;

    return PST_E_OK;
}

// end MASTER KEYS
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// SECURITY STATE
#define SECURITY_STATE_VERSION 0x01

BOOL FBPGetSecurityState(
            LPCWSTR  szUser,
            LPCWSTR  szMK,
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbConfirm[],
            DWORD   cbConfirm,
            PBYTE*  ppbMK,
            DWORD*  pcbMK)
{
    DWORD dwRet;
    HKEY hMKKey = NULL;

    // Open MK Key //
    if (PST_E_OK != (dwRet =
        GetPSTMasterKeyHKEY(
            szUser,
            szMK,
            &hMKKey)) )
        goto Ret;

    dwRet = PST_E_FAIL;

    if(!FBPGetSecurityStateFromHKEY(
                hMKKey,
                rgbSalt,
                cbSalt,
                rgbConfirm,
                cbConfirm,
                ppbMK,
                pcbMK))
        goto Ret;


    dwRet = PST_E_OK;
Ret:
    if (hMKKey)
        RegCloseKey(hMKKey);

    return (dwRet == PST_E_OK);
}

BOOL FBPGetSecurityStateFromHKEY(
            HKEY hMKKey,
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbConfirm[],
            DWORD   cbConfirm,
            PBYTE*  ppbMK,
            DWORD*  pcbMK)
{
    DWORD dwRet;

    PBYTE pbBuf = NULL;
    DWORD cbBuf;

    // helpful pointer
    PBYTE pbCurPtr;

    DWORD dwMemberSize;
    DWORD dwCreated;


    PBYTE pbLocalSalt;
    PBYTE pbLocalMK;
    PBYTE pbLocalConfirm;

    DWORD cbLocalSalt;
    DWORD cbLocalMK;
    DWORD cbLocalConfirm;

    PBYTE pbMaximumPtr;
    PBYTE pbMinimumPtr;



    if (ERROR_SUCCESS != (dwRet =
        RegGetValue(
            hMKKey,
            REG_SECURITY_SALT_VALNAME,
            &pbBuf,
            &cbBuf)) )
        goto Ret;

    dwRet = PST_E_FAIL;

    // Security data format
    // Version | size(MK) | MK | size(Salt) | Salt | size(Confirm) | Confirm

    if ( cbBuf < (sizeof(DWORD)*4) )
        goto Ret;

    // version check
    if (SECURITY_STATE_VERSION != *(DWORD*)pbBuf)
        goto Ret;

    pbCurPtr = pbBuf + sizeof(DWORD);   // fwd past vers

    pbMinimumPtr = pbCurPtr;
    pbMaximumPtr = (pbBuf+cbBuf);


    //
    // MK
    //

    if( pbCurPtr >= pbMaximumPtr || pbCurPtr < pbMinimumPtr )
        goto Ret;

    cbLocalMK = *(DWORD*)pbCurPtr;      // size

    if( cbLocalMK > cbBuf )
        goto Ret;

    pbCurPtr += sizeof(DWORD);          // fwd past size

    pbLocalMK = pbCurPtr;

    pbCurPtr += cbLocalMK;              // fwd past data

    //
    // Salt
    //

    if( pbCurPtr >= pbMaximumPtr || pbCurPtr < pbMinimumPtr )
        goto Ret;

    cbLocalSalt = *(DWORD*)pbCurPtr;    // size
    if( cbLocalSalt > cbBuf )
        goto Ret;

    pbCurPtr += sizeof(DWORD);          // fwd past size

    pbLocalSalt = pbCurPtr;

    if (cbLocalSalt != cbSalt)          // sizechk
        goto Ret;

    pbCurPtr += cbSalt;                 // fwd past data

    //
    // Confirm
    //

    if( pbCurPtr >= pbMaximumPtr || pbCurPtr < pbMinimumPtr )
        goto Ret;

    cbLocalConfirm = *(DWORD*)pbCurPtr; // size
    if( cbLocalConfirm > cbBuf )
        goto Ret;

    pbCurPtr += sizeof(DWORD);          // fwd past size

    pbLocalConfirm = pbCurPtr;

    if (cbLocalConfirm != cbConfirm)    // sizechk
        goto Ret;

    pbCurPtr += cbConfirm;              // fwd past data


    //
    // do a single size sanity check before copying data out.
    //

    if( pbCurPtr != (pbBuf + cbBuf) )
        goto Ret;

    MoveMemory(pbBuf, pbLocalMK, cbLocalMK);        // move left to front for later realloc
    CopyMemory(rgbSalt, pbLocalSalt, cbLocalSalt);  // data
    CopyMemory(rgbConfirm, pbLocalConfirm, cbLocalConfirm); // data

    //
    // MK fixup
    //

    *pcbMK = cbLocalMK;

    pbCurPtr = (PBYTE)SSReAlloc(pbBuf, *pcbMK);      // shorten to MK data
    if (pbCurPtr == NULL)
    {
        dwRet = PST_E_FAIL;
        if (pbBuf) {
            SSFree(pbBuf);
            *ppbMK = NULL;
        }
        goto Ret;
    }
    *ppbMK = pbCurPtr;


    dwRet = PST_E_OK;
Ret:

    return (dwRet == PST_E_OK);
}

BOOL FBPSetSecurityState(
            LPCWSTR  szUser,
            LPCWSTR  szMK,
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbConfirm[],
            DWORD   cbConfirm,
            PBYTE   pbMK,
            DWORD   cbMK)
{
    DWORD   dwRet;
    HKEY    hMKKey = NULL;
    
    // helpful pointer
    PBYTE pbCurPtr;

    DWORD cbBuf = cbSalt + cbConfirm + cbMK + 4*sizeof(DWORD);  // ver + size + data
    PBYTE pbBuf = (PBYTE)SSAlloc(cbBuf);
    if (pbBuf == NULL)
    {
        dwRet = PST_E_FAIL;
        goto Ret;
    }

    pbCurPtr = pbBuf;


    // Security data format
    // Version | size(MK) | MK | size(Salt) | Salt | size(Confirm) | Confirm

    *(DWORD*)pbCurPtr = SECURITY_STATE_VERSION;     // ver
    pbCurPtr += sizeof(DWORD);                  // fwd past ver

    // MK
    *(DWORD*)pbCurPtr = cbMK;                   // size
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    CopyMemory(pbCurPtr, pbMK, cbMK);           // data
    pbCurPtr += cbMK;                           // fwd past data

    // Salt
    *(DWORD*)pbCurPtr = cbSalt;                 // size
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    CopyMemory(pbCurPtr, rgbSalt, cbSalt);      // data
    pbCurPtr += cbSalt;                         // fwd past data

    // Confirm
    *(DWORD*)pbCurPtr = cbConfirm;              // size
    pbCurPtr += sizeof(DWORD);                  // fwd past size
    CopyMemory(pbCurPtr, rgbConfirm, cbConfirm);// data
    pbCurPtr += cbConfirm;                      // fwd past data



    // Open User Key //
    if (PST_E_OK != (dwRet =
        GetPSTMasterKeyHKEY(
            szUser,
            szMK,
            &hMKKey)) )
        goto Ret;

    if (ERROR_SUCCESS != (dwRet =
        RegSetValueExU(
            hMKKey,
            REG_SECURITY_SALT_VALNAME,
            0,
            REG_BINARY,
            pbBuf,
            cbBuf)) )
        goto Ret;

    dwRet = PST_E_OK;
Ret:
    if (hMKKey)
        RegCloseKey(hMKKey);

    if (pbBuf)
        SSFree(pbBuf);

    return (dwRet == PST_E_OK);
}

// end SECURITY STATE
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// begin global MAC Key storage
#define INTERNAL_MAC_KEY_VERSION 0x1

BOOL FGetInternalMACKey(LPCWSTR szUser, PBYTE* ppbKey, DWORD* pcbKey)
{
    BOOL fRet = FALSE;
    HKEY hBaseKey = NULL;
    HKEY hDataKey = NULL;

    // Open User Key //
    if (PST_E_OK !=
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL))
        goto Ret;

    // Open Data Key //
    if (ERROR_SUCCESS !=
        RegOpenKeyExU(
            hBaseKey,
            REG_DATA_LOC,
            0,
            KEY_READ | KEY_WRITE,
            &hDataKey))
        goto Ret;

    if (ERROR_SUCCESS !=
        RegGetValue(
            hDataKey,
            REG_USER_INTERNAL_MAC_KEY,
            ppbKey,
            pcbKey))
        goto Ret;

    if(*pcbKey < sizeof(DWORD))
        goto Ret;

    // only know about ver 1 keys
    if (*(DWORD*)*ppbKey != INTERNAL_MAC_KEY_VERSION)
        goto Ret;

    // strip version tag, shift left
    *pcbKey -= sizeof(DWORD);
    MoveMemory(*ppbKey, *ppbKey + sizeof(DWORD), *pcbKey);

    fRet = TRUE;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return fRet;
}

BOOL FSetInternalMACKey(LPCWSTR szUser, PBYTE pbKey, DWORD cbKey)
{
    BOOL fRet = FALSE;
    HKEY hBaseKey = NULL;
    HKEY hDataKey = NULL;

    DWORD dwCreate;

    // no need to alloc, we assume we know cbKey size (2 deskeys + blocklen pad + dwVersion)
    BYTE rgbTmp[(8*3)+sizeof(DWORD)];

    // ASSUME: two deskeys, each 8 bytes + blocklen pad
    if (cbKey != (8*3))
        goto Ret;

    // tack version on front
    *(DWORD*)rgbTmp = (DWORD)INTERNAL_MAC_KEY_VERSION;
    CopyMemory(rgbTmp + sizeof(DWORD), pbKey, cbKey);

    // Open User Key //
    if (PST_E_OK !=
        GetPSTUserHKEY(
            szUser,
            &hBaseKey,
            NULL))
        goto Ret;

    // Open/Create Data Key //
    if (ERROR_SUCCESS !=
        RegCreateKeyExU(
            hBaseKey,
            REG_DATA_LOC,
            0,
            NULL,                       // address of class string
            0,
            KEY_READ | KEY_WRITE,
            NULL,
            &hDataKey,
            &dwCreate))
        goto Ret;

    if (ERROR_SUCCESS !=
        RegSetValueExU(
            hDataKey,
            REG_USER_INTERNAL_MAC_KEY,
            0,
            REG_BINARY,
            rgbTmp,
            sizeof(rgbTmp) ))
        goto Ret;

    fRet = TRUE;
Ret:
    if (hBaseKey)
        RegCloseKey(hBaseKey);

    if (hDataKey)
        RegCloseKey(hDataKey);

    return fRet;
}

// end global MAC Key storage
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

BOOL
DeleteAllUserData(
    HKEY hKey
    )
{
    BOOL fRestorePrivs = FALSE;
    BOOL fRet = FALSE;

    //
    // enable backup and restore privs on NT to circumvent any security
    // settings.
    //

    if(FIsWinNT()) {
        SetCurrentPrivilege(L"SeRestorePrivilege", TRUE);
        SetCurrentPrivilege(L"SeBackupPrivilege", TRUE);

        fRestorePrivs = TRUE;
    }

    fRet = DeleteUserData( hKey );

    if(fRestorePrivs) {
        SetCurrentPrivilege(L"SeRestorePrivilege", FALSE);
        SetCurrentPrivilege(L"SeBackupPrivilege", FALSE);
    }

    return fRet;
}

BOOL
DeleteUserData(
    HKEY hKey
    )
{
    LONG rc;

    WCHAR szSubKey[MAX_PATH];
    DWORD cchSubKeyLength;
    DWORD dwSubKeyMaxIndex;
    DWORD dwDisposition;

    cchSubKeyLength = sizeof(szSubKey) / sizeof(WCHAR);

    // First, get the number of subkeys, so we can decrement the index,
    // and avoid and re-indexing of the subkeys

    if (ERROR_SUCCESS != RegQueryInfoKeyA(hKey,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &dwSubKeyMaxIndex,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL))
    {
        return FALSE;
    }

    if (dwSubKeyMaxIndex) dwSubKeyMaxIndex--;  // 0 based index, so index = #keys -1


    while((rc=RegEnumKeyExU(
                        hKey,
                        dwSubKeyMaxIndex,
                        szSubKey,
                        &cchSubKeyLength,
                        NULL,
                        NULL,
                        NULL,
                        NULL)
                        ) != ERROR_NO_MORE_ITEMS) { // are we done?

        if(rc == ERROR_SUCCESS)
        {
            HKEY hSubKey;
            LONG lRet;

            lRet = RegCreateKeyExU(
                            hKey,
                            szSubKey,
                            0,
                            NULL,
                            REG_OPTION_BACKUP_RESTORE, // in winnt.h
                            DELETE | KEY_ENUMERATE_SUB_KEYS,
                            NULL,
                            &hSubKey,
                            &dwDisposition
                            );

            if(lRet != ERROR_SUCCESS)
                return FALSE;


            //
            // recurse
            //

            DeleteUserData(hSubKey);
            RegDeleteKeyU(hKey, szSubKey);

            RegCloseKey(hSubKey);
           

            // increment index into the key
            dwSubKeyMaxIndex--;

            // reset buffer size
            cchSubKeyLength = sizeof(szSubKey) / sizeof(WCHAR);

            // Continue the festivities
            continue;
        }
        else
        {
           //
           // note: we need to watch for ERROR_MORE_DATA
           // this indicates we need a bigger szSubKey buffer
           //
            return FALSE;
        }

    } 

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\config.cpp ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This module contains routines to perform configuration data item management
    in the protected store.

Author:

    Scott Field (sfield)    28-Mar-97

--*/

#include <pch.cpp>
#pragma hdrstop

//
// these are temporary until better home is found.
//

extern PST_PROVIDERID g_guidBaseProvider;
extern CALL_STATE g_sDummyCallState;
extern PLIST_ITEM g_psDummyListItem;

BOOL
AllocatePseudoUniqueHandle(
    PST_PROVIDER_HANDLE *phPSTProv
    );

BOOL
FAcquireProvider(
    PST_PROVIDERID*  pProviderID
    );

BOOL
CreateDummyUserContext(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      CALL_STATE *pNewContext
    );

BOOL
DeleteDummyUserContext(
    IN      CALL_STATE *pNewContext
    );

//
// ... end of temporary section.
//


LPVOID
RulesAlloc(
    IN      DWORD cb
    )
{
    return SSAlloc( cb );
}

VOID
RulesFree(
    IN      LPVOID pv
    )
{
    SSFree( pv );
}

BOOL
FGetConfigurationData(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  PST_KEY KeyLocation,
    IN  GUID *pguidSubtype,
    IN  LPCWSTR szItemName,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData
    )
{
    PST_PROVIDER_HANDLE *phNewPSTProv = NULL;
    CALL_STATE          NewContext;
    BOOL                fDummyContext = FALSE;
    BOOL                fSuccess = FALSE;

    HRESULT             hr;

    if(KeyLocation != PST_KEY_CURRENT_USER && KeyLocation != PST_KEY_LOCAL_MACHINE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Hard case is PST_KEY_CURRENT_USER.  Prepare user context for that
    // scenario.
    //

    if(KeyLocation == PST_KEY_CURRENT_USER) {
        phNewPSTProv = (PST_PROVIDER_HANDLE *)&NewContext;

        //
        // hard case: PST_KEY_CURRENT_USER
        //


        fDummyContext = CreateDummyUserContext( hPSTProv, &NewContext );

        if(!fDummyContext)
            goto cleanup;
    } else {

        //
        // PST_KEY_LOCAL_MACHINE : global dummy call state
        //

        phNewPSTProv = (PST_PROVIDER_HANDLE *)&g_sDummyCallState;
    }

    __try {

        //
        // get the system provider (dispatch table)
        //

        PPROV_LIST_ITEM pli = SearchProvListByID(&g_guidBaseProvider);
        GUID guidType =  PST_CONFIGDATA_TYPE_GUID;
        PST_PROMPTINFO sPrompt = {sizeof(PST_PROMPTINFO), 0, 0, L""};

        if( pli == NULL )
            goto cleanup;

        //
        // make call with the new context we setup
        //

        hr = pli->fnList.SPReadItem(
                    phNewPSTProv,
                    KeyLocation,    // target PST_KEY_CURRENT_USER or PST_KEY_LOCAL_MACHINE
                    &guidType,
                    pguidSubtype,
                    szItemName,
                    pcbData,
                    ppbData,
                    &sPrompt,
                    0
                    );

        if( hr == S_OK )
            fSuccess = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // swallow
        fSuccess = FALSE;
    }

cleanup:


    if(fDummyContext) {
        DeleteDummyUserContext( &NewContext );
    }

    return fSuccess;
}

BOOL
FSetConfigurationData(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  PST_KEY KeyLocation,
    IN  GUID *pguidSubtype,
    IN  LPCWSTR szItemName,
    IN  BYTE *pbData,
    IN  DWORD cbData
    )
{
    PST_PROVIDER_HANDLE *phNewPSTProv = NULL;
    CALL_STATE          NewContext;
    BOOL                fDummyContext = FALSE;
    BOOL                fSuccess = FALSE;

    HRESULT             hr;

    if(KeyLocation != PST_KEY_CURRENT_USER && KeyLocation != PST_KEY_LOCAL_MACHINE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Hard case is PST_KEY_CURRENT_USER.  Prepare user context for that
    // scenario.
    //

    if(KeyLocation == PST_KEY_CURRENT_USER) {
        phNewPSTProv = (PST_PROVIDER_HANDLE *)&NewContext;

        //
        // hard case: PST_KEY_CURRENT_USER
        //


        fDummyContext = CreateDummyUserContext( hPSTProv, &NewContext );

        if(!fDummyContext)
            goto cleanup;
    } else {

        //
        // PST_KEY_LOCAL_MACHINE : global dummy call state
        //

        phNewPSTProv = (PST_PROVIDER_HANDLE *)&g_sDummyCallState;
    }

    __try {

        //
        // get the system provider (dispatch table)
        //

        PPROV_LIST_ITEM pli = SearchProvListByID(&g_guidBaseProvider);
        GUID guidType =  PST_CONFIGDATA_TYPE_GUID;
        PST_PROMPTINFO sPrompt = {sizeof(PST_PROMPTINFO), 0, 0, L""};

        if( pli == NULL )
            goto cleanup;

        //
        // make call with the new context we setup
        //

        hr = pli->fnList.SPWriteItem(
                    phNewPSTProv,
                    KeyLocation,    // target PST_KEY_CURRENT_USER or PST_KEY_LOCAL_MACHINE
                    &guidType,
                    pguidSubtype,
                    szItemName,
                    cbData,
                    pbData,
                    &sPrompt,
                    0,
                    0
                    );

        if( hr == S_OK )
            fSuccess = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // swallow
        fSuccess = FALSE;
    }

cleanup:


    if(fDummyContext) {
        DeleteDummyUserContext( &NewContext );
    }

    return fSuccess;
}

BOOL
FInternalCreateType(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    PPST_TYPEINFO pinfoType,
    DWORD dwFlags
    )
{

    PST_PROVIDER_HANDLE *phNewPSTProv = NULL;
    CALL_STATE          NewContext;
    BOOL                fDummyContext = FALSE;
    BOOL                fSuccess = FALSE;

    PST_ACCESSRULESET   Rules;
    HRESULT             hr;

    if(KeyLocation != PST_KEY_CURRENT_USER && KeyLocation != PST_KEY_LOCAL_MACHINE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Hard case is PST_KEY_CURRENT_USER.  Prepare user context for that
    // scenario.
    //

    if(KeyLocation == PST_KEY_CURRENT_USER) {
        phNewPSTProv = (PST_PROVIDER_HANDLE *)&NewContext;

        //
        // hard case: PST_KEY_CURRENT_USER
        //


        fDummyContext = CreateDummyUserContext( phPSTProv, &NewContext );

        if(!fDummyContext)
            goto cleanup;
    } else {

        //
        // PST_KEY_LOCAL_MACHINE : global dummy call state
        //

        phNewPSTProv = (PST_PROVIDER_HANDLE *)&g_sDummyCallState;
    }

    __try {

        //
        // get the system provider (dispatch table)
        //

        PPROV_LIST_ITEM pli = SearchProvListByID(&g_guidBaseProvider);

        if( pli == NULL )
            goto cleanup;

        //
        // make call with the new context we setup
        //

        Rules.cbSize = sizeof( Rules );
        Rules.cRules = 0;
        Rules.rgRules = NULL;

        hr = pli->fnList.SPCreateType(
                    phNewPSTProv,
                    KeyLocation,
                    pguidType,
                    pinfoType,
                    dwFlags
                    );

        if(hr == S_OK || hr == PST_E_TYPE_EXISTS)
            fSuccess = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // swallow
        fSuccess = FALSE;
    }

cleanup:


    if(fDummyContext) {
        DeleteDummyUserContext( &NewContext );
    }

    return fSuccess;
}

BOOL
FInternalCreateSubtype(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    const GUID *pguidSubtype,
    PPST_TYPEINFO pinfoSubtype,
    DWORD dwFlags
    )
/*++

    This routine allows the protected storage server to create a subtype
    within the Microsoft Protected Storage Base Provider.

    The subtype is created with no access ruleset.  The caller should use
    the FInternalWriteAccessRuleset() if an access ruleset needs to be applied
    after the subtype is created.

--*/
{

    PST_PROVIDER_HANDLE *phNewPSTProv = NULL;
    CALL_STATE          NewContext;
    BOOL                fDummyContext = FALSE;
    BOOL                fSuccess = FALSE;

    PST_ACCESSRULESET   Rules;
    HRESULT             hr;

    if(KeyLocation != PST_KEY_CURRENT_USER && KeyLocation != PST_KEY_LOCAL_MACHINE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Hard case is PST_KEY_CURRENT_USER.  Prepare user context for that
    // scenario.
    //

    if(KeyLocation == PST_KEY_CURRENT_USER) {
        phNewPSTProv = (PST_PROVIDER_HANDLE *)&NewContext;

        //
        // hard case: PST_KEY_CURRENT_USER
        //


        fDummyContext = CreateDummyUserContext( phPSTProv, &NewContext );

        if(!fDummyContext)
            goto cleanup;
    } else {

        //
        // PST_KEY_LOCAL_MACHINE : global dummy call state
        //

        phNewPSTProv = (PST_PROVIDER_HANDLE *)&g_sDummyCallState;
    }

    __try {

        //
        // get the system provider (dispatch table)
        //

        PPROV_LIST_ITEM pli = SearchProvListByID(&g_guidBaseProvider);

        if( pli == NULL )
            goto cleanup;

        //
        // make call with the new context we setup
        //

        Rules.cbSize = sizeof( Rules );
        Rules.cRules = 0;
        Rules.rgRules = NULL;

        hr = pli->fnList.SPCreateSubtype(
                    phNewPSTProv,
                    KeyLocation,
                    pguidType,
                    pguidSubtype,
                    pinfoSubtype,
                    &Rules,
                    dwFlags
                    );

        if(hr == S_OK || hr == PST_E_TYPE_EXISTS)
            fSuccess = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // swallow
        fSuccess = FALSE;
    }

cleanup:


    if(fDummyContext) {
        DeleteDummyUserContext( &NewContext );
    }

    return fSuccess;
}


BOOL
FInternalWriteAccessRuleset(
    PST_PROVIDER_HANDLE *phPSTProv,
    PST_KEY KeyLocation,
    const GUID *pguidType,
    const GUID *pguidSubtype,
    PPST_ACCESSRULESET psRules,
    DWORD dwFlags
    )
{
    PST_PROVIDER_HANDLE *phNewPSTProv = NULL;
    CALL_STATE          NewContext;
    BOOL                fDummyContext = FALSE;
    BOOL                fSuccess = FALSE;

    PPST_ACCESSRULESET  NewRules = NULL;

    HRESULT             hr = S_OK;

    if(KeyLocation != PST_KEY_CURRENT_USER && KeyLocation != PST_KEY_LOCAL_MACHINE) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Hard case is PST_KEY_CURRENT_USER.  Prepare user context for that
    // scenario.
    //

    if(KeyLocation == PST_KEY_CURRENT_USER) {
        phNewPSTProv = (PST_PROVIDER_HANDLE *)&NewContext;

        //
        // hard case: PST_KEY_CURRENT_USER
        //


        fDummyContext = CreateDummyUserContext( phPSTProv, &NewContext );

        if(!fDummyContext)
            goto cleanup;
    } else {

        //
        // PST_KEY_LOCAL_MACHINE : global dummy call state
        //

        phNewPSTProv = (PST_PROVIDER_HANDLE *)&g_sDummyCallState;
    }

    __try {

        //
        // get the system provider (dispatch table)
        //

        PPROV_LIST_ITEM pli = SearchProvListByID(&g_guidBaseProvider);

        if( pli == NULL )
            goto cleanup;


        //
        // Need to make rule data contiguous for push across RPC
        //

        DWORD cbRules;

        // get the length of the entire ruleset structure
        if (!GetLengthOfRuleset(psRules, &cbRules))
        {
            hr = PST_E_INVALID_RULESET;
            goto cleanup;
        }

        // allocate space for the rules
        if (NULL == (NewRules = (PST_ACCESSRULESET*)SSAlloc(cbRules)))
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        ZeroMemory(NewRules, cbRules);

        // set up the rules to be output
        if (!MyCopyOfRuleset(psRules, NewRules))
        {
            hr = PST_E_FAIL;
            goto cleanup;
        }

        // make clause data relative
        if(!RulesAbsoluteToRelative(NewRules))
        {
            hr = PST_E_INVALID_RULESET;
            goto cleanup;
        }

        //
        // make call with the new context we setup
        //

        hr = pli->fnList.SPWriteAccessRuleset(
                    phNewPSTProv,
                    KeyLocation,
                    pguidType,
                    pguidSubtype,
                    NewRules,
                    dwFlags
                    );

        if(hr == S_OK || hr == PST_E_TYPE_EXISTS)
            fSuccess = TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        // swallow
        fSuccess = FALSE;
    }

cleanup:


    if(fDummyContext) {
        DeleteDummyUserContext( &NewContext );
    }

    if(NewRules)
    {
        FreeClauseDataRelative( NewRules );
        SSFree( NewRules );
    }

    if(!fSuccess && hr != S_OK)
        SetLastError((DWORD) hr);

    return fSuccess;
}

BOOL
CreateDummyUserContext(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      CALL_STATE *pNewContext
    )
{
    //
    // hard case: PST_KEY_CURRENT_USER
    //

    PLIST_ITEM pliCaller; // list item associated with user calling this function
    PLIST_ITEM pliNew;    // newly allocated list item
    DWORD cbName;

    CALL_STATE *CallerContext = (CALL_STATE *)hPSTProv;

    BOOL bSuccess = FALSE;

    if (NULL == (pliCaller = SearchListByHandleT(hPSTProv)))
        return FALSE;


    //
    // allocate memory for new list item, and initially populate
    // it with information from the calling list item.
    //

    pliNew = (PLIST_ITEM)SSAlloc(sizeof(LIST_ITEM));
    if(pliNew == NULL)
        return FALSE;

    CopyMemory(pliNew, pliCaller, sizeof(LIST_ITEM));
    pliNew->szProcessName = NULL;
    pliNew->szCallerUsername = NULL;


    //
    // now, overwrite with some server related elements to
    // make it look like the server is accessing the data as the calling
    // user.
    //

    if(!AllocatePseudoUniqueHandle( &(pliNew->hPSTProv) ))
        goto cleanup;

    CopyMemory(&(pliNew->ProviderID), &g_guidBaseProvider, sizeof(PST_PROVIDERID));
    pliNew->hProcess = g_psDummyListItem->hProcess;
    pliNew->hThread = g_psDummyListItem->hThread;
    pliNew->dwProcessId = g_psDummyListItem->dwProcessId;

    //
    // allocate new copy of process name string because it get separately freed
    // by DelItemFromList
    //
    // TODO: consider not allocating copies of szProcessName and szCallerUsername
    // and just set these member to NULL prior to calling DelItemFromList()
    //

    cbName = (lstrlenW(g_psDummyListItem->szProcessName) + 1) * sizeof(WCHAR);
    pliNew->szProcessName = (LPWSTR)SSAlloc(cbName);
    if(pliNew->szProcessName == NULL)
        goto cleanup;
    CopyMemory(pliNew->szProcessName, g_psDummyListItem->szProcessName, cbName);

    //
    // user name associated with caller.
    //

    cbName = (lstrlenW(pliCaller->szCallerUsername) + 1) * sizeof(WCHAR);
    pliNew->szCallerUsername = (LPWSTR)SSAlloc(cbName);
    if(pliNew->szCallerUsername == NULL)
        goto cleanup;
    CopyMemory(pliNew->szCallerUsername, pliCaller->szCallerUsername, cbName);


    //
    // build new PST_PROVIDER_HANDLE, which is really a CALL_CONTEXT in disguise
    //

    ZeroMemory( pNewContext, sizeof(CALL_STATE) );

    CopyMemory(&(pNewContext->hPSTProv), &(pliNew->hPSTProv), sizeof(PST_PROVIDER_HANDLE));
    pNewContext->hBinding = CallerContext->hBinding;

    //
    // pickup stuff from server context
    //

    pNewContext->hThread = pliNew->hThread;
    pNewContext->hProcess = pliNew->hProcess;
    pNewContext->dwProcessId = pliNew->dwProcessId;


    //
    // add to list
    //

    AddItemToList(pliNew);

    //
    // make sure ref count is raised - caller in PST_KEY_CURRENT_USER
    // case is responsible for decrementing when finished.
    //

    bSuccess = FAcquireProvider(&g_guidBaseProvider);

cleanup:

    if(!bSuccess && pliNew) {

        //
        // these should only be non-NULL if we allocated storage that
        // was not freed as a result of the call to DelItemFromList()
        //

        if(pliNew->szProcessName)
            SSFree(pliNew->szProcessName);

        if(pliNew->szCallerUsername)
            SSFree(pliNew->szCallerUsername);

        SSFree(pliNew);
    }

    return bSuccess;
}

BOOL
DeleteDummyUserContext(
    IN      CALL_STATE *pNewContext
    )
{
    PST_PROVIDER_HANDLE *phProv = (PST_PROVIDER_HANDLE *)pNewContext;

    DelItemFromList( phProv );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\prov\storage.h ===
// Per-user data items

// export for one-time initialization
DWORD GetPSTUserHKEY(
        LPCWSTR szUser,         // in
        HKEY* phUserKey,        // out
        BOOL* pfExisted);       // out

// types
DWORD BPCreateType(            // fills in PST_GUIDNAME's sz if NULL
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,    // in
        PST_TYPEINFO* pinfoType);   // in

DWORD BPDeleteType(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType);     // in

DWORD BPEnumTypes(
        LPCWSTR  szUser,        // in
        DWORD   dwIndex,        // in
        GUID*   pguidType);     // out

DWORD BPGetTypeName(           // fills in PST_GUIDNAME's sz
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        LPWSTR* ppszType);      // out


// subtypes
DWORD BPCreateSubtype(         // fills in PST_GUIDNAME's sz if NULL
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        PST_TYPEINFO* pinfoSubtype);    // in

DWORD BPDeleteSubtype(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype);  // in

DWORD BPEnumSubtypes(
        LPCWSTR  szUser,        // in
        DWORD   dwIndex,        // in
        const GUID*   pguidType,      // in
        GUID*   pguidSubtype);  // out

DWORD BPGetSubtypeName(        // fills in PST_GUIDNAME's sz
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPWSTR* ppszSubtype);   // out


// items
DWORD BPCreateItem(            
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName);   // in

DWORD BPDeleteItem(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName);   // in

DWORD BPEnumItems(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        DWORD   dwIndex,        // in
        LPWSTR* ppszName);      // out


#if 0

// rulesets
DWORD BPGetSubtypeRuleset(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        PST_ACCESSRULESET* psRules); // out

DWORD BPSetSubtypeRuleset(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        PST_ACCESSRULESET *sRules); // in

DWORD BPGetItemRuleset(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        PST_ACCESSRULESET* psRules); // out

DWORD BPSetItemRuleset(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        PST_ACCESSRULESET *sRules); // in

#endif

      
// secured data 
BOOL FBPGetSecuredItemData(
        LPCWSTR  szUser,        // in
        LPCWSTR  szMasterKey,   // in
		BYTE    rgbPwd[],	    // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        PBYTE*  ppbData,        // out
        DWORD*  pcbData);       // out

BOOL FBPSetSecuredItemData(   
        LPCWSTR  szUser,        // in
        LPCWSTR  szMasterKey,   // in
		BYTE    rgbPwd[],		// in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        PBYTE   pbData,         // in
        DWORD   cbData);        // in

// insecure data 
DWORD BPGetInsecureItemData(
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in
        LPCWSTR  szItemName,    // in
        PBYTE*  ppbData,        // out
        DWORD*  pcbData);       // out

DWORD BPSetInsecureItemData(
        LPCWSTR szUser,         // in
        const GUID*     pguidType,      // in
        const GUID*     pguidSubtype,   // in
        LPCWSTR szItemName,     // in
        PBYTE   pbData,         // in
        DWORD   cbData);        // in


// Item Confirmation 
DWORD BPGetItemConfirm(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in           
        LPCWSTR  szItemName,    // in
        DWORD*  pdwConfirm,     // out
        LPWSTR* pszMK);         // out

DWORD BPSetItemConfirm(
        PST_PROVIDER_HANDLE* phPSTProv, // in
        LPCWSTR  szUser,        // in
        const GUID*   pguidType,      // in
        const GUID*   pguidSubtype,   // in           
        LPCWSTR  szItemName,    // in
        DWORD   dwConfirm,      // in
        LPCWSTR  szMK);         // in


// Master Keys
BOOL BPMasterKeyExists(
        LPCWSTR  szUser,        // in
        LPWSTR   szMasterKey);  // in

DWORD BPEnumMasterKeys(
        LPCWSTR  szUser,        // in
        DWORD   dwIndex,        // in
        LPWSTR* ppszMasterKey); // out

DWORD BPGetMasterKeys(
        LPCWSTR  szUser,        // in
        LPCWSTR  rgszMasterKeys[],  // in 
        DWORD*  pcbMasterKeys,  // in, out
        BOOL    fUserFilter);   // in

// security state
BOOL FBPGetSecurityState(
        LPCWSTR  szUser,        // in
        LPCWSTR  szMK,          // in
        BYTE    rgbSalt[],      // out
        DWORD   cbSalt,         // in
        BYTE    rgbConfirm[],   // out
        DWORD   cbConfirm,      // in
        PBYTE*  ppbMK,          // out
        DWORD*  pcbMK);         // out

BOOL FBPGetSecurityStateFromHKEY(
            HKEY    hMKKey,
            BYTE    rgbSalt[],
            DWORD   cbSalt,
            BYTE    rgbConfirm[],
            DWORD   cbConfirm,
            PBYTE*  ppbMK,
            DWORD*  pcbMK);

BOOL FBPSetSecurityState(
        LPCWSTR  szUser,        // in
        LPCWSTR  szMK,          // in
        BYTE    rgbSalt[],      // in
        DWORD   cbSalt,         // in
        BYTE    rgbConfirm[],   // in
        DWORD   cbConfirm,      // in
        PBYTE   pbMK,           // in
        DWORD   cbMK);          // in


// MAC keys
BOOL FGetInternalMACKey(
        LPCWSTR szUser,         // in
        PBYTE* ppbKey,          // out
        DWORD* pcbKey);         // out

BOOL FSetInternalMACKey(
        LPCWSTR szUser,         // in
        PBYTE pbKey,            // in
        DWORD cbKey);           // in

// nuke existing user data
BOOL
DeleteAllUserData(
    HKEY hKey
    );

BOOL
DeleteUserData(
    HKEY hKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\dynalink.h ===
#ifndef __DYNALINK_H__
#define __DYNALINK_H__

#ifdef __cplusplus
extern "C" {
#endif

BOOL
InitDynamicInterfaces(
	VOID
	);



#ifdef __cplusplus
}
#endif


#endif // __DYNALINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\dynalink.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    dynalink.c

Abstract:

    This module contains routines to perform dynamic linking to interfaces
    during protected storage server startup.  This is required because some
    interfaces do not exist on both target platforms, or, due to setup/install
    requirements where some of these .dlls may not be on the system when
    we are run the first time to do install initialization.

Author:

    Scott Field (sfield)    03-Feb-97

--*/

#include <windows.h>

#include "dynalink.h"

#if 1
BOOL
InitDynamicInterfaces(
    VOID
    )
{
    return TRUE;
}
#else
#include "unicode.h"

// WinNT specific
extern FARPROC pNtQueryInformationProcess;

extern FARPROC _NtOpenEvent;
FARPROC _NtWaitForSingleObject = NULL;
FARPROC _ZwClose = NULL;
//FARPROC _DbgPrint = NULL;
FARPROC _ZwRequestWaitReplyPort = NULL;
FARPROC _RtlInitUnicodeString = NULL;
FARPROC _NtClose = NULL;
//FARPROC _strncpy = NULL;
FARPROC _ZwConnectPort = NULL;
FARPROC _ZwFreeVirtualMemory = NULL;
FARPROC _RtlInitString = NULL;

FARPROC _ZwWaitForSingleObject = NULL;
FARPROC _ZwOpenEvent = NULL;


#ifdef WIN95_LEGACY
// Win95 specific
// kernel.dll
extern FARPROC pCreateToolhelp32Snapshot;
extern FARPROC pModule32First;
extern FARPROC pModule32Next;
extern FARPROC pProcess32First;
extern FARPROC pProcess32Next;
extern FARPROC _WNetGetUserA;
#endif  // WIN95_LEGACY

//
// common
// authenticode related (wintrust.dll, crypt32.dll)
//
extern BOOL g_bAuthenticodeInitialized; // authenticode available for us to use?

BOOL
InitDynamicInterfaces(
    VOID
    )
{
    UINT uPriorErrorMode;
    BOOL bSuccess = FALSE;

    //
    // insure no popups are seen about missing files,
    // entry points, etc.
    //

    uPriorErrorMode = SetErrorMode(
                        SEM_FAILCRITICALERRORS |
                        SEM_NOGPFAULTERRORBOX |
                        SEM_NOOPENFILEERRORBOX
                        );

    if(FIsWinNT()) {

        //
        // get WinNT specific interfaces
        //

        HINSTANCE hNtDll;

        // we LoadLibrary ntdll.dll even though it is likely to be in our
        // address space - we don't want to assume it is so because it may not be.
        hNtDll = LoadLibraryW(L"ntdll.dll");
        if(hNtDll == NULL) goto cleanup;

        if((pNtQueryInformationProcess = GetProcAddress(hNtDll, "NtQueryInformationProcess")) == NULL)
            goto cleanup;

        // interfaces required for lsadll.lib
        if((_NtWaitForSingleObject = GetProcAddress(hNtDll, "NtWaitForSingleObject")) == NULL)
            goto cleanup;

        if((_ZwClose = GetProcAddress(hNtDll, "ZwClose")) == NULL)
            goto cleanup;

//      if((_DbgPrint = GetProcAddress(hNtDll, "DbgPrint")) == NULL)
//          goto cleanup;

        if((_ZwRequestWaitReplyPort = GetProcAddress(hNtDll, "ZwRequestWaitReplyPort")) == NULL)
            goto cleanup;

        if((_RtlInitUnicodeString = GetProcAddress(hNtDll, "RtlInitUnicodeString")) == NULL)
            goto cleanup;

        if((_NtOpenEvent = GetProcAddress(hNtDll, "NtOpenEvent")) == NULL)
            goto cleanup;

        if((_NtClose = GetProcAddress(hNtDll, "NtClose")) == NULL)
            goto cleanup;

//      if((_strncpy = GetProcAddress(hNtDll, "strncpy")) == NULL)
//          goto cleanup;

        if((_ZwConnectPort = GetProcAddress(hNtDll, "ZwConnectPort")) == NULL)
            goto cleanup;

        if((_ZwFreeVirtualMemory = GetProcAddress(hNtDll, "ZwFreeVirtualMemory")) == NULL)
            goto cleanup;

        if((_RtlInitString = GetProcAddress(hNtDll, "RtlInitString")) == NULL)
            goto cleanup;

        if((_ZwWaitForSingleObject = GetProcAddress(hNtDll, "ZwWaitForSingleObject")) == NULL)
            goto cleanup;

        if((_ZwOpenEvent = GetProcAddress(hNtDll, "ZwOpenEvent")) == NULL)
            goto cleanup;

        bSuccess = TRUE;
    }
#ifdef WIN95_LEGACY
    else {

        //
        // get Win95 specific interfaces
        //

        HMODULE hKernel = NULL;
        HMODULE hMpr = NULL;

        hKernel = GetModuleHandle("KERNEL32.DLL");

        pCreateToolhelp32Snapshot = GetProcAddress(
            hKernel,
            "CreateToolhelp32Snapshot");

        if(pCreateToolhelp32Snapshot == NULL)
            goto cleanup;

        pModule32First  = GetProcAddress(
            hKernel,
            "Module32First");

        if(pModule32First == NULL)
            goto cleanup;

        pModule32Next   = GetProcAddress(
            hKernel,
            "Module32Next");

        if(pModule32Next == NULL)
            goto cleanup;

        pProcess32First  = GetProcAddress(
            hKernel,
            "Process32First");

        if(pProcess32First == NULL)
            goto cleanup;

        pProcess32Next  = GetProcAddress(
            hKernel,
            "Process32Next");

        if(pProcess32Next == NULL)
            goto cleanup;

        hMpr = LoadLibraryA("MPR.DLL");

        if(hMpr == NULL)
            goto cleanup;

        _WNetGetUserA = GetProcAddress(
            hMpr,
            "WNetGetUserA"
            );

        if(_WNetGetUserA == NULL)
            goto cleanup;

        bSuccess = TRUE;
    }
#endif  // WIN95_LEGACY

cleanup:

    //
    // restore previous error mode.
    //

    SetErrorMode(uPriorErrorMode);

    return bSuccess;
}

ULONG
NTAPI
NtWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    return (ULONG)_NtWaitForSingleObject(Handle, Alertable, Timeout);
}


ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    )
{
    return 0;
}


VOID
NTAPI
RtlInitUnicodeString(
    PVOID DestinationString,
    PCWSTR SourceString
    )
{
    _RtlInitUnicodeString(DestinationString, SourceString);
}

VOID
NTAPI
RtlInitString(
    PVOID DestinationString,
    PVOID SourceString
    )
{
    _RtlInitString(DestinationString, SourceString);
}

ULONG
NTAPI
NtOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes
    )
{
    return (ULONG)_NtOpenEvent(EventHandle, DesiredAccess, ObjectAttributes);
}

ULONG
NTAPI
NtClose(
    IN HANDLE Handle
    )
{

    return (ULONG)_NtClose( Handle );
}


ULONG
NTAPI
ZwClose(
    IN HANDLE Handle
    )
{
    return (ULONG)_ZwClose(Handle);
}

ULONG
NTAPI
ZwRequestWaitReplyPort(
    IN HANDLE PortHandle,
    IN PVOID RequestMessage,
    OUT PVOID ReplyMessage
    )
{
    return (ULONG)_ZwRequestWaitReplyPort(
                PortHandle,
                RequestMessage,
                ReplyMessage
                );

}

ULONG
NTAPI
ZwConnectPort(
    OUT PHANDLE PortHandle,
    IN PVOID PortName,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN OUT PVOID ClientView OPTIONAL,
    OUT PVOID ServerView OPTIONAL,
    OUT PULONG MaxMessageLength OPTIONAL,
    IN OUT PVOID ConnectionInformation OPTIONAL,
    IN OUT PULONG ConnectionInformationLength OPTIONAL
    )
{
    return (ULONG)_ZwConnectPort(
                PortHandle,
                PortName,
                SecurityQos,
                ClientView,
                ServerView,
                MaxMessageLength,
                ConnectionInformation,
                ConnectionInformationLength
                );
}

ULONG
NTAPI
ZwFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PULONG RegionSize,
    IN ULONG FreeType
    )
{
    return (ULONG)_ZwFreeVirtualMemory(
                ProcessHandle,
                BaseAddress,
                RegionSize,
                FreeType
                );
}



ULONG
NTAPI
ZwWaitForSingleObject(
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    return (ULONG)_ZwWaitForSingleObject(Handle, Alertable, Timeout);
}

ULONG
NTAPI
ZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PVOID ObjectAttributes
    )
{
    return (ULONG)_ZwOpenEvent(EventHandle, DesiredAccess, ObjectAttributes);
}

VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    )
{
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\dispif.cpp ===
#include <pch.cpp>
#pragma hdrstop


#define MAX_PW_LEN  160
#define MAX_STRING_RSC_SIZE 512

#define WSZ_NULLSTRING L""

extern HINSTANCE    g_hInst;

extern "C" {

typedef DWORD (WINAPI *WNETGETUSERA)(
    LPCSTR lpName,
    LPSTR lpUserName,
    LPDWORD lpnLength
    );

extern WNETGETUSERA _WNetGetUserA;

}




typedef struct _GETWINPW_DIALOGARGS
{
    LPWSTR* ppszPW;
    PST_PROVIDER_HANDLE     *phPSTProv;

} GETWINPW_DIALOGARGS, *PGETWINPW_DIALOGARGS;


INT_PTR CALLBACK DialogGetWindowsPassword(
    HWND hDlg,  // handle to dialog box
    UINT message,   // message
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
)
{
    int iRet = IDCANCEL; // assume cancel
    BOOL bSuccess = FALSE; // assume error

    WCHAR szMessage[MAX_STRING_RSC_SIZE];
    WCHAR szDlgTitle[MAX_STRING_RSC_SIZE];

    switch (message)
    {
        case WM_INITDIALOG:
        {
            UINT uResString;

            SetLastError( 0 ); // as per win32 documentation
            if(SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)lParam) == 0) {
                if(GetLastError() != ERROR_SUCCESS) {
                    EndDialog(hDlg, IDCANCEL);
                    return FALSE;
                }
            }

            if(FIsWinNT()) {
                uResString = IDS_GET_WINDOWS_PASSWORD_NT;
            } else {
                uResString = IDS_GET_WINDOWS_PASSWORD_95;
            }

            LoadStringU(
                g_hInst,
                uResString,
                szMessage,
                MAX_STRING_RSC_SIZE);

            SetWindowTextU(GetDlgItem(hDlg, IDC_MESSAGE), szMessage);

            return TRUE;
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                PGETWINPW_DIALOGARGS pDlgArgs;
                LPWSTR* ppszPW;
                WCHAR sz1[MAX_PW_LEN];

                DWORD cch1 = 0;
                BOOL bPasswordVerified;

                pDlgArgs = (PGETWINPW_DIALOGARGS)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                if(pDlgArgs == 0) break; // TODO:   bail out

                ppszPW = pDlgArgs->ppszPW;
                *ppszPW = NULL;

                // must impersonate client.  If it fails, bail.
                if(!FImpersonateClient(pDlgArgs->phPSTProv))
                    break;

                cch1 = GetDlgItemTextU(
                    hDlg,
                    IDC_EDIT1,
                    sz1,
                    MAX_PW_LEN);

                // push an hourglass to the screen
                HCURSOR curOld;
                curOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                // validate  password
                bPasswordVerified = VerifyWindowsPassword(sz1);

                // put old cursor back
                SetCursor(curOld);

                FRevertToSelf(pDlgArgs->phPSTProv);

                // Clear any queued user keyboard entry turds before returning
                MSG sMsg;
                while (PeekMessage(&sMsg, hDlg, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
                    ;

                if(!bPasswordVerified)
                {
                    szMessage[0] = L'\0';
                    LoadStringU(
                        g_hInst,
                        IDS_PASSWORD_NOVERIFY,
                        szMessage,
                        MAX_STRING_RSC_SIZE);

                    szDlgTitle[0] = L'\0';
                    LoadStringU(
                        g_hInst,
                        IDS_PASSWORD_ERROR_DLGTITLE,
                        szDlgTitle,
                        MAX_STRING_RSC_SIZE);

                    // this W implemented in both Win95 & NT!
                    MessageBoxW(
                            NULL, // hDlg,
                            szMessage,
                            szDlgTitle,
                            MB_OK|MB_ICONEXCLAMATION|MB_SERVICE_NOTIFICATION);

                    SetWindowTextU(GetDlgItem(hDlg, IDC_EDIT1), WSZ_NULLSTRING);

                    goto cleanup;
                }

                // now bite it: save

                SS_ASSERT(ppszPW != NULL);
                *ppszPW = (LPWSTR)SSAlloc( (cch1+1) * sizeof(WCHAR) );
                if(*ppszPW == NULL) goto cleanup;

                //
                // sfield: defer copying strings until we know everything succeeded.
                // this way, we don't have to zero these buffers if some
                // allocs + copies succeed, and others fail.
                //
                wcscpy(*ppszPW, sz1);

                iRet = IDOK;
                bSuccess = TRUE;

cleanup:

                if(cch1) RtlSecureZeroMemory(sz1, cch1 * sizeof(WCHAR));

                if(!bSuccess)
                {
                    if(*ppszPW)
                    {
                        SSFree(*ppszPW);
                        *ppszPW = NULL;
                    }

                    return FALSE;
                }

                break; // things went OK, just bail to EndDialog

            } // IDOK

            if( LOWORD(wParam) == IDCANCEL )
                break;

        default:
            return FALSE;
    }

    EndDialog(hDlg, iRet);

    return bSuccess;
}


BOOL
FGetWindowsPassword(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    IN  BYTE                rgbPasswordDerivedBytes[],
    IN  DWORD               cbPasswordDerivedBytes
    )
{
    BOOL fRet;
    LPWSTR pszPW = NULL;


    if ((rgbPasswordDerivedBytes == NULL) || (cbPasswordDerivedBytes < A_SHA_DIGEST_LEN))
        return FALSE;


    //
    // the general event flow for this routine:
    //
    // 1. Search cache for credentials.  WinNT requires impersonating around search.
    // 2. If search fails on Win95, try to get the password directly from MPR
    // 3. If search fails on WinNT, check for special cases like LocalSystem and NETWORK
    //     Allow Local System by building fixed credential.
    //     Disallow NETWORK because no credentials exist (return FAILURE).
    // 4. If we still don't have credentials, prompt user via UI.
    //


    //
    // we must be impersonating around this call !!!
    //

    if(!FImpersonateClient(hPSTProv))
        return FALSE;

    fRet = GetPasswordNT(rgbPasswordDerivedBytes);

    FRevertToSelf(hPSTProv);


    // if either GetPassword routine fails
    if (!fRet)
    {
        INT_PTR iRet;
        DWORD cbPassword;
        BOOL fCachePassword = TRUE; // cache the results by default
        BOOL fSpecialCase;

        if(!FImpersonateClient(hPSTProv))
            goto Ret;

        //
        // WinNT: check for some special cases, namely, if we are runninng
        // under Local System or Network credentials.
        //

        fRet = GetSpecialCasePasswordNT(
                        rgbPasswordDerivedBytes,    // derived bits when fSpecialCase == TRUE
                        &fSpecialCase               // legal special case encountered?
                        );

        FRevertToSelf(hPSTProv);

        //
        // if the query failed bail out, since we encountered an illegal
        // or inapproriate condition.
        //

        if(!fRet)
            goto Ret;

        //
        // now, set fRet to the result of the special case test.
        // so, if we encountered an allowed special case, we have an
        // validly filled rgbPasswordDerivedBytes buffer.  If we didn't
        // encounter a legal special case, we continue on our quest for
        // a password.
        //

        fRet = fSpecialCase;


        //
        // re-evaluate fRet for the special hack for Win95 above.
        //

        if(!fRet) {

            // return a validated password
            GETWINPW_DIALOGARGS DialogArgs = {&pszPW, hPSTProv};
            iRet = DialogBoxParam(
                    g_hInst,
                    MAKEINTRESOURCE(IDD_GET_WINDOWS_PASSWORD),
                    NULL,
                    DialogGetWindowsPassword,
                    (LPARAM)&DialogArgs);

            if(iRet != IDOK) goto Ret;

            if (pszPW == NULL)
                goto Ret;

            //
            // everything went fine, now derive the password bits!
            //
            
            cbPassword = WSZ_BYTECOUNT(pszPW) - sizeof(WCHAR) ;

            // hash pwd, copy out
            A_SHA_CTX   sSHAHash;
            A_SHAInit(&sSHAHash);
            A_SHAUpdate(&sSHAHash, (BYTE *) pszPW, cbPassword);
            RtlSecureZeroMemory(pszPW, cbPassword); // sfield: zero the password

            // Finish off the hash
            A_SHAFinal(&sSHAHash, rgbPasswordDerivedBytes);
        }

        //
        // now, update the password cache
        //
        if(fCachePassword) 
        {
            LUID AuthenticationId;

            // get user LUID

            //
            // we must be impersonating around this call !!!
            //

            if(!FImpersonateClient(hPSTProv))
                goto Ret;

            if(!GetThreadAuthenticationId(
                    GetCurrentThread(),
                    &AuthenticationId))
            {
                FRevertToSelf(hPSTProv);
                goto Ret;
            }

            if (!SetPasswordNT(
                    &AuthenticationId,
                    rgbPasswordDerivedBytes))
            {
                FRevertToSelf(hPSTProv);
                goto Ret;
            }

            FRevertToSelf(hPSTProv);

        } // fCachePassword
    }

    fRet = TRUE;
Ret:
    if (pszPW)
        SSFree(pszPW);

    return fRet;
}


BOOL
FIsACLSatisfied(
    IN          PST_PROVIDER_HANDLE     *hPSTProv,
    IN          PST_ACCESSRULESET       *psRules,
    IN          DWORD                   dwAccess,
    IN  OUT     LPVOID      // coming soon: fill a status structure with data about access attempt
    )
{
    if ((psRules->cRules == 0)||(psRules->rgRules == NULL))
        return TRUE;

    //
    // parent exe name.  cached through loop
    //

    LPWSTR pszParentExeName = NULL;

    //
    // direct caller image.  cached through loop
    //

    LPWSTR pszDirectCaller = NULL;

    //
    // base address of direct call module
    //

    DWORD_PTR BaseAddressDirect;

    //
    // module that is the subject of analysis
    //

    LPWSTR szHashTarget;


    //
    // search for a list of terms that are completely satisfied
    //

    for(DWORD cRule=0; cRule<psRules->cRules; cRule++)
    {
        // check only those rules that govern the right access
        //
        // loop while we still have dwAccess modes to check
        //
        if (0 == (psRules->rgRules[cRule].AccessModeFlags & dwAccess))
            continue;

        // evaluate the ith term
        PPST_ACCESSCLAUSE pClause;

        // walk down list
        for(DWORD cClause=0; cClause<psRules->rgRules[cRule].cClauses; cClause++)
        {
            pClause = &psRules->rgRules[cRule].rgClauses[cClause];

            // for each term, make sure ALL ENTRIES are satisfied

            // TODO: what to do if clause data not self relative?
            // not possible at this point in time, but it may come up later
            //

            switch(pClause->ClauseType & ~PST_SELF_RELATIVE_CLAUSE)
            {
            // for each type, may use the pClause->pbClauseData
            case PST_SECURITY_DESCRIPTOR:
                {
                    // passed test
                    continue;   // next clause
                }
            case PST_AUTHENTICODE:
                {
                    // passed test
                    continue;       // next clause
                }
            case PST_BINARY_CHECK:
                {
                    // passed test
                    continue;       // next clause
                }

            default:
                // unknown type in ACL: this chain failed, goto next chain
                goto NextRule;    // next rule
            }
        }

        // YES! ALL clauses evaluated and OK

        // turn off the bits that got us into this clause chain
        dwAccess &= ~ psRules->rgRules[cRule].AccessModeFlags;

NextRule:

        continue;
    }

//Cleanup:

    // cleanup
    if (pszParentExeName)
        SSFree(pszParentExeName);

    if(pszDirectCaller)
        SSFree(pszDirectCaller);

    return (dwAccess == 0);
}


BOOL FGetUser(
        PST_PROVIDER_HANDLE *hPSTProv,
        LPWSTR* ppszUser)
{
    return FGetUserName(hPSTProv, ppszUser);
}

BOOL
FGetCallerName(
    IN  PST_PROVIDER_HANDLE *hPSTProv,
    OUT LPWSTR* ppszCallerName,
    OUT DWORD_PTR *lpdwBaseAddress
    )
{
    return FGetParentFileName(hPSTProv, ppszCallerName, lpdwBaseAddress);
}

BOOL
FGetServerParam(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      DWORD  dwParam,
    IN      LPVOID pData,
    IN  OUT DWORD *pcbData
    )
{
    //
    // check for the server get param that asks for private dispatch interfaces
    //

    if( dwParam == SS_SERVERPARAM_CALLBACKS &&
        *pcbData >= sizeof( PRIVATE_CALLBACKS )) {

        PRIVATE_CALLBACKS *PrivateCallbacks = (PRIVATE_CALLBACKS *)pData;

        PrivateCallbacks->cbSize = sizeof( PRIVATE_CALLBACKS );
        PrivateCallbacks->pfnFGetWindowsPassword = FGetWindowsPassword;
        PrivateCallbacks->pfnAuthenticodeInitPolicy = NULL;
        PrivateCallbacks->pfnAuthenticodeFinalPolicy = NULL;

        *pcbData = sizeof( PRIVATE_CALLBACKS );

        return TRUE;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
FSetServerParam(
    IN      PST_PROVIDER_HANDLE *hPSTProv,
    IN      DWORD  dwParam,
    IN      LPVOID pData,
    IN      DWORD pcbData
    )
{

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\lnklist.cpp ===
#include <pch.cpp>
#pragma hdrstop

static DWORD            g_dwHandleListUseCount;
static PPROV_LIST_ITEM  g_pProvList = NULL;         // ptr to loaded providers


extern HANDLE hServerStopEvent;
extern DWORD g_dwLastHandleIssued;

// sacp.cpp
BOOL        InitMyProviderHandle();
void        UnInitMyProviderHandle();
PROV_LIST_ITEM  g_liProv = {0}; // global list item for base prov.


BOOL ListConstruct()
{
    // create internal provider handle

    if(!InitMyProviderHandle())
        return FALSE;


    return TRUE;
}

void ListTeardown()
{

    // free internal provider handle
    UnInitMyProviderHandle();

}


// internal: prov search by name
PPROV_LIST_ITEM SearchProvListByID(const PST_PROVIDERID* pProviderID)
{
    SS_ASSERT(pProviderID != NULL);

    static const GUID guidBaseProvider = MS_BASE_PSTPROVIDER_ID;

    if( memcmp( &guidBaseProvider, pProviderID, sizeof(guidBaseProvider) ) != 0 )
        return NULL;

    return &g_liProv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\lnklist.h ===
#ifndef __LNKLIST_H__
#define __LNKLIST_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "pstypes.h"
#include "dispif.h"
#include "provif.h"
#include <sha.h>

// a structure with a bunch of funcs
typedef struct FuncList
{
    SPACQUIRECONTEXT*       SPAcquireContext;
    SPRELEASECONTEXT*       SPReleaseContext;
    SPGETPROVINFO*          SPGetProvInfo;
    SPGETTYPEINFO*          SPGetTypeInfo;
    SPGETSUBTYPEINFO*       SPGetSubtypeInfo;
    SPGETPROVPARAM*         SPGetProvParam;
    SPSETPROVPARAM*         SPSetProvParam;
    SPENUMTYPES*            SPEnumTypes;
    SPENUMSUBTYPES*         SPEnumSubtypes;
    SPENUMITEMS*            SPEnumItems;
    SPCREATETYPE*           SPCreateType;
    SPDELETETYPE*           SPDeleteType;
    SPCREATESUBTYPE*        SPCreateSubtype;
    SPDELETESUBTYPE*        SPDeleteSubtype;
    SPREADITEM*             SPReadItem;
    SPWRITEITEM*            SPWriteItem;
    SPOPENITEM*             SPOpenItem;
    SPCLOSEITEM*            SPCloseItem;
    SPDELETEITEM*           SPDeleteItem;
    SPWRITEACCESSRULESET*   SPWriteAccessRuleset;
    SPREADACCESSRULESET*    SPReadAccessRuleset;

    FPASSWORDCHANGENOTIFY*  FPasswordChangeNotify;

} FUNCLIST, *PFUNCLIST;


// provider list element
typedef struct _PROV_LISTITEM
{
    // set by creator before adding to list
    PST_PROVIDERINFO        sProviderInfo;

    HINSTANCE               hInst;
    FUNCLIST                fnList;

} PROV_LIST_ITEM, *PPROV_LIST_ITEM;

//
// milliseconds stale image cache elements live
//

#ifdef DBG
#define IMAGE_TTL (60*1000)     // 1 minute in debug
#else
#define IMAGE_TTL (60*1000*60)  // 60 minutes retail
#endif // DBG

typedef struct _NT_HASHED_PASSWORD {
    LUID LogonID;
    BYTE HashedPassword[A_SHA_DIGEST_LEN];
    DWORD dwLastAccess;
    struct _NT_HASHED_PASSWORD *Next;
} NT_HASHED_PASSWORD, *PNT_HASHED_PASSWORD, *LPNT_HASHED_PASSWORD;


// construct, destruct lists
BOOL ListConstruct();
void ListTeardown();


//////////////////////
// Item list

// search
PPROV_LIST_ITEM  SearchProvListByID(const PST_PROVIDERID* pProvID);

#ifdef __cplusplus
}
#endif

#endif // __LNKLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\pch.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pch.cpp

Abstract:

    pch header files


Author:

    petesk 2/2/2000

Revision History:

    

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>
#include <rpc.h>
// crypto headers

#include <sha.h>
#include <des.h>

#include "pstypes.h"
#include "pstrpc.h"
#include "pstprv.h"
#include "pstdef.h"
#include "crtem.h"
#include "unicode.h"
#include "unicode5.h"

#include "secmisc.h"
#include "filemisc.h"
#include "primitiv.h"
#include "pmacros.h"
#include "debug.h"
#include "guidcnvt.h"



#include "acl.h"
#include "lnklist.h"
#include "winpw.h"
#include "module.h"
#include "resource.h"
#include "dispif.h"
#include "rules.h"


#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\module.c ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    module.c

Abstract:

    This module contains routines to perform module related query activities
    in the protected store.

Author:

    Scott Field (sfield)    27-Nov-96

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <tlhelp32.h>

#include "module.h"
#include "filemisc.h"

#include "unicode.h"
#include "debug.h"

#include "pstypes.h"
#include "pstprv.h"


//
// common function typedefs + pointers
//

typedef BOOL (WINAPI *SYMLOADMODULE)(
    IN HANDLE hProcess,
    IN HANDLE hFile,
    IN LPSTR ImageName,
    IN LPSTR ModuleName,
    IN DWORD_PTR BaseOfDll,
    IN DWORD SizeOfDll
    );

SYMLOADMODULE _SymLoadModule                    = NULL;

//
// winnt specific function typedefs + pointers
//

typedef NTSTATUS (NTAPI *NTQUERYPROCESS)(
    HANDLE ProcessHandle,
    PROCESSINFOCLASS ProcessInformationClass,
    PVOID ProcessInformation,
    ULONG ProcessInformationLength,
    PULONG ReturnLength OPTIONAL
    );


#ifdef WIN95_LEGACY

//
// win95 specific function typedefs + pointers.
//

typedef BOOL (WINAPI *MODULEWALK)(
    HANDLE hSnapshot,
    LPMODULEENTRY32 lpme
    );

typedef BOOL (WINAPI *THREADWALK)(
    HANDLE hSnapshot,
    LPTHREADENTRY32 lpte
    );

typedef BOOL (WINAPI *PROCESSWALK)(
    HANDLE hSnapshot,
    LPPROCESSENTRY32 lppe
    );

typedef HANDLE (WINAPI *CREATESNAPSHOT)(
    DWORD dwFlags,
    DWORD th32ProcessID
    );

CREATESNAPSHOT pCreateToolhelp32Snapshot = NULL;
MODULEWALK  pModule32First = NULL;
MODULEWALK  pModule32Next = NULL;
PROCESSWALK pProcess32First = NULL;
PROCESSWALK pProcess32Next = NULL;

#endif  // WIN95_LEGACY

extern FARPROC _ImageNtHeader;


//
// private function prototypes
//

VOID
FixupBrokenLoaderPath(
    IN      LPWSTR szFilePath
    );

BOOL
GetFileNameFromBaseAddrNT(
    IN  HANDLE  hProcess,
    IN  DWORD   dwProcessId,
    IN  DWORD_PTR   dwBaseAddr,
    OUT LPWSTR  *lpszDirectCaller
    );


#ifdef WIN95_LEGACY

BOOL
GetFileNameFromBaseAddr95(
    IN  HANDLE  hProcess,
    IN  DWORD   dwProcessId,
    IN  DWORD_PTR   dwBaseAddr,
    OUT LPWSTR  *lpszDirectCaller
    );

#endif  // WIN95_LEGACY

VOID
FixupBrokenLoaderPath(
    IN      LPWSTR szFilePath
    )
{
    if( !FIsWinNT() || szFilePath == NULL )
        return;


    //
    // sfield, 28-Oct-97 (NTbug 118803 filed against MarkL)
    // for WinNT, the loader data structures are broken:
    // a path len extension prefix of \??\ is used instead of \\?\
    //

    if( szFilePath[0] == L'\\' &&
        szFilePath[1] == L'?' &&
        szFilePath[2] == L'?' &&
        szFilePath[3] == L'\\' ) {

        szFilePath[1] = L'\\';

    }

}


#ifdef WIN95_LEGACY

BOOL
GetFileNameFromBaseAddr95(
    IN  HANDLE  hProcess,
    IN  DWORD   dwProcessId,
    IN  DWORD_PTR   dwBaseAddr,
    OUT LPWSTR  *lpszDirectCaller
    )
{
    HANDLE hSnapshot;
    MODULEENTRY32 me32;
    BOOL bSuccess = FALSE;
    BOOL bFound = FALSE;

    *lpszDirectCaller = NULL;

    hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwProcessId);
    if(hSnapshot == INVALID_HANDLE_VALUE)
        return FALSE;

    me32.dwSize = sizeof(me32);

    bSuccess = pModule32First(hSnapshot, &me32);

    while(bSuccess) {
        LPCSTR szFileName;
        DWORD cchModule;

        if((DWORD_PTR)me32.modBaseAddr != dwBaseAddr) {
            me32.dwSize = sizeof(me32);
            bSuccess = pModule32Next(hSnapshot, &me32);
            continue;
        }

        cchModule = lstrlenA(me32.szExePath) + 1;

        *lpszDirectCaller = (LPWSTR)SSAlloc(cchModule * sizeof(WCHAR));
        if(*lpszDirectCaller == NULL)
            break;

        if(MultiByteToWideChar(
            0,
            0,
            me32.szExePath,
            cchModule,
            *lpszDirectCaller,
            cchModule
            ) != 0) {

            bFound = TRUE;
        }

        break;
    }

    CloseHandle(hSnapshot);

    if(!bFound) {
        if(*lpszDirectCaller) {
            SSFree(*lpszDirectCaller);
            *lpszDirectCaller = NULL;
        }
    }

    return bFound;
}

BOOL
GetProcessIdFromPath95(
    IN      LPCSTR  szProcessPath,
    IN OUT  DWORD   *dwProcessId
    )
{
    LPCSTR szProcessName;
    HANDLE hSnapshot;
    PROCESSENTRY32 pe32;
    DWORD dwLastError = 0;
    BOOL bSuccess;
    BOOL bFound = FALSE; // assume no match found

    if(!GetFileNameFromPathA(szProcessPath, &szProcessName))
        return FALSE;

    hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(hSnapshot == INVALID_HANDLE_VALUE)
        return FALSE;

    pe32.dwSize = sizeof(pe32);

    bSuccess = pProcess32First(hSnapshot, &pe32);

    while(bSuccess) {
        LPCSTR szFileName;

        GetFileNameFromPathA(pe32.szExeFile, &szFileName);

        if(lstrcmpiA( szFileName, szProcessName ) == 0) {
            *dwProcessId = pe32.th32ProcessID;
            bFound = TRUE;
            break;
        }

        pe32.dwSize = sizeof(pe32);
        bSuccess = pProcess32Next(hSnapshot, &pe32);
    }

    CloseHandle(hSnapshot);

    if(!bFound && dwLastError) {
        SetLastError(dwLastError);
    }

    return bFound;
}


BOOL
GetBaseAddressModule95(
    IN      DWORD   dwProcessId,
    IN      LPCSTR  szImagePath,
    IN  OUT DWORD_PTR   *dwBaseAddress,
    IN  OUT DWORD   *dwUseCount
    )
{
    LPSTR szImageName;
    HANDLE hSnapshot;
    MODULEENTRY32 me32;
    BOOL bSuccess = FALSE;
    BOOL bFound = FALSE;

    if(!GetFileNameFromPathA(szImagePath, &szImageName))
        return FALSE;

    hSnapshot = pCreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwProcessId);
    if(hSnapshot == INVALID_HANDLE_VALUE)
        return FALSE;

    me32.dwSize = sizeof(me32);

    bSuccess = pModule32First(hSnapshot, &me32);

    while(bSuccess) {
        LPCSTR szFileName;

        GetFileNameFromPathA(me32.szExePath, &szFileName);

        if(lstrcmpiA( szFileName, szImageName ) == 0) {
            *dwBaseAddress = (DWORD_PTR)me32.modBaseAddr;
            *dwUseCount = me32.ProccntUsage;
            bFound = TRUE;
            break;
        }

        me32.dwSize = sizeof(me32);
        bSuccess = pModule32Next(hSnapshot, &me32);
    }

    CloseHandle(hSnapshot);

    return bFound;
}

#endif  // WIN95_LEGACY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\sacp.cpp ===
#include <pch.cpp>
#pragma hdrstop

BOOL
InitCallState(
    CALL_STATE *CallState,              // result call state
    PST_CALL_CONTEXT *CallerContext,    // client caller context
    handle_t h                          // binding handle
    );

BOOL
FAcquireProvider(
    const PST_PROVIDERID*  pProviderID
    );


extern HANDLE hServerStopEvent;
extern PROV_LIST_ITEM g_liProv;
BOOL g_fBaseInitialized = FALSE;

static LPCWSTR g_szBaseDLL = L"psbase.dll";
const PST_PROVIDERID g_guidBaseProvider = MS_BASE_PSTPROVIDER_ID;

DWORD g_dwLastHandleIssued = 0;

BOOL InitMyProviderHandle()
{
    // load the base provider!
    return FAcquireProvider(&g_guidBaseProvider);
}

void UnInitMyProviderHandle()
{
    PROV_LIST_ITEM *pliProv = &g_liProv;

    if (pliProv->hInst)
        FreeLibrary(pliProv->hInst);

    if (pliProv->sProviderInfo.szProviderName)
        SSFree(pliProv->sProviderInfo.szProviderName);

    ZeroMemory(pliProv, sizeof(PROV_LIST_ITEM));
    g_fBaseInitialized = FALSE;

}



BOOL FAcquireProvider(
    const PST_PROVIDERID*  pProviderID
    )
{
    PPROV_LIST_ITEM pliProv = &g_liProv;

    WCHAR szFullPath[ 256 ];
    DWORD cchFullPath = sizeof(szFullPath) / sizeof(WCHAR);
    HANDLE hFile;

    SS_ASSERT(pProviderID);

    if (0 != memcmp(pProviderID, &g_guidBaseProvider, sizeof(PST_PROVIDERID))) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if( g_fBaseInitialized )
        return TRUE;

    if(!FindAndOpenFile( g_szBaseDLL, szFullPath, cchFullPath, &hFile ))
        return FALSE;

    CloseHandle( hFile );

    pliProv->hInst = LoadLibraryU( szFullPath );

    if(pliProv->hInst == NULL)
        goto Ret;

    // everything loaded correctly

    // init callbacks
    {
        SPPROVIDERINITIALIZE* pfnProvInit;
        if (NULL == (pfnProvInit = (SPPROVIDERINITIALIZE*) GetProcAddress(pliProv->hInst, "SPProviderInitialize")))
            goto Ret;

        DISPIF_CALLBACKS sCallbacks;

        sCallbacks.cbSize = sizeof(DISPIF_CALLBACKS);

        sCallbacks.pfnFIsACLSatisfied = FIsACLSatisfied;

        sCallbacks.pfnFGetUser = FGetUser;
        sCallbacks.pfnFGetCallerName = FGetCallerName;

        sCallbacks.pfnFImpersonateClient = FImpersonateClient;
        sCallbacks.pfnFRevertToSelf = FRevertToSelf;

        sCallbacks.pfnFGetServerParam = FGetServerParam;
        sCallbacks.pfnFSetServerParam = FSetServerParam;

        // register the callbacks I expose
        if (PST_E_OK != pfnProvInit( &sCallbacks ))
            goto Ret;
    }

    // everything okay - load list element pfns
    if (NULL == (pliProv->fnList.SPAcquireContext   = (SPACQUIRECONTEXT*)  GetProcAddress(pliProv->hInst, "SPAcquireContext")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPReleaseContext   = (SPRELEASECONTEXT*)  GetProcAddress(pliProv->hInst, "SPReleaseContext")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPGetProvInfo   = (SPGETPROVINFO*)  GetProcAddress(pliProv->hInst, "SPGetProvInfo")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPGetTypeInfo   = (SPGETTYPEINFO*)  GetProcAddress(pliProv->hInst, "SPGetTypeInfo")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPGetSubtypeInfo   = (SPGETSUBTYPEINFO*)  GetProcAddress(pliProv->hInst, "SPGetSubtypeInfo")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPGetProvParam   = (SPGETPROVPARAM*)  GetProcAddress(pliProv->hInst, "SPGetProvParam")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPSetProvParam   = (SPSETPROVPARAM*)  GetProcAddress(pliProv->hInst, "SPSetProvParam")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPEnumTypes     = (SPENUMTYPES*)    GetProcAddress(pliProv->hInst, "SPEnumTypes")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPEnumSubtypes  = (SPENUMSUBTYPES*)    GetProcAddress(pliProv->hInst, "SPEnumSubtypes")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPEnumItems     = (SPENUMITEMS*)    GetProcAddress(pliProv->hInst, "SPEnumItems")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPCreateType    = (SPCREATETYPE*)   GetProcAddress(pliProv->hInst, "SPCreateType")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPDeleteType   = (SPDELETETYPE*)  GetProcAddress(pliProv->hInst, "SPDeleteType")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPCreateSubtype = (SPCREATESUBTYPE*)   GetProcAddress(pliProv->hInst, "SPCreateSubtype")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPDeleteSubtype = (SPDELETESUBTYPE*)  GetProcAddress(pliProv->hInst, "SPDeleteSubtype")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPDeleteItem    = (SPDELETEITEM*)   GetProcAddress(pliProv->hInst, "SPDeleteItem")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPReadItem      = (SPREADITEM*)     GetProcAddress(pliProv->hInst, "SPReadItem")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPWriteItem     = (SPWRITEITEM*)    GetProcAddress(pliProv->hInst, "SPWriteItem")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPOpenItem      = (SPOPENITEM*)     GetProcAddress(pliProv->hInst, "SPOpenItem")))
        goto Ret;
    if (NULL == (pliProv->fnList.SPCloseItem     = (SPCLOSEITEM*)    GetProcAddress(pliProv->hInst, "SPCloseItem")))
        goto Ret;

    // side door interface
    if (NULL == (pliProv->fnList.FPasswordChangeNotify = (FPASSWORDCHANGENOTIFY*)GetProcAddress(pliProv->hInst, "FPasswordChangeNotify")))
        goto Ret;

    // fill in the provider info
    {
        PPST_PROVIDERINFO pReportedProviderInfo;

        if (RPC_S_OK !=
            pliProv->fnList.SPGetProvInfo(
                &pReportedProviderInfo,
                0))
            goto Ret;

        // They better report the friendly name they're registered as having
        if (0 != memcmp(&pReportedProviderInfo->ID, pProviderID, sizeof(PST_PROVIDERID)))
            goto Ret;

        CopyMemory(&pliProv->sProviderInfo, pReportedProviderInfo, sizeof(PST_PROVIDERINFO));

        // don't free the indirections -- pliProv->sProviderInfo owns them
        SSFree(pReportedProviderInfo);
    }

    g_fBaseInitialized = TRUE;

Ret:

    return g_fBaseInitialized;
}


/////////////////////////////////////////////////////////////////////////
// Dispatcher-only routines

HRESULT s_SSPStoreEnumProviders(
    /* [in] */ handle_t         h,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [out] */ PPST_PROVIDERINFO*   ppPSTInfo,
    /* [in] */ DWORD            dwIndex,
    /* [in] */ DWORD            dwFlags)
{
    HRESULT hr;
    PST_PROVIDERID ProvID;

    __try
    {
        PPROV_LIST_ITEM pli;

        if (dwIndex != 0)
        {
            hr = ERROR_NO_MORE_ITEMS;
            goto Ret;
        }
        else
        {
            // base provider is index 0; not in list
            CopyMemory(&ProvID, &g_guidBaseProvider, sizeof(PST_PROVIDERID));
        }

        // now we have the Provider ID
        *ppPSTInfo = (PST_PROVIDERINFO*)SSAlloc(sizeof(PST_PROVIDERINFO));
        if( *ppPSTInfo == NULL ) {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }

        ZeroMemory(*ppPSTInfo, sizeof(PST_PROVIDERINFO));

        // retrieve from list
        if (NULL == (pli = SearchProvListByID(&ProvID)))
        {
            hr = PST_E_PROV_DLL_NOT_FOUND;
            goto RefuseLoad;
        }

        // copy direct members
        CopyMemory(*ppPSTInfo, &pli->sProviderInfo, sizeof(PST_PROVIDERINFO));

        // copy indirects
        (*ppPSTInfo)->szProviderName = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(pli->sProviderInfo.szProviderName));

        if( (*ppPSTInfo)->szProviderName == NULL ) {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }

        wcscpy((*ppPSTInfo)->szProviderName, pli->sProviderInfo.szProviderName);

        hr = PST_E_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = GetExceptionCode();
    }

Ret:

    if(hr != PST_E_OK)
    {
        if( *ppPSTInfo ) {

            if( (*ppPSTInfo)->szProviderName )
                SSFree( (*ppPSTInfo)->szProviderName );

            SSFree( *ppPSTInfo );
            *ppPSTInfo = NULL;
        }
    }

    return hr;


RefuseLoad:
    // copy dummy provider info
    (*ppPSTInfo)->cbSize = sizeof(PST_PROVIDERINFO);
    CopyMemory(&(*ppPSTInfo)->ID, &ProvID, sizeof(GUID));

    // notify that we couldn't touch this provider (in a graceful way)
    (*ppPSTInfo)->Capabilities = PST_PC_NOT_AVAILABLE;

    // eat error code here -- they can see it during acquire ctxt if they want
    return PST_E_OK;
}

BOOL
AllocatePseudoUniqueHandle(
    PST_PROVIDER_HANDLE *phPSTProv
    )
/*++

    This is here because:
    AllocateLocallyUniqueId() is not present on Win95.
    UuidCreate() requires too much baggage and memory to store handle.

--*/
{
    static LONG HighPart;


    //
    // GetTickCount() yields ~49 days of unique handles
    //

    phPSTProv->LowPart = GetTickCount(); // sneaky, huh?

    //
    // interlocked increment thread-safe insurance of no collision at same time
    // ~4 billion values
    //

    phPSTProv->HighPart = InterlockedIncrement(&HighPart);

    //
    // after ~49 days, we may collide with old handles
    // this is here just to be correct, but slim likelihood of no reboot
    // within 49 days on most machines.
    //

    //
    // update time of last handle issue.
    //

    g_dwLastHandleIssued = GetTickCount();

    return TRUE;
}


BOOL
InitCallState(
    CALL_STATE *CallState,              // result call state
    PST_CALL_CONTEXT *CallerContext,    // client caller context
    handle_t h                          // binding handle
    )
{
    HANDLE hThread;
    DWORD dwProcessId;
    BOOL bSuccess = FALSE;

    if(CallerContext == NULL)
        return FALSE;

    ZeroMemory( CallState, sizeof(CALL_STATE) );

    CallState->hBinding = h;
    CallState->dwProcessId = CallerContext->Address;
    CallState->hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, CallState->dwProcessId );
    if( CallState->hProcess == NULL )
        return FALSE;

    if(DuplicateHandle(
                CallState->hProcess,
                (HANDLE)CallerContext->Handle, // source handle
                GetCurrentProcess(),
                &hThread,
                THREAD_ALL_ACCESS, // tone down later
                FALSE,
                0)) {

        CallState->hThread = hThread;
        bSuccess = TRUE;
    }

    if(!bSuccess) {
        if( CallState->hProcess )
            CloseHandle( CallState->hProcess );
    }

    return bSuccess;
}

BOOL
DeleteCallState(
    CALL_STATE *CallState
    )
{
    BOOL bSuccess;

    __try {

        if(CallState->hThread != NULL)
            CloseHandle(CallState->hThread);
        if(CallState->hProcess)
            CloseHandle(CallState->hProcess);

        memset(CallState, 0, sizeof(CALL_STATE));

        bSuccess = TRUE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        bSuccess = FALSE;
    }

    return bSuccess;
}

HRESULT s_SSAcquireContext(
    /* [in] */ handle_t         h,
    /* [in] */ PPST_PROVIDERID  pProviderID,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ DWORD            pidCaller,
    /* [out] */ PST_PROVIDER_HANDLE* phPSTProv,
    /* [in] */ DWORD_PTR        lpReserved,
    /* [in] */ DWORD            dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    CALL_STATE CallState;
    BOOL bDelItemFromList = FALSE; // free list item on failure?
    BOOL bCallState = FALSE;
    HRESULT hr = PST_E_FAIL;

    //
    // lpReserved must currently be NULL.
    //

    if(lpReserved != 0)
        return ERROR_INVALID_PARAMETER;

    __try
    {
        if(!AllocatePseudoUniqueHandle(phPSTProv))
            return PST_E_FAIL;

        bCallState = InitCallState(&CallState, &CallerContext, h);

        if(!bCallState) {
            hr = PST_E_INVALID_HANDLE;
            goto cleanup;
        }

        // now allow SPAcquireContext to be called: look up interface
        // (call state already initialized)
        if (NULL == (pliProv = SearchProvListByID(pProviderID)))
        {
            hr = PST_E_INVALID_HANDLE;
            goto cleanup;
        }

        hr = pliProv->fnList.SPAcquireContext(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

cleanup:

    if(bCallState)
        DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSReleaseContext(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ DWORD            dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPReleaseContext(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

// interface to communicate passwords from external sources
// such as credential managers.
// this is a currently a private interface and is likely to stay that way

HRESULT s_SSPasswordInterface(
    /* [in] */                      handle_t    h,
    /* [in] */                      DWORD       dwParam,
    /* [in] */                      DWORD       cbData,
    /* [in][size_is(cbData)] */     BYTE*       pbData)
{
    __try {
        PLUID pLogonID;
        PBYTE pHashedUsername;
        PBYTE pHashedPassword;

        switch(dwParam) {

        case PASSWORD_LOGON_NT:
        {
            if(cbData == A_SHA_DIGEST_LEN + sizeof(LUID)) {

                pLogonID = (PLUID)pbData;
                pHashedPassword = (PBYTE)pbData + sizeof(LUID);

                SetPasswordNT(pLogonID, pHashedPassword);

                return PST_E_OK;
            }
        }

#ifdef WIN95_LEGACY

        //
        // legacy case-sensitive password material for Win95
        //

        case PASSWORD_LOGON_LEGACY_95:
        {
            if(cbData == A_SHA_DIGEST_LEN + A_SHA_DIGEST_LEN) {

                // for legacy logon notification, just flush Win95 password.
                SetPassword95(NULL, NULL);
                return PST_E_OK;
            }
        }

        //
        // case-insensitive password material for Win95
        //

        case PASSWORD_LOGON_95:
        {
            if(cbData == A_SHA_DIGEST_LEN + A_SHA_DIGEST_LEN) {
                pHashedUsername = pbData;
                pHashedPassword = pbData + A_SHA_DIGEST_LEN;

                SetPassword95(pHashedUsername, pHashedPassword);
                return PST_E_OK;
            }
        }

        case PASSWORD_LOGOFF_95:
        {
            HRESULT hr = ERROR_INVALID_PARAMETER;

            //
            // scrub existing password material on logoff
            //

            if(cbData == 0) {
                SetPassword95(NULL, NULL);
                hr = PST_E_OK;
            }

            //
            // shutdown server (us) at logoff on Win95.
            //

            PulseEvent(hServerStopEvent);

            return hr;
        }

#endif  // WIN95_LEGACY

        default:
            return ERROR_INVALID_PARAMETER;

        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        return PST_E_UNKNOWN_EXCEPTION;
    }
}



/////////////////////////////////////////////////////////////////////////
// Wrapper functions destined for provider

HRESULT s_SSGetProvInfo(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [out] */ PPST_PROVIDERINFO*   ppPSTInfo,
    /* [in] */ DWORD            dwFlags)
{
    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        return (pliProv->fnList.SPGetProvInfo(
                            ppPSTInfo,
                            dwFlags));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        return PST_E_UNKNOWN_EXCEPTION;
    }
}

HRESULT     s_SSGetTypeInfo(
    /* [in] */ handle_t        h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY         Key,
    /* [in] */ const GUID*     pguidType,
    /* [in] */ PPST_TYPEINFO   *ppinfoType,
    /* [in] */ DWORD           dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPGetTypeInfo(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            ppinfoType,
                            dwFlags);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT     s_SSGetSubtypeInfo(
    /* [in] */ handle_t        h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY         Key,
    /* [in] */ const GUID*     pguidType,
    /* [in] */ const GUID*     pguidSubtype,
    /* [in] */ PPST_TYPEINFO   *ppinfoSubtype,
    /* [in] */ DWORD           dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPGetSubtypeInfo(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            ppinfoSubtype,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT     s_SSGetProvParam(
    /* [in] */  handle_t        h,
    /* [in] */  PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */  PST_CALL_CONTEXT CallerContext,
    /* [in] */  DWORD           dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */
                BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */  DWORD           dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPGetProvParam(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            dwParam,
                            pcbData,
                            ppbData,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT     s_SSSetProvParam(
    /* [in] */  handle_t        h,
    /* [in] */  PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */  PST_CALL_CONTEXT CallerContext,
    /* [in] */  DWORD           dwParam,
    /* [in] */  DWORD           cbData,
    /* [in] */  BYTE*           pbData,
    /* [in] */  DWORD           dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPSetProvParam(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            dwParam,
                            cbData,
                            pbData,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}


HRESULT s_SSEnumTypes(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [out] */GUID*            pguidType,
    /* [in] */ DWORD            dwIndex,
    /* [in] */ DWORD            dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPEnumTypes(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            dwIndex,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSEnumSubtypes(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [out] */ GUID __RPC_FAR *pguidSubtype,
    /* [in] */ DWORD            dwIndex,
    /* [in] */ DWORD            dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPEnumSubtypes(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            dwIndex,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSEnumItems(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [out] */ LPWSTR __RPC_FAR *ppszItemName,
    /* [in] */ DWORD            dwIndex,
    /* [in] */ DWORD            dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPEnumItems(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            ppszItemName,
                            dwIndex,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSCreateType(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID*      pguidType,
    /* [in] */ PPST_TYPEINFO    pinfoType,
    /* [in] */ DWORD            dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPCreateType(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pinfoType,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSCreateSubtype(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID*      pguidType,
    /* [in] */ const GUID*      pguidSubtype,
    /* [in] */ PPST_TYPEINFO    pinfoSubtype,
    /* [in] */ PPST_ACCESSRULESET psRules,
    /* [in] */ DWORD            dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    CALL_STATE CallState;
    HRESULT hr;

    __try
     {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPCreateSubtype(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            pinfoSubtype,
                            psRules,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT     s_SSDeleteType(
    /* [in] */  handle_t        h,
    /* [in] */  PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */  PST_CALL_CONTEXT CallerContext,
    /* [in] */  PST_KEY         Key,
    /* [in] */  const GUID*     pguidType,
    /* [in] */  DWORD           dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    PPST_TYPEINFO   ppinfoType = NULL;
    CALL_STATE      CallState;
    HRESULT         hr;
    HRESULT         hrTypeInfo = E_FAIL;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPDeleteType(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT     s_SSDeleteSubtype(
    /* [in] */  handle_t        h,
    /* [in] */  PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */  PST_CALL_CONTEXT CallerContext,
    /* [in] */  PST_KEY         Key,
    /* [in] */  const GUID*     pguidType,
    /* [in] */  const GUID*     pguidSubtype,
    /* [in] */  DWORD           dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    PPST_TYPEINFO   ppinfoSubtype = NULL;
    CALL_STATE      CallState;
    HRESULT         hr;
    HRESULT         hrSubtypeInfo = E_FAIL;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPDeleteSubtype(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSDeleteItem(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ LPCWSTR          szItemName,
    /* [in] */ PPST_PROMPTINFO  psPrompt,
    /* [in] */ DWORD            dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    PPST_TYPEINFO   ppinfoType = NULL;
    PPST_TYPEINFO   ppinfoSubtype = NULL;
    CALL_STATE CallState;
    HRESULT hr;
    HRESULT         hrTypeInfo = E_FAIL;
    HRESULT         hrSubtypeInfo = E_FAIL;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPDeleteItem(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            szItemName,
                            psPrompt,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSReadItem(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ LPCWSTR          szItemName,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO  psPrompt,
    /* [in] */ DWORD            dwFlags)
{
    PPROV_LIST_ITEM pliProv;
    PPST_TYPEINFO   ppinfoType = NULL;
    PPST_TYPEINFO   ppinfoSubtype = NULL;
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPReadItem(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            szItemName,
                            pcbData,
                            ppbData,
                            psPrompt,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSWriteItem(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ LPCWSTR          szItemName,
    /* [in] */ DWORD            cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO  psPrompt,
    /* [in] */ DWORD            dwDefaultConfirmationStyle,
    /* [in] */ DWORD            dwFlags)
{
    PPST_TYPEINFO   ppinfoType = NULL;
    PPST_TYPEINFO   ppinfoSubtype = NULL;
    PPROV_LIST_ITEM pliProv;
    CALL_STATE      CallState;
    HRESULT         hr;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPWriteItem(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            szItemName,
                            cbData,
                            pbData,
                            psPrompt,
                            dwDefaultConfirmationStyle,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}


HRESULT s_SSReadAccessRuleset(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [out] */ PPST_ACCESSRULESET *ppsRules,
    /* [in] */ DWORD            dwFlags)
{
    return ERROR_NOT_SUPPORTED;
}

HRESULT s_SSWriteAccessRuleset(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ PPST_ACCESSRULESET psRules,
    /* [in] */ DWORD            dwFlags)
{
    return ERROR_NOT_SUPPORTED;
}

HRESULT s_SSOpenItem(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ LPCWSTR          szItemName,
    /* [in] */ PST_ACCESSMODE   ModeFlags,
    /* [in] */ PPST_PROMPTINFO  psPrompt,
    /* [in] */ DWORD            dwFlags)
{
    PPST_TYPEINFO   ppinfoType = NULL;
    PPST_TYPEINFO   ppinfoSubtype = NULL;
    PPROV_LIST_ITEM pliProv;
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPOpenItem(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            szItemName,
                            ModeFlags,
                            psPrompt,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}

HRESULT s_SSCloseItem(
    /* [in] */ handle_t         h,
    /* [in] */ PST_PROVIDER_HANDLE hPSTProv,
    /* [in] */ PST_CALL_CONTEXT CallerContext,
    /* [in] */ PST_KEY          Key,
    /* [in] */ const GUID __RPC_FAR *pguidType,
    /* [in] */ const GUID __RPC_FAR *pguidSubtype,
    /* [in] */ LPCWSTR          szItemName,
    /* [in] */ DWORD            dwFlags)
{
    CALL_STATE CallState;
    HRESULT hr;

    __try
    {
        PPROV_LIST_ITEM pliProv;
        if (NULL == (pliProv = SearchProvListByID(&g_guidBaseProvider)))
            return PST_E_INVALID_HANDLE;

        if(!InitCallState(&CallState, &CallerContext, h))
            return PST_E_INVALID_HANDLE;

        hr = pliProv->fnList.SPCloseItem(
                            (PST_PROVIDER_HANDLE *)&CallState,
                            Key,
                            pguidType,
                            pguidSubtype,
                            szItemName,
                            dwFlags);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError(GetExceptionCode());
        hr = PST_E_UNKNOWN_EXCEPTION;
    }

    DeleteCallState(&CallState);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\module.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    module.h

Abstract:

    This module contains routines to perform module related query activities
    in the protected store.

Author:

    Scott Field (sfield)    27-Nov-96

--*/

#ifndef __MODULE_H__
#define __MODULE_H__

#ifdef __cplusplus
extern "C" {
#endif


BOOL
GetProcessPath(
    IN      HANDLE hProcess,
    IN      DWORD dwProcessId,
    IN      LPWSTR ProcessName,
    IN  OUT DWORD *cchProcessName,
    IN  OUT DWORD_PTR *lpdwBaseAddress
    );

BOOL
EnumRemoteProcessModules(
    IN  HANDLE hProcess,
    IN  DWORD dwProcessId,
    OUT DWORD_PTR *lpdwBaseAddrClient
    );

BOOL
GetFileNameFromBaseAddr(
    IN  HANDLE  hProcess,
    IN  DWORD   dwProcessId,
    IN  DWORD_PTR   dwBaseAddr,
    OUT LPWSTR  *lpszDirectCaller
    );

#ifdef WIN95_LEGACY

BOOL
GetProcessIdFromPath95(
    IN      LPCSTR  szProcessPath,
    IN OUT  DWORD   *dwProcessId
    );

BOOL
GetBaseAddressModule95(
    IN      DWORD   dwProcessId,
    IN      LPCSTR  szImagePath,
    IN  OUT DWORD_PTR   *dwBaseAddress,
    IN  OUT DWORD   *dwUseCount
    );

#endif  // WIN95_LEGACY

#ifdef __cplusplus
}
#endif


#endif // __MODULE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\service.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.c
//
//  PURPOSE:  Implements functions required by all services
//            and takes into account dumbed-down win95 services
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    PSTOREServiceMain(DWORD dwArgc, LPWSTR *lpszArgv);
//    WinNTDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//  MODIFIED: Matt Thomlinson
//            Scott Field
//


#include <pch.cpp>
#pragma hdrstop

#include <svcs.h>
#include "service.h"

// this event is signalled when the
// service should end
//
HANDLE  hServerStopEvent = NULL;

//
// this event is used to allow external code to determine if we are initialized
// and running.  Currently, this is only used by the WinNT and Win95 credential
// managers to prevent logon delays when the service is not available.
//

HANDLE  hServiceStarted = NULL;

PACL    pDaclInitEvent = NULL;


extern DWORD GlobalSecurityMask;
extern BOOL g_bAudit;


//
// waitable thread pool handle.
//

HANDLE hRegisteredWait = NULL;


VOID
TeardownServer(
    DWORD dwLastError
    );

VOID
NTAPI
TerminationNotify(
    PVOID Context,
    BOOLEAN TimerOrWaitFired
    );


#define RTN_OK                  0   // no errors
#define RTN_USAGE               1   // usage error (invalid commandline)
#define RTN_ERROR_INIT          2   // error during service initialization
#define RTN_ERROR_INSTALL       13  // error during -install or -remove
#define RTN_ERROR_INSTALL_SIG   14  // error installing signature(s)
#define RTN_ERROR_INSTALL_START 15  // could not start service during install
#define RTN_ERROR_INSTALL_SHEXT 16  // error installing shell extension

//
// global module handle used to reference resources contained in this module.
//

HINSTANCE   g_hInst = NULL;


// internal variables
static SERVICE_STATUS   ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;


// internal function prototypes
void WINAPI service_ctrl(DWORD dwCtrlCode);
void WINAPI PSTOREServiceMain(DWORD dwArgc, LPWSTR *lpszArgv);

DWORD
WINAPI
Start(
    LPVOID lpV
    );


BOOL
WINAPI
DllMain(
    HMODULE hInst,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    if( dwReason == DLL_PROCESS_ATTACH ) {
        g_hInst = hInst;
        DisableThreadLibraryCalls(hInst);
    }

    return TRUE;
}


VOID
WINAPI
ServiceEntry(
    DWORD NumArgs,
    LPWSTR *ArgsArray,
    PVOID LmsvcsGlobalData,
    HANDLE SvcRefHandle
    )
{
    Start( NULL );
}


DWORD
WINAPI
Start(
    LPVOID lpV
    )
{
    BOOL fIsNT = FIsWinNT();
    int iRet;


    //
    // surpress dialog boxes generated by missing files, etc.
    //

    SetErrorMode(SEM_NOOPENFILEERRORBOX);

    SERVICE_TABLE_ENTRYW dispatchTable[] =
    {
        { SZSERVICENAME, (LPSERVICE_MAIN_FUNCTIONW)PSTOREServiceMain },
        { NULL, NULL }
    };

#ifdef WIN95_LEGACY

    if (!fIsNT)
        goto dispatch95;

#endif  // WIN95_LEGACY

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher

    if(!FIsWinNT5()) {
        if (!StartServiceCtrlDispatcherW(dispatchTable))
            AddToMessageLog(L"StartServiceCtrlDispatcher failed.");
    } else {
        PSTOREServiceMain( 0, NULL );
    }

    return RTN_OK;

#ifdef WIN95_LEGACY

dispatch95:


    //
    // Win95 doesn't support services, except as pseudo-.exe files
    //

    HMODULE hKernel = GetModuleHandleA("kernel32.dll");
    if (NULL == hKernel)
    {
        AddToMessageLog(L"RegisterServiceProcess module handle failed");
        return RTN_ERROR_INIT;
    }

    // inline typedef: COOL!
    typedef DWORD REGISTERSERVICEPROCESS(
        DWORD dwProcessId,
        DWORD dwServiceType);

    REGISTERSERVICEPROCESS* pfnRegSvcProc = NULL;

    // Make sure Win95 Logoff won't stop our .exe
    if (NULL == (pfnRegSvcProc = (REGISTERSERVICEPROCESS*)GetProcAddress(hKernel, "RegisterServiceProcess")))
    {
        AddToMessageLog(L"RegisterServiceProcess failed");
        return RTN_ERROR_INIT;
    }

    pfnRegSvcProc(GetCurrentProcessId(), TRUE);  // register this process ID as a service process

    //
    // call re-entry point and return with result of it.
    //

    iRet = ServiceStart(0, 0);

    if(iRet != ERROR_SUCCESS)
        AddToMessageLog(L"ServiceStart error!");

    return iRet;

#endif  // WIN95_LEGACY

}

//
//  FUNCTION: PSTOREServiceMain
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI PSTOREServiceMain(DWORD dwArgc, LPWSTR * /*lpszArgv*/)
{
    DWORD dwLastError = ERROR_SUCCESS;

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandlerW( SZSERVICENAME, service_ctrl);

    if (!sshStatusHandle)
        return;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //

    if (!ReportStatusToSCMgr(
                    SERVICE_START_PENDING, // service state
                    NO_ERROR,              // exit code
                    3000                   // wait hint
                    )) return ;

    dwLastError = ServiceStart(0, 0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        case SERVICE_CONTROL_STOP:

            //
            // tell the SCM we are stopping before triggering StopService() code
            // to avoid potential race condition during STOP_PENDING -> STOPPED transition
            //

            ssStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
            ServiceStop();
            return;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);
}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if (dwCurrentState == SERVICE_START_PENDING)
        ssStatus.dwControlsAccepted = 0;
    else
        ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    ssStatus.dwCurrentState = dwCurrentState;
    if(dwWin32ExitCode == 0) {
        ssStatus.dwWin32ExitCode = 0;
    } else {
        ssStatus.dwServiceSpecificExitCode = dwWin32ExitCode;
        ssStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
    }

    ssStatus.dwWaitHint = dwWaitHint;

    if ( ( dwCurrentState == SERVICE_RUNNING ) ||
         ( dwCurrentState == SERVICE_STOPPED ) )
        ssStatus.dwCheckPoint = 0;
    else
        ssStatus.dwCheckPoint = dwCheckPoint++;


    // Report the status of the service to the service control manager.
    //
    if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
        AddToMessageLog(L"SetServiceStatus");
    }

    return fResult;
}



//
//  FUNCTION: AddToMessageLog(LPWSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(LPWSTR lpszMsg)
{
    DWORD dwLastError = GetLastError();

    if(FIsWinNT()) {

        //
        // WinNT: Use event logging to log the error.
        //

        WCHAR   szMsg[512];
        HANDLE  hEventSource;
        LPWSTR  lpszStrings[2];

        hEventSource = RegisterEventSourceW(NULL, SZSERVICENAME);

        if(hEventSource == NULL)
            return;

        wsprintfW(szMsg, L"%s error: %lu", SZSERVICENAME, dwLastError);
        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        ReportEventW(hEventSource, // handle of event source
            EVENTLOG_ERROR_TYPE,  // event type
            0,                    // event category
            0,                    // event ID
            NULL,                 // current user's SID
            2,                    // strings in lpszStrings
            0,                    // no bytes of raw data
            (LPCWSTR*)lpszStrings,          // array of error strings
            NULL);                // no raw data

        (VOID) DeregisterEventSource(hEventSource);

    }
#ifdef WIN95_LEGACY
    else {

        //
        // Win95: log error to file
        //

        HANDLE hFile;
        SYSTEMTIME st;
        CHAR szMsgOut[512];
        DWORD cchMsgOut;
        DWORD dwBytesWritten;

        hFile = CreateFileA(
            "pstore.log",
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            OPEN_ALWAYS,
            0,
            NULL
            );

        if(hFile == INVALID_HANDLE_VALUE)
            return;

        GetSystemTime( &st );

        cchMsgOut = wsprintfA(szMsgOut, "%.2u-%.2u-%.2u %.2u:%.2u:%.2u %ls (rc=%lu)\015\012",
            st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond,
            lpszMsg,
            dwLastError
            );

        //
        // seek to EOF
        //

        SetFilePointer(hFile, 0, NULL, FILE_END);

        WriteFile(hFile, szMsgOut, cchMsgOut, &dwBytesWritten, NULL);
        CloseHandle(hFile);
    }
#endif  // WIN95_LEGACY

}


RPC_STATUS
RPC_ENTRY
PstoreCallback(
    RPC_IF_HANDLE idIF,
    PVOID pCtx)
{
    RPC_STATUS Status;
    PWSTR pBinding = NULL;
    PWSTR pProtSeq = NULL;

    Status = RpcBindingToStringBinding(pCtx, &pBinding);

    if(Status != RPC_S_OK)
    {
        goto cleanup;
    }

    Status = RpcStringBindingParse(pBinding,
                                   NULL,
                                   &pProtSeq,
                                   NULL,
                                   NULL,
                                   NULL);
    if(Status != RPC_S_OK)
    {
        goto cleanup;
    }

    // Make sure caller is using local RPC
    if(CompareString(LOCALE_INVARIANT,
                     NORM_IGNORECASE, 
                     pProtSeq,
                     -1,
                     PSTORE_LOCAL_PROT_SEQ,
                     -1) != CSTR_EQUAL)
    {
        Status = ERROR_ACCESS_DENIED;
        goto cleanup;
    }

    Status = RPC_S_OK;

cleanup:

    if(pProtSeq)
    {
        RpcStringFree(&pProtSeq);
    }

    if(pBinding)
    {
        RpcStringFree(&pBinding);
    }

    return Status;
}


//
//  FUNCTION: ServiceStart
//
//  COMMENTS:
//    The service
//    stops when hServerStopEvent is signalled

DWORD
ServiceStart(
    HINSTANCE hInstance,
    int nCmdShow
    )
{
    SECURITY_ATTRIBUTES sa;

    PSID pEveryoneSid = NULL;
    SECURITY_DESCRIPTOR sdInitEvent;
    RPC_STATUS status = 0;


    SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
    DWORD EveryoneSidBuffer[6];

    DWORD dwAclSize;

    DWORD dwLastError = ERROR_SUCCESS;
    BOOL fStartedKeyService = FALSE;
    BOOL bListConstruct = FALSE;

    pEveryoneSid = (PSID)EveryoneSidBuffer;
    InitializeSid(pEveryoneSid, &sia, 1);
    *(GetSidSubAuthority( pEveryoneSid, 0)) = SECURITY_WORLD_RID; 


    dwAclSize = sizeof(ACL) +
        1 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pEveryoneSid) ;

    pDaclInitEvent = (PACL)SSAlloc(dwAclSize);
    if(pDaclInitEvent == NULL)
    {
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    if(!InitializeAcl(pDaclInitEvent, dwAclSize, ACL_REVISION))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if(!AddAccessAllowedAce(
        pDaclInitEvent,
        ACL_REVISION,
        SYNCHRONIZE,
        pEveryoneSid
        ))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if(!InitializeSecurityDescriptor(
        &sdInitEvent,
        SECURITY_DESCRIPTOR_REVISION
        ))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    if(!SetSecurityDescriptorDacl(
        &sdInitEvent,
        TRUE,
        pDaclInitEvent,
        FALSE
        ))
    {
        dwLastError = GetLastError();
        goto cleanup;
    }


    sa.lpSecurityDescriptor = &sdInitEvent;



    //
    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    // On WinNT, we let security default to local system+admins access.
    // On WinNT, the ServiceStop() API is the correct way to cause a service
    // to stop, so we let Service Control manager dictate who can do it.
    //

    // Only on Win95 do we use a named event, in order to support shutting
    // down the server cleanly on that platform, since Win95 does not support
    // real services.

    hServerStopEvent = CreateEventA(
            NULL,
            TRUE,           // manual reset event
            FALSE,          // not-signalled
            (FIsWinNT() ? NULL : PST_EVENT_STOP)    // WinNT: unnamed, Win95 named
            );

    //
    // if event already exists, terminate quietly so that only one instance
    // of the service is allowed.
    //

    if(hServerStopEvent && GetLastError() == ERROR_ALREADY_EXISTS) {
        CloseHandle(hServerStopEvent);
        hServerStopEvent = NULL;
    }

    if(hServerStopEvent == NULL) {
        dwLastError = GetLastError();
        goto cleanup;
    }

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = FALSE;

    hServiceStarted = CreateEventA(
                        &sa,        // security attributes for WinNT
                        TRUE,       // manual reset event
                        FALSE,      // not-signalled
                        PST_EVENT_INIT_NT5
                        );


    if(hServiceStarted == NULL) {
        dwLastError = GetLastError();
        goto cleanup;
    }


    //
    // free Dacl on event, since we no longer need it.
    //

    if(pDaclInitEvent) {
        SSFree(pDaclInitEvent);
        pDaclInitEvent = NULL;
    }

    //
    // report the status to the service control manager.
    // (service start still pending).
    //

    if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING,  // service state
            NO_ERROR,               // exit code
            3000                    // wait hint
            )) {
        dwLastError = GetLastError();
        goto cleanup;
    }

    bListConstruct = ListConstruct();

    if(!bListConstruct)
    {
        dwLastError = GetLastError();
        goto cleanup;
    }

    status = RpcServerUseProtseqEpW(PSTORE_LOCAL_PROT_SEQ,   //ncalrpc 
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
                                    PSTORE_LOCAL_ENDPOINT,   //protected_storage
                                    NULL);              //Security Descriptor

    if(RPC_S_DUPLICATE_ENDPOINT == status)
    {
        status = RPC_S_OK;
    }

    if ( status != RPC_S_OK )
    {
        dwLastError = status;
        goto cleanup;
    }


    status = RpcServerRegisterIfEx(s_IPStoreProv_v1_0_s_ifspec, 
                                   NULL, 
                                   NULL,
                                   RPC_IF_AUTOLISTEN,
                                   RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                   PstoreCallback);

    if ( status != RPC_S_OK )
    {
        dwLastError = status;
        goto cleanup;
    }





    SetEvent(hServiceStarted); // signal service is ready to take requests


    //
    // report the status to the service control manager.
    //

    if (!ReportStatusToSCMgr(
            SERVICE_RUNNING,       // service state
            NO_ERROR,              // exit code
            0                      // wait hint
            )) {
        dwLastError = GetLastError();
        goto cleanup;
    }


    //
    // on WinNT5, ask services.exe to notify us when the service is shutting
    // down, and return this thread to the work item queue.
    //


    if(!RegisterWaitForSingleObject(
                            &hRegisteredWait,
                            hServerStopEvent,   // wait handle
                            TerminationNotify,  // callback fcn
                            NULL,               // parameter
                            INFINITE,           // timeout
                            WT_EXECUTELONGFUNCTION | WT_EXECUTEONLYONCE
                            )) {

        hRegisteredWait = NULL;
        dwLastError = GetLastError();
    }

    return dwLastError;


cleanup:

    TeardownServer( dwLastError );

    return dwLastError;
}

VOID
NTAPI
TerminationNotify(
    PVOID Context,
    BOOLEAN TimerOrWaitFired
    )
/*++

Routine Description:

    This function gets called by a services worker thread when the
    termination event gets signaled.

Arguments:

Return Value:

--*/
{
    //
    // per JSchwart:
    // safe to unregister during callback.
    //

    if( hRegisteredWait ) {
        UnregisterWaitEx( hRegisteredWait, NULL );
        hRegisteredWait = NULL;
    }

    TeardownServer( ERROR_SUCCESS );
}

VOID
TeardownServer(
    DWORD dwLastError
    )
{
    //
    // ignore errors because we are shutting down
    //

    RpcServerUnregisterIf(s_IPStoreProv_v1_0_s_ifspec, 0, 0);




    if(pDaclInitEvent) {
        SSFree(pDaclInitEvent);
        pDaclInitEvent = NULL;
    }

    if(hServiceStarted) {
        ResetEvent(hServiceStarted);
        CloseHandle(hServiceStarted);
        hServiceStarted = NULL;
    }


    if(hServerStopEvent) {
        SetEvent(hServerStopEvent); // make event signalled to release anyone waiting for termination
        CloseHandle(hServerStopEvent);
        hServerStopEvent = NULL;
    }

    ListTeardown();



    ReportStatusToSCMgr(
                        SERVICE_STOPPED,
                        dwLastError,
                        0
                        );

}

//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//
VOID ServiceStop()
{

    if(hServiceStarted) {
        ResetEvent(hServiceStarted);
        CloseHandle(hServiceStarted);
        hServiceStarted = NULL;
    }

    if(hServerStopEvent)
        PulseEvent(hServerStopEvent); // signal waiting threads and reset to non-signalled
}

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_API midl_user_allocate(size_t len)
{
    return(SSAlloc(len));
}

void __RPC_API midl_user_free(void __RPC_FAR * ptr)
{
    //
    // sfield: zero memory before freeing it.
    // do this because RPC allocates alot on our behalf, and we want to
    // be as sanitary as possible with respect to not letting anything
    // sensitive go to pagefile.
    //

    ZeroMemory( ptr, SSSize( ptr ) );
    SSFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\tlhelp32.h ===
/*****************************************************************************\
*                                                                             *
* tlhelp32.h -	WIN32 tool help functions, types, and definitions	      *
*                                                                             *
* Version 1.0								      *
*                                                                             *
* NOTE: windows.h/winbase.h must be #included first			      *
*                                                                             *
* Copyright (c) 1994-1995, Microsoft Corp.   All rights reserved. 	      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP32
#define _INC_TOOLHELP32

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MAX_MODULE_NAME32 255

/****** Shapshot function **********************************************/

HANDLE WINAPI CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
//
// The th32ProcessID argument is only used if TH32CS_SNAPHEAPLIST or
// TH32CS_SNAPMODULE is specified. th32ProcessID == 0 means the current
// process.
//
// NOTE that all of the snapshots are global except for the heap and module
//	lists which are process specific. To enumerate the heap or module
//	state for all WIN32 processes call with TH32CS_SNAPALL and the
//	current process. Then for each process in the TH32CS_SNAPPROCESS
//	list that isn't the current process, do a call with just
//	TH32CS_SNAPHEAPLIST and/or TH32CS_SNAPMODULE.
//
// dwFlags
//
#define TH32CS_SNAPHEAPLIST 0x00000001
#define TH32CS_SNAPPROCESS  0x00000002
#define TH32CS_SNAPTHREAD   0x00000004
#define TH32CS_SNAPMODULE   0x00000008
#define TH32CS_SNAPALL	    (TH32CS_SNAPHEAPLIST | TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD | TH32CS_SNAPMODULE)
#define TH32CS_INHERIT	    0x80000000
//
// Use CloseHandle to destroy the snapshot
//

/****** heap walking ***************************************************/

typedef struct tagHEAPLIST32
{
    DWORD  dwSize;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap (in owning process's context!)
    DWORD  dwFlags;
} HEAPLIST32;
typedef HEAPLIST32 *  PHEAPLIST32;
typedef HEAPLIST32 *  LPHEAPLIST32;
//
// dwFlags
//
#define HF32_DEFAULT	  1  // process's default heap
#define HF32_SHARED	  2  // is shared heap

BOOL WINAPI Heap32ListFirst(HANDLE hSnapshot, LPHEAPLIST32 lphl);
BOOL WINAPI Heap32ListNext(HANDLE hSnapshot, LPHEAPLIST32 lphl);

typedef struct tagHEAPENTRY32
{
    DWORD  dwSize;
    HANDLE hHandle;	// Handle of this heap block
    DWORD  dwAddress;	// Linear address of start of block
    DWORD  dwBlockSize; // Size of block in bytes
    DWORD  dwFlags;
    DWORD  dwLockCount;
    DWORD  dwResvd;
    DWORD  th32ProcessID;   // owning process
    DWORD  th32HeapID;	    // heap block is in
} HEAPENTRY32;
typedef HEAPENTRY32 *  PHEAPENTRY32;
typedef HEAPENTRY32 *  LPHEAPENTRY32;
//
// dwFlags
//
#define LF32_FIXED    0x00000001
#define LF32_FREE     0x00000002
#define LF32_MOVEABLE 0x00000004

BOOL WINAPI Heap32First(LPHEAPENTRY32 lphe, DWORD th32ProcessID,
			DWORD th32HeapID);
BOOL WINAPI Heap32Next(LPHEAPENTRY32 lphe);
BOOL WINAPI Toolhelp32ReadProcessMemory(DWORD	th32ProcessID,
					LPCVOID lpBaseAddress,
					LPVOID	lpBuffer,
					DWORD	cbRead,
					LPDWORD lpNumberOfBytesRead);

/***** Process walking *************************************************/

typedef struct tagPROCESSENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ProcessID;	    // this process
    DWORD   th32DefaultHeapID;
    DWORD   th32ModuleID;	    // associated exe
    DWORD   cntThreads;
    DWORD   th32ParentProcessID;    // this process's parent process
    LONG    pcPriClassBase;	    // Base priority of process's threads
    DWORD   dwFlags;
    char    szExeFile[MAX_PATH];    // Path
} PROCESSENTRY32;
typedef PROCESSENTRY32 *  PPROCESSENTRY32;
typedef PROCESSENTRY32 *  LPPROCESSENTRY32;

BOOL WINAPI Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
BOOL WINAPI Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);

/***** Thread walking **************************************************/

typedef struct tagTHREADENTRY32
{
    DWORD   dwSize;
    DWORD   cntUsage;
    DWORD   th32ThreadID;	// this thread
    DWORD   th32OwnerProcessID; // Process this thread is associated with
    LONG    tpBasePri;
    LONG    tpDeltaPri;
    DWORD   dwFlags;
} THREADENTRY32;
typedef THREADENTRY32 *  PTHREADENTRY32;
typedef THREADENTRY32 *  LPTHREADENTRY32;

BOOL WINAPI Thread32First(HANDLE hSnapshot, LPTHREADENTRY32 lpte);
BOOL WINAPI Thread32Next(HANDLE hSnapshot, LPTHREADENTRY32 lpte);

/***** Module walking *************************************************/

typedef struct tagMODULEENTRY32
{
    DWORD   dwSize;
    DWORD   th32ModuleID;	// This module
    DWORD   th32ProcessID;	// owning process
    DWORD   GlblcntUsage;	// Global usage count on the module
    DWORD   ProccntUsage;	// Module usage count in th32ProcessID's context
    BYTE  * modBaseAddr;	// Base address of module in th32ProcessID's context
    DWORD   modBaseSize;	// Size in bytes of module starting at modBaseAddr
    HMODULE hModule;		// The hModule of this module in th32ProcessID's context
    char    szModule[MAX_MODULE_NAME32 + 1];
    char    szExePath[MAX_PATH];
} MODULEENTRY32;
typedef MODULEENTRY32 *  PMODULEENTRY32;
typedef MODULEENTRY32 *  LPMODULEENTRY32;

//
// NOTE CAREFULLY that the modBaseAddr and hModule fields are valid ONLY
// in th32ProcessID's process context.
//

BOOL WINAPI Module32First(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
BOOL WINAPI Module32Next(HANDLE hSnapshot, LPMODULEENTRY32 lpme);

#ifdef __cplusplus
}
#endif

#endif // _INC_TOOLHELP32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\winpw.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    winpw.h

Abstract:

    This module contains routines for retrieving and verification of
    Windows [NT] password associated with client calling protected storage.

Author:

    Scott Field (sfield)    12-Dec-96

--*/

#ifndef __WINPW_H__
#define __WINPW_H__

#ifdef __cplusplus
extern "C" {
#endif


typedef struct {
    BYTE HashedUsername[A_SHA_DIGEST_LEN];  // hash of ANSI username, not include terminal NULL
    BYTE HashedPassword[A_SHA_DIGEST_LEN];  // hash of Unicode password, not include terminal NULL
    BOOL bValid;                            // indicates if structure contents valid
} WIN95_PASSWORD, *PWIN95_PASSWORD, *LPWIN95_PASSWORD;


BOOL
SetPasswordNT(
    PLUID LogonID,
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    );

BOOL
GetPasswordNT(
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    );

BOOL
GetSpecialCasePasswordNT(
    BYTE    HashedPassword[A_SHA_DIGEST_LEN],   // derived bits when fSpecialCase == TRUE
    LPBOOL  fSpecialCase                        // legal special case encountered?
    );

BOOL
SetPassword95(
    BYTE HashedUsername[A_SHA_DIGEST_LEN],
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    );

BOOL
GetPassword95(
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    );

BOOL
VerifyWindowsPassword(
    LPCWSTR Password             // password to validate
    );


#ifdef __cplusplus
}
#endif


#endif // __WINPW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\secstor\svr\winpw.c ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    winpw.c

Abstract:

    This module contains routines for retrieving and verification of the
    Windows NT and Windows 95 password associated with the client calling
    protected storage.

Author:

    Scott Field (sfield)    12-Dec-96

--*/

#include <windows.h>
#include <lmcons.h>
#include <sha.h>
#include "lnklist.h"
#include "winpw.h"
#include "module.h"
#include "unicode.h"
#include "unicode5.h"
#include "debug.h"

#include "secmisc.h"

#define MPR_PROCESS     "MPREXE.EXE"
#define MPRSERV_MODULE  "MPRSERV.DLL"

#define GLOBAL_USERNAME 0x0E8
#define PWL_USERNAME    0x170
#define GLOBAL_PASSWORD 0x188
#define PWL_PASSWORD    0x210

//
// this one comes and goes only when needed
//

typedef DWORD (WINAPI *WNETVERIFYPASSWORD)(
    LPCSTR lpszPassword,
    BOOL *pfMatch
    );

typedef DWORD (WINAPI *WNETGETUSERA)(
    LPCSTR lpName,
    LPSTR lpUserName,
    LPDWORD lpnLength
    );

WNETGETUSERA _WNetGetUserA = NULL;

//
// global Win95 password buffer.  Only need one entry because Win95
// only allows one user logged on at a time.
//

static WIN95_PASSWORD g_Win95Password;

BOOL
VerifyWindowsPasswordNT(
    LPCWSTR Password
    );

BOOL
GetTokenLogonType(
    HANDLE hToken,
    LPDWORD lpdwLogonType
    );

BOOL
GetTokenLogonType(
    HANDLE hToken,
    LPDWORD lpdwLogonType
    )
/*++
    This function retrieves the logon type associated with the
    access token specified by the hToken parameter.  On success,
    the DWORD buffer provided by the dwLogonType parameter is
    filled with the logon type which corresponds to the currently
    known logon types supported by the LogonUser() Windows NT
    API call.

    The token specified by the hToken parameter must have been
    opened with at least TOKEN_QUERY access.

    This function is only relevant on Windows NT and should not
    be called on Windows 95, as it will always return FALSE.

--*/
{
    UCHAR InfoBuffer[1024];
    DWORD dwInfoBufferSize = sizeof(InfoBuffer);
    PTOKEN_GROUPS SlowBuffer = NULL;
    PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)InfoBuffer;
    PSID psidInteractive = NULL;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL bSuccess;

    bSuccess = GetTokenInformation(
            hToken,
            TokenGroups,
            ptgGroups,
            dwInfoBufferSize,
            &dwInfoBufferSize
            );

    //
    // if fast buffer wasn't big enough, allocate enough storage
    // and try again.
    //

    if(!bSuccess && GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
        SlowBuffer = (PTOKEN_GROUPS)SSAlloc(dwInfoBufferSize);
        if(SlowBuffer != NULL) {

            ptgGroups = SlowBuffer;
            bSuccess = GetTokenInformation(
                    hToken,
                    TokenGroups,
                    ptgGroups,
                    dwInfoBufferSize,
                    &dwInfoBufferSize
                    );

            if(!bSuccess) {
                SSFree(SlowBuffer);
                SlowBuffer = NULL;
            }
        }
    }

    if(!bSuccess)
        return FALSE;

    //
    // initialize a single well-known logon Sid, since
    // we only compare the prefix and then the Rid
    // note that if performance were of utmost importance, we should
    // use InitializeSid + GetSidSubAuthority (to _set_ the Rid).
    // also note that we could do a simple memcmp against just the sid
    // identifier authority, but this assumes that Sid versions/layouts don't
    // change
    //

    bSuccess = AllocateAndInitializeSid(
            &siaNtAuthority,
            1,
            SECURITY_INTERACTIVE_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidInteractive
            );

    if(bSuccess) {
        UINT x;

        bSuccess = FALSE; // assume no match

        //
        // loop through groups checking for equality against
        // the well-known logon Sids.
        //

        for(x = 0 ; x < ptgGroups->GroupCount ; x++)
        {
            DWORD Rid;

            //
            // first, see if subauthority count matches, since
            // not too many sids have only one subauthority.
            //

            if(*GetSidSubAuthorityCount(ptgGroups->Groups[x].Sid) != 1)
                continue;

            //
            // next, see if the Sid prefix matches, since
            // all the logon Sids have the same prefix
            // "S-1-5"
            //

            if(!EqualPrefixSid(psidInteractive, ptgGroups->Groups[x].Sid))
                continue;

            //
            // if it's a logon sid prefix, just compare the Rid
            // to the known values.
            //

            Rid = *GetSidSubAuthority(ptgGroups->Groups[x].Sid, 0);
            switch (Rid) {
                case SECURITY_INTERACTIVE_RID:
                    *lpdwLogonType = LOGON32_LOGON_INTERACTIVE;
                    break;

                case SECURITY_BATCH_RID:
                    *lpdwLogonType = LOGON32_LOGON_BATCH;
                    break;

                case SECURITY_SERVICE_RID:
                    *lpdwLogonType = LOGON32_LOGON_SERVICE;
                    break;

                case SECURITY_NETWORK_RID:
                    *lpdwLogonType = LOGON32_LOGON_NETWORK;
                    break;

                default:
                    continue;   // ignore unknown logon type and continue
            }

            bSuccess = TRUE;    // indicate success and bail
            break;
        }
    }

    if(SlowBuffer)
        SSFree(SlowBuffer);

    if(psidInteractive)
        FreeSid(psidInteractive);

    return bSuccess;
}

BOOL
SetPasswordNT(
    PLUID LogonID,
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    )

/*++

    This function adds the hashed password that is referenced by the specified
    Logon ID.

--*/

{
#if 0
    return AddNTPassword(LogonID, HashedPassword);
#else
    return TRUE; // do nothing, just return success
#endif
}


BOOL
GetPasswordNT(
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    )
/*++

    This function retrieves the hashed password associated with the calling
    thread access token.  This requires that the calling thread is impersonating
    the user associated with the password request.  The credentials associated
    with the authentication ID are returned.  This is done because WinNT
    supports multiple logged on users, and we must return the correct credentials.

--*/
{
#if 0
    LUID AuthenticationId;

    if(!GetThreadAuthenticationId(
            GetCurrentThread(),
            &AuthenticationId
            )) return FALSE;

    return FindNTPassword(&AuthenticationId, HashedPassword);
#else

    return FALSE; // no cache to search, just return FALSE

#endif

}

BOOL
GetSpecialCasePasswordNT(
    BYTE    HashedPassword[A_SHA_DIGEST_LEN],   // derived bits when fSpecialCase == TRUE
    LPBOOL  fSpecialCase                        // legal special case encountered?
    )
/*++

    This routine determines if the calling thread's access token is eligible
    to recieve a special case hashed password.

    If an legal special case is encountered (Local System Account), we
    fill the HashPassword buffer with an consistent hash, set fSpecialCase to
    TRUE, and return TRUE.

    If an illegal special case is encountered (Network SID), fSpecialCase is
    set FALSE, and we return FALSE.

    If we encounter an access token that appears to have valid credentials,
    but we have no way to get at them (Interactive, Batch, Service ... ),
    fSpecialCase is set FALSE and we return TRUE.

    The calling thread MUST be imperonsating the client in question prior to
    making this call.

--*/
{
    HANDLE hToken = NULL;
    DWORD dwLogonType;
    A_SHA_CTX context;
    BOOL fSuccess = FALSE;

    *fSpecialCase = FALSE;

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
        return FALSE;

    //
    // first, get the token logon type.
    //

    fSuccess = GetTokenLogonType(hToken, &dwLogonType);

    //
    // if we got the token logon type ok, check if it's an appropriate type.
    // otherwise, check for the local system special case.
    //

    if(fSuccess) {

        //
        // we only indicate success for the interactive logon type.
        // note default is fSuccess == TRUE when going to cleanup
        //

        if(dwLogonType != LOGON32_LOGON_INTERACTIVE)
            fSuccess = FALSE;

        goto cleanup;
    } else {

        SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
        PSID pSystemSid;
        PSID pTokenSid;

        fSuccess = GetTokenUserSid(hToken, &pTokenSid);
        if(!fSuccess)
            goto cleanup;


        //
        // build local system sid and compare.
        //

        fSuccess = AllocateAndInitializeSid(
                            &sia,
                            1,
                            SECURITY_LOCAL_SYSTEM_RID,
                            0, 0, 0, 0, 0, 0, 0,
                            &pSystemSid
                            );

        if( fSuccess ) {

            //
            // check sid equality.  If so, hash and tell the caller about it.
            //

            if( EqualSid(pSystemSid, pTokenSid) ) {

                //
                // hash the special case user Sid
                //

                A_SHAInit(&context);
                A_SHAUpdate(&context, (LPBYTE)pTokenSid, GetLengthSid(pTokenSid));
                A_SHAFinal(&context, HashedPassword);

                *fSpecialCase = TRUE;
            }

            FreeSid(pSystemSid);
        }

        SSFree(pTokenSid);
    }



cleanup:

    if(hToken)
        CloseHandle(hToken);

    return fSuccess;
}




BOOL
SetPassword95(
    BYTE HashedUsername[A_SHA_DIGEST_LEN],
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    )
/*++

    This function adds the hashed password that is referenced by the hashed
    user name.

    Set HashedUsername and HashedPassword to NULL when calling to zero-out
    the single password entry.

--*/
{
    if(HashedUsername == NULL || HashedPassword == NULL) {
        g_Win95Password.bValid = FALSE;
        RtlSecureZeroMemory(g_Win95Password.HashedPassword, A_SHA_DIGEST_LEN);
        RtlSecureZeroMemory(g_Win95Password.HashedUsername, A_SHA_DIGEST_LEN);

        return TRUE;
    }


    memcpy(g_Win95Password.HashedUsername, HashedUsername, A_SHA_DIGEST_LEN);
    memcpy(g_Win95Password.HashedPassword, HashedPassword, A_SHA_DIGEST_LEN);

    g_Win95Password.bValid = TRUE;

    return TRUE;
}


BOOL
GetPassword95(
    BYTE HashedPassword[A_SHA_DIGEST_LEN]
    )
/*++

    This function retrieves the hashed password associated with the calling
    thread.  In Win95, only one user is logged on, so this operation is
    a simple copy from global memory, once the hash of the current user
    matches that which was stored with the hashed credential.

--*/
{
    A_SHA_CTX context;
    BYTE HashUsername[A_SHA_DIGEST_LEN];
    CHAR Username[UNLEN+1];
    DWORD cchUsername = UNLEN;

    //
    // don't release credential unless hash of username matches
    // sfield: use WNetGetUser() instead of GetUserName() as WNetGetUser()
    // will correspond to the password associated with what the network
    // provider gave us.
    //

    if(_WNetGetUserA(NULL, Username, &cchUsername) != NO_ERROR) {

        //
        // for Win95, if nobody is logged on, empty user name + password
        //

        if(GetLastError() != ERROR_NOT_LOGGED_ON)
            return FALSE;

        Username[0] = '\0'; // not really necessary
        cchUsername = 1;
    } else {

        // arg, WNetGetUserA() doesn't fill in cchUsername
        cchUsername = lstrlenA(Username) + 1; // include terminal NULL
        if(g_Win95Password.bValid == FALSE)
            return FALSE;
    }

    cchUsername--; // do not include terminal NULL

    A_SHAInit(&context);
    A_SHAUpdate(&context, Username, cchUsername);
    A_SHAFinal(&context, HashUsername);

    //
    // non empty username, may not be empty password
    //

    if(cchUsername) {
        if(memcmp(HashUsername, g_Win95Password.HashedUsername, A_SHA_DIGEST_LEN) != 0) {
            //
            // rare case on Win95: if we didn't automatically flush the entry
            // during a logoff (this can occur if network provider not hooked),
            // flush it now because we know the entry cannot possibly be valid.
            //
            g_Win95Password.bValid = FALSE;
            return FALSE;
        }

        memcpy(HashedPassword, g_Win95Password.HashedPassword, A_SHA_DIGEST_LEN);

        return TRUE;
    }

    //
    // empty user name == empty password
    //

    memcpy(HashedPassword, HashUsername, A_SHA_DIGEST_LEN);

    return TRUE;
}


BOOL
VerifyWindowsPassword(
    LPCWSTR Password
    )
/*++
    This function verifies that the specified password matches that of the
    current user.

    On Windows 95, the current user equates to the user is currently logged
    onto the machine.

    On Windows NT, the current user equates to the user which is being
    impersonated during the call.  On Windows NT, the caller MUST be
    impersonating the user associated with the validation.

    On Windows NT, a side effect of the validation is notification of
    a new logon to the credential manager.  This is ignored because the
    authentication ID present in the new logon does not match the
    authentication ID present in the impersonated access token.

--*/
{
    return VerifyWindowsPasswordNT(Password);
}

BOOL
VerifyWindowsPasswordNT(
    LPCWSTR Password
    )
{
    HANDLE hPriorToken = NULL;
    HANDLE hToken;
    HANDLE hLogonToken = NULL;
    PTOKEN_USER pTokenInfo = NULL;
    DWORD cbTokenInfoSize;
    WCHAR User[UNLEN+1];
    WCHAR Domain[DNLEN+1];
    DWORD cchUser = UNLEN;
    DWORD cchDomain = DNLEN;
    SID_NAME_USE peUse;
    BOOL bSuccess = FALSE;

    //
    // find out domain and user name associated with current user
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
        return FALSE;

    cbTokenInfoSize = 512;
    pTokenInfo = (PTOKEN_USER)SSAlloc(cbTokenInfoSize);
    if(pTokenInfo == NULL)
        goto cleanup;

    if(!GetTokenInformation(
            hToken,
            TokenUser,
            pTokenInfo,
            cbTokenInfoSize,
            &cbTokenInfoSize
            )) {

        //
        // realloc and try again
        //

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            SSFree(pTokenInfo);

            pTokenInfo = (PTOKEN_USER)SSAlloc(cbTokenInfoSize);
            if(pTokenInfo == NULL)
                goto cleanup;

            if(!GetTokenInformation(
                hToken,
                TokenUser,
                pTokenInfo,
                cbTokenInfoSize,
                &cbTokenInfoSize
                )) {
                goto cleanup;
            }

        } else {
            goto cleanup;
        }
    }

    if(!LookupAccountSidW(
            NULL, // default lookup logic
            pTokenInfo->User.Sid,
            User,
            &cchUser,
            Domain,
            &cchDomain,
            &peUse
            ))
        goto cleanup;


    //
    // WinNT:
    // first try network logon type, if that fails, grovel the token
    // and try the same logon type which is associated with the impersonation
    // token.
    //


    //
    // arg! LogonUser() fails in some cases if we are impersonating!
    // so save off impersonation token, revert, and put it back later.
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hPriorToken)) {
        hPriorToken = NULL;
    } else {
        RevertToSelf();
    }

    //
    // network logon type is fastest, and in default NT install, everyone
    // has the SeNetworkLogonRight, so it's very likely to pass the logon right
    // test
    //

    if(!LogonUserW(
            User,
            Domain,
            (LPWSTR)Password,
            LOGON32_LOGON_NETWORK,
            LOGON32_PROVIDER_DEFAULT,
            &hLogonToken
            )) {

        DWORD dwLastError = GetLastError();
        DWORD dwLogonType;

        //
        // retry with different logon type if necessary.
        // note: ERROR_LOGON_TYPE_NOT_GRANTED currently only occurs
        // if the password matches but user didn't have specified logon
        // type.  So, currently, we could treat this as a successful validation
        // without retrying, but this is subject to change in future, so retry
        // anyway.
        //

        if( dwLastError == ERROR_LOGON_TYPE_NOT_GRANTED &&
            GetTokenLogonType(hPriorToken, &dwLogonType)
            ) {

            bSuccess = LogonUserW(
                    User,
                    Domain,
                    (LPWSTR)Password,
                    dwLogonType,
                    LOGON32_PROVIDER_DEFAULT,
                    &hLogonToken
                    );
        }

        if(!bSuccess)
            hLogonToken = NULL; // LogonUser() has tendency to leave garbage in hToken

        goto cleanup;
    }

    bSuccess = TRUE;

cleanup:

    if(hPriorToken != NULL) {
        SetThreadToken(NULL, hPriorToken);
        CloseHandle(hPriorToken);
    }

    CloseHandle(hToken);

    if(hLogonToken)
        CloseHandle(hLogonToken);

    if(pTokenInfo)
        SSFree(pTokenInfo);

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\certtest\certtest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       certtest.cpp
//
//  Contents:   Certificate Test Helper APIs
//
//  History:	11-Apr-96   philh   created
//				31-May-96	helles	Removed check for a particular error code,
//									NTE_PROV_TYPE_NOT_DEF, since this can get
//									overwritten due to known problem with
//									the msvcr40d.dll on Win95.
//              20-Aug-96   jeffspel name changes
//--------------------------------------------------------------------------


#include <windows.h>
#include <winldap.h>
#include <assert.h>
#include "certtest.h"
#include "cryptuiapi.h"
#include "spc.h"
#include "setcert.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

DWORD dwCertEncodingType = X509_ASN_ENCODING;
DWORD dwMsgEncodingType = PKCS_7_ASN_ENCODING;
DWORD dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;

#define NULL_ASN_TAG    0x05

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
void PrintError(LPCSTR pszMsg)
{
    printf("%s\n", pszMsg);
}
void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

LPCSTR FileTimeText(FILETIME *pft)
{
    static char buf[80];
    FILETIME ftLocal;
    struct tm ctm;
    SYSTEMTIME st;

    FileTimeToLocalFileTime(pft, &ftLocal);
    if (FileTimeToSystemTime(&ftLocal, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        strcpy(buf, asctime(&ctm));
        buf[strlen(buf)-1] = 0;

        if (st.wMilliseconds) {
            char *pch = buf + strlen(buf);
            sprintf(pch, " <milliseconds:: %03d>", st.wMilliseconds);
        }
    }
    else
        sprintf(buf, "<FILETIME %08lX:%08lX>", pft->dwHighDateTime,
                pft->dwLowDateTime);
    return buf;
}

#define CROW 16
void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    if (cbSize == 0) {
        printf("%s NO Value Bytes\n", pszHdr);
        return;
    }

    while (cbSize > 0)
    {
        printf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
LPVOID
WINAPI
TestAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    pv = malloc(cbBytes);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}

LPVOID
WINAPI
TestRealloc(
    IN LPVOID pvOrg,
    IN size_t cbBytes
    )
{
    LPVOID pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes))) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}

VOID
WINAPI
TestFree(
    IN LPVOID pv
    )
{
    if (pv)
        free(pv);
}

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string
//--------------------------------------------------------------------------
LPWSTR AllocAndSzToWsz(LPCSTR psz)
{
    size_t  cb;
    LPWSTR  pwsz = NULL;

    if (-1 == (cb = mbstowcs( NULL, psz, strlen(psz))))
        goto bad_param;
    cb += 1;        // terminating NULL
    if (NULL == (pwsz = (LPWSTR)TestAlloc( cb * sizeof(WCHAR)))) {
        PrintLastError("AllocAndSzToWsz");
        goto failed;
    }
    if (-1 == mbstowcs( pwsz, psz, cb))
        goto bad_param;
    goto common_return;

bad_param:
    PrintError("Bad AllocAndSzToWsz");
failed:
    if (pwsz) {
        TestFree(pwsz);
        pwsz = NULL;
    }
common_return:
    return pwsz;
}

static CRYPT_DECODE_PARA TestDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(TestDecodePara.pfnFree),
    TestAlloc,
    TestFree
};

static void *TestNoCopyDecodeObject(
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &TestDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;

ErrorReturn:
    if ((DWORD_PTR) lpszStructType <= 0xFFFF)
        printf("CryptDecodeObject(StructType: %d)",
            (DWORD)(DWORD_PTR) lpszStructType);
    else
        printf("CryptDecodeObject(StructType: %s)",
            lpszStructType);
    PrintLastError("");

    pvStructInfo = NULL;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL ReadDERFromFile(
    LPCSTR  pszFileName,
    PBYTE   *ppbDER,
    PDWORD  pcbDER
    )
{
    BOOL        fRet;
    HANDLE      hFile = 0;
    PBYTE       pbDER = NULL;
    DWORD       cbDER;
    DWORD       cbRead;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszFileName);
        goto ErrorReturn;
    }

    cbDER = GetFileSize( hFile, NULL);
    if (cbDER == 0) {
        printf( "empty file %s\n", pszFileName);
        goto ErrorReturn;
    }
    if (NULL == (pbDER = (PBYTE)TestAlloc(cbDER))) {
        printf( "can't alloc %d bytes\n", cbDER);
        goto ErrorReturn;
    }
    if (!ReadFile( hFile, pbDER, cbDER, &cbRead, NULL) ||
            (cbRead != cbDER)) {
        printf( "can't read %s\n", pszFileName);
        goto ErrorReturn;
    }

    *ppbDER = pbDER;
    *pcbDER = cbDER;
    fRet = TRUE;
CommonReturn:
    if (hFile)
        CloseHandle(hFile);
    return fRet;
ErrorReturn:
    if (pbDER)
        TestFree(pbDER);
    *ppbDER = NULL;
    *pcbDER = 0;
    fRet = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
        PrintLastError("WriteDERToFile::CreateFile");
    } else {
        DWORD dwBytesWritten;
        if (!(fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                )))
            PrintLastError("WriteDERToFile::WriteFile");
        CloseHandle(hFile);
    }
    return fResult;
}

HCRYPTPROV GetCryptProvEx(BOOL fVerbose)
{
    HCRYPTPROV hProv = 0;
    BOOL fResult;

    DWORD dwCryptProvType = PROV_RSA_FULL;

    fResult = CryptAcquireContext(
                &hProv,
                NULL,           // pszContainer
                NULL,           // pszProvider
                dwCryptProvType,
                0               // dwFlags
                );
    if (fResult) {
        if (fVerbose)
            printf("Using default sign and xchg keys for provider: %d\n",
                dwCryptProvType);
    } else {
        DWORD dwErr = GetLastError();
        if (dwErr == NTE_BAD_KEYSET) {

            // Need to create the keys
            printf("Generating SIGNATURE and EXCHANGE private keys\n");

            hProv = 0;
            fResult = CryptAcquireContext(
                    &hProv,
                    NULL,           // pszContainer
                    NULL,           // pszProvider
                    dwCryptProvType,
                    CRYPT_NEWKEYSET
                    );
            if (!fResult || hProv == 0) {
                PrintLastError("CryptAcquireContext");
                return 0;
            }

            HCRYPTKEY hKey = 0;
            fResult = CryptGenKey(
                    hProv,
                    AT_SIGNATURE,
                    CRYPT_EXPORTABLE,
                    &hKey
                    );
            if (!fResult || hKey == 0)
                PrintLastError("CryptGenKey(AT_SIGNATURE)");
            else
                CryptDestroyKey(hKey);

            hKey = 0;
            fResult = CryptGenKey(
                    hProv,
                    AT_KEYEXCHANGE,
                    CRYPT_EXPORTABLE,
                    &hKey
                    );
            if (!fResult || hKey == 0)
                PrintLastError("CryptGenKey(AT_KEYEXCHANGE)");
            else
                CryptDestroyKey(hKey);

        } else {
            PrintLastError("CryptAcquireContext");
            return 0;
        }
    }
    return hProv;
}

HCRYPTPROV GetCryptProv() {
    return GetCryptProvEx(TRUE);
}


static HKEY OpenRelocateKey(
    IN OUT LPCSTR *ppszStoreFilename,
    IN DWORD dwFlags
    )
{
    LPCSTR pszStoreFilename = *ppszStoreFilename;
    HKEY hKeyRelocate;
    char szRelocate[256];
    LPCSTR pszRelocate;
    int i = 0;
    HKEY hKeyBase;
    LONG err;

    // Use the following characters until the terminating ":" as the
    // relocation path
    while ('\0' != *pszStoreFilename && ':' != *pszStoreFilename) {
        if (i >= sizeof(szRelocate) - 1)
            break;
        szRelocate[i++] = *pszStoreFilename++;
    }

    if (':' == *pszStoreFilename)
        pszStoreFilename++;
    szRelocate[i] = '\0';
    *ppszStoreFilename = pszStoreFilename;


    if (0 == _stricmp(szRelocate, "NULL")) {
        return NULL;
    } else if (0 == _strnicmp(szRelocate, "HKCU", 4)) {
        hKeyRelocate = HKEY_CURRENT_USER;
        pszRelocate = szRelocate+4;
        if ('\\' == *pszRelocate)
            pszRelocate++;
    } else if (0 == _strnicmp(szRelocate, "HKLM", 4)) {
        hKeyRelocate = HKEY_LOCAL_MACHINE;
        pszRelocate = szRelocate+4;
        if ('\\' == *pszRelocate)
            pszRelocate++;
    } else {
        hKeyRelocate = HKEY_CURRENT_USER;
        pszRelocate = szRelocate;
    }

    if (dwFlags & (CERT_STORE_READONLY_FLAG | CERT_STORE_OPEN_EXISTING_FLAG)) {
        REGSAM samDesired;
        if (dwFlags & CERT_STORE_READONLY_FLAG)
            samDesired = KEY_READ;
        else
            samDesired = KEY_ALL_ACCESS;

        if (ERROR_SUCCESS != (err = RegOpenKeyExA(
                hKeyRelocate,
                pszRelocate,
                0,                      // dwReserved
                samDesired,
                &hKeyBase))) {
            printf("RegOpenKeyExA(%s) failed => %d 0x%x\n",
                pszRelocate, err, err);
            hKeyBase = NULL;
        }
    } else {
        DWORD dwDisposition;
        if (ERROR_SUCCESS != (err = RegCreateKeyExA(
                hKeyRelocate,
                pszRelocate,
                0,                      // dwReserved
                NULL,                   // lpClass
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,                   // lpSecurityAttributes
                &hKeyBase,
                &dwDisposition))) {
            printf("RegCreateKeyExA(%s) failed => %d 0x%x\n",
                pszRelocate, err, err);
            hKeyBase = NULL;
        }
    }

    return hKeyBase;
}

// LastError can get globbered when doing remote registry access
static void CloseRelocateKey(
    IN HKEY hKey
    )
{
    if (hKey) {
        DWORD dwErr = GetLastError();
        LONG RegCloseKeyStatus;
        RegCloseKeyStatus = RegCloseKey(hKey);
        assert(ERROR_SUCCESS == RegCloseKeyStatus);
        SetLastError(dwErr);
    }
}

typedef PLDAP (LDAPAPI *PFN_LDAP_INIT_W)(
    const PWCHAR HostName,
    ULONG PortNumber
    );

typedef ULONG (LDAPAPI *PFN_LDAP_UNBIND)(
    LDAP *ld
    );

typedef ULONG (LDAPAPI *PFN_LDAP_CONNECT)(
    LDAP *ld,
    struct l_timeval  *timeout
    );

typedef ULONG (LDAPAPI *PFN_LDAP_BIND_SW)(
    LDAP *ld,
    PWCHAR dn,
    PWCHAR cred,
    ULONG method
    );

static
HCERTSTORE
OpenLdapStore(
    IN DWORD dwFlags,
    IN OUT LPWSTR pwszLdapUrl
    )
{
    HCERTSTORE hStore = NULL;
    LPWSTR pwszHostName = NULL;
    LPWSTR pwszTrailingSlash = NULL;
    CERT_LDAP_STORE_OPENED_PARA OpenPara = {NULL, pwszLdapUrl};
    HMODULE hDll = NULL;
    PFN_LDAP_INIT_W pfn_ldap_initW = NULL;
    PFN_LDAP_BIND_SW pfn_ldap_bind_sW = NULL;
    PFN_LDAP_UNBIND pfn_ldap_unbind = NULL;
    LDAP *ld = NULL;

    ULONG ulStatus;

    if (0 == _wcsnicmp(L"ldap://", pwszLdapUrl, 7)) {
        pwszHostName = pwszLdapUrl + 7;
        pwszTrailingSlash = pwszHostName;

        while (L'\0' != *pwszTrailingSlash && L'/' != *pwszTrailingSlash)
            pwszTrailingSlash++;

        if (L'/' == *pwszTrailingSlash && pwszTrailingSlash != pwszHostName) {
            *pwszTrailingSlash = L'\0';
        } else {
            pwszHostName = NULL;
            pwszTrailingSlash = NULL;
        }
    }


    if (NULL == (hDll = LoadLibraryA("wldap32.dll"))) {
        PrintLastError("LoadLibraryA(wldap32.dll)");
        goto CommonReturn;
    }

    if (NULL == (pfn_ldap_initW =
            (PFN_LDAP_INIT_W) GetProcAddress(hDll,
                "ldap_initW"))) {
        PrintLastError("GetProcAddress(ldap_initW)");
        goto CommonReturn;
    }

    if (NULL == (pfn_ldap_bind_sW =
            (PFN_LDAP_BIND_SW) GetProcAddress(hDll,
                "ldap_bind_sW"))) {
        PrintLastError("GetProcAddress(ldap_bind_sW)");
        goto CommonReturn;
    }

    if (NULL == (pfn_ldap_unbind =
            (PFN_LDAP_UNBIND) GetProcAddress(hDll,
                "ldap_unbind"))) {
        PrintLastError("GetProcAddress(ldap_unbind)");
        goto CommonReturn;
    }

    ld = pfn_ldap_initW(pwszHostName, 0);

    if (pwszTrailingSlash)
        *pwszTrailingSlash = L'/';

    if (NULL == ld) {
        PrintError("ldap_initW failed");
        goto CommonReturn;
    }

    OpenPara.pvLdapSessionHandle = ld;

    ulStatus = pfn_ldap_bind_sW(ld, NULL, NULL, LDAP_AUTH_SSPI);
    if (LDAP_SUCCESS != ulStatus) {
        printf("ldap_bind_sW failed ==> 0x%x\n", ulStatus);
        goto CommonReturn;
    }

    if (0 == (dwFlags & CERT_STORE_READONLY_FLAG))
        dwFlags |= CERT_LDAP_STORE_UNBIND_FLAG;
    hStore = CertOpenStore(
        CERT_STORE_PROV_LDAP_W,
        dwCertEncodingType | dwMsgEncodingType,
        0,                      // hCryptProv
        dwFlags | CERT_LDAP_STORE_OPENED_FLAG,
        (const void *) &OpenPara
        );
    if (NULL == hStore) {
        PrintLastError("CertOpenStore(CERT_LDAP_STORE_OPENED_FLAG)");

        if (0 != (dwFlags & CERT_STORE_DELETE_FLAG) && 0 == GetLastError() &&
                0 != (dwFlags & CERT_LDAP_STORE_UNBIND_FLAG))
            ld = NULL;
    } else if (0 != (dwFlags & CERT_LDAP_STORE_UNBIND_FLAG))
        ld = NULL;

CommonReturn:
    if (ld)
        pfn_ldap_unbind(ld);
    if (hDll)
        FreeLibrary(hDll);

    return hStore;
}

typedef struct _SYSTEM_LOCATION_INFO {
    LPCSTR      pszPrefix;
    DWORD       dwStoreLocation;
} SYSTEM_LOCATION_INFO;


static SYSTEM_LOCATION_INFO rgSystemLocationInfo[] = {
    "LocalMachine:", CERT_SYSTEM_STORE_LOCAL_MACHINE,
    "LM:", CERT_SYSTEM_STORE_LOCAL_MACHINE,
    "Services:", CERT_SYSTEM_STORE_SERVICES,
    "Users:", CERT_SYSTEM_STORE_USERS,
    "CurrentService:", CERT_SYSTEM_STORE_CURRENT_SERVICE,
    "CS:", CERT_SYSTEM_STORE_CURRENT_SERVICE,
    "CurrentUser:", CERT_SYSTEM_STORE_CURRENT_USER,
    "CU:", CERT_SYSTEM_STORE_CURRENT_USER,
    "CUGP:", CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY,
    "LMGP:", CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY,
    "Enterprise:", CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE,
    "EP:", CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
};
#define NUM_SYSTEM_LOCATION (sizeof(rgSystemLocationInfo) / \
                                sizeof(rgSystemLocationInfo[0]))

// returns NULL if unable to open. Doesn't open memory store.
HCERTSTORE OpenStoreEx2(BOOL fSystemStore, LPCSTR pszStoreFilename,
    DWORD dwFlags)
{
    HCERTSTORE hStore = NULL;

    if (fSystemStore) {
        DWORD i;

        // Check for special System Location Prefix. If found, strip off,
        // set store location and try again
        for (i = 0; i < NUM_SYSTEM_LOCATION; i++) {
            LPCSTR pszPrefix = rgSystemLocationInfo[i].pszPrefix;
            DWORD cchPrefix = strlen(pszPrefix);
            if (0 == _strnicmp(pszPrefix, pszStoreFilename, cchPrefix)) {
                if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                    dwFlags |= rgSystemLocationInfo[i].dwStoreLocation;
                return OpenStoreEx2(TRUE, pszStoreFilename + cchPrefix,
                    dwFlags);
            }
        }

        // Check for special "archived:" Prefix. If found, strip off and
        // set ENUM_ARCHIVE flag and try again
        if (0 == _strnicmp("archived:", pszStoreFilename, 9)) {
            dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;
            return OpenStoreEx2(TRUE, pszStoreFilename + 9,
                dwFlags);
        }

        // Check for special "reg:", "unprotected:",  "phy:", "prov:ProvName:",
        // "rel:<RegPath>:", "relreg:<RegPath>:" or "relphy:<RegPath>:" prefix
        //
        // Where <RegPath> is <string>, HKCU\<string>, HKLM\<string> or
        // NULL. <string> defaults to HKCU.
        if (0 == _strnicmp("reg:", pszStoreFilename, 4)) {
            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_REGISTRY_A,
                    dwCertEncodingType | dwMsgEncodingType,
                    0,                      // hCryptProv
                    dwFlags,
                    (const void *) (pszStoreFilename + 4)
                    );
        } else if (0 == _strnicmp("unprotected:", pszStoreFilename, 12)) {
            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_REGISTRY_A,
                    dwCertEncodingType | dwMsgEncodingType,
                    0,                      // hCryptProv
                    dwFlags | CERT_SYSTEM_STORE_UNPROTECTED_FLAG,
                    (const void *) (pszStoreFilename + 12)
                    );
        } else if (0 == _strnicmp("phy:", pszStoreFilename, 4)) {
            LPWSTR pwszStore;

            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            if (pwszStore = AllocAndSzToWsz(pszStoreFilename + 4)) {
                hStore = CertOpenStore(
                        CERT_STORE_PROV_PHYSICAL,
                        dwCertEncodingType | dwMsgEncodingType,
                        0,                      // hCryptProv
                        dwFlags,
                        (const void *) pwszStore
                        );
                TestFree(pwszStore);
            }
        } else if (0 == _strnicmp("prov:", pszStoreFilename, 5)) {
            LPWSTR pwszStore;
            char ch;
            char szStoreProvider[256];
            int i = 0;
            
            // Advance past "prov:"
            pszStoreFilename += 5;

            // Use the following characters until the terminating ":" as the
            // store provider
            while ('\0' != *pszStoreFilename && ':' != *pszStoreFilename) {
                if (i >= sizeof(szStoreProvider) - 1)
                    break;
                szStoreProvider[i++] = *pszStoreFilename++;
            }

            if (':' == *pszStoreFilename)
                pszStoreFilename++;
            szStoreProvider[i] = '\0';

            if (pwszStore = AllocAndSzToWsz(pszStoreFilename)) {
                if (0 == _stricmp("ldap", szStoreProvider) &&
                        0 != (dwFlags & CERT_LDAP_STORE_OPENED_FLAG))
                    hStore = OpenLdapStore(dwFlags, pwszStore);
                else
                    hStore = CertOpenStore(
                        szStoreProvider,
                        dwCertEncodingType | dwMsgEncodingType,
                        0,                      // hCryptProv
                        dwFlags,
                        (const void *) pwszStore
                        );
                TestFree(pwszStore);
            }
        } else if (0 == _strnicmp("rel:", pszStoreFilename, 4)) {
            CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

            pszStoreFilename += 4;
            RelocatePara.hKeyBase = OpenRelocateKey(&pszStoreFilename, dwFlags);
            RelocatePara.pszSystemStore = pszStoreFilename;

            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            dwFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;

            hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_A,
                    dwCertEncodingType | dwMsgEncodingType,
                    0,                      // hCryptProv
                    dwFlags,
                    (const void *) &RelocatePara
                    );
            CloseRelocateKey(RelocatePara.hKeyBase);
        } else if (0 == _strnicmp("relsys:", pszStoreFilename, 7)) {
            CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

            pszStoreFilename += 7;
            RelocatePara.hKeyBase = OpenRelocateKey(&pszStoreFilename, dwFlags);
            RelocatePara.pszSystemStore = pszStoreFilename;

            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            dwFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;

            hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_REGISTRY_A,
                    dwCertEncodingType | dwMsgEncodingType,
                    0,                      // hCryptProv
                    dwFlags,
                    (const void *) &RelocatePara
                    );
            CloseRelocateKey(RelocatePara.hKeyBase);
        } else if (0 == _strnicmp("relphy:", pszStoreFilename, 7)) {
            LPWSTR pwszStore;
            CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

            pszStoreFilename += 7;
            RelocatePara.hKeyBase = OpenRelocateKey(&pszStoreFilename, dwFlags);

            if (pwszStore = AllocAndSzToWsz(pszStoreFilename)) {
                RelocatePara.pwszSystemStore = pwszStore;

                if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                    dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
                dwFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;

                hStore = CertOpenStore(
                        CERT_STORE_PROV_PHYSICAL_W,
                        dwCertEncodingType | dwMsgEncodingType,
                        0,                      // hCryptProv
                        dwFlags,
                        (const void *) &RelocatePara
                        );
                TestFree(pwszStore);
            }
            CloseRelocateKey(RelocatePara.hKeyBase);
        } else if (0 != (dwFlags & ~CERT_STORE_SET_LOCALIZED_NAME_FLAG)) {
            if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
                dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
            hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_A,
                    dwCertEncodingType | dwMsgEncodingType,
                    0,                      // hCryptProv
                    dwFlags,
                    (const void *) pszStoreFilename
                    );
        } else
            hStore = CertOpenSystemStore(NULL, pszStoreFilename);

    } else
        hStore = CertOpenStore(
                CERT_STORE_PROV_FILENAME_A,
                dwCertEncodingType | dwMsgEncodingType,
                0,                      // hCryptProv
                dwFlags,
                (const void *) pszStoreFilename
                );

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        if (NULL != hStore)
            printf(
                "failed => CERT_STORE_DELETE_FLAG returned non-NULL hStore\n");
        else {
            if (0 == GetLastError())
                printf("Successful delete store\n");
            else
                PrintLastError("CertOpenStore(CERT_STORE_DELETE_FLAG)");
        }

        hStore = NULL;
    } else if (NULL == hStore) {
        DWORD dwErr = GetLastError();
        printf("NULL OpenStoreEx %d 0x%x\n", dwErr, dwErr);
    } else {
        if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG) {
            LPWSTR pwszLocalizedName;
            DWORD cbLocalizedName;

            if (!CertGetStoreProperty(
                    hStore,
                    CERT_STORE_LOCALIZED_NAME_PROP_ID,
                    NULL,
                    &cbLocalizedName
                    )) {
                if (CRYPT_E_NOT_FOUND == GetLastError())
                    printf("No localized store name property\n");
                else
                    PrintLastError("CertGetStoreProperty");
            } else if (pwszLocalizedName = (LPWSTR) TestAlloc(
                    cbLocalizedName)) {
                if (!CertGetStoreProperty(
                        hStore,
                        CERT_STORE_LOCALIZED_NAME_PROP_ID,
                        pwszLocalizedName,
                        &cbLocalizedName
                        ))
                    PrintLastError("CertGetStoreProperty");
                else
                    printf("Localized Store Name:: %S\n", pwszLocalizedName);
                TestFree(pwszLocalizedName);
            }
        }

        DWORD dwAccessStateFlags;
        DWORD cbData = sizeof(dwAccessStateFlags);

        CertGetStoreProperty(
            hStore,
            CERT_ACCESS_STATE_PROP_ID,
            &dwAccessStateFlags,
            &cbData
            );
        if (0 == cbData)
            printf("No Store AccessState PropId\n");
        else {
            printf("Store AccessState PropId dwFlags:: 0x%x",
                dwAccessStateFlags);
            if (dwAccessStateFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG)
                printf(" WRITE_PERSIST");
            if (dwAccessStateFlags & CERT_ACCESS_STATE_SYSTEM_STORE_FLAG)
                printf(" SYSTEM_STORE");
            if (dwAccessStateFlags & CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG)
                printf(" LM_SYSTEM_STORE");
            printf("\n");
        }
    }
    return hStore;
}

HCERTSTORE OpenSystemStoreOrFile(BOOL fSystemStore, LPCSTR pszStoreFilename,
    DWORD dwFlags)
{
    HCERTSTORE hStore;

    hStore = OpenStoreEx2(fSystemStore, pszStoreFilename, dwFlags);
    if (hStore == NULL) {
        DWORD dwErr = GetLastError();
        printf( "can't open %s\n", pszStoreFilename);
        SetLastError(dwErr);
        PrintLastError("CertOpenStore");
    }
    return hStore;
}

HCERTSTORE OpenStoreEx(BOOL fSystemStore, LPCSTR pszStoreFilename,
    DWORD dwFlags)
{
    HCERTSTORE hStore;
    hStore = OpenStoreEx2(fSystemStore, pszStoreFilename, dwFlags);

    if (hStore == NULL) {
        printf( "can't open %s\n", pszStoreFilename);
        hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
    }

    if (hStore == NULL)
        PrintLastError("CertOpenStore");

    return hStore;
}

HCERTSTORE OpenStore(BOOL fSystemStore, LPCSTR pszStoreFilename)
{
    return OpenStoreEx(fSystemStore, pszStoreFilename, 0);
}

HCERTSTORE OpenStoreOrSpc(BOOL fSystemStore, LPCSTR pszStoreFilename,
    BOOL *pfSpc)
{
    *pfSpc = FALSE;
    return OpenStore(fSystemStore, pszStoreFilename);
}


void SaveStore(HCERTSTORE hStore, LPCSTR pszSaveFilename)
{
    HANDLE hFile;
    hFile = CreateFile(pszSaveFilename,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        printf( "can't open %s\n", pszSaveFilename);
        PrintLastError("CloseStore::CreateFile");
    } else {
        printf("Saving store to %s\n", pszSaveFilename);
        if (!CertSaveStore(
                hStore,
                0,                          // dwEncodingType,
                CERT_STORE_SAVE_AS_STORE,
                CERT_STORE_SAVE_TO_FILE,
                (void *) hFile,
                0                           // dwFlags
                ))
            PrintLastError("CertSaveStore");
        CloseHandle(hFile);
    }
}

void SaveStoreEx(HCERTSTORE hStore, BOOL fPKCS7Save, LPCSTR pszSaveFilename)
{
    DWORD dwSaveAs;
    if (fPKCS7Save) {
        dwSaveAs = CERT_STORE_SAVE_AS_PKCS7;
        printf("Saving store as PKCS #7 to %s\n", pszSaveFilename);
    } else {
        dwSaveAs = CERT_STORE_SAVE_AS_STORE;
        printf("Saving store to %s\n", pszSaveFilename);
    }

    if (!CertSaveStore(
            hStore,
            dwCertEncodingType | dwMsgEncodingType,
            dwSaveAs,
            CERT_STORE_SAVE_TO_FILENAME_A,
            (void *) pszSaveFilename,
            0                   // dwFlags
            ))
        PrintLastError("CertSaveStore");
}

LPCWSTR GetOIDName(LPCSTR pszOID, DWORD dwGroupId)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            )) {
        if (L'\0' != pInfo->pwszName[0])
            return pInfo->pwszName;
    }

    return L"???";
}

ALG_ID GetAlgid(LPCSTR pszOID, DWORD dwGroupId)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            dwGroupId
            ))
        return pInfo->Algid;
    return 0;
}

static void GetSignAlgids(
    IN LPCSTR pszOID,
    OUT ALG_ID *paiHash,
    OUT ALG_ID *paiPubKey
    )
{
    PCCRYPT_OID_INFO pInfo;

    *paiHash = 0;
    *paiPubKey = 0;
    if (pInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            (void *) pszOID,
            CRYPT_SIGN_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pInfo->ExtraInfo.pbData;

        *paiHash = pInfo->Algid;
        if (1 <= cExtra)
            *paiPubKey = pdwExtra[0];
    }
}


void DisplayVerifyFlags(LPSTR pszHdr, DWORD dwFlags)
{
    if (dwFlags == CERT_STORE_TIME_VALIDITY_FLAG)
        printf("*****  %s: Warning:: Time Invalid\n", pszHdr);
    else if (dwFlags != 0) {
        printf("*****  %s: Failed Verification Checks:: ", pszHdr);
        if (dwFlags & CERT_STORE_SIGNATURE_FLAG)
            printf("SIGNATURE ");
        if (dwFlags & CERT_STORE_TIME_VALIDITY_FLAG)
            printf("TIME ");
        if (dwFlags & CERT_STORE_REVOCATION_FLAG)
            printf("REVOCATION ");
        if (dwFlags & CERT_STORE_NO_CRL_FLAG)
            printf("NO_CRL ");
        if (dwFlags & CERT_STORE_NO_ISSUER_FLAG)
            printf("NO_ISSUER ");
        if (dwFlags & CERT_STORE_DELTA_CRL_FLAG)
            printf("NOT_DELTA_CRL ");
        if (dwFlags & CERT_STORE_BASE_CRL_FLAG)
            printf("NOT_BASE_CRL ");
        printf("\n");
    }
}

static void DisplayThumbprint(
    LPCSTR pszHash,
    BYTE *pbHash,
    DWORD cbHash
    )
{
    printf("%s Thumbprint:: ", pszHash);
    if (cbHash == 0)
        printf("???");
    else {
        ULONG cb;

        while (cbHash > 0) {
            cb = min(4, cbHash);
            cbHash -= cb;
            for (; cb > 0; cb--, pbHash++)
                printf("%02X", *pbHash);
            printf(" ");
        }
    }
    printf("\n");
}

static void DisplaySerialNumber(
    PCRYPT_INTEGER_BLOB pSerialNumber
    )
{
    DWORD cb;
    BYTE *pb;
    for (cb = pSerialNumber->cbData,
         pb = pSerialNumber->pbData + (cb - 1); cb > 0; cb--, pb--) {
        printf(" %02X", *pb);
    }
}

static void DisplayAnyString(
    LPCSTR pszPrefix,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags
    )
{
    PCERT_NAME_VALUE pInfo = NULL;

    if (NULL == (pInfo = (PCERT_NAME_VALUE) TestNoCopyDecodeObject(
            X509_UNICODE_ANY_STRING,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->dwValueType == CERT_RDN_ENCODED_BLOB ||
            pInfo->dwValueType == CERT_RDN_OCTET_STRING) {
        printf("%s ValueType: %d\n", pszPrefix, pInfo->dwValueType);
        PrintBytes("    ", pInfo->Value.pbData, pInfo->Value.cbData);
    } else
        printf("%s ValueType: %d String: %S\n",
            pszPrefix, pInfo->dwValueType, pInfo->Value.pbData);

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayBits(
    LPCSTR pszPrefix,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_BIT_BLOB pInfo = NULL;

    if (NULL == (pInfo = (PCRYPT_BIT_BLOB) TestNoCopyDecodeObject(
            X509_BITS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    printf("%s", pszPrefix);
    if (1 == pInfo->cbData) {
        printf(" %02X", *pInfo->pbData);
        if (pInfo->cUnusedBits)
            printf(" UnusedBits: %d\n", pInfo->cUnusedBits);
        else
            printf("\n");
    } else {
        if (pInfo->cbData) {
            printf("\n");
            PrintBytes("    ", pInfo->pbData, pInfo->cbData);
            printf("    UnusedBits: %d\n", pInfo->cUnusedBits);
        } else
            printf(" NONE\n");
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayInteger(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    int iInfo = 0;
    DWORD cbInfo;

    cbInfo = sizeof(iInfo);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_INTEGER,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &iInfo,
            &cbInfo
            )) {
        PrintLastError("IntegerDecode");
        goto CommonReturn;
    }

    printf("  Integer:: %d (0x%x)\n", iInfo, iInfo);

CommonReturn:
    return;
}

static void DisplayOctetString(
    LPCSTR pszPrefix,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_DATA_BLOB pInfo = NULL;

    if (NULL == (pInfo = (PCRYPT_DATA_BLOB) TestNoCopyDecodeObject(
            X509_OCTET_STRING,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    printf("%s", pszPrefix);
    if (pInfo->cbData) {
        printf("\n");
        PrintBytes("    ", pInfo->pbData, pInfo->cbData);
    } else
        printf(" NONE\n");

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded, DWORD dwDisplayFlags)
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;

#if 0
    {
        CERT_NAME_BLOB Name;
        DWORD cwsz;
        LPWSTR pwsz;
        DWORD csz;
        LPSTR psz;
        Name.pbData = pbEncoded;
        Name.cbData = cbEncoded;

        DWORD rgdwStrType[] = {
            CERT_SIMPLE_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG |
                CERT_NAME_STR_NO_PLUS_FLAG | CERT_NAME_STR_NO_QUOTING_FLAG,
            CERT_OID_NAME_STR,
            CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG |
                CERT_NAME_STR_NO_QUOTING_FLAG,
            0
        };

        DWORD *pdwStrType;

        cwsz = CertNameToStrW(
            dwCertEncodingType,
            &Name,
            CERT_X500_NAME_STR,
            NULL,                   // pwsz
            0);                     // cwsz
        if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
            CertNameToStrW(
                dwCertEncodingType,
                &Name,
                CERT_X500_NAME_STR,
                pwsz,
                cwsz);
            printf("  %S\n", pwsz);
            TestFree(pwsz);
        }

        for (pdwStrType = rgdwStrType; *pdwStrType; pdwStrType++) {
            csz = CertNameToStrA(
                dwCertEncodingType,
                &Name,
                *pdwStrType,
                NULL,                   // psz
                0);                     // csz
            if (psz = (LPSTR) TestAlloc(csz)) {
                CertNameToStrA(
                    dwCertEncodingType,
                    &Name,
                    *pdwStrType,
                    psz,
                    csz);
                printf("  %s\n", psz);
                TestFree(psz);
            }
        }
    }
#endif

    if (NULL == (pInfo = (PCERT_NAME_INFO) TestNoCopyDecodeObject(
            X509_NAME,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) {
        for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) {
            LPSTR pszObjId = pAttr->pszObjId;
            if (pszObjId == NULL)
                pszObjId = "<NULL OBJID>";
            if ((dwDisplayFlags & DISPLAY_VERBOSE_FLAG) ||
                (pAttr->dwValueType == CERT_RDN_ENCODED_BLOB) ||
                (pAttr->dwValueType == CERT_RDN_OCTET_STRING)) {
                printf("  [%d,%d] %s (%S) ValueType: %d\n",
                    i, j, pszObjId, GetOIDName(pszObjId), pAttr->dwValueType);
                PrintBytes("    ", pAttr->Value.pbData, pAttr->Value.cbData);
            } else if (pAttr->dwValueType == CERT_RDN_UNIVERSAL_STRING) {
                printf("  [%d,%d] %s (%S)",
                    i, j, pszObjId, GetOIDName(pszObjId));

                DWORD cdw = pAttr->Value.cbData / 4;
                DWORD *pdw = (DWORD *) pAttr->Value.pbData;
                for ( ; cdw > 0; cdw--, pdw++)
                    printf(" 0x%08X", *pdw);
                printf("\n");

                DWORD csz;
                csz = CertRDNValueToStrA(
                    pAttr->dwValueType,
                    &pAttr->Value,
                    NULL,               // psz
                    0                   // csz
                    );
                if (csz > 1) {
                    LPSTR psz = (LPSTR) TestAlloc(csz);
                    if (psz) {
                        CertRDNValueToStrA(
                            pAttr->dwValueType,
                            &pAttr->Value,
                            psz,
                            csz
                            );
                        printf("    Str: %s\n", psz);
                        PrintBytes("    ", (BYTE *) psz, csz);
                        TestFree(psz);
                    }
                }

                DWORD cwsz;
                cwsz = CertRDNValueToStrW(
                    pAttr->dwValueType,
                    &pAttr->Value,
                    NULL,               // pwsz
                    0                   // cwsz
                    );
                if (cwsz > 1) {
                    LPWSTR pwsz =
                        (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR));
                    if (pwsz) {
                        CertRDNValueToStrW(
                            pAttr->dwValueType,
                            &pAttr->Value,
                            pwsz,
                            cwsz
                            );
                        printf("    WStr: %S\n", pwsz);
                        PrintBytes("    ", (BYTE *) pwsz, cwsz * sizeof(WCHAR));
                        TestFree(pwsz);
                    }
                }
            } else if (pAttr->dwValueType == CERT_RDN_BMP_STRING ||
                    pAttr->dwValueType == CERT_RDN_UTF8_STRING) {
                printf("  [%d,%d] %s (%S) %S\n",
                    i, j, pszObjId, GetOIDName(pszObjId), pAttr->Value.pbData);
            } else
                printf("  [%d,%d] %s (%S) %s\n",
                    i, j, pszObjId, GetOIDName(pszObjId), pAttr->Value.pbData);
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static void DisplayAltNameEntry(
    PCERT_ALT_NAME_ENTRY pEntry,
    DWORD dwDisplayFlags)
{

    switch (pEntry->dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        printf("OtherName: %s\n", pEntry->pOtherName->pszObjId);
        PrintBytes("    ", pEntry->pOtherName->Value.pbData,
            pEntry->pOtherName->Value.cbData);
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
        printf("X400Address:\n");
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        printf("DirectoryName:\n");
        DecodeName(pEntry->DirectoryName.pbData,
            pEntry->DirectoryName.cbData, dwDisplayFlags);
        break;
    case CERT_ALT_NAME_EDI_PARTY_NAME:
        printf("EdiPartyName:\n");
        break;
    case CERT_ALT_NAME_RFC822_NAME:
        printf("RFC822: %S\n", pEntry->pwszRfc822Name);
        break;
    case CERT_ALT_NAME_DNS_NAME:
        printf("DNS: %S\n", pEntry->pwszDNSName);
        break;
    case CERT_ALT_NAME_URL:
        printf("URL: %S\n", pEntry->pwszURL);
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        printf("IPAddress:\n");
        PrintBytes("    ", pEntry->IPAddress.pbData, pEntry->IPAddress.cbData);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        printf("RegisteredID: %s\n", pEntry->pszRegisteredID);
        break;
    default:
        printf("Unknown choice: %d\n", pEntry->dwAltNameChoice);
    }
}

static void DisplayAltName(
    PCERT_ALT_NAME_INFO pInfo,
    DWORD dwDisplayFlags)
{
    DWORD i;
    PCERT_ALT_NAME_ENTRY pEntry = pInfo->rgAltEntry;
    DWORD cEntry = pInfo->cAltEntry;

    for (i = 0; i < cEntry; i++, pEntry++) {
        printf("    [%d] ", i);
        DisplayAltNameEntry(pEntry, dwDisplayFlags);
    }
}

static void DecodeAndDisplayAltName(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_ALT_NAME_INFO pInfo = NULL;

    if (NULL == (pInfo = (PCERT_ALT_NAME_INFO) TestNoCopyDecodeObject(
            X509_ALTERNATE_NAME,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    DisplayAltName(pInfo, dwDisplayFlags);

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayAuthorityKeyIdExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_AUTHORITY_KEY_ID_INFO pInfo;
    printf("  <AuthorityKeyId>\n");
    if (NULL == (pInfo = (PCERT_AUTHORITY_KEY_ID_INFO) TestNoCopyDecodeObject(
            X509_AUTHORITY_KEY_ID,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->KeyId.cbData) {
        printf("  KeyId::\n");
        PrintBytes("    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->CertIssuer.cbData) {
        printf("  CertIssuer::\n");
        DecodeName(pInfo->CertIssuer.pbData, pInfo->CertIssuer.cbData,
            dwDisplayFlags);
    }
    if (pInfo->CertSerialNumber.cbData) {
        printf("  CertSerialNumber::");
        DisplaySerialNumber(&pInfo->CertSerialNumber);
        printf("\n");
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayAuthorityKeyId2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_AUTHORITY_KEY_ID2_INFO pInfo;
    printf("  <AuthorityKeyId #2>\n");
    if (NULL == (pInfo = (PCERT_AUTHORITY_KEY_ID2_INFO) TestNoCopyDecodeObject(
            X509_AUTHORITY_KEY_ID2,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->KeyId.cbData) {
        printf("  KeyId::\n");
        PrintBytes("    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->AuthorityCertIssuer.cAltEntry) {
        printf("  AuthorityCertIssuer::\n");
        DisplayAltName(&pInfo->AuthorityCertIssuer, dwDisplayFlags);
    }
    if (pInfo->AuthorityCertSerialNumber.cbData) {
        printf("  AuthorityCertSerialNumber::");
        DisplaySerialNumber(&pInfo->AuthorityCertSerialNumber);
        printf("\n");
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayKeyAttrExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_KEY_ATTRIBUTES_INFO pInfo;
    if (NULL == (pInfo = (PCERT_KEY_ATTRIBUTES_INFO) TestNoCopyDecodeObject(
            X509_KEY_ATTRIBUTES,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->KeyId.cbData) {
        printf("  KeyId::\n");
        PrintBytes("    ", pInfo->KeyId.pbData, pInfo->KeyId.cbData);
    }

    if (pInfo->IntendedKeyUsage.cbData) {
        BYTE bFlags = *pInfo->IntendedKeyUsage.pbData;

        printf("  IntendedKeyUsage:: ");
        if (bFlags == 0)
            printf("<NONE> ");
        if (bFlags & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
            printf("DIGITAL_SIGNATURE ");
        if (bFlags &  CERT_NON_REPUDIATION_KEY_USAGE)
            printf("NON_REPUDIATION ");
        if (bFlags & CERT_KEY_ENCIPHERMENT_KEY_USAGE)
            printf("KEY_ENCIPHERMENT ");
        if (bFlags & CERT_DATA_ENCIPHERMENT_KEY_USAGE)
            printf("DATA_ENCIPHERMENT ");
        if (bFlags & CERT_KEY_AGREEMENT_KEY_USAGE)
            printf("KEY_AGREEMENT ");
        if (bFlags & CERT_KEY_CERT_SIGN_KEY_USAGE)
            printf("KEY_CERT ");
        if (bFlags & CERT_OFFLINE_CRL_SIGN_KEY_USAGE)
            printf("OFFLINE_CRL_SIGN ");
        printf("\n");
    }

    if (pInfo->pPrivateKeyUsagePeriod) {
        PCERT_PRIVATE_KEY_VALIDITY p = pInfo->pPrivateKeyUsagePeriod;
        printf("  NotBefore:: %s\n", FileTimeText(&p->NotBefore));
        printf("  NotAfter:: %s\n", FileTimeText(&p->NotAfter));
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayKeyUsageRestrictionExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo;
    if (NULL == (pInfo =
            (PCERT_KEY_USAGE_RESTRICTION_INFO) TestNoCopyDecodeObject(
                X509_KEY_USAGE_RESTRICTION,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    if (pInfo->cCertPolicyId) {
        DWORD i, j;
        printf("  CertPolicySet::\n");

        PCERT_POLICY_ID pPolicyId = pInfo->rgCertPolicyId;
        for (i = 0; i < pInfo->cCertPolicyId; i++, pPolicyId++) {
            if (pPolicyId->cCertPolicyElementId == 0)
                printf("     [%d,*] <NO ELEMENTS>\n", i);
            LPSTR *ppszObjId = pPolicyId->rgpszCertPolicyElementId;
            for (j = 0; j < pPolicyId->cCertPolicyElementId; j++, ppszObjId++) {
                LPSTR pszObjId = *ppszObjId;
                if (pszObjId == NULL)
                    pszObjId = "<NULL OBJID>";
                printf("     [%d,%d] %s\n", i, j, pszObjId);
            }
        }
    }

    if (pInfo->RestrictedKeyUsage.cbData) {
        BYTE bFlags = *pInfo->RestrictedKeyUsage.pbData;

        printf("  RestrictedKeyUsage:: ");
        if (bFlags == 0)
            printf("<NONE> ");
        if (bFlags & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
            printf("DIGITAL_SIGNATURE ");
        if (bFlags &  CERT_NON_REPUDIATION_KEY_USAGE)
            printf("NON_REPUDIATION ");
        if (bFlags & CERT_KEY_ENCIPHERMENT_KEY_USAGE)
            printf("KEY_ENCIPHERMENT ");
        if (bFlags & CERT_DATA_ENCIPHERMENT_KEY_USAGE)
            printf("DATA_ENCIPHERMENT ");
        if (bFlags & CERT_KEY_AGREEMENT_KEY_USAGE)
            printf("KEY_AGREEMENT ");
        if (bFlags & CERT_KEY_CERT_SIGN_KEY_USAGE)
            printf("KEY_CERT ");
        if (bFlags & CERT_OFFLINE_CRL_SIGN_KEY_USAGE)
            printf("OFFLINE_CRL_SIGN ");
        printf("\n");
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayBasicConstraintsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_BASIC_CONSTRAINTS_INFO pInfo;
    if (NULL == (pInfo = (PCERT_BASIC_CONSTRAINTS_INFO) TestNoCopyDecodeObject(
            X509_BASIC_CONSTRAINTS,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    printf("  SubjectType:: ");
    if (pInfo->SubjectType.cbData == 0)
        printf("<NONE> ");
    else {
        BYTE bSubjectType = *pInfo->SubjectType.pbData;
        if (bSubjectType == 0)
            printf("<NONE> ");
        if (bSubjectType & CERT_CA_SUBJECT_FLAG)
            printf("CA ");
        if (bSubjectType & CERT_END_ENTITY_SUBJECT_FLAG)
            printf("END_ENTITY ");
    }
    printf("\n");

    printf("  PathLenConstraint:: ");
    if (pInfo->fPathLenConstraint)
        printf("%d", pInfo->dwPathLenConstraint);
    else
        printf("<NONE>");
    printf("\n");

    if (pInfo->cSubtreesConstraint) {
        DWORD i;
        PCERT_NAME_BLOB pSubtrees = pInfo->rgSubtreesConstraint;
        for (i = 0; i < pInfo->cSubtreesConstraint; i++, pSubtrees++) {
            printf("  SubtreesConstraint[%d]::\n", i);
            DecodeName(pSubtrees->pbData, pSubtrees->cbData, dwDisplayFlags);
        }
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_BIT_BLOB pInfo;
    BYTE bFlags;

    if (NULL == (pInfo =
            (PCRYPT_BIT_BLOB) TestNoCopyDecodeObject(
                X509_KEY_USAGE,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    printf("  KeyUsage:: ");
    if (pInfo->cbData)
        bFlags = *pInfo->pbData;
    else
        bFlags = 0;

    if (bFlags == 0)
        printf("<NONE> ");
    if (bFlags & CERT_DIGITAL_SIGNATURE_KEY_USAGE)
        printf("DIGITAL_SIGNATURE ");
    if (bFlags &  CERT_NON_REPUDIATION_KEY_USAGE)
        printf("NON_REPUDIATION ");
    if (bFlags & CERT_KEY_ENCIPHERMENT_KEY_USAGE)
        printf("KEY_ENCIPHERMENT ");
    if (bFlags & CERT_DATA_ENCIPHERMENT_KEY_USAGE)
        printf("DATA_ENCIPHERMENT ");
    if (bFlags & CERT_KEY_AGREEMENT_KEY_USAGE)
        printf("KEY_AGREEMENT ");
    if (bFlags & CERT_KEY_CERT_SIGN_KEY_USAGE)
        printf("KEY_CERT ");
    if (bFlags & CERT_OFFLINE_CRL_SIGN_KEY_USAGE)
        printf("OFFLINE_CRL_SIGN ");
    printf("\n");


ErrorReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayBasicConstraints2Extension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo;
    if (NULL == (pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) TestNoCopyDecodeObject(
            X509_BASIC_CONSTRAINTS2,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    
    printf("  Basic Constraints:: ");
    if (pInfo->fCA)
        printf("CA\n");
    else
        printf("End-user\n");

    printf("  PathLenConstraint:: ");
    if (pInfo->fPathLenConstraint)
        printf("%d", pInfo->dwPathLenConstraint);
    else
        printf("<NONE>");
    printf("\n");

ErrorReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayPoliciesExtension(
    LPSTR pszType,          // "Certificate" | "Revocation" | "Application"
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_POLICIES_INFO pInfo;
    DWORD cPolicy;
    PCERT_POLICY_INFO pPolicy;
    DWORD i;

    if (NULL == (pInfo =
            (PCERT_POLICIES_INFO) TestNoCopyDecodeObject(
                X509_CERT_POLICIES,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    cPolicy = pInfo->cPolicyInfo;
    pPolicy = pInfo->rgPolicyInfo;

    if (cPolicy == 0)
        printf("  No %s Policies\n", pszType);
    else
        printf("  %s Policies::\n", pszType);

    for (i = 0; i < cPolicy; i++, pPolicy++) {
        DWORD cQualifier = pPolicy->cPolicyQualifier;
        PCERT_POLICY_QUALIFIER_INFO pQualifier;
        DWORD j;
        if (pPolicy->pszPolicyIdentifier)
            printf("    [%d] %s", i, pPolicy->pszPolicyIdentifier);
        if (cQualifier)
            printf(" Qualifiers::");
        printf("\n");

        pQualifier = pPolicy->rgPolicyQualifier;
        for (j = 0; j < cQualifier; j++, pQualifier++) {
            printf("      [%d] %s", j, pQualifier->pszPolicyQualifierId);
            if (pQualifier->Qualifier.cbData) {
                printf(" Encoded Data::\n");
                PrintBytes("    ",
                    pQualifier->Qualifier.pbData, pQualifier->Qualifier.cbData);
            } else
                printf("\n");
                    
        }
    }

ErrorReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplaySMIMECapabilitiesExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_SMIME_CAPABILITIES pInfo;
    DWORD cCap;
    PCRYPT_SMIME_CAPABILITY pCap;
    DWORD i;

    if (NULL == (pInfo =
            (PCRYPT_SMIME_CAPABILITIES) TestNoCopyDecodeObject(
                PKCS_SMIME_CAPABILITIES,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    cCap = pInfo->cCapability;
    pCap = pInfo->rgCapability;

    if (cCap == 0)
        printf("  No SMIME Capabilities\n");
    else
        printf("  SMIME Capabilties::\n");

    for (i = 0; i < cCap; i++, pCap++) {
        LPSTR pszObjId = pCap->pszObjId;
        printf("    [%d] %s (%S)", i, pszObjId, GetOIDName(pszObjId));
        if (pCap->Parameters.cbData) {
            printf(" Parameters::\n");
            PrintBytes("      ",
                pCap->Parameters.pbData,
                pCap->Parameters.cbData);
        } else
            printf("\n");
    }

ErrorReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DecodeAndDisplayCtlUsage(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCTL_USAGE pInfo;
    DWORD cId;
    LPSTR *ppszId;
    DWORD i;

    if (NULL == (pInfo =
            (PCTL_USAGE) TestNoCopyDecodeObject(
                X509_ENHANCED_KEY_USAGE,
                pbEncoded,
                cbEncoded
                ))) goto ErrorReturn;

    cId = pInfo->cUsageIdentifier;
    ppszId = pInfo->rgpszUsageIdentifier;

    if (cId == 0)
        printf("    No Usage Identifiers\n");

    for (i = 0; i < cId; i++, ppszId++)
        printf("    [%d] %s\n", i, *ppszId);

ErrorReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayEnhancedKeyUsageExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    printf("  EnhancedKeyUsage::\n");
    DecodeAndDisplayCtlUsage(pbEncoded, cbEncoded, dwDisplayFlags);
}

static void DisplayAltNameExtension(
    LPCSTR pszExt,
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    printf("  <%s>\n", pszExt);
    DecodeAndDisplayAltName(pbEncoded, cbEncoded, dwDisplayFlags);
}

static void DisplayNameConstraintsSubtree(
    DWORD cSubtree,
    PCERT_GENERAL_SUBTREE pSubtree,
    DWORD dwDisplayFlags
    )
{
    DWORD i;

    for (i = 0; i < cSubtree; i++, pSubtree++) {
        printf("    Subtree[%d] ", i);
        if (pSubtree->dwMinimum || pSubtree->fMaximum) {
            printf("(%d ", pSubtree->dwMinimum);
            if (pSubtree->fMaximum)
                printf("- %d)  ", pSubtree->dwMaximum);
            else
                printf("...)  ");
        }
        DisplayAltNameEntry(&pSubtree->Base, dwDisplayFlags);
    }

}
static void DisplayNameConstraintsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_NAME_CONSTRAINTS_INFO pInfo = NULL;

    if (NULL == (pInfo = (PCERT_NAME_CONSTRAINTS_INFO) TestNoCopyDecodeObject(
            X509_NAME_CONSTRAINTS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->cPermittedSubtree) {
        printf("  <PermittedSubtree>\n");
        DisplayNameConstraintsSubtree(pInfo->cPermittedSubtree,
            pInfo->rgPermittedSubtree, dwDisplayFlags);
    } else
        printf("  No PermittedSubtree\n");

    if (pInfo->cExcludedSubtree) {
        printf("  <ExcludedSubtree>\n");
        DisplayNameConstraintsSubtree(pInfo->cExcludedSubtree,
            pInfo->rgExcludedSubtree, dwDisplayFlags);
    } else
        printf("  No ExcludedSubtree\n");


CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayPolicyMappingsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_POLICY_MAPPINGS_INFO pInfo = NULL;
    DWORD i;

    if (NULL == (pInfo = (PCERT_POLICY_MAPPINGS_INFO) TestNoCopyDecodeObject(
            X509_POLICY_MAPPINGS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->cPolicyMapping) {
        for (i = 0; i < pInfo->cPolicyMapping; i++) {
            printf("  [%d] Issuer: %s  Subject: %s\n", i,
                pInfo->rgPolicyMapping[i].pszIssuerDomainPolicy,
                pInfo->rgPolicyMapping[i].pszSubjectDomainPolicy);
        }
    } else
        printf("  No PolicyMappings\n");

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayPolicyConstraintsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_POLICY_CONSTRAINTS_INFO pInfo = NULL;

    if (NULL == (pInfo = (PCERT_POLICY_CONSTRAINTS_INFO) TestNoCopyDecodeObject(
            X509_POLICY_CONSTRAINTS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->fRequireExplicitPolicy)
        printf("  RequireExplicitPolicySkipCerts: %d",
            pInfo->dwRequireExplicitPolicySkipCerts);
    if (pInfo->fInhibitPolicyMapping)
        printf("  InhibitPolicyMappingSkipCerts: %d",
            pInfo->dwInhibitPolicyMappingSkipCerts);
    printf("\n");

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayCrossCertDistPointsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCROSS_CERT_DIST_POINTS_INFO pInfo = NULL;
    DWORD i;

    if (NULL == (pInfo = (PCROSS_CERT_DIST_POINTS_INFO) TestNoCopyDecodeObject(
            X509_CROSS_CERT_DIST_POINTS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    printf("  SyncDeltaTime (seconds) : %d\n", pInfo->dwSyncDeltaTime);
    for (i = 0; i < pInfo->cDistPoint; i++) {
        printf("  DistPoint[%d]\n", i);
        DisplayAltName(&pInfo->rgDistPoint[i], dwDisplayFlags);
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayAccessDescriptions(
    LPCSTR pszAccDescr,
    DWORD cAccDescr,
    PCERT_ACCESS_DESCRIPTION pAccDescr,
    DWORD dwDisplayFlags)
{
    DWORD i;

    for (i = 0; i < cAccDescr; i++, pAccDescr++) {
        printf("    %s[%d] %s ", pszAccDescr, i, pAccDescr->pszAccessMethod);
        DisplayAltNameEntry(&pAccDescr->AccessLocation, dwDisplayFlags);
    }
}

static void DisplayAuthorityInfoAccessExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_AUTHORITY_INFO_ACCESS pInfo = NULL;

    if (NULL == (pInfo = (PCERT_AUTHORITY_INFO_ACCESS) TestNoCopyDecodeObject(
            X509_AUTHORITY_INFO_ACCESS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    printf("  <AuthorityInfoAccess>\n");
    if (pInfo->cAccDescr)
        DisplayAccessDescriptions("",
            pInfo->cAccDescr, pInfo->rgAccDescr, dwDisplayFlags);

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayCrlDistPointsExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRL_DIST_POINTS_INFO pInfo = NULL;
    DWORD i;

    if (NULL == (pInfo = (PCRL_DIST_POINTS_INFO) TestNoCopyDecodeObject(
            X509_CRL_DIST_POINTS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 == pInfo->cDistPoint)
        printf("    NO CRL Distribution Points\n");
    else {
        DWORD cPoint = pInfo->cDistPoint;
        PCRL_DIST_POINT pPoint = pInfo->rgDistPoint;

        for (i = 0; i < cPoint; i++, pPoint++) {
            printf("  CRL Distribution Point[%d]\n", i);
            DWORD dwNameChoice = pPoint->DistPointName.dwDistPointNameChoice;
            switch (dwNameChoice) {
                case CRL_DIST_POINT_NO_NAME:
                    break;
                case CRL_DIST_POINT_FULL_NAME:
                    printf("    FullName:\n");
                    DisplayAltName(&pPoint->DistPointName.FullName,
                        dwDisplayFlags);
                    break;
                case CRL_DIST_POINT_ISSUER_RDN_NAME:
                    printf("    IssuerRDN: (Not Implemented)\n");
                    break;
                default:
                    printf("    Unknown name choice: %d\n", dwNameChoice);
            }

            if (pPoint->ReasonFlags.cbData) {
                BYTE bFlags;
                printf("    ReasonFlags: ");
                bFlags = *pPoint->ReasonFlags.pbData;

                if (bFlags == 0)
                    printf("<NONE> ");
                if (bFlags & CRL_REASON_UNUSED_FLAG)
                    printf("UNUSED ");
                if (bFlags & CRL_REASON_KEY_COMPROMISE_FLAG)
                    printf("KEY_COMPROMISE ");
                if (bFlags & CRL_REASON_CA_COMPROMISE_FLAG)
                    printf("CA_COMPROMISE ");
                if (bFlags & CRL_REASON_AFFILIATION_CHANGED_FLAG)
                    printf("AFFILIATION_CHANGED ");
                if (bFlags & CRL_REASON_SUPERSEDED_FLAG)
                    printf("SUPERSEDED ");
                if (bFlags & CRL_REASON_CESSATION_OF_OPERATION_FLAG)
                    printf("CESSATION_OF_OPERATION ");
                if (bFlags & CRL_REASON_CERTIFICATE_HOLD_FLAG)
                    printf("CERTIFICATE_HOLD ");
                printf("\n");
            }

            if (pPoint->CRLIssuer.cAltEntry) {
                printf("    CRLIssuer:");
                DisplayAltName(&pPoint->CRLIssuer, dwDisplayFlags);
            }
        }
    }

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplayIssuingDistPointExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRL_ISSUING_DIST_POINT pInfo = NULL;
    DWORD i;
    DWORD dwNameChoice;

    if (NULL == (pInfo = (PCRL_ISSUING_DIST_POINT) TestNoCopyDecodeObject(
            X509_ISSUING_DIST_POINT,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    dwNameChoice = pInfo->DistPointName.dwDistPointNameChoice;
    switch (dwNameChoice) {
        case CRL_DIST_POINT_NO_NAME:
            printf("  No DistPointName\n");
            break;
        case CRL_DIST_POINT_FULL_NAME:
            printf("  DistPointName FullName:\n");
            DisplayAltName(&pInfo->DistPointName.FullName,
                dwDisplayFlags);
            break;
        case CRL_DIST_POINT_ISSUER_RDN_NAME:
            printf("  DistPointName IssuerRDN: (Not Implemented)\n");
            break;
        default:
            printf("  Unknown DistPointName choice: %d\n", dwNameChoice);
    }

    if (pInfo->fOnlyContainsUserCerts ||
            pInfo->fOnlyContainsCACerts ||
            pInfo->fIndirectCRL
            ) {
        printf(" ");
        if (pInfo->fOnlyContainsUserCerts)
            printf(" OnlyContainsUserCerts");
        if (pInfo->fOnlyContainsCACerts)
            printf(" OnlyContainsCACerts");
        if (pInfo->fIndirectCRL)
            printf(" IndirectCRL");
        printf("\n");
    }

    if (pInfo->OnlySomeReasonFlags.cbData) {
        BYTE bFlags;
        printf("  OnlySomeReasonFlags: ");
        bFlags = *pInfo->OnlySomeReasonFlags.pbData;

        if (bFlags == 0)
            printf("<NONE> ");
        if (bFlags & CRL_REASON_UNUSED_FLAG)
            printf("UNUSED ");
        if (bFlags & CRL_REASON_KEY_COMPROMISE_FLAG)
            printf("KEY_COMPROMISE ");
        if (bFlags & CRL_REASON_CA_COMPROMISE_FLAG)
            printf("CA_COMPROMISE ");
        if (bFlags & CRL_REASON_AFFILIATION_CHANGED_FLAG)
            printf("AFFILIATION_CHANGED ");
        if (bFlags & CRL_REASON_SUPERSEDED_FLAG)
            printf("SUPERSEDED ");
        if (bFlags & CRL_REASON_CESSATION_OF_OPERATION_FLAG)
            printf("CESSATION_OF_OPERATION ");
        if (bFlags & CRL_REASON_CERTIFICATE_HOLD_FLAG)
            printf("CERTIFICATE_HOLD ");
        printf("\n");
    }


CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplaySETAccountAliasExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    BOOL bInfo = FALSE;
    DWORD cbInfo;

    cbInfo = sizeof(bInfo);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            szOID_SET_ACCOUNT_ALIAS,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &bInfo,
            &cbInfo
            )) {
        PrintLastError("SETAccountAliasDecode");
        goto CommonReturn;
    }

    if (bInfo)
        printf("  SETAccountAlias:: TRUE\n");
    else
        printf("  SETAccountAlias:: FALSE\n");

CommonReturn:
    return;
}

static void DisplaySETHashedRootKeyExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    BYTE rgbInfo[SET_HASHED_ROOT_LEN];
    DWORD cbInfo;

    cbInfo = sizeof(rgbInfo);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            szOID_SET_HASHED_ROOT_KEY,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            rgbInfo,
            &cbInfo
            )) {
        PrintLastError("SETHashedRootKeyDecode");
        goto CommonReturn;
    }

    DisplayThumbprint("  SETHashedRootKey", rgbInfo, cbInfo);

CommonReturn:
    return;
}

static void DisplaySETCertTypeExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCRYPT_BIT_BLOB pInfo;
    if (NULL == (pInfo = (PCRYPT_BIT_BLOB) TestNoCopyDecodeObject(
            szOID_SET_CERTIFICATE_TYPE,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    printf("  SETCertificateType:: ");
    if (pInfo->cbData == 0)
        printf("<NONE> ");
    else {
        DWORD cb;
        BYTE *pb;
        for (cb = pInfo->cbData, pb = pInfo->pbData; cb > 0; cb--, pb++)
            printf(" %02X", *pb);
    }
    printf("\n");

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplaySETMerchantDataExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PSET_MERCHANT_DATA_INFO pInfo;
    if (NULL == (pInfo = (PSET_MERCHANT_DATA_INFO) TestNoCopyDecodeObject(
            szOID_SET_MERCHANT_DATA,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    printf("  SETMerchantData:: \n");
    if(pInfo->pszMerID && *pInfo->pszMerID)
        printf("    MerID: %s\n", pInfo->pszMerID);
    if(pInfo->pszMerAcquirerBIN && *pInfo->pszMerAcquirerBIN)
        printf("    MerAcquirerBIN: %s\n", pInfo->pszMerAcquirerBIN);
    if(pInfo->pszMerTermID && *pInfo->pszMerTermID)
        printf("    MerTermID: %s\n", pInfo->pszMerTermID);
    if(pInfo->pszMerName && *pInfo->pszMerName)
        printf("    MerName: %s\n", pInfo->pszMerName);
    if(pInfo->pszMerCity && *pInfo->pszMerCity)
        printf("    MerCity: %s\n", pInfo->pszMerCity);
    if(pInfo->pszMerStateProvince && *pInfo->pszMerStateProvince)
        printf("    MerStateProvince: %s\n", pInfo->pszMerStateProvince);
    if(pInfo->pszMerPostalCode && *pInfo->pszMerPostalCode)
        printf("    MerPostalCode: %s\n", pInfo->pszMerPostalCode);
    if(pInfo->pszMerCountry && *pInfo->pszMerCountry)
        printf("    MerCountry: %s\n", pInfo->pszMerCountry);
    if(pInfo->pszMerPhone && *pInfo->pszMerPhone)
        printf("    MerPhone: %s\n", pInfo->pszMerPhone);
    if(pInfo->fMerPhoneRelease)
        printf("    MerPhoneRelease: TRUE\n");
    else
        printf("    MerPhoneRelease: FALSE\n");
    if(pInfo->fMerAuthFlag)
        printf("    MerAuthFlag: TRUE\n");
    else
        printf("    MerAuthFlag: FALSE\n");

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}
#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

static char *GuidText(GUID *pguid)
{
    static char buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    sprintf(buf, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}


void DisplaySpcLink(PSPC_LINK pSpcLink)
{
    switch (pSpcLink->dwLinkChoice) {
    case SPC_URL_LINK_CHOICE:
        printf("URL=> %S\n", pSpcLink->pwszUrl);
        break;
    case SPC_MONIKER_LINK_CHOICE:
        printf("%s\n", GuidText((GUID *) pSpcLink->Moniker.ClassId));
        if (pSpcLink->Moniker.SerializedData.cbData) {
            printf("     SerializedData::\n");
            PrintBytes("    ", pSpcLink->Moniker.SerializedData.pbData,
                pSpcLink->Moniker.SerializedData.cbData);
        }
        break;
    case SPC_FILE_LINK_CHOICE:
        printf("FILE=> %S\n", pSpcLink->pwszFile);
        break;
    default:
        printf("Bad SPC Link Choice:: %d\n", pSpcLink->dwLinkChoice);
    }
}

static void DisplaySpcSpAgencyExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PSPC_SP_AGENCY_INFO pInfo;
    if (NULL == (pInfo = (PSPC_SP_AGENCY_INFO) TestNoCopyDecodeObject(
            SPC_SP_AGENCY_INFO_OBJID,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    printf("  SpAgencyInfo::\n");
    if (pInfo->pPolicyInformation) {
        printf("    PolicyInformation: ");
        DisplaySpcLink(pInfo->pPolicyInformation);
    }
    if (pInfo->pwszPolicyDisplayText) {
        printf("    PolicyDisplayText: %S\n", pInfo->pwszPolicyDisplayText);
    }
    if (pInfo->pLogoImage) {
        PSPC_IMAGE pImage = pInfo->pLogoImage;
        if (pImage->pImageLink) {
            printf("    ImageLink: ");
            DisplaySpcLink(pImage->pImageLink);
        }
        if (pImage->Bitmap.cbData) {
            printf("    Bitmap:\n");
            PrintBytes("    ", pImage->Bitmap.pbData, pImage->Bitmap.cbData);
        }
        if (pImage->Metafile.cbData) {
            printf("    Metafile:\n");
            PrintBytes("    ", pImage->Metafile.pbData,
                pImage->Metafile.cbData);
        }
        if (pImage->EnhancedMetafile.cbData) {
            printf("    EnhancedMetafile:\n");
            PrintBytes("    ", pImage->EnhancedMetafile.pbData,
                pImage->EnhancedMetafile.cbData);
        }
        if (pImage->GifFile.cbData) {
            printf("    GifFile:\n");
            PrintBytes("    ", pImage->GifFile.pbData,
                pImage->GifFile.cbData);
        }
    }
    if (pInfo->pLogoLink) {
        printf("    LogoLink: ");
        DisplaySpcLink(pInfo->pLogoLink);
    }

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void DisplaySpcFinancialCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    SPC_FINANCIAL_CRITERIA FinancialCriteria;
    DWORD cbInfo = sizeof(FinancialCriteria);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            SPC_FINANCIAL_CRITERIA_OBJID,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &FinancialCriteria,
            &cbInfo
            )) {
        PrintLastError("SpcFinancialCriteriaInfoDecode");
        return;
    }

    printf("  FinancialCriteria:: ");
    if (FinancialCriteria.fFinancialInfoAvailable)
        printf("Financial Info Available.");
    else
        printf("NO Financial Info.");
    if (FinancialCriteria.fMeetsCriteria)
        printf(" Meets Criteria.");
    else
        printf(" Doesn't Meet Criteria.");
    printf("\n");
}

static void DisplaySpcMinimalCriteriaExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    BOOL fMinimalCriteria;
    DWORD cbInfo = sizeof(fMinimalCriteria);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            SPC_MINIMAL_CRITERIA_OBJID,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &fMinimalCriteria,
            &cbInfo)) {
        PrintLastError("SpcMinimalCriteriaInfoDecode");
        return;
    }

    printf("  MinimalCriteria:: ");
    if (fMinimalCriteria)
        printf("Meets Minimal Criteria.");
    else
        printf("Doesn't Meet Minimal Criteria.");
    printf("\n");
}

static void DisplayCommonNameExtension(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    PCERT_NAME_VALUE pInfo = NULL;
    LPWSTR pwsz = NULL;
    DWORD cwsz;

    if (NULL == (pInfo = (PCERT_NAME_VALUE) TestNoCopyDecodeObject(
            X509_NAME_VALUE,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    cwsz = CertRDNValueToStrW(
        pInfo->dwValueType,
        &pInfo->Value,
        NULL,               // pwsz
        0                   // cwsz
        );
    if (cwsz > 1) {
        pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR));
        if (pwsz)
            CertRDNValueToStrW(
                pInfo->dwValueType,
                &pInfo->Value,
                pwsz,
                cwsz
                );
    }

    printf("  CommonName:: ValueType: %d String: ", pInfo->dwValueType);
    if (pwsz)
        printf("%S\n", pwsz);
    else
        printf("NULL");

    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    if (pwsz)
        TestFree(pwsz);
}

static void DisplayCRLReason(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags)
{
    DWORD cbInfo;
    int CRLReason;

    cbInfo = sizeof(CRLReason);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            szOID_CRL_REASON_CODE,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &CRLReason,
            &cbInfo
            )) {
        PrintLastError("CRLReason");
        return;
    }

    printf("  CRL Reason:: ");
    switch (CRLReason) {
        case CRL_REASON_UNSPECIFIED:
            printf("Unspecified");
            break;
        case CRL_REASON_KEY_COMPROMISE:
            printf("Key Compromise");
            break;
        case CRL_REASON_CA_COMPROMISE:
            printf("CA Compromise");
            break;
        case CRL_REASON_AFFILIATION_CHANGED:
            printf("Affiliation Changed");
            break;
        case CRL_REASON_SUPERSEDED:
            printf("Superseded");
            break;
        case CRL_REASON_CESSATION_OF_OPERATION:
            printf("Cessation of Operation");
            break;
        case CRL_REASON_CERTIFICATE_HOLD:
            printf("Certificate Hold");
            break;
        case CRL_REASON_REMOVE_FROM_CRL:
            printf("Remove from CRL");
            break;
        default:
            printf("%d", CRLReason);
            break;
    }
    printf("\n");
}


static void PrintExtensions(DWORD cExt, PCERT_EXTENSION pExt, DWORD dwDisplayFlags)
{
    DWORD i;

    for (i = 0; i < cExt; i++, pExt++) {
        LPSTR pszObjId = pExt->pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        LPSTR pszCritical = pExt->fCritical ? "TRUE" : "FALSE";
        printf("Extension[%d] %s (%S) Critical: %s::\n",
            i, pszObjId, GetOIDName(pszObjId), pszCritical);
        PrintBytes("    ", pExt->Value.pbData, pExt->Value.cbData);

        if (strcmp(pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER) == 0)
            DisplayAuthorityKeyIdExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_AUTHORITY_KEY_IDENTIFIER2) == 0)
            DisplayAuthorityKeyId2Extension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_AUTHORITY_INFO_ACCESS) == 0)
            DisplayAuthorityInfoAccessExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_CRL_DIST_POINTS) == 0)
            DisplayCrlDistPointsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_KEY_IDENTIFIER) == 0)
            DisplayOctetString("  SubjectKeyIdentifer::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_ATTRIBUTES) == 0)
            DisplayKeyAttrExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_ALT_NAME) == 0)
            DisplayAltNameExtension("Subject AltName",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_ISSUER_ALT_NAME) == 0)
            DisplayAltNameExtension("Issuer AltName",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SUBJECT_ALT_NAME2) == 0)
            DisplayAltNameExtension("Subject AltName #2",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_ISSUER_ALT_NAME2) == 0)
            DisplayAltNameExtension("Issuer AltName #2",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NEXT_UPDATE_LOCATION) == 0)
            DisplayAltNameExtension("NextUpdateLocation",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_USAGE_RESTRICTION) == 0)
            DisplayKeyUsageRestrictionExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_BASIC_CONSTRAINTS) == 0)
            DisplayBasicConstraintsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_KEY_USAGE) == 0)
            DisplayKeyUsageExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_BASIC_CONSTRAINTS2) == 0)
            DisplayBasicConstraints2Extension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_CERT_POLICIES) == 0)
            DisplayPoliciesExtension("Certificate",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_CERT_POLICIES_95) == 0)
            DisplayPoliciesExtension("Certificate",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_APPLICATION_CERT_POLICIES) == 0)
            DisplayPoliciesExtension("Application",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SET_ACCOUNT_ALIAS) == 0)
            DisplaySETAccountAliasExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SET_HASHED_ROOT_KEY) == 0)
            DisplaySETHashedRootKeyExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SET_CERTIFICATE_TYPE) == 0)
            DisplaySETCertTypeExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_SET_MERCHANT_DATA) == 0)
            DisplaySETMerchantDataExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, SPC_SP_AGENCY_INFO_OBJID) == 0)
            DisplaySpcSpAgencyExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, SPC_FINANCIAL_CRITERIA_OBJID) == 0)
            DisplaySpcFinancialCriteriaExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, SPC_MINIMAL_CRITERIA_OBJID) == 0)
            DisplaySpcMinimalCriteriaExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_COMMON_NAME) == 0)
            DisplayCommonNameExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        else if (strcmp(pszObjId, szOID_ENHANCED_KEY_USAGE) == 0)
            DisplayEnhancedKeyUsageExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_RSA_SMIMECapabilities) == 0)
            DisplaySMIMECapabilitiesExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        // CRL extensions
        else if (strcmp(pszObjId, szOID_CRL_REASON_CODE) == 0)
            DisplayCRLReason(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        else if (strcmp(pszObjId, szOID_CRL_NUMBER) == 0)
            DisplayInteger(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_DELTA_CRL_INDICATOR) == 0)
            DisplayInteger(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_ISSUING_DIST_POINT) == 0)
            DisplayIssuingDistPointExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_FRESHEST_CRL) == 0)
            DisplayCrlDistPointsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NAME_CONSTRAINTS) == 0)
            DisplayNameConstraintsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_POLICY_MAPPINGS) == 0)
            DisplayPolicyMappingsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_LEGACY_POLICY_MAPPINGS) == 0)
            DisplayPolicyMappingsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_APPLICATION_POLICY_MAPPINGS) == 0)
            DisplayPolicyMappingsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_POLICY_CONSTRAINTS) == 0)
            DisplayPolicyConstraintsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_APPLICATION_POLICY_CONSTRAINTS) == 0)
            DisplayPolicyConstraintsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_CROSS_CERT_DIST_POINTS) == 0)
            DisplayCrossCertDistPointsExtension(
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);

        // Netscape extensions
        else if (strcmp(pszObjId, szOID_NETSCAPE_CERT_TYPE) == 0)
            DisplayBits("  NetscapeCertType::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_BASE_URL) == 0)
            DisplayAnyString("  NetscapeBaseURL::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_REVOCATION_URL) == 0)
            DisplayAnyString("  NetscapeRevocationURL::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CA_REVOCATION_URL) == 0)
            DisplayAnyString("  NetscapeCARevocationURL::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CERT_RENEWAL_URL) == 0)
            DisplayAnyString("  NetscapeCertRenewalURL::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_CA_POLICY_URL) == 0)
            DisplayAnyString("  NetscapeCAPolicyURL::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_SSL_SERVER_NAME) == 0)
            DisplayAnyString("  NetscapeSSLServerName::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
        else if (strcmp(pszObjId, szOID_NETSCAPE_COMMENT) == 0)
            DisplayAnyString("  NetscapeComment::",
                pExt->Value.pbData, pExt->Value.cbData, dwDisplayFlags);
    }
}

static void DecodeAndDisplayDSSParameters(
    IN BYTE *pbData,
    IN DWORD cbData
    )
{
    PCERT_DSS_PARAMETERS pDssParameters;
    DWORD cbDssParameters;
    if (pDssParameters =
        (PCERT_DSS_PARAMETERS) TestNoCopyDecodeObject(
            X509_DSS_PARAMETERS,
            pbData,
            cbData,
            &cbDssParameters
            )) {
        DWORD cbKey = pDssParameters->p.cbData;
        printf("DSS Key Length:: %d bytes, %d bits\n", cbKey,
            cbKey*8);
        printf("DSS P (little endian)::\n");
        PrintBytes("    ", pDssParameters->p.pbData,
            pDssParameters->p.cbData);
        printf("DSS Q (little endian)::\n");
        PrintBytes("    ", pDssParameters->q.pbData,
            pDssParameters->q.cbData);
        printf("DSS G (little endian)::\n");
        PrintBytes("    ", pDssParameters->g.pbData,
            pDssParameters->g.cbData);
        TestFree(pDssParameters);
    }
}

static void PrintAuxCertProperties(
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags
    )
{
    if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
        return;

    DWORD dwPropId = 0;
    while (dwPropId = CertEnumCertificateContextProperties(pCert, dwPropId)) {
        switch (dwPropId) {
        case CERT_KEY_PROV_INFO_PROP_ID:
        case CERT_SHA1_HASH_PROP_ID:
        case CERT_MD5_HASH_PROP_ID:
        case CERT_SIGNATURE_HASH_PROP_ID:
        case CERT_KEY_CONTEXT_PROP_ID:
        case CERT_KEY_IDENTIFIER_PROP_ID:
            // Formatted elsewhere
            break;
        default:
            {
                BYTE *pbData;
                DWORD cbData;

                if (CERT_ARCHIVED_PROP_ID == dwPropId)
                    printf("Archived PropId %d (0x%x) ::\n",
                        dwPropId, dwPropId);
                else
                    printf("Aux PropId %d (0x%x) ::\n", dwPropId, dwPropId);
                CertGetCertificateContextProperty(
                    pCert,
                    dwPropId,
                    NULL,                           // pvData
                    &cbData
                    );
                if (cbData) {
                    if (pbData = (BYTE *) TestAlloc(cbData)) {
                        // Try without a large enough buffer
                        DWORD cbSmall = cbData - 1;

                        if (CertGetCertificateContextProperty(
                                pCert,
                                dwPropId,
                                pbData,
                                &cbSmall
                                ))
                            printf("failed => returned success for too small buffer\n");
                        else {
                            DWORD dwErr = GetLastError();
                            if (ERROR_MORE_DATA != dwErr)
                                printf("failed => returned: %d 0x%x instead of ERROR_MORE_DATA\n", dwErr, dwErr);
                        }
                        if (cbSmall != cbData)
                            printf("failed => wrong size returned for small buffer\n");


                        if (CertGetCertificateContextProperty(
                                pCert,
                                dwPropId,
                                pbData,
                                &cbData
                                )) {
                            PrintBytes("    ", pbData, cbData);
                            if (CERT_CTL_USAGE_PROP_ID == dwPropId) {
                                printf("  EnhancedKeyUsage::\n");
                                DecodeAndDisplayCtlUsage(pbData, cbData,
                                    dwDisplayFlags);
                            } else if (CERT_CROSS_CERT_DIST_POINTS_PROP_ID ==
                                    dwPropId) {
                                printf("  CrossCertDistPoints::\n");
                                DisplayCrossCertDistPointsExtension(
                                    pbData, cbData, dwDisplayFlags);
#ifdef CERT_PUBKEY_ALG_PARA_PROP_ID
                            } else if (CERT_PUBKEY_ALG_PARA_PROP_ID ==
                                    dwPropId) {
                                DecodeAndDisplayDSSParameters(pbData, cbData);
#endif
                            }
                        } else
                            printf("     ERROR getting property bytes\n");
                        TestFree(pbData);
                    }
                } else
                    printf("     NO Property Bytes\n");
            }
            break;
        }
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

static void DisplaySignature(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    DWORD dwDisplayFlags
    )
{
    PCERT_SIGNED_CONTENT_INFO pSignedContent;
    
    if (pSignedContent = (PCERT_SIGNED_CONTENT_INFO) TestNoCopyDecodeObject(
            X509_CERT,
            pbEncoded,
            cbEncoded
            )) {
        LPSTR pszObjId;

        pszObjId = pSignedContent->SignatureAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        printf("Content SignatureAlgorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));
        if (pSignedContent->SignatureAlgorithm.Parameters.cbData) {
            printf("Content SignatureAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pSignedContent->SignatureAlgorithm.Parameters.pbData,
                pSignedContent->SignatureAlgorithm.Parameters.cbData);
        }

        if (pSignedContent->Signature.cbData) {
            ALG_ID aiHash;
            ALG_ID aiPubKey;

            printf("Content Signature (little endian)::\n");
            PrintBytes("    ", pSignedContent->Signature.pbData,
                pSignedContent->Signature.cbData);

            GetSignAlgids(pszObjId, &aiHash, &aiPubKey);
            if (CALG_SHA == aiHash && CALG_DSS_SIGN == aiPubKey) {
                BYTE *pbDssSignature;
                DWORD cbDssSignature;

                ReverseBytes(pSignedContent->Signature.pbData,
                    pSignedContent->Signature.cbData);

                if (pbDssSignature =
                    (BYTE *) TestNoCopyDecodeObject(
                        X509_DSS_SIGNATURE,
                        pSignedContent->Signature.pbData,
                        pSignedContent->Signature.cbData,
                        &cbDssSignature
                        )) {
                    if (CERT_DSS_SIGNATURE_LEN == cbDssSignature) {
                        printf("DSS R (little endian)::\n");
                        PrintBytes("    ", pbDssSignature, CERT_DSS_R_LEN);
                        printf("DSS S (little endian)::\n");
                        PrintBytes("    ", pbDssSignature + CERT_DSS_R_LEN,
                            CERT_DSS_S_LEN);
                    } else {
                        printf("DSS Signature (unexpected length, little endian)::\n");
                        PrintBytes("    ", pbDssSignature, cbDssSignature);
                    }
                    TestFree(pbDssSignature);
                }
            }
        } else
            printf("Content Signature:: NONE\n");

        printf("Content Length:: %d\n", pSignedContent->ToBeSigned.cbData);
        TestFree(pSignedContent);
    }
}

void DisplayStore(
    IN HCERTSTORE hStore,
    IN DWORD dwDisplayFlags
    )
{
    DWORD i;
    DWORD dwFlags;
    PCCERT_CONTEXT pCert;
    PCCRL_CONTEXT pCrl;
    PCCTL_CONTEXT pCtl;

    printf("####  Certificates  ####\n");
    pCert = NULL;
    i = 0;
    while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
        printf("=====  %d  =====\n", i);
        DisplayCert(pCert, dwDisplayFlags);
        i++;
    }

    printf("####  CRLs  ####\n");
    pCrl = NULL;
    i = 0;
    while (pCrl = CertEnumCRLsInStore(hStore, pCrl)) {
        printf("=====  %d  =====\n", i);
        DisplayCrl(pCrl, dwDisplayFlags);
        i++;
    }

    printf("####  CTLs  ####\n");
    pCtl = NULL;
    i = 0;
    while (pCtl = CertEnumCTLsInStore(hStore, pCtl)) {
        printf("=====  %d  =====\n", i);
        DisplayCtl(pCtl, dwDisplayFlags);
        i++;
    }
}

// Not displayed when DISPLAY_BRIEF_FLAG is set
void DisplayCertKeyProvInfo(
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags
    )
{
    PCRYPT_KEY_PROV_INFO pInfo = NULL;
    DWORD cbInfo;

    if (dwDisplayFlags & DISPLAY_BRIEF_FLAG)
        return;

    cbInfo = 0;
    CertGetCertificateContextProperty(
        pCert,
        CERT_KEY_PROV_INFO_PROP_ID,
        NULL,                           // pvData
        &cbInfo
        );
    if (cbInfo) {
        pInfo = (PCRYPT_KEY_PROV_INFO) TestAlloc(cbInfo);
        if (pInfo) {
            // Try without a large enough buffer
            DWORD cbSmall = cbInfo - 1;

            if (CertGetCertificateContextProperty(
                    pCert,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    pInfo,
                    &cbSmall
                    ))
                printf("failed => returned success for too small buffer\n");
            else {
                DWORD dwErr = GetLastError();
                if (ERROR_MORE_DATA != dwErr)
                    printf("failed => returned: %d 0x%x instead of ERROR_MORE_DATA\n", dwErr, dwErr);
            }
            if (cbSmall != cbInfo)
                printf("failed => wrong size returned for small buffer\n");

            if (CertGetCertificateContextProperty(
                    pCert,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    pInfo,
                    &cbInfo
                    )) {
                printf("Key Provider:: Type: %d", pInfo->dwProvType);
                if (pInfo->pwszProvName)
                    printf(" Name: %S", pInfo->pwszProvName);
                if (pInfo->dwFlags) {
                    printf(" Flags: 0x%x", pInfo->dwFlags);
                    if (pInfo->dwFlags & CRYPT_MACHINE_KEYSET)
                        printf(" (MACHINE_KEYSET)");
                    if (pInfo->dwFlags & CERT_SET_KEY_CONTEXT_PROP_ID)
                        printf(" (SET_KEY_CONTEXT_PROP)");
                    printf(" ");
                }
                if (pInfo->pwszContainerName)
                    printf(" Container: %S", pInfo->pwszContainerName);
                if (pInfo->dwKeySpec)
                    printf(" KeySpec: %d", pInfo->dwKeySpec);
                printf("\n");
                if (pInfo->cProvParam) {
                    DWORD i;
                    printf("Key Provider Params::\n");
                    for (i = 0; i < pInfo->cProvParam; i++) {
                        PCRYPT_KEY_PROV_PARAM pParam =
                            &pInfo->rgProvParam[i];
                        printf(" [%d] dwParam: 0x%x dwFlags: 0x%x\n",
                            i, pParam->dwParam, pParam->dwFlags);
                        if (pParam->cbData)
                            PrintBytes("      ",
                                pParam->pbData, pParam->cbData);
                    }
                }
            } else
                PrintLastError("CertGetCertificateContextProperty");
            TestFree(pInfo);
        }
    }
}

void DisplayFriendlyName(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwDisplayFlags
    )
{
    DWORD cch;
    LPWSTR pwsz = NULL;

    if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
        return;

    cch = CertGetNameStringW(
        pCertContext,
        CERT_NAME_FRIENDLY_DISPLAY_TYPE,
        0,                                  // dwFlags
        NULL,                               // pvTypePara
        NULL,                               // pwsz
        0);                                 // cch
    if (cch <= 1) {
        DWORD dwErr = GetLastError();

        printf("failed => CertGetNameStringW returned empty string\n");
    } else if (pwsz = (LPWSTR) TestAlloc(cch * sizeof(WCHAR))) {
        cch = CertGetNameStringW(
            pCertContext,
            CERT_NAME_FRIENDLY_DISPLAY_TYPE,
            0,                              // dwFlags
            NULL,                           // pvTypePara
            pwsz,
            cch);
        printf("Friendly Name:: <%S>\n", pwsz);
        TestFree(pwsz);
    }
}

void DisplayUPN(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwDisplayFlags
    )
{
    DWORD cch;
    LPWSTR pwsz = NULL;

    if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
        return;

    cch = CertGetNameStringW(
        pCertContext,
        CERT_NAME_UPN_TYPE,
        0,                                  // dwFlags
        NULL,                               // pvTypePara
        NULL,                               // pwsz
        0);                                 // cch
    if (cch <= 1) {
        ;
    } else if (pwsz = (LPWSTR) TestAlloc(cch * sizeof(WCHAR))) {
        cch = CertGetNameStringW(
            pCertContext,
            CERT_NAME_UPN_TYPE,
            0,                              // dwFlags
            NULL,                           // pvTypePara
            pwsz,
            cch);
        printf("UPN Name:: <%S>\n", pwsz);
        TestFree(pwsz);
    }
}

void DisplayCert(
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags,
    DWORD dwIssuer
    )
{
    DisplayCert2(
        pCert->hCertStore,
        pCert,
        dwDisplayFlags,
        dwIssuer
        );
}

typedef BOOL (WINAPI *PFN_CRYPT_UI_DLG_VIEW_CONTEXT)(
    IN DWORD dwContextType,
    IN const void *pvContext,
    IN OPTIONAL HWND hwnd,              // Defaults to the desktop window
    IN OPTIONAL LPCWSTR pwszTitle,      // Defaults to the context type title
    IN DWORD dwFlags,
    IN void *pvReserved
    );

void DisplayContextUI(
    IN DWORD dwContextType,
    IN const void *pvContext
    )
{
    HMODULE hDll = NULL;
    PFN_CRYPT_UI_DLG_VIEW_CONTEXT pfnCryptUIDlgViewContext;

    if (NULL == (hDll = LoadLibraryA("cryptui.dll"))) {
        PrintLastError("LoadLibraryA(cryptui.dll)");
        goto CommonReturn;
    }

    if (NULL == (pfnCryptUIDlgViewContext =
            (PFN_CRYPT_UI_DLG_VIEW_CONTEXT) GetProcAddress(hDll,
                "CryptUIDlgViewContext"))) {
        PrintLastError("GetProcAddress(CryptUIDlgViewContext)");
        goto CommonReturn;
    }

    if (!pfnCryptUIDlgViewContext(
            dwContextType,
            pvContext,
            NULL,       // hHwnd
            NULL,       // pwszTitle
            0,          // dwFlags
            NULL        // pvReserved
            ))
        PrintLastError("CryptUIDlgViewContext");

CommonReturn:
    if (hDll)
        FreeLibrary(hDll);
}


void DisplayCert2(
    HCERTSTORE hStore,
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags,
    DWORD dwIssuer
    )
{
    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        DisplayContextUI(CERT_STORE_CERTIFICATE_CONTEXT, pCert);
        dwDisplayFlags = DISPLAY_BRIEF_FLAG;
    }

    DisplayFriendlyName(pCert, dwDisplayFlags);
    DisplayUPN(pCert, dwDisplayFlags);

    printf("Subject::\n");
    DecodeName(pCert->pCertInfo->Subject.pbData,
        pCert->pCertInfo->Subject.cbData, dwDisplayFlags);
    if (!(dwDisplayFlags & DISPLAY_BRIEF_FLAG)) {
        printf("Issuer::\n");
        DecodeName(pCert->pCertInfo->Issuer.pbData,
            pCert->pCertInfo->Issuer.cbData, dwDisplayFlags);
        {
            printf("SerialNumber::");
            DisplaySerialNumber(&pCert->pCertInfo->SerialNumber);
            printf("\n");
        }
    }

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;

#define MAX_KEY_ID_LEN  128
        BYTE rgbKeyId[MAX_KEY_ID_LEN];
        DWORD cbKeyId;

        CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
        cbHash = MAX_HASH_LEN;
        CertGetCertificateContextProperty(
            pCert,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("MD5", rgbHash, cbHash);
        cbHash = MAX_HASH_LEN;
        CertGetCertificateContextProperty(
            pCert,
            CERT_SIGNATURE_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("Signature", rgbHash, cbHash);


        cbKeyId = MAX_KEY_ID_LEN;
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_KEY_IDENTIFIER_PROP_ID,
                rgbKeyId,
                &cbKeyId
                ))
            DisplayThumbprint("KeyIdentifier", rgbKeyId, cbKeyId);
        else
            PrintLastError(
                "CertGetCertificateContextProperty(KEY_IDENTIFIER)");

        cbKeyId = MAX_KEY_ID_LEN;
        if (CryptHashPublicKeyInfo(
                NULL,               // hCryptProv
                CALG_SHA1,
                0,                  // dwFlags
                X509_ASN_ENCODING,
                &pCert->pCertInfo->SubjectPublicKeyInfo,
                rgbKeyId,
                &cbKeyId
                ))
            DisplayThumbprint("SHA1 KeyIdentifier", rgbKeyId, cbKeyId);
        else
            PrintLastError(
                "CertGetCertificateContextProperty(SHA1 KEY_IDENTIFIER)");


        if (dwDisplayFlags & DISPLAY_KEY_THUMB_FLAG) {
            HCRYPTPROV hProv = 0;
            CryptAcquireContext(
                &hProv,
                NULL,
                NULL,           // pszProvider
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT
                );
            if (hProv) {
                cbHash = MAX_HASH_LEN;
                CryptHashPublicKeyInfo(
                    hProv,
                    CALG_MD5,
                    0,                  // dwFlags
                    dwCertEncodingType,
                    &pCert->pCertInfo->SubjectPublicKeyInfo,
                    rgbHash,
                    &cbHash
                    );
                DisplayThumbprint("Key (MD5)", rgbHash, cbHash);
                CryptReleaseContext(hProv, 0);
            }
        }
    }

    DisplayCertKeyProvInfo(pCert);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        DWORD dwAccessStateFlags;
        DWORD cbData = sizeof(dwAccessStateFlags);

        CertGetCertificateContextProperty(
            pCert,
            CERT_ACCESS_STATE_PROP_ID,
            &dwAccessStateFlags,
            &cbData
            );
        if (0 == cbData)
            printf("No AccessState PropId\n");
        else {
            printf("AccessState PropId dwFlags:: 0x%x", dwAccessStateFlags);
            if (dwAccessStateFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG)
                printf(" WRITE_PERSIST");
            if (dwAccessStateFlags & CERT_ACCESS_STATE_SYSTEM_STORE_FLAG)
                printf(" SYSTEM_STORE");
            if (dwAccessStateFlags & CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG)
                printf(" LM_SYSTEM_STORE");
            printf("\n");
        }
    }

    PrintAuxCertProperties(pCert, dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        LPSTR pszObjId;
        ALG_ID aiPubKey;
        DWORD dwBitLen;

        printf("Version:: %d\n", pCert->pCertInfo->dwVersion);

        pszObjId = pCert->pCertInfo->SignatureAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        printf("SignatureAlgorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));
        if (pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData) {
            printf("SignatureAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pCert->pCertInfo->SignatureAlgorithm.Parameters.pbData,
                pCert->pCertInfo->SignatureAlgorithm.Parameters.cbData);
        }
        printf("NotBefore:: %s\n", FileTimeText(&pCert->pCertInfo->NotBefore));
        printf("NotAfter:: %s\n", FileTimeText(&pCert->pCertInfo->NotAfter));

        pszObjId = pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        printf("SubjectPublicKeyInfo.Algorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID));
        aiPubKey = GetAlgid(pszObjId, CRYPT_PUBKEY_ALG_OID_GROUP_ID);

        if (pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData) {
            printf("SubjectPublicKeyInfo.Algorithm.Parameters::\n");
            PrintBytes("    ",
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
            if (NULL_ASN_TAG ==
                    *pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData)
            {
                // NULL parameters
            } else if (CALG_DSS_SIGN == aiPubKey) {
                DecodeAndDisplayDSSParameters(
                    pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                    pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
            } else if (CALG_DH_SF == aiPubKey || CALG_DH_EPHEM == aiPubKey) {
                PCERT_X942_DH_PARAMETERS pDhParameters;
                DWORD cbDhParameters;
                if (pDhParameters =
                    (PCERT_X942_DH_PARAMETERS) TestNoCopyDecodeObject(
                        X942_DH_PARAMETERS,
                        pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData,
                        &cbDhParameters
                        )) {
                    DWORD cbKey = pDhParameters->p.cbData;
                    printf("DH Key Length:: %d bytes, %d bits\n", cbKey,
                        cbKey*8);
                    printf("DH P (little endian)::\n");
                    PrintBytes("    ", pDhParameters->p.pbData,
                        pDhParameters->p.cbData);
                    printf("DH G (little endian)::\n");
                    PrintBytes("    ", pDhParameters->g.pbData,
                        pDhParameters->g.cbData);

                    if (pDhParameters->q.cbData) {
                        printf("DH Q (little endian)::\n");
                        PrintBytes("    ", pDhParameters->q.pbData,
                            pDhParameters->q.cbData);
                    }
                    if (pDhParameters->j.cbData) {
                        printf("DH J (little endian)::\n");
                        PrintBytes("    ", pDhParameters->j.pbData,
                            pDhParameters->j.cbData);
                    }
                    if (pDhParameters->pValidationParams) {
                        printf("DH seed ::\n");
                        PrintBytes("    ",
                            pDhParameters->pValidationParams->seed.pbData,
                            pDhParameters->pValidationParams->seed.cbData);
                        printf("DH pgenCounter:: %d (0x%x)\n",
                            pDhParameters->pValidationParams->pgenCounter,
                            pDhParameters->pValidationParams->pgenCounter);
                    }
                    TestFree(pDhParameters);
                }
            }
        }
        printf("SubjectPublicKeyInfo.PublicKey");
        if (0 != (dwBitLen = CertGetPublicKeyLength(
                dwCertEncodingType,
                &pCert->pCertInfo->SubjectPublicKeyInfo)))
            printf(" (BitLength: %d)", dwBitLen);
        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
            printf(" (UnusedBits: %d)",
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);
        printf("::\n");
        if (pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData) {
            PrintBytes("    ",
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData);

            if (CALG_RSA_SIGN == aiPubKey || CALG_RSA_KEYX == aiPubKey) {
                PUBLICKEYSTRUC *pPubKeyStruc;
                DWORD cbPubKeyStruc;

                printf("RSA_CSP_PUBLICKEYBLOB::\n");
                if (pPubKeyStruc = (PUBLICKEYSTRUC *) TestNoCopyDecodeObject(
                        RSA_CSP_PUBLICKEYBLOB,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                        &cbPubKeyStruc
                        )) {
                    PrintBytes("    ", (BYTE *) pPubKeyStruc, cbPubKeyStruc);
                    TestFree(pPubKeyStruc);
                }
            } else if (CALG_DSS_SIGN == aiPubKey) {
                PCRYPT_UINT_BLOB pDssPubKey;
                DWORD cbDssPubKey;
                printf("DSS Y (little endian)::\n");
                if (pDssPubKey = (PCRYPT_UINT_BLOB) TestNoCopyDecodeObject(
                        X509_DSS_PUBLICKEY,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                        &cbDssPubKey
                        )) {
                    PrintBytes("    ", pDssPubKey->pbData, pDssPubKey->cbData);
                    TestFree(pDssPubKey);
                }
            } else if (CALG_DH_SF == aiPubKey || CALG_DH_EPHEM == aiPubKey) {
                PCRYPT_UINT_BLOB pDhPubKey;
                DWORD cbDhPubKey;
                printf("DH Y (little endian)::\n");
                if (pDhPubKey = (PCRYPT_UINT_BLOB) TestNoCopyDecodeObject(
                        X509_DH_PUBLICKEY,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                        pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData,
                        &cbDhPubKey
                        )) {
                    PrintBytes("    ", pDhPubKey->pbData, pDhPubKey->cbData);
                    TestFree(pDhPubKey);
                }
            }
        } else
            printf("  No public key\n");

        DisplaySignature(
            pCert->pbCertEncoded,
            pCert->cbCertEncoded,
            dwDisplayFlags);

        if (pCert->pCertInfo->IssuerUniqueId.cbData) {
            printf("IssuerUniqueId");
            if (pCert->pCertInfo->IssuerUniqueId.cUnusedBits)
                printf(" (UnusedBits: %d)",
                    pCert->pCertInfo->IssuerUniqueId.cUnusedBits);
            printf("::\n");
            PrintBytes("    ", pCert->pCertInfo->IssuerUniqueId.pbData,
                pCert->pCertInfo->IssuerUniqueId.cbData);
        }

        if (pCert->pCertInfo->SubjectUniqueId.cbData) {
            printf("SubjectUniqueId");
            if (pCert->pCertInfo->SubjectUniqueId.cUnusedBits)
                printf(" (UnusedBits: %d)",
                    pCert->pCertInfo->SubjectUniqueId.cUnusedBits);
            printf("::\n");
            PrintBytes("    ", pCert->pCertInfo->SubjectUniqueId.pbData,
                pCert->pCertInfo->SubjectUniqueId.cbData);
        }

        if (pCert->pCertInfo->cExtension != 0) {
            PrintExtensions(pCert->pCertInfo->cExtension,
                pCert->pCertInfo->rgExtension, dwDisplayFlags);
        }

    }

    if (dwDisplayFlags & DISPLAY_CHECK_FLAG) {
        // Display any CRLs associated with the certificate
        PCCRL_CONTEXT pCrl = NULL;
        PCCRL_CONTEXT pFindCrl = NULL;
        DWORD dwFlags;
        int i;

        // i = 0 => BASE
        // i = 1 => DELTA
        for (i = 0; i <= 1; i++) {
          while (TRUE) {
            if (dwDisplayFlags &
                    (DISPLAY_CHECK_SIGN_FLAG | DISPLAY_CHECK_TIME_FLAG)) {
                dwFlags = 0;
                if (dwDisplayFlags & DISPLAY_CHECK_SIGN_FLAG)
                    dwFlags |= CERT_STORE_SIGNATURE_FLAG;
                if (dwDisplayFlags & DISPLAY_CHECK_TIME_FLAG)
                    dwFlags |= CERT_STORE_TIME_VALIDITY_FLAG;
            } else
                dwFlags = CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;
            if (i == 0)
                dwFlags |= CERT_STORE_BASE_CRL_FLAG;
            else
                dwFlags |= CERT_STORE_DELTA_CRL_FLAG;
            pCrl = CertGetCRLFromStore(
                hStore,
                pCert,
                pCrl,
                &dwFlags
                );

            // Check that find comes up with the same CRL
            pFindCrl = CertFindCRLInStore(
                hStore,
                pCert->dwCertEncodingType,
                (i == 0) ? CRL_FIND_ISSUED_BY_BASE_FLAG :
                            CRL_FIND_ISSUED_BY_DELTA_FLAG,
                CRL_FIND_ISSUED_BY,
                (const void *) pCert,
                pFindCrl
                );

            if (pCrl == NULL) {
                if (pFindCrl != NULL) {
                    printf("failed => CertFindCRLInStore didn't return expected NULL\n");
                    CertFreeCRLContext(pFindCrl);
                    pFindCrl = NULL;
                }
                break;
            } else if (pFindCrl == NULL) {
                printf("failed => CertFindCRLInStore returned unexpected NULL\n");
                CertFreeCRLContext(pCrl);
                pCrl = NULL;
                break;
            }

            if (!(pFindCrl->pbCrlEncoded == pCrl->pbCrlEncoded
                                    ||
                    (pFindCrl->cbCrlEncoded == pCrl->cbCrlEncoded &&
                        0 == memcmp(pFindCrl->pbCrlEncoded, pCrl->pbCrlEncoded,
                            pFindCrl->cbCrlEncoded))))
                printf("failed => CertFindCRLInStore didn't match CertGetCRLFromStore\n");

            if (i == 0)
                printf("-----  BASE CRL  -----\n");
            else
                printf("-----  DELTA CRL  -----\n");
            DisplayCrl(pCrl, dwDisplayFlags | DISPLAY_NO_ISSUER_FLAG);
            DisplayVerifyFlags("CRL", dwFlags);
        }
      }
    }

    if (dwDisplayFlags & DISPLAY_CHECK_FLAG) {
        BOOL fIssuer = FALSE;
        PCCERT_CONTEXT pIssuer = NULL;
        DWORD dwFlags;

        while (TRUE) {
            if (dwDisplayFlags &
                    (DISPLAY_CHECK_SIGN_FLAG | DISPLAY_CHECK_TIME_FLAG)) {
                dwFlags = 0;
                if (dwDisplayFlags & DISPLAY_CHECK_SIGN_FLAG)
                    dwFlags |= CERT_STORE_SIGNATURE_FLAG;
                if (dwDisplayFlags & DISPLAY_CHECK_TIME_FLAG)
                    dwFlags |= CERT_STORE_TIME_VALIDITY_FLAG;
            } else
                dwFlags = CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG |
                    CERT_STORE_REVOCATION_FLAG;
            pIssuer = CertGetIssuerCertificateFromStore(
                hStore,
                pCert,
                pIssuer,
                &dwFlags
                );
            if (pIssuer) {
                printf("-----  Issuer [%d]  -----\n", dwIssuer);
                DisplayVerifyFlags("Above Subject", dwFlags);
                DisplayCert2(hStore, pIssuer, dwDisplayFlags, dwIssuer + 1);
                fIssuer = TRUE;
            } else {
                DWORD dwErr = GetLastError();
                if (dwErr == CRYPT_E_SELF_SIGNED) {
                    printf("-----  Self Signed Issuer   -----\n");
                    DisplayVerifyFlags("Issuer", dwFlags);
                } else if (dwErr != CRYPT_E_NOT_FOUND)
                    PrintLastError("CertGetIssuerCertificateFromStore");
                else if (!fIssuer) {
                    printf("-----  No Issuer   -----\n");
                    DisplayVerifyFlags("Above Subject", dwFlags);
                }
                break;
            }
        }
    }
}


void PrintCrlEntries(
    DWORD cEntry,
    PCRL_ENTRY pEntry,
    DWORD dwDisplayFlags
    )
{
    DWORD i;

    for (i = 0; i < cEntry; i++, pEntry++) {
        {
            printf(" [%d] SerialNumber::", i);
            DisplaySerialNumber(&pEntry->SerialNumber);
            printf("\n");
        }

        if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
            printf(" [%d] RevocationDate:: %s\n", i,
                FileTimeText(&pEntry->RevocationDate));

            if (pEntry->cExtension == 0)
                printf(" [%d] Extensions:: NONE\n", i);
            else {
                printf(" [%d] Extensions::\n", i);
                PrintExtensions(pEntry->cExtension, pEntry->rgExtension,
                    dwDisplayFlags);
            }
        }
    }
}

static void PrintAuxCrlProperties(
    PCCRL_CONTEXT pCrl,
    DWORD dwDisplayFlags
    )
{
    if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
        return;

    DWORD dwPropId = 0;
    while (dwPropId = CertEnumCRLContextProperties(pCrl, dwPropId)) {
        switch (dwPropId) {
        case CERT_SHA1_HASH_PROP_ID:
        case CERT_MD5_HASH_PROP_ID:
            // Formatted elsewhere
            break;
        default:
            {
                BYTE *pbData;
                DWORD cbData;
                printf("Aux PropId %d (0x%x) ::\n", dwPropId, dwPropId);

                CertGetCRLContextProperty(
                    pCrl,
                    dwPropId,
                    NULL,                           // pvData
                    &cbData
                    );
                if (cbData) {
                    if (pbData = (BYTE *) TestAlloc(cbData)) {
                        if (CertGetCRLContextProperty(
                                pCrl,
                                dwPropId,
                                pbData,
                                &cbData
                                ))
                            PrintBytes("    ", pbData, cbData);
                        else
                            printf("    ERROR getting property bytes\n");
                        TestFree(pbData);
                    }
                } else
                    printf("    NO Property Bytes\n");
            }
            break;
        }
    }
}

void DisplayCrl(PCCRL_CONTEXT pCrl, DWORD dwDisplayFlags)
{
    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        DisplayContextUI(CERT_STORE_CRL_CONTEXT, pCrl);
        dwDisplayFlags = DISPLAY_BRIEF_FLAG;
    }

    if (!(dwDisplayFlags & DISPLAY_NO_ISSUER_FLAG)) {
        printf("Issuer::\n");
        DecodeName(pCrl->pCrlInfo->Issuer.pbData,
            pCrl->pCrlInfo->Issuer.cbData, dwDisplayFlags);
    }

    printf("ThisUpdate:: %s\n", FileTimeText(&pCrl->pCrlInfo->ThisUpdate));
    printf("NextUpdate:: %s\n", FileTimeText(&pCrl->pCrlInfo->NextUpdate));

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;
        CertGetCRLContextProperty(
            pCrl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
        cbHash = MAX_HASH_LEN;
        CertGetCRLContextProperty(
            pCrl,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("MD5", rgbHash, cbHash);
        cbHash = MAX_HASH_LEN;
        CertGetCRLContextProperty(
            pCrl,
            CERT_SIGNATURE_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("Signature", rgbHash, cbHash);
    }

    PrintAuxCrlProperties(pCrl, dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        LPSTR pszObjId;

        printf("Version:: %d\n", pCrl->pCrlInfo->dwVersion);

        pszObjId = pCrl->pCrlInfo->SignatureAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        printf("SignatureAlgorithm:: %s (%S)\n",
            pszObjId, GetOIDName(pszObjId, CRYPT_SIGN_ALG_OID_GROUP_ID));
        if (pCrl->pCrlInfo->SignatureAlgorithm.Parameters.cbData) {
            printf("SignatureAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pCrl->pCrlInfo->SignatureAlgorithm.Parameters.pbData,
                pCrl->pCrlInfo->SignatureAlgorithm.Parameters.cbData);
        }


        if (pCrl->pCrlInfo->cExtension != 0) {
            PrintExtensions(pCrl->pCrlInfo->cExtension,
                pCrl->pCrlInfo->rgExtension,
                dwDisplayFlags);
        }
    }

    if (pCrl->pCrlInfo->cCRLEntry == 0)
        printf("Entries:: NONE\n");
    else {
        printf("Entries::\n");
        PrintCrlEntries(pCrl->pCrlInfo->cCRLEntry,
            pCrl->pCrlInfo->rgCRLEntry, dwDisplayFlags);
    }
}

static void PrintAttributes(DWORD cAttr, PCRYPT_ATTRIBUTE pAttr,
        DWORD dwDisplayFlags)
{
    DWORD i; 
    DWORD j; 

    for (i = 0; i < cAttr; i++, pAttr++) {
        DWORD cValue = pAttr->cValue;
        PCRYPT_ATTR_BLOB pValue = pAttr->rgValue;
        LPSTR pszObjId = pAttr->pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        if (cValue) {
            for (j = 0; j < cValue; j++, pValue++) {
                printf("  [%d,%d] %s\n", i, j, pszObjId);
                if (pValue->cbData) {
                    PrintBytes("    ", pValue->pbData, pValue->cbData);
                    if (strcmp(pszObjId, szOID_NEXT_UPDATE_LOCATION) == 0) {
                        printf("   NextUpdateLocation::\n");
                        DecodeAndDisplayAltName(pValue->pbData, pValue->cbData,
                            dwDisplayFlags);
                    }
                } else
                    printf("    NO Value Bytes\n");
            }
        } else
            printf("  [%d] %s :: No Values\n", i, pszObjId);
    }
}

static void PrintCtlEntries(
        PCCTL_CONTEXT pCtl,
        DWORD dwDisplayFlags,
        HCERTSTORE hStore)
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;
    DWORD cEntry = pInfo->cCTLEntry;
    PCTL_ENTRY pEntry = pInfo->rgCTLEntry;
    DWORD i;
    DWORD Algid;
    DWORD dwFindType;

    Algid = CertOIDToAlgId(pInfo->SubjectAlgorithm.pszObjId);
    switch (Algid) {
        case CALG_SHA1:
            dwFindType = CERT_FIND_SHA1_HASH;
            break;
        case CALG_MD5:
            dwFindType = CERT_FIND_MD5_HASH;
            break;
        default:
            dwFindType = 0;
    }

    for (i = 0; i < cEntry; i++, pEntry++) {
        printf(" [%d] SubjectIdentifier::\n", i);
        PrintBytes("      ",
            pEntry->SubjectIdentifier.pbData,
            pEntry->SubjectIdentifier.cbData);

        if (hStore && dwFindType) {
            PCCERT_CONTEXT pCert;
            pCert = CertFindCertificateInStore(
                hStore,
                dwCertEncodingType,
                0,                  // dwFindFlags
                dwFindType,
                (void *) &pEntry->SubjectIdentifier,
                NULL                // pPrevCert
                );
            if (pCert) {
                DWORD cwsz;
                LPWSTR pwsz;

                cwsz = CertNameToStrW(
                    dwCertEncodingType,
                    &pCert->pCertInfo->Subject,
                    CERT_SIMPLE_NAME_STR,
                    NULL,                   // pwsz
                    0);                     // cwsz
                if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
                    CertNameToStrW(
                        dwCertEncodingType,
                        &pCert->pCertInfo->Subject,
                        CERT_SIMPLE_NAME_STR,
                        pwsz,
                        cwsz);
                    printf("      Subject:  %S\n", pwsz);
                    TestFree(pwsz);
                }
                CertFreeCertificateContext(pCert);
            }
        }

        if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
            if (pEntry->cAttribute) {
                printf(" [%d] Attributes::\n", i);
                PrintAttributes(pEntry->cAttribute, pEntry->rgAttribute,
                    dwDisplayFlags);
            }
        }
    }
}

static void PrintAuxCtlProperties(
    PCCTL_CONTEXT pCtl,
    DWORD dwDisplayFlags
    )
{
    if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
        return;

    DWORD dwPropId = 0;
    while (dwPropId = CertEnumCTLContextProperties(pCtl, dwPropId)) {
        switch (dwPropId) {
        case CERT_SHA1_HASH_PROP_ID:
#if 0
        case CERT_MD5_HASH_PROP_ID:
#endif
            // Formatted elsewhere
            break;
        default:
            {
                BYTE *pbData;
                DWORD cbData;

                printf("Aux PropId %d (0x%x) ::\n", dwPropId, dwPropId);
                CertGetCTLContextProperty(
                    pCtl,
                    dwPropId,
                    NULL,                           // pvData
                    &cbData
                    );
                if (cbData) {
                    if (pbData = (BYTE *) TestAlloc(cbData)) {
                        if (CertGetCTLContextProperty(
                                pCtl,
                                dwPropId,
                                pbData,
                                &cbData
                                )) {
                            PrintBytes("    ", pbData, cbData);
                            if (CERT_NEXT_UPDATE_LOCATION_PROP_ID ==
                                    dwPropId) {
                                printf("  NextUpdateLocation::\n");
                                DecodeAndDisplayAltName(pbData, cbData,
                                    dwDisplayFlags);
                            }
                        } else
                            printf("     ERROR getting property bytes\n");
                        TestFree(pbData);
                    }
                } else
                    printf("     NO Property Bytes\n");
            }
            break;
        }
    }
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the CTL is still time valid.
//
//  A CTL without a NextUpdate is considered time valid.
//--------------------------------------------------------------------------
BOOL IsTimeValidCtl(
    IN PCCTL_CONTEXT pCtl
    )
{
    PCTL_INFO pCtlInfo = pCtl->pCtlInfo;
    SYSTEMTIME SystemTime;
    FILETIME CurrentTime;

    // Get current time to be used to determine if CTLs are time valid
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &CurrentTime);

    // Note, NextUpdate is optional. When not present, its set to 0
    if ((0 == pCtlInfo->NextUpdate.dwLowDateTime &&
                0 == pCtlInfo->NextUpdate.dwHighDateTime) ||
            CompareFileTime(&pCtlInfo->NextUpdate, &CurrentTime) >= 0)
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Allocates and returns the specified cryptographic message parameter.
//--------------------------------------------------------------------------
static void *AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT DWORD *pcbData
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto ErrorReturn;
    if (NULL == (pvData = TestAlloc(cbData)))
        goto ErrorReturn;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        TestFree(pvData);
        goto ErrorReturn;
    }

CommonReturn:
    *pcbData = cbData;
    return pvData;
ErrorReturn:
    pvData = NULL;
    cbData = 0;
    goto CommonReturn;
}

void DisplaySignerInfo(
    HCRYPTMSG hMsg,
    DWORD dwSignerIndex,
    DWORD dwDisplayFlags
    )
{
    DWORD cbData;
    PCRYPT_ATTRIBUTES pAttrs;

    if (pAttrs = (PCRYPT_ATTRIBUTES) AllocAndGetMsgParam(
            hMsg,
            CMSG_SIGNER_AUTH_ATTR_PARAM,
            dwSignerIndex,
            &cbData)) {
        printf("-----  Signer [%d] AuthenticatedAttributes  -----\n",
            dwSignerIndex);
        PrintAttributes(pAttrs->cAttr, pAttrs->rgAttr, dwDisplayFlags);
        TestFree(pAttrs);
    }

    if (pAttrs = (PCRYPT_ATTRIBUTES) AllocAndGetMsgParam(
            hMsg,
            CMSG_SIGNER_UNAUTH_ATTR_PARAM,
            dwSignerIndex,
            &cbData)) {
        printf("-----  Signer [%d] UnauthenticatedAttributes  -----\n",
            dwSignerIndex);
        PrintAttributes(pAttrs->cAttr, pAttrs->rgAttr, dwDisplayFlags);
        TestFree(pAttrs);
    }
}

static BOOL CompareSortedAttributes(
    IN DWORD dwSubject,
    IN PCTL_ENTRY pEntry,
    IN PCRYPT_DER_BLOB pEncodedAttributes
    )
{
    BOOL fResult;
    PCRYPT_ATTRIBUTES pAttrs = NULL;
    DWORD i;

    if (0 == pEntry->cAttribute) {
        if (0 != pEncodedAttributes->cbData) {
            printf("failed => Didn't expect sorted attributes for subject %d\n",
                dwSubject);
            return FALSE;
        } else
            return TRUE;
    }

    if (0 == pEncodedAttributes->cbData) {
        printf("failed => Expected sorted attributes for subject %d\n",
            dwSubject);
        return FALSE;
    }

    if (NULL == (pAttrs = (PCRYPT_ATTRIBUTES) TestNoCopyDecodeObject(
            PKCS_ATTRIBUTES,
            pEncodedAttributes->pbData,
            pEncodedAttributes->cbData
            )))
        goto ErrorReturn;

    if (pAttrs->cAttr != pEntry->cAttribute) {
        printf("failed => Wrong number of sorted attributes for subject %d\n",
            dwSubject);
        goto ErrorReturn;
    }

    for (i = 0; i < pAttrs->cAttr; i++) {
        PCRYPT_ATTRIBUTE pAttr = &pEntry->rgAttribute[i];
        PCRYPT_ATTRIBUTE pSortedAttr = &pAttrs->rgAttr[i];
        DWORD j;

        if (0 != strcmp(pAttr->pszObjId, pSortedAttr->pszObjId)) {
            printf("failed => wrong sorted attribute[%d] OID for subject %d\n",
                i, dwSubject);
            goto ErrorReturn;
        }

        if (pAttr->cValue != pSortedAttr->cValue) {
            printf("failed => Wrong number of values for attribute[%d] for subject %d\n",
                i, dwSubject);
            goto ErrorReturn;
        }

        for (j = 0; j < pAttr->cValue; j++) {
            PCRYPT_ATTR_BLOB pValue = &pAttr->rgValue[j];
            PCRYPT_ATTR_BLOB pSortedValue = &pSortedAttr->rgValue[j];
            if (pValue->cbData != pSortedValue->cbData ||
                (0 != pValue->cbData &&
                    0 != memcmp(pValue->pbData, pSortedValue->pbData,
                            pValue->cbData))) {
                printf("failed => bad value[%d, %d] for subject %d\n",
                    i, j, dwSubject);
                goto ErrorReturn;
            }
        }
    }

    fResult = TRUE;

CommonReturn:
    TestFree(pAttrs);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


void DisplayCtl(PCCTL_CONTEXT pCtl, DWORD dwDisplayFlags, HCERTSTORE hStore)
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;
    PCCTL_CONTEXT pSortedCtl;

    if (dwDisplayFlags & DISPLAY_UI_FLAG) {
        DisplayContextUI(CERT_STORE_CTL_CONTEXT, pCtl);
        dwDisplayFlags = DISPLAY_BRIEF_FLAG;
    }

    // Test the creation of a sorted CTL. Its decoded output should match
    // the normal decoded CTL.
    if (NULL == (pSortedCtl = (PCCTL_CONTEXT) CertCreateContext(
            CERT_STORE_CTL_CONTEXT,
            pCtl->dwMsgAndCertEncodingType,
            pCtl->pbCtlEncoded,
            pCtl->cbCtlEncoded,
            CERT_CREATE_CONTEXT_NOCOPY_FLAG |
                CERT_CREATE_CONTEXT_SORTED_FLAG,
            NULL                                    // pCreatePara
            )))
        PrintLastError("CertCreateContext(CTL => NOCOPY, SORTED)");
    else {
        PCTL_INFO pSortedInfo = pSortedCtl->pCtlInfo;
        DWORD cEntry = pInfo->cCTLEntry;
        PCTL_ENTRY pEntry = pInfo->rgCTLEntry;
        DWORD iEntry;
        void *pvNextSubject;
        CRYPT_DER_BLOB SubjectIdentifier;
        CRYPT_DER_BLOB EncodedAttributes;

        // Check that the sorted info matches
        if (pSortedInfo->dwVersion != pInfo->dwVersion ||
                pSortedInfo->SubjectUsage.cUsageIdentifier !=
                    pInfo->SubjectUsage.cUsageIdentifier ||
                0 != CompareFileTime(&pSortedInfo->ThisUpdate,
                    &pInfo->ThisUpdate) ||
                0 != CompareFileTime(&pSortedInfo->NextUpdate,
                    &pInfo->NextUpdate) ||
                0 != strcmp(pSortedInfo->SubjectAlgorithm.pszObjId,
                        pInfo->SubjectAlgorithm.pszObjId) ||
                pSortedInfo->SubjectAlgorithm.Parameters.cbData !=
                        pInfo->SubjectAlgorithm.Parameters.cbData)
            printf("failed => SortedCtl info doesn't match Ctl info\n");
        else {
            // Check that the sorted extensions match
            DWORD cExt = pInfo->cExtension;
            PCERT_EXTENSION pExt = pInfo->rgExtension;
            DWORD cSortedExt = pSortedInfo->cExtension;
            PCERT_EXTENSION pSortedExt = pSortedInfo->rgExtension;

            if (cExt > 0 && 0 == strcmp(pExt->pszObjId, szOID_SORTED_CTL)) {
                cExt--,
                pExt++;
            }

            if (cSortedExt != cExt)
                printf("failed => SortedCtl extension count doesn't match Ctl\n");
            else {
                for ( ; cExt; cExt--, pSortedExt++, pExt++) {
                    if (0 != strcmp(pSortedExt->pszObjId, pExt->pszObjId) ||
                                pSortedExt->fCritical != pExt->fCritical ||
                            pSortedExt->Value.cbData != pExt->Value.cbData) {
                        printf("failed => SortedCtl extension doesn't match Ctl\n");
                        break;
                    }
                    if (pSortedExt->Value.cbData && 0 != memcmp(
                            pSortedExt->Value.pbData, pExt->Value.pbData,
                                pSortedExt->Value.cbData)) {
                        printf("failed => SortedCtl extension doesn't match Ctl\n");
                        break;
                    }
                }
            }
        }
        

        pvNextSubject = NULL;
        iEntry = 0;
        while (CertEnumSubjectInSortedCTL(
                pSortedCtl,
                &pvNextSubject,
                &SubjectIdentifier,
                &EncodedAttributes
                )) {
            if (iEntry >= cEntry) {
                printf( "failed => CertEnumSubjectInSortedCTL(too many subjects)\n");
                break;
            }
            if (SubjectIdentifier.cbData !=
                        pEntry[iEntry].SubjectIdentifier.cbData ||
                    0 != memcmp(SubjectIdentifier.pbData,
                            pEntry[iEntry].SubjectIdentifier.pbData,
                            SubjectIdentifier.cbData)) {
                printf("failed => CertEnumSubjectsInSortedCTL(invalid subject %d)\n",
                    iEntry);
                iEntry = cEntry;
                break;
            }
            if (!CompareSortedAttributes(
                    iEntry,
                    &pEntry[iEntry],
                    &EncodedAttributes
                    )) {
                iEntry = cEntry;
                break;
            }

            iEntry++;
        }

        if (iEntry != cEntry)
            printf( "failed => CertEnumSubjectInSortedCTL(missing subjects)\n");

        if (0 == cEntry) {
            BYTE rgbIdentifier[] = {0x1, 0x2};
            SubjectIdentifier.pbData = rgbIdentifier;
            SubjectIdentifier.cbData = sizeof(rgbIdentifier);

            if (CertFindSubjectInSortedCTL(
                    &SubjectIdentifier,
                    pSortedCtl,
                    0,                      // dwFlags
                    NULL,                   // pvReserved,
                    &EncodedAttributes
                    ))
                printf("failed => CertFindSubjectInSortedCTL returned success for no entries\n");
            else if (GetLastError() != CRYPT_E_NOT_FOUND)
                printf("failed => CertFindSubjectInSortedCTL didn't return CRYPT_E_NOT_FOUND for no entries\n");
        } else {
            DWORD rgiEntry[] = {0, cEntry/3, cEntry/2, cEntry -1};
            DWORD i;
            for (i = 0; i < sizeof(rgiEntry) / sizeof(rgiEntry[0]); i++) {
                iEntry = rgiEntry[i];
                if (!CertFindSubjectInSortedCTL(
                        &pEntry[iEntry].SubjectIdentifier,
                        pSortedCtl,
                        0,                      // dwFlags
                        NULL,                   // pvReserved,
                        &EncodedAttributes
                        )) {
                    PrintLastError("CertFindSubjectInSortedCTL");
                    break;
                }
            }
        }

        CertFreeCTLContext(pSortedCtl);
    }

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        printf("Version:: %d\n", pInfo->dwVersion);

    {
        DWORD cId;
        LPSTR *ppszId;
        DWORD i;

        printf("SubjectUsage::\n");
        cId = pInfo->SubjectUsage.cUsageIdentifier;
        ppszId = pInfo->SubjectUsage.rgpszUsageIdentifier;
        if (cId == 0)
            printf("  No Usage Identifiers\n");
        for (i = 0; i < cId; i++, ppszId++)
            printf("  [%d] %s\n", i, *ppszId);
    }

    if (pInfo->ListIdentifier.cbData) {
        printf("ListIdentifier::\n");
        PrintBytes("    ",
            pInfo->ListIdentifier.pbData,
            pInfo->ListIdentifier.cbData);
    }
    if (pInfo->SequenceNumber.cbData) {
        printf("SequenceNumber::");
        DisplaySerialNumber(&pInfo->SequenceNumber);
        printf("\n");
    }

    printf("ThisUpdate:: %s\n", FileTimeText(&pCtl->pCtlInfo->ThisUpdate));
    printf("NextUpdate:: %s\n", FileTimeText(&pCtl->pCtlInfo->NextUpdate));
    if (!IsTimeValidCtl(pCtl))
        printf("****** Time Invalid CTL\n");

    {
        BYTE rgbHash[MAX_HASH_LEN];
        DWORD cbHash = MAX_HASH_LEN;
        CertGetCTLContextProperty(
            pCtl,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("SHA1", rgbHash, cbHash);
#if 0
        CertGetCTLContextProperty(
            pCtl,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &cbHash
            );
        DisplayThumbprint("MD5", rgbHash, cbHash);
#endif
    }

    PrintAuxCtlProperties(pCtl, dwDisplayFlags);

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        LPSTR pszObjId;

        pszObjId = pInfo->SubjectAlgorithm.pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        printf("SubjectAlgorithm:: %s\n", pszObjId);
        if (pInfo->SubjectAlgorithm.Parameters.cbData) {
            printf("SubjectAlgorithm.Parameters::\n");
            PrintBytes("    ",
                pInfo->SubjectAlgorithm.Parameters.pbData,
                pInfo->SubjectAlgorithm.Parameters.cbData);
        }

        if (pInfo->cExtension != 0) {
            PrintExtensions(pInfo->cExtension, pInfo->rgExtension,
                dwDisplayFlags);
        }
    }

    if (dwDisplayFlags & DISPLAY_NO_ISSUER_FLAG)
        ;
    else if (0 == (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)) {
        DWORD dwFlags;
        PCCERT_CONTEXT pSigner;

        if (dwDisplayFlags & DISPLAY_CHECK_FLAG)
            dwFlags = 0;
        else
            dwFlags = CMSG_SIGNER_ONLY_FLAG;
        if (CryptMsgGetAndVerifySigner(
                pCtl->hCryptMsg,
                1,                  // cSignerStore
                &hStore,            // rghSignerStore
                dwFlags,
                &pSigner,
                NULL                // pdwSignerIndex
                )) {
            printf("-----  Signer  -----\n");
            DisplayCert(pSigner, dwDisplayFlags & DISPLAY_BRIEF_FLAG);
            CertFreeCertificateContext(pSigner);
        } else {
            DWORD dwErr = GetLastError();
            if (CRYPT_E_NO_TRUSTED_SIGNER == dwErr)
                printf("-----  No Trusted Signer  -----\n");
            else {
                printf("-----  Signer  -----\n");
                PrintLastError("CryptMsgGetAndVerifySigner");
            }
        }
    } else {
        DWORD dwSignerCount;
        DWORD cbData;

        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                pCtl->hCryptMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData)) {
            printf("-----  Signer  -----\n");
            PrintLastError("CryptMsgGetParam(SIGNER_COUNT)");
        } else if (0 == dwSignerCount)
            printf("-----  No Signers  -----\n");
        else {
            DWORD dwSignerIndex;
            for (dwSignerIndex = 0; dwSignerIndex < dwSignerCount;
                                                            dwSignerIndex++) {
                DWORD dwFlags;
                PCCERT_CONTEXT pSigner;

                dwFlags = CMSG_USE_SIGNER_INDEX_FLAG;
                if (0 == (dwDisplayFlags & DISPLAY_CHECK_FLAG))
                    dwFlags |= CMSG_SIGNER_ONLY_FLAG;
                if (CryptMsgGetAndVerifySigner(
                        pCtl->hCryptMsg,
                        1,                  // cSignerStore
                        &hStore,            // rghSignerStore
                        dwFlags,
                        &pSigner,
                        &dwSignerIndex
                        )) {
                    printf("-----  Signer [%d]  -----\n", dwSignerIndex);
                    DisplayCert(pSigner, 0);
                    CertFreeCertificateContext(pSigner);
                } else {
                    DWORD dwErr = GetLastError();
                    if (CRYPT_E_NO_TRUSTED_SIGNER == dwErr)
                        printf("-----  No Trusted Signer [%d]  -----\n",
                            dwSignerIndex);
                    else {
                        printf("-----  Signer [%d]  -----\n", dwSignerIndex);
                        PrintLastError("CryptMsgGetAndVerifySigner");
                    }
                }

                DisplaySignerInfo(pCtl->hCryptMsg, dwSignerIndex,
                    dwDisplayFlags);
            }
        }
    }

    if (0 == (dwDisplayFlags & DISPLAY_BRIEF_FLAG)) {
        if (pInfo->cCTLEntry == 0)
            printf("-----  No Entries  -----\n");
        else {
            printf("-----  Entries  -----\n");
            PrintCtlEntries(pCtl, dwDisplayFlags, hStore);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\certtest\certtest.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       certtest.h
//
//  Contents:   Certificate Test Helper API Prototypes and Definitions
//
//  History:    11-Apr-96   philh   created
//--------------------------------------------------------------------------

#ifndef __CERTTEST_H__
#define __CERTTEST_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "wincrypt.h"
#include "mssip.h"
#include "sipbase.h"
#include "softpub.h"
#include "signutil.h"

#define MAX_HASH_LEN  20

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
void PrintError(LPCSTR pszMsg);
void PrintLastError(LPCSTR pszMsg);

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
LPVOID
WINAPI
TestAlloc(
    IN size_t cbBytes
    );


LPVOID
WINAPI
TestRealloc(
    IN LPVOID pvOrg,
    IN size_t cbBytes
    );

VOID
WINAPI
TestFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string
//--------------------------------------------------------------------------
LPWSTR AllocAndSzToWsz(LPCSTR psz);

//+-------------------------------------------------------------------------
//  Useful display functions
//--------------------------------------------------------------------------
LPCSTR FileTimeText(FILETIME *pft);
void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize);

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL ReadDERFromFile(
    LPCSTR  pszFileName,
    PBYTE   *ppbDER,
    PDWORD  pcbDER
    );

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    );

//+-------------------------------------------------------------------------
//  Get the default Crypt Provider. Create the private signature/exchange
//  if they don't already exist.
//--------------------------------------------------------------------------
HCRYPTPROV GetCryptProv();

//+-------------------------------------------------------------------------
//  Open/Save the specified cert store
//--------------------------------------------------------------------------
HCERTSTORE OpenStore(BOOL fSystemStore, LPCSTR pszStoreFilename);
HCERTSTORE OpenStoreEx(BOOL fSystemStore, LPCSTR pszStoreFilename,
    DWORD dwFlags);
// returns NULL if unable to open. Doesn't open memory store as in the above
// 2 versions of OpenStore
HCERTSTORE OpenSystemStoreOrFile(BOOL fSystemStore, LPCSTR pszStoreFilename,
    DWORD dwFlags);
void SaveStore(HCERTSTORE hStore, LPCSTR pszSaveFilename);
void SaveStoreEx(HCERTSTORE hStore, BOOL fPKCS7Save, LPCSTR pszSaveFilename);

//+-------------------------------------------------------------------------
//  Open the specified cert store or SPC file
//
//  No longer supported. The above OpenStore tries opening as
//  SPC if unable to open as a store.
//--------------------------------------------------------------------------
HCERTSTORE OpenStoreOrSpc(BOOL fSystemStore, LPCSTR pszStoreFilename,
    BOOL *pfSpc);

//+-------------------------------------------------------------------------
//  Certificate encoding type used by cert test routines.
//  The default is X509_ASN_ENCODING;
//--------------------------------------------------------------------------
extern DWORD dwCertEncodingType;

//+-------------------------------------------------------------------------
//  Message encoding type used by cert test routines.
//  The default is PKCS_7_ASN_ENCODING;
//--------------------------------------------------------------------------
extern DWORD dwMsgEncodingType;


//+-------------------------------------------------------------------------
//  Message and certificate encoding type used by cert test routines.
//  The default is PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
//--------------------------------------------------------------------------
extern DWORD dwMsgAndCertEncodingType;

//+-------------------------------------------------------------------------
//  Certificate Display definitions and APIs
//--------------------------------------------------------------------------
// Display flags
#define DISPLAY_VERBOSE_FLAG        0x00000001
#define DISPLAY_CHECK_FLAG          0x00000002
#define DISPLAY_BRIEF_FLAG          0x00000004
#define DISPLAY_KEY_THUMB_FLAG      0x00000008
#define DISPLAY_UI_FLAG             0x00000010
#define DISPLAY_NO_ISSUER_FLAG      0x00000100
#define DISPLAY_CHECK_SIGN_FLAG     0x00001000
#define DISPLAY_CHECK_TIME_FLAG     0x00002000

void DisplayVerifyFlags(LPSTR pszHdr, DWORD dwFlags);

void DisplayCert(
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags = 0,
    DWORD dwIssuer = 0
    );
void DisplayCert2(
    HCERTSTORE hStore,          // needed when displaying cert from file
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags = 0,
    DWORD dwIssuer = 0
    );
void DisplayCrl(
    PCCRL_CONTEXT pCrl,
    DWORD dwDisplayFlags = 0
    );
void DisplayCtl(
    PCCTL_CONTEXT pCtl,
    DWORD dwDisplayFlags = 0,
    HCERTSTORE hStore = NULL
    );

void DisplaySignerInfo(
    HCRYPTMSG hMsg,
    DWORD dwSignerIndex = 0,
    DWORD dwDisplayFlags = 0
    );

void DisplayStore(
    IN HCERTSTORE hStore,
    IN DWORD dwDisplayFlags = 0
    );

// Not displayed when DISPLAY_BRIEF_FLAG is set
void DisplayCertKeyProvInfo(
    PCCERT_CONTEXT pCert,
    DWORD dwDisplayFlags = 0
    );

void PrintCrlEntries(
    DWORD cEntry,
    PCRL_ENTRY pEntry,
    DWORD dwDisplayFlags = 0
    );

//+-------------------------------------------------------------------------
//  Returns TRUE if the CTL is still time valid.
//
//  A CTL without a NextUpdate is considered time valid.
//--------------------------------------------------------------------------
BOOL IsTimeValidCtl(
    IN PCCTL_CONTEXT pCtl
    );

//+-------------------------------------------------------------------------
//  Display structures used in Software Publishing Certificate (SPC)
//--------------------------------------------------------------------------
void DisplaySpcLink(PSPC_LINK pSpcLink);

//+-------------------------------------------------------------------------
//  Returns OID's name string. If not found returns L"???".
//--------------------------------------------------------------------------
LPCWSTR GetOIDName(LPCSTR pszOID, DWORD dwGroupId = 0);

//+-------------------------------------------------------------------------
//  Returns OID's Algid. If not found returns 0.
//--------------------------------------------------------------------------
ALG_ID GetAlgid(LPCSTR pszOID, DWORD dwGroupId = 0);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\pkcs8ex\pkcs8ex.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       pkcs8ex.cpp
//
//  Contents:   Private Key Save Test
//
//              See Usage() for list of save options.
//
//  Functions:  main
//
//  History:    11-May-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static struct
{
    LPCSTR      pszName;
    LPCWSTR     pwszKeyTitle;
    DWORD       dwKeySpec;
} KeyTypes[] = {
    "Sign",     L"Signature",   AT_SIGNATURE,
    "Xchg",     L"Exchange",    AT_KEYEXCHANGE
};
#define NKEYTYPES (sizeof(KeyTypes)/sizeof(KeyTypes[0]))


static void Usage(void)
{
    int i;

    printf("Usage: pkcs8ex [options] <Filename> <KeyType>\n");
    printf("Options are:\n");
    printf("  -p<name>              - Crypto provider name (if not default)\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -d                    - Delete from provider after saving\n");
    printf("  -h                    - This message\n");
    printf("\n");
    printf("KeyType (case insensitive):\n");
    
	for (i = 0; i < NKEYTYPES; i++)
		printf("  %s\n", KeyTypes[i].pszName);
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    HCRYPTPROV hProv = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwProvType = PROV_RSA_FULL;
    BOOL fDelete = FALSE;
    LPSTR pszContainer = NULL;
    LPSTR pszFilename = NULL;
    BYTE *pbKey = NULL;
	DWORD cbKey = 0;
    LPSTR pszKeyType = NULL;
    int KeyIdx = 0;
	DWORD numBytesWritten;
	DWORD dwFlags;

    while (--argc>0)
    {
		if (**++argv == '-')
		{
			switch(argv[0][1])
			{
			case 'd':
				fDelete = TRUE;
				break;
			case 'p':
				dwProvType = strtoul( argv[0]+2, NULL, 10);
				break;
			case 'c':
				pszContainer = argv[0]+2;
				if (*pszContainer == '\0') {
					printf("Need to specify crypto key container name\n");
					goto BadUsage;
				}
				break;
			case 'h':
				default:
				goto BadUsage;
			}
		} else {
			if (pszFilename == NULL)
				pszFilename = argv[0];
			else if(pszKeyType == NULL)
				pszKeyType = argv[0];
			else {
				printf("Too many arguments\n");
			goto BadUsage;
			}
		}
    }

	printf("command line: %s\n", GetCommandLine());

    if (pszFilename == NULL) {
		printf("missing Filename\n");
		goto BadUsage;
    }


    if (pszKeyType) {
		for (KeyIdx = 0; KeyIdx < NKEYTYPES; KeyIdx++) {
			if (_stricmp(pszKeyType, KeyTypes[KeyIdx].pszName) == 0)
				break;
	}
	if (KeyIdx >= NKEYTYPES) {
	    printf("Bad KeyType: %s\n", pszKeyType);
	    goto BadUsage;
	}
    } else {
		printf("missing KeyType\n");
		goto BadUsage;
    }

    if (!CryptAcquireContext(
			&hProv,
			pszContainer,
			NULL,           // pszProvider
			dwProvType,
			0               // dwFlags
			)) {
		PrintLastError("CryptAcquireContext\n");
		goto ErrorReturn;
    }

    hFile = CreateFileA(
	    pszFilename,
	    GENERIC_READ | GENERIC_WRITE,
	    FILE_SHARE_READ,
	    NULL,                   // lpsa
	    CREATE_ALWAYS,
	    FILE_ATTRIBUTE_NORMAL,
	    NULL                    // hTemplateFile
	    );
    if (hFile == INVALID_HANDLE_VALUE) {
		printf("can't open %s\n", pszFilename);
		printf("Failed");
		goto ErrorReturn;
    }
	
	if (!CryptExportPKCS8(
			hProv,                  
			KeyTypes[KeyIdx].dwKeySpec,             
			szOID_RSA_RSA,
			0,                      
			NULL,                   
			NULL,   
			&cbKey)) {
		PrintLastError("CryptExportPKCS8");
		goto ErrorReturn;
    }

	if (NULL == (pbKey = (BYTE *) TestAlloc(cbKey))) {
		printf("memory allocation error\n");
		goto ErrorReturn;
    }

	/*if (fDelete)
		dwFlags = DELETE_KEYSET;
	else
		dwFlags = 0;*/

	if (!CryptExportPKCS8(
			hProv,                  
			KeyTypes[KeyIdx].dwKeySpec,             
			szOID_RSA_RSA,
			0,                      
			NULL,                   
			pbKey,  
			&cbKey)) {
		PrintLastError("CryptExportPKCS8");
		goto ErrorReturn;
    }

	
	if (!WriteFile( 
			hFile, 
			pbKey, 
			cbKey, 
			&numBytesWritten, 
			NULL)) {
		PrintLastError("WriteFile");
		goto ErrorReturn;
    }
	
	if (fDelete) {
		// Delete the existing keys
		CryptReleaseContext(hProv, 0);
		printf("Deleting existing private keys\n");

		// Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined
		// and must not be released.
		if (!CryptAcquireContext(
				&hProv,
				pszContainer,
				NULL,           // pszProvider
				dwProvType,
				CRYPT_DELETEKEYSET
				)) {
				PrintLastError("CryptAcquireContext(CRYPT_DELETEKEYSET)");
				hProv = 0;
				goto ErrorReturn;
		}
		hProv = 0;
    }
	    
    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
    if (hFile != INVALID_HANDLE_VALUE) {
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
		DeleteFile(pszFilename);
    }
CommonReturn:
    if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
    if (hProv)
		CryptReleaseContext(hProv, 0);
    if (pbKey)
		TestFree(pbKey);

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tcert\tcert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tcert.cpp
//
//  Contents:   Certificate and CRL Encode/Decode API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    04-Mar-96   philh   created
//              07-Jun-96   HelleS  Added printing the command line
//                                  and Failed or Passed at the end.
//              20-Aug-96   jeffspel name changes
//              
//--------------------------------------------------------------------------

#include <windows.h>
#include <regstr.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

#include <wincrypt.h>
#include <signcde.h>
//#include <crypt32l.h>


// Note: the SubjectPublicKey is really the PKCS #1 ASN encoding of the
// following information. However, since the SubjectPublicKeyInfo.PublicKey
// is a CRYPT_BIT_BLOB that following is OK for testing purposes.
#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#endif
// Build my own CAPI public key
typedef struct _CAPI_PUB_KEY {
    PUBLICKEYSTRUC PubKeyStruc;
    RSAPUBKEY RsaPubKey;
    BYTE rgbModulus[10];
} CAPI_PUB_KEY;

static const CAPI_PUB_KEY SubjectPublicKey = {
    {PUBLICKEYBLOB, CUR_BLOB_VERSION, 0, CALG_RSA_SIGN},    // PUBLICKEYSTRUC
    {RSA1, 10*8, 4},        // RSAPUBKEY
    {0,1,2,3,4,5,6,7,8,9}   // rgbModulus
};

static LPSTR pszReadFilename = NULL;
static LPSTR pszPublicKeyFilename = NULL;
static BOOL fWritePublicKeyInfo = FALSE;

static LPSTR pszForwardCertFilename = NULL;
static LPSTR pszReverseCertFilename = NULL;

//+-------------------------------------------------------------------------
// Parameters, data used to encode the messages.
//--------------------------------------------------------------------------
static DWORD dwCertEncodingType = X509_ASN_ENCODING;

static DWORD dwDecodeObjectFlags = 0;
static BOOL fFormatNameStrings = FALSE;
static BOOL fFormatAllNameStrings = FALSE;
static DWORD dwExtLen = 0;

static LPCSTR pszOIDNoSignHash = szOID_OIWSEC_sha1;

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
static void PrintError(LPCSTR pszMsg)
{
    printf("%s\n", pszMsg);
}
static void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

void PrintNoError(LPCSTR pszMsg)
{
    printf("%s failed => expected error\n", pszMsg);
}

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
static void *TestAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}
static void TestFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}

static CRYPT_DECODE_PARA TestDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(TestDecodePara.pfnFree),
    TestAlloc,
    TestFree
};

static void *TestDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT OPTIONAL DWORD *pcbStructInfo = NULL
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwDecodeObjectFlags | CRYPT_DECODE_ALLOC_FLAG,
            &TestDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;

ErrorReturn:
    if ((DWORD_PTR) lpszStructType <= 0xFFFF)
        printf("CryptDecodeObject(StructType: %d)",
            (DWORD)(DWORD_PTR) lpszStructType);
    else
        printf("CryptDecodeObject(StructType: %s)",
            lpszStructType);
    PrintLastError("");

    pvStructInfo = NULL;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Allocate and read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL
ReadDERFromFile(
    LPCSTR  pszFileName,
    PBYTE   *ppbDER,
    PDWORD  pcbDER
    )
{
    BOOL        fRet;
    HANDLE      hFile = 0;
    PBYTE       pbDER = NULL;
    DWORD       cbDER;
    DWORD       cbRead;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszFileName);
        goto ErrorReturn;
    }

    cbDER = GetFileSize( hFile, NULL);
    if (cbDER == 0) {
        printf( "empty file %s\n", pszFileName);
        goto ErrorReturn;
    }
    if (NULL == (pbDER = (PBYTE)TestAlloc(cbDER))) {
        printf( "can't alloc %d bytes\n", cbDER);
        goto ErrorReturn;
    }
    if (!ReadFile( hFile, pbDER, cbDER, &cbRead, NULL) ||
            (cbRead != cbDER)) {
        printf( "can't read %s\n", pszFileName);
        goto ErrorReturn;
    }

    *ppbDER = pbDER;
    *pcbDER = cbDER;
    fRet = TRUE;
CommonReturn:
    if (hFile)
        CloseHandle(hFile);
    return fRet;
ErrorReturn:
    if (pbDER)
        TestFree(pbDER);
    *ppbDER = NULL;
    *pcbDER = 0;
    fRet = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL
WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
        PrintLastError("WriteDERToFile::CreateFile");
    } else {
        DWORD dwBytesWritten;
        if (!(fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                )))
            PrintLastError("WriteDERToFile::WriteFile");
        CloseHandle(hFile);
    }
    return fResult;
}


typedef BOOL (*PFN_ENCODE)(BYTE **ppbEncoded, DWORD *pcbEncoded);
typedef BOOL (*PFN_DECODE)(BYTE *pbEncoded, DWORD cbEncoded);
typedef struct _TEST {
    LPCSTR      pszName;
    PFN_ENCODE  pfnEncode;
    PFN_DECODE  pfnDecode;
} TEST, *PTEST;

static BOOL EncodeCert(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeCert(BYTE *pbEncoded, DWORD cbEncoded);
static BOOL EncodeCrl(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeCrl(BYTE *pbEncoded, DWORD cbEncoded);
static BOOL EncodeCertReq(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeCertReq(BYTE *pbEncoded, DWORD cbEncoded);
static BOOL EncodeKeygenReq(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeKeygenReq(BYTE *pbEncoded, DWORD cbEncoded);
static BOOL EncodeContentInfo(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeContentInfo(BYTE *pbEncoded, DWORD cbEncoded);
static BOOL EncodeCertPair(BYTE **ppbEncoded, DWORD *pcbEncoded);
static BOOL DecodeCertPair(BYTE *pbEncoded, DWORD cbEncoded);

TEST Tests[] = {
    "cert",         EncodeCert,         DecodeCert,
    "crl",          EncodeCrl,          DecodeCrl,
    "certReq",      EncodeCertReq,      DecodeCertReq,
    "keygenReq",    EncodeKeygenReq,    DecodeKeygenReq,
    "ContentInfo",  EncodeContentInfo,  DecodeContentInfo,
    "CertPair",     EncodeCertPair,     DecodeCertPair
};
#define NTESTS (sizeof(Tests)/sizeof(Tests[0]))

static void Usage(void)
{
    int i;

    printf("Usage: tcert [options] [<ContentType>]\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -r<filename>          - Read encoded content from file\n");
    printf("  -w<filename>          - Write encoded content to file\n");
    printf("  -p<filename>          - Write public key to file\n");
    printf("  -P<filename>          - Write Name, PublicKeyInfo to file\n");
    printf("  -f                    - Enable name string formatting\n");
    printf("  -fAll                 - Name string formatting (All types)\n");
    printf("  -N                    - Enable NOCOPY decode\n");
    printf("  -o<OID>               - NoSignHash OID (SHA1 is default)\n");
    printf("  -X<number>            - eXtension byte length\n");
    printf("  -F<CertFilename>      - CertPair Forward certificate\n");
    printf("  -R<CertFilename>      - CertPair Reverse certificate\n");
    printf("\n");
    printf("ContentTypes (case insensitive):\n");
    for (i = 0; i < NTESTS; i++)
        printf("  %s\n", Tests[i].pszName);
    printf("\n");
    printf("Default: %s\n", Tests[0].pszName);
}

int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    BOOL fResult;

    LPCSTR pszName = Tests[0].pszName;
    LPSTR pszWriteFilename = NULL;
    int c;
    PTEST pTest;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

/*
    if (!Crypt32DllMain( NULL, DLL_PROCESS_ATTACH, NULL)) {
        printf("Crypt32DllMain attach failed, aborting\n");
        ReturnStatus = -1;
        goto CommonReturn;
    }
*/

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'r':
                pszReadFilename = argv[0]+2;
                if (*pszReadFilename == '\0') {
                    printf("Need to specify filename\n");
                    goto BadUsage;
                }
                break;
            case 'w':
                pszWriteFilename = argv[0]+2;
                if (*pszWriteFilename == '\0') {
                    printf("Need to specify filename\n");
                    goto BadUsage;
                }
                break;
            case 'P':
                fWritePublicKeyInfo = TRUE;
            case 'p':
                pszPublicKeyFilename = argv[0]+2;
                if (*pszPublicKeyFilename == '\0') {
                    printf("Need to specify filename\n");
                    goto BadUsage;
                }
                break;
            case 'F':
                pszForwardCertFilename = argv[0]+2;
                if (*pszForwardCertFilename == '\0') {
                    printf("Need to specify Forward filename\n");
                    goto BadUsage;
                }
                break;
            case 'R':
                pszReverseCertFilename = argv[0]+2;
                if (*pszReverseCertFilename == '\0') {
                    printf("Need to specify Reverse filename\n");
                    goto BadUsage;
                }
                break;
            case 'N':
                dwDecodeObjectFlags |= CRYPT_DECODE_NOCOPY_FLAG;
                break;
            case 'X':
                dwExtLen = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'f':
                if (argv[0][2]) {
                    if (0 != _stricmp(argv[0]+2, "ALL")) {
                        printf("Need to specify -fALL\n");
                        goto BadUsage;
                    }
                    fFormatAllNameStrings = TRUE;
                } else
                    fFormatNameStrings = TRUE;
                break;
            case 'o':
                pszOIDNoSignHash = (LPCSTR) argv[0]+2;
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else
            pszName = argv[0];
    }

    for (c = NTESTS, pTest = Tests; c > 0; c--, pTest++) {
        if (_stricmp(pszName, pTest->pszName) == 0)
            break;
    }
    if (c == 0) {
        printf("Bad ContentType: %s\n", pszName);
        goto BadUsage;
    }
            
    printf("command line: %s\n", GetCommandLine());

    if (pszReadFilename) printf("Reading from: %s ", pszReadFilename);
    if (pszWriteFilename) printf("Writing to: %s ", pszWriteFilename);
    if (pszPublicKeyFilename) {
        if (fWritePublicKeyInfo)
            printf("PublicKeyInfo to: %s ", pszPublicKeyFilename);
        else
            printf("Public Key to: %s ", pszPublicKeyFilename);
    }
    if (pszForwardCertFilename)
        printf("ForwardCert: %s ", pszForwardCertFilename);
    if (pszReverseCertFilename)
        printf("ReverseCert: %s ", pszReverseCertFilename);
    printf("\n");

    if (pszReadFilename)
        fResult = ReadDERFromFile(pszReadFilename, &pbEncoded, &cbEncoded);
    else
        fResult = pTest->pfnEncode(&pbEncoded, &cbEncoded);

    if (fResult) {
        if (pszWriteFilename)
            WriteDERToFile(pszWriteFilename, pbEncoded, cbEncoded);
        pTest->pfnDecode(pbEncoded, cbEncoded);
        TestFree(pbEncoded);
    }

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
    ReturnStatus = -1;
CommonReturn:
    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");

/*
    if (!Crypt32DllMain( NULL, DLL_PROCESS_DETACH, NULL)) {
        printf("Crypt32DllMain detach failed, aborting\n");
        ReturnStatus = -1;
    }
*/

    return ReturnStatus;

}

static BOOL EncodeSignedContent(
    BYTE *pbToBeSigned,
    DWORD cbToBeSigned,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbSignature = NULL;
    DWORD cbSignature;
    CERT_SIGNED_CONTENT_INFO CertEncoding;

    CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm = {
        (LPSTR) pszOIDNoSignHash, 0, 0
    };

    CRYPT_DATA_BLOB EncodedBlob;

    cbSignature = 0;
    if (!CryptSignCertificate(
            NULL,               // hCryptProv
            0,                  // dwKeySpec
            dwCertEncodingType,
            pbToBeSigned,
            cbToBeSigned,
            &SignatureAlgorithm,
            NULL,               // pvHashAuxInfo
            NULL,               // pbSignature
            &cbSignature
            )) {
        PrintLastError("EncodeSignedContent::CryptSignCertificate(cbEncoded == 0)");
        goto ErrorReturn;
    }

    pbSignature = (BYTE *) TestAlloc(cbSignature);
    if (pbSignature == NULL) goto ErrorReturn;
    if (!CryptSignCertificate(
            NULL,               // hCryptProv
            0,                  // dwKeySpec
            dwCertEncodingType,
            pbToBeSigned,
            cbToBeSigned,
            &SignatureAlgorithm,
            NULL,               // pvHashAuxInfo
            pbSignature,
            &cbSignature
            )) {
        PrintLastError("EncodeSignedContent::CryptSignCertificate");
        goto ErrorReturn;
    }

    ZeroMemory(&CertEncoding, sizeof(CertEncoding));
    CertEncoding.ToBeSigned.pbData = pbToBeSigned;
    CertEncoding.ToBeSigned.cbData = cbToBeSigned;
    CertEncoding.SignatureAlgorithm = SignatureAlgorithm;
    CertEncoding.Signature.pbData = pbSignature;
    CertEncoding.Signature.cbData = cbSignature;
    cbEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT,
            &CertEncoding,
            NULL,                       // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError("EncodeSignedContent::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) TestAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT,
            &CertEncoding,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError("EncodeSignedContent::CryptEncodeObject");
        goto ErrorReturn;
    }

    EncodedBlob.cbData = cbEncoded;
    EncodedBlob.pbData = pbEncoded;

    if (!CryptVerifyCertificateSignatureEx(
            NULL,                   // hCryptProv
            dwCertEncodingType,
            CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB,
            (void *) &EncodedBlob,
            CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL,
            NULL,                   // pvIssuer
            0,                      // dwFlags
            NULL                    // pvReserved
            )) {
        PrintLastError("EncodeSignedContent::CryptVerifyCertificateSignatureEx");
    }


    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbSignature)
        TestFree(pbSignature);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
}

static void PrintBadUnicodeEncode(LPCSTR pszMsg, DWORD dwExpectedErr,
        DWORD cbEncoded)
{
    DWORD dwErr = GetLastError();

    if (dwErr != dwExpectedErr)
        printf("%s failed => expected : 0x%x (%d), LastError: 0x%x (%d)\n", 
            pszMsg, dwExpectedErr, dwExpectedErr, dwErr, dwErr);
    printf("%s bad unicode encode => LastError: 0x%x (%d) ",
        pszMsg, dwErr, dwErr);
    printf("cbEncoded: 0x%x RDN: %d Attr: %d Value: %d\n",
        cbEncoded,
        GET_CERT_UNICODE_RDN_ERR_INDEX(cbEncoded),
        GET_CERT_UNICODE_ATTR_ERR_INDEX(cbEncoded),
        GET_CERT_UNICODE_VALUE_ERR_INDEX(cbEncoded));
}

static void DoBadEncodeIssuer()
{
    DWORD cbIssuerEncoded;

    CERT_RDN_ATTR rgBadPrintableAttr[] = {
        // 0 - rgdwPrintableOrT61ValueType,
        szOID_COMMON_NAME, 0, 0,
            (BYTE *) L"CN: printable or t61",

        // 1 - rgdwPrintableOrT61ValueType,
        szOID_LOCALITY_NAME, 0, 0,
            (BYTE *) L"L: printable or t61 \"###\"",

        // 2 - BAD rgdwPrintableValueType,
        szOID_COUNTRY_NAME, 0, 0,
            (BYTE *) L"C: printable ### az AZ 09 \'()+,-./:=? "
    };
    CERT_RDN rgBadPrintableRDN[] = {
        1, &rgBadPrintableAttr[0],
        3, &rgBadPrintableAttr[0]
    };
    CERT_NAME_INFO BadPrintableName = {2, rgBadPrintableRDN};

    CERT_RDN_ATTR rgBadNumericAttr[] = {
        // 0 - rgdwPrintableOrT61ValueType,
        szOID_COMMON_NAME, 0, 0,
            (BYTE *) L"CN: printable or t61",

        // 1 - rgdwPrintableValueType,
        szOID_COUNTRY_NAME, 0, 0,
            (BYTE *) L"C: printable az AZ 09 \'()+,-./:=? ",

        // 2 - rgdwPrintableOrT61ValueType,
        szOID_LOCALITY_NAME, 0, 0,
            (BYTE *) L"L: printable or t61 \"###\"",

        // 3 - BAD rgdwNumericValueType,
        szOID_X21_ADDRESS, 0, 0,
            (BYTE *) L"0123456789a ",

        // 4 - none, use default
        szOID_REGISTERED_ADDRESS, 0, 0,
            (BYTE *) L"Default"
    };
    CERT_RDN rgBadNumericRDN[] = {
        1, &rgBadNumericAttr[0],
        1, &rgBadNumericAttr[1],
        1, &rgBadNumericAttr[2],
        1, &rgBadNumericAttr[3],
        1, &rgBadNumericAttr[4]
    };
    CERT_NAME_INFO BadNumericName = {5, rgBadNumericRDN};

    // This one has non-zero dwValueTypes
    CERT_RDN_ATTR rgBadNumericAttr2[] = {
        // 0 - rgdwPrintableOrT61ValueType,
        szOID_COMMON_NAME, CERT_RDN_PRINTABLE_STRING, 0,
            (BYTE *) L"CN: printable or t61",

        // 1 - rgdwPrintableValueType,
        szOID_COUNTRY_NAME, CERT_RDN_PRINTABLE_STRING, 0,
            (BYTE *) L"C: printable az AZ 09 \'()+,-./:=? ",

        // 2 - rgdwPrintableOrT61ValueType,
        szOID_LOCALITY_NAME, CERT_RDN_T61_STRING, 0,
            (BYTE *) L"L: printable or t61 \"###\"",

        // 3 - BAD rgdwNumericValueType,
        szOID_X21_ADDRESS, CERT_RDN_NUMERIC_STRING, 0,
            (BYTE *) L"0123456789a ",

        // 4 - none, use default
        szOID_REGISTERED_ADDRESS, CERT_RDN_IA5_STRING, 0,
            (BYTE *) L"Default"
    };
    CERT_RDN rgBadNumericRDN2[] = {
        1, &rgBadNumericAttr2[0],
        1, &rgBadNumericAttr2[1],
        1, &rgBadNumericAttr2[2],
        4, &rgBadNumericAttr2[1],
        1, &rgBadNumericAttr2[4]
    };
    CERT_NAME_INFO BadNumericName2 = {5, rgBadNumericRDN2};

    BYTE rgbBadIA5[] = {0x80, 0x00, 0x00, 0x00};
    CERT_RDN_ATTR rgBadIA5Attr[] = {
        // 0 - BAD rgdwIA5ValueType
        szOID_RSA_emailAddr, 0, 0,
            rgbBadIA5,
    };
    CERT_RDN rgBadIA5RDN[] = {
        1, &rgBadIA5Attr[0]
    };
    CERT_NAME_INFO BadIA5Name = {1, rgBadIA5RDN};

    cbIssuerEncoded = 0;
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ))
        PrintNoError("X509_UNICODE_NAME:: BadPrintableName");
    else
        PrintBadUnicodeEncode("PrintableString",
            (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING, cbIssuerEncoded);

    cbIssuerEncoded = 0;
    rgBadPrintableAttr[2].dwValueType = CERT_RDN_PRINTABLE_STRING;
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ))
        PrintNoError("X509_UNICODE_NAME:: BadPrintableName(set dwValueType)");
    else
        PrintBadUnicodeEncode("PrintableString(set dwValueType)",
            (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING, cbIssuerEncoded);

    cbIssuerEncoded = 0;
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG,
            NULL,               // pEncodePara
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ) || 0 == cbIssuerEncoded)
        PrintLastError("X509_UNICODE_NAME:: DISABLE_CHECK dwFlags");

    rgBadPrintableAttr[2].dwValueType =
        CERT_RDN_DISABLE_CHECK_TYPE_FLAG | CERT_RDN_PRINTABLE_STRING;
    cbIssuerEncoded = 0;
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            0,
            NULL,               // pEncodePara
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ) || 0 == cbIssuerEncoded)
        PrintLastError("X509_UNICODE_NAME:: DISABLE_CHECK dwValueType");

    cbIssuerEncoded = 0;
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            CRYPT_UNICODE_NAME_ENCODE_ENABLE_T61_UNICODE_FLAG,
            NULL,               // pEncodePara
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ) || 0 == cbIssuerEncoded)
        PrintLastError("X509_UNICODE_NAME:: ENABLE_T61 dwFlags");

    rgBadPrintableAttr[1].dwValueType =
        CERT_RDN_ENABLE_T61_UNICODE_FLAG;
    cbIssuerEncoded = 0;
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            0,
            NULL,               // pEncodePara
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ) || 0 == cbIssuerEncoded)
        PrintLastError("X509_UNICODE_NAME:: ENABLE_T61 dwValueType");

    cbIssuerEncoded = 0;
    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadPrintableName,
            CRYPT_UNICODE_NAME_ENCODE_ENABLE_UTF8_UNICODE_FLAG,
            NULL,               // pEncodePara
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ) || 0 == cbIssuerEncoded)
        PrintLastError("X509_UNICODE_NAME:: ENABLE_UTF8 dwFlags");

    cbIssuerEncoded = 0;
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadNumericName,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ))
        PrintNoError("X509_UNICODE_NAME:: BadNumericName");
    else
        PrintBadUnicodeEncode("NumericString",
            (DWORD) CRYPT_E_INVALID_NUMERIC_STRING, cbIssuerEncoded);

    cbIssuerEncoded = 0;
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadNumericName2,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ))
        PrintNoError("X509_UNICODE_NAME:: BadNumericName2");
    else
        PrintBadUnicodeEncode("NumericString2",
            (DWORD) CRYPT_E_INVALID_NUMERIC_STRING, cbIssuerEncoded);

    cbIssuerEncoded = 0;
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &BadIA5Name,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            ))
        PrintNoError("X509_UNICODE_NAME:: BadIA5Name");
    else
        PrintBadUnicodeEncode("IA5String",
            (DWORD) CRYPT_E_INVALID_IA5_STRING, cbIssuerEncoded);
}

static BYTE *EncodeIssuer(DWORD *pcbIssuerEncoded)
{
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;

    BYTE rgbOctet[] = {1, 0xFF, 0x7F};
    BYTE rgbEncodedBlob[] = {0x05, 00};

    CERT_RDN_ATTR rgAttr[] = {
        // 0 - rgdwPrintableOrT61ValueType
        szOID_COMMON_NAME, 0, 0,
            (BYTE *) L"CN: printable or t61",

        // 1 - rgdwPrintableValueType
        szOID_COUNTRY_NAME, 0, 0,
            (BYTE *) L"C: printable az AZ 09 \'()+,-./:=? ",

        // 2 - rgdwPrintableOrT61ValueType
        szOID_LOCALITY_NAME, 0, 0,
            (BYTE *) L"L: printable or t61 \"###\"",

        // 3 - rgdwNumericValueType
        szOID_X21_ADDRESS, 0, 0,
            (BYTE *) L" 0123456789 ",

        // 4 - none, use default
        szOID_REGISTERED_ADDRESS, 0, 0,
            (BYTE *) L"Default",

        // 5 - rgdwIA5ValueType
        szOID_RSA_emailAddr, 0, 0,
            (BYTE *) L"Email, IA5 !@#$%^&*()_+{|}",

        // 6 - Unicode
        "1.2.2.5", CERT_RDN_BMP_STRING, 0,
            (BYTE *) L"Null terminated UNICODE",

        // 7 - Unicode
        "1.2.2.5.1", CERT_RDN_BMP_STRING, 10 *2,
            (BYTE *) L"Length UNICODE",

        // 8 - Universal
        "1.2.2.5.2", CERT_RDN_UNIVERSAL_STRING, 0,
            (BYTE *) L"Universal ~!@#$%^&*()_+{}:\"<>?",

        // 9 - Octet
        "1.2.2.5.3", CERT_RDN_OCTET_STRING, sizeof(rgbOctet),
            rgbOctet,

        // 10 - EncodedBlob
        "1.2.2.5.4", CERT_RDN_ENCODED_BLOB, sizeof(rgbEncodedBlob),
            rgbEncodedBlob,

        // 11 - Empty rgdwPrintableOrT61ValueType
        szOID_LOCALITY_NAME, 0, 0, NULL,

        // 12 - Empty rgdwNumericValueType
        szOID_X21_ADDRESS, 0, 0, NULL,

        // 13 - DC (IA5)
        szOID_DOMAIN_COMPONENT, 0, 0,
            (BYTE *) L"microsoft",

        // 14 - DC (IA5)
        szOID_DOMAIN_COMPONENT, 0, 0,
            (BYTE *) L"com",

        // 15 - UTF8
        "1.2.8.5", CERT_RDN_UTF8_STRING, 0,
            (BYTE *) L"Null terminated UTF8",

        // 16 - UTF8
        "1.2.8.5.1", CERT_RDN_UTF8_STRING, 11 *2,
            (BYTE *) L"Length UTF8",

        // Note, FFFE and FFFF are excluded from the UTF8 standard
        // 17 - UTF8
        "1.2.8.5.2", CERT_RDN_UTF8_STRING, 0,
            (BYTE *) L"SPECIAL UTF8: "
        L"\x0001 \x0002 \x007e \x007f "
        L"\x0080 \x0081 \x07fe \x07ff "
        L"\x0800 \x0801 \xfffc \xfffd",

        // 18 - UNICODE
        "1.2.8.5.3", CERT_RDN_UNICODE_STRING, 0,
            (BYTE *) L"SPECIAL UNICODE: "
        L"\x0001 \x0002 \x007e \x007f "
        L"\x0080 \x0081 \x07fe \x07ff "
        L"\x0800 \x0801 \xfffe \xffff",

        // 19 - DC (UTF8)
        szOID_DOMAIN_COMPONENT, 0, 0,
            (BYTE *) L"Unicode DC: "
        L"\x0001 \x0002 \x007e \x007f "
        L"\x0080 \x0081 \x07fe \x07ff "
        L"\x0800 \x0801 \xfffe \xffff",

        // 20 - Universal
        "1.2.2.5.2.1.1.1", CERT_RDN_UNIVERSAL_STRING, 0,
            (BYTE *) L"SPECIAL UNIVERSAL with Surrogate Pairs: "
        L"\xd800\xdc00\xdbff\xdfff"
        L"\xdbfe\xdc03\xd801\xdfcf"
        L"\xd801\x0081\xdc01\xdc02"
        L"\xd805\xd806\xd807\xdc04"
        L"\xd802\xd803\xfffe\xd804",
       
    };

    CERT_RDN rgRDN[] = {
        1, &rgAttr[0],
        1, &rgAttr[1],
        1, &rgAttr[2],
        1, &rgAttr[3],
        1, &rgAttr[4],
        1, &rgAttr[5],
        3, &rgAttr[5],
        13, &rgAttr[8]
    };
    CERT_NAME_INFO Name = {8, rgRDN};

    DoBadEncodeIssuer();

    cbIssuerEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbIssuerEncoded
            );
    if (cbIssuerEncoded == 0) {
        PrintLastError("EncodeIssuer::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbIssuerEncoded = (BYTE *) TestAlloc(cbIssuerEncoded);
    if (pbIssuerEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            &Name,
            pbIssuerEncoded,
            &cbIssuerEncoded
            )) {
        PrintLastError("EncodeIssuer::CryptEncodeObject");
        goto ErrorReturn;
    }

    goto CommonReturn;

ErrorReturn:
    if (pbIssuerEncoded)
        TestFree(pbIssuerEncoded);
    pbIssuerEncoded = NULL;
    cbIssuerEncoded = 0;
CommonReturn:
    *pcbIssuerEncoded = cbIssuerEncoded;
    return pbIssuerEncoded;
}

static BOOL EncodeCert(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbIssuerEncoded = NULL;
    DWORD cbIssuerEncoded;

    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    BYTE *pbCertEncoded = NULL;
    DWORD cbCertEncoded;

    DWORD SerialNumber[2] = {0x12345678, 0x33445566};
    SYSTEMTIME SystemTime;

#define ISSUER_UNIQUE_ID "IssuerUniqueId"

#define ATTR_0_0 "attr 0_0 printable"
#define ATTR_0_1 "attr 0_1 IA5"
#define ATTR_1_0 "attr 1_0 numeric"
#define ATTR_1_1 "attr 1_1 octet"
#define ATTR_2_0 "attr 2_0 teletex"
#define ATTR_2_1 "attr 2_1 videotex"
#define ATTR_2_2 "attr 2_2 graphic"
#define ATTR_2_3 "attr 2_3 visible"
#define ATTR_2_4 "attr 2_4 general"
#define ATTR_2_5 L"attr 2_5 BMP:: Unicode"
#define ATTR_2_6 L"attr 2_6 UTF8:: Unicode"

    ULONG Universal[] = {0x12345678, 0, 0xFFFF1111, 0x87654321,
        0x00FFFF,
        0x010000,
        0x010001,
        0x10FFFE,
        0x10FFFF,
        0x110000,
        0x10F803,
        0x0107CF,
        0x011C04,
        };

    BYTE NullDer[] = {0x05, 0x00};
    BYTE IntegerDer[] = {0x02, 0x01, 0x35};
    CERT_RDN_ATTR rgAttr0[] = {
        "1.2.0.0", CERT_RDN_PRINTABLE_STRING,
            strlen(ATTR_0_0), (BYTE *) ATTR_0_0,
        "1.2.0.1", CERT_RDN_IA5_STRING,
             strlen(ATTR_0_1), (BYTE *) ATTR_0_1
    };
    CERT_RDN_ATTR rgAttr1[] = {
        "1.2.1.0", CERT_RDN_NUMERIC_STRING,
            strlen(ATTR_1_0), (BYTE *) ATTR_1_0,
        "1.2.1.1", CERT_RDN_OCTET_STRING,
            strlen(ATTR_1_1), (BYTE *) ATTR_1_1,
        "1.2.1.2", CERT_RDN_PRINTABLE_STRING,
            0, NULL,
        "1.2.1.3", CERT_RDN_ENCODED_BLOB,
            sizeof(NullDer), NullDer,
        "1.2.1.4", CERT_RDN_ENCODED_BLOB,
            sizeof(IntegerDer), IntegerDer 
    };
    CERT_RDN_ATTR rgAttr2[] = {
        "1.2.2.0", CERT_RDN_TELETEX_STRING,
            strlen(ATTR_2_0), (BYTE *) ATTR_2_0,
        "1.2.2.1", CERT_RDN_VIDEOTEX_STRING,
            strlen(ATTR_2_1), (BYTE *) ATTR_2_1,
        "1.2.2.2", CERT_RDN_GRAPHIC_STRING,
            strlen(ATTR_2_2), (BYTE *) ATTR_2_2,
        "1.2.2.3", CERT_RDN_VISIBLE_STRING,
            strlen(ATTR_2_3), (BYTE *) ATTR_2_3,
        "1.2.2.4", CERT_RDN_GENERAL_STRING,
            strlen(ATTR_2_4), (BYTE *) ATTR_2_4,
        "1.2.2.5", CERT_RDN_BMP_STRING,
            wcslen(ATTR_2_5) * 2, (BYTE *) ATTR_2_5,
        "1.2.2.6", CERT_RDN_UTF8_STRING,
            wcslen(ATTR_2_6) * 2, (BYTE *) ATTR_2_6,
        "1.2.2.7", CERT_RDN_UNIVERSAL_STRING,
            sizeof(Universal), (BYTE *) Universal
    };

    CERT_RDN_ATTR rgAttr3[] = {
        "1.2.2.2", CERT_RDN_OCTET_STRING,
            0, NULL,
        "1.2.2.3", CERT_RDN_NUMERIC_STRING,
            0, NULL,
        "1.2.2.4", CERT_RDN_PRINTABLE_STRING,
            0, NULL,
        "1.2.2.5", CERT_RDN_TELETEX_STRING,
            0, NULL,
        "1.2.2.6", CERT_RDN_VIDEOTEX_STRING,
            0, NULL,
        "1.2.2.7", CERT_RDN_IA5_STRING,
            0, NULL,
        "1.2.2.8", CERT_RDN_GRAPHIC_STRING,
            0, NULL,
        "1.2.2.9", CERT_RDN_VISIBLE_STRING,
            0, NULL,
        "1.2.2.10", CERT_RDN_GENERAL_STRING,
            0, NULL,
        "1.2.2.11", CERT_RDN_UNIVERSAL_STRING,
            0, NULL,
        "1.2.2.12", CERT_RDN_BMP_STRING,
            0, NULL,
        "1.2.2.13", CERT_RDN_UTF8_STRING,
            0, NULL
    };
    CERT_RDN rgRDN[] = {
        2, rgAttr0,
        5, rgAttr1,
        8, rgAttr2,
        12, rgAttr3
    };
    CERT_NAME_INFO Name = {4, rgRDN};

#define EXT_0 "extension 0 ."
#define EXT_1 "extension 1 .."
#define EXT_2 "extension 2 ..."
#define EXT_3 "extension 3 ...."
    CERT_EXTENSION rgExt[] = {
        "1.14.0", TRUE, strlen(EXT_0), (BYTE *) EXT_0,
        "1.14.1.35.45", FALSE, strlen(EXT_1), (BYTE *) EXT_1,
        "1.14.2", TRUE, strlen(EXT_2), (BYTE *) EXT_2,
        "1.14.4", FALSE, strlen(EXT_3), (BYTE *) EXT_3
    };
    CERT_INFO Cert;
    BYTE *pbExt = NULL;

    if (dwExtLen) {
        DWORD i;
        if (NULL == (pbExt = (BYTE *) TestAlloc(dwExtLen)))
            goto ErrorReturn;

        for (i = 0; i < dwExtLen; i++)
            pbExt[i] = (BYTE) i;

        rgExt[3].Value.cbData = dwExtLen;
        rgExt[3].Value.pbData = pbExt;
    }
        
    cbNameEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbNameEncoded
            );
    if (cbNameEncoded == 0) {
        PrintLastError("EncodeCert::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbNameEncoded = (BYTE *) TestAlloc(cbNameEncoded);
    if (pbNameEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbNameEncoded,
            &cbNameEncoded
            )) {
        PrintLastError("EncodeCert::CryptEncodeObject");
        goto ErrorReturn;
    }

    pbIssuerEncoded = EncodeIssuer(&cbIssuerEncoded);
    if (NULL == pbIssuerEncoded)
        goto ErrorReturn;

    memset(&Cert, 0, sizeof(Cert));
    Cert.dwVersion = CERT_V3;
    Cert.SerialNumber.pbData = (BYTE *) &SerialNumber;
    Cert.SerialNumber.cbData = sizeof(SerialNumber);
    Cert.SignatureAlgorithm.pszObjId = "1.2.4.5.898";
    Cert.Issuer.pbData = pbIssuerEncoded;
    Cert.Issuer.cbData = cbIssuerEncoded;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &Cert.NotBefore);
    SystemTime.wYear++;
    SystemTimeToFileTime(&SystemTime, &Cert.NotAfter);

    Cert.Subject.pbData = pbNameEncoded;
    Cert.Subject.cbData = cbNameEncoded;
    Cert.SubjectPublicKeyInfo.Algorithm.pszObjId = "1.3.4.5.911";
    Cert.SubjectPublicKeyInfo.PublicKey.pbData = (BYTE *) &SubjectPublicKey;
    Cert.SubjectPublicKeyInfo.PublicKey.cbData = sizeof(SubjectPublicKey);
    Cert.IssuerUniqueId.pbData = (BYTE *) ISSUER_UNIQUE_ID;
    Cert.IssuerUniqueId.cbData = strlen(ISSUER_UNIQUE_ID);
    Cert.IssuerUniqueId.cUnusedBits = 5;
    // Cert.SubjectUniqueId = 0
    Cert.cExtension = sizeof(rgExt) / sizeof(rgExt[0]);
    Cert.rgExtension = rgExt;

    cbCertEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            NULL,               // pbEncoded
            &cbCertEncoded
            );
    if (cbCertEncoded == 0) {
        PrintLastError("EncodeCert::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCertEncoded = (BYTE *) TestAlloc(cbCertEncoded);
    if (pbCertEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_TO_BE_SIGNED,
            &Cert,
            pbCertEncoded,
            &cbCertEncoded
            )) {
        PrintLastError("EncodeCert::CryptEncodeObject");
        goto ErrorReturn;
    }

    if (!EncodeSignedContent(
            pbCertEncoded,
            cbCertEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNameEncoded)
        TestFree(pbNameEncoded);
    if (pbIssuerEncoded)
        TestFree(pbIssuerEncoded);
    if (pbCertEncoded)
        TestFree(pbCertEncoded);
    if (pbExt)
        TestFree(pbExt);

    return fResult;
}

static BOOL EncodeCertReq(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    BYTE *pbCertReqEncoded = NULL;
    DWORD cbCertReqEncoded;

    BYTE *pbExtEncoded = NULL;
    DWORD cbExtEncoded;


#define CERT_REQ_0 "Cert Request subject 0"
#define CERT_REQ_1 "Cert Request subject 1 ...."
#define CERT_REQ_2 "Cert Request subject 2 ......."
    

    CERT_RDN_ATTR rgNameAttr[] = {
        "1.2.1.0", CERT_RDN_PRINTABLE_STRING,
            strlen(CERT_REQ_0), (BYTE *) CERT_REQ_0,
        "1.2.1.1", CERT_RDN_PRINTABLE_STRING,
            strlen(CERT_REQ_1), (BYTE *) CERT_REQ_1,
        "1.2.1.2", CERT_RDN_PRINTABLE_STRING,
            strlen(CERT_REQ_2), (BYTE *) CERT_REQ_2
    };
    CERT_RDN rgRDN[] = {
        1, &rgNameAttr[0],
        1, &rgNameAttr[1],
        1, &rgNameAttr[2]
    };
    CERT_NAME_INFO Name = {3, rgRDN};

    BYTE NullDer[] = {0x05, 0x00};
    BYTE IntegerDer[] = {0x02, 0x01, 0x35};
    CRYPT_ATTR_BLOB rgAttrBlob[2] = {
            2, (BYTE *) NullDer,
            3, (BYTE *) IntegerDer
    };

    CRYPT_ATTR_BLOB ExtAttrBlob;

    CRYPT_ATTRIBUTE rgAttr[] = {
        szOID_RSA_certExtensions,
            1, &ExtAttrBlob,
        "1.2.3.4.5.0", 
            1, rgAttrBlob,
        "1.2.1.1.1.1.1.1", 
            2, rgAttrBlob
    };

#define REQ_EXT_0 "request extension 0 -"
#define REQ_EXT_1 "request extension 1 --"
#define REQ_EXT_2 "request extension 2 ---"
#define REQ_EXT_3 "request extension 3 ----"
    CERT_EXTENSION rgExt[4] = {
        "2.50.0", FALSE, strlen(REQ_EXT_0), (BYTE *) REQ_EXT_0,
        "2.51.1", TRUE, strlen(REQ_EXT_1), (BYTE *) REQ_EXT_1,
        "2.52.2", FALSE, strlen(REQ_EXT_2), (BYTE *) REQ_EXT_2,
        "2.53.3", FALSE, strlen(REQ_EXT_3), (BYTE *) REQ_EXT_3
    };
    CERT_EXTENSIONS Extensions = {4, &rgExt[0]};

    CERT_REQUEST_INFO CertReq;

    cbNameEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbNameEncoded
            );
    if (cbNameEncoded == 0) {
        PrintLastError("EncodeCertReq::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbNameEncoded = (BYTE *) TestAlloc(cbNameEncoded);
    if (pbNameEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbNameEncoded,
            &cbNameEncoded
            )) {
        PrintLastError("EncodeCertReq::CryptEncodeObject");
        goto ErrorReturn;
    }

    cbExtEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_EXTENSIONS,
            &Extensions,
            NULL,               // pbEncoded
            &cbExtEncoded
            );
    if (cbExtEncoded == 0) {
        PrintLastError("EncodeCertReq::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbExtEncoded = (BYTE *) TestAlloc(cbExtEncoded);
    if (pbExtEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_EXTENSIONS,
            &Extensions,
            pbExtEncoded,
            &cbExtEncoded
            )) {
        PrintLastError("EncodeCertReq::CryptEncodeObject");
        goto ErrorReturn;
    }
    ExtAttrBlob.pbData = pbExtEncoded;
    ExtAttrBlob.cbData = cbExtEncoded;

    memset(&CertReq, 0, sizeof(CertReq));
    CertReq.dwVersion = 2;
    CertReq.Subject.pbData = pbNameEncoded;
    CertReq.Subject.cbData = cbNameEncoded;
    CertReq.SubjectPublicKeyInfo.Algorithm.pszObjId = "1.3.4.5.911";
    CertReq.SubjectPublicKeyInfo.PublicKey.pbData = (BYTE *) &SubjectPublicKey;
    CertReq.SubjectPublicKeyInfo.PublicKey.cbData = sizeof(SubjectPublicKey);
    CertReq.cAttribute = sizeof(rgAttr) / sizeof(rgAttr[0]);
    CertReq.rgAttribute = rgAttr;

    cbCertReqEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_REQUEST_TO_BE_SIGNED,
            &CertReq,
            NULL,               // pbEncoded
            &cbCertReqEncoded
            );
    if (cbCertReqEncoded == 0) {
        PrintLastError("EncodeCertReq::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCertReqEncoded = (BYTE *) TestAlloc(cbCertReqEncoded);
    if (pbCertReqEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_REQUEST_TO_BE_SIGNED,
            &CertReq,
            pbCertReqEncoded,
            &cbCertReqEncoded
            )) {
        PrintLastError("EncodeCertReq::CryptEncodeObject");
        goto ErrorReturn;
    }

    if (!EncodeSignedContent(
            pbCertReqEncoded,
            cbCertReqEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbExtEncoded)
        TestFree(pbExtEncoded);
    if (pbNameEncoded)
        TestFree(pbNameEncoded);
    if (pbCertReqEncoded)
        TestFree(pbCertReqEncoded);

    return fResult;
}

static BOOL EncodeKeygenReq(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbKeygenReqEncoded = NULL;
    DWORD cbKeygenReqEncoded;

    CERT_KEYGEN_REQUEST_INFO KeygenReq;

    memset(&KeygenReq, 0, sizeof(KeygenReq));
    KeygenReq.dwVersion = CERT_KEYGEN_REQUEST_V1;
    KeygenReq.SubjectPublicKeyInfo.Algorithm.pszObjId = "1.3.4.5.911";
    KeygenReq.SubjectPublicKeyInfo.PublicKey.pbData = (BYTE *) &SubjectPublicKey;
    KeygenReq.SubjectPublicKeyInfo.PublicKey.cbData = sizeof(SubjectPublicKey);
    KeygenReq.pwszChallengeString = L"Keygen Challenge String";

    cbKeygenReqEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_KEYGEN_REQUEST_TO_BE_SIGNED,
            &KeygenReq,
            NULL,               // pbEncoded
            &cbKeygenReqEncoded
            );
    if (cbKeygenReqEncoded == 0) {
        PrintLastError("EncodeKeygenReq::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbKeygenReqEncoded = (BYTE *) TestAlloc(cbKeygenReqEncoded);
    if (pbKeygenReqEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_KEYGEN_REQUEST_TO_BE_SIGNED,
            &KeygenReq,
            pbKeygenReqEncoded,
            &cbKeygenReqEncoded
            )) {
        PrintLastError("EncodeKeygenReq::CryptEncodeObject");
        goto ErrorReturn;
    }

    if (!EncodeSignedContent(
            pbKeygenReqEncoded,
            cbKeygenReqEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbKeygenReqEncoded)
        TestFree(pbKeygenReqEncoded);

    return fResult;
}

static BOOL EncodeContentInfo(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CRYPT_CONTENT_INFO ContentInfo;
    BYTE rgb0[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    CRYPT_DER_BLOB Content = {
        sizeof(rgb0), rgb0
    };


    memset(&ContentInfo, 0, sizeof(ContentInfo));
    ContentInfo.pszObjId = "1.2.3.4.5.6.7.8.9.10";
    ContentInfo.Content = Content;

    cbEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            PKCS_CONTENT_INFO,
            &ContentInfo,
            NULL,               // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError("EncodeContentInfo::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) TestAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            PKCS_CONTENT_INFO,
            &ContentInfo,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError("EncodeContent::CryptEncodeObject");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;

    return fResult;
}

static LPCSTR FileTimeText(FILETIME *pft)
{
    static char buf[80];
    FILETIME ftLocal;
    struct tm ctm;
    SYSTEMTIME st;

    FileTimeToLocalFileTime(pft, &ftLocal);
    if (FileTimeToSystemTime(&ftLocal, &st))
    {
        ctm.tm_sec = st.wSecond;
        ctm.tm_min = st.wMinute;
        ctm.tm_hour = st.wHour;
        ctm.tm_mday = st.wDay;
        ctm.tm_mon = st.wMonth-1;
        ctm.tm_year = st.wYear-1900;
        ctm.tm_wday = st.wDayOfWeek;
        ctm.tm_yday  = 0;
        ctm.tm_isdst = 0;
        strcpy(buf, asctime(&ctm));
        buf[strlen(buf)-1] = 0;
    }
    else
        sprintf(buf, "<FILETIME %08lX:%08lX>", pft->dwHighDateTime,
                pft->dwLowDateTime);
    return buf;
}

#define CROW 16
static void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    while (cbSize > 0)
    {
        printf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}

static BOOL DecodeName(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD i,j;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    
    if (NULL == (pInfo = (PCERT_NAME_INFO) TestDecodeObject(
            X509_NAME,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    for (i = 0, pRDN = pInfo->rgRDN; i < pInfo->cRDN; i++, pRDN++) {
        for (j = 0, pAttr = pRDN->rgRDNAttr; j < pRDN->cRDNAttr; j++, pAttr++) {
            LPSTR pszObjId = pAttr->pszObjId;
            if (pszObjId == NULL)
                pszObjId = "<NULL OBJID>";
            printf("  [%d,%d] %s ValueType: %d\n",
                i, j, pszObjId, pAttr->dwValueType);
            if (pAttr->Value.cbData)
                PrintBytes("    ", pAttr->Value.pbData, pAttr->Value.cbData);
            else
                printf("    NO Value Bytes\n");
        }
    }

    if (fFormatAllNameStrings) {
        CERT_NAME_BLOB Name;
        DWORD cwsz;
        LPWSTR pwsz;
        DWORD csz;
        LPSTR psz;
        Name.pbData = pbEncoded;
        Name.cbData = cbEncoded;
#define DELTA_DECRMENT    7
        DWORD dwDelta;

        DWORD rgdwStrType[] = {
            CERT_SIMPLE_NAME_STR,
            CERT_OID_NAME_STR,
            CERT_X500_NAME_STR,
            CERT_SIMPLE_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG |
                CERT_NAME_STR_NO_PLUS_FLAG | CERT_NAME_STR_NO_QUOTING_FLAG,
            CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG |
                CERT_NAME_STR_NO_QUOTING_FLAG,
            CERT_X500_NAME_STR | CERT_NAME_STR_CRLF_FLAG,
            0
        };
        DWORD *pdwStrType;

        for (pdwStrType = rgdwStrType, dwDelta = DELTA_DECRMENT; *pdwStrType;
                                pdwStrType++, dwDelta += DELTA_DECRMENT) {
            printf("\nCertNameToStrW(dwStrType == 0x%x)\n", *pdwStrType);
            cwsz = CertNameToStrW(
                dwCertEncodingType,
                &Name,
                *pdwStrType,
                NULL,                   // pwsz
                0);                     // cwsz
            if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
                CertNameToStrW(
                    dwCertEncodingType,
                    &Name,
                    *pdwStrType,
                    pwsz,
                    cwsz);
                printf("  %S\n", pwsz);
                if (cwsz > dwDelta) {
                    CertNameToStrW(
                        dwCertEncodingType,
                        &Name,
                        *pdwStrType,
                        pwsz,
                        cwsz - dwDelta);
                    printf("Delta[-%d]\n", dwDelta);
                    printf("  %S\n", pwsz);
                }
                TestFree(pwsz);
            }
        }

        for (pdwStrType = rgdwStrType, dwDelta = DELTA_DECRMENT; *pdwStrType;
                                pdwStrType++, dwDelta += DELTA_DECRMENT) {
            printf("\nCertNameToStrA(dwStrType == 0x%x)\n", *pdwStrType);
            csz = CertNameToStrA(
                dwCertEncodingType,
                &Name,
                *pdwStrType,
                NULL,                   // psz
                0);                     // csz
            if (psz = (LPSTR) TestAlloc(csz)) {
                CertNameToStrA(
                    dwCertEncodingType,
                    &Name,
                    *pdwStrType,
                    psz,
                    csz);
                printf("  %s\n", psz);
                if (csz > dwDelta) {
                    csz = CertNameToStrA(
                        dwCertEncodingType,
                        &Name,
                        *pdwStrType,
                        psz,
                        csz - dwDelta);
                    printf("Delta[-%d]\n", dwDelta);
                    if (1 >= csz) {
                        DWORD dwErr = GetLastError();
                        printf("  No CertNameToStrA string, LastError: 0x%x (%d) \n",
                            dwErr, dwErr);
                    } else
                        printf("  %s\n", psz);
                }
                TestFree(psz);
            }
        }
    } else if (fFormatNameStrings) {
        CERT_NAME_BLOB Name;
        DWORD cwsz;
        LPWSTR pwsz;
        Name.pbData = pbEncoded;
        Name.cbData = cbEncoded;

        cwsz = CertNameToStrW(
            dwCertEncodingType,
            &Name,
            CERT_X500_NAME_STR,
            NULL,                   // pwsz
            0);                     // cwsz
        if (pwsz = (LPWSTR) TestAlloc(cwsz * sizeof(WCHAR))) {
            CertNameToStrW(
                dwCertEncodingType,
                &Name,
                CERT_X500_NAME_STR,
                pwsz,
                cwsz);
            printf("  %S\n", pwsz);
            TestFree(pwsz);
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static void DecodeSignedContent(
    BYTE *pbEncoded,
    DWORD cbEncoded,
    LPCSTR lpszToBeSignedStructType,
    DWORD cbToBeSignedStruct
    )
{
    BOOL fResult;
    PCERT_INFO pInfo = NULL;
    LPSTR pszObjId;
    DWORD cbInfo;

    PCERT_SIGNED_CONTENT_INFO pCertEncoding;
    
    if (NULL == (pCertEncoding = (PCERT_SIGNED_CONTENT_INFO) TestDecodeObject(
            X509_CERT,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    // Decode the ToBeSigned
    cbInfo = 0x12345678;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            lpszToBeSignedStructType,
            pCertEncoding->ToBeSigned.pbData,
            pCertEncoding->ToBeSigned.cbData,
            dwDecodeObjectFlags | CRYPT_DECODE_TO_BE_SIGNED_FLAG,
            NULL,                   // pvInfo
            &cbInfo))
        PrintLastError("CryptDecodeObject(TO_BE_SIGNED_FLAG)");
    else if (cbInfo != cbToBeSignedStruct)
        printf("failed => CryptDecodeObject(TO_BE_SIGNED_FLAG) returned cbInfo = %d, not %d\n",
            cbInfo, cbToBeSignedStruct);
    cbInfo = 0x12345678;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            lpszToBeSignedStructType,
            pCertEncoding->ToBeSigned.pbData,
            pCertEncoding->ToBeSigned.cbData,
            dwDecodeObjectFlags,
            NULL,                   // pvInfo
            &cbInfo))
        PrintLastError("CryptDecodeObject(ToBeSigned, without flag)");
    else if (cbInfo != cbToBeSignedStruct)
        printf("failed => CryptDecodeObject(ToBeSigned without flag) returned cbInfo = %d, not %d\n",
            cbInfo, cbToBeSignedStruct);

    pszObjId = pCertEncoding->SignatureAlgorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("Content SignatureAlgorithm:: %s\n", pszObjId);
    if (pCertEncoding->SignatureAlgorithm.Parameters.cbData) {
        printf("Content SignatureAlgorithm.Parameters::\n");
        PrintBytes("    ", pCertEncoding->SignatureAlgorithm.Parameters.pbData,
            pCertEncoding->SignatureAlgorithm.Parameters.cbData);
    }

    if (pCertEncoding->Signature.cbData) {
        printf("Content Signature::\n");
        PrintBytes("    ", pCertEncoding->Signature.pbData,
            pCertEncoding->Signature.cbData);
    } else
        printf("Content Signature:: NONE\n");

    printf("Content Length:: %d\n", pCertEncoding->ToBeSigned.cbData);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pCertEncoding)
        TestFree(pCertEncoding);
}

static void PrintExtensions(DWORD cExt, PCERT_EXTENSION pExt)
{
    DWORD i; 

    for (i = 0; i < cExt; i++, pExt++) {
        LPSTR pszObjId = pExt->pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        LPSTR pszCritical = pExt->fCritical ? "TRUE" : "FALSE";
        printf("  [%d] %s Critical: %s\n", i, pszObjId, pszCritical);
        if (pExt->Value.cbData)
            PrintBytes("    ", pExt->Value.pbData, pExt->Value.cbData);
        else
            printf("    NO Value Bytes\n");
    }
}

static void DecodeExtensions(BYTE *pbEncoded, DWORD cbEncoded)
{
    PCERT_EXTENSIONS pInfo;
    if (NULL == (pInfo = (PCERT_EXTENSIONS) TestDecodeObject(
            X509_EXTENSIONS,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    PrintExtensions(pInfo->cExtension, pInfo->rgExtension);
    goto CommonReturn;

ErrorReturn:
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
}

static void PrintAttributes(DWORD cAttr, PCRYPT_ATTRIBUTE pAttr)
{
    DWORD i; 
    DWORD j; 

    for (i = 0; i < cAttr; i++, pAttr++) {
        DWORD cValue = pAttr->cValue;
        PCRYPT_ATTR_BLOB pValue = pAttr->rgValue;
        LPSTR pszObjId = pAttr->pszObjId;
        if (pszObjId == NULL)
            pszObjId = "<NULL OBJID>";
        if (cValue) {
            for (j = 0; j < cValue; j++, pValue++) {
                printf("  [%d,%d] %s\n", i, j, pszObjId);
                if (pValue->cbData) {
                    PrintBytes("    ", pValue->pbData, pValue->cbData);
                    if (strcmp(pszObjId, szOID_RSA_certExtensions) == 0 ||
                        strcmp(pszObjId, SPC_CERT_EXTENSIONS_OBJID) == 0) {
                        printf("  Extensions::\n");
                        DecodeExtensions(pValue->pbData, pValue->cbData);
                    }
                } else
                    printf("    NO Value Bytes\n");
            }
        } else
            printf("  [%d] %s :: No Values\n", i, pszObjId);
    }
}

//+-------------------------------------------------------------------------
//  Write the public key to the file
//--------------------------------------------------------------------------
BOOL WritePublicKeyToFile(
    LPCSTR  pszFileName,
    PBYTE   pbPub,
    DWORD   cbPub
    )
{
    FILE *stream;
    DWORD i;

    if (NULL == (stream = fopen(pszFileName, "w"))) {
        printf("Failed to open %s for writing public key\n", pszFileName);
        return FALSE;
    }


    for (i = 0; i < cbPub; i++) {
        fprintf(stream, "0x%02X", pbPub[i]);
        if (i != (cbPub - 1))
            fprintf(stream, ",");
        if ((i + 1) % 16 == 0)
            fprintf(stream, "\n");
    }
    fprintf(stream, "\n");

    fclose(stream);
    return TRUE;
}

void WriteBytesToFile(
    IN FILE *stream,
    IN const BYTE *pb,
    IN DWORD cb
    )
{
    DWORD i;

    fprintf(stream, "= {\n");
    for (i = 0; i < cb; i++) {
        if ((i % 8) == 0)
            fprintf(stream, "    ");
        fprintf(stream, "0x%02X", pb[i]);
        if (i == (cb - 1))
            fprintf(stream, "\n");
        else {
            fprintf(stream, ",");
            if ((i + 1) % 8 == 0)
                fprintf(stream, "\n");
            else
                fprintf(stream, " ");
        }
    }

    fprintf(stream, "};\n\n");

}

//+-------------------------------------------------------------------------
//  Write the Name and PublicKeyInfo to the file
//--------------------------------------------------------------------------
BOOL WritePublicKeyInfoToFile(
    LPCSTR pszFileName,
    PCERT_INFO pCertInfo
    )
{
    BOOL fResult;
    FILE *stream;
    LPWSTR pwszName = NULL;
    DWORD cchName;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    if (NULL == (stream = fopen(pszFileName, "w"))) {
        printf("Failed to open %s for writing PublicKeyInfo\n", pszFileName);
        return FALSE;
    }

    // Output the Subject X500 name string as a comment
    cchName = CertNameToStrW(
        X509_ASN_ENCODING,
        &pCertInfo->Subject,
        CERT_X500_NAME_STR,
        NULL,                   // pwsz
        0                       // cch
        );
    if (NULL == (pwszName = (LPWSTR) TestAlloc(cchName * sizeof(WCHAR))))
        goto ErrorReturn;
    cchName = CertNameToStrW(
        X509_ASN_ENCODING,
        &pCertInfo->Subject,
        CERT_NAME_STR_REVERSE_FLAG |
            CERT_X500_NAME_STR,
        pwszName,
        cchName
        );

    fprintf(stream, "// Name:: <%S>\n", pwszName);
    // Write the encoded Subject Name bytes
    WriteBytesToFile(stream, pCertInfo->Subject.pbData,
        pCertInfo->Subject.cbData);

    fprintf(stream, "// PublicKeyInfo\n");

    // Encode and write the PublicKeyInfo bytes

    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            X509_PUBLIC_KEY_INFO,
            &pCertInfo->SubjectPublicKeyInfo,
            NULL,                       // pbEncoded
            &cbEncoded
            )) {
        PrintLastError("CryptEncodeObject(X509_PUBLIC_KEY_INFO)");
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) TestAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            X509_PUBLIC_KEY_INFO,
            &pCertInfo->SubjectPublicKeyInfo,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError("CryptEncodeObject(X509_PUBLIC_KEY_INFO)");
        goto ErrorReturn;
    }

    WriteBytesToFile(stream, pbEncoded, cbEncoded);

    fprintf(stream, "\n");

    fResult = TRUE;
CommonReturn:
    fclose(stream);

    TestFree(pwszName);
    TestFree(pbEncoded);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL DecodeCert(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_INFO pInfo = NULL;
    DWORD cbInfo;
    LPSTR pszObjId;
    
    if (NULL == (pInfo = (PCERT_INFO) TestDecodeObject(
            X509_CERT_TO_BE_SIGNED,
            pbEncoded,
            cbEncoded,
            &cbInfo
            ))) goto ErrorReturn;

    printf("Version:: %d\n", pInfo->dwVersion);
    {
        DWORD cb;
        BYTE *pb;
        printf("SerialNumber::");
        for (cb = pInfo->SerialNumber.cbData,
             pb = pInfo->SerialNumber.pbData + (cb - 1);
                                                cb > 0; cb--, pb--) {
            printf(" %02X", *pb);
        }
        printf("\n");
    }

    pszObjId = pInfo->SignatureAlgorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("SignatureAlgorithm:: %s\n", pszObjId);
    if (pInfo->SignatureAlgorithm.Parameters.cbData) {
        printf("SignatureAlgorithm.Parameters::\n");
        PrintBytes("    ", pInfo->SignatureAlgorithm.Parameters.pbData,
            pInfo->SignatureAlgorithm.Parameters.cbData);
    }

    printf("Issuer::\n");
    DecodeName(pInfo->Issuer.pbData, pInfo->Issuer.cbData);

    printf("NotBefore:: %s\n", FileTimeText(&pInfo->NotBefore));
    printf("NotAfter:: %s\n", FileTimeText(&pInfo->NotAfter));

    printf("Subject::\n");
    DecodeName(pInfo->Subject.pbData, pInfo->Subject.cbData);

    pszObjId = pInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("SubjectPublicKeyInfo.Algorithm:: %s\n", pszObjId);
    if (pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData) {
        printf("SubjectPublicKeyInfo.Algorithm.Parameters::\n");
        PrintBytes("    ",
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
    }
    printf("SubjectPublicKeyInfo.PublicKey");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
        printf(" (UnusedBits: %d)",
            pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);
    printf("::\n");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cbData) {
        PrintBytes("    ", pInfo->SubjectPublicKeyInfo.PublicKey.pbData,
            pInfo->SubjectPublicKeyInfo.PublicKey.cbData);
    } else
        printf("  No public key\n");

    if (pszPublicKeyFilename) {
        if (fWritePublicKeyInfo)
            WritePublicKeyInfoToFile(pszPublicKeyFilename, pInfo);
        else
            WritePublicKeyToFile(pszPublicKeyFilename,
                pInfo->SubjectPublicKeyInfo.PublicKey.pbData,
                pInfo->SubjectPublicKeyInfo.PublicKey.cbData
                );
    }
            

    if (pszReadFilename == NULL) {
        // Verify that the public key was properly encoded/decoded
        CERT_PUBLIC_KEY_INFO PublicKeyInfo;

        memset(&PublicKeyInfo, 0, sizeof(PublicKeyInfo));
        PublicKeyInfo.Algorithm.pszObjId = "1.3.4.5.911";
        PublicKeyInfo.PublicKey.pbData = (BYTE *) &SubjectPublicKey;
        PublicKeyInfo.PublicKey.cbData = sizeof(SubjectPublicKey);
        if (!CertComparePublicKeyInfo(
                dwCertEncodingType,
                &PublicKeyInfo,
                &pInfo->SubjectPublicKeyInfo))
            PrintLastError("CertComparePublicKeyInfo");
    }

    if (pInfo->IssuerUniqueId.cbData) {
        printf("IssuerUniqueId");
        if (pInfo->IssuerUniqueId.cUnusedBits)
            printf(" (UnusedBits: %d)", pInfo->IssuerUniqueId.cUnusedBits);
        printf("::\n");
        PrintBytes("    ", pInfo->IssuerUniqueId.pbData,
            pInfo->IssuerUniqueId.cbData);
    }

    if (pInfo->SubjectUniqueId.cbData) {
        printf("SubjectUniqueId");
        if (pInfo->SubjectUniqueId.cUnusedBits)
            printf(" (UnusedBits: %d)", pInfo->SubjectUniqueId.cUnusedBits);
        printf("::\n");
        PrintBytes("    ", pInfo->SubjectUniqueId.pbData,
            pInfo->SubjectUniqueId.cbData);
    }

    if (pInfo->cExtension == 0)
        printf("Extensions:: NONE\n");
    else {
        printf("Extensions::\n");
        PrintExtensions(pInfo->cExtension, pInfo->rgExtension);
    }

    DecodeSignedContent(pbEncoded, cbEncoded, X509_CERT_TO_BE_SIGNED,
        cbInfo);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}


static BOOL DecodeCertReq(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_REQUEST_INFO pInfo = NULL;
    DWORD cbInfo;
    LPSTR pszObjId;
    
    if (NULL == (pInfo = (PCERT_REQUEST_INFO) TestDecodeObject(
            X509_CERT_REQUEST_TO_BE_SIGNED,
            pbEncoded,
            cbEncoded,
            &cbInfo
            ))) goto ErrorReturn;

    printf("Version:: %d\n", pInfo->dwVersion);
    printf("Subject::\n");
    DecodeName(pInfo->Subject.pbData, pInfo->Subject.cbData);

    pszObjId = pInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("SubjectPublicKeyInfo.Algorithm:: %s\n", pszObjId);
    if (pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData) {
        printf("SubjectPublicKeyInfo.Algorithm.Parameters::\n");
        PrintBytes("    ",
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
    }
    printf("SubjectPublicKeyInfo.PublicKey");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
        printf(" (UnusedBits: %d)",
            pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);
    printf("::\n");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cbData) {
        PrintBytes("    ", pInfo->SubjectPublicKeyInfo.PublicKey.pbData,
            pInfo->SubjectPublicKeyInfo.PublicKey.cbData);
    } else
        printf("  No public key\n");


    if (pInfo->cAttribute == 0)
        printf("Attributes:: NONE\n");
    else {
        printf("Attributes::\n");
        PrintAttributes(pInfo->cAttribute, pInfo->rgAttribute);
    }

    DecodeSignedContent(pbEncoded, cbEncoded, X509_CERT_REQUEST_TO_BE_SIGNED,
        cbInfo);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static BOOL DecodeKeygenReq(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_KEYGEN_REQUEST_INFO pInfo = NULL;
    DWORD cbInfo;
    LPSTR pszObjId;
    
    if (NULL == (pInfo = (PCERT_KEYGEN_REQUEST_INFO) TestDecodeObject(
            X509_KEYGEN_REQUEST_TO_BE_SIGNED,
            pbEncoded,
            cbEncoded,
            &cbInfo
            ))) goto ErrorReturn;

    printf("Version:: %d\n", pInfo->dwVersion);

    pszObjId = pInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("SubjectPublicKeyInfo.Algorithm:: %s\n", pszObjId);
    if (pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData) {
        printf("SubjectPublicKeyInfo.Algorithm.Parameters::\n");
        PrintBytes("    ",
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
            pInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData);
    }
    printf("SubjectPublicKeyInfo.PublicKey");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits)
        printf(" (UnusedBits: %d)",
            pInfo->SubjectPublicKeyInfo.PublicKey.cUnusedBits);
    printf("::\n");
    if (pInfo->SubjectPublicKeyInfo.PublicKey.cbData) {
        PrintBytes("    ", pInfo->SubjectPublicKeyInfo.PublicKey.pbData,
            pInfo->SubjectPublicKeyInfo.PublicKey.cbData);
    } else
        printf("  No public key\n");

    printf("ChallengeString:: %S\n", pInfo->pwszChallengeString);

    DecodeSignedContent(pbEncoded, cbEncoded, X509_KEYGEN_REQUEST_TO_BE_SIGNED,
        cbInfo);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static BOOL DecodeContentInfo(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCRYPT_CONTENT_INFO pInfo = NULL;
    LPSTR pszObjId;
    
    if (NULL == (pInfo = (PCRYPT_CONTENT_INFO) TestDecodeObject(
            PKCS_CONTENT_INFO,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    pszObjId = pInfo->pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("ContentType:: %s\n", pszObjId);
    if (pInfo->Content.cbData) {
        printf("Content::\n");
        PrintBytes("    ", pInfo->Content.pbData, pInfo->Content.cbData);
    } else
        printf("NO Content\n");

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static void TestCompareIntegerBlob()
{
    BYTE bZero = 0;
    BYTE bFF = 0xFF;
    
    BYTE rgbLeadZero1[] = {0x12, 0x34, 0x56, 0x87, 0, 0};
    BYTE rgbLeadZero2[] = {0x12, 0x34, 0x56, 0x87, 0, 0, 0, 0};

    BYTE rgbLeadFF1[] = {0x12, 0x34, 0x56, 0x87, 0xFF, 0xFF};
    BYTE rgbLeadFF2[] = {0x12, 0x34, 0x56, 0x87};

    CRYPT_INTEGER_BLOB Int1;
    CRYPT_INTEGER_BLOB Int2;

    Int1.pbData = &bZero;
    Int1.cbData = sizeof(bZero);
    Int2 = Int1;
    if (!CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of Zero == Zero\n");

    Int1.pbData = &bFF;
    Int1.cbData = sizeof(bFF);
    Int2 = Int1;
    if (!CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of FF == FF\n");

    Int1.pbData = &bZero;
    Int1.cbData = sizeof(bZero);
    if (CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of Zero != FF\n");

    Int1.pbData = rgbLeadZero1;
    Int1.cbData = sizeof(rgbLeadZero1);
    Int2.pbData = rgbLeadZero2;
    Int2.cbData = sizeof(rgbLeadZero2);
    if (!CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of Leading Zeroes\n");

    Int1.pbData = rgbLeadFF1;
    Int1.cbData = sizeof(rgbLeadFF1);
    Int2.pbData = rgbLeadFF2;
    Int2.cbData = sizeof(rgbLeadFF2);
    if (!CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of Leading FFs\n");

    Int1.pbData = rgbLeadZero1;
    Int1.cbData = sizeof(rgbLeadZero1);
    if (CertCompareIntegerBlob(&Int1, &Int2))
        printf("Failed => Compare of Leading Zeroes != Leading FFs\n");
}

static BOOL EncodeCrl(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;
    BYTE *pbCrlEncoded = NULL;
    DWORD cbCrlEncoded;

    DWORD SerialNumber0[2] = {0x12345678, 0x33445566};
    DWORD SerialNumber1[1] = {0x12345678};
    SYSTEMTIME SystemTime;


#define CRL_ATTR_0_0 "attr 0_0 printable"
#define CRL_ATTR_0_1 "attr 0_1 IA5"
#define CRL_ATTR_1_0 "attr 1_0 numeric"
#define CRL_ATTR_1_1 "attr 1_1 octet"

    CERT_RDN_ATTR rgAttr0[] = {
        "1.2.3.4.5.0.0.0", CERT_RDN_PRINTABLE_STRING,
            strlen(CRL_ATTR_0_0), (BYTE *) CRL_ATTR_0_0,
        "1.2.3.4.5.0.1.1.1", CERT_RDN_IA5_STRING,
            strlen(CRL_ATTR_0_1), (BYTE *) CRL_ATTR_0_1
    };
    CERT_RDN_ATTR rgAttr1[] = {
        "1.2.3.4.5.1.0", CERT_RDN_NUMERIC_STRING,
            strlen(CRL_ATTR_1_0), (BYTE *) CRL_ATTR_1_0,
        "1.2.3.4.5.1.1", CERT_RDN_OCTET_STRING,
            strlen(CRL_ATTR_1_1), (BYTE *) CRL_ATTR_1_1,
        "1.2.3.4.5.2", CERT_RDN_PRINTABLE_STRING,
            0, NULL
    };
    CERT_RDN rgRDN[] = {
        2, rgAttr0,
        3, rgAttr1,
    };
    CERT_NAME_INFO Name = {2, rgRDN};

#define CRL_EXT_0 "extension 0 ."
#define CRL_EXT_1 "extension 1 .."
#define CRL_EXT_2 "extension 2 ..."
#define CRL_EXT_3 "extension 3 ...."
    CERT_EXTENSION rgExt[] = {
        "1.14.89990", FALSE, strlen(CRL_EXT_0), (BYTE *) CRL_EXT_0,
        "1.14.89991", TRUE, strlen(CRL_EXT_1), (BYTE *) CRL_EXT_1,
        "1.14.89992", FALSE, strlen(CRL_EXT_2), (BYTE *) CRL_EXT_2,
        "1.14.89993", FALSE, strlen(CRL_EXT_3), (BYTE *) CRL_EXT_3
    };
    CRL_INFO Crl;
    BYTE *pbExt = NULL;

    if (dwExtLen) {
        DWORD i;
        if (NULL == (pbExt = (BYTE *) TestAlloc(dwExtLen)))
            goto ErrorReturn;

        for (i = 0; i < dwExtLen; i++)
            pbExt[i] = (BYTE) i;

        rgExt[3].Value.cbData = dwExtLen;
        rgExt[3].Value.pbData = pbExt;
    }

    CRL_ENTRY rgCrlEntry[2];

    TestCompareIntegerBlob();

    cbNameEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbNameEncoded
            );
    if (cbNameEncoded == 0) {
        PrintLastError("EncodeCrl::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbNameEncoded = (BYTE *) TestAlloc(cbNameEncoded);
    if (pbNameEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbNameEncoded,
            &cbNameEncoded
            )) {
        PrintLastError("EncodeCrl::CryptEncodeObject");
        goto ErrorReturn;
    }

    GetSystemTime(&SystemTime);

    memset(rgCrlEntry, 0, sizeof(rgCrlEntry));
    rgCrlEntry[0].SerialNumber.pbData = (BYTE *) &SerialNumber0[0];
    rgCrlEntry[0].SerialNumber.cbData = sizeof(SerialNumber0);
    SystemTime.wYear--;
    SystemTimeToFileTime(&SystemTime, &rgCrlEntry[0].RevocationDate);
    rgCrlEntry[0].cExtension = 0;
    rgCrlEntry[0].rgExtension = NULL;

    rgCrlEntry[1].SerialNumber.pbData = (BYTE *) &SerialNumber1[0];
    rgCrlEntry[1].SerialNumber.cbData = sizeof(SerialNumber1);
    SystemTime.wYear--;
    SystemTimeToFileTime(&SystemTime, &rgCrlEntry[1].RevocationDate);
    rgCrlEntry[1].cExtension = 2;
    rgCrlEntry[1].rgExtension = &rgExt[1];

    memset(&Crl, 0, sizeof(Crl));
    Crl.dwVersion = CRL_V2;
    Crl.SignatureAlgorithm.pszObjId = "1.2.4.5.898";
    Crl.Issuer.pbData = pbNameEncoded;
    Crl.Issuer.cbData = cbNameEncoded;
    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &Crl.ThisUpdate);
    SystemTime.wYear++;
    SystemTimeToFileTime(&SystemTime, &Crl.NextUpdate);
    Crl.cCRLEntry = sizeof(rgCrlEntry) / sizeof(rgCrlEntry[0]);
    Crl.rgCRLEntry = rgCrlEntry;
    Crl.cExtension = sizeof(rgExt) / sizeof(rgExt[0]);
    Crl.rgExtension = rgExt;

    cbCrlEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_CRL_TO_BE_SIGNED,
            &Crl,
            NULL,               // pbEncoded
            &cbCrlEncoded
            );
    if (cbCrlEncoded == 0) {
        PrintLastError("EncodeCrl::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbCrlEncoded = (BYTE *) TestAlloc(cbCrlEncoded);
    if (pbCrlEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_CRL_TO_BE_SIGNED,
            &Crl,
            pbCrlEncoded,
            &cbCrlEncoded
            )) {
        PrintLastError("EncodeCrl::CryptEncodeObject");
        goto ErrorReturn;
    }

    if (!EncodeSignedContent(
            pbCrlEncoded,
            cbCrlEncoded,
            ppbEncoded,
            pcbEncoded))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbNameEncoded)
        TestFree(pbNameEncoded);
    if (pbExt)
        TestFree(pbExt);
    if (pbCrlEncoded)
        TestFree(pbCrlEncoded);

    return fResult;
}

static void PrintCrlEntries(DWORD cEntry, PCRL_ENTRY pEntry)
{
    DWORD i; 

    for (i = 0; i < cEntry; i++, pEntry++) {
        {
            DWORD cb;
            BYTE *pb;
            printf(" [%d] SerialNumber::", i);
            for (cb = pEntry->SerialNumber.cbData,
                 pb = pEntry->SerialNumber.pbData + (cb - 1);
                                                    cb > 0; cb--, pb--) {
                printf(" %02X", *pb);
            }
            printf("\n");
        }

        printf(" [%d] RevocationDate:: %s\n", i,
            FileTimeText(&pEntry->RevocationDate));

        if (pEntry->cExtension == 0)
            printf(" [%d] Extensions:: NONE\n", i);
        else {
            printf(" [%d] Extensions::\n", i);
            PrintExtensions(pEntry->cExtension, pEntry->rgExtension);
        }
    }
}

static BOOL DecodeCrl(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCRL_INFO pInfo = NULL;
    DWORD cbInfo;
    LPSTR pszObjId;
    
    if (NULL == (pInfo = (PCRL_INFO) TestDecodeObject(
            X509_CERT_CRL_TO_BE_SIGNED,
            pbEncoded,
            cbEncoded,
            &cbInfo
            ))) goto ErrorReturn;

    printf("Version:: %d\n", pInfo->dwVersion);

    pszObjId = pInfo->SignatureAlgorithm.pszObjId;
    if (pszObjId == NULL)
        pszObjId = "<NULL OBJID>";
    printf("SignatureAlgorithm:: %s\n", pszObjId);
    if (pInfo->SignatureAlgorithm.Parameters.cbData) {
        printf("SignatureAlgorithm.Parameters::\n");
        PrintBytes("    ", pInfo->SignatureAlgorithm.Parameters.pbData,
            pInfo->SignatureAlgorithm.Parameters.cbData);
    }

    printf("Issuer::\n");
    DecodeName(pInfo->Issuer.pbData, pInfo->Issuer.cbData);

    printf("ThisUpdate:: %s\n", FileTimeText(&pInfo->ThisUpdate));
    printf("NextUpdate:: %s\n", FileTimeText(&pInfo->NextUpdate));

    if (pInfo->cExtension == 0)
        printf("Extensions:: NONE\n");
    else {
        printf("Extensions::\n");
        PrintExtensions(pInfo->cExtension, pInfo->rgExtension);
    }

    if (pInfo->cCRLEntry == 0)
        printf("Entries:: NONE\n");
    else {
        printf("Entries::\n");
        PrintCrlEntries(pInfo->cCRLEntry, pInfo->rgCRLEntry);
    }

    DecodeSignedContent(pbEncoded, cbEncoded, X509_CERT_CRL_TO_BE_SIGNED,
        cbInfo);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    return fResult;
}

static BOOL EncodeCertPair(BYTE **ppbEncoded, DWORD *pcbEncoded)
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    CERT_PAIR CertPair;

    memset(&CertPair, 0, sizeof(CertPair));
    if (pszForwardCertFilename)
        ReadDERFromFile(pszForwardCertFilename,
            &CertPair.Forward.pbData, &CertPair.Forward.cbData);
    if (pszReverseCertFilename)
        ReadDERFromFile(pszReverseCertFilename,
            &CertPair.Reverse.pbData, &CertPair.Reverse.cbData);

    cbEncoded = 0;
    CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_PAIR,
            &CertPair,
            NULL,               // pbEncoded
            &cbEncoded
            );
    if (cbEncoded == 0) {
        PrintLastError("EncodeCertPair::CryptEncodeObject(cbEncoded == 0)");
        goto ErrorReturn;
    }
    pbEncoded = (BYTE *) TestAlloc(cbEncoded);
    if (pbEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_CERT_PAIR,
            &CertPair,
            pbEncoded,
            &cbEncoded
            )) {
        PrintLastError("EncodeCertPair::CryptEncodeObject");
        goto ErrorReturn;
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;

CommonReturn:
    TestFree(CertPair.Forward.pbData);
    TestFree(CertPair.Reverse.pbData);
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;

    return fResult;
}

static BOOL DecodeCertPair(BYTE *pbEncoded, DWORD cbEncoded)
{
    BOOL fResult;
    PCERT_PAIR pInfo = NULL;
    
    if (NULL == (pInfo = (PCERT_PAIR) TestDecodeObject(
            X509_CERT_PAIR,
            pbEncoded,
            cbEncoded
            ))) goto ErrorReturn;

    if (pInfo->Forward.cbData) {
        printf("Forward Certificate::\n");
        PrintBytes("    ", pInfo->Forward.pbData, pInfo->Forward.cbData);
    } else
        printf("NO Forward Certificate\n");

    if (pInfo->Reverse.cbData) {
        printf("Reverse Certificate::\n");
        PrintBytes("    ", pInfo->Reverse.pbData, pInfo->Reverse.cbData);
    } else
        printf("NO Reverse Certificate\n");

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    TestFree(pInfo);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\pkcs8im\pkcs8im.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       pkcs8im.cpp
//
//  Contents:   Private Key Load Test
//
//              See Usage() for list of load options.
//
//  Functions:  main
//
//  History:    6-26-96   
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static struct
{
    LPCSTR      pszName;
    LPCWSTR     pwszKeyTitle;
    DWORD       dwKeySpec;
} KeyTypes[] = {
    "Sign",     L"Signature",   AT_SIGNATURE,
    "Xchg",     L"Exchange",    AT_KEYEXCHANGE
};
#define NKEYTYPES (sizeof(KeyTypes)/sizeof(KeyTypes[0]))


static void Usage(void)
{
    int i;

    printf("Usage: pkcs8im [options] <Filename> <KeyType>\n");
    printf("Options are:\n");
    printf("  -p<name>              - Crypto provider name (if not default)\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -E                    - Exportable private keys\n");
    printf("  -h                    - This message\n");
    printf("\n");
    printf("KeyType (case insensitive):\n");
    for (i = 0; i < NKEYTYPES; i++)
        printf("  %s\n", KeyTypes[i].pszName);
    printf("\n");
}


static BOOL CALLBACK ResolvehCryptFunc(
	CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo,
	HCRYPTPROV			*phCryptProv,
	LPVOID				pVoidResolveFunc)
{
	CRYPT_KEY_PROV_INFO *pCryptKeyProvInfo = (CRYPT_KEY_PROV_INFO *) pVoidResolveFunc;
	
	return (CryptAcquireContext(
				phCryptProv,
				(LPSTR) pCryptKeyProvInfo->pwszContainerName,
				(LPSTR) pCryptKeyProvInfo->pwszProvName,
				PROV_RSA_FULL,
				CRYPT_NEWKEYSET));
}



int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    HCRYPTPROV hProv = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BOOL fForce = FALSE;
    BYTE *pbKey = NULL;
	DWORD cbKey;
    DWORD cbRead;
	LPSTR pszProvider = NULL;
	DWORD numWideChars;
    LPSTR pszContainer = NULL;
    LPSTR pszFilename = NULL;
    LPSTR pszKeyType = NULL;
    int KeyIdx = 0;
    DWORD dwFlags = 0;
	DWORD dwKeySpec = 0;
	CRYPT_KEY_PROV_INFO CryptKeyProvInfo;
	CRYPT_PRIVATE_KEY_BLOB_AND_PARAMS KeyBlobAndParams;
	BYTE *pPrivateKeyBuffer = NULL;


    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'F':
                fForce = TRUE;
                break;
            case 'E':
                dwFlags = CRYPT_EXPORTABLE;
                break;
            case 'p':
                 pszProvider = (LPSTR) argv[0]+2; 
									
                if (*pszContainer == L'\0') {
                    printf("Need to specify crypto key container name\n");
                    goto BadUsage;
                }
                break;
            case 'c':
				pszContainer = (LPSTR) argv[0]+2;
									
                if (*pszContainer == L'\0') {
                    printf("Need to specify crypto key container name\n");
                    goto BadUsage;
                }
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (pszFilename == NULL)
                pszFilename = argv[0];
            else if(pszKeyType == NULL)
                pszKeyType = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    if (pszFilename == NULL) {
        printf("missing Filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());
    
    if (pszKeyType) {
        for (KeyIdx = 0; KeyIdx < NKEYTYPES; KeyIdx++) {
            if (_stricmp(pszKeyType, KeyTypes[KeyIdx].pszName) == 0)
                break;
        }
        if (KeyIdx >= NKEYTYPES) {
            printf("Bad KeyType: %s\n", pszKeyType);
            goto BadUsage;
        }
    } else {
        printf("No KeyType specified... using type specified in key\n");
    }

    hFile = CreateFileA(
            pszFilename,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,                   // lpsa
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL                    // hTemplateFile
            );
    if (hFile == INVALID_HANDLE_VALUE) {
        printf( "can't open %s\n", pszFilename);
        goto ErrorReturn;
    }
	
	memset(&CryptKeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));
	CryptKeyProvInfo.pwszContainerName = (LPWSTR) pszContainer;
	CryptKeyProvInfo.pwszProvName = (LPWSTR) pszProvider;
	if (pszKeyType)
		CryptKeyProvInfo.dwKeySpec = KeyTypes[KeyIdx].dwKeySpec;
	else
		CryptKeyProvInfo.dwKeySpec = 0;

    cbKey = GetFileSize(hFile, NULL);
    if (cbKey == 0) {
        printf( "empty file %s\n", pszFilename);
        goto ErrorReturn;
    }
    if (NULL == (pbKey = (PBYTE)TestAlloc(cbKey)))
        goto ErrorReturn;

    if (!ReadFile(hFile, pbKey, cbKey, &cbRead, NULL) ||
            (cbRead != cbKey)) {
        printf( "can't read %s\n", pszFilename);
        goto ErrorReturn;
    }

	KeyBlobAndParams.PrivateKey.cbData = cbKey;
	KeyBlobAndParams.PrivateKey.pbData = pbKey;
	KeyBlobAndParams.pResolvehCryptProvFunc = ResolvehCryptFunc;
	KeyBlobAndParams.pVoidResolveFunc = &CryptKeyProvInfo;
	KeyBlobAndParams.pDecryptPrivateKeyFunc = NULL;
	KeyBlobAndParams.pVoidDecryptFunc = NULL;
    
	if (!CryptImportPKCS8(
			KeyBlobAndParams,
			dwFlags,
			NULL,
			NULL
			)) {
            PrintLastError("CryptImportPKCS8()");
            goto ErrorReturn;
        }

	if (dwKeySpec == AT_SIGNATURE)
		printf("Key imported as type 'Sign'\n");
	else if (dwKeySpec == AT_KEYEXCHANGE)
		printf("Key imported as type 'Xchg'\n");

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (pbKey)
        TestFree(pbKey);
	if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tcertper\tcertper.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tcertper.cpp
//
//  Contents:   Cert Performance Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    30-Nov-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "wintrust.h"
#include "softpub.h"
#include "mscat.h"
#include "certtest.h"
#include "unicode.h"
#include "certprot.h"

#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf("Usage: tcertper [options] <TestName> [<Para1> <Para2>]\n");
    printf("\n");
    printf("  -UseIE4Trust\n");
    printf("  -NoIE4Chain\n");
    printf("  -CacheEndCert\n");
    printf("\n");
    printf("  -NoEntry\n");
    printf("  -NoMsg\n");
    printf("\n");
    printf("  -AuthPolicy\n");
    printf("  -TSPolicy\n");
    printf("\n");
    printf("  -Pause\n");
    printf("\n");
    printf("Options are:\n");
    printf("  -u<OID String>    - Usage OID string -u1.3.6.1.5.5.7.3.3\n");
    printf("  -h                - This message\n");
    printf("  -i<number>        - Iterations (default to 1000)\n");
    printf("TestNames (case insensitive):\n");
    printf("  NULL\n");
    printf("  CreateCertContext <cert filename>\n");
    printf("  VerifyCertSignature <cert filename> [<issuer filename>]\n");
    printf("  CreateCRLContext <CRL filename>\n");
    printf("  CreateCTLContext <CTL filename>\n");
    printf("  CreateSortedCTLContext <CTL filename>\n");
    printf("  CreateFastCTLContext <CTL filename>\n");
    printf("  DecodePKCS7 <CTL filename>\n");
    printf("  StreamDecodePKCS7 <CTL filename>\n");
    printf("  GetCertProperty <cert filename>\n");
    printf("  DecodeOID <OID>\n");
    printf("  FindExtension <cert filename> <OID>\n");
    printf("  DecodeExtension <cert filename> <OID>\n");
    printf("  WVTCert <cert filename> [<AdditionalFileStore>]\n");
    printf("  WVTFile <filename>\n");
    printf("  WVTCat <cat filename> <member filename>\n");
    printf("  CertChain <cert filename> [<AdditionalFileStore>]\n");
    printf("\n");
}

#define NULL_TEST_ID                        1
#define CREATE_CERT_CONTEXT_TEST_ID         2
#define VERIFY_CERT_SIGNATURE_TEST_ID       3
#define CREATE_CTL_CONTEXT_TEST_ID          4
#define GET_CERT_PROPERTY_TEST_ID           5
#define DECODE_OID_TEST_ID                  6
#define FIND_EXTENSION_TEST_ID              7
#define DECODE_EXTENSION_TEST_ID            8
#define CREATE_SORTED_CTL_CONTEXT_TEST_ID   9
#define DECODE_PKCS7_TEST_ID                10
#define STREAM_DECODE_PKCS7_TEST_ID         11
#define WVT_CERT_TEST_ID                    12
#define WVT_FILE_TEST_ID                    13
#define CERT_CHAIN_TEST_ID                  14
#define CREATE_CRL_CONTEXT_TEST_ID          15
#define WVT_CAT_TEST_ID                     16
#define CREATE_FAST_CTL_CONTEXT_TEST_ID     17
static struct
{
    LPCSTR      pszName;
    DWORD       dwID;
} Tests[] = {
    "NULL",                 NULL_TEST_ID,
    "CreateCertContext",    CREATE_CERT_CONTEXT_TEST_ID,
    "VerifyCertSignature",  VERIFY_CERT_SIGNATURE_TEST_ID,
    "CreateCRLContext",     CREATE_CRL_CONTEXT_TEST_ID,
    "CreateCTLContext",     CREATE_CTL_CONTEXT_TEST_ID,
    "GetCertProperty",      GET_CERT_PROPERTY_TEST_ID,
    "DecodeOID",            DECODE_OID_TEST_ID,
    "FindExtension",        FIND_EXTENSION_TEST_ID,
    "DecodeExtension",      DECODE_EXTENSION_TEST_ID,
    "CreateSortedCTLContext", CREATE_SORTED_CTL_CONTEXT_TEST_ID,
    "CreateFastCTLContext", CREATE_FAST_CTL_CONTEXT_TEST_ID,
    "DecodePKCS7",          DECODE_PKCS7_TEST_ID,
    "StreamDecodePKCS7",    STREAM_DECODE_PKCS7_TEST_ID,
    "WVTCert",              WVT_CERT_TEST_ID,
    "WVTFile",              WVT_FILE_TEST_ID,
    "WVTCat",               WVT_CAT_TEST_ID,
    "CertChain",            CERT_CHAIN_TEST_ID,
};
#define NTESTS (sizeof(Tests)/sizeof(Tests[0]))

static BOOL WINAPI StreamOutputCallback(
        IN const void *pvArg,
        IN BYTE *pbData,
        IN DWORD cbData,
        IN BOOL fFinal
        )
{
#if 0
    printf("StreamOutputCallback:: pbData: 0x%x cbData: 0x%x fFinal: 0x%x\n",
        pbData, cbData, fFinal);
#endif
    return TRUE;
}


static PCCERT_CONTEXT ReadCert(
    IN LPCSTR pszCert
    )
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszCert, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCert");
        return NULL;
    }

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL)
        PrintLastError("CertCreateCertificateContext");

    TestFree(pbEncoded);
    return pCert;
}


int _cdecl main(int argc, char * argv[]) 
{
    int status;

#define TEST_NAME_INDEX         0
#define CERT_FILENAME_INDEX     1
#define CTL_FILENAME_INDEX      1
#define CRL_FILENAME_INDEX      1
#define PKCS7_FILENAME_INDEX    1
#define OID_INDEX               1
#define WVT_FILENAME_INDEX      1
#define ISSUER_FILENAME_INDEX   2
#define CERT_OID_INDEX          2
#define STORE_FILENAME_INDEX    2
#define WVT_CAT_FILENAME_INDEX  1
#define WVT_MEMBER_FILENAME_INDEX 2
#define MAX_NAME_CNT            3
    DWORD dwNameCnt = 0;
    LPCSTR rgpszName[MAX_NAME_CNT];
    LPCSTR pszTestName;                 // not allocated

    
    DWORD dwIterations = 1000;
    DWORD i;
    DWORD dwTestID;
    BOOL fPause = FALSE;


    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbEncodedCert = NULL;
    DWORD cbEncodedCert;
    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT pIssuer = NULL;
    PCCTL_CONTEXT pCtl = NULL;
    PCCRL_CONTEXT pCrl = NULL;
    HCRYPTMSG hMsg = NULL;
    CMSG_STREAM_INFO StreamInfo;

    LPCSTR pszOID;
    BYTE rgbEncodedAttr[512];
    DWORD cbEncodedAttr;

    BYTE rgbAttr[512];
    DWORD cbAttr;
    PCRYPT_ATTRIBUTE pAttr = (PCRYPT_ATTRIBUTE) rgbAttr;
    

    DWORD dwProp;
    DWORD cbData;

    PCERT_EXTENSION pExt;
    DWORD cbExt;
    BYTE rgbExt[8192];

    SYSTEMTIME stFirst, stStart, stEnd;
    FILETIME ftFirst, ftStart, ftEnd;

    _int64 DeltaTime;
    int Microseconds;
    int Milliseconds;
    int Seconds;

    DWORD dwCreateChainFlags = 0;
    DWORD dwError;
    DWORD dwFirstError;
    LONG lStatus;
    LONG lFirstStatus;
    LPSTR pszUsageOID = NULL;           // not allocated
    LPSTR pszSignerUsage = szOID_KP_CTL_USAGE_SIGNING;

    GUID wvtFileActionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID wvtCertActionID = WINTRUST_ACTION_GENERIC_CERT_VERIFY;
    GUID wvtDriverActionID = DRIVER_ACTION_VERIFY;
    GUID *pwvtActionID;

    WINTRUST_FILE_INFO wvtFileInfo;
    memset(&wvtFileInfo, 0, sizeof(wvtFileInfo));
    wvtFileInfo.cbStruct = sizeof(wvtFileInfo);
    wvtFileInfo.pcwszFilePath = NULL;

    HCERTSTORE hAdditionalStore = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;

    WINTRUST_CERT_INFO wvtCertInfo;
    memset(&wvtCertInfo, 0, sizeof(wvtCertInfo));
    wvtCertInfo.cbStruct = sizeof(wvtCertInfo);
    wvtCertInfo.psCertContext = NULL;
    wvtCertInfo.chStores = 0;
    wvtCertInfo.pahStores = &hAdditionalStore;
    wvtCertInfo.dwFlags = 0;
    wvtCertInfo.pcwszDisplayName = L"Cert Display Name";

    WINTRUST_DATA wvtData;
    memset(&wvtData, 0, sizeof(wvtData));
    wvtData.cbStruct = sizeof(wvtData);
    wvtData.pPolicyCallbackData = NULL;
    wvtData.dwUIChoice = WTD_UI_NONE;
    wvtData.fdwRevocationChecks = WTD_REVOKE_NONE;
    wvtData.dwUnionChoice = WTD_CHOICE_CERT;
    wvtData.pCert = &wvtCertInfo;
    wvtData.dwStateAction = WTD_STATEACTION_IGNORE;
    wvtData.hWVTStateData = NULL;
    wvtData.dwProvFlags = 0;

    WINTRUST_CATALOG_INFO wvtCat;
    memset(&wvtCat, 0, sizeof(wvtCat));
    wvtCat.cbStruct = sizeof(WINTRUST_CATALOG_INFO);

    DWORD cbCatHash;
    BYTE rgbCatHash[40];

    CERT_CHAIN_PARA ChainPara;
    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    CERT_CHAIN_POLICY_PARA ChainPolicyPara;
    memset(&ChainPolicyPara, 0, sizeof(ChainPolicyPara));
    ChainPolicyPara.cbSize = sizeof(ChainPolicyPara);

    CERT_CHAIN_POLICY_STATUS ChainPolicyStatus;
    memset(&ChainPolicyStatus, 0, sizeof(ChainPolicyStatus));
    ChainPolicyStatus.cbSize = sizeof(ChainPolicyStatus);

    LPCSTR pszChainPolicyOID = CERT_CHAIN_POLICY_BASE;

    DWORD dwFastCtlFlags = 0;

    while (--argc>0) {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "UseIE4Trust")) {
                wvtData.dwProvFlags |= WTD_USE_IE4_TRUST_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "NoIE4Chain")) {
                wvtData.dwProvFlags |= WTD_NO_IE4_CHAIN_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "CacheEndCert")) {
                dwCreateChainFlags |= CERT_CHAIN_CACHE_END_CERT;

            } else if (0 == _stricmp(argv[0]+1, "AuthPolicy")) {
                pszChainPolicyOID = CERT_CHAIN_POLICY_AUTHENTICODE;
            } else if (0 == _stricmp(argv[0]+1, "TSPolicy")) {
                pszChainPolicyOID = CERT_CHAIN_POLICY_AUTHENTICODE_TS;

            } else if (0 == _stricmp(argv[0]+1, "NoMsg")) {
                dwFastCtlFlags |= CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "NoEntry")) {
                dwFastCtlFlags |= CERT_CREATE_CONTEXT_NO_ENTRY_FLAG;

            } else if (0 == _stricmp(argv[0]+1, "Pause")) {
                fPause = TRUE;

            } else {
                switch(argv[0][1])
                {
                case 'u':
                    pszUsageOID = argv[0]+2;
                    break;
                case 'i':
                    dwIterations = strtoul(argv[0]+2, NULL, 0);
                    break;

                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (MAX_NAME_CNT <= dwNameCnt) {
                printf("Too many names starting with:: %s\n", argv[0]);
                goto BadUsage;
            }
            rgpszName[dwNameCnt++] = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());

    if (0 == dwNameCnt) {
        printf("Missing <TestName>\n");
        goto BadUsage;
    } else
        pszTestName = rgpszName[TEST_NAME_INDEX];

    dwTestID = 0;
    for (i = 0; i < NTESTS; i++) {
        if (_stricmp(pszTestName, Tests[i].pszName) == 0) {
            dwTestID = Tests[i].dwID;
            break;
        }
    }
    if (0 == dwTestID) {
        printf("Bad TestName: %s\n", pszTestName);
        Usage();
        goto BadUsage;
    }

    if (0 == dwIterations) {
        printf("0 iterations\n");
        goto BadUsage;
    } else
        printf("%d iterations\n", dwIterations);

    if (fPause) {
        int c;
        fputs("Waiting to start ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();
    }

    GetSystemTime(&stFirst);
    for (i = 0; i <= dwIterations; i++) {
        if (1 == i)
            GetSystemTime(&stStart);

        switch (dwTestID) {
            case NULL_TEST_ID:
                break;

            case CREATE_CERT_CONTEXT_TEST_ID:
                if (0 == i) {
                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CERT_FILENAME_INDEX],
                            &pbEncodedCert,
                            &cbEncodedCert
                            )) {
                        printf("Unable to read cert file\n");
                        goto ErrorReturn;
                    }
                }

                if (NULL == (pCert = CertCreateCertificateContext(
                        X509_ASN_ENCODING,
                        pbEncodedCert,
                        cbEncodedCert
                        ))) {
                    PrintLastError("CertCreateCertificateContext");
                    goto ErrorReturn;
                }
                CertFreeCertificateContext(pCert);
                pCert = NULL;
                break;

            case VERIFY_CERT_SIGNATURE_TEST_ID:
                if (0 == i) {
                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CERT_FILENAME_INDEX],
                            &pbEncodedCert,
                            &cbEncodedCert
                            )) {
                        printf("Unable to read cert file\n");
                        goto ErrorReturn;
                    }

                    if (NULL == (pCert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbEncodedCert,
                            cbEncodedCert
                            ))) {
                        PrintLastError("CertCreateCertificateContext(cert)");
                        goto ErrorReturn;
                    }

                    TestFree(pbEncodedCert);
                    pbEncodedCert = NULL;

                    if (ISSUER_FILENAME_INDEX >= dwNameCnt)
                        pIssuer = CertDuplicateCertificateContext(pCert);
                    else {
                        if (!ReadDERFromFile(
                                rgpszName[ISSUER_FILENAME_INDEX],
                                &pbEncodedCert,
                                &cbEncodedCert
                                )) {
                            printf("Unable to read issuer file\n");
                            goto ErrorReturn;
                        }

                        if (NULL == (pIssuer = CertCreateCertificateContext(
                                X509_ASN_ENCODING,
                                pbEncodedCert,
                                cbEncodedCert
                                ))) {
                            PrintLastError(
                                "CertCreateCertificateContext(issuer)");
                            goto ErrorReturn;
                        }
                    }
                }

                if (!CryptVerifyCertificateSignature(
                        0,              // hCryptProv
                        pCert->dwCertEncodingType,
                        pCert->pbCertEncoded,
                        pCert->cbCertEncoded,
                        &pIssuer->pCertInfo->SubjectPublicKeyInfo
                        )) {
                    PrintLastError("CryptVerifyCertificateSignature");
                    goto ErrorReturn;
                }
                break;

            case CREATE_CRL_CONTEXT_TEST_ID:
                if (0 == i) {
                    if (CRL_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing CRL filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CRL_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read CRL file\n");
                        goto ErrorReturn;
                    }
                }

                if (NULL == (pCrl = CertCreateCRLContext(
                        X509_ASN_ENCODING,
                        pbEncoded,
                        cbEncoded
                        ))) {
                    PrintLastError("CertCreateCRLContext");
                    goto ErrorReturn;
                }
                CertFreeCRLContext(pCrl);
                pCrl = NULL;
                break;


            case CREATE_CTL_CONTEXT_TEST_ID:
                if (0 == i) {
                    if (CTL_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing CTL filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CTL_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read CTL file\n");
                        goto ErrorReturn;
                    }
                }

                if (NULL == (pCtl = CertCreateCTLContext(
                        X509_ASN_ENCODING,
                        pbEncoded,
                        cbEncoded
                        ))) {
                    PrintLastError("CertCreateCTLContext");
                    goto ErrorReturn;
                }
                CertFreeCTLContext(pCtl);
                pCtl = NULL;
                break;

            case CREATE_SORTED_CTL_CONTEXT_TEST_ID:
                if (0 == i) {
                    if (CTL_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing CTL filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CTL_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read CTL file\n");
                        goto ErrorReturn;
                    }
                }

                if (NULL == (pCtl = (PCCTL_CONTEXT) CertCreateContext(
                        CERT_STORE_CTL_CONTEXT,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        pbEncoded,
                        cbEncoded,
                        CERT_CREATE_CONTEXT_NOCOPY_FLAG |
                            CERT_CREATE_CONTEXT_SORTED_FLAG,
                        NULL                                // pCreatePara
                        ))) {
                    PrintLastError("CertCreateContext(Sorted CTL)");
                    goto ErrorReturn;
                }
                CertFreeCTLContext(pCtl);
                pCtl = NULL;
                break;

            case CREATE_FAST_CTL_CONTEXT_TEST_ID:
                if (0 == i) {
                    dwFastCtlFlags |= CERT_CREATE_CONTEXT_NOCOPY_FLAG;

                    if (CTL_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing CTL filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CTL_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read CTL file\n");
                        goto ErrorReturn;
                    }
                }

                if (NULL == (pCtl = (PCCTL_CONTEXT) CertCreateContext(
                        CERT_STORE_CTL_CONTEXT,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        pbEncoded,
                        cbEncoded,
                        dwFastCtlFlags,
                        NULL                                // pCreatePara
                        ))) {
                    PrintLastError("CertCreateContext(Fast CTL)");
                    goto ErrorReturn;
                }
                CertFreeCTLContext(pCtl);
                pCtl = NULL;
                break;

            case DECODE_PKCS7_TEST_ID:
                if (0 == i) {
                    if (PKCS7_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing PKCS7 filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[PKCS7_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read PKCS7 file\n");
                        goto ErrorReturn;
                    }
                }
                if (NULL == (hMsg = CryptMsgOpenToDecode(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        0,                          // dwFlags
                        0,                          // dwMsgType
                        NULL,                       // hProv
                        NULL,                       // pRecipientInfo
                        NULL                        // pStreamInfo
                        ))) {
                    PrintLastError("CryptMsgOpenToDecode");
                    goto ErrorReturn;
                }
                if (!CryptMsgUpdate(
                        hMsg,
                        pbEncoded,
                        cbEncoded,
                        TRUE                    // fFinal
                        )) {
                    PrintLastError("CryptMsgUpdate");
                    goto ErrorReturn;
                }
                CryptMsgClose(hMsg);
                hMsg = NULL;
                break;

            case STREAM_DECODE_PKCS7_TEST_ID:
                if (0 == i) {
                    if (PKCS7_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing PKCS7 filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[PKCS7_FILENAME_INDEX],
                            &pbEncoded,
                            &cbEncoded
                            )) {
                        printf("Unable to read PKCS7 file\n");
                        goto ErrorReturn;
                    }
                }
                memset(&StreamInfo, 0, sizeof(StreamInfo));
                StreamInfo.pfnStreamOutput = StreamOutputCallback;
                if (NULL == (hMsg = CryptMsgOpenToDecode(
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        0,                          // dwFlags
                        0,                          // dwMsgType
                        NULL,                       // hProv
                        NULL,                       // pRecipientInfo
                        &StreamInfo
                        ))) {
                    PrintLastError("CryptMsgOpenToDecode(STREAM)");
                    goto ErrorReturn;
                }
                if (!CryptMsgUpdate(
                        hMsg,
                        pbEncoded,
                        cbEncoded,
                        TRUE                    // fFinal
                        )) {
                    PrintLastError("CryptMsgUpdate");
                    goto ErrorReturn;
                }
                CryptMsgClose(hMsg);
                hMsg = NULL;
                break;

            case GET_CERT_PROPERTY_TEST_ID:
                if (0 == i) {
                    CRYPT_DATA_BLOB DataBlob;

                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CERT_FILENAME_INDEX],
                            &pbEncodedCert,
                            &cbEncodedCert
                            )) {
                        printf("Unable to read cert file\n");
                        goto ErrorReturn;
                    }

                    if (NULL == (pCert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbEncodedCert,
                            cbEncodedCert
                            ))) {
                        PrintLastError("CertCreateCertificateContext");
                        goto ErrorReturn;
                    }

                    DataBlob.pbData = (BYTE *) &dwProp;
                    DataBlob.cbData = sizeof(dwProp);
                    dwProp = 0x12345678;

                    if (!CertSetCertificateContextProperty(
                            pCert,
                            CERT_FIRST_USER_PROP_ID,
                            0,                          // dwFlags
                            &DataBlob
                            )) {
                        PrintLastError("CertSetCertificateContextProperty");
                        goto ErrorReturn;
                    }
                }

                dwProp = 0;
                cbData = sizeof(dwProp);
                if (!CertGetCertificateContextProperty(
                        pCert,
                        CERT_FIRST_USER_PROP_ID,
                        &dwProp,
                        &cbData
                        )) {
                    PrintLastError("CertGetCertificateContextProperty");
                    goto ErrorReturn;
                }

                if (0x12345678 != dwProp || sizeof(dwProp) != cbData) {
                    printf("failed => invalid get property\n");
                    goto ErrorReturn;
                }
                break;

            case DECODE_OID_TEST_ID:
                if (0 == i) {
                    CRYPT_ATTRIBUTE Attribute;

                    if (OID_INDEX >= dwNameCnt) {
                        printf("missing OID\n");
                        goto BadUsage;
                    } else
                        pszOID = rgpszName[OID_INDEX];

                    Attribute.pszObjId = (LPSTR) pszOID;
                    Attribute.cValue = 0;
                    Attribute.rgValue = NULL;

                    cbEncodedAttr = sizeof(rgbEncodedAttr);
                    if (!CryptEncodeObject(
                            X509_ASN_ENCODING,
                            PKCS_ATTRIBUTE,
                            &Attribute,
                            rgbEncodedAttr,
                            &cbEncodedAttr
                            )) {
                        PrintLastError("CryptEncodeObject(PKCS_ATTRIBUTE)");
                        goto ErrorReturn;
                    }
                }

                pAttr->pszObjId = NULL;
                cbAttr = sizeof(rgbAttr);
                if (!CryptDecodeObject(
                        X509_ASN_ENCODING,
                        PKCS_ATTRIBUTE,
                        rgbEncodedAttr,
                        cbEncodedAttr,
                        CRYPT_DECODE_NOCOPY_FLAG,
                        pAttr,
                        &cbAttr
                        )) {
                    PrintLastError("CryptDecodeObject(PKCS_ATTRIBUTE)");
                    goto ErrorReturn;
                }

                if (0 != strcmp(pszOID, pAttr->pszObjId)) {
                    printf("failed => invalid decoded OID\n");
                    goto ErrorReturn;
                }
                break;

            case FIND_EXTENSION_TEST_ID:
                if (0 == i) {
                    CRYPT_DATA_BLOB DataBlob;

                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CERT_FILENAME_INDEX],
                            &pbEncodedCert,
                            &cbEncodedCert
                            )) {
                        printf("Unable to read cert file\n");
                        goto ErrorReturn;
                    }

                    if (NULL == (pCert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbEncodedCert,
                            cbEncodedCert
                            ))) {
                        PrintLastError("CertCreateCertificateContext");
                        goto ErrorReturn;
                    }

                    if (CERT_OID_INDEX >= dwNameCnt) {
                        printf("missing OID\n");
                        goto BadUsage;
                    } else
                        pszOID = rgpszName[CERT_OID_INDEX];

                }

                if (NULL == (pExt = CertFindExtension(
                        pszOID,
                        pCert->pCertInfo->cExtension,
                        pCert->pCertInfo->rgExtension
                        ))) {
                    PrintLastError("CertFindExtension");
                    goto ErrorReturn;
                }

                break;

            case DECODE_EXTENSION_TEST_ID:
                if (0 == i) {
                    CRYPT_DATA_BLOB DataBlob;

                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }

                    if (!ReadDERFromFile(
                            rgpszName[CERT_FILENAME_INDEX],
                            &pbEncodedCert,
                            &cbEncodedCert
                            )) {
                        printf("Unable to read cert file\n");
                        goto ErrorReturn;
                    }

                    if (NULL == (pCert = CertCreateCertificateContext(
                            X509_ASN_ENCODING,
                            pbEncodedCert,
                            cbEncodedCert
                            ))) {
                        PrintLastError("CertCreateCertificateContext");
                        goto ErrorReturn;
                    }

                    if (CERT_OID_INDEX >= dwNameCnt) {
                        printf("missing OID\n");
                        goto BadUsage;
                    } else
                        pszOID = rgpszName[CERT_OID_INDEX];

                    if (NULL == (pExt = CertFindExtension(
                            pszOID,
                            pCert->pCertInfo->cExtension,
                            pCert->pCertInfo->rgExtension
                            ))) {
                        PrintLastError("CertFindExtension");
                        goto ErrorReturn;
                    }

                }

#if 0
                cbExt = sizeof(rgbExt);
                if (!CryptDecodeObject(
                        X509_ASN_ENCODING,
                        pExt->pszObjId,
                        pExt->Value.pbData,
                        pExt->Value.cbData,
                        CRYPT_DECODE_NOCOPY_FLAG,
                        rgbExt,
                        &cbExt
                        )) {
                    PrintLastError("CryptDecodeObject(Extension)");
                    goto ErrorReturn;
                }
#else
                {
                    void *pvExt;
                    if (!CryptDecodeObjectEx(
                            X509_ASN_ENCODING,
                            pExt->pszObjId,
                            pExt->Value.pbData,
                            pExt->Value.cbData,
                            CRYPT_DECODE_ALLOC_FLAG |
                                CRYPT_DECODE_NOCOPY_FLAG |
                                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                            NULL,
                            (void *) &pvExt,
                            &cbExt
                            )) {
                        PrintLastError("CryptDecodeObjectEx(Extension)");
                        goto ErrorReturn;
                    } else
                        LocalFree(pvExt);
                }
#endif


                break;

            case WVT_CERT_TEST_ID:
                if (0 == i) {
                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }
                    pwvtActionID = &wvtCertActionID;
                    wvtData.dwUnionChoice = WTD_CHOICE_CERT;
                    wvtData.pCert = &wvtCertInfo;
                    wvtData.pPolicyCallbackData = (void *) pszUsageOID;
                    if (NULL == (wvtCertInfo.psCertContext = (CERT_CONTEXT *)
                            ReadCert(rgpszName[CERT_FILENAME_INDEX])))
                        goto ErrorReturn;

                    if (STORE_FILENAME_INDEX < dwNameCnt) {
                        if (NULL == (hAdditionalStore =
                            OpenSystemStoreOrFile(
                                FALSE,              // fSystemStore
                                rgpszName[STORE_FILENAME_INDEX],
                                0                   // dwFlags
                                )))
                            goto BadUsage;
                        wvtCertInfo.chStores = 1;
                    }
                }

                lStatus = WinVerifyTrust(
                    NULL,               // hwnd
                    pwvtActionID,
                    &wvtData
                    );
                if (0 == i) {
                    lFirstStatus = lStatus;
                    printf("WinVerifyTrust returned => 0x%x\n", lStatus);
                } else {
                    if (lStatus != lFirstStatus) {
                        printf("WinVerifyTrust failed => 0x%x\n", lStatus);
                        goto ErrorReturn;
                    }
                }
                break;

            case WVT_FILE_TEST_ID:
                if (0 == i) {
                    if (WVT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing WVT filename\n");
                        goto BadUsage;
                    }
                    pwvtActionID = &wvtFileActionID;
                    wvtData.dwUnionChoice = WTD_CHOICE_FILE;
                    wvtData.pFile = &wvtFileInfo;
                    wvtFileInfo.pcwszFilePath = AllocAndSzToWsz(
                        rgpszName[WVT_FILENAME_INDEX]);
                }

                lStatus = WinVerifyTrust(
                    NULL,               // hwnd
                    pwvtActionID,
                    &wvtData
                    );
                if (0 == i) {
                    lFirstStatus = lStatus;
                    printf("WinVerifyTrust returned => 0x%x\n", lStatus);
                } else {
                    if (lStatus != lFirstStatus) {
                        printf("WinVerifyTrust failed => 0x%x\n", lStatus);
                        goto ErrorReturn;
                    }
                }
                break;

            case WVT_CAT_TEST_ID:
                if (0 == i) {
                    if (WVT_MEMBER_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing WVT member filename\n");
                        goto BadUsage;
                    }
                    pwvtActionID = &wvtDriverActionID;

                    wvtData.dwUnionChoice = WTD_CHOICE_CATALOG;
                    wvtData.pCatalog = &wvtCat;

                    wvtCat.pcwszCatalogFilePath = AllocAndSzToWsz(
                        rgpszName[WVT_CAT_FILENAME_INDEX]);
                    wvtCat.pcwszMemberTag = L"foo";
                    wvtCat.pcwszMemberFilePath = AllocAndSzToWsz(
                        rgpszName[WVT_MEMBER_FILENAME_INDEX]);
                    wvtCat.hMemberFile = CreateFileU(
                        wvtCat.pcwszMemberFilePath,
                        GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);

                    cbCatHash  = sizeof(rgbCatHash);
                    if (!(CryptCATAdminCalcHashFromFileHandle(
                            wvtCat.hMemberFile, &cbCatHash, rgbCatHash, 0))) {
                        PrintLastError("CryptCATAdminCalcHashFromFileHandle");
                        goto ErrorReturn;
                    }

                    wvtCat.pbCalculatedFileHash = rgbCatHash;
                    wvtCat.cbCalculatedFileHash = cbCatHash;
                }

                lStatus = WinVerifyTrust(
                    NULL,               // hwnd
                    pwvtActionID,
                    &wvtData
                    );
                if (0 == i) {
                    lFirstStatus = lStatus;
                    printf("WinVerifyTrust returned => 0x%x\n", lStatus);
                } else {
                    if (lStatus != lFirstStatus) {
                        printf("WinVerifyTrust failed => 0x%x\n", lStatus);
                        goto ErrorReturn;
                    }
                }
                break;

            case CERT_CHAIN_TEST_ID:
                if (0 == i) {
                    if (CERT_FILENAME_INDEX >= dwNameCnt) {
                        printf("missing cert filename\n");
                        goto BadUsage;
                    }
                    if (NULL == (pCert =
                            ReadCert(rgpszName[CERT_FILENAME_INDEX])))
                        goto ErrorReturn;

                    if (STORE_FILENAME_INDEX < dwNameCnt) {
                        if (NULL == (hAdditionalStore =
                            OpenSystemStoreOrFile(
                                FALSE,              // fSystemStore
                                rgpszName[STORE_FILENAME_INDEX],
                                0                   // dwFlags
                                )))
                            goto BadUsage;
                    }

                    if (pszUsageOID) {
                        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
                        ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
                        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier =
                            &pszUsageOID;
                    }
                }

                if (!CertGetCertificateChain(
                        NULL,                   // hChainEngine
                        pCert,
                        NULL,                   // pTime
                        hAdditionalStore,
                        &ChainPara,
                        dwCreateChainFlags,
                        NULL,                   // pvReserved
                        &pChainContext
                        )) {
                    PrintLastError("CertGetCertificateChain");
                    goto ErrorReturn;
                }
                if (!CertVerifyCertificateChainPolicy(
                        pszChainPolicyOID,
                        pChainContext,
                        &ChainPolicyPara,
                        &ChainPolicyStatus
                        )) {
                    PrintLastError("CertVerifyCertificateChainPolicy");
                    goto ErrorReturn;
                }

                if (0 == i) {
                    dwFirstError = ChainPolicyStatus.dwError;
                    printf("Chain Policy returned => 0x%x\n", dwFirstError);
                    if (dwFirstError)
                        printf("Chain Index: %d Element Index: %d\n",
                            ChainPolicyStatus.lChainIndex,
                            ChainPolicyStatus.lElementIndex
                            );
                } else {
                    dwError = ChainPolicyStatus.dwError;
                    if (dwError != dwFirstError) {
                        printf("Chain Policy failed => 0x%x\n", dwError);
                        goto ErrorReturn;
                    }
                }

                if (pChainContext) {
                    CertFreeCertificateChain(pChainContext);
                    pChainContext = NULL;
                }
                break;

            default:
                printf("unknown test name\n");
                goto BadUsage;
        }
    }

    GetSystemTime(&stEnd);
    SystemTimeToFileTime(&stFirst, &ftFirst);
    SystemTimeToFileTime(&stStart, &ftStart);
    SystemTimeToFileTime(&stEnd, &ftEnd);

    DeltaTime = *((_int64 *) &ftStart) - *((_int64 *) &ftFirst);
    Microseconds = (int) (DeltaTime / 10);
    Milliseconds = (int) (DeltaTime / 10000);
    Seconds = (int) (DeltaTime / 10000000);
    printf("First Micro: %d Milli: %d Seconds: %d\n",
        Microseconds, Milliseconds, Seconds);

    DeltaTime = *((_int64 *) &ftEnd) - *((_int64 *) &ftStart);
    Microseconds = (int) (DeltaTime / 10);
    Milliseconds = (int) (DeltaTime / 10000);
    Seconds = (int) (DeltaTime / 10000000);
    printf("Total Micro: %d Milli: %d Seconds: %d\n",
        Microseconds, Milliseconds, Seconds);

    DeltaTime = DeltaTime / dwIterations;
    Microseconds = (int) (DeltaTime / 10);
    Milliseconds = (int) (DeltaTime / 10000);
    Seconds = (int) (DeltaTime / 10000000);
    printf("Average Micro: %d Milli: %d Seconds: %d\n",
        Microseconds, Milliseconds, Seconds);

    


    status = 0;
CommonReturn:
    CertFreeCertificateContext(pCert);
    CertFreeCertificateContext(pIssuer);
    CertFreeCTLContext(pCtl);
    CertFreeCRLContext(pCrl);
    CryptMsgClose(hMsg);
    TestFree(pbEncodedCert);
    TestFree(pbEncoded);

    CertFreeCertificateContext(wvtCertInfo.psCertContext);
    TestFree((LPWSTR) wvtFileInfo.pcwszFilePath);
    if (hAdditionalStore) {
        if (!CertCloseStore(hAdditionalStore, CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore(AdditionalStore)");
    }

    if (pChainContext)
        CertFreeCertificateChain(pChainContext);

    TestFree(const_cast<LPWSTR>(wvtCat.pcwszCatalogFilePath));
    TestFree(const_cast<LPWSTR>(wvtCat.pcwszMemberFilePath));
    if (!(NULL == wvtCat.hMemberFile ||
            INVALID_HANDLE_VALUE == wvtCat.hMemberFile))
        CloseHandle(wvtCat.hMemberFile);

    if (fPause) {
        int c;
        fputs("Waiting to exit ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();
    }

    return status;

ErrorReturn:
    status = -1;
    goto CommonReturn;

BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tcopycer\tcopycer.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tcopycer.cpp
//
//  Contents:   Cert Store Copy Cert/CRL/CTL context API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    11-Apr-96   philh   created
//				07-Jun-96   HelleS	Added printing the command line
//									and Failed or Passed at the end.
//              20-Aug-96   jeffspel name changes
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf("Usage: tcopycer [options] <Src StoreName> <Dst StoreName>\n");
    printf("Options are:\n");
    printf("  -h                - This message\n");
    printf("  -s                - Dst \"StoreName\" System store\n");
    printf("  -7                - PKCS# 7 save for Dst if filename\n");
    printf("  -S                - Src \"StoreName\" System store\n");
    printf("  -R                - Replace certs that exist\n");
    printf("  -I                - Replace certs with property inheritance\n");
    printf("  -A                - Always add a new cert\n");
    printf("  -b<number>        - Add Base CRL having specified number\n");
    printf("  -f<number>        - Add Freshest CRL having specified number\n");
    printf("  -a[<ValueString>] - Only certs matching name attribute value\n");
    printf("\n");
    printf("-b and/or -f only copy the CRL having the specified number\n");
    printf("-b and/or -f delete all CRLs unless -A is also specified\n");
    printf("\n");
}

static void DisplayFindAttr(DWORD cRDNAttr, CERT_RDN_ATTR rgRDNAttr[])
{
    DWORD i;

    for (i = 0; i < cRDNAttr; i++) {
        LPSTR pszObjId = rgRDNAttr[i].pszObjId;
        LPSTR pszValue = (LPSTR) rgRDNAttr[i].Value.pbData;
        printf("  [%d] ", i);
        if (pszObjId)
            printf("%s ", pszObjId);
        if (rgRDNAttr[i].dwValueType)
            printf("ValueType: %d ", rgRDNAttr[i].dwValueType);
        if (pszValue == NULL)
            pszValue = "<NONE>";
        printf("Value: %s\n", pszValue);
    }
}

int _cdecl main(int argc, char * argv[])
{
    int ReturnStatus = 0;
    BOOL fSrcSystemStore = FALSE;
    BOOL fDstSystemStore = FALSE;
    LPSTR pszSrcStoreFilename = NULL;
    LPSTR pszDstStoreFilename = NULL;

    BOOL fPKCS7Save = FALSE;
    DWORD dwAddDisposition = CERT_STORE_ADD_USE_EXISTING;

    HANDLE hSrcStore = NULL;
    HANDLE hDstStore = NULL;

#define MAX_RDN_ATTR 20
    DWORD cRDNAttr = 0;
    CERT_RDN_ATTR rgRDNAttr[MAX_RDN_ATTR + 1];
    memset (rgRDNAttr, 0, sizeof(rgRDNAttr));
    CERT_RDN NameRDN;

    BOOL fBaseOrFreshestCrl = FALSE;
    int iBaseCrl = -1;
    int iFreshestCrl = -1;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 's':
                fDstSystemStore = TRUE;
                break;
            case '7':
                fPKCS7Save = TRUE;
                break;
            case 'S':
                fSrcSystemStore = TRUE;
                break;
            case 'R':
                dwAddDisposition = CERT_STORE_ADD_REPLACE_EXISTING;
                break;
            case 'A':
                dwAddDisposition = CERT_STORE_ADD_ALWAYS;
                break;
            case 'I':
                dwAddDisposition =
                    CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES;
                break;
            case 'a':
                if (cRDNAttr >= MAX_RDN_ATTR) {
                    printf("Maximum number of attributes: %d\n", MAX_RDN_ATTR);
                    Usage();
                    return -1;
                }
                rgRDNAttr[cRDNAttr].Value.cbData = strlen(argv[0] + 2);
                if (rgRDNAttr[cRDNAttr].Value.cbData == 0)
                    rgRDNAttr[cRDNAttr].Value.pbData = NULL;
                else
                    rgRDNAttr[cRDNAttr].Value.pbData = (BYTE *) (argv[0] + 2);
                cRDNAttr++;
                break;
            case 'b':
                iBaseCrl = atoi(argv[0]+2);
                fBaseOrFreshestCrl = TRUE;
                break;
            case 'f':
                iFreshestCrl = atoi(argv[0]+2);
                fBaseOrFreshestCrl = TRUE;
                break;
            case 'h':
            default:
            	goto BadUsage;

            }
        } else {
            if (pszSrcStoreFilename == NULL)
                pszSrcStoreFilename = argv[0];
            else if (pszDstStoreFilename == NULL)
                pszDstStoreFilename = argv[0];
            else {
                printf("too many store filenames\n");
            	goto BadUsage;
            }
        }
    }


    if (pszDstStoreFilename == NULL) {
        printf("missing store filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    // Attempt to open the source and destination stores
    hSrcStore = OpenStore(fSrcSystemStore, pszSrcStoreFilename);
    if (hSrcStore == NULL)
        goto ErrorReturn;
    hDstStore = OpenStore(fDstSystemStore, pszDstStoreFilename);
    if (hDstStore == NULL) {
        if (!CertCloseStore(hSrcStore, 0))
            PrintLastError("CertCloseStore");
        goto ErrorReturn;
    }

    if (cRDNAttr) {
        printf("Copy certs matching attribute values::\n");
        DisplayFindAttr(cRDNAttr, rgRDNAttr);
        NameRDN.cRDNAttr = cRDNAttr;
        NameRDN.rgRDNAttr = rgRDNAttr;
    }

    if (!fBaseOrFreshestCrl)
    {
        DWORD dwCopyCnt = 0;
        PCCERT_CONTEXT pCert = NULL;
        int i = 0;

        while (TRUE) {
            BOOL fResult;

            if (cRDNAttr) {
                pCert = CertFindCertificateInStore(
                    hSrcStore,
                    dwCertEncodingType,
                    0,                          // dwFindFlags,
                    CERT_FIND_SUBJECT_ATTR,
                    &NameRDN,
                    pCert
                    );
                if (pCert) {
                    printf("=====  Copy Cert %d  =====\n", i++);
                    DisplayCert(pCert, DISPLAY_BRIEF_FLAG);
                }
            } else
                pCert = CertEnumCertificatesInStore(
                    hSrcStore,
                    pCert
                    );
            if (pCert == NULL)
                break;
            if (!(fResult = CertAddCertificateContextToStore(
                    hDstStore,
                    pCert,
                    CERT_STORE_ADD_NEW,
                    NULL))) {
                if (GetLastError() == CRYPT_E_EXISTS) {
                    printf("Cert %d already exists in store\n", dwCopyCnt);

                    DWORD dwNewer;

                    if (dwAddDisposition == CERT_STORE_ADD_REPLACE_EXISTING)
                        dwNewer = CERT_STORE_ADD_NEWER;
                    else if (dwAddDisposition ==
                            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES)
                        dwNewer = CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES;
                    else
                        dwNewer = 0;

                    fResult = FALSE;
                    if (dwNewer) {
                        fResult = CertAddCertificateContextToStore(
                            hDstStore,
                            pCert,
                            dwNewer,
                            NULL);
                        if (fResult)
                            printf("Added newer cert\n");
                        else {
                            DWORD dwErr = GetLastError();
                            if (dwErr == CRYPT_E_EXISTS)
                                printf("Didn't add older cert\n");
                            else
                                PrintLastError("Cert: CERT_ADD_NEWER");
                        }
                    }


                    if (!fResult)
                        fResult = CertAddCertificateContextToStore(
                            hDstStore,
                            pCert,
                            dwAddDisposition,
                            NULL);
                }
            }
            if (!fResult) {
                PrintLastError("CertAddCertificateContextToStore");
                ReturnStatus = -1;
                CertFreeCertificateContext(pCert);
                break;
            } else {
                dwCopyCnt++;

            }

        }
        printf("Copied %d certificates\n", dwCopyCnt);

    }

    if (fBaseOrFreshestCrl) {
        DWORD fCopyCrl = FALSE;
        PCCRL_CONTEXT pCrl;

        if (dwAddDisposition != CERT_STORE_ADD_ALWAYS) {
            // Delete all existing CRLs from the destination store

            pCrl = NULL;
            while (pCrl = CertEnumCRLsInStore(hDstStore, pCrl)) {
                PCCRL_CONTEXT pDeleteCrl = CertDuplicateCRLContext(pCrl);
                if (!CertDeleteCRLFromStore(pDeleteCrl))
                    PrintLastError("CertDeleteCRLFromStore");
            }
        }

        pCrl = NULL;
        while (pCrl = CertEnumCRLsInStore(hSrcStore, pCrl)) {
            PCERT_EXTENSION pDeltaExt;
            PCERT_EXTENSION pBaseExt;
            DWORD cbInt;
            int iNum;

            pDeltaExt = CertFindExtension(
                szOID_DELTA_CRL_INDICATOR,
                pCrl->pCrlInfo->cExtension,
                pCrl->pCrlInfo->rgExtension
                );
            pBaseExt = CertFindExtension(
                szOID_CRL_NUMBER,
                pCrl->pCrlInfo->cExtension,
                pCrl->pCrlInfo->rgExtension
                );
            if (pDeltaExt) {
                // Freshest, delta CRL
                if (0 <= iFreshestCrl) {
                    cbInt = sizeof(iNum);
                    if (!CryptDecodeObject(
                            pCrl->dwCertEncodingType,
                            X509_INTEGER,
                            pDeltaExt->Value.pbData,
                            pDeltaExt->Value.cbData,
                            0,                      // dwFlags
                            &iNum,
                            &cbInt
                            ))
                        PrintLastError("CryptDecodeObject(DeltaCrlNumber)");
                    else if (iFreshestCrl == iNum) {
                        if (CertAddCRLContextToStore(
                                hDstStore,
                                pCrl,
                                CERT_STORE_ADD_ALWAYS,
                                NULL
                                )) {
                            printf("Added freshest CRL %d\n", iNum);
                            fCopyCrl = TRUE;
                        } else
                            PrintLastError("CertAddCRLContextToStore(Freshest)");
                    }
                }
            } else if (pBaseExt) {
                // Base CRL
                if (0 <= iBaseCrl) {
                    cbInt = sizeof(iNum);
                    if (!CryptDecodeObject(
                            pCrl->dwCertEncodingType,
                            X509_INTEGER,
                            pBaseExt->Value.pbData,
                            pBaseExt->Value.cbData,
                            0,                      // dwFlags
                            &iNum,
                            &cbInt
                            ))
                        PrintLastError("CryptDecodeObject(BaseCrlNumber)");
                    else if (iBaseCrl == iNum) {
                        if (CertAddCRLContextToStore(
                                hDstStore,
                                pCrl,
                                CERT_STORE_ADD_ALWAYS,
                                NULL
                                )) {
                            printf("Added base CRL %d\n", iNum);
                            fCopyCrl = TRUE;
                        } else
                            PrintLastError("CertAddCRLContextToStore(Base)");
                    }
                }
            }
        }

        if (!fCopyCrl)
            printf("failed => no base or freshest, delta CRLs copied\n");

    } else if (cRDNAttr == 0) {
        DWORD dwCopyCnt;
        PCCRL_CONTEXT pCrl = NULL;
        PCCTL_CONTEXT pCtl = NULL;
        DWORD dwFlags;

        dwCopyCnt = 0;
        while (TRUE) {
            BOOL fResult;

            dwFlags = 0;
            pCrl = CertGetCRLFromStore(
                hSrcStore,
                NULL,   // pIssuerContext
                pCrl,
                &dwFlags);
            if (pCrl == NULL)
                break;
            if (!(fResult = CertAddCRLContextToStore(
                    hDstStore,
                    pCrl,
                    CERT_STORE_ADD_NEW,
                    NULL))) {
                if (GetLastError() == CRYPT_E_EXISTS) {
                    printf("CRL %d already exists in store\n", dwCopyCnt);

                    DWORD dwNewer;

                    if (dwAddDisposition == CERT_STORE_ADD_REPLACE_EXISTING)
                        dwNewer = CERT_STORE_ADD_NEWER;
                    else if (dwAddDisposition ==
                            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES)
                        dwNewer = CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES;
                    else
                        dwNewer = 0;

                    fResult = FALSE;
                    if (dwNewer) {
                        fResult = CertAddCRLContextToStore(
                            hDstStore,
                            pCrl,
                            dwNewer,
                            NULL);
                        if (fResult)
                            printf("Added newer CRL\n");
                        else {
                            DWORD dwErr = GetLastError();
                            if (dwErr == CRYPT_E_EXISTS)
                                printf("Didn't add older CRL\n");
                            else
                                PrintLastError("CRL: CERT_ADD_NEWER");
                        }
                    }

                    if (!fResult)
                        fResult = CertAddCRLContextToStore(
                            hDstStore,
                            pCrl,
                            dwAddDisposition,
                            NULL);
                }
            }
            if (!fResult) {
                PrintLastError("CertAddCRLContextToStore");
                ReturnStatus = -1;
                CertFreeCRLContext(pCrl);
                break;
            } else
                dwCopyCnt++;

        }
        printf("Copied %d CRLs\n", dwCopyCnt);

        dwCopyCnt = 0;
        while (TRUE) {
            BOOL fResult;

            dwFlags = 0;
            pCtl = CertEnumCTLsInStore(
                hSrcStore,
                pCtl
                );
            if (pCtl == NULL)
                break;
            if (!(fResult = CertAddCTLContextToStore(
                    hDstStore,
                    pCtl,
                    CERT_STORE_ADD_NEW,
                    NULL))) {
                if (GetLastError() == CRYPT_E_EXISTS) {
                    printf("CTL %d already exists in store\n", dwCopyCnt);

                    DWORD dwNewer;

                    if (dwAddDisposition == CERT_STORE_ADD_REPLACE_EXISTING)
                        dwNewer = CERT_STORE_ADD_NEWER;
                    else if (dwAddDisposition ==
                            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES)
                        dwNewer = CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES;
                    else
                        dwNewer = 0;

                    fResult = FALSE;
                    if (dwNewer) {
                        fResult = CertAddCTLContextToStore(
                            hDstStore,
                            pCtl,
                            dwNewer,
                            NULL);
                        if (fResult)
                            printf("Added newer CTL\n");
                        else {
                            DWORD dwErr = GetLastError();
                            if (dwErr == CRYPT_E_EXISTS)
                                printf("Didn't add older CTL\n");
                            else
                                PrintLastError("CTL: CERT_ADD_NEWER");
                        }
                    }

                    if (!fResult)
                        fResult = CertAddCTLContextToStore(
                            hDstStore,
                            pCtl,
                            dwAddDisposition,
                            NULL);
                }
            }
            if (!fResult) {
                PrintLastError("CertAddCTLContextToStore");
                ReturnStatus = -1;
                CertFreeCTLContext(pCtl);
                break;
            } else
                dwCopyCnt++;

        }
        printf("Copied %d CTLs\n", dwCopyCnt);

    }

    if (!fDstSystemStore)
        SaveStoreEx(hDstStore, fPKCS7Save, pszDstStoreFilename);

    if (!CertCloseStore(hSrcStore, 0))
    {
        PrintLastError("CertCloseStore(hSrcStore)");
        ReturnStatus = -1;
	}
    if (!CertCloseStore(hDstStore, 0))
    {
    
        PrintLastError("CertCloseStore(hDstStore)");
        ReturnStatus = -1;
	}
	if (-1 == ReturnStatus)
		goto ErrorReturn;
    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tcertpro\tcertpro.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tcertpro.cpp
//
//  Contents:   Cert Protection Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    30-Nov-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "unicode.h"
#include "certprot.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static void PrintLastError(LPCSTR pszMsg, LONG lErr)
{
    printf("  %s failed => 0x%x (%d) \n", pszMsg, lErr, lErr);
}

static void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("  %s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

static
BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCSTR Privilege,       // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValueA( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

static
BOOL
SetCurrentPrivilege(
    LPCSTR Privilege,       // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if(OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            ))
    {

        if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;

        CloseHandle(hToken);
    }

    return bSuccess;
}


static void Usage(void)
{
    printf("Usage: tcertpro [options] <TestName> <RegPath>\n");
    printf("Options are:\n");
    printf("  -h                  - This message\n");
//    printf("  -r                - Recurse subkeys\n");
    printf("  -lCU                - CurrentUser (default)\n");
    printf("  -lLM                - LocalMachine\n");
    printf("TestNames (case insensitive):\n");
    printf("  GetKey              - Get Registry Key Security Information\n");
    printf("  SetKey              - Set Registry Key Security Information\n");
    printf("  PurgeLMRoots        - Purge LocalMachine Roots From CurrentUser\n");
    printf("  DeleteUnknownRoots  - Delete Unknown Roots From Protected List\n");
    printf("  CheckProtectedRoots - Check ProtectedRoots ACLs\n");
    printf("  ServiceUI           - Cert protect service UI\n");
    printf("  ServiceTokenInfo    - Get Cert protect service token info\n");
    printf("  ServiceInvalid      - Invalid Cert protect function\n");
    printf("\n");
}

#if 0
#define OWNER_SECURITY_INFORMATION       (0X00000001L)
#define GROUP_SECURITY_INFORMATION       (0X00000002L)
#define DACL_SECURITY_INFORMATION        (0X00000004L)
#define SACL_SECURITY_INFORMATION        (0X00000008L)
#endif


static PSECURITY_DESCRIPTOR AllocAndGetSecurityDescriptor(
    IN HKEY hKey,
    SECURITY_INFORMATION SecInf
    )
{
    LONG err;
    PSECURITY_DESCRIPTOR psd = NULL;
    DWORD cbsd = 0;

    err = RegGetKeySecurity(
            hKey,
            SecInf,
            NULL,                   // psd
            &cbsd
            );
    if (!(ERROR_SUCCESS == err || ERROR_INSUFFICIENT_BUFFER == err)) {
        PrintLastError("RegGetKeySecurity", err);
        return NULL;
    }
    if (0 == cbsd)
        return NULL;

    if (NULL == (psd = (PSECURITY_DESCRIPTOR) TestAlloc(cbsd)))
        return NULL;

    if (ERROR_SUCCESS != (err = RegGetKeySecurity(
            hKey,
            SecInf,
            psd,
            &cbsd
            ))) {
        PrintLastError("RegGetKeySecurity", err);
        TestFree(psd);
    }
    return psd;
}

#if 0
#define SE_OWNER_DEFAULTED               (0x0001)
#define SE_GROUP_DEFAULTED               (0x0002)
#define SE_DACL_PRESENT                  (0x0004)
#define SE_DACL_DEFAULTED                (0x0008)
#define SE_SACL_PRESENT                  (0x0010)
#define SE_SACL_DEFAULTED                (0x0020)
#define SE_DACL_AUTO_INHERIT_REQ         (0x0100)
#define SE_SACL_AUTO_INHERIT_REQ         (0x0200)
#define SE_DACL_AUTO_INHERITED           (0x0400)
#define SE_SACL_AUTO_INHERITED           (0x0800)
#define SE_DACL_PROTECTED                (0x1000)
#define SE_SACL_PROTECTED                (0x2000)
#define SE_SELF_RELATIVE                 (0x8000)
#endif

//
//  Where:
//
//      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
//          SID pointed to by the Owner field was provided by a
//          defaulting mechanism rather than explicitly provided by the
//          original provider of the security descriptor.  This may
//          affect the treatment of the SID with respect to inheritence
//          of an owner.
//
//      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
//          SID in the Group field was provided by a defaulting mechanism
//          rather than explicitly provided by the original provider of
//          the security descriptor.  This may affect the treatment of
//          the SID with respect to inheritence of a primary group.
//
//      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
//          security descriptor contains a discretionary ACL.  If this
//          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
//          null, then a null ACL is explicitly being specified.
//
//      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Dacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the DaclPresent flag is not set.
//
//      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
//          security descriptor contains a system ACL pointed to by the
//          Sacl field.  If this flag is set and the Sacl field of the
//          SECURITY_DESCRIPTOR is null, then an empty (but present)
//          ACL is being specified.
//
//      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Sacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the SaclPresent flag is not set.
//
//      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
//          security descriptor is in self-relative form.  In this form,
//          all fields of the security descriptor are contiguous in memory
//          and all pointer fields are expressed as offsets from the
//          beginning of the security descriptor.  This form is useful
//          for treating security descriptors as opaque data structures
//          for transmission in communication protocol or for storage on
//          secondary media.
//

#if 0
typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown
} SID_NAME_USE, *PSID_NAME_USE;
#endif

static void DisplayControl(
    PSECURITY_DESCRIPTOR psd
    )
{
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwRevision;

    if (!GetSecurityDescriptorControl(psd, &sdc, &dwRevision))
        PrintLastError("GetSecurityDescriptorControl");
    else {
        printf("  Control: 0x%x", sdc);
        if (sdc & SE_OWNER_DEFAULTED)
            printf(" OWNER_DEFAULTED");
        if (sdc & SE_GROUP_DEFAULTED)
            printf(" GROUP_DEFAULTED");
        if (sdc & SE_DACL_PRESENT)
            printf(" DACL_PRESENT");
        if (sdc & SE_DACL_DEFAULTED)
            printf(" DACL_DEFAULTED");
        if (sdc & SE_SACL_PRESENT)
            printf(" SACL_PRESENT");
        if (sdc & SE_SACL_DEFAULTED)
            printf(" SACL_DEFAULTED");
        if (sdc & SE_DACL_AUTO_INHERIT_REQ)
            printf(" DACL_AUTO_INHERIT_REQ");
        if (sdc & SE_SACL_AUTO_INHERIT_REQ)
            printf(" SACL_AUTO_INHERIT_REQ");
        if (sdc & SE_DACL_AUTO_INHERITED)
            printf(" DACL_AUTO_INHERITED");
        if (sdc & SE_SACL_AUTO_INHERITED)
            printf(" SACL_AUTO_INHERITED");
        if (sdc & SE_DACL_PROTECTED)
            printf(" DACL_PROTECTED");
        if (sdc & SE_SACL_PROTECTED)
            printf(" SACL_PROTECTED");
        if (sdc & SE_SELF_RELATIVE)
            printf(" SELF_RELATIVE");
        printf("\n");
        printf("  Revision: %d\n", dwRevision);
    }
}

static void DisplaySid(
    PSID pSid
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;

    char szAccount[_MAX_PATH];
    DWORD cchAccount;
    char szDomain[_MAX_PATH];
    DWORD cchDomain;
    SID_NAME_USE snu;

    if (!IsValidSid(pSid)) {
        printf("Invalid SID\n");
        return;
    }

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // prepare S-SID_REVISION-
    //
    printf("S-%lu-", SID_REVISION);

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        printf("0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        printf("%lu",
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for (dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        printf("-%lu", *GetSidSubAuthority(pSid, dwCounter) );
    }


    cchAccount = sizeof(szAccount) - 1;
    memset(szAccount, 0, sizeof(szAccount));
    cchDomain = sizeof(szDomain) - 1;
    memset(szDomain, 0, sizeof(szDomain));
    snu = (SID_NAME_USE) 0;
    if (LookupAccountSidA(
            NULL,               // lpSystemName
            pSid,
            szAccount,
            &cchAccount,
            szDomain,
            &cchDomain,
            &snu
            ))
        printf("  Account: %s Domain: %s SNU: %d", szAccount, szDomain, snu);
    printf("\n");

}

static void DisplayOwnerSecurityInfo(
    IN PSECURITY_DESCRIPTOR psd
    )
{
    PSID pSid = NULL;
    BOOL fOwnerDefaulted;

    if (!GetSecurityDescriptorOwner(psd, &pSid, &fOwnerDefaulted)) {
        PrintLastError("GetSecurityDescriptorOwner");
        return;
    }

    if (NULL == pSid)
        printf("  NO OWNER\n");
    else {
        printf("  Owner: ");
        DisplaySid(pSid);
        if (fOwnerDefaulted)
            printf("  Owner Defaulted\n");
    }
}

static void DisplayGroupSecurityInfo(
    IN PSECURITY_DESCRIPTOR psd
    )
{
    PSID pSid = NULL;
    BOOL fGroupDefaulted;

    if (!GetSecurityDescriptorGroup(psd, &pSid, &fGroupDefaulted)) {
        PrintLastError("GetSecurityDescriptorGroup");
        return;
    }

    if (NULL == pSid)
        printf("  NO Group\n");
    else {
        printf("  Group: ");
        DisplaySid(pSid);
        if (fGroupDefaulted)
            printf("  Group Defaulted\n");
    }

}

            

static LPCSTR GetAceTypeString(
    IN BYTE AceType
    )
{
    switch (AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            return "ACCESS_ALLOWED";
            break;
        case ACCESS_DENIED_ACE_TYPE:
            return "ACCESS_DENIED_ACE_TYPE";
            break;
        case SYSTEM_AUDIT_ACE_TYPE:
            return "SYSTEM_AUDIT_ACE_TYPE";
            break;
        case SYSTEM_ALARM_ACE_TYPE:
            return "SYSTEM_ALARM_ACE_TYPE";
            break;
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
            return "ACCESS_ALLOWED_COMPOUND_ACE_TYPE";
            break;
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            return "ACCESS_ALLOWED_OBJECT_ACE_TYPE";
            break;
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
            return "ACCESS_DENIED_OBJECT_ACE_TYPE";
            break;
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            return "SYSTEM_AUDIT_OBJECT_ACE_TYPE";
            break;
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            return "SYSTEM_ALARM_OBJECT_ACE_TYPE";
            break;
        default:
            return "???";
    }
    
}

static void DisplayAceFlags(
    IN BYTE AceFlags
    )
{
    if (AceFlags & OBJECT_INHERIT_ACE)
        printf(" OBJECT_INHERIT");
    if (AceFlags & CONTAINER_INHERIT_ACE)
        printf(" CONTAINER_INHERIT");
    if (AceFlags & NO_PROPAGATE_INHERIT_ACE)
        printf(" NO_PROPAGATE_INHERIT");
    if (AceFlags & INHERIT_ONLY_ACE)
        printf(" INHERIT_ONLY");
    if (AceFlags & INHERITED_ACE)
        printf(" INHERITED");
    if (AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
        printf(" SUCCESSFUL_ACCESS");
    if (AceFlags & FAILED_ACCESS_ACE_FLAG)
        printf(" FAILED_ACCESS");
}

static void DisplayAccessMask(
    IN ACCESS_MASK Mask
    )
{
    if (Mask & SYNCHRONIZE)
        printf(" SYNCHRONIZE");
    if (Mask & ACCESS_SYSTEM_SECURITY)
        printf(" ACCESS_SYSTEM_SECURITY");
    if (Mask & MAXIMUM_ALLOWED)
        printf(" MAXIMUM_ALLOWED");
    if (Mask & GENERIC_READ)
        printf(" GENERIC_READ");
    if (Mask & GENERIC_WRITE)
        printf(" GENERIC_WRITE");
    if (Mask & GENERIC_EXECUTE)
        printf(" GENERIC_EXECUTE");
    if (Mask & GENERIC_ALL)
        printf(" GENERIC_ALL");

    if (KEY_ALL_ACCESS == (Mask & KEY_ALL_ACCESS)) {
        printf(" KEY_ALL_ACCESS");
        return;
    }

    if (KEY_READ == (Mask & KEY_READ))
        printf(" KEY_READ");
    if (KEY_WRITE == (Mask & KEY_WRITE))
        printf(" KEY_WRITE");
    if (KEY_EXECUTE == (Mask & KEY_EXECUTE))
        printf(" KEY_EXECUTE");

    if (Mask & DELETE)
        printf(" DELETE");
    if (Mask & READ_CONTROL)
        printf(" READ_CONTROL");
    if (Mask & WRITE_DAC)
        printf(" WRITE_DAC");
    if (Mask & WRITE_OWNER)
        printf(" WRITE_OWNER");


    if (Mask & KEY_QUERY_VALUE)
        printf(" KEY_QUERY_VALUE");
    if (Mask & KEY_SET_VALUE)
        printf(" KEY_SET_VALUE");
    if (Mask & KEY_CREATE_SUB_KEY)
        printf(" KEY_CREATE_SUB_KEY");
    if (Mask & KEY_ENUMERATE_SUB_KEYS)
        printf(" KEY_ENUMERATE_SUB_KEYS");
    if (Mask & KEY_NOTIFY)
        printf(" KEY_NOTIFY");
    if (Mask & KEY_CREATE_LINK)
        printf(" KEY_CREATE_LINK");
}

static void DisplayAcl(
    IN BOOL fDaclPresent,
    IN PACL pAcl,
    IN BOOL fDaclDefaulted
    )
{
    DWORD dwAceIndex;

    if (!fDaclPresent) {
        printf("  NO ACL\n");
        return;
    }

    if (NULL == pAcl) {
        printf("  NULL ACL\n");
        return;
    }

    printf("  AclRevision: %d", pAcl->AclRevision);
    if (fDaclDefaulted)
        printf(" Defaulted ACL");
    printf("\n");

    for (dwAceIndex = 0; dwAceIndex < pAcl->AceCount; dwAceIndex++) {
        PACE_HEADER pAceHdr;
        PACCESS_ALLOWED_ACE pAce;
        if (!GetAce(pAcl, dwAceIndex, (void **) &pAceHdr)) {
            PrintLastError("GetAce");
            return;
        }

        printf("  Ace[%d]\n", dwAceIndex);
        printf("   Type: 0x%x %s\n", pAceHdr->AceType,
            GetAceTypeString(pAceHdr->AceType));
        printf("   Flags: 0x%x ", pAceHdr->AceFlags);
        DisplayAceFlags(pAceHdr->AceFlags);
        printf("\n");
        switch (pAceHdr->AceType) {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
            case SYSTEM_ALARM_ACE_TYPE:
                pAce = (PACCESS_ALLOWED_ACE) pAceHdr;
                printf("   Mask: 0x%x", pAce->Mask);
                DisplayAccessMask(pAce->Mask);
                printf("\n");
                printf("   SID: ");
                DisplaySid((PSID) &pAce->SidStart);
                break;
            default:
                break;
        }
    }
}

static void DisplayDaclSecurityInfo(
    IN PSECURITY_DESCRIPTOR psd
    )
{
    BOOL fDaclPresent;
    PACL pAcl;
    BOOL fDaclDefaulted;
    DWORD dwAceIndex;

    printf("  ---  DACLs  ---\n");
    if (!GetSecurityDescriptorDacl(psd, &fDaclPresent, &pAcl,
            &fDaclDefaulted)) {
        PrintLastError("GetSecurityDescriptorDacl");
        return;
    }
    DisplayAcl(fDaclPresent, pAcl, fDaclDefaulted);
}

static void DisplaySaclSecurityInfo(
    IN PSECURITY_DESCRIPTOR psd
    )
{
    BOOL fSaclPresent;
    PACL pAcl;
    BOOL fSaclDefaulted;
    DWORD dwAceIndex;

    printf("  ---  SACLs  ---\n");
    if (!GetSecurityDescriptorSacl(psd, &fSaclPresent, &pAcl,
            &fSaclDefaulted)) {
        PrintLastError("GetSecurityDescriptorSacl");
        return;
    }
    DisplayAcl(fSaclPresent, pAcl, fSaclDefaulted);
}

static void DisplayRegQueryInfo(
    IN HKEY hKey
    )
{
    FILETIME ftLastWriteTime;
    LONG err;

    memset(&ftLastWriteTime, 0, sizeof(ftLastWriteTime));
    if (ERROR_SUCCESS == (err = RegQueryInfoKeyA(
            hKey,
            NULL,       // lpszClass
            NULL,       // lpcchClass
            NULL,       // lpdwReserved
            NULL,       // lpcSubKeys
            NULL,       // lpcchMaxSubKey
            NULL,       // lpcchMaxClass
            NULL,       // lpcValues
            NULL,       // lpcchMaxValuesName
            NULL,       // lpcbMaxValueData
            NULL,       // lpcbSecurityDescriptor
            &ftLastWriteTime
            ))) {
        printf("LastWriteTime:: %s\n", FileTimeText(&ftLastWriteTime));
    }
}

static void DisplayRegSecurityInfo(
    IN HKEY hKey,
    IN LPCSTR pszKeyBase,
    IN LPCSTR pszRegPath,
    SECURITY_INFORMATION SecInf,
    IN BOOL fRecurse
    )
{
    PSECURITY_DESCRIPTOR psd = NULL;

    printf("%s\\%s\n", pszKeyBase, pszRegPath);

    if (NULL == (psd = AllocAndGetSecurityDescriptor(
            hKey, SecInf)))
        return;

    DisplayRegQueryInfo(hKey);

    DisplayControl(psd);

    DisplayOwnerSecurityInfo(psd);
    DisplayGroupSecurityInfo(psd);
    DisplayDaclSecurityInfo(psd);
    if (SecInf & SACL_SECURITY_INFORMATION)
        DisplaySaclSecurityInfo(psd);

    TestFree(psd);
    if (fRecurse) {
    }
}

static void * AllocAndGetTokenInfo(
    IN HANDLE hToken,
    IN TOKEN_INFORMATION_CLASS tic
    )
{
    void *pvInfo = NULL;
    DWORD cbInfo = 0;
    DWORD cbInfo2;

    if (!GetTokenInformation(
            hToken,
            tic,
            pvInfo,
            0,              // cbInfo
            &cbInfo
            )) {
        if (ERROR_INSUFFICIENT_BUFFER != GetLastError()) {
            PrintLastError("GetTokenInformation");
            return NULL;
        }
    }

    if (0 == cbInfo) {
        printf("No Information\n");
        return NULL;
    }
    if (NULL == (pvInfo = TestAlloc(cbInfo)))
        return NULL;

    cbInfo2 = cbInfo;
    if (!GetTokenInformation(
            hToken,
            tic,
            pvInfo,
            cbInfo,
            &cbInfo2
            )) {
        PrintLastError("GetTokenInformation");
        TestFree(pvInfo);
        return NULL;
    }

    return pvInfo;
}


static void GetProcessTokenInfo()
{
    HANDLE hToken = NULL;
    void *pvInfo = NULL;

    printf("Get Process Token Information\n\n");
    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            )) {
        PrintLastError("OpenProcessToken");
        goto ErrorReturn;
    }

    printf("TokenUser: ");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenUser)) {
        PTOKEN_USER pTokenUser = (PTOKEN_USER) pvInfo;
        if (pTokenUser->User.Attributes)
            printf("Attributes(0x%x) ", pTokenUser->User.Attributes);

        DisplaySid(pTokenUser->User.Sid);
        TestFree(pvInfo);
        pvInfo = NULL;
    }

    printf("TokenOwner: ");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenOwner)) {
        PTOKEN_OWNER pTokenOwner = (PTOKEN_OWNER) pvInfo;

        DisplaySid(pTokenOwner->Owner);
        TestFree(pvInfo);
        pvInfo = NULL;
    }

    printf("TokenPrimaryGroup: ");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenPrimaryGroup)) {
        PTOKEN_PRIMARY_GROUP pTokenPrimaryGroup = (PTOKEN_PRIMARY_GROUP) pvInfo;

        DisplaySid(pTokenPrimaryGroup->PrimaryGroup);
        TestFree(pvInfo);
        pvInfo = NULL;
    }

    printf("TokenGroups\n");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenGroups)) {
        PTOKEN_GROUPS pTokenGroups = (PTOKEN_GROUPS) pvInfo;
        DWORD GroupCount = pTokenGroups->GroupCount;
        if (0 == GroupCount)
            printf("  No Groups\n");
        else {
            DWORD i;
            for (i = 0; i < GroupCount; i++) {
                printf("  Group[%d]: ", i);
                if (pTokenGroups->Groups[i].Attributes)
                    printf("Attributes(0x%x) ",
                        pTokenGroups->Groups[i].Attributes);

                DisplaySid(pTokenGroups->Groups[i].Sid);
            }
        }
        TestFree(pvInfo);
        pvInfo = NULL;
    }

    printf("TokenPrivileges\n");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenPrivileges)) {
        PTOKEN_PRIVILEGES pTokenPrivileges = (PTOKEN_PRIVILEGES) pvInfo;
        DWORD PrivilegeCount = pTokenPrivileges->PrivilegeCount;
        if (0 == PrivilegeCount)
            printf("  No Privileges\n");
        else {
            DWORD i;
            for (i = 0; i < PrivilegeCount; i++) {
                char szName[_MAX_PATH];
                DWORD cchName;
                printf("  Privilege[%d]: ", i);
                if (pTokenPrivileges->Privileges[i].Attributes)
                    printf("Attributes(0x%x) ",
                        pTokenPrivileges->Privileges[i].Attributes);

                cchName = sizeof(szName);
                if (LookupPrivilegeName(
                        NULL,                           // pszSystemName
                        &pTokenPrivileges->Privileges[i].Luid,
                        szName,
                        &cchName
                        ))
                    printf("%s\n", szName);
                else
                    PrintLastError("LookupPrivlegeName");
            }
        }
        TestFree(pvInfo);
        pvInfo = NULL;
    }

    printf("TokenDefaultDacl\n");
    if (pvInfo = AllocAndGetTokenInfo(hToken, TokenDefaultDacl)) {
        PTOKEN_DEFAULT_DACL pTokenDacl = (PTOKEN_DEFAULT_DACL) pvInfo;

        DisplayAcl(TRUE, pTokenDacl->DefaultDacl, FALSE);
        TestFree(pvInfo);
        pvInfo = NULL;
    }

ErrorReturn:
    if (hToken)
        CloseHandle(hToken);
    TestFree(pvInfo);
}


static void SetOwner(
    IN HKEY hKeyBase,
    IN LPCSTR pszRegPath
    )
{
    LONG err;
    HKEY hKey = NULL;
    HANDLE hToken = NULL;
    void *pvInfo = NULL;

    SECURITY_DESCRIPTOR sd;
    PSID pSid;              // not allocated

    printf("SetOwner\n");

    if (!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE))
        PrintLastError("SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME)");

    if (ERROR_SUCCESS != (err = RegOpenKeyExA(
            hKeyBase,
            pszRegPath,
            0,                      // dwReserved
            WRITE_OWNER,
            &hKey))) {
        if (ERROR_FILE_NOT_FOUND == err) {
            DWORD dwDisposition;
            if (ERROR_SUCCESS == (err = RegCreateKeyExA(
                    hKeyBase,
                    pszRegPath,
                    0,                      // dwReserved
                    NULL,                   // lpClass
                    REG_OPTION_NON_VOLATILE,
                    WRITE_OWNER,
                    NULL,                   // lpSecurityAttributes
                    &hKey,
                    &dwDisposition)))
                printf("Created Subkey\n");
        }
    }

    if (ERROR_SUCCESS != err) {
        PrintLastError("RegOpenKeyExA(WRITE_OWNER)", err);
        hKey = NULL;
        goto ErrorReturn;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        PrintLastError("InitializeSecurityDescriptor");
        goto ErrorReturn;
    }

    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            )) {
        PrintLastError("OpenProcessToken");
        goto ErrorReturn;
    }

    if (NULL == (pvInfo = AllocAndGetTokenInfo(hToken, TokenUser)))
        goto ErrorReturn;
    else {
        PTOKEN_USER pTokenUser = (PTOKEN_USER) pvInfo;
        pSid = pTokenUser->User.Sid;
    }

    if (!SetSecurityDescriptorOwner(&sd, pSid, FALSE)) {
        PrintLastError("SetSecurityDescriptorOwner");
        goto ErrorReturn;
    }

    if (ERROR_SUCCESS != (err = RegSetKeySecurity(
            hKey,
            OWNER_SECURITY_INFORMATION,
            &sd
            ))) {
        PrintLastError("RegSetKeySecurity(OWNER)", err);
        goto ErrorReturn;
    }

ErrorReturn:
    if (hKey)
        RegCloseKey(hKey);
    if (hToken)
        CloseHandle(hToken);
    TestFree(pvInfo);
}

static void SetGroupDaclSacl(
    IN HKEY hKeyBase,
    IN LPCSTR pszRegPath
    )
{
    LONG err;
    HKEY hKey = NULL;
    HANDLE hToken = NULL;
    void *pvGroupInfo = NULL;
    void *pvUserInfo = NULL;

    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority =
        SECURITY_WORLD_SID_AUTHORITY;
    PSID psidLocalSystem = NULL;
    PSID psidAdministrators = NULL;
    PSID psidEveryone = NULL;
    PSID psidUser;                      // Not allocated

    PACL pDacl = NULL;
    PACCESS_ALLOWED_ACE pAce;
    DWORD dwAclSize;
    DWORD i;

    SECURITY_INFORMATION SecInf = DACL_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION;
    REGSAM samDesired = WRITE_OWNER | WRITE_DAC;

    printf("SetGroupDaclSacl\n");

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        PrintLastError("InitializeSecurityDescriptor");
        goto ErrorReturn;
    }

    if (!SetCurrentPrivilege(SE_SECURITY_NAME, TRUE))
        PrintLastError("SetCurrentPrivilege(SE_SECURITY_NAME)");
    else {
        SecInf |= SACL_SECURITY_INFORMATION;
        samDesired |= ACCESS_SYSTEM_SECURITY;
        if (!SetSecurityDescriptorSacl(&sd, FALSE, NULL, FALSE)) {
            PrintLastError("SetSecurityDescriptorSacl");
            goto ErrorReturn;
        }
    }

    if (ERROR_SUCCESS != (err = RegOpenKeyExA(
            hKeyBase,
            pszRegPath,
            0,                      // dwReserved
            samDesired,
            &hKey))) {
        PrintLastError("RegOpenKeyExA(WRITE_OWNER | WRITE_DAC)", err);
        hKey = NULL;
        goto ErrorReturn;
    }

    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            )) {
        PrintLastError("OpenProcessToken");
        goto ErrorReturn;
    }

    if (NULL == (pvGroupInfo = AllocAndGetTokenInfo(hToken, TokenPrimaryGroup)))
        goto ErrorReturn;
    else {
        PTOKEN_PRIMARY_GROUP pTokenPrimaryGroup =
            (PTOKEN_PRIMARY_GROUP) pvGroupInfo;
        PSID pSid = pTokenPrimaryGroup->PrimaryGroup;

        if (!SetSecurityDescriptorGroup(&sd, pSid, FALSE)) {
            PrintLastError("SetSecurityDescriptorGroup");
            goto ErrorReturn;
        }
    }

    if (NULL == (pvUserInfo = AllocAndGetTokenInfo(hToken, TokenUser)))
        goto ErrorReturn;
    else {
        PTOKEN_USER pTokenUser = (PTOKEN_USER) pvUserInfo;
        psidUser = pTokenUser->User.Sid;
    }


    //
    // prepare the SIDS for LocalSystem, Administrators and Everyone
    //
    if (!AllocateAndInitializeSid(
            &siaNtAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidLocalSystem
            )) {
        PrintLastError("AllocateAndInitializeSid(LocalSystem)");
        goto ErrorReturn;
    }

    if (!AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            )) {
        PrintLastError("AllocateAndInitializeSid(Administrators)");
        goto ErrorReturn;
    }

    if (!AllocateAndInitializeSid(
            &siaWorldSidAuthority,
            1,
            SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidEveryone
            )) {
        PrintLastError("AllocateAndInitializeSid(Everyone)");
        goto ErrorReturn;
    }

    //
    // compute size of new acl
    //

    dwAclSize = sizeof(ACL) +
        4 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(psidLocalSystem) +
        GetLengthSid(psidAdministrators) +
        GetLengthSid(psidEveryone) +
        GetLengthSid(psidUser)
        ;

    //
    // allocate storage for Acl
    //
    if (NULL == (pDacl = (PACL) TestAlloc(dwAclSize)))
        goto ErrorReturn;

    if (!InitializeAcl(pDacl, dwAclSize, ACL_REVISION)) {
        PrintLastError("InitializeAcl");
        goto ErrorReturn;
    }

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            KEY_ALL_ACCESS,
            psidLocalSystem
            )) {
        PrintLastError("AddAccessAllowedAce(LocalSystem)");
        goto ErrorReturn;
    }

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            KEY_ALL_ACCESS,
            psidAdministrators
            )) {
        PrintLastError("AddAccessAllowedAce(Administrators)");
        goto ErrorReturn;
    }

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            KEY_READ,
            psidEveryone
            )) {
        PrintLastError("AddAccessAllowedAce(Everyone)");
        goto ErrorReturn;
    }

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            KEY_ALL_ACCESS,
            psidUser
            )) {
        PrintLastError("AddAccessAllowedAce(User)");
        goto ErrorReturn;
    }

    //
    // make containers inherit.
    //

    for (i = 0; i < 4; i++) {
        if(!GetAce(pDacl, i, (void **) &pAce)) {
            PrintLastError("GetAce");
            goto ErrorReturn;
        }
        pAce->Header.AceFlags = CONTAINER_INHERIT_ACE;
    }

    if (!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE)) {
        PrintLastError("SetSecurityDescriptorDacl");
        goto ErrorReturn;
    }

    if (ERROR_SUCCESS != (err = RegSetKeySecurity(
            hKey,
            SecInf,
            &sd
            ))) {
        PrintLastError("RegSetKeySecurity(Group, DACL, SACL)", err);
        goto ErrorReturn;
    }

ErrorReturn:
    if (hKey)
        RegCloseKey(hKey);
    if (hToken)
        CloseHandle(hToken);
    TestFree(pvGroupInfo);
    TestFree(pvUserInfo);

    if (psidLocalSystem)
        FreeSid(psidLocalSystem);
    if (psidAdministrators)
        FreeSid(psidAdministrators);
    if (psidEveryone)
        FreeSid(psidEveryone);
    TestFree(pDacl);
}

#define PROT_ROOT_SUBKEY_NAME       L"ProtectedRoots"
#define SYSTEM_STORE_REGPATH        L"Software\\Microsoft\\SystemCertificates"
#define PROT_ROOT_REGPATH           \
                SYSTEM_STORE_REGPATH L"\\Root\\" PROT_ROOT_SUBKEY_NAME

#define PSID_PROT_OWNER             psidAdministrators
#define PSID_PROT_SYSTEM            psidLocalSystem
#define PSID_PROT_EVERYONE          psidEveryone

//+-------------------------------------------------------------------------
//  ACL definitions used to set security on the "ProtectedRoots" SubKey.
//--------------------------------------------------------------------------
#define PROT_SYSTEM_ACE_MASK        KEY_ALL_ACCESS
#define PROT_EVERYONE_ACE_MASK      KEY_READ
#define PROT_ACE_FLAGS              CONTAINER_INHERIT_ACE

#define PROT_ACE_COUNT              2
#define PROT_SYSTEM_ACE_INDEX       0
#define PROT_EVERYONE_ACE_INDEX     1


static void CheckProtectedRoots()
{
    LONG lErr;
    HKEY hKeyProtRoot = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;
    PSID psidOwner;                 // not allocated
    BOOL fOwnerDefaulted;
    BOOL fDaclPresent;
    PACL pAcl;                      // not allocated
    BOOL fDaclDefaulted;
    DWORD dwAceIndex;
    PACCESS_ALLOWED_ACE rgpAce[PROT_ACE_COUNT];

    PSID psidLocalSystem = NULL;
    PSID psidAdministrators = NULL;
    PSID psidEveryone = NULL;

    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority =
        SECURITY_WORLD_SID_AUTHORITY;

    if (ERROR_SUCCESS != (lErr = RegOpenKeyExU(
            HKEY_CURRENT_USER,
            PROT_ROOT_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hKeyProtRoot))) {
        PrintLastError("OpenProtectedRootKey", lErr);
        goto ErrorReturn;
    }

    if (NULL == (psd = AllocAndGetSecurityDescriptor(
            hKeyProtRoot,
            OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION
            )))
        goto ErrorReturn;

    //
    // prepare the SIDS for LocalSystem, Administrators and Everyone
    //
    if (!AllocateAndInitializeSid(
            &siaNtAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidLocalSystem
            )) {
        PrintLastError("AllocateAndInitializeSid(LocalSystem)");
        goto ErrorReturn;
    }

    if (!AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            )) {
        PrintLastError("AllocateAndInitializeSid(Administrators)");
        goto ErrorReturn;
    }

    if (!AllocateAndInitializeSid(
            &siaWorldSidAuthority,
            1,
            SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidEveryone
            )) {
        PrintLastError("AllocateAndInitializeSid(Everyone)");
        goto ErrorReturn;
    }

    // Verify owner
    if (!GetSecurityDescriptorOwner(psd, &psidOwner, &fOwnerDefaulted)) {
        PrintLastError("GetSecurityDescriptorOwner");
        goto ErrorReturn;
    }
    if (NULL == psidOwner || !EqualSid(psidOwner, PSID_PROT_OWNER)) {
        printf("failed => invalid Owner\n");
        goto ErrorReturn;
    }

    // Verify DACL
    if (!GetSecurityDescriptorDacl(psd, &fDaclPresent, &pAcl,
            &fDaclDefaulted)) {
        PrintLastError("GetSecurityDescriptorDacl");
        goto ErrorReturn;
    }
    if (!fDaclPresent || NULL == pAcl) {
        printf("failed => missing Dacl\n");
        goto ErrorReturn;
    }
    if (PROT_ACE_COUNT != pAcl->AceCount) {
        printf("failed => invalid AceCount\n");
        goto ErrorReturn;
    }

    for (dwAceIndex = 0; dwAceIndex < PROT_ACE_COUNT; dwAceIndex++) {
        PACCESS_ALLOWED_ACE pAce;
        if (!GetAce(pAcl, dwAceIndex, (void **) &pAce)) {
            printf("failed => invalid Acl\n");
            goto ErrorReturn;
        }
        rgpAce[dwAceIndex] = pAce;

        if (ACCESS_ALLOWED_ACE_TYPE != pAce->Header.AceType ||
                PROT_ACE_FLAGS != pAce->Header.AceFlags) {
            printf("failed => invalid Acl\n");
            goto ErrorReturn;
        }
    }

    if (PROT_SYSTEM_ACE_MASK != rgpAce[PROT_SYSTEM_ACE_INDEX]->Mask ||
            !EqualSid(PSID_PROT_SYSTEM,
                (PSID) &rgpAce[PROT_SYSTEM_ACE_INDEX]->SidStart) ||
            PROT_EVERYONE_ACE_MASK != rgpAce[PROT_EVERYONE_ACE_INDEX]->Mask ||
            !EqualSid(PSID_PROT_EVERYONE,
                (PSID) &rgpAce[PROT_EVERYONE_ACE_INDEX]->SidStart)) {
        printf("failed => invalid Acl\n");
        goto ErrorReturn;
    }

    printf("Success => ProtectedRoots has correct ACLs\n");
CommonReturn:
    if (psidLocalSystem)
        FreeSid(psidLocalSystem);
    if (psidAdministrators)
        FreeSid(psidAdministrators);
    if (psidEveryone)
        FreeSid(psidEveryone);

    TestFree(psd);
    if (hKeyProtRoot)
        RegCloseKey(hKeyProtRoot);
    return;

ErrorReturn:
    printf("Failed => ProtectedRoots has the following BAD ACLs\n");
    if (hKeyProtRoot)
        DisplayRegQueryInfo(hKeyProtRoot);

    if (psd) {
        DisplayControl(psd);
        DisplayOwnerSecurityInfo(psd);
        DisplayGroupSecurityInfo(psd);
        DisplayDaclSecurityInfo(psd);
    }
    goto CommonReturn;
}


int _cdecl main(int argc, char * argv[]) 
{
    int status;

#define TEST_NAME_INDEX     0
#define PATH_NAME_INDEX     1
#define MAX_NAME_CNT        2
    DWORD dwNameCnt = 0;
    LPCSTR rgpszName[MAX_NAME_CNT];
    LPCSTR pszTestName;                 // not allocated
    LPCSTR pszRegPath;                  // not allocated

    HKEY hKeyBase = HKEY_CURRENT_USER;
    LPCSTR pszKeyBase = "HKEY_CURRENT_USER";
    BOOL fRecurse = FALSE;
    HKEY hKey = NULL;

    while (--argc>0) {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'l':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "CU")) {
                        hKeyBase = HKEY_CURRENT_USER;
                        pszKeyBase = "HKEY_CURRENT_USER";
                    } else if (0 == _stricmp(argv[0]+2, "LM")) {
                        hKeyBase = HKEY_LOCAL_MACHINE;
                        pszKeyBase = "HKEY_LOCAL_MACHINE";
                    } else {
                        printf("Need to specify -lCU or -lLM\n");
                        goto BadUsage;
                    }
                } else {
                    printf("Need to specify -lCU or -lLM\n");
                    goto BadUsage;
                }
                break;
            case 'r':
                fRecurse = TRUE;
                break;

            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (MAX_NAME_CNT <= dwNameCnt) {
                printf("Too many names starting with:: %s\n", argv[0]);
                goto BadUsage;
            }
            rgpszName[dwNameCnt++] = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());

    if (0 == dwNameCnt) {
        printf("Missing <TestName>\n");
        goto BadUsage;
    } else
        pszTestName = rgpszName[TEST_NAME_INDEX];

    if (0 == _stricmp("PurgeLMRoots", pszTestName)) {
        printf("Purge LocalMachine Duplicate Roots from CurrentUser\n");
        if (!I_CertProtectFunction(
                CERT_PROT_PURGE_LM_ROOTS_FUNC_ID,
                0,                                  // dwFlags
                NULL,                               // pwszIn
                NULL,                               // pbIn
                0,                                  // cbIn
                NULL,                               // ppbOut
                NULL                                // pcbOut
                ))
            PrintLastError(
                "I_CertProtectFunction(CERT_PROT_PURGE_LM_ROOTS_FUNC_ID)");
        goto SuccessReturn;
    } else if (0 == _stricmp("DeleteUnknownRoots", pszTestName)) {
        printf("Delete unknown CurrentUser roots from Protected List\n");
        if (!I_CertProtectFunction(
                CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID,
                0,                                  // dwFlags
                NULL,                               // pwszIn
                NULL,                               // pbIn
                0,                                  // cbIn
                NULL,                               // ppbOut
                NULL                                // pcbOut
                ))
            PrintLastError(
                "I_CertProtectFunction(CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID)");
        goto SuccessReturn;
    } else if (0 == _stricmp("CheckProtectedRoots", pszTestName)) {
        printf("Check ProtectedRoots ACLs\n");
        CheckProtectedRoots();
        goto SuccessReturn;
    } else if (0 == _stricmp("ServiceUI", pszTestName)) {
        BYTE *pbOut = NULL;
        DWORD cbOut = 0;

        printf("Certificate Protect Service UI\n");
        if (!I_CertProtectFunction(
                1000,
                0,                  // dwFlags
                L"Root test",       // pwszIn
                NULL,               // pbIn
                0,                  // cbIn
                &pbOut,
                &cbOut
                ))
            PrintLastError("I_CertProtectFunction(UI)");
        else if (pbOut) {
            PrintBytes("DataOut", pbOut, cbOut);
            CryptMemFree(pbOut);
        }
        goto SuccessReturn;
    } else if (0 == _stricmp("ServiceTokenInfo", pszTestName)) {
        BYTE *pbOut = NULL;
        DWORD cbOut = 0;

        printf("Certificate Protect Service's Token Info\n");
        if (!I_CertProtectFunction(
                1001,
                0,                  // dwFlags
                NULL,               // pwszIn
                NULL,               // pbIn
                0,                  // cbIn
                &pbOut,
                &cbOut
                ))
            PrintLastError("I_CertProtectFunction(GetTokenInfo)");
        else if (pbOut) {
            if (cbOut)
                puts((LPCSTR) pbOut);
            CryptMemFree(pbOut);
        }
        goto SuccessReturn;
    } else if (0 == _stricmp("ServiceInvalid", pszTestName)) {
        printf("Calling Invalid Certificate Protect Function\n");
        if (!I_CertProtectFunction(
                1002,
                0,                  // dwFlags
                NULL,               // pwszIn
                NULL,               // pbIn
                0,                  // cbIn
                NULL,               // ppbOut
                NULL                // pcbOut
                ))
            PrintLastError("I_CertProtectFunction(1002)");
        goto SuccessReturn;
    } else if (1 == dwNameCnt) {
        printf("Missing <RegPath>\n");
        goto BadUsage;
    } else
        pszRegPath = rgpszName[PATH_NAME_INDEX];

    printf("\n");
    if (0 == _stricmp("GetKey", pszTestName)) {
        LONG err;
        REGSAM samDesired = READ_CONTROL | ACCESS_SYSTEM_SECURITY;
        SECURITY_INFORMATION SecInf = OWNER_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION |
            DACL_SECURITY_INFORMATION |
            SACL_SECURITY_INFORMATION;

        if (!SetCurrentPrivilege(SE_SECURITY_NAME, TRUE)) {
            PrintLastError("SetCurrentPrivilege(SE_SECURITY_NAME)");
            samDesired = READ_CONTROL;
            SecInf &= ~SACL_SECURITY_INFORMATION;
        }

        if (!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE))
            PrintLastError("SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME)");

        GetProcessTokenInfo();

        printf("\n\nGet Registry Key Security Information\n\n");
        if (ERROR_SUCCESS != (err = RegOpenKeyExA(
                hKeyBase,
                pszRegPath,
                0,                      // dwReserved
                KEY_READ | samDesired,
                &hKey))) {
            if (ERROR_ACCESS_DENIED == err) {
                if (ERROR_SUCCESS == (err = RegOpenKeyExA(
                        hKeyBase,
                        pszRegPath,
                        0,                      // dwReserved
                        samDesired,
                        &hKey))) {
                    printf("No Read Access\n");
                    fRecurse = FALSE;
                }
            }
        }

        
        if (ERROR_SUCCESS != err) {
            printf("RegOpenKeyExA(%s\\%s) failed => 0x%x (%d)\n",
                pszKeyBase, pszRegPath, err, err);
            hKey = NULL;
        } else
            DisplayRegSecurityInfo(
                hKey,
                pszKeyBase,
                pszRegPath,
                SecInf,
                fRecurse
                );
    } else if (0 == _stricmp("SetKey", pszTestName)) {
        printf("Set Registry Key Security Information\n\n");

        SetOwner(hKeyBase, pszRegPath);
        SetGroupDaclSacl(hKeyBase, pszRegPath);

    } else {
        printf("Invalid TestName: %s\n", pszTestName);
        goto BadUsage;
    }

SuccessReturn:
    status = 0;
CommonReturn:
    if (hKey)
        RegCloseKey(hKey);
    return status;
BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tcrmsg\tcrmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tcrmsg.cpp
//
//  Contents:   Cryptographic Message API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    26-Feb-96   philh   created
//
//--------------------------------------------------------------------------

#include "global.hxx"

#define SAVE_STREAM_FILES   1

#define MAX_HASH_LEN  20

#define ZEROSTRUCT(arg) (memset( &arg, 0, sizeof(arg)))

//+-------------------------------------------------------------------------
// Parameters, data used to encode the messages.
//--------------------------------------------------------------------------
HCRYPTPROV hCryptProv = 0;
DWORD dwProvType = PROV_RSA_FULL;

#ifdef CMS_PKCS7
HCRYPTPROV hMultiSignerCryptProv = 0;
DWORD dwMultiSignerProvType = PROV_RSA_FULL;
BOOL fMultiSigner = FALSE;
BOOL fHashEncryptionAlgorithm = FALSE;
BOOL fAlgorithmParameters = FALSE;
BOOL fNoSignature = FALSE;

BYTE rgbOctets[] = {4, 8, 1,2,3,4,5,6,7,8};
BYTE rgbInvalidAsn[] = {0xFF, 0xFF};
#endif  // CMS_PKCS7

LPSTR pszCertNameFindStr = NULL;
HCERTSTORE hSignerStore = NULL;
PCCERT_CONTEXT pNamedSigner = NULL;
HCRYPTPROV hNamedSignerCryptProv = 0;

LPSTR pszFilename = NULL;
BOOL fVerbose = FALSE;
BOOL fNoSigners = FALSE;
BOOL fAddSigner = FALSE;
BOOL fDetached = FALSE;
BOOL fAuthAttr = FALSE;
BOOL fInnerContent = FALSE;
BOOL fCountersign = FALSE;
BOOL fStream = FALSE;
BOOL fIndefinite = FALSE;
BOOL fBare = FALSE;
BOOL fMD5 = FALSE;
BOOL fNoRecipients = FALSE;
DWORD dwMsgEncodingType = PKCS_7_ASN_ENCODING;
DWORD dwCertEncodingType = X509_ASN_ENCODING;


LPCSTR pszContainer = NULL;
LPCSTR pszProvider = NULL;
BOOL fDefaultVerifyProv = FALSE;
HCRYPTPROV hDefaultVerifyProv = 0;
BOOL fEnhanced = FALSE;
LPCSTR pszEncryptName = "rc2";
LPCSTR pszEncryptOID = NULL;
DWORD dwEncryptBitLen = 0;
BOOL fEncryptIV = FALSE;

#ifdef CMS_PKCS7
BOOL fOriginatorInfo = FALSE;
#endif  // CMS_PKCS7

typedef struct _PUBLIC_KEY_DATA {
    BYTE    Data[1024];
} PUBLIC_KEY_DATA;

#define DEFAULT_MSG_CONTENT_SIZE 49
DWORD   cbMsgContent = DEFAULT_MSG_CONTENT_SIZE;
BYTE    rgbMsgContentFill[7] = {'C','o','n','t','e','n','t'};
#define cbMsgContentFill sizeof(rgbMsgContentFill)
DWORD   iMsgContentOffset = 0;
PBYTE   pbInnerContent = NULL;
DWORD   cbInnerContent;

// rsaEncryption
CRYPT_ALGORITHM_IDENTIFIER PublicKeyAlgorithm =
    {szOID_RSA_RSA, {0,0}};

// DES or RC4
CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm[] = {
    {szOID_OIWSEC_desCBC,   {0,0}},
    {szOID_RSA_RC4,         {0,0}},
    {szOID_RSA_RC2CBC,      {0,0}},
};
#define CONTENT_ALG_DES     0
#define CONTENT_ALG_RC4     1
#define CONTENT_ALG_RC2     2

// MD5 or SHA1
CRYPT_ALGORITHM_IDENTIFIER DigestAlgorithms[] = {
    {szOID_RSA_MD5,     {0,0}},
    {szOID_OIWSEC_sha1, {0,0}},
};
#define DIGEST_ALG_MD5      0
#define DIGEST_ALG_SHA      1

// MD5 or SHA
CRYPT_ALGORITHM_IDENTIFIER SignDigestAlgorithms[] = {
    {szOID_RSA_MD5,     {0,0}},
    {szOID_OIWSEC_sha1, {0,0}},
};
#define SIGNDIGEST_ALG_MD5  0
#define SIGNDIGEST_ALG_SHA  1

LPSTR pszSignerSerialNumberFileName = "name.der";
DWORD dwSignerSerialNumber  = 0x01010101;
DWORD dwSignerSerialNumber1 = 0x02020202;
DWORD dwSignerSerialNumber2 = 0x03030303;
PUBLIC_KEY_DATA SignerPublicKeyData;

#define SIGNED_CERT_COUNT   3
DWORD cSignedCert = 1;
LPCSTR rgpszSignedCertFileName[SIGNED_CERT_COUNT] = {
    "cert1.der",
    "cert2.der",
    "cert3.der"
};
CERT_BLOB rgSignedCertBlob[3];

#ifdef CMS_PKCS7
#define ATTR_CERT_COUNT   2
DWORD cAttrCert = 0;
BOOL fEncapsulatedContent = FALSE;

LPCSTR rgpszAttrCertFileName[ATTR_CERT_COUNT] = {
    "cert2.der",
    "cert3.der"
};
CERT_BLOB rgAttrCertBlob[ATTR_CERT_COUNT];
#endif  // CMS_PKCS7

#ifdef CMS_PKCS7
#define SIGNED_CRL_COUNT    1
DWORD cSignedCrl = 0;
LPCSTR rgpszSignedCrlFileName[SIGNED_CRL_COUNT] = {
    "crl1.der"
};
CRL_BLOB rgSignedCrlBlob[SIGNED_CRL_COUNT];
#else
#define SIGNED_CRL_COUNT    0
#endif

#define RECIPIENT_COUNT     2
DWORD PkcsRecipientCount = RECIPIENT_COUNT;
LPCSTR rgpszRecipientIssuerFileName[RECIPIENT_COUNT] = {
    "recip1.der",
    "recip2.der"
};
DWORD rgdwRecipientSerialNumber[RECIPIENT_COUNT] = {
    0x02020202,
    0x03030303
};
PUBLIC_KEY_DATA RecipientPublicKeyData;
CERT_INFO rgRecipientCertInfo[RECIPIENT_COUNT];
PCERT_INFO rgpRecipientCertInfo[RECIPIENT_COUNT];

#ifdef CMS_PKCS7
BOOL fRecipientProv = FALSE;
BOOL fKeyTrans = FALSE;
BOOL fKeyAgree = FALSE;
BOOL fMailList = FALSE;
BOOL fCmsRecipient = FALSE;
BOOL fRecipientKeyId = FALSE;
BOOL fCertInfoKeyId = FALSE;
BOOL fSignerId = FALSE;

BOOL fNoSalt = FALSE;
#define MAX_SALT_LEN    11
BYTE rgbSalt[MAX_SALT_LEN];
CMSG_RC4_AUX_INFO RC4AuxInfo;

CMSG_RECIPIENT_ENCODE_INFO rgCmsRecipient[RECIPIENT_COUNT * 4];
CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO rgKeyTrans[RECIPIENT_COUNT * 4];

HCRYPTPROV hKeyAgreeProv = 0;
PUBLIC_KEY_DATA KeyAgreePublicKeyData;
CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO rgKeyAgree[RECIPIENT_COUNT * 4];
CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO rgEncryptedKey[RECIPIENT_COUNT];
PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO rgpEncryptedKey[RECIPIENT_COUNT];
CMSG_RC2_AUX_INFO KeyAgreeRC2AuxInfo;

BYTE rgbKeyAgreeOtherAttr[] = {0x04, 3, 3, 2, 1};
CRYPT_ATTRIBUTE_TYPE_VALUE KeyAgreeOtherAttr = {
    "1.2.10.11.12",
    sizeof(rgbKeyAgreeOtherAttr), rgbKeyAgreeOtherAttr
};

LPCSTR pszUserKeyingMaterial = "UserKeyingMaterial";


CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO rgMailList[RECIPIENT_COUNT * 4];
CMSG_RC2_AUX_INFO MailListRC2AuxInfo;

BYTE rgbMailListOtherAttr[] = {0x04, 2, 1, 2};
CRYPT_ATTRIBUTE_TYPE_VALUE MailListOtherAttr = {
    "1.2.3.4.5.6.7.8.9",
    sizeof(rgbMailListOtherAttr), rgbMailListOtherAttr
};

DWORD cCmsRecipients = 0;
#endif  // CMS_PKCS7

#define AUTH_ATTR_COUNT     2
BYTE    attr1[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','1',0};
BYTE    attr2[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','2',0};
BYTE    attr3[] = {0x04, 0x0c, 'A','t','t','r','i','b','u','t','e',' ','3',0};
CRYPT_ATTR_BLOB rgatrblob1[] = {
    { sizeof( attr1), attr1}
};
CRYPT_ATTR_BLOB rgatrblob2[] = {
    { sizeof( attr2), attr2},
    { sizeof( attr3), attr3}
};
CRYPT_ATTRIBUTE rgAuthAttr[AUTH_ATTR_COUNT] = {
    {"1.2.3.5.7",  1, rgatrblob1},
    {"1.2.3.5.11", 2, rgatrblob2}
};

#define UNAUTH_ATTR_COUNT     1
BYTE    unattr1[] = {0x04, 0x0c, 'A','T','T','R','I','B','U','T','E',' ','1',0};
CRYPT_ATTR_BLOB rgunatrblob1[] = {
    { sizeof( unattr1), unattr1}
};
CRYPT_ATTRIBUTE rgUnauthAttr[UNAUTH_ATTR_COUNT] = {
    {"1.2.3.5.13.23",  1, rgunatrblob1},
};

LPSTR pszInnerContentObjId     = szOID_RSA_digestedData;
LPCSTR pszInnerContentFileName = "content.der";
//CRYPT_DER_BLOB    derInnerContent = {NULL,0};

CERT_INFO rgSignerCertInfo[2];
#ifdef CMS_PKCS7
CERT_ID rgSignerId[2];
#endif  // CMS_PKCS7
CMSG_SIGNER_ENCODE_INFO rgSignerEncodeInfo[2];
CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;
CMSG_ENVELOPED_ENCODE_INFO EnvelopedMsgEncodeInfo;
CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO SignedAndEnvelopedMsgEncodeInfo;
CMSG_HASHED_ENCODE_INFO HashedMsgEncodeInfo;

#ifdef CMS_PKCS7
PUBLIC_KEY_DATA MultiSignerPublicKeyData;

BYTE rgbEncodedSignerHash[2][MAX_HASH_LEN];
DWORD rgcbEncodedSignerHash[2];

#endif  // CMS_PKCS7

static inline IsDSSProv(
    IN DWORD dwProvType
    )
{
    return (PROV_DSS == dwProvType || PROV_DSS_DH == dwProvType);
}

//+-------------------------------------------------------------------------
//  Error output routines
//--------------------------------------------------------------------------
#define PRINT_ERROR(function,label)                                     \
label##:                                                                \
    PrintError( #function "::" #label);                                 \
    goto ErrorReturn;

void PrintError(LPCSTR pszMsg)
{
    printf("failed => %s\n", pszMsg);
}
void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

//+-------------------------------------------------------------------------
//  Test allocation and free routines
//--------------------------------------------------------------------------
void *TestAlloc(
    IN size_t cb
    )
{
    void *pv;
//    pv = LocalAlloc(LMEM_FIXED, cb);
    pv = malloc(cb);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    }
    return pv;
}

void *TestAllocZero(
    IN size_t cb
    )
{
    void *pv;
//    pv = LocalAlloc(LMEM_FIXED, cb);
    pv = malloc(cb);
    if (pv == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        PrintLastError("TestAlloc");
    } else {
        memset( pv, 0, cb);
    }
    return pv;
}

void TestFree(
    IN void *pv
    )
{
//        LocalFree((HLOCAL) pv);
    if (pv)
        free(pv);
}


static BOOL AllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    fResult = CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            lpszStructType,
            pvStructInfo,
            NULL,           // pbEncoded
            &cbEncoded);
    if (!fResult || cbEncoded == 0) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d, cbEncoded == 0)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s, cbEncoded == 0)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }

    if (NULL == (pbEncoded = (BYTE *) TestAlloc(cbEncoded)))
        goto ErrorReturn;
    if (!CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            lpszStructType,
            pvStructInfo,
            pbEncoded,
            &cbEncoded
            )) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }
    fResult = TRUE;

CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    if (pbEncoded) {
        TestFree(pbEncoded);
        pbEncoded = NULL;
    }
    cbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL AllocAndDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT void        **ppvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    )
{
    BOOL fResult;
    void *pvStructInfo = NULL;
    DWORD cbStructInfo = 0;

    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                          // dwFlags
            NULL,
            &cbStructInfo
            )) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptDecodeObject(StructType: %d, cbStructInfo == 0)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptDecodeObject(StructType: %s, cbStructInfo == 0)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }
    if (NULL == (pvStructInfo = TestAlloc(cbStructInfo)))
        goto ErrorReturn;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            0,                          // dwFlags
            pvStructInfo,
            &cbStructInfo
            )) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptDecodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptDecodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
        goto ErrorReturn;
    }

    fResult = TRUE;

CommonReturn:
    *ppvStructInfo = pvStructInfo;
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    TestFree(pvStructInfo);
    pvStructInfo = NULL;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Stream support
//--------------------------------------------------------------------------
typedef struct _TEST_STREAM_DATA {
    DWORD               dwEncodingType;
    DWORD               dwEncodeFlags;
    DWORD               dwDecodeFlags;
    DWORD               dwMsgTypeEncoding;
    DWORD               dwMsgTypeDecoding;
    PVOID               pvMsgEncodeInfo;
    LPSTR               pszInnerContentType;
    PCMSG_STREAM_INFO   pStreamInfo;
    HCRYPTMSG           hMsg;
    BOOL                fEncoding;
    BOOL                fReady;
#ifdef CMS_PKCS7
    DWORD               rgcbComputedHash[2];
    BYTE                rgbComputedHash[2][MAX_HASH_LEN];
#endif  // CMS_PKCS7
} TEST_STREAM_DATA, *PTEST_STREAM_DATA;

DEFINE_LIST_AND_NODE_CLASS( CStreamList, CStreamNode, TEST_STREAM_DATA);
CStreamNode::~CStreamNode()
{
    TestFree( m_data.pStreamInfo);
};

CStreamList     *plistStream = NULL;


DEFINE_LIST_AND_NODE_CLASS( CBlobList, CBlobNode, CRYPT_DATA_BLOB);
CBlobNode::~CBlobNode()
{
    TestFree( m_data.pbData);
};


LPSTR           pszStreamMsgTypes = "S";
#define pszStreamFileName "stream.msg"
#define pszFilenameDecode "decode.dat"
HANDLE          hFileStream       = INVALID_HANDLE_VALUE;
HANDLE          hFileStreamDecode = INVALID_HANDLE_VALUE;
DWORD           cbFileDecode;
#if DBG
#define cbStreamDataDeltaEncode 17
#else
#define cbStreamDataDeltaEncode 1024
#endif
BYTE abStreamDataDeltaEncode[cbStreamDataDeltaEncode];
#if DBG
DWORD cbStreamDataDeltaDecode = 1;
//DWORD cbStreamDataDeltaDecode = 19;
#else
DWORD cbStreamDataDeltaDecode = 1024;
#endif

//+-------------------------------------------------------------------------
//  Check that a CryptMsgGetParam to a buffer fails with the right error
//  because the buffer is too small.
//--------------------------------------------------------------------------
BOOL
WINAPI
TCM_CheckGetParam(
    IN HCRYPTMSG    hCryptMsg,
    IN DWORD        dwParamType,
    IN DWORD        dwIndex,
    IN PVOID        pv,
    IN DWORD        cbData)
{
    BOOL    fRet;
    DWORD   cbSmall;

    if (cbData < 1)
        goto SuccessReturn;

    cbSmall = cbData - 1;
    if (CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            pv,
            &cbSmall))
        goto GetSmallBufferRetError;

    if (ERROR_MORE_DATA != GetLastError())
        goto GetSmallBufferLastErrorError;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(TCM_CheckGetParam,GetSmallBufferRetError)
PRINT_ERROR(TCM_CheckGetParam,GetSmallBufferLastErrorError)
}


//+-------------------------------------------------------------------------
//  Do a CryptMsgGetParam to a buffer alloc'd by TestAlloc
//--------------------------------------------------------------------------
BOOL
WINAPI
TCM_AllocGetParam(
    IN HCRYPTMSG    hCryptMsg,
    IN DWORD        dwParamType,
    IN DWORD        dwIndex,
    OUT PBYTE       *ppbData,
    OUT DWORD       *pcbData)
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    fRet;
    DWORD   cb;
    PBYTE   pb = NULL;
    
    cb = 0;
    CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            NULL,
            &cb);
    if (cb == 0)
        goto GetEncodedSizeError;
    if (NULL == (pb = (PBYTE)TestAlloc(cb)))
        goto AllocEncodedError;
    if (!TCM_CheckGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            pb,
            cb))
        goto CheckGetEncodedError;
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            pb,
            &cb))
        goto GetEncodedError;

    fRet = TRUE;
CommonReturn:
    *ppbData = pb;
    *pcbData = cb;
    if (dwError != ERROR_SUCCESS)
        SetLastError(dwError);
	return fRet;

ErrorReturn:
    dwError = GetLastError();
    TestFree(pb);
    pb = NULL;
    cb = 0;
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(TCM_AllocGetParam,GetEncodedSizeError)
PRINT_ERROR(TCM_AllocGetParam,AllocEncodedError)
PRINT_ERROR(TCM_AllocGetParam,CheckGetEncodedError)
PRINT_ERROR(TCM_AllocGetParam,GetEncodedError)
}


//+-------------------------------------------------------------------------
//  Compare 2 CRYPT_ALGORITHM_IDENTIFIER structs.
//
//  Returns: FALSE iff differ
//--------------------------------------------------------------------------
BOOL
WINAPI
EqualAlgorithm(
    IN PCRYPT_ALGORITHM_IDENTIFIER    pai1,
    IN PCRYPT_ALGORITHM_IDENTIFIER    pai2)
{
    BOOL    fRet;

    fRet  = (0 == strcmp( pai1->pszObjId, pai2->pszObjId));
    fRet &= (pai1->Parameters.cbData == pai2->Parameters.cbData);
    if (fRet) {
        fRet &= (0 == memcmp(   pai1->Parameters.pbData,
                                pai2->Parameters.pbData,
                                pai1->Parameters.cbData));
    }

	return fRet;
}


//+-------------------------------------------------------------------------
//  Compare 2 CRYPT_ATTRIBUTE structs.
//
//  Returns: FALSE iff differ
//--------------------------------------------------------------------------
BOOL
WINAPI
EqualAttribute(
    IN PCRYPT_ATTRIBUTE    patr1,
    IN PCRYPT_ATTRIBUTE    patr2)
{
    BOOL        fRet;
    DWORD       i;
    PCRYPT_ATTR_BLOB  pabl1;
    PCRYPT_ATTR_BLOB  pabl2;

    fRet  = (0 == strcmp( patr1->pszObjId, patr2->pszObjId));
    fRet &= (patr1->cValue == patr2->cValue);
    if (fRet) {
        for (i=patr1->cValue, pabl1=patr1->rgValue, pabl2=patr2->rgValue;
                i>0;
                i--, pabl1++, pabl2++) {
            fRet &= (pabl1->cbData == pabl2->cbData);
            if (fRet) {
                fRet &= (0 == memcmp( pabl1->pbData, 
                                      pabl2->pbData,
                                      pabl1->cbData));
            }
        }
    }

	return fRet;
}

void XORAttributeBytes()
{
    DWORD cb;
    BYTE *pb;

    cb = sizeof(attr1) / sizeof(attr1[0]);
    pb = attr1;
    while(cb--)
        *pb++ ^= 0xFF;

    cb = sizeof(attr2) / sizeof(attr2[0]);
    pb = attr2;
    while(cb--)
        *pb++ ^= 0xFF;

    cb = sizeof(attr3) / sizeof(attr3[0]);
    pb = attr3;
    while(cb--)
        *pb++ ^= 0xFF;

    cb = sizeof(unattr1) / sizeof(unattr1[0]);
    pb = unattr1;
    while(cb--)
        *pb++ ^= 0xFF;
}

void XORBlob(
    IN PCRYPT_DATA_BLOB pBlob
    )
{
    DWORD cb;
    BYTE *pb;

    cb = pBlob->cbData;
    pb = pBlob->pbData;
    while(cb--)
        *pb++ ^= 0xFF;
}

void XORBitBlob(
    IN PCRYPT_BIT_BLOB pBlob
    )
{
    CRYPT_DATA_BLOB Blob;
    Blob.pbData = pBlob->pbData;
    Blob.cbData = pBlob->cbData;

    XORBlob(&Blob);
}


//+-------------------------------------------------------------------------
//  Read an encoded DER blob from a file
//--------------------------------------------------------------------------
BOOL
GetDERFromFile(
	LPCSTR	pszFileName,
	PBYTE	*ppbDER,
	PDWORD	pcbDER
	)
{
	BOOL		fRet;
    HANDLE      hFile;
	PBYTE		pbDER;
    DWORD       cbDER;
    DWORD       cbRead;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszFileName);
        goto ErrorReturn;
    }

    cbDER = GetFileSize( hFile, NULL);
    if (NULL == (pbDER = (PBYTE)TestAlloc( cbDER))) {
        printf( "can't alloc %d bytes\n", cbDER);
        goto ErrorReturn;
    }
    if (!ReadFile( hFile, pbDER, cbDER, &cbRead, NULL) ||
            (cbRead != cbDER)) {
        printf( "can't read %s\n", pszFileName);
        goto ErrorReturn;
    }

	CloseHandle( hFile);
	*ppbDER = pbDER;
	*pcbDER = cbDER;
	fRet = TRUE;
CommonReturn:
	return fRet;
ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Write a buffer to a file
//--------------------------------------------------------------------------
BOOL
WINAPI
TCM_WriteBufToFile(
    LPCSTR      pszFile,
    PBYTE       pbData,
    DWORD       cbData)
{
    BOOL        fRet;
    HANDLE      hFile;
    DWORD       cbWritten;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFile, GENERIC_WRITE,
            0, NULL, CREATE_ALWAYS, 0, NULL)))
        goto CreateFileError;

    if (!WriteFile( hFile, pbData, cbData, &cbWritten, NULL) ||
            (cbWritten != cbData))
        goto WriteFileError;

    CloseHandle( hFile);
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(TCM_WriteBufToFile,CreateFileError)
PRINT_ERROR(TCM_WriteBufToFile,WriteFileError)
}


//+-------------------------------------------------------------------------
//  Get the number of contents octets in a DER encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbDER      - number of bytes remaining in the DER encoding
//
//  Returns:
//          success - the number of bytes in the length field, >=0
//          failure - <0
//--------------------------------------------------------------------------
LONG
WINAPI
TCM_DecodeLength(
    OUT DWORD   *pcbContent,
    IN  PBYTE   pbLength,
    IN  DWORD   cbDER)
{
    long    i;
    BYTE    cbLength;
    PBYTE   pb;

    if (cbDER < 1)
        goto EncodeOverflowError;

    if (0x80 == *pbLength)
        goto IsBERError;

    // determine the number of length octets and contents octets
    if ((cbLength = *pbLength) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        if (cbLength > 4)
            goto LengthTooLargeError;
        if (cbLength >= cbDER)
            goto EncodeOverflowError2;
        *pcbContent = 0;
        for (i=cbLength, pb=pbLength+1; i>0; i--, pb++)
            *pcbContent = (*pcbContent << 8) + (DWORD)*pb;
        i = cbLength + 1;
    } else {
        *pcbContent = (DWORD)cbLength;
        i = 1;
    }

CommonReturn:
    return i;   // how many bytes there were in the length field

EncodeOverflowError:
IsBERError:
LengthTooLargeError:
EncodeOverflowError2:
    i = -1;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Point to the content octets in a DER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, >=0
//          failure - <0
//
//  Assume pbData points to a definite-length BER-encoded blob.
//--------------------------------------------------------------------------
LONG
WINAPI
TCM_ExtractContent(
    IN PBYTE pbDER,
    IN DWORD cbDER,
    OUT DWORD *pcbContent,
    OUT OPTIONAL PBYTE *ppbContent)
{
#define TAG_MASK 0x1f
    DWORD   cbIdentifier;
    DWORD   cbContent;
    LONG    cbLength;
    PBYTE   pb = pbDER;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        for (cbIdentifier=2; *pb++ & 0x80; cbIdentifier++)
            ;
    } else {
        // low-tag-number form
        cbIdentifier = 1;
    }

    if (0 > (cbLength = TCM_DecodeLength( &cbContent, pb, cbDER-cbIdentifier)))
        goto DecodeLengthError;

    pb += cbLength;

    *pcbContent = cbContent;
    if (ppbContent)
        *ppbContent = pb;

    return cbLength + cbIdentifier;

DecodeLengthError:
    return -1;
}



//+-------------------------------------------------------------------------
//  Functions for initializing message encode information
//--------------------------------------------------------------------------
void InitSignedMsgEncodeInfo(
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    );
void InitEnvelopedMsgEncodeInfo(
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    );

//+-------------------------------------------------------------------------
//  Functions for cleaning up message encode information
//--------------------------------------------------------------------------
void CleanupSignedMsgEncodeInfo(
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    );
void CleanupEnvelopedMsgEncodeInfo(
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    );

//+-------------------------------------------------------------------------
//  Message encode and decode routines
//--------------------------------------------------------------------------
BOOL EncodeAndDecodeMsg(
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo
    );
BOOL EncodeMsg(
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    OUT BYTE **ppbEncodedBlob,
    OUT DWORD *pcbEncodedBlob
    );
BOOL DecodeMsg(
    IN DWORD dwExpectedMsgType,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob
    );
BOOL StreamEncodeAndDecodeMsg();
BOOL StreamEncodeMsg();
BOOL StreamDecodeMsg();

//+-------------------------------------------------------------------------
//  Get signer info and verify the signed message
//--------------------------------------------------------------------------
BOOL GetSignerInfoAndVerify(IN HCRYPTMSG hMsg, IN BOOL fInnerNonData);

BOOL GetSignerInfoAndVerify(
    IN HCRYPTMSG hMsg,
    IN BOOL fInnerNonData,
    IN DWORD dwSignerIndex,
    OUT DWORD *pdwSrcIndex
    );

//+-------------------------------------------------------------------------
// Get recipient info and decrypt the message.
//--------------------------------------------------------------------------
BOOL GetRecipientInfoAndDecrypt(IN HCRYPTMSG hMsg);

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_SIGNER_CERT_INFO_PARAM or CMSG_RECIPIENT_INFO_PARAM
// from the message
//--------------------------------------------------------------------------
PCERT_INFO GetCertIdFromMsg(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    );

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_SIGNER_INFO_PARAM from the message
//--------------------------------------------------------------------------
PCMSG_SIGNER_INFO GetSignerInfoFromMsg(
    IN HCRYPTMSG hMsg,
    IN DWORD dwIndex
    );

//+-------------------------------------------------------------------------
// Get computed digest and digest data from a decoded CMSG_HASHED
//--------------------------------------------------------------------------
BOOL Undigest(IN HCRYPTMSG hMsg);

//+-------------------------------------------------------------------------
// Countersign test functions
//--------------------------------------------------------------------------
BOOL CountersignAndVerify(IN HCRYPTMSG hCryptMsg);

//+-------------------------------------------------------------------------
// Add signer test functions
//--------------------------------------------------------------------------
BOOL AddSignerAndVerify(IN HCRYPTMSG hCryptMsg);

//+-------------------------------------------------------------------------
//  Top Level Test Functions
//--------------------------------------------------------------------------
BOOL TestSign()
{
    BOOL    fRet;

    InitSignedMsgEncodeInfo(&SignedMsgEncodeInfo);
    fRet = EncodeAndDecodeMsg(CMSG_SIGNED, &SignedMsgEncodeInfo);
    CleanupSignedMsgEncodeInfo(&SignedMsgEncodeInfo);
    return fRet;
}

BOOL TestEnvelope()
{
    BOOL    fRet;

    InitEnvelopedMsgEncodeInfo(&EnvelopedMsgEncodeInfo);
    fRet = EncodeAndDecodeMsg(CMSG_ENVELOPED, &EnvelopedMsgEncodeInfo);
    CleanupEnvelopedMsgEncodeInfo(&EnvelopedMsgEncodeInfo);
    return fRet;
}

BOOL TestSignAndEnvelope()
{
    BOOL    fRet;

    return FALSE;
    SignedAndEnvelopedMsgEncodeInfo.cbSize =
        sizeof(CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO);
    InitSignedMsgEncodeInfo(&SignedAndEnvelopedMsgEncodeInfo.SignedInfo);
    InitEnvelopedMsgEncodeInfo(&SignedAndEnvelopedMsgEncodeInfo.EnvelopedInfo);
    fRet = EncodeAndDecodeMsg(CMSG_SIGNED_AND_ENVELOPED,
        &SignedAndEnvelopedMsgEncodeInfo);
    CleanupSignedMsgEncodeInfo(&SignedAndEnvelopedMsgEncodeInfo.SignedInfo);
    CleanupEnvelopedMsgEncodeInfo(&SignedAndEnvelopedMsgEncodeInfo.EnvelopedInfo);
    return fRet;
}

BOOL TestDigest()
{
    HashedMsgEncodeInfo.cbSize = sizeof(CMSG_HASHED_ENCODE_INFO);
    HashedMsgEncodeInfo.hCryptProv = hDefaultVerifyProv;
    HashedMsgEncodeInfo.HashAlgorithm =
        DigestAlgorithms[ fMD5 ? DIGEST_ALG_MD5 : DIGEST_ALG_SHA];
    HashedMsgEncodeInfo.pvHashAuxInfo = NULL;

    return EncodeAndDecodeMsg(CMSG_HASHED, &HashedMsgEncodeInfo);
}

BOOL TestCountersign()
{
    BOOL    fRet;

    fCountersign = TRUE;
    InitSignedMsgEncodeInfo(&SignedMsgEncodeInfo);
    fRet = EncodeAndDecodeMsg(CMSG_SIGNED, &SignedMsgEncodeInfo);
    CleanupSignedMsgEncodeInfo(&SignedMsgEncodeInfo);
    return fRet;
}

BOOL TestStream()
{
    BOOL    fRet;

    if (NULL == (plistStream = new CStreamList))
        return FALSE;
    fStream = TRUE;

    InitSignedMsgEncodeInfo(&SignedMsgEncodeInfo);
    InitEnvelopedMsgEncodeInfo(&EnvelopedMsgEncodeInfo);
    fRet = StreamEncodeAndDecodeMsg();
    CleanupEnvelopedMsgEncodeInfo(&EnvelopedMsgEncodeInfo);
    CleanupSignedMsgEncodeInfo(&SignedMsgEncodeInfo);

    delete plistStream;
    plistStream = NULL;
    return fRet;
}


typedef BOOL (*PFN_TEST)(void);
struct
{
    LPCSTR      pszName;
    PFN_TEST    pfn;
} Tests[] = {
    "Sign",             TestSign,
    "Envelope",         TestEnvelope,
    "SignAndEnvelope",  TestSignAndEnvelope,
    "Digest",           TestDigest,
    "Countersign",      TestCountersign,
    "Stream",           TestStream
};
#define NTESTS (sizeof(Tests)/sizeof(Tests[0]))

void Usage(void)
{
    int i;

    printf("Usage: tcrmsg [options] [<TestName>] [<StoreFilename>][<CertNameString>]\n");
    printf("Options are:\n");
#ifdef CMS_PKCS7
    printf("  -AttrCert             - Add CMS attribute certificates\n");
    printf("  -Crl                  - Add CRLs\n");
    printf("  -EncapsulatedContent  - CMS encapsulated content\n");
    printf("  -OriginatorInfo       - CMS EnvelopedData OriginatorInfo\n");
    printf("  -KeyTrans             - CMS KeyTrans recipients\n");
    printf("  -KeyAgree             - CMS KeyAgree recipients\n");
    printf("  -MailList             - CMS MailList recipients\n");
    printf("  -RecipientKeyId       - Use KeyId for recipients\n");
    printf("  -CertInfoKeyId        - Use KeyId for encode CertInfo\n");
    printf("  -SignerId             - Use SignerId instead of CertInfo\n");
    printf("  -HashEncryptionAlgorithm - Use for first signer info\n");
    printf("  -NoSignature          - Use NO_SIGNATURE OID \n");
    printf("  -NoRecipients         - No Envelope Recipients\n");
    printf("  -AlgorithmParameters  - Algorithms have dummy parameters\n");
    printf("  -NoSalt               - NoSalt for RC4\n");
#endif  // CMS_PKCS7
    printf("  -h                    - This message\n");
    printf("  -A                    - Authenticated Attributes\n");
    printf("  -B                    - Bare content (no outer ContentInfo)\n");
    printf("  -c                    - no Certs\n");
    printf("  -C                    - non-data inner Content\n");
    printf("  -D                    - Detached Signature/Digest\n");
    printf("  -i                    - indefinite-length encoding\n");
    printf("  -l                    - print command Line\n");
    printf("  -M                    - MD5 hash algorithm\n");
    printf("  -n<size>              - Number of bytes in content\n");
    printf("  -N                    - No signers\n");
#ifdef CMS_PKCS7
    printf("  -NMultiple            - Multiple signers\n");
#endif  // CMS_PKCS7
    printf("  -p<provider#>         - Crypto Provider\n");
    printf("  -PEnhanced            - Use enhanced crypto provider\n");
    printf("  -PDefault             - Use default crypto provider\n");
#ifdef CMS_PKCS7
    printf("  -PRecipient           - Each recipient has a crypto provider\n");
    printf("  -PDSS                 - Use DSS provider for second signer\n");
    printf("  -PDSS_DH              - Use DSS_DH provider for second signer\n");
#endif  // CMS_PKCS7
    printf("  -P<ProviderName>      - Crypto provider Name\n");
    printf("  -K<ContainerName>     - Provider key container Name\n");
    printf("  -E<name>              - Encrypt algorithm, default of \"rc2\"\n");
    printf("  -e<EncryptBitLen>     - Encrypt key bit length\n");
    printf("  -I                    - Include IV in encrypt parameters\n");
    printf("  -s[ES]+               - list of stream message types\n");
    printf("  -S                    - add signer\n");
    printf("  -t                    - tiny streaming decode buffer\n");
    printf("  -v                    - verbose\n");
    printf("  -f<filename>          - Write encoded message to file\n");
    printf("\n");
    printf("Tests are (case insensitive name):\n");
    for (i = 0; i < NTESTS; i++)
        printf("  %s\n", Tests[i].pszName);
    printf("\n");
    printf("Default: ALL Tests\n");
}

HCRYPTPROV GetCryptProv(
    DWORD dwMyProvType = dwProvType,
    LPCSTR pszMyProvider = pszProvider
    )
{
    HCRYPTPROV hProv = 0;
    BOOL fResult;

    if (NULL == pszMyProvider) {
        if (fEnhanced) {
            if (PROV_RSA_FULL == dwMyProvType)
                pszMyProvider = MS_ENHANCED_PROV_A;
        }
    }

    fResult = CryptAcquireContextA(
                &hProv,
                pszContainer,
                pszMyProvider,
                dwMyProvType,
                fNoSignature ? CRYPT_VERIFYCONTEXT : 0  // dwFlags
                );
    if (fResult) {
        printf("Using default sign and xchg keys for provider type: %d",
            dwMyProvType);
        if (pszMyProvider && *pszMyProvider)
            printf(" provider: %s", pszMyProvider);
        if (pszContainer && *pszContainer)
            printf(" container: %s", pszContainer);
        printf("\n");
    } else {
        DWORD dwErr = GetLastError();
        if (dwErr == NTE_BAD_KEYSET) {

            // Need to create the keys
            printf("Generating SIGNATURE and EXCHANGE private keys\n");

            hProv = 0;
            fResult = CryptAcquireContextA(
                    &hProv,
                    pszContainer,
                    pszMyProvider,
                    dwMyProvType,
                    CRYPT_NEWKEYSET
                    );
            if (!fResult || hProv == 0) {
                PrintLastError("CryptAcquireContext");
                return 0;
            }

            HCRYPTKEY hKey = 0;
            fResult = CryptGenKey(
                    hProv,
                    AT_SIGNATURE,
                    CRYPT_EXPORTABLE,
                    &hKey
                    );
            if (!fResult || hKey == 0)
                PrintLastError("CryptGenKey(AT_SIGNATURE)");
            else
                CryptDestroyKey(hKey);

            hKey = 0;
            fResult = CryptGenKey(
                    hProv,
                    AT_KEYEXCHANGE,
                    CRYPT_EXPORTABLE,
                    &hKey
                    );
            if (!fResult || hKey == 0)
                PrintLastError("CryptGenKey(AT_KEYEXCHANGE)");
            else
                CryptDestroyKey(hKey);

        } else {
            PrintLastError("CryptAcquireContext");
            return 0;
        }
    }
    return hProv;
}


BOOL
GetNonStreamedMsgContent(
    IN  DWORD   cbContent,
    OUT PBYTE   *ppbContent,
    OUT DWORD   *pcbContent)
{
    BOOL    fRet;
    PBYTE   pbContent;
    PBYTE   pb;
    DWORD   cb;

    if (fInnerContent) {
    	if (!GetDERFromFile(
                pszInnerContentFileName,
                ppbContent,
                pcbContent))
            goto GetDERFromFileError;
    } else {
        if (NULL == (pbContent = (PBYTE)TestAlloc( cbContent)))
            goto AllocContentError;

        for (pb=pbContent, cb=0; cb < cbContent; pb++, cb++)
            *pb = rgbMsgContentFill[ cb%cbMsgContentFill];
        *ppbContent = pbContent;
        *pcbContent = cbContent;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    *ppbContent = NULL;
    *pcbContent = 0;
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(GetNonStreamedMsgContent,GetDERFromFileError)
PRINT_ERROR(GetNonStreamedMsgContent,AllocContentError)
}

PCCRYPT_OID_INFO GetOIDInfo(LPCSTR pszName, DWORD dwGroupId = 0)
{
    WCHAR wszName[256];
    PCCRYPT_OID_INFO pInfo;

    MultiByteToWideChar(
        CP_ACP,
        0,                      // dwFlags
        pszName,
        -1,                     // null terminated
        wszName,
        sizeof(wszName) / sizeof(wszName[0]));

    return CryptFindOIDInfo(
        CRYPT_OID_INFO_NAME_KEY,
        (void *) wszName,
        dwGroupId
        );
}

LPCSTR GetOID(LPCSTR pszName, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = GetOIDInfo(pszName, dwGroupId))
        return pInfo->pszOID;
    else
        return NULL;
}

ALG_ID GetAlgid(LPCSTR pszName, DWORD dwGroupId = 0)
{
    PCCRYPT_OID_INFO pInfo;

    if (pInfo = GetOIDInfo(pszName, dwGroupId))
        return pInfo->Algid;
    else
        return 0;
}

static HCERTSTORE OpenStore(LPCSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    HANDLE hFile = 0;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile(pszStoreFilename,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, OPEN_EXISTING, 0, NULL))) {
        printf( "can't open %s\n", pszStoreFilename);

        hStore = NULL;
    } else {
        hStore = CertOpenStore(
            CERT_STORE_PROV_FILE,
            dwCertEncodingType,
            0,                      // hProv
            0,                      // dwFlags
            hFile
            );
        CloseHandle(hFile);
    }

    if (hStore == NULL)
        PrintLastError("CertOpenStore");
    return hStore;
}

int _cdecl main(int argc, char * argv[])
{
    BOOL fResult;
    LPSTR pszTestName = NULL;
    int TestIdx = 0;
    LPSTR pszStoreFilename = NULL;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
#ifdef CMS_PKCS7
            if (0 == _stricmp(argv[0]+1, "AttrCert")) {
                cAttrCert = ATTR_CERT_COUNT;
            } else if (0 == _stricmp(argv[0]+1, "Crl")) {
                cSignedCrl = SIGNED_CRL_COUNT;
            } else if (0 == _stricmp(argv[0]+1, "EncapsulatedContent")) {
                fEncapsulatedContent = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "OriginatorInfo")) {
                fOriginatorInfo = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "KeyTrans")) {
                fKeyTrans = TRUE;
                fCmsRecipient = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "KeyAgree")) {
                fKeyAgree = TRUE;
                fCmsRecipient = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "MailList")) {
                fMailList = TRUE;
                fCmsRecipient = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "RecipientKeyId")) {
                fRecipientKeyId = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "CertInfoKeyId")) {
                fCertInfoKeyId = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "SignerId")) {
                fSignerId = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "HashEncryptionAlgorithm")) {
                fHashEncryptionAlgorithm = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NoSignature")) {
                fNoSignature = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NoRecipients")) {
                fNoRecipients = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "AlgorithmParameters")) {
                fAlgorithmParameters = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "NoSalt")) {
                fNoSalt = TRUE;
            } else {
#endif  // CMS_PKCS7
                switch(argv[0][1])
                {
                case 'A':
                    fAuthAttr = TRUE;
                    break;
                case 'B':
                    fBare = TRUE;
                    break;
                case 'c':
                    cSignedCert = 0;
                    break;
                case 'C':
                    fInnerContent = TRUE;
                    break;
                case 'D':
                    fDetached = TRUE;
                    break;
                case 'i':
                    fIndefinite = TRUE;
                    break;
                case 'l':
                    printf("command line: %s\n", GetCommandLine());
                    break;
                case 'M':
                    fMD5 = TRUE;
                    break;
                case 'n':
                    cbMsgContent = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'N':
#ifdef CMS_PKCS7
                    if (0 == _stricmp(argv[0]+2, "Multiple"))
                        fMultiSigner = TRUE;
                    else
#endif  // CMS_PKCS7
                        fNoSigners = TRUE;
                    break;
                case 'p':
                    dwProvType = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'P':
                    if (0 == _stricmp(argv[0]+2, "Enhanced"))
                        fEnhanced = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "Default"))
                        fDefaultVerifyProv = TRUE;
#ifdef CMS_PKCS7
                    else if (0 == _stricmp(argv[0]+2, "Recipient"))
                        fRecipientProv = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "DSS"))
                        dwMultiSignerProvType = PROV_DSS;
                    else if (0 == _stricmp(argv[0]+2, "DSS_DH"))
                        dwMultiSignerProvType = PROV_DSS_DH;
#endif  // CMS_PKCS7
                    else
                        pszProvider = argv[0]+2;
                    break;
                case 'K':
                    pszContainer = argv[0]+2;
                    break;
                case 'E':
                    pszEncryptName = argv[0]+2;
                    break;
                case 'e':
                    dwEncryptBitLen = strtoul( argv[0]+2, NULL, 0);
                    break;
                case 'I':
                    fEncryptIV = TRUE;
                    break;
                case 'R':
                    pszEncryptName = "rc4";
                    break;
                case 's':
                    pszStreamMsgTypes = argv[0]+2;
                    break;
                case 'S':
                    fAddSigner = TRUE;
                    break;
                case 't':
                    cbStreamDataDeltaDecode = 1;
                    break;
                case 'v':
                    fVerbose = TRUE;
                    break;
                case 'f':
                    pszFilename = argv[0]+2;
                    if (*pszFilename == '\0') {
                        printf("Need to specify filename\n");
                        Usage();
                        return -1;
                    }
                    break;
                case 'h':
                default:
                    Usage();
                    return -1;
                }
#ifdef CMS_PKCS7
            }
#endif  // CMS_PKCS7
        } else {
            if(pszTestName == NULL)
                pszTestName = argv[0];
            else if (pszStoreFilename == NULL)
                pszStoreFilename = argv[0];
            else if (pszCertNameFindStr == NULL)
                pszCertNameFindStr = argv[0];
            else {
                printf("Too many arguments\n");
                Usage();
                return -1;
            }
        }
    }

    if (fInnerContent && (cbMsgContent != DEFAULT_MSG_CONTENT_SIZE)) {
        printf( "-n and -C not compatible\n");
        return -1;
    }

    if (pszTestName) {
        for (TestIdx = 0; TestIdx < NTESTS; TestIdx++) {
            if (_stricmp(pszTestName, Tests[TestIdx].pszName) == 0)
                break;
        }
        if (TestIdx >= NTESTS) {
            printf("Bad TestName: %s\n", pszTestName);
            Usage();
            return -1;
        }

    } else
        TestIdx = 0;

    if (NULL == (pszEncryptOID = (LPSTR) GetOID(
            pszEncryptName, CRYPT_ENCRYPT_ALG_OID_GROUP_ID))) {
        printf("Failed => unknown encrypt name (%s)\n", pszEncryptName);
        return -1;
    }

    if (fDetached)      printf("Enabled: DetachedDigest/Signature\n");
    if (fNoSigners)     printf("Enabled: NoSigners\n");
    if (fAuthAttr)      printf("Enabled: Authenticated attributes\n");
    if (fInnerContent)  printf("Enabled: non-data Content\n");
    if (0 != _stricmp("rc2", pszEncryptName))
        printf("Enabled: %s\n", pszEncryptName);
    if (0 != dwEncryptBitLen)
        printf("Enabled: Encrypt bit length: %d\n", dwEncryptBitLen);
    if (fEncryptIV)     printf("Enabled: IV\n");
    if (fMD5)           printf("Enabled: MD5\n");
    if (pszFilename)    printf("Enabled: Writing encoded to file: %s\n", pszFilename);

    // Get crypto provider having both signature and exchange private keys
    hCryptProv = GetCryptProv();
    if (hCryptProv == 0)
        return -1;

    // Attempt to open the store
    if (pszStoreFilename) {
        hSignerStore = OpenStore(pszStoreFilename);
        if (NULL == hSignerStore)
            return -1;
    }

#ifdef CMS_PKCS7
    if (fKeyAgree) {
        hKeyAgreeProv = GetCryptProv(PROV_DSS_DH, NULL);

        if (hKeyAgreeProv == 0)
            return -1;
    }

    if (fMultiSigner) {
        hMultiSignerCryptProv = GetCryptProv(dwMultiSignerProvType, NULL);
        if (hMultiSignerCryptProv == 0)
            return -1;
    }
#endif  // CMS_PKCS7

    if (fDefaultVerifyProv) {
        printf("Using default hCryptProv for encrypting and verifying\n");
        hDefaultVerifyProv = 0;
    } else
        hDefaultVerifyProv = hCryptProv;

    for ( ; TestIdx < NTESTS; TestIdx++) {
        printf("Starting %s Test\n", Tests[TestIdx].pszName);
        fResult = Tests[TestIdx].pfn();
        if (fResult)
            printf("Passed\n");
        else
            printf("Failed\n");
        printf("\n");
        if (pszTestName)
            break;
    }

    TestFree( pbInnerContent);
    if (pNamedSigner)
        CertFreeCertificateContext(pNamedSigner);
    if (hSignerStore)
        CertCloseStore(hSignerStore, 0);

    return 0;
}



//+-------------------------------------------------------------------------
//  Functions for initializing message encode information
//--------------------------------------------------------------------------

static PCCERT_CONTEXT FindCertWithKey(
    IN HCERTSTORE hCertStore,
    IN DWORD dwKeySpec
    )
{
    PCCERT_CONTEXT pCert;
    void *pvFindPara;
    DWORD dwFindType;

    if (pszCertNameFindStr) {
        dwFindType = CERT_FIND_SUBJECT_STR_A;
        pvFindPara = (void *) pszCertNameFindStr;
    } else {
        dwFindType = CERT_FIND_ANY;
        pvFindPara = NULL;
    }

    // Find the first certificate in the store with a CRYPT_KEY_PROV_INFO
    // property matching the specified dwSignKeySpec, dwCryptProvType and
    // dwPubKeyBitLen
    pCert = NULL;
    while (TRUE) {
        pCert = CertFindCertificateInStore(
            hCertStore,
            dwCertEncodingType,
            0,                      // dwFindFlags,
            dwFindType,
            pvFindPara,
            pCert
            );
        if (pCert == NULL)
            break;

        PCRYPT_KEY_PROV_INFO pInfo = NULL;
        DWORD cbInfo = 0;
        CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbInfo
            );
        if (cbInfo >= sizeof(CRYPT_KEY_PROV_INFO) &&
                (pInfo = (PCRYPT_KEY_PROV_INFO) TestAlloc(cbInfo))) {
            BOOL fMatch = FALSE;
            if (CertGetCertificateContextProperty(
                        pCert,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        pInfo,
                        &cbInfo) && 
                    dwKeySpec == pInfo->dwKeySpec)
                fMatch = TRUE;
            TestFree(pInfo);
            if (fMatch)
                break;
        }
    }
    return pCert;
}


#ifdef CMS_PKCS7

static BYTE bZeroSerialNumber = 0;

//+-------------------------------------------------------------------------
//  Create a Special Issuer and SerialNumber from a KeyId.
//--------------------------------------------------------------------------
void CreateIssuerAndSerialNumberFromKeyId(
    IN const BYTE *pbKeyId,
    IN DWORD cbKeyId,
    IN OUT PCERT_INFO pCertInfo
    )
{
    CERT_RDN_ATTR KeyIdAttr;
    CERT_RDN KeyIdRDN;
    CERT_NAME_INFO IssuerInfo;

    KeyIdAttr.pszObjId = szOID_KEYID_RDN;
    KeyIdAttr.dwValueType = CERT_RDN_OCTET_STRING;
    KeyIdAttr.Value.pbData = (BYTE *) pbKeyId;
    KeyIdAttr.Value.cbData = cbKeyId;
    KeyIdRDN.cRDNAttr = 1;
    KeyIdRDN.rgRDNAttr = &KeyIdAttr;
    IssuerInfo.cRDN = 1;
    IssuerInfo.rgRDN = &KeyIdRDN;

    // Encode the special Issuer Name containing the KeyId
    AllocAndEncodeObject(
            X509_NAME,
            &IssuerInfo,
            &pCertInfo->Issuer.pbData,
            &pCertInfo->Issuer.cbData
            );

    pCertInfo->SerialNumber.cbData = 1;
    pCertInfo->SerialNumber.pbData = &bZeroSerialNumber;
}
#endif


void InitSignerEncodeInfo()
{
    DWORD cbSignerPublicKeyData;

    // Update the Issuer, SerialNumber and PublicKeyAlgorithm in
    // the signer's CERT_INFO
    memset(&rgSignerCertInfo[0], 0, sizeof(CERT_INFO));

#ifdef CMS_PKCS7
    if (fCertInfoKeyId) {
        CreateIssuerAndSerialNumberFromKeyId(
            (const BYTE *)"Signer 0",
            strlen("Signer 0"),
			&rgSignerCertInfo[0]
            );

        rgSignerId[0].dwIdChoice = CERT_ID_KEY_IDENTIFIER;
        rgSignerId[0].KeyId.pbData = (BYTE *)"Signer 0";
        rgSignerId[0].KeyId.cbData = strlen("Signer 0");
    } else {
#endif

	GetDERFromFile(
			pszSignerSerialNumberFileName,
			&rgSignerCertInfo[0].Issuer.pbData,
			&rgSignerCertInfo[0].Issuer.cbData);
    rgSignerCertInfo[0].SerialNumber.cbData = sizeof(DWORD);
    rgSignerCertInfo[0].SerialNumber.pbData = (BYTE *) &dwSignerSerialNumber;
#ifdef CMS_PKCS7
    rgSignerId[0].dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
    rgSignerId[0].IssuerSerialNumber.Issuer = rgSignerCertInfo[0].Issuer;
    rgSignerId[0].IssuerSerialNumber.SerialNumber =
        rgSignerCertInfo[0].SerialNumber;
    }
#endif

    if (!fNoSignature) {
        // Get crypt provider's public signature key. It will be used as the
        // signer's public key algorithm
        cbSignerPublicKeyData = sizeof(SignerPublicKeyData.Data);
        memset(SignerPublicKeyData.Data, 0, cbSignerPublicKeyData);
        CryptExportPublicKeyInfo(
            hCryptProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            (PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data,
            &cbSignerPublicKeyData);
        rgSignerCertInfo[0].SubjectPublicKeyInfo.Algorithm =
            ((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data)->Algorithm;
    }

    // Update the rgSignerEncodeInfo[0]
    memset(&rgSignerEncodeInfo[0], 0, sizeof(CMSG_SIGNER_ENCODE_INFO));
    rgSignerEncodeInfo[0].cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);
    rgSignerEncodeInfo[0].pCertInfo = &rgSignerCertInfo[0];
    rgSignerEncodeInfo[0].hCryptProv = hCryptProv;
    rgSignerEncodeInfo[0].HashAlgorithm =
        SignDigestAlgorithms[ fMD5 ? SIGNDIGEST_ALG_MD5 : SIGNDIGEST_ALG_SHA];
    rgSignerEncodeInfo[0].pvHashAuxInfo = NULL;
#ifdef CMS_PKCS7
    if (fAlgorithmParameters) {
        rgSignerEncodeInfo[0].HashAlgorithm.Parameters.pbData = rgbOctets;
        rgSignerEncodeInfo[0].HashAlgorithm.Parameters.cbData =
            sizeof(rgbOctets);
    }
#endif  // CMS_PKCS7

    if (fAuthAttr) {
        rgSignerEncodeInfo[0].cAuthAttr = AUTH_ATTR_COUNT;
        rgSignerEncodeInfo[0].rgAuthAttr = rgAuthAttr;

        if (!fCountersign) {
            rgSignerEncodeInfo[0].cUnauthAttr = UNAUTH_ATTR_COUNT;
            rgSignerEncodeInfo[0].rgUnauthAttr = rgUnauthAttr;
        }
    }

    if (hSignerStore) {
        pNamedSigner = FindCertWithKey(hSignerStore, AT_SIGNATURE);
        if (NULL == pNamedSigner) {
            PrintLastError("FindCertWithKey(AT_SIGNATURE)");
        } else {
            if (!CryptAcquireCertificatePrivateKey(
                    pNamedSigner,
                    0,                      // dwFlags
                    NULL,                   // pvReserved
                    &hNamedSignerCryptProv,
                    NULL,                   // pdwKeySpec,
                    NULL                    // pfCallerFreeProv
                    )) {
                PrintLastError("CryptAcquireCertificatePrivateKey");
                CertFreeCertificateContext(pNamedSigner);
                pNamedSigner = NULL;
            } else {
                rgSignerEncodeInfo[0].pCertInfo = pNamedSigner->pCertInfo;
                rgSignerEncodeInfo[0].hCryptProv = hNamedSignerCryptProv;
#ifdef CMS_PKCS7
                rgSignerId[0].dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
                rgSignerId[0].IssuerSerialNumber.Issuer =
                    rgSignerEncodeInfo[0].pCertInfo->Issuer;
                rgSignerId[0].IssuerSerialNumber.SerialNumber =
                    rgSignerEncodeInfo[0].pCertInfo->SerialNumber;
#endif  // CMS_PKCS7
            }
        }
    }

#ifdef CMS_PKCS7
    if (fNoSignature) {
        rgSignerEncodeInfo[0].HashEncryptionAlgorithm.pszObjId =
            szOID_PKIX_NO_SIGNATURE;
    } else if (fHashEncryptionAlgorithm) {
        if (pNamedSigner)
            rgSignerEncodeInfo[0].HashEncryptionAlgorithm =
                pNamedSigner->pCertInfo->SignatureAlgorithm;
        else
            rgSignerEncodeInfo[0].HashEncryptionAlgorithm =
                rgSignerCertInfo[0].SubjectPublicKeyInfo.Algorithm;

        if (fAlgorithmParameters &&
                0 == rgSignerEncodeInfo[0].HashEncryptionAlgorithm.Parameters.cbData)
        {
            rgSignerEncodeInfo[0].HashEncryptionAlgorithm.Parameters.pbData =
                rgbOctets;
            rgSignerEncodeInfo[0].HashEncryptionAlgorithm.Parameters.cbData =
                sizeof(rgbOctets);
        }
    }

    if (fMultiSigner) {
        // Update the Issuer, SerialNumber and PublicKeyAlgorithm in
        // the signer's CERT_INFO
        memset(&rgSignerCertInfo[1], 0, sizeof(CERT_INFO));

        if (fCertInfoKeyId) {
            CreateIssuerAndSerialNumberFromKeyId(
                (const BYTE *)"Signer 1",
                strlen("Signer 1"),
                &rgSignerCertInfo[1]
                );

            rgSignerId[1].dwIdChoice = CERT_ID_KEY_IDENTIFIER;
            rgSignerId[1].KeyId.pbData = (BYTE *)"Signer 1";
            rgSignerId[1].KeyId.cbData = strlen("Signer 1");
        } else {
            GetDERFromFile(
                    pszSignerSerialNumberFileName,
                    &rgSignerCertInfo[1].Issuer.pbData,
                    &rgSignerCertInfo[1].Issuer.cbData);
            rgSignerCertInfo[1].SerialNumber.cbData = sizeof(DWORD);
            rgSignerCertInfo[1].SerialNumber.pbData =
                (BYTE *) &dwSignerSerialNumber1;

            rgSignerId[1].dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
            rgSignerId[1].IssuerSerialNumber.Issuer =
                rgSignerCertInfo[1].Issuer;
            rgSignerId[1].IssuerSerialNumber.SerialNumber =
                rgSignerCertInfo[1].SerialNumber;
        }


        if (!fNoSignature) {
            // Get crypt provider's public signature key. It will be used as the
            // signer's public key algorithm
            cbSignerPublicKeyData = sizeof(MultiSignerPublicKeyData.Data);
            memset(MultiSignerPublicKeyData.Data, 0, cbSignerPublicKeyData);
            CryptExportPublicKeyInfo(
                hMultiSignerCryptProv,
                AT_SIGNATURE,
                X509_ASN_ENCODING,
                (PCERT_PUBLIC_KEY_INFO) MultiSignerPublicKeyData.Data,
                &cbSignerPublicKeyData);
            rgSignerCertInfo[1].SubjectPublicKeyInfo.Algorithm =
                ((PCERT_PUBLIC_KEY_INFO) MultiSignerPublicKeyData.Data)->Algorithm;
        }

        // Update the rgSignerEncodeInfo[1]
        memset(&rgSignerEncodeInfo[1], 0, sizeof(CMSG_SIGNER_ENCODE_INFO));
        rgSignerEncodeInfo[1].cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);
        rgSignerEncodeInfo[1].pCertInfo = &rgSignerCertInfo[1];
        rgSignerEncodeInfo[1].hCryptProv = hMultiSignerCryptProv;
        rgSignerEncodeInfo[1].HashAlgorithm =
            SignDigestAlgorithms[SIGNDIGEST_ALG_SHA];
        rgSignerEncodeInfo[1].pvHashAuxInfo = NULL;

        if (fNoSignature) {
            rgSignerEncodeInfo[1].HashEncryptionAlgorithm.pszObjId =
                szOID_PKIX_NO_SIGNATURE;
        }

        if (fAuthAttr) {
            rgSignerEncodeInfo[1].cAuthAttr = AUTH_ATTR_COUNT;
            rgSignerEncodeInfo[1].rgAuthAttr = rgAuthAttr;

            if (!fCountersign) {
                rgSignerEncodeInfo[1].cUnauthAttr = UNAUTH_ATTR_COUNT;
                rgSignerEncodeInfo[1].rgUnauthAttr = rgUnauthAttr;
            }
        }

        if (fSignerId)
            rgSignerEncodeInfo[1].SignerId = rgSignerId[1];
    }

    if (fSignerId) {
        rgSignerEncodeInfo[0].SignerId = rgSignerId[0];
        if (fHashEncryptionAlgorithm)
            rgSignerEncodeInfo[0].pCertInfo = NULL;
    }
#endif  // CMS_PKCS7

}

void CleanupSignerEncodeInfo()
{
	free( rgSignerCertInfo[0].Issuer.pbData);
#ifdef CMS_PKCS7
    if (fMultiSigner)
        free( rgSignerCertInfo[1].Issuer.pbData);
#endif  // CMS_PKCS7
}

void InitSignedCertAndCrl()
{
    DWORD i;

#ifdef CMS_PKCS7
    if (rgSignedCertBlob[0].pbData)
        return;
#endif  // CMS_PKCS7

    for (i = 0; i < SIGNED_CERT_COUNT; i++) {
    	GetDERFromFile(
            rgpszSignedCertFileName[i],
            &rgSignedCertBlob[i].pbData,
            &rgSignedCertBlob[i].cbData);
    }
#ifdef CMS_PKCS7
    for (i = 0; i < SIGNED_CRL_COUNT; i++) {
    	GetDERFromFile(
            rgpszSignedCrlFileName[i],
            &rgSignedCrlBlob[i].pbData,
            &rgSignedCrlBlob[i].cbData);
    }

    for (i = 0; i < ATTR_CERT_COUNT; i++) {
    	GetDERFromFile(
            rgpszAttrCertFileName[i],
            &rgAttrCertBlob[i].pbData,
            &rgAttrCertBlob[i].cbData);
    }
#endif  // CMS_PKCS7
}

void CleanupSignedCertAndCrl()
{
    DWORD i;

    for (i = 0; i < SIGNED_CERT_COUNT; i++) {
        if (rgSignedCertBlob[i].pbData) {
            free( rgSignedCertBlob[i].pbData);
            rgSignedCertBlob[i].pbData = NULL;
        }
    }

#ifdef CMS_PKCS7
    for (i = 0; i < SIGNED_CRL_COUNT; i++) {
        if (rgSignedCrlBlob[i].pbData) {
            free( rgSignedCrlBlob[i].pbData);
            rgSignedCrlBlob[i].pbData = NULL;
        }
    }

    for (i = 0; i < ATTR_CERT_COUNT; i++) {
        if (rgAttrCertBlob[i].pbData) {
            free( rgAttrCertBlob[i].pbData);
            rgAttrCertBlob[i].pbData = NULL;
        }
    }
#endif  // CMS_PKCS7
}

void InitSignedMsgEncodeInfo(
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    )
{
    InitSignerEncodeInfo();
    pSignedMsgEncodeInfo->cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);
    pSignedMsgEncodeInfo->cSigners = fNoSigners ? 0 : 1;
#ifdef CMS_PKCS7
    if (fMultiSigner)
        pSignedMsgEncodeInfo->cSigners = 2;
#endif  // CMS_PKCS7
    pSignedMsgEncodeInfo->rgSigners = &rgSignerEncodeInfo[0];
    InitSignedCertAndCrl();
    pSignedMsgEncodeInfo->cCertEncoded = cSignedCert;
    pSignedMsgEncodeInfo->rgCertEncoded = rgSignedCertBlob;
#ifdef CMS_PKCS7
    pSignedMsgEncodeInfo->cCrlEncoded = cSignedCrl;
    pSignedMsgEncodeInfo->rgCrlEncoded = rgSignedCrlBlob;
#else
    pSignedMsgEncodeInfo->cCrlEncoded = 0;
    pSignedMsgEncodeInfo->rgCrlEncoded = NULL;
#endif
#ifdef CMS_PKCS7
    pSignedMsgEncodeInfo->cAttrCertEncoded = cAttrCert;
    pSignedMsgEncodeInfo->rgAttrCertEncoded = rgAttrCertBlob;
#endif  // CMS_PKCS7
}

void CleanupSignedMsgEncodeInfo(
    IN PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    )
{
    CleanupSignerEncodeInfo();
    CleanupSignedCertAndCrl();
}

void InitRecipientEncodeInfo()
{
    DWORD cbRecipientPublicKeyData;
    int i;

    // Get crypt provider's public exchange key. It will be used as the
    // recipient's public key
    cbRecipientPublicKeyData = sizeof(RecipientPublicKeyData.Data);
    memset(RecipientPublicKeyData.Data, 0, cbRecipientPublicKeyData);
    CryptExportPublicKeyInfo(
        hCryptProv,
        AT_KEYEXCHANGE,
        X509_ASN_ENCODING,
        (PCERT_PUBLIC_KEY_INFO) RecipientPublicKeyData.Data,
        &cbRecipientPublicKeyData);

    // Update the Issuer, SerialNumber, PublicKey and PublicKeyAlgorithm
    // for each recipient. Update the rgpRecipientCertInfo[].
    for (i = 0; i < RECIPIENT_COUNT; i++) {
        memset(&rgRecipientCertInfo[i], 0, sizeof(CERT_INFO));

#ifdef CMS_PKCS7
        if (fCertInfoKeyId) {
            CreateIssuerAndSerialNumberFromKeyId(
                (const BYTE *)rgpszRecipientIssuerFileName[i],
                strlen(rgpszRecipientIssuerFileName[i]),
                &rgRecipientCertInfo[i]
                );
        } else {
#endif
	    GetDERFromFile(
            rgpszRecipientIssuerFileName[i],
            &rgRecipientCertInfo[i].Issuer.pbData,
            &rgRecipientCertInfo[i].Issuer.cbData);
        rgRecipientCertInfo[i].SerialNumber.cbData = sizeof(DWORD);
        rgRecipientCertInfo[i].SerialNumber.pbData =
            (BYTE *) &rgdwRecipientSerialNumber[i];

#ifdef CMS_PKCS7
        }
#endif

        rgRecipientCertInfo[i].SubjectPublicKeyInfo = 
            *((PCERT_PUBLIC_KEY_INFO) RecipientPublicKeyData.Data);

        if (0 == i)
            rgRecipientCertInfo[i].SubjectPublicKeyInfo.Algorithm.pszObjId =
                szOID_OIWSEC_rsaXchg;

        rgpRecipientCertInfo[i] = &rgRecipientCertInfo[i];
    }
}

void CleanupRecipientEncodeInfo()
{
    int i;

    for (i = 0; i < RECIPIENT_COUNT; i++)
        free( rgRecipientCertInfo[i].Issuer.pbData);
}

#ifdef CMS_PKCS7

HCRYPTKEY
WINAPI
GenerateMailListKey(
    IN HCRYPTPROV hProv,
    IN PCRYPT_DATA_BLOB pKeyId
    )
{
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hDeriveKey = 0;
    ALG_ID AlgId;

    // Generate derive key to use to encrypt and export the content encrypt key
    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash)) {
        PrintLastError("CryptCreateHash");
        goto ErrorReturn;
    }
    if (!CryptHashData(hHash, pKeyId->pbData, pKeyId->cbData, 0)) {
        PrintLastError("CryptHashData");
        goto ErrorReturn;
    }

    if (0 == _stricmp(pszEncryptName, "rc2"))
        AlgId = CALG_RC2;
    else
        AlgId = CALG_3DES;
    if (!CryptDeriveKey(hProv, AlgId, hHash, 0, &hDeriveKey)) {
        PrintLastError("CryptDeriveKey");
        goto ErrorReturn;
    }

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    return hDeriveKey;
ErrorReturn:
    goto CommonReturn;
}

void InitCmsRecipientEncodeInfo(
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo;
    DWORD cbRecipientPublicKeyData;
    DWORD i;
    DWORD cRecipients = 0;

    // Get crypt provider's public exchange key. It will be used as the
    // recipient's public key
    cbRecipientPublicKeyData = sizeof(RecipientPublicKeyData.Data);
    memset(RecipientPublicKeyData.Data, 0, cbRecipientPublicKeyData);
    CryptExportPublicKeyInfo(
        hCryptProv,
        AT_KEYEXCHANGE,
        X509_ASN_ENCODING,
        (PCERT_PUBLIC_KEY_INFO) RecipientPublicKeyData.Data,
        &cbRecipientPublicKeyData);
    pPublicKeyInfo = (PCERT_PUBLIC_KEY_INFO) RecipientPublicKeyData.Data;

    if (fKeyTrans && fRecipientKeyId) {
        PkcsRecipientCount = RECIPIENT_COUNT * 2;

        for (i = 0; i < RECIPIENT_COUNT; i++) {
            PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans =
                &rgKeyTrans[cRecipients];

            rgCmsRecipient[cRecipients].dwRecipientChoice =
                CMSG_KEY_TRANS_RECIPIENT;
            rgCmsRecipient[cRecipients].pKeyTrans = pKeyTrans;

            memset(pKeyTrans, 0, sizeof(*pKeyTrans));
            pKeyTrans->cbSize = sizeof(*pKeyTrans);
            pKeyTrans->KeyEncryptionAlgorithm = pPublicKeyInfo->Algorithm;
            // pKeyTrans->pvKeyEncryptionAuxInfo =
            // pKeyTrans->hCryptProv =
            pKeyTrans->RecipientPublicKey = pPublicKeyInfo->PublicKey;
            pKeyTrans->RecipientId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
            pKeyTrans->RecipientId.KeyId.pbData = 
                (PBYTE) rgpszRecipientIssuerFileName[i];
            pKeyTrans->RecipientId.KeyId.cbData = 
                strlen(rgpszRecipientIssuerFileName[i]);

            cRecipients++;
        }
    }

    if (fKeyTrans) {
        for (i = 0; i < RECIPIENT_COUNT; i++) {
            PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans =
                &rgKeyTrans[cRecipients];

            rgCmsRecipient[cRecipients].dwRecipientChoice =
                CMSG_KEY_TRANS_RECIPIENT;
            rgCmsRecipient[cRecipients].pKeyTrans = pKeyTrans;

            memset(pKeyTrans, 0, sizeof(*pKeyTrans));
            pKeyTrans->cbSize = sizeof(*pKeyTrans);
            pKeyTrans->KeyEncryptionAlgorithm = pPublicKeyInfo->Algorithm;
            // pKeyTrans->pvKeyEncryptionAuxInfo =
            // pKeyTrans->hCryptProv =
            pKeyTrans->RecipientPublicKey = pPublicKeyInfo->PublicKey;
            pKeyTrans->RecipientId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
            GetDERFromFile(
                rgpszRecipientIssuerFileName[i],
                &pKeyTrans->RecipientId.IssuerSerialNumber.Issuer.pbData,
                &pKeyTrans->RecipientId.IssuerSerialNumber.Issuer.cbData
                );
            pKeyTrans->RecipientId.IssuerSerialNumber.SerialNumber.cbData =
                sizeof(DWORD);
            pKeyTrans->RecipientId.IssuerSerialNumber.SerialNumber.pbData =
                (BYTE *) &rgdwRecipientSerialNumber[i];

            if (fRecipientProv)
                pKeyTrans->hCryptProv = GetCryptProv();

            cRecipients++;
        }
    }

    if (fKeyAgree) {
        void *pvStructInfo;
        DWORD cbStructInfo;

        cbRecipientPublicKeyData = sizeof(KeyAgreePublicKeyData.Data);
        memset(KeyAgreePublicKeyData.Data, 0, cbRecipientPublicKeyData);
        CryptExportPublicKeyInfo(
            hKeyAgreeProv,
            AT_KEYEXCHANGE,
            X509_ASN_ENCODING,
            (PCERT_PUBLIC_KEY_INFO) KeyAgreePublicKeyData.Data,
            &cbRecipientPublicKeyData);
        pPublicKeyInfo = (PCERT_PUBLIC_KEY_INFO) KeyAgreePublicKeyData.Data;

        // Check that we can decode both as X509_DH_PARAMETERS and
        // X942_DH_PARAMETERS
        AllocAndDecodeObject(
            X509_DH_PARAMETERS,
            pPublicKeyInfo->Algorithm.Parameters.pbData,
            pPublicKeyInfo->Algorithm.Parameters.cbData,
            &pvStructInfo,
            &cbStructInfo
            );
        TestFree(pvStructInfo);
        AllocAndDecodeObject(
            X942_DH_PARAMETERS,
            pPublicKeyInfo->Algorithm.Parameters.pbData,
            pPublicKeyInfo->Algorithm.Parameters.cbData,
            &pvStructInfo,
            &cbStructInfo
            );
        TestFree(pvStructInfo);

        for (i = 0; i < RECIPIENT_COUNT; i++) {
            PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgree =
                &rgKeyAgree[cRecipients];
            PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO pEncryptedKey =
                &rgEncryptedKey[i];

            rgCmsRecipient[cRecipients].dwRecipientChoice =
                CMSG_KEY_AGREE_RECIPIENT;
            rgCmsRecipient[cRecipients].pKeyAgree = pKeyAgree;

            memset(pKeyAgree, 0, sizeof(*pKeyAgree));
            pKeyAgree->cbSize = sizeof(*pKeyAgree);

            pKeyAgree->KeyEncryptionAlgorithm.pszObjId =
                szOID_RSA_SMIMEalgESDH;

            if (0 == _stricmp(pszEncryptName, "rc2")) {
                pKeyAgree->KeyWrapAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMSRC2wrap;

                // Update pvKeyWrapAuxInfo or KeyWrapAlgorithm
                // Parameters
                if (0 != dwEncryptBitLen) {
                    if (0 == i) {
                        int iVersion;

                        switch (dwEncryptBitLen) {
                            case 40:
                                iVersion = CRYPT_RC2_40BIT_VERSION;
                                break;
                            case 56:
                                iVersion = CRYPT_RC2_56BIT_VERSION;
                                break;
                            case 64:
                                iVersion = CRYPT_RC2_64BIT_VERSION;
                                break;
                            case 128:
                                iVersion = CRYPT_RC2_128BIT_VERSION;
                                break;
                            default:
                                printf("Failed => unknown RC2 length (%d)\n", dwEncryptBitLen);
                                iVersion = 0;
                        }

                        AllocAndEncodeObject(
                            X509_INTEGER,
                            &iVersion,
                            &pKeyAgree->KeyWrapAlgorithm.Parameters.pbData,
                            &pKeyAgree->KeyWrapAlgorithm.Parameters.cbData);
                    } else {
                        KeyAgreeRC2AuxInfo.cbSize = sizeof(KeyAgreeRC2AuxInfo);
                        KeyAgreeRC2AuxInfo.dwBitLen = dwEncryptBitLen;
                        pKeyAgree->pvKeyWrapAuxInfo =
                            &KeyAgreeRC2AuxInfo;
                    }
                }
            } else {
                pKeyAgree->KeyWrapAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMS3DESwrap;
            }

            if (fRecipientProv)
                pKeyAgree->hCryptProv = GetCryptProv(PROV_DSS_DH, NULL);


            pKeyAgree->dwKeyChoice = CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE;
            pKeyAgree->pEphemeralAlgorithm = &pPublicKeyInfo->Algorithm;

            if (1 == i) {
                pKeyAgree->UserKeyingMaterial.cbData =
                    strlen(pszUserKeyingMaterial);
                pKeyAgree->UserKeyingMaterial.pbData =
                    (BYTE *) pszUserKeyingMaterial;
            }

            pKeyAgree->cRecipientEncryptedKeys = i + 1;
            pKeyAgree->rgpRecipientEncryptedKeys = rgpEncryptedKey;

            rgpEncryptedKey[i] = pEncryptedKey;
            memset(pEncryptedKey, 0, sizeof(*pEncryptedKey));
            pEncryptedKey->cbSize = sizeof(*pEncryptedKey);
            pEncryptedKey->RecipientPublicKey = pPublicKeyInfo->PublicKey;

            if (fRecipientKeyId) {
                pEncryptedKey->RecipientId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
                pEncryptedKey->RecipientId.KeyId.pbData = 
                    (PBYTE) rgpszRecipientIssuerFileName[i];
                pEncryptedKey->RecipientId.KeyId.cbData = 
                    strlen(rgpszRecipientIssuerFileName[i]);

                if (1 == i) {
                    SYSTEMTIME st;

                    GetSystemTime(&st);
                    SystemTimeToFileTime(&st, &pEncryptedKey->Date);
                    pEncryptedKey->pOtherAttr = &KeyAgreeOtherAttr;
                }
            } else {
                pEncryptedKey->RecipientId.dwIdChoice =
                    CERT_ID_ISSUER_SERIAL_NUMBER;
                GetDERFromFile(
                    rgpszRecipientIssuerFileName[i],
                    &pEncryptedKey->RecipientId.IssuerSerialNumber.Issuer.pbData,
                    &pEncryptedKey->RecipientId.IssuerSerialNumber.Issuer.cbData
                    );
                pEncryptedKey->RecipientId.IssuerSerialNumber.SerialNumber.cbData =
                    sizeof(DWORD);
                pEncryptedKey->RecipientId.IssuerSerialNumber.SerialNumber.pbData =
                    (BYTE *) &rgdwRecipientSerialNumber[i];
            }

            cRecipients++;
        }
    }

    if (fMailList) {
        for (i = 0; i < RECIPIENT_COUNT; i++) {
            PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailList =
                &rgMailList[cRecipients];

            rgCmsRecipient[cRecipients].dwRecipientChoice =
                CMSG_MAIL_LIST_RECIPIENT;
            rgCmsRecipient[cRecipients].pMailList = pMailList;

            memset(pMailList, 0, sizeof(*pMailList));
            pMailList->cbSize = sizeof(*pMailList);

            if (0 == _stricmp(pszEncryptName, "rc2")) {
                pMailList->KeyEncryptionAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMSRC2wrap;

                // Update pvKeyEncryptionAuxInfo or KeyEncryptionAlgorithm
                // Parameters
                if (0 != dwEncryptBitLen) {
                    if (0 == i) {
                        int iVersion;

                        switch (dwEncryptBitLen) {
                            case 40:
                                iVersion = CRYPT_RC2_40BIT_VERSION;
                                break;
                            case 56:
                                iVersion = CRYPT_RC2_56BIT_VERSION;
                                break;
                            case 64:
                                iVersion = CRYPT_RC2_64BIT_VERSION;
                                break;
                            case 128:
                                iVersion = CRYPT_RC2_128BIT_VERSION;
                                break;
                            default:
                                printf("Failed => unknown RC2 length (%d)\n", dwEncryptBitLen);
                                iVersion = 0;
                        }

                        AllocAndEncodeObject(
                            X509_INTEGER,
                            &iVersion,
                            &pMailList->KeyEncryptionAlgorithm.Parameters.pbData,
                            &pMailList->KeyEncryptionAlgorithm.Parameters.cbData);
                    } else {
                        MailListRC2AuxInfo.cbSize = sizeof(MailListRC2AuxInfo);
                        MailListRC2AuxInfo.dwBitLen = dwEncryptBitLen;
                        pMailList->pvKeyEncryptionAuxInfo =
                            &MailListRC2AuxInfo;
                    }
                }
            } else {
                pMailList->KeyEncryptionAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMS3DESwrap;
            }

            pMailList->KeyId.pbData = 
                (PBYTE) rgpszRecipientIssuerFileName[i];
            pMailList->KeyId.cbData = 
                strlen(rgpszRecipientIssuerFileName[i]);

            if (fRecipientProv)
                pMailList->hCryptProv = GetCryptProv();
            else
                pMailList->hCryptProv = hCryptProv;
            pMailList->dwKeyChoice = CMSG_MAIL_LIST_HANDLE_KEY_CHOICE;
            pMailList->hKeyEncryptionKey = GenerateMailListKey(
                pMailList->hCryptProv,
                &pMailList->KeyId
                );

            if (0 != i) {
                SYSTEMTIME st;
                GetSystemTime(&st);
                SystemTimeToFileTime(&st, &pMailList->Date);

                pMailList->pOtherAttr = &MailListOtherAttr;
            }

            cRecipients++;
        }
    }

    pEnvelopedMsgEncodeInfo->cRecipients = cRecipients;
    cCmsRecipients = cRecipients;
    pEnvelopedMsgEncodeInfo->rgpRecipients = NULL;
    pEnvelopedMsgEncodeInfo->rgCmsRecipients = rgCmsRecipient;
    fNoRecipients = FALSE;
}

void CleanupCmsRecipientEncodeInfo()
{
    DWORD i;

    for (i = 0; i < cCmsRecipients; i++) {
        switch (rgCmsRecipient[i].dwRecipientChoice) {
            case CMSG_KEY_TRANS_RECIPIENT:
                {
                    PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans =
                        &rgKeyTrans[i];
                    if (CERT_ID_ISSUER_SERIAL_NUMBER ==
                            pKeyTrans->RecipientId.dwIdChoice)
                        free(pKeyTrans->RecipientId.IssuerSerialNumber.Issuer.pbData);
                    if (pKeyTrans->hCryptProv)
                        CryptReleaseContext(pKeyTrans->hCryptProv, 0);
                }
                break;
            case CMSG_KEY_AGREE_RECIPIENT:
                {
                    PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgree =
                        &rgKeyAgree[i];

                    TestFree(
                        pKeyAgree->KeyEncryptionAlgorithm.Parameters.pbData);
                    TestFree(pKeyAgree->KeyWrapAlgorithm.Parameters.pbData);

                    if (pKeyAgree->hCryptProv)
                        CryptReleaseContext(pKeyAgree->hCryptProv, 0);
                }
                break;
            case CMSG_MAIL_LIST_RECIPIENT:
                {
                    PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailList =
                        &rgMailList[i];
                    TestFree(
                        pMailList->KeyEncryptionAlgorithm.Parameters.pbData);
                    if (pMailList->hCryptProv &&
                            pMailList->hCryptProv != hCryptProv)
                        CryptReleaseContext(pMailList->hCryptProv, 0);
                    if (pMailList->hKeyEncryptionKey)
                        CryptDestroyKey(pMailList->hKeyEncryptionKey);
                }
                break;
        }
    }

    if (fKeyAgree) {
        for (i = 0; i < RECIPIENT_COUNT; i++) {
            PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO pEncryptedKey =
                &rgEncryptedKey[i];

            if (CERT_ID_ISSUER_SERIAL_NUMBER ==
                    pEncryptedKey->RecipientId.dwIdChoice)
                free(pEncryptedKey->RecipientId.IssuerSerialNumber.Issuer.pbData);
        }
    }
}

#endif  // CMS_PKCS7

#define IV_LENGTH 8
static BOOL GetIV(BYTE rgbIV[IV_LENGTH])
{

    SYSTEMTIME st;
    GetSystemTime(&st);
    assert(IV_LENGTH == sizeof(FILETIME));
    SystemTimeToFileTime(&st, (LPFILETIME) rgbIV);
    return TRUE;
}

void InitEnvelopedMsgEncodeInfo(
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
    PCRYPT_OBJID_BLOB pAlgPara;

    InitRecipientEncodeInfo();

    pEnvelopedMsgEncodeInfo->cbSize = sizeof(CMSG_ENVELOPED_ENCODE_INFO);
    pEnvelopedMsgEncodeInfo->hCryptProv = hDefaultVerifyProv;
    pEnvelopedMsgEncodeInfo->pvEncryptionAuxInfo = NULL;
    pEnvelopedMsgEncodeInfo->cRecipients = fNoRecipients ? 0 : RECIPIENT_COUNT;
    pEnvelopedMsgEncodeInfo->rgpRecipients = rgpRecipientCertInfo;
#ifdef CMS_PKCS7
    if (fCmsRecipient)
        InitCmsRecipientEncodeInfo(pEnvelopedMsgEncodeInfo);

    if (fOriginatorInfo) {
        InitSignedCertAndCrl();
        pEnvelopedMsgEncodeInfo->cCertEncoded = cSignedCert;
        pEnvelopedMsgEncodeInfo->rgCertEncoded = rgSignedCertBlob;
        pEnvelopedMsgEncodeInfo->cCrlEncoded = cSignedCrl;
        pEnvelopedMsgEncodeInfo->rgCrlEncoded = rgSignedCrlBlob;
        pEnvelopedMsgEncodeInfo->cAttrCertEncoded = cAttrCert;
        pEnvelopedMsgEncodeInfo->rgAttrCertEncoded = rgAttrCertBlob;
    }

    if (fAuthAttr) {
        pEnvelopedMsgEncodeInfo->cUnprotectedAttr = AUTH_ATTR_COUNT;
        pEnvelopedMsgEncodeInfo->rgUnprotectedAttr = rgAuthAttr;
    }
#endif  // CMS_PKCS7

    pEnvelopedMsgEncodeInfo->ContentEncryptionAlgorithm.pszObjId =
        (LPSTR) pszEncryptOID;
    pAlgPara = &pEnvelopedMsgEncodeInfo->ContentEncryptionAlgorithm.Parameters;
    memset(pAlgPara, 0, sizeof(*pAlgPara));

    if (0 != dwEncryptBitLen && 0 == _stricmp(pszEncryptName, "rc2")) {
        CRYPT_RC2_CBC_PARAMETERS RC2Parameters;

        switch (dwEncryptBitLen) {
            case 40:
                RC2Parameters.dwVersion = CRYPT_RC2_40BIT_VERSION;
                break;
            case 56:
                RC2Parameters.dwVersion = CRYPT_RC2_56BIT_VERSION;
                break;
            case 64:
                RC2Parameters.dwVersion = CRYPT_RC2_64BIT_VERSION;
                break;
            case 128:
                RC2Parameters.dwVersion = CRYPT_RC2_128BIT_VERSION;
                break;
            default:
                printf("Failed => unknown RC2 length (%d)\n", dwEncryptBitLen);
                return;
        }
        RC2Parameters.fIV = fEncryptIV;
        if (fEncryptIV) {
            if (!GetIV(RC2Parameters.rgbIV))
                return;
        }

        if (!AllocAndEncodeObject(
                PKCS_RC2_CBC_PARAMETERS,
                &RC2Parameters,
                &pAlgPara->pbData,
                &pAlgPara->cbData))
            return;
    } else if (0 == _stricmp(pszEncryptName, "rc4")) {
        if (fEncryptIV) {
            CRYPT_DATA_BLOB Salt;
            DWORD i;

            for (i = 0; i < MAX_SALT_LEN; i++)
                rgbSalt[i] = (BYTE) i;

            Salt.cbData = MAX_SALT_LEN;
            Salt.pbData = rgbSalt;

            AllocAndEncodeObject(
                X509_OCTET_STRING,
                &Salt,
                &pAlgPara->pbData,
                &pAlgPara->cbData
                );
        } else if (0 != dwEncryptBitLen) {
            memset(&RC4AuxInfo, 0, sizeof(RC4AuxInfo));
            RC4AuxInfo.cbSize = sizeof(RC4AuxInfo);
            RC4AuxInfo.dwBitLen = dwEncryptBitLen;
            if (fNoSalt)
                RC4AuxInfo.dwBitLen |= CMSG_RC4_NO_SALT_FLAG;
            pEnvelopedMsgEncodeInfo->pvEncryptionAuxInfo = &RC4AuxInfo;
        }
    } else if (fEncryptIV) {
        BYTE rgbIV[IV_LENGTH];
        CRYPT_DATA_BLOB Data;

        Data.pbData = rgbIV;
        Data.cbData = sizeof(rgbIV);

        if (!GetIV(rgbIV))
            return;
        if (!AllocAndEncodeObject(
                X509_OCTET_STRING,
                &Data,
                &pAlgPara->pbData,
                &pAlgPara->cbData))
            return;
    }
}


void CleanupEnvelopedMsgEncodeInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
    TestFree(
        pEnvelopedMsgEncodeInfo->ContentEncryptionAlgorithm.Parameters.pbData);
    CleanupRecipientEncodeInfo();
#ifdef CMS_PKCS7
    if (fCmsRecipient)
        CleanupCmsRecipientEncodeInfo();
    if (fOriginatorInfo)
        CleanupSignedCertAndCrl();
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Add and delete items
//--------------------------------------------------------------------------
BOOL AddDelItems(
        IN HCRYPTMSG    hCryptMsg,
        IN DWORD        dwCountType,
        IN DWORD        dwAddAction,
        IN DWORD        dwDelAction,
        IN void const  *pvCtrlPara)
{
    BOOL    fRet;
    DWORD   cb;
    DWORD   cOrg;
    DWORD   cCurr;

    // Get the original count of items
    cb = sizeof(cOrg);
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwCountType,
            0,                              // dwIndex
            &cOrg,
            &cb))
        goto GetItemCountError;
    // Add an item
    if (!CryptMsgControl(
            hCryptMsg,
            0,                              // dwFlags
            dwAddAction,
            pvCtrlPara))
        goto AddItemError;
    // Check that the count of items has increased by 1
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwCountType,
            0,                              // dwIndex
            &cCurr,
            &cb))
        goto GetItemCountAddError;
    if (cCurr != (cOrg + 1))
        goto AddCountError;

    // Delete the item we just added.
    // Since new items get added to the tail, we use the count of items
    // prior to the add as the index of the new item.
    if (!CryptMsgControl(
            hCryptMsg,
            0,                              // dwFlags
            dwDelAction,
            &cOrg))
        goto DelItemError;
    // Check that the count of items is back to what it was
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwCountType,
            0,                              // dwIndex
            &cCurr,
            &cb))
        goto GetItemCountDelError;
    if (cCurr != cOrg)
        goto DelCountError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(AddDelItems,GetItemCountError)
PRINT_ERROR(AddDelItems,AddItemError)
PRINT_ERROR(AddDelItems,GetItemCountAddError)
PRINT_ERROR(AddDelItems,AddCountError)
PRINT_ERROR(AddDelItems,DelItemError)
PRINT_ERROR(AddDelItems,GetItemCountDelError)
PRINT_ERROR(AddDelItems,DelCountError)
}


//+-------------------------------------------------------------------------
//  Insert blob at the tail of a blob list
//--------------------------------------------------------------------------
BOOL
WINAPI
TCM_InsertTailBlob(
    IN OUT CBlobList    *pBlobList,
    IN PBYTE            pbIn,
    IN DWORD            cbIn)
{
    BOOL                    fRet;
    CBlobNode               *pnBlob = NULL;
    PBYTE                   pb = NULL;
    CRYPT_DATA_BLOB         blob;

    if (NULL == (pnBlob = new CBlobNode))
        goto NewCBlobNodeError;
    if (NULL == (pb = (PBYTE)TestAlloc( cbIn)))
        goto AllocError;
    memcpy( pb, pbIn, cbIn);
    blob.cbData = cbIn;
    blob.pbData = pb;
    pnBlob->SetData( &blob);
    pBlobList->InsertTail( pnBlob);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    TestFree( pb);
    goto CommonReturn;
PRINT_ERROR(TCM_InsertTailBlob,NewCBlobNodeError)
PRINT_ERROR(TCM_InsertTailBlob,AllocError)
}

#ifdef CMS_PKCS7
BOOL VerifyCerts(IN HCRYPTMSG hMsg);
BOOL VerifyUnprotectedAttr(IN HCRYPTMSG hMsg);
BOOL GetCmsRecipientInfoAndDecrypt(IN HCRYPTMSG hMsg);
#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
// Get message type, recipient info, and set the hProv needed to decrypt
// the message.
//--------------------------------------------------------------------------
BOOL StreamGetRecipientInfoAndSetHProv(
    IN HCRYPTMSG    hMsg,
    OUT PDWORD      pdwMsgType,
    OUT BOOL        *pfReady)
{
    BOOL                    fRet;
    PCERT_INFO              pRecipientInfo = NULL;
    DWORD                   cRecipient;
    DWORD                   cbData;
    DWORD                   dwIndex;
    CMSG_CTRL_DECRYPT_PARA  DecryptPara;        ZEROSTRUCT(DecryptPara);
    DWORD                   cbEnvelopeAlgorithm;
    DWORD                   cKeyIdRecipient;

    // Get the message type.
    cbData = sizeof(DWORD);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                      // dwIndex
            pdwMsgType,
            &cbData)) {
        if (GetLastError() != CRYPT_E_STREAM_MSG_NOT_READY)
            goto GetMessageTypeError;
        *pfReady = FALSE;
        goto SuccessReturn;
    }
    if (CMSG_ENVELOPED != *pdwMsgType) {
        *pfReady = TRUE;
        goto SuccessReturn;
    }

    // Get content encryption algorithm.
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_ENVELOPE_ALGORITHM_PARAM,
            0,                      // dwIndex
            NULL,
            &cbEnvelopeAlgorithm)) {
        if (GetLastError() != CRYPT_E_STREAM_MSG_NOT_READY)
            goto GetEnvelopeAlgorithmError;
        *pfReady = FALSE;
        goto SuccessReturn;
    }
    *pfReady = TRUE;

    // Get # of recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_RECIPIENT_COUNT_PARAM,
            0,                      // dwIndex
            &cRecipient,
            &cbData))
        goto GetRecipientCountError;
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_RECIPIENT_COUNT_PARAM,
            0,                      // dwIndex
            &cRecipient,
            cbData))
        goto CheckGetRecipientCountError;
    if (fNoRecipients) {
        if (cRecipient != 0)
            goto WrongRecipientCountError;
    } else {
        if (cRecipient != PkcsRecipientCount)
            goto WrongRecipientCountError;
    }

#ifdef CMS_PKCS7
    if (fKeyTrans && fRecipientKeyId && !fNoRecipients) {
        // The first RECIPIENT_COUNT recipients should be KeyId recipients
        cKeyIdRecipient = RECIPIENT_COUNT;

        // Get all the KeyId recipients and verify
        for (dwIndex = 0; dwIndex < RECIPIENT_COUNT; dwIndex++) {
            // Allocate and get the CERT_INFO containing the Special
            // KeyId RecipientId
            PCERT_NAME_INFO pKeyIdName = NULL;
            DWORD cbKeyIdName;

            pRecipientInfo = GetCertIdFromMsg(
                hMsg,
                CMSG_RECIPIENT_INFO_PARAM,
                dwIndex
                );

            if (pRecipientInfo == NULL)
                goto GetRecipientInfoError;

            if (pRecipientInfo->SerialNumber.cbData != 1 ||
                    *pRecipientInfo->SerialNumber.pbData != 0)
                PrintError("StreamGetRecipientInfoAndSetHProv::Bad KeyId SerialNumber");

            // Decode the Issuer Name. It should contain the special KeyId
            // RDN

            if (AllocAndDecodeObject(
                    X509_NAME,
                    pRecipientInfo->Issuer.pbData,
                    pRecipientInfo->Issuer.cbData,
                    (void **) &pKeyIdName,
                    &cbKeyIdName
                    )) {

                    if (pKeyIdName->cRDN != 1 ||
                            pKeyIdName->rgRDN[0].cRDNAttr != 1)
                        PrintError("StreamGetRecipientInfoAndSetHProv::Bad KeyId Issuer");
                    else {
                        PCERT_RDN_ATTR pAttr = pKeyIdName->rgRDN[0].rgRDNAttr;

                        if (0 != strcmp(pAttr->pszObjId, szOID_KEYID_RDN) ||
                                pAttr->dwValueType != CERT_RDN_OCTET_STRING ||
                                pAttr->Value.cbData !=
                                    strlen(rgpszRecipientIssuerFileName[dwIndex]) ||
                                0 != memcmp(pAttr->Value.pbData,
                                    rgpszRecipientIssuerFileName[dwIndex],
                                    pAttr->Value.cbData))
                            PrintError("StreamGetRecipientInfoAndSetHProv::Bad KeyId Issuer");
                    }

                TestFree(pKeyIdName);
            }

            TestFree(pRecipientInfo);
            pRecipientInfo = NULL;
        }
    } else
#endif  // CMS_PKCS7
        cKeyIdRecipient = 0;

    // Get all the non KeyId recipients and verify
    for (dwIndex = 0; dwIndex < cRecipient - cKeyIdRecipient; dwIndex++) {
        // Allocate and get the CERT_INFO containing the RecipientId
        // (Issuer and SerialNumber)
        if (NULL == (pRecipientInfo = GetCertIdFromMsg(
                                    hMsg,
                                    CMSG_RECIPIENT_INFO_PARAM,
                                    cKeyIdRecipient + dwIndex)))
            goto GetRecipientInfoError;
        if (pRecipientInfo->Issuer.cbData !=
                    rgRecipientCertInfo[dwIndex].Issuer.cbData ||
                memcmp(pRecipientInfo->Issuer.pbData,
                    rgRecipientCertInfo[dwIndex].Issuer.pbData,
                    pRecipientInfo->Issuer.cbData) != 0 ||
                pRecipientInfo->SerialNumber.cbData !=
                    rgRecipientCertInfo[dwIndex].SerialNumber.cbData ||
                memcmp(pRecipientInfo->SerialNumber.pbData,
                    rgRecipientCertInfo[dwIndex].SerialNumber.pbData,
                    pRecipientInfo->SerialNumber.cbData) != 0)
            goto BadRecipientInfoError;
        TestFree(pRecipientInfo);
        pRecipientInfo = NULL;
    }

#ifdef CMS_PKCS7
    if (fOriginatorInfo)
        VerifyCerts(hMsg);
    if (fCmsRecipient) {
        fRet = GetCmsRecipientInfoAndDecrypt(hMsg);
        goto CommonReturn;
    }
#endif  // CMS_PKCS7

    if (fNoRecipients)
        goto SuccessReturn;

    DecryptPara.cbSize = sizeof(DecryptPara);
    DecryptPara.hCryptProv = hCryptProv;
    DecryptPara.dwKeySpec = 0;
    DecryptPara.dwRecipientIndex = RECIPIENT_COUNT - 1;
    if (!CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_DECRYPT,
            &DecryptPara))
        goto SetDecryptParamError;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    TestFree(pRecipientInfo);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,GetEnvelopeAlgorithmError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,GetRecipientCountError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,CheckGetRecipientCountError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,WrongRecipientCountError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,GetRecipientInfoError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,BadRecipientInfoError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,SetDecryptParamError)
PRINT_ERROR(StreamGetRecipientInfoAndSetHProv,GetMessageTypeError)
}


//+-------------------------------------------------------------------------
//  Fill a buffer with content.
//--------------------------------------------------------------------------
BOOL
WINAPI
FillBufferWithContent(
        OUT PBYTE   pbData,
        IN DWORD    cbData)
{
    BOOL    fRet;
    PBYTE   pb;
    DWORD   cb;
    DWORD   i;

    if (fInnerContent) {
        if (!pbInnerContent) {
        	if (!GetDERFromFile(
                    pszInnerContentFileName,
                    &pbInnerContent,
                    &cbInnerContent))
                goto GetDERFromFileError;
        }
        if (iMsgContentOffset + cbData > cbInnerContent)
            goto RequestForTooMuchDataError;
        for (pb=pbData, cb=iMsgContentOffset, i=cbData; i>0; pb++, cb++, i--)
            *pb = pbInnerContent[ cb];
        iMsgContentOffset = cb;
    } else {
        for (pb=pbData, cb=iMsgContentOffset, i=cbData; i>0; pb++, cb++, i--)
            *pb = rgbMsgContentFill[ cb%cbMsgContentFill];
        iMsgContentOffset = cb%cbMsgContentFill;
    }

    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(FillBufferWithContent,GetDERFromFileError)
PRINT_ERROR(FillBufferWithContent,RequestForTooMuchDataError)
}


//+-------------------------------------------------------------------------
//  Compare a buffer with content.
//--------------------------------------------------------------------------
BOOL
WINAPI
BufferEqualsContent(
        IN PBYTE    pbData,
        IN DWORD    cbData)
{
    BOOL    fRet;
    PBYTE   pb;
    DWORD   cb;
    DWORD   i;

    if (fInnerContent) {
        if (iMsgContentOffset + cbData > cbInnerContent)
            goto RequestForTooMuchDataError;
        for (pb=pbData, cb=iMsgContentOffset, i=cbData; i>0; pb++, cb++, i--)
            if (*pb != pbInnerContent[ cb])
                goto InnerContentNotEqualError;
        iMsgContentOffset = cb;
    } else {
        for (pb=pbData, cb=iMsgContentOffset, i=cbData; i>0; pb++, cb++, i--)
            if (*pb != rgbMsgContentFill[ cb%cbMsgContentFill])
                goto ContentNotEqualError;
        iMsgContentOffset = cb%cbMsgContentFill;
    }

    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(BufferEqualsContent,RequestForTooMuchDataError)
PRINT_ERROR(BufferEqualsContent,InnerContentNotEqualError)
PRINT_ERROR(BufferEqualsContent,ContentNotEqualError)
}


//+-------------------------------------------------------------------------
//  Callback for streaming messages.
//--------------------------------------------------------------------------
BOOL
WINAPI
StreamCallback(
        IN const void *pvArg,
        IN BYTE *pbData,
        IN DWORD cbData,
        IN BOOL fFinal)
{
    BOOL            fRet;
    CStreamNode     *pnStream = (CStreamNode *)pvArg;
    BOOL            fEncoding = pnStream->Data()->fEncoding;
    CStreamNode     *pnStreamNbr;
    DWORD           cbWritten;

    pnStreamNbr = fEncoding ? pnStream->Prev() : pnStream->Next();
    if (pnStreamNbr) {
        if (!CryptMsgUpdate(
                pnStreamNbr->Data()->hMsg,
                pbData,
                cbData,
                fFinal))
            goto MsgUpdateError;
    } else {
        if (fEncoding) {
            if (!WriteFile(
                        hFileStream,
                        pbData,
                        cbData,
                        &cbWritten,
                        NULL) ||
                    (cbWritten != cbData))
                goto WriteFileError;
        } else {
            if (!WriteFile(
                        hFileStreamDecode,
                        pbData,
                        cbData,
                        &cbWritten,
                        NULL) ||
                    (cbWritten != cbData))
                goto WriteFileDecodeError;
        }
    }

    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(StreamCallback,MsgUpdateError)
PRINT_ERROR(StreamCallback,WriteFileError)
PRINT_ERROR(StreamCallback,WriteFileDecodeError)
}


//+-------------------------------------------------------------------------
//  Encodes and decodes the streamed message.
//--------------------------------------------------------------------------
BOOL StreamEncodeAndDecodeMsg()
{
    BOOL                fRet;
    CStreamNode         *pnStream = NULL;
    TEST_STREAM_DATA    tsd;                ZEROSTRUCT(tsd);
    PCMSG_STREAM_INFO   pstrmi = NULL;
    PBYTE               pb;
    DWORD               cb;
    LPSTR               psz;
    CHAR                ch;
    DWORD               dwMsgTypeEncodingPrev;
    LPSTR               pszFilenameEncoded = pszFilename ? pszFilename : pszStreamFileName;

    if (INVALID_HANDLE_VALUE == (hFileStream = CreateFile(
            pszFilenameEncoded,
            GENERIC_WRITE,
            0, 
            NULL, 
            CREATE_ALWAYS, 
            0, 
            NULL)))
        goto CreateFileError;

    for (psz=pszStreamMsgTypes, dwMsgTypeEncodingPrev=0; ch=*psz; psz++) {
        switch (ch) {
        case 'd':
        case 'D':
            tsd.dwMsgTypeEncoding   = CMSG_DATA;
            tsd.pvMsgEncodeInfo     = NULL;
            break;
        case 'e':
        case 'E':
            tsd.dwMsgTypeEncoding   = CMSG_ENVELOPED;
            tsd.pvMsgEncodeInfo     = &EnvelopedMsgEncodeInfo;
            break;
        case 's':
        case 'S':
            tsd.dwMsgTypeEncoding   = CMSG_SIGNED;
            tsd.pvMsgEncodeInfo     = &SignedMsgEncodeInfo;
            break;
        default:
            goto InvalidMsgTypeError;
        }
        tsd.dwEncodingType          = dwMsgEncodingType;

        tsd.dwEncodeFlags = 0;
        if ((psz != pszStreamMsgTypes) && (dwMsgTypeEncodingPrev != CMSG_DATA))
            tsd.dwEncodeFlags |= CMSG_BARE_CONTENT_FLAG;
        if (dwMsgTypeEncodingPrev == CMSG_ENVELOPED)
            tsd.dwEncodeFlags |= CMSG_CONTENTS_OCTETS_FLAG;
        if (fBare && (psz == pszStreamMsgTypes))
            tsd.dwEncodeFlags |= CMSG_BARE_CONTENT_FLAG;
#ifdef CMS_PKCS7
        if (fEncapsulatedContent)
            tsd.dwEncodeFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7

        tsd.dwDecodeFlags = 0;
        if (fBare && (psz == pszStreamMsgTypes))
            tsd.dwDecodeFlags |= CMSG_BARE_CONTENT_FLAG;

        if (NULL == (pstrmi = (PCMSG_STREAM_INFO)TestAllocZero(
                                        sizeof(CMSG_STREAM_INFO))))
            goto AllocTestStreamInfoError;
        tsd.pStreamInfo         = pstrmi;
        if (NULL == (pnStream = new CStreamNode))
            goto NewNodeError;
        pstrmi->cbContent       = CMSG_INDEFINITE_LENGTH;
        pstrmi->pfnStreamOutput = StreamCallback;
        pstrmi->pvArg           = pnStream;
        pnStream->SetData( &tsd);
        plistStream->InsertTail( pnStream);
        dwMsgTypeEncodingPrev = tsd.dwMsgTypeEncoding;
    }
    pstrmi = NULL;

    if (!StreamEncodeMsg())
        goto EncodeError;

    if (hFileStream != INVALID_HANDLE_VALUE) {
        CloseHandle( hFileStream);
        hFileStream = INVALID_HANDLE_VALUE;
    }

    if (!StreamDecodeMsg())
        goto DecodeError;

    fRet = TRUE;
CommonReturn:
    if (hFileStream != INVALID_HANDLE_VALUE)
        CloseHandle( hFileStream);
#ifndef SAVE_STREAM_FILES
    if (!pszFilename)
        DeleteFile( pszStreamFileName);
#endif // SAVE_STREAM_FILES
    TestFree( pstrmi);
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(StreamEncodeAndDecodeMsg,CreateFileError)
PRINT_ERROR(StreamEncodeAndDecodeMsg,NewNodeError)
PRINT_ERROR(StreamEncodeAndDecodeMsg,EncodeError)
PRINT_ERROR(StreamEncodeAndDecodeMsg,DecodeError)
PRINT_ERROR(StreamEncodeAndDecodeMsg,InvalidMsgTypeError)
PRINT_ERROR(StreamEncodeAndDecodeMsg,AllocTestStreamInfoError)
}


#ifdef CMS_PKCS7

BOOL VerifyEncodedSignerComputedHash(
    IN LPCSTR pszHdr,
    IN HCRYPTMSG hMsg,
    IN DWORD dwSignerIndex,
    IN PBYTE pbExpectedHash,
    IN DWORD cbExpectedHash
    )
{
    BOOL fResult;
    DWORD cbHash;
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD dwSrcIndex;

    if (fVerbose)
        printf("%s VerifyEncodedSignerComputedHash(Signer[%d])\n",
            pszHdr, dwSignerIndex);

    cbHash = sizeof(rgbHash);
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_COMPUTED_HASH_PARAM,
        dwSignerIndex,
        rgbHash,
        &cbHash
        );
    if (!fResult) {
        printf("%s VerifyEncodedSignerComputedHash::CryptMsgGetParam(Signer[%d])",
            pszHdr, dwSignerIndex);
        PrintLastError("");
    } else if (cbHash != cbExpectedHash ||
            0 != memcmp(rgbHash, pbExpectedHash, cbHash)) {
        fResult = FALSE;
        printf("%s VerifyEncodedSignerComputedHash:: failed => bad hash for Signer[%d]\n",
            pszHdr, dwSignerIndex);
    } else {
        TCM_CheckGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            dwSignerIndex,
            rgbHash,
            cbHash
            );
    }

    return fResult;
}

BOOL VerifyDecodedSignerComputedHash(
    IN LPCSTR pszHdr,
    IN HCRYPTMSG hMsg,
    IN BOOL fInnerNonData,
    IN DWORD dwSignerIndex,
    IN BYTE rgbExpectedHash[2][MAX_HASH_LEN],
    IN DWORD rgcbExpectedHash[2]
    )
{
    DWORD cbHash;
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD dwSrcIndex;

    if (fVerbose)
        printf("%s VerifyDecodedSignerComputedHash(Signer[%d])\n",
            pszHdr, dwSignerIndex);

    cbHash = sizeof(rgbHash);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            dwSignerIndex,
            rgbHash,
            &cbHash
            )) {
        printf("%s VerifyDecodedSignerComputedHash(before verify signature)::CryptMsgGetParam(Signer[%d])",
            pszHdr, dwSignerIndex);
        PrintLastError("");
        return FALSE;
    }

    if (pNamedSigner)
        dwSrcIndex = dwSignerIndex;
    else if (!GetSignerInfoAndVerify(
            hMsg,
            fInnerNonData,
            dwSignerIndex,
            &dwSrcIndex
            )) {
        printf("%s VerifyDecodedSignerComputedHash GetSignerInfoAndVerify(Signer[%d]):: failed\n",
            pszHdr, dwSignerIndex);
        return FALSE;
    }

    if (cbHash != rgcbExpectedHash[dwSrcIndex] ||
            0 != memcmp(rgbHash, rgbExpectedHash[dwSrcIndex], cbHash)) {
        printf("%s VerifyDecodedSignerComputedHash(before verify signature):: failed => unexpected hash for Signer[%d]\n",
            pszHdr, dwSignerIndex);
        return FALSE;
    }

    cbHash = sizeof(rgbHash);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            dwSignerIndex,
            rgbHash,
            &cbHash
            )) {
        printf("%s VerifyDecodedSignerComputedHash(after verify signature)::CryptMsgGetParam(Signer[%d])",
            pszHdr, dwSignerIndex);
        PrintLastError("");
        return FALSE;
    }

    if (cbHash != rgcbExpectedHash[dwSrcIndex] ||
            0 != memcmp(rgbHash, rgbExpectedHash[dwSrcIndex], cbHash)) {
        printf("%s VerifyDecodedSignerComputedHash(after verify signature):: failed => unexpected hash for Signer[%d]\n",
            pszHdr, dwSignerIndex);
        return FALSE;
    } else {
        TCM_CheckGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            dwSignerIndex,
            rgbHash,
            cbHash
            );
    }

    return TRUE;
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Encodes the streamed message.
//--------------------------------------------------------------------------
BOOL StreamEncodeMsg()
{
    BOOL                fRet;
    CStreamNode         *pnStream;
    PTEST_STREAM_DATA   ptsd;
    HCRYPTMSG           hMsg;
    PBYTE               pb;
    DWORD               cb;
    DWORD               cbRemain;
    BOOL                fFinal;
    DWORD               cbData;
    DWORD               cbDataInner;
    LPSTR               pszInnerContentType;

    if (fVerbose)
        printf( "Beginning stream encode\n");

    if (fInnerContent && !FillBufferWithContent( NULL, 0))  // load inner content
        goto NullFillBufferWithContentError;

    cbDataInner = fInnerContent ? cbInnerContent : cbMsgContent;

    if (fInnerContent &&
#ifdef CMS_PKCS7
            !fEncapsulatedContent &&
#endif  // CMS_PKCS7
            (plistStream->Tail()->Data()->dwMsgTypeEncoding == CMSG_ENVELOPED)) {
        if (!TCM_ExtractContent(
                pbInnerContent,
                cbInnerContent,
                &cbDataInner,
                NULL))                  // ppbContent
            goto ExtractContentError;
    }

    for (pnStream = plistStream->Tail(),
                cbData=cbDataInner,
                pszInnerContentType =
                                fInnerContent ? pszInnerContentObjId : NULL;
            pnStream;
            pnStream = pnStream->Prev()) {
        ptsd = pnStream->Data();
        ptsd->fEncoding = TRUE;
        ptsd->pStreamInfo->cbContent = fIndefinite ? CMSG_INDEFINITE_LENGTH : cbData;
        ptsd->pszInnerContentType = pszInnerContentType;
        if (NULL == (ptsd->hMsg = CryptMsgOpenToEncode(
                ptsd->dwEncodingType,
                ptsd->dwEncodeFlags,
                ptsd->dwMsgTypeEncoding,
                ptsd->pvMsgEncodeInfo,
                pszInnerContentType,
                ptsd->pStreamInfo)))
            goto OpenToEncodeError;
        // NB- from PKCS#7, sec.10.3:
        // An enveloped message encrypts only "the contents octets of a
        // definite-length BER encoding of the content field of the ContentInfo"
        // ie. The identifier and length octets are not included.
        // Ergo, we must ask for the size of the contents octets if the outer
        // message is enveloped.
        if (0 == (cbData = CryptMsgCalculateEncodedLength(
                ptsd->dwEncodingType,
                ptsd->dwEncodeFlags,
                ptsd->dwMsgTypeEncoding,
                ptsd->pvMsgEncodeInfo,
                pszInnerContentType,
                cbData)))
            goto CalculateEncodedLengthError;
        switch(ptsd->dwMsgTypeEncoding) {
        case CMSG_DATA:
            pszInnerContentType = szOID_RSA_data;
            break;
        case CMSG_ENVELOPED:
            pszInnerContentType = szOID_RSA_envelopedData;
            break;
        case CMSG_SIGNED:
            pszInnerContentType = szOID_RSA_signedData;
            break;
        default:
            goto InvalidMsgTypeError;
        }

#ifdef CMS_PKCS7
        if (ptsd->dwMsgTypeEncoding != CMSG_DATA &&
                (fVerbose || fEncapsulatedContent || cAttrCert ||
                    fOriginatorInfo || fCmsRecipient)) {
            BOOL fResult;
            DWORD dwVersion;
            DWORD cbData = sizeof(dwVersion);
            fResult = CryptMsgGetParam(
                ptsd->hMsg,
                CMSG_VERSION_PARAM,
                0,                      // dwIndex
                (PBYTE) &dwVersion,
                &cbData
                );
            if (!fResult)
                PrintLastError("StreamEncodeMsg::CryptMsgGetParam(CMSG_VERSION_PARAM)");
            else
                printf("StreamEncodeMsg(%d - %s) Version:: %d\n",
                    ptsd->dwMsgTypeEncoding, pszInnerContentType, dwVersion);
        }
#endif  // CMS_PKCS7
    }

    hMsg = plistStream->Tail()->Data()->hMsg;
    iMsgContentOffset = 0;
    cbRemain = fInnerContent ? cbInnerContent : cbMsgContent;
    if (0 == cbRemain) {
        if (!CryptMsgUpdate(
                hMsg,
                NULL,
                0,
                TRUE))
            goto UpdateError;
    } else {
        for ( ; cbRemain; cbRemain -= cb) {
            fFinal = (cbRemain <= cbStreamDataDeltaEncode);
            cb = fFinal ? cbRemain : cbStreamDataDeltaEncode;
            FillBufferWithContent( abStreamDataDeltaEncode, cb);
            if (!CryptMsgUpdate(
                    hMsg,
                    (PBYTE)abStreamDataDeltaEncode,
                    cb,
                    fFinal))
                goto UpdateError;
        }
    }

    for (pnStream = plistStream->Head();
            pnStream;
            pnStream = pnStream->Next()) {
        ptsd = pnStream->Data();

        cbData = 0;
        if (CryptMsgGetParam(
                ptsd->hMsg,
                CMSG_CONTENT_PARAM,
                0,                      // dwIndex
                NULL,                   // pvData
                &cbData
                ))
            PrintError("CryptMsgGetParam(CMSG_CONTENT_PARAM) succeeded for streaming");

#ifdef CMS_PKCS7
        if (CMSG_SIGNED == ptsd->dwMsgTypeEncoding && !fNoSigners) {
            DWORD i;
            DWORD c;

            if (fMultiSigner)
                c = 2;
            else
                c = 1;

            for (i = 0; i < c; i++) {
                ptsd->rgcbComputedHash[i] = sizeof(ptsd->rgbComputedHash[i]);
                if (!CryptMsgGetParam(
                        ptsd->hMsg,
                        CMSG_COMPUTED_HASH_PARAM,
                        i,                      // dwSignerIndex
                        ptsd->rgbComputedHash[i],
                        &ptsd->rgcbComputedHash[i]
                        )) {
                    printf("StreamEncodeMsg::CryptMsgGetParam(Signer[%d] CMSG_COMPUTED_HASH_PARAM)",
                        i);
                    PrintLastError("");
                } else
                    VerifyEncodedSignerComputedHash(
                        "StreamEncodeMsg", ptsd->hMsg, i,
                        ptsd->rgbComputedHash[i], ptsd->rgcbComputedHash[i]);
            }
        }
#endif  // CMS_PKCS7

        if (!CryptMsgClose(ptsd->hMsg))
            goto CloseError;
    }

    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(StreamEncodeMsg,NullFillBufferWithContentError)
PRINT_ERROR(StreamEncodeMsg,ExtractContentError)
PRINT_ERROR(StreamEncodeMsg,InvalidMsgTypeError)
PRINT_ERROR(StreamEncodeMsg,OpenToEncodeError)
PRINT_ERROR(StreamEncodeMsg,CalculateEncodedLengthError)
PRINT_ERROR(StreamEncodeMsg,UpdateError)
PRINT_ERROR(StreamEncodeMsg,CloseError)
}


//+-------------------------------------------------------------------------
//  Decodes the streamed message.
//--------------------------------------------------------------------------
BOOL StreamDecodeMsg()
{
    BOOL fRet;
    CStreamNode         *pnStream;
    PTEST_STREAM_DATA   ptsd;
    HCRYPTMSG           hMsg;
    PBYTE               pb;
    DWORD               cb;
    PBYTE               pbRemain;
    DWORD               cbRemain;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    PBYTE               pbRead = NULL;
    DWORD               cbRead;
    BOOL                fFinal;
    BOOL                fFirst;
    DWORD               cbFile;
    CBlobNode           *pnBlob;
    PCRYPT_DATA_BLOB    pblob;
    BOOL                fInnerNonData;
    DWORD               dwMsgTypeInner;
    LPSTR               pszFilenameEncoded = pszFilename ? pszFilename : pszStreamFileName;

    if (fVerbose)
        printf( "Beginning stream decode\n");

    if (NULL == (pbRead = (PBYTE)TestAlloc(cbStreamDataDeltaDecode)))
        goto AllocDecodeBufferError;

    // Open the messages
    for (pnStream = plistStream->Head();
            pnStream;
            pnStream = pnStream->Next()) {
        ptsd = pnStream->Data();
        ptsd->fEncoding = FALSE;
        fFirst = (NULL == pnStream->Prev());
        if (NULL == (ptsd->hMsg = CryptMsgOpenToDecode(
                ptsd->dwEncodingType,
                ptsd->dwDecodeFlags,
                ((fFirst && fBare) ||
                    (!fFirst && (CMSG_DATA != pnStream->Prev()->Data()->dwMsgTypeEncoding)))
                    ? ptsd->dwMsgTypeEncoding : 0,
                hDefaultVerifyProv,
                NULL,                   // pRecipientInfo
                ptsd->pStreamInfo)))
            goto OpenToDecodeError;
    }

    // Open the file containing the nested messages to decode
    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(
            pszFilenameEncoded,
            GENERIC_READ,
            0, 
            NULL, 
            OPEN_EXISTING, 
            0, 
            NULL)))
        goto CreateFileError;
    if (INVALID_FILE_SIZE == (cbFile = GetFileSize( hFile, NULL)))
        goto GetFileSizeError;

    // Create the file to hold the decoded data
    if (INVALID_HANDLE_VALUE == (hFileStreamDecode = CreateFile(
            pszFilenameDecode,
            GENERIC_WRITE,
            0, 
            NULL, 
            CREATE_ALWAYS, 
            0, 
            NULL)))
        goto CreateFileDecodeError;

    // Feed in the encoded nested messages in chunks
    hMsg = plistStream->Head()->Data()->hMsg;
    for (cbRemain=cbFile; cbRemain; cbRemain-=cbRead) {
        if (!ReadFile(
                hFile,
                pbRead,
                cbStreamDataDeltaDecode,
                &cbRead,
                NULL))              // lpOverlapped
            goto ReadFileError;
        fFinal = (cbRead == cbRemain);
        if (!CryptMsgUpdate(
                hMsg,
                pbRead,
                cbRead,
                fFinal))
            goto UpdateError;
        for (pnStream = plistStream->Head();
                pnStream;
                pnStream = pnStream->Next()) {
            ptsd = pnStream->Data();
            if (((0 == ptsd->dwMsgTypeDecoding) ||
                        (CMSG_ENVELOPED == ptsd->dwMsgTypeDecoding)) &&
                    !ptsd->fReady) {
                if (!StreamGetRecipientInfoAndSetHProv(
                        ptsd->hMsg,
                        &ptsd->dwMsgTypeDecoding,
                        &ptsd->fReady))
                    goto StreamGetRecipientInfoAndSetHProvError;
            }
        }
    }


    // Validate the message types
    for (pnStream = plistStream->Head();
            pnStream;
            pnStream = pnStream->Next()) {
        ptsd = pnStream->Data();
        if (ptsd->dwMsgTypeEncoding != ptsd->dwMsgTypeDecoding)
            goto MsgTypeMismatchError;
    }

    // Check signatures
    if (fVerbose)
        printf( "Verify signatures\n");
    for (pnStream = plistStream->Tail(), dwMsgTypeInner=CMSG_DATA;
            pnStream;
            pnStream = pnStream->Prev()) {
        ptsd = pnStream->Data();
        fInnerNonData = ((pnStream == plistStream->Tail()) && fInnerContent) ||
                        (dwMsgTypeInner != CMSG_DATA);

#ifdef CMS_PKCS7
        if (ptsd->dwMsgTypeDecoding != CMSG_DATA &&
                (fVerbose || fEncapsulatedContent || cAttrCert ||
                    fOriginatorInfo || fCmsRecipient)) {
            BOOL fResult;
            DWORD dwVersion;
            DWORD cbData = sizeof(dwVersion);
            fResult = CryptMsgGetParam(
                ptsd->hMsg,
                CMSG_VERSION_PARAM,
                0,                      // dwIndex
                (PBYTE) &dwVersion,
                &cbData
                );
            if (!fResult)
                PrintLastError("StreamDecodeMsg::CryptMsgGetParam(CMSG_VERSION_PARAM)");
            else
                printf("StreamDecodeMsg(%d) Version:: %d\n",
                    ptsd->dwMsgTypeDecoding, dwVersion);
        }

        if (fAuthAttr && CMSG_ENVELOPED == ptsd->dwMsgTypeDecoding)
            VerifyUnprotectedAttr(hMsg);

        if (CMSG_SIGNED == ptsd->dwMsgTypeDecoding && !fNoSigners) {
            DWORD i;
            DWORD c;

            if (fMultiSigner)
                c = 2;
            else
                c = 1;

            for (i = 0; i < c; i++) {
                VerifyDecodedSignerComputedHash(
                    "StreamDecodeMsg",
                    ptsd->hMsg,
                    fInnerNonData,
                    i,
                    ptsd->rgbComputedHash,
                    ptsd->rgcbComputedHash
                    );
            }
        }
#endif  // CMS_PKCS7

        if ((CMSG_SIGNED == ptsd->dwMsgTypeDecoding) &&
                !GetSignerInfoAndVerify( ptsd->hMsg, fInnerNonData))
            goto GetSignerInfoAndVerifyError;
        dwMsgTypeInner = ptsd->dwMsgTypeEncoding;
    }

    // Verify the data
    if (fVerbose)
        printf( "Verify data\n");
    if (INVALID_FILE_SIZE ==
            (cbFileDecode = GetFileSize( hFileStreamDecode, NULL)))
        goto GetFileSizeDecodeError;
    if (cbFileDecode != (fInnerContent ? cbInnerContent : cbMsgContent)) {
        if (fNoRecipients && 0 == cbFileDecode)
            ;
        else
            goto WrongDataSizeError;
    }
    CloseHandle( hFileStreamDecode);
    if (INVALID_HANDLE_VALUE == (hFileStreamDecode = CreateFile(
            pszFilenameDecode,
            GENERIC_READ,
            0, 
            NULL, 
            OPEN_EXISTING, 
            0, 
            NULL)))
        goto CreateFileDecodeReadError;
    iMsgContentOffset = 0;
    for (cbRemain=cbFileDecode; cbRemain; cbRemain-=cbRead) {
        if (!ReadFile(
                hFileStreamDecode,
                pbRead,
                cbStreamDataDeltaDecode,
                &cbRead,
                NULL))              // lpOverlapped
            goto ReadFileDecodeError;
        if (!BufferEqualsContent( pbRead, cbRead))
            goto WrongDataError;
    }

    // Close the messages
    if (fVerbose)
        printf( "Close messages\n");
    for (pnStream = plistStream->Head();
            pnStream;
            pnStream = pnStream->Next()) {

        DWORD cbData = 0;
        if (CryptMsgGetParam(
                pnStream->Data()->hMsg,
                CMSG_CONTENT_PARAM,
                0,                      // dwIndex
                NULL,                   // pvData
                &cbData
                ))
            PrintError("CryptMsgGetParam(CMSG_CONTENT_PARAM) succeeded for streaming");

        if (!CryptMsgClose( pnStream->Data()->hMsg))
            goto CloseError;
    }

    fRet = TRUE;
CommonReturn:
    TestFree( pbRead);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle( hFile);
    if (hFileStreamDecode != INVALID_HANDLE_VALUE)
        CloseHandle( hFileStreamDecode);
#ifndef SAVE_STREAM_FILES
    DeleteFile( pszFilenameDecode);
#endif // SAVE_STREAM_FILES
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
PRINT_ERROR(StreamDecodeMsg,AllocDecodeBufferError)
PRINT_ERROR(StreamDecodeMsg,UpdateError)
PRINT_ERROR(StreamDecodeMsg,GetFileSizeError)
PRINT_ERROR(StreamDecodeMsg,CreateFileError)
PRINT_ERROR(StreamDecodeMsg,ReadFileError)
PRINT_ERROR(StreamDecodeMsg,ReadFileDecodeError)
PRINT_ERROR(StreamDecodeMsg,OpenToDecodeError)
PRINT_ERROR(StreamDecodeMsg,StreamGetRecipientInfoAndSetHProvError)
PRINT_ERROR(StreamDecodeMsg,MsgTypeMismatchError)
PRINT_ERROR(StreamDecodeMsg,GetSignerInfoAndVerifyError)
PRINT_ERROR(StreamDecodeMsg,WrongDataSizeError)
PRINT_ERROR(StreamDecodeMsg,WrongDataError)
PRINT_ERROR(StreamDecodeMsg,CloseError)
PRINT_ERROR(StreamDecodeMsg,CreateFileDecodeError)
PRINT_ERROR(StreamDecodeMsg,GetFileSizeDecodeError)
PRINT_ERROR(StreamDecodeMsg,CreateFileDecodeReadError)
}


//+-------------------------------------------------------------------------
//  Encodes and decodes the message.
//--------------------------------------------------------------------------
BOOL EncodeAndDecodeMsg(
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo
    )
{
    BOOL fResult;

    BYTE *pbEncodedBlob;
    DWORD cbEncodedBlob;

    fResult = EncodeMsg(
        dwMsgType,
        pvMsgEncodeInfo,
        &pbEncodedBlob,
        &cbEncodedBlob
        );

    if (fResult) {
        if (pszFilename)
            TCM_WriteBufToFile( pszFilename, pbEncodedBlob, cbEncodedBlob);

        fResult = DecodeMsg(
            dwMsgType,
            pbEncodedBlob,
            cbEncodedBlob
            );

        TestFree(pbEncodedBlob);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Allocates and encodes the message.
//--------------------------------------------------------------------------
BOOL EncodeMsg(
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    OUT BYTE **ppbEncodedBlob,
    OUT DWORD *pcbEncodedBlob
    )
{
    BOOL    fResult;
    PBYTE   pbToBeEncoded;
    DWORD   cbToBeEncoded;
    PBYTE   pbInnerEncoded;
    DWORD   cbInnerEncoded;
    HCRYPTMSG hMsg = NULL;
    BYTE *pbEncodedBlob = NULL;
    DWORD cbEncodedBlobOrg;
    DWORD cbEncodedBlob;
    DWORD dwFlags = fBare ? CMSG_BARE_CONTENT_FLAG : 0;

    if (!GetNonStreamedMsgContent(
            cbMsgContent,
            &pbToBeEncoded,
            &cbToBeEncoded))
        goto GetNonStreamedMsgContentError;

    if (fInnerContent) {
        if (dwMsgType == CMSG_ENVELOPED
#ifdef CMS_PKCS7
                && !fEncapsulatedContent
#endif  // CMS_PKCS7
                ) {
            if (0 > TCM_ExtractContent(
                        pbToBeEncoded,
                        cbToBeEncoded,
                        &cbInnerEncoded,
                        &pbInnerEncoded))
                goto ExtractContentError;
        } else {
            pbInnerEncoded = pbToBeEncoded;
            cbInnerEncoded = cbToBeEncoded;
        }
    }

    switch (dwMsgType) {
    case CMSG_HASHED:
    case CMSG_SIGNED:
        dwFlags |= fDetached ? CMSG_DETACHED_FLAG : 0;
        break;
    default:
        break;
    }

#ifdef CMS_PKCS7
    if (fEncapsulatedContent)
        dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7

    if (0 == (cbEncodedBlobOrg = CryptMsgCalculateEncodedLength(
                    dwMsgEncodingType,
                    dwFlags,
                    dwMsgType,
                    pvMsgEncodeInfo,
                    fInnerContent ? pszInnerContentObjId : NULL,
                    fInnerContent ? cbInnerEncoded : cbToBeEncoded))) {
        PrintLastError("EncodeMsg::CryptMsgCalculateEncodedLength == 0");
        goto ErrorReturn;
    }
    cbEncodedBlob = cbEncodedBlobOrg + 1024;        // A wee bit of padding
    pbEncodedBlob = (BYTE *) TestAlloc( cbEncodedBlob);
    if (pbEncodedBlob == NULL) goto ErrorReturn;

    hMsg = CryptMsgOpenToEncode(
        dwMsgEncodingType,
        dwFlags,
        dwMsgType,
        pvMsgEncodeInfo,
        fInnerContent ? pszInnerContentObjId : NULL,
        NULL                    // pStreamInfo
        );
    if (hMsg == NULL) {
        PrintLastError("EncodeMsg::CryptMsgOpenToEncode");
        goto ErrorReturn;
    }

#ifdef CMS_PKCS7
    if (fAlgorithmParameters) {
        rgSignerEncodeInfo[0].HashEncryptionAlgorithm.Parameters.pbData =
            rgbInvalidAsn;
        rgSignerEncodeInfo[0].HashEncryptionAlgorithm.Parameters.cbData =
            sizeof(rgbInvalidAsn);

        rgSignerEncodeInfo[0].HashAlgorithm.Parameters.pbData =
            rgbInvalidAsn;
        rgSignerEncodeInfo[0].HashAlgorithm.Parameters.cbData =
            sizeof(rgbInvalidAsn);
    }
#endif  // CMS_PKCS7

    fResult = CryptMsgUpdate(
        hMsg,
        pbToBeEncoded,
        cbToBeEncoded,
        TRUE                    // fFinal
        );
    if (!fResult) {
        PrintLastError("EncodeMsg::CryptMsgUpdate");
        goto ErrorReturn;
    }

#ifdef CMS_PKCS7
    if (fAuthAttr)
        XORAttributeBytes();

    if (fVerbose || fEncapsulatedContent || cAttrCert ||
            fOriginatorInfo || fCmsRecipient) {
        DWORD dwVersion;
        DWORD cbData = sizeof(dwVersion);
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_VERSION_PARAM,
            0,                      // dwIndex
            (PBYTE) &dwVersion,
            &cbData
            );
        if (!fResult)
            PrintLastError("EncodeMsg::CryptMsgGetParam(CMSG_VERSION_PARAM)");
        else
            printf("EncodeMsg Version:: %d\n", dwVersion);
    }
#endif  // CMS_PKCS7

    fResult = CryptMsgGetParam(
        hMsg,
        fBare ? CMSG_BARE_CONTENT_PARAM : CMSG_CONTENT_PARAM,
        0,                      // dwIndex
        pbEncodedBlob,
        &cbEncodedBlob
        );
    if (!fResult) {
        PrintLastError("EncodeMsg::CryptMsgGetParam(MSG_(BARE_)CONTENT_PARAM)");
        goto ErrorReturn;
    }
#ifdef CMS_PKCS7
    if (IsDSSProv(dwProvType) || fKeyAgree ||
            (fMultiSigner && PROV_RSA_FULL != dwMultiSignerProvType)
#else
    if (IsDSSProv(dwProvType)
#endif  // CMS_PKCS7
                || hNamedSignerCryptProv) {
        // For DSS the length of the encoded output may be less than
        // the length returned by CryptMsgCalculateEncodedLength

        // Also Key Agreement recipients containing generated ephemeral
        // public keys may have an encoded length less than
        // the length returned by CryptMsgCalculateEncodedLength
        if (cbEncodedBlobOrg < cbEncodedBlob)
            printf( "Fail: encoding size mismatch: expect=%x >= actual=%x\n",
                    cbEncodedBlobOrg,
                    cbEncodedBlob);
    } else {
        if (cbEncodedBlobOrg != cbEncodedBlob)
            printf( "Fail: encoding size mismatch: expect=%x    actual=%x\n",
                    cbEncodedBlobOrg,
                    cbEncodedBlob);
    }
    // NB- We depart from the usual practice here since cbEncodedBlob can be
    // somewhat larger than required. A buffer size of 1 will always be too
    // small.
    if (!TCM_CheckGetParam(
            hMsg,
            fBare ? CMSG_BARE_CONTENT_PARAM : CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbEncodedBlob,
            2))
        goto CheckGetEncodedError;

    if (dwMsgType == CMSG_HASHED) {
        BYTE *pbComputedDigest = NULL;
        DWORD cbComputedDigest = 0;

        if (!TCM_AllocGetParam(
                hMsg,
                CMSG_COMPUTED_HASH_PARAM,
                0,                      // dwIndex
                &pbComputedDigest,
                &cbComputedDigest))
            goto GetComputedHashError;

        TCM_CheckGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            0,                      // dwIndex
            pbComputedDigest,
            cbComputedDigest
            );

        TestFree(pbComputedDigest);
    }

#ifdef CMS_PKCS7
    if (dwMsgType == CMSG_SIGNED && !fNoSigners) {
        DWORD i;
        DWORD c;

        if (fMultiSigner)
            c = 2;
        else
            c = 1;

        for (i = 0; i < c; i++) {
            rgcbEncodedSignerHash[i] = sizeof(rgbEncodedSignerHash[i]);
            if (!CryptMsgGetParam(
                    hMsg,
                    CMSG_COMPUTED_HASH_PARAM,
                    i,                      // dwSignerIndex
                    rgbEncodedSignerHash[i],
                    &rgcbEncodedSignerHash[i]
                    )) {
                printf("EncodeMsg::CryptMsgGetParam(Signer[%d] CMSG_COMPUTED_HASH_PARAM)",
                    i);
                PrintLastError("");
            } else
                VerifyEncodedSignerComputedHash(
                    "EncodeMsg", hMsg, i,
                    rgbEncodedSignerHash[i],
                    rgcbEncodedSignerHash[i]);
        }
    }

    if (fAuthAttr)
        XORAttributeBytes();
#endif  // CMS_PKCS7

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    TestFree(pbEncodedBlob);
    pbEncodedBlob = NULL;
    cbEncodedBlob = 0;
CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    TestFree(pbToBeEncoded);
    *ppbEncodedBlob = pbEncodedBlob;
    *pcbEncodedBlob = cbEncodedBlob;

    return fResult;
//PRINT_ERROR(EncodeMsg,CalculateEncodedLengthWrongSizeError)
PRINT_ERROR(EncodeMsg,GetNonStreamedMsgContentError)
PRINT_ERROR(EncodeMsg,ExtractContentError)
PRINT_ERROR(EncodeMsg,CheckGetEncodedError)
PRINT_ERROR(EncodeMsg,GetComputedHashError)
}


//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//--------------------------------------------------------------------------
BOOL DecodeMsg(
    IN DWORD dwExpectedMsgType,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob
    )
{
    BOOL        fResult;
    HCRYPTMSG   hMsg = NULL;
    PBYTE       pbContent;
    DWORD       cbContent;
    PBYTE       pbDecoded = NULL;
    DWORD       cbDecoded;
    DWORD       cbData;
    DWORD       dwMsgType;
    DWORD       dwFlags = CMSG_LENGTH_ONLY_FLAG;

    if (!GetNonStreamedMsgContent(
            cbMsgContent,
            &pbContent,
            &cbContent))
        goto GetNonStreamedMsgContentError;

    switch (dwExpectedMsgType) {
    case CMSG_HASHED:
    case CMSG_SIGNED:
        dwFlags |= fDetached ? CMSG_DETACHED_FLAG : 0;
        break;
    default:
        break;
    }

    // Open to decode to get the message type and content length
    hMsg = CryptMsgOpenToDecode(
        dwMsgEncodingType,
        dwFlags,
        fBare ? dwExpectedMsgType : 0,
        hDefaultVerifyProv,
        NULL,                       // pRecipientInfo
        NULL                        // pStreamInfo
        );
    if (hMsg == NULL) {
        PrintLastError("DecodeMsg::CryptMsgOpenToDecode(CMSG_LENGTH_ONLY_FLAG)");
        goto ErrorReturn;
    }

    fResult = CryptMsgUpdate(
        hMsg,
        pbEncodedBlob,
        cbEncodedBlob,
        TRUE                    // fFinal
        );
    if (!fResult) {
        PrintLastError("DecodeMsg::CryptMsgUpdate");
        goto ErrorReturn;
    }

#ifdef CMS_PKCS7
    if (fVerbose || fEncapsulatedContent || cAttrCert ||
            fOriginatorInfo || fCmsRecipient) {
        DWORD dwVersion;
        DWORD cbData = sizeof(dwVersion);
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_VERSION_PARAM,
            0,                      // dwIndex
            (PBYTE) &dwVersion,
            &cbData
            );
        if (!fResult)
            PrintLastError("DecodeMsg::CryptMsgGetParam(CMSG_VERSION_PARAM)");
        else
            printf("DecodeMsg Version:: %d\n", dwVersion);
    }
#endif  // CMS_PKCS7

    if (fDetached) {
        fResult = CryptMsgUpdate(
            hMsg,
            pbContent,
            cbContent,
            TRUE                    // fFinal
            );
        if (!fResult) {
            PrintLastError("DecodeMsg::CryptMsgUpdate");
            goto ErrorReturn;
        }
    } else if (!fNoSigners) {
        cbData = sizeof(dwMsgType);
        dwMsgType = 0;
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                  // dwIndex
            &dwMsgType,
            &cbData
            );
        if (!fResult) {
            PrintLastError("DecodeMsg::CryptMsgGetParam(CMSG_TYPE_PARAM)");
            goto ErrorReturn;
        }
        if ((dwMsgType != dwExpectedMsgType) &&
                (CMSG_SIGNED != dwExpectedMsgType)) {
            PrintError("DecodeMsg::Unexpected message type");
        }
        if (!TCM_CheckGetParam(
                hMsg,
                CMSG_TYPE_PARAM,
                0,                  // dwIndex
                &dwMsgType,
                cbData))
            goto CheckGetTypeError;

    	cbDecoded = 0;
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            NULL,                   // pvData
            &cbDecoded
            );
        if (cbDecoded == 0) {
            PrintError("DecodeMsg::message content length == 0");
            goto ErrorReturn;
        }

        if ((cbDecoded < cbContent) && !fInnerContent)
            PrintError(
                "DecodeMsg::Ciphertext Length Less Than Plaintext Length");

        pbDecoded = (BYTE *) TestAlloc(cbDecoded);
        if (pbDecoded == NULL) goto ErrorReturn;
    }
    CryptMsgClose(hMsg);
    hMsg = NULL;

    // Re-open message to get its decoded content.
    hMsg = CryptMsgOpenToDecode(
        dwMsgEncodingType,
        dwFlags,
        fBare ? dwExpectedMsgType : 0,
        hDefaultVerifyProv,
        NULL,                       // pRecipientInfo
        NULL                        // pStreamInfo
        );
    if (hMsg == NULL) {
        PrintLastError("DecodeMsg::CryptMsgOpenToDecode");
        goto ErrorReturn;
    }

    // Check that duplicate works
    hMsg = CryptMsgDuplicate(hMsg);
    CryptMsgClose(hMsg);

    fResult = CryptMsgUpdate(
        hMsg,
        pbEncodedBlob,
        cbEncodedBlob,
        TRUE                    // fFinal
        );
    if (!fResult) {
        PrintLastError("DecodeMsg::CryptMsgUpdate");
        goto ErrorReturn;
    }

    if (fDetached) {
        fResult = CryptMsgUpdate(
            hMsg,
            pbContent,
            cbContent,
            TRUE                    // fFinal
            );
        if (!fResult) {
            PrintLastError("DecodeMsg::CryptMsgUpdate");
            goto ErrorReturn;
        }
    }

    if (fInnerContent) {
        DWORD   cbInnerContentObjId;
        PBYTE   pbInnerContentObjId;

        if (!TCM_AllocGetParam(
                hMsg,
                CMSG_INNER_CONTENT_TYPE_PARAM,
                0,                      // dwIndex
                &pbInnerContentObjId,
                &cbInnerContentObjId))
            goto GetInnerContentTypeError;

        if ((cbInnerContentObjId != (strlen(pszInnerContentObjId) + 1)) ||
                (0 != memcmp(
                        pszInnerContentObjId,
                        pbInnerContentObjId,
                        cbInnerContentObjId))) {
            PrintError(
                "DecodeMsg::Decoded Content Object ID incorrect");
        }
        TestFree(pbInnerContentObjId);
    }

    if (dwExpectedMsgType == CMSG_ENVELOPED ||
        dwExpectedMsgType == CMSG_SIGNED_AND_ENVELOPED) {
        fResult = GetRecipientInfoAndDecrypt(hMsg);
        if (!fResult) goto ErrorReturn;
    }

    if (!fNoSigners &&
            (dwExpectedMsgType == CMSG_SIGNED ||
            dwExpectedMsgType == CMSG_SIGNED_AND_ENVELOPED)) {
        if (fAuthAttr) {
            DWORD   cbAuthAttrs;
            PBYTE   pbAuthAttrs;

            if (!TCM_AllocGetParam(
                    hMsg,
                    CMSG_SIGNER_AUTH_ATTR_PARAM,
                    0,                      // dwIndex
                    &pbAuthAttrs,
                    &cbAuthAttrs)) {
                TestFree(pbAuthAttrs);
                goto GetAuthAttrError;
            }
            TestFree(pbAuthAttrs);

            if (!fCountersign) {
                if (!TCM_AllocGetParam(
                        hMsg,
                        CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                        0,                      // dwIndex
                        &pbAuthAttrs,
                        &cbAuthAttrs)) {
                    TestFree(pbAuthAttrs);
                    goto GetAuthAttrError;
                }
                TestFree(pbAuthAttrs);
            }
        }

#ifdef CMS_PKCS7
        VerifyDecodedSignerComputedHash(
            "DecodeMsg", hMsg, fInnerContent, 0,
            rgbEncodedSignerHash,
            rgcbEncodedSignerHash);
        if (fMultiSigner) {
            VerifyDecodedSignerComputedHash(
                "DecodeMsg", hMsg, fInnerContent, 1,
                rgbEncodedSignerHash,
                rgcbEncodedSignerHash);
        }
#endif  // CMS_PKCS7

        fResult = GetSignerInfoAndVerify(hMsg, fInnerContent);
        if (!fResult) goto ErrorReturn;

        if (fCountersign && !CountersignAndVerify( hMsg)) {
            PrintError( "DecodeMsg::CountersignAndVerify");
            goto ErrorReturn;
        }

        if (fAddSigner && !AddSignerAndVerify( hMsg)) {
            PrintError( "DecodeMsg::AddSignerAndVerify");
            goto ErrorReturn;
        }

        if (!AddDelItems(
                hMsg,
                CMSG_CERT_COUNT_PARAM,
                CMSG_CTRL_ADD_CERT,
                CMSG_CTRL_DEL_CERT,
                rgSignedCertBlob))
            goto AddDelCertsError;

        if (!AddDelItems(
                hMsg,
                CMSG_CRL_COUNT_PARAM,
                CMSG_CTRL_ADD_CRL,
                CMSG_CTRL_DEL_CRL,
                rgSignedCertBlob))  // This is not a cert
            goto AddDelCrlsError;
#ifdef CMS_PKCS7
        if (cAttrCert || (fEncapsulatedContent && fInnerContent)) {
            if (!AddDelItems(
                    hMsg,
                    CMSG_ATTR_CERT_COUNT_PARAM,
                    CMSG_CTRL_ADD_ATTR_CERT,
                    CMSG_CTRL_DEL_ATTR_CERT,
                    rgSignedCertBlob))
                goto AddDelAttrCertsError;
        }
#endif  // CMS_PKCS7
    }

    if (!fDetached && !fNoSigners
#ifdef CMS_PKCS7
            && !fNoRecipients
#endif  // CMS_PKCS7
            ) {
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbDecoded,
            &cbDecoded
            );
        if (!fResult) {
            PrintLastError("DecodeMsg::CryptMsgGetParam(CMSG_CONTENT_PARAM)");
            goto ErrorReturn;
        }
        if (!TCM_CheckGetParam(
                hMsg,
                CMSG_CONTENT_PARAM,
                0,                      // dwIndex
                pbDecoded,
                cbDecoded))
            goto CheckGetContentError;

        if (cbDecoded != cbContent ||
                memcmp(pbContent, pbDecoded, cbContent) != 0) {
            PrintError(
                "DecodeMsg::Decoded Content doesn't match ToBeEncoded Content");
        }
    }

    if (dwExpectedMsgType == CMSG_HASHED) {
        fResult = Undigest(hMsg);
        if (!fResult) goto ErrorReturn;
    }


    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    TestFree(pbDecoded);
    TestFree(pbContent);
    return fResult;
PRINT_ERROR(DecodeMsg,GetNonStreamedMsgContentError)
PRINT_ERROR(DecodeMsg,CheckGetTypeError)
PRINT_ERROR(DecodeMsg,GetInnerContentTypeError)
PRINT_ERROR(DecodeMsg,GetAuthAttrError)
PRINT_ERROR(DecodeMsg,CheckGetContentError)
PRINT_ERROR(DecodeMsg,AddDelCrlsError)
PRINT_ERROR(DecodeMsg,AddDelCertsError)
#ifdef CMS_PKCS7
PRINT_ERROR(DecodeMsg,AddDelAttrCertsError)
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Decode and encode a SignerInfo, and check that the input matches the output
//--------------------------------------------------------------------------
BOOL VerifyEncodedSigner(
    IN PBYTE    pbEncodedSigner,
    IN DWORD    cbEncodedSigner)
{
    BOOL                fRet;
    PCMSG_SIGNER_INFO   psi = NULL;
#ifdef CMS_PKCS7
    PCMSG_CMS_SIGNER_INFO pCMSsi = NULL;
#endif  // CMS_PKCS7
    DWORD               cbsi;
    PBYTE               pbEncodedSignerNew = NULL;
    DWORD               cbEncodedSignerNew;

    cbsi = 0;
    if (!CryptDecodeObject(
            PKCS_7_ASN_ENCODING,
            PKCS7_SIGNER_INFO,
            pbEncodedSigner,
            cbEncodedSigner,
            0,                              // dwFlags
            NULL,
            &cbsi))
        goto DecodeSizeError;
    if (NULL == (psi = (PCMSG_SIGNER_INFO)TestAlloc( cbsi)))
        goto AllocDecodeError;
    if (!CryptDecodeObject(
            PKCS_7_ASN_ENCODING,
            PKCS7_SIGNER_INFO,
            pbEncodedSigner,
            cbEncodedSigner,
            0,                              // dwFlags
            psi,
            &cbsi))
        goto DecodeError;

    cbEncodedSignerNew = 0;
    if (!CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            PKCS7_SIGNER_INFO,
            psi,
            NULL,
            &cbEncodedSignerNew))
        goto EncodeSizeError;
    if (NULL == (pbEncodedSignerNew = (PBYTE)TestAlloc( cbEncodedSignerNew)))
        goto AllocEncodeError;
    if (!CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            PKCS7_SIGNER_INFO,
            psi,
            pbEncodedSignerNew,
            &cbEncodedSignerNew))
        goto EncodeError;

    if (cbEncodedSigner != cbEncodedSignerNew)
        goto UnequalEncodedSignerSizeError;
    if (0 != memcmp( pbEncodedSigner, pbEncodedSignerNew, cbEncodedSigner))
        goto UnequalEncodedSignerError;

#ifdef CMS_PKCS7
    TestFree(pbEncodedSignerNew);
    pbEncodedSignerNew = NULL;

    cbsi = 0;
    if (!CryptDecodeObject(
            PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            pbEncodedSigner,
            cbEncodedSigner,
            0,                              // dwFlags
            NULL,
            &cbsi))
        goto CMSDecodeSizeError;
    if (NULL == (pCMSsi = (PCMSG_CMS_SIGNER_INFO)TestAlloc( cbsi)))
        goto CMSAllocDecodeError;
    if (!CryptDecodeObject(
            PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            pbEncodedSigner,
            cbEncodedSigner,
            0,                              // dwFlags
            pCMSsi,
            &cbsi))
        goto CMSDecodeError;

    cbEncodedSignerNew = 0;
    if (!CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            pCMSsi,
            NULL,
            &cbEncodedSignerNew))
        goto CMSEncodeSizeError;
    if (NULL == (pbEncodedSignerNew = (PBYTE)TestAlloc( cbEncodedSignerNew)))
        goto CMSAllocEncodeError;
    if (!CryptEncodeObject(
            PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            pCMSsi,
            pbEncodedSignerNew,
            &cbEncodedSignerNew))
        goto CMSEncodeError;

    if (cbEncodedSigner != cbEncodedSignerNew)
        goto CMSUnequalEncodedSignerSizeError;
    if (0 != memcmp( pbEncodedSigner, pbEncodedSignerNew, cbEncodedSigner))
        goto CMSUnequalEncodedSignerError;
#endif  // CMS_PKCS7

    fRet = TRUE;
CommonReturn:
    TestFree(psi);
#ifdef CMS_PKCS7
    TestFree(pCMSsi);
#endif  // CMS_PKCS7
    TestFree(pbEncodedSignerNew);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(VerifyEncodedSigner,DecodeSizeError)
PRINT_ERROR(VerifyEncodedSigner,AllocDecodeError)
PRINT_ERROR(VerifyEncodedSigner,DecodeError)
PRINT_ERROR(VerifyEncodedSigner,EncodeSizeError)
PRINT_ERROR(VerifyEncodedSigner,AllocEncodeError)
PRINT_ERROR(VerifyEncodedSigner,EncodeError)
PRINT_ERROR(VerifyEncodedSigner,UnequalEncodedSignerSizeError)
PRINT_ERROR(VerifyEncodedSigner,UnequalEncodedSignerError)
#ifdef CMS_PKCS7
PRINT_ERROR(VerifyEncodedSigner,CMSDecodeSizeError)
PRINT_ERROR(VerifyEncodedSigner,CMSAllocDecodeError)
PRINT_ERROR(VerifyEncodedSigner,CMSDecodeError)
PRINT_ERROR(VerifyEncodedSigner,CMSEncodeSizeError)
PRINT_ERROR(VerifyEncodedSigner,CMSAllocEncodeError)
PRINT_ERROR(VerifyEncodedSigner,CMSEncodeError)
PRINT_ERROR(VerifyEncodedSigner,CMSUnequalEncodedSignerSizeError)
PRINT_ERROR(VerifyEncodedSigner,CMSUnequalEncodedSignerError)
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Countersign the signed message and verify the countersignature
//--------------------------------------------------------------------------
BOOL CountersignAndVerify(IN HCRYPTMSG hCryptMsg)
{
    BOOL                fRet;
    HCRYPTMSG           hMsgNew = NULL;
    PBYTE               pbEncodedMessage = NULL;
    DWORD               cbEncodedMessage;
    PBYTE               pbSignerInfo = NULL;
    DWORD               cbSignerInfo;
    PCRYPT_ATTRIBUTES   patrs = NULL;
    DWORD               cbatrs;
    PCERT_INFO          pciCountersigner = NULL;
    DWORD               cbSignerPublicKeyData;

    // Allocate and get the CERT_INFO containing the SignerId
    // (Issuer and SerialNumber) of the countersigner.
    // NB: For this particular test, the signer and countersigner are the same.
    if (NULL == (pciCountersigner = GetCertIdFromMsg(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            0)))                    // dwIndex
        goto GetCertIdFromMsgError;

    // countersign
    if (!CryptMsgCountersign(
            hCryptMsg,
            0,                      // dwIndex
            1,                      // cCountersigners
            &rgSignerEncodeInfo[0]))
        goto CountersignError;

    if (!TCM_AllocGetParam(
            hCryptMsg,
            CMSG_ENCODED_MESSAGE,
            0,                      // dwIndex
            &pbEncodedMessage,
            &cbEncodedMessage))
        goto GetEncodedMessageError;

    if (pszFilename)
        TCM_WriteBufToFile( pszFilename, pbEncodedMessage, cbEncodedMessage);

    // Re-open message to get its decoded content.
    if (NULL == (hMsgNew = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            0,                          // dwFlags
            0,                          // dwMsgType
            hDefaultVerifyProv,
            NULL,                       // pRecipientInfo
            NULL)))                     // pStreamInfo
        goto CryptMsgOpenToDecodeError;
    if (!CryptMsgUpdate(
            hMsgNew,
            pbEncodedMessage,
            cbEncodedMessage,
            TRUE))                  // fFinal
        goto CryptMsgUpdateError;

    // Get the SignerInfo which was countersigned
    if (!TCM_AllocGetParam(
            hMsgNew,
            CMSG_ENCODED_SIGNER,
            0,                      // dwIndex
            &pbSignerInfo,
            &cbSignerInfo))
        goto GetEncodedSignerInfoError;

    if (!VerifyEncodedSigner( pbSignerInfo, cbSignerInfo))
        goto VerifyEncodedSignerError;

    // Get the unauth attrs, and find the countersignature
    if (!TCM_AllocGetParam(
            hMsgNew,
            CMSG_SIGNER_UNAUTH_ATTR_PARAM,
            0,                      // dwIndex
            (PBYTE *)&patrs,
            &cbatrs))
        goto GetUnauthAttrsError;

    // Do some consistency checks
    if (patrs->cAttr != 1)
        goto AttrCountError;
    if (strcmp( patrs->rgAttr->pszObjId, szOID_RSA_counterSign))
        goto AttrOidNotCountersignError;
    if (patrs->rgAttr->cValue != 1)
        goto CountersignCountError;

    // Get the signer's public key
    cbSignerPublicKeyData = sizeof(SignerPublicKeyData.Data);
    memset(SignerPublicKeyData.Data, 0, cbSignerPublicKeyData);
    if (!CryptExportPublicKeyInfo(
            hCryptProv,
            AT_SIGNATURE,
            X509_ASN_ENCODING,
            (PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data,
            &cbSignerPublicKeyData))
        goto ExportPublicKeyInfoError;

    pciCountersigner->SubjectPublicKeyInfo =
        *((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data);

    // Verify the countersignature
    if (!CryptMsgVerifyCountersignatureEncoded(
            hDefaultVerifyProv,
            PKCS_7_ASN_ENCODING,
            pbSignerInfo,
            cbSignerInfo,
            patrs->rgAttr->rgValue->pbData,
            patrs->rgAttr->rgValue->cbData,
            pciCountersigner))
        goto VerifyCountersignatureEncodedError;

    fRet = TRUE;
CommonReturn:
    if (hMsgNew)
        CryptMsgClose(hMsgNew);
    TestFree(pciCountersigner);
    TestFree(pbEncodedMessage);
    TestFree(pbSignerInfo);
    TestFree(patrs);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(CountersignAndVerify,GetEncodedMessageError)
PRINT_ERROR(CountersignAndVerify,CryptMsgOpenToDecodeError)
PRINT_ERROR(CountersignAndVerify,CryptMsgUpdateError)
PRINT_ERROR(CountersignAndVerify,GetCertIdFromMsgError)
PRINT_ERROR(CountersignAndVerify,CountersignError)
PRINT_ERROR(CountersignAndVerify,GetEncodedSignerInfoError)
PRINT_ERROR(CountersignAndVerify,VerifyEncodedSignerError)
PRINT_ERROR(CountersignAndVerify,GetUnauthAttrsError)
PRINT_ERROR(CountersignAndVerify,AttrCountError)
PRINT_ERROR(CountersignAndVerify,AttrOidNotCountersignError)
PRINT_ERROR(CountersignAndVerify,CountersignCountError)
PRINT_ERROR(CountersignAndVerify,ExportPublicKeyInfoError)
PRINT_ERROR(CountersignAndVerify,VerifyCountersignatureEncodedError)
}


//+-------------------------------------------------------------------------
//  Add signers to the signed message and verify the new signatures
//--------------------------------------------------------------------------
BOOL AddSignerAndVerify(IN HCRYPTMSG hCryptMsg)
{
    BOOL                fRet;
    HCRYPTMSG           hMsgNew = NULL;
    PBYTE               pbEncodedMessage = NULL;
    DWORD               cbEncodedMessage;
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo1 = rgSignerEncodeInfo[0];
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo2 = rgSignerEncodeInfo[0];
    PCERT_INFO          pciSigner0 = NULL;
    PCERT_INFO          pciSigner1 = NULL;
    PCERT_INFO          pciSigner2 = NULL;

    if (NULL == (pciSigner0 = GetCertIdFromMsg(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            0)))                        // dwIndex
        goto GetCertId0Error;
    if (NULL == (pciSigner1 = GetCertIdFromMsg(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            0)))                        // dwIndex
        goto GetCertId1Error;
    if (NULL == (pciSigner2 = GetCertIdFromMsg(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            0)))                        // dwIndex
        goto GetCertId2Error;

    // Give the new signers different serial numbers
    pciSigner1->SerialNumber.pbData = (PBYTE)&dwSignerSerialNumber1;
    pciSigner2->SerialNumber.pbData = (PBYTE)&dwSignerSerialNumber2;

    // Fill in the public key info
    // NB- We are relying on this already having been filled in by GetSignerInfoAndVerify
    pciSigner0->SubjectPublicKeyInfo =
        *((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data);
    pciSigner1->SubjectPublicKeyInfo =
        *((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data);
    pciSigner2->SubjectPublicKeyInfo =
        *((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data);

    SignerEncodeInfo1.pCertInfo = pciSigner1;
    SignerEncodeInfo2.pCertInfo = pciSigner2;

    if (IsDSSProv(dwProvType))
        // DSS only supports signing of sha1
        SignerEncodeInfo2.HashAlgorithm =
            SignDigestAlgorithms[fMD5 ? SIGNDIGEST_ALG_MD5 : SIGNDIGEST_ALG_SHA];
    else
        // Use a different hash algorithm to force adding a hash node and
        // hashing the content again.
        SignerEncodeInfo2.HashAlgorithm =
            SignDigestAlgorithms[ !fMD5 ? SIGNDIGEST_ALG_MD5 : SIGNDIGEST_ALG_SHA];

    // Add the signers
    if (!CryptMsgControl(
            hCryptMsg,
            0,                      // dwFlags
            CMSG_CTRL_ADD_SIGNER,
            &SignerEncodeInfo1))
        goto AddSigner1Error;
    if (!CryptMsgControl(
            hCryptMsg,
            0,                      // dwFlags
            CMSG_CTRL_ADD_SIGNER,
            &SignerEncodeInfo2))
        goto AddSigner2Error;

    if (!AddDelItems(
            hCryptMsg,
            CMSG_SIGNER_COUNT_PARAM,
            CMSG_CTRL_ADD_SIGNER,
            CMSG_CTRL_DEL_SIGNER,
            &SignerEncodeInfo2))
        goto AddDelSignersError;

    // Verify all the signatures
    if (!CryptMsgControl(
            hCryptMsg,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner0))
        goto VerifySigner0Error;
    if (!CryptMsgControl(
            hCryptMsg,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner1))
        goto VerifySigner1Error;
    if (!CryptMsgControl(
            hCryptMsg,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner2))
        goto VerifySigner2Error;

    // Re-encode the message, with the new signers
    if (!TCM_AllocGetParam(
            hCryptMsg,
            CMSG_ENCODED_MESSAGE,
            0,                      // dwIndex
            &pbEncodedMessage,
            &cbEncodedMessage))
        goto GetEncodedMessageError;

    if (pszFilename)
        TCM_WriteBufToFile( pszFilename, pbEncodedMessage, cbEncodedMessage);

    // Re-open message to get its decoded content.
    if (NULL == (hMsgNew = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            0,                          // dwFlags
            0,                          // dwMsgType
            hDefaultVerifyProv,
            NULL,                       // pRecipientInfo
            NULL)))                     // pStreamInfo
        goto CryptMsgOpenToDecodeError;
    if (!CryptMsgUpdate(
            hMsgNew,
            pbEncodedMessage,
            cbEncodedMessage,
            TRUE))                  // fFinal
        goto CryptMsgUpdateError;

    // Verify all the signatures, again
    if (!CryptMsgControl(
            hMsgNew,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner0))
        goto ReVerifySigner0Error;
    if (!CryptMsgControl(
            hMsgNew,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner1))
        goto ReVerifySigner1Error;
    if (!CryptMsgControl(
            hMsgNew,
            0,                      // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pciSigner2))
        goto ReVerifySigner2Error;

    fRet = TRUE;
CommonReturn:
    if (hMsgNew)
        CryptMsgClose(hMsgNew);
    TestFree(pciSigner0);
    TestFree(pciSigner1);
    TestFree(pciSigner2);
    TestFree(pbEncodedMessage);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
PRINT_ERROR(AddSignerAndVerify,GetCertId0Error)
PRINT_ERROR(AddSignerAndVerify,GetCertId1Error)
PRINT_ERROR(AddSignerAndVerify,GetCertId2Error)
PRINT_ERROR(AddSignerAndVerify,AddSigner1Error)
PRINT_ERROR(AddSignerAndVerify,AddSigner2Error)
PRINT_ERROR(AddSignerAndVerify,VerifySigner0Error)
PRINT_ERROR(AddSignerAndVerify,VerifySigner1Error)
PRINT_ERROR(AddSignerAndVerify,VerifySigner2Error)
PRINT_ERROR(AddSignerAndVerify,GetEncodedMessageError)
PRINT_ERROR(AddSignerAndVerify,CryptMsgOpenToDecodeError)
PRINT_ERROR(AddSignerAndVerify,CryptMsgUpdateError)
PRINT_ERROR(AddSignerAndVerify,ReVerifySigner0Error)
PRINT_ERROR(AddSignerAndVerify,ReVerifySigner1Error)
PRINT_ERROR(AddSignerAndVerify,ReVerifySigner2Error)
PRINT_ERROR(AddSignerAndVerify,AddDelSignersError)
}

//+-------------------------------------------------------------------------
//  Verify certificates and CRLs in a signed or enveloped message.
//--------------------------------------------------------------------------
BOOL VerifyCerts(IN HCRYPTMSG hMsg)
{
    BOOL fResult;
    BYTE *pbCertEncoded = NULL;
    DWORD cCert;
#ifdef CMS_PKCS7
    BYTE *pbCrlEncoded = NULL;
    DWORD cCrl;
#endif  // CMS_PKCS7
    DWORD cbData;
    DWORD dwIndex;

//--------------------------------------------------------------
    // Get count of certificates in the message
    cCert = 0;
    cbData = sizeof(cCert);
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_CERT_COUNT_PARAM,
        0,                      // dwIndex
        &cCert,
        &cbData
        );
    if (!fResult) {
        PrintLastError(
            "VerifyCerts::CryptMsgGetParam(CMSG_CERT_COUNT_PARAM)");
        goto ErrorReturn;
    }
    if (cCert != cSignedCert) {
        PrintError("VerifyCerts::cCert != cSignedCert");
        goto ErrorReturn;
    }
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_CERT_COUNT_PARAM,
            0,                      // dwIndex
            &cCert,
            cbData))
        goto CheckGetCertCountError;


    // Get certs from the message and verify
    for (dwIndex = 0; dwIndex < cCert; dwIndex++) {
        if (!TCM_AllocGetParam(
                hMsg,
                CMSG_CERT_PARAM,
                dwIndex,
                &pbCertEncoded,
                &cbData))
            goto GetCertError;

        if (cbData != rgSignedCertBlob[dwIndex].cbData ||
            memcmp(pbCertEncoded, rgSignedCertBlob[dwIndex].pbData,
                cbData) != 0) {
            PrintError("VerifyCerts::Bad Cert content");
        }

        TestFree(pbCertEncoded);
        pbCertEncoded = NULL;
    }

#ifdef CMS_PKCS7
//--------------------------------------------------------------
    // Get count of attribute certificates in the message
    cCert = 0;
    cbData = sizeof(cCert);
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_ATTR_CERT_COUNT_PARAM,
        0,                      // dwIndex
        &cCert,
        &cbData
        );
    if (!fResult) {
        PrintLastError(
            "VerifyCerts::CryptMsgGetParam(CMSG_ATTR_CERT_COUNT_PARAM)");
        goto ErrorReturn;
    }
    if (cCert != cAttrCert) {
        PrintError("VerifyCerts::cAttrCert != cAttrCert");
        goto ErrorReturn;
    }
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_ATTR_CERT_COUNT_PARAM,
            0,                      // dwIndex
            &cCert,
            cbData))
        goto CheckGetCertCountError;


    // Get attribute certs from the message and verify
    for (dwIndex = 0; dwIndex < cCert; dwIndex++) {
        if (!TCM_AllocGetParam(
                hMsg,
                CMSG_ATTR_CERT_PARAM,
                dwIndex,
                &pbCertEncoded,
                &cbData))
            goto GetCertError;

        if (cbData != rgAttrCertBlob[dwIndex].cbData ||
            memcmp(pbCertEncoded, rgAttrCertBlob[dwIndex].pbData,
                cbData) != 0) {
            PrintError("VerifyCerts::Bad Attribute Cert content");
        }

        TestFree(pbCertEncoded);
        pbCertEncoded = NULL;
    }

//--------------------------------------------------------------
    // Get count of CRLs in the message
    cCrl = 0;
    cbData = sizeof(cCrl);
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_CRL_COUNT_PARAM,
        0,                      // dwIndex
        &cCrl,
        &cbData
        );
    if (!fResult) {
        PrintLastError(
            "VerifyCrls::CryptMsgGetParam(CMSG_CRL_COUNT_PARAM)");
        goto ErrorReturn;
    }
    if (cCrl != cSignedCrl) {
        PrintError("VerifyCrls::cCrl != cSignedCrl");
        goto ErrorReturn;
    }
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_CRL_COUNT_PARAM,
            0,                      // dwIndex
            &cCrl,
            cbData))
        goto CheckGetCrlCountError;


    // Get CRLs from the message and verify
    for (dwIndex = 0; dwIndex < cCrl; dwIndex++) {
        if (!TCM_AllocGetParam(
                hMsg,
                CMSG_CRL_PARAM,
                dwIndex,
                &pbCrlEncoded,
                &cbData))
            goto GetCrlError;

        if (cbData != rgSignedCrlBlob[dwIndex].cbData ||
            memcmp(pbCrlEncoded, rgSignedCrlBlob[dwIndex].pbData,
                cbData) != 0) {
            PrintError("VerifyCrls::Bad Crl content");
        }

        TestFree(pbCrlEncoded);
        pbCrlEncoded = NULL;
    }
#endif  // CMS_PKCS7

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;

CommonReturn:
    TestFree(pbCertEncoded);
#ifdef CMS_PKCS7
    TestFree(pbCrlEncoded);
#endif  // CMS_PKCS7
    return fResult;
PRINT_ERROR(VerifyCerts,CheckGetCertCountError)
PRINT_ERROR(VerifyCerts,GetCertError)
#ifdef CMS_PKCS7
PRINT_ERROR(VerifyCerts,CheckGetCrlCountError)
PRINT_ERROR(VerifyCerts,GetCrlError)
#endif  // CMS_PKCS7
}

//+-------------------------------------------------------------------------
//  Get signer info and verify the signed message
//--------------------------------------------------------------------------
BOOL GetSignerInfoAndVerify(
    IN HCRYPTMSG hMsg,
    IN BOOL fInnerNonData,
    IN DWORD dwSignerIndex,
    OUT DWORD *pdwSrcIndex
    )
{
    BOOL fResult;
    PCERT_INFO pSignerCertInfo = NULL;
    PCMSG_SIGNER_INFO pSignerInfo = NULL;
    DWORD cbData;
    BOOL  fEqual;
    DWORD i;
    PCRYPT_ATTRIBUTE patr1;
    PCRYPT_ATTRIBUTE patr2;

    DWORD cbSignerPublicKeyData;
    DWORD dwSrcIndex = 0;
    HCRYPTPROV hVerifyProv;

#ifdef CMS_PKCS7
    if (fMultiSigner) {
        DWORD cSigner = 0;
        cbData = sizeof(cSigner);

        if (!CryptMsgGetParam(
                hMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                           // dwIndex
                &cSigner,
                &cbData) || cSigner != 2) {
            PrintLastError(
                "GetSignerInfoAndVerify:: Invalid multisigner count");
        }
    }
#endif  // CMS_PKCS7

    // Allocate and get the CERT_INFO containing the SignerId
    // (Issuer and SerialNumber)
    pSignerCertInfo = GetCertIdFromMsg(
        hMsg,
        CMSG_SIGNER_CERT_INFO_PARAM,
        dwSignerIndex
        );
    if (pSignerCertInfo == NULL) {
        PrintLastError(
            "GetSignerInfoAndVerify::CryptMsgGetParam(CMSG_SIGNER_CERT_INFO_PARAM)");
        goto ErrorReturn;
    }
#ifdef CMS_PKCS7
    if (!(fCertInfoKeyId && fMultiSigner)) {
#endif  // CMS_PKCS7

    if (pSignerCertInfo->Issuer.cbData != rgSignerCertInfo[0].Issuer.cbData ||
        memcmp(pSignerCertInfo->Issuer.pbData, rgSignerCertInfo[0].Issuer.pbData,
            pSignerCertInfo->Issuer.cbData) != 0) {
        PrintError("GetSignerInfoAndVerify::Bad SignerIssuerName");
    }

#ifdef CMS_PKCS7
    }
#endif  // CMS_PKCS7

#ifdef CMS_PKCS7
    if (fMultiSigner) {

        if (pSignerCertInfo->SerialNumber.cbData ==
                rgSignerCertInfo[0].SerialNumber.cbData &&
            memcmp(pSignerCertInfo->SerialNumber.pbData,
                rgSignerCertInfo[0].SerialNumber.pbData,
                pSignerCertInfo->SerialNumber.cbData) == 0) {
            dwSrcIndex = 0;
        } else if (pSignerCertInfo->SerialNumber.cbData ==
                rgSignerCertInfo[1].SerialNumber.cbData &&
            memcmp(pSignerCertInfo->SerialNumber.pbData,
                rgSignerCertInfo[1].SerialNumber.pbData,
                pSignerCertInfo->SerialNumber.cbData) == 0) {
            dwSrcIndex = 1;
        } else {
            PrintError("GetSignerInfoAndVerify::Bad SignerSerialNumber");
        }

        if (fCertInfoKeyId) {
            if (pSignerCertInfo->Issuer.cbData ==
                    rgSignerCertInfo[0].Issuer.cbData &&
                memcmp(pSignerCertInfo->Issuer.pbData,
                    rgSignerCertInfo[0].Issuer.pbData,
                    pSignerCertInfo->Issuer.cbData) == 0) {
                dwSrcIndex = 0;
            } else if (pSignerCertInfo->Issuer.cbData ==
                    rgSignerCertInfo[1].Issuer.cbData &&
                memcmp(pSignerCertInfo->Issuer.pbData,
                    rgSignerCertInfo[1].Issuer.pbData,
                    pSignerCertInfo->Issuer.cbData) == 0) {
                dwSrcIndex = 1;
            } else {
                PrintError("GetSignerInfoAndVerify::Bad CertInfoKeyId");
            }
        }
    } else
#endif  // CMS_PKCS7
    if (pSignerCertInfo->SerialNumber.cbData !=
            rgSignerCertInfo[0].SerialNumber.cbData ||
        memcmp(pSignerCertInfo->SerialNumber.pbData,
            rgSignerCertInfo[0].SerialNumber.pbData,
            pSignerCertInfo->SerialNumber.cbData) != 0) {
        PrintError("GetSignerInfoAndVerify::Bad SignerSerialNumber");
    }


//--------------------------------------------------------------
    // Allocate and get the CMSG_SIGNER_INFO for the signer
    if (NULL == (pSignerInfo = GetSignerInfoFromMsg(
                                        hMsg,
                                        dwSignerIndex))) {
        PrintLastError(
            "GetSignerInfoAndVerify::CryptMsgGetParam(CMSG_SIGNER_INFO_PARAM)");
        goto ErrorReturn;
    }
    fEqual  = (pSignerInfo->Issuer.cbData ==
        rgSignerCertInfo[dwSrcIndex].Issuer.cbData);
    if (fEqual) {
        fEqual &= (memcmp(  pSignerInfo->Issuer.pbData,
                            rgSignerCertInfo[dwSrcIndex].Issuer.pbData,
                            pSignerInfo->Issuer.cbData) == 0);
    }
    fEqual &= (pSignerInfo->SerialNumber.cbData ==
               rgSignerCertInfo[dwSrcIndex].SerialNumber.cbData);
    if (fEqual) {
        fEqual &= (memcmp(  pSignerInfo->SerialNumber.pbData,
                            rgSignerCertInfo[dwSrcIndex].SerialNumber.pbData,
                            pSignerInfo->SerialNumber.cbData) == 0);
    }
    if (fAuthAttr) {
        fEqual &= EqualAlgorithm(  &rgSignerEncodeInfo[dwSrcIndex].HashAlgorithm,
                                   &pSignerInfo->HashAlgorithm);
        // Allow for the 2 auth attrs which get added automatically
        fEqual &= ((rgSignerEncodeInfo[dwSrcIndex].cAuthAttr + 2) ==
            pSignerInfo->AuthAttrs.cAttr);
        if (fEqual) {
            for (i=pSignerInfo->AuthAttrs.cAttr,
                        patr1=rgSignerEncodeInfo[dwSrcIndex].rgAuthAttr,
                        patr2=pSignerInfo->AuthAttrs.rgAttr;
                    i>0;
                    i--, patr2++) {
                // NB: We skip over the 2 auth attrs added by the system.
                if (    (0 == strcmp( szOID_RSA_contentType,   patr2->pszObjId)) ||
                        (0 == strcmp( szOID_RSA_messageDigest, patr2->pszObjId)))
                    continue;
                fEqual &= EqualAttribute( patr1++, patr2);
            }
        }

        if (!fCountersign) {
            fEqual &= (rgSignerEncodeInfo[dwSrcIndex].cUnauthAttr ==
                pSignerInfo->UnauthAttrs.cAttr);
            if (fEqual) {
                for (i=pSignerInfo->UnauthAttrs.cAttr,
                            patr1=rgSignerEncodeInfo[dwSrcIndex].rgUnauthAttr,
                            patr2=pSignerInfo->UnauthAttrs.rgAttr;
                        i>0;
                        i--, patr1++, patr2++) {
                    fEqual &= EqualAttribute( patr1, patr2);
                }
            }
        }
    } else {
        // It would be more thorough to check the message digest and
        // content type auth attrs are present in the fInnerContent case.
        if (fInnerNonData)
        {
            fEqual &= (pSignerInfo->AuthAttrs.cAttr == 2) ? 1 : 0;
        }
        else
        {
            fEqual &= (pSignerInfo->AuthAttrs.cAttr == 0) ? 1 : 0;
        }

//        fEqual &= fInnerNonData
//                        ? (2 == pSignerInfo->AuthAttrs.cAttr)
//                        : (0 == pSignerInfo->AuthAttrs.cAttr);
    }
    if (!fAuthAttr || fCountersign)
        fEqual &= (0 == pSignerInfo->UnauthAttrs.cAttr);
    if (!fEqual) {
        PrintError("GetSignerInfoAndVerify::Bad SignerInfo");
        goto ErrorReturn;
    }

    VerifyCerts(hMsg);

    // Get crypt provider's public signature key. It will be used as the
    // signer's public key
    cbSignerPublicKeyData = sizeof(SignerPublicKeyData.Data);
    memset(SignerPublicKeyData.Data, 0, cbSignerPublicKeyData);
    hVerifyProv = hCryptProv;
#ifdef CMS_PKCS7
    if (fMultiSigner) {
        if (dwSrcIndex != 0)
            hVerifyProv = hMultiSignerCryptProv;
    }
#endif  // CMS_PKCS7

    if (fNoSignature) {
        CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA Para;

        memset(&Para, 0, sizeof(Para));
        Para.cbSize = sizeof(Para);
        // Para.hCryptProv = 
        Para.dwSignerIndex = dwSignerIndex;
        Para.dwSignerType = CMSG_VERIFY_SIGNER_NULL;
        // Para.pvSigner =

        fResult = CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE_EX,
            &Para
            );
        if (!fResult) {
            PrintLastError(
                "GetSignerInfoAndVerify::CryptMsgControl(CMSG_VERIFY_SIGNER_NULL)");
            goto ErrorReturn;
        }

        goto CommonReturn;
    }

    CryptExportPublicKeyInfo(
        hVerifyProv,
        AT_SIGNATURE,
        X509_ASN_ENCODING,
        (PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data,
        &cbSignerPublicKeyData);

    pSignerCertInfo->SubjectPublicKeyInfo =
        *((PCERT_PUBLIC_KEY_INFO) SignerPublicKeyData.Data);

    fResult = CryptMsgControl(
        hMsg,
        0,                  // dwFlags
        CMSG_CTRL_VERIFY_SIGNATURE,
        pSignerCertInfo
        );
    if (!fResult) {
        PrintLastError(
            "GetSignerInfoAndVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE)");
        goto ErrorReturn;
    }

#ifdef CMS_PKCS7
    // Modify public key. Verify should fail.
    XORBitBlob(&pSignerCertInfo->SubjectPublicKeyInfo.PublicKey);
    fResult = CryptMsgControl(
        hMsg,
        0,                  // dwFlags
        CMSG_CTRL_VERIFY_SIGNATURE,
        pSignerCertInfo
        );
    if (fResult)
        printf("GetSignerInfoAndVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE) failed => verified with bad public key");
    XORBitBlob(&pSignerCertInfo->SubjectPublicKeyInfo.PublicKey);

    if (!fCertInfoKeyId) {
        // Modify serial number. Verify should fail.
        XORBlob(&pSignerCertInfo->SerialNumber);
        fResult = CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pSignerCertInfo
            );
        if (fResult)
            printf("GetSignerInfoAndVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE) failed => verified with bad serial number");
        XORBlob(&pSignerCertInfo->SerialNumber);

        // Modify issuer. Verify should fail.
        XORBlob(&pSignerCertInfo->Issuer);
        fResult = CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pSignerCertInfo
            );
        if (fResult)
            printf("GetSignerInfoAndVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE) failed => verified with bad issuer");
        XORBlob(&pSignerCertInfo->Issuer);
    }
    fResult = TRUE;
#endif  // CMS_PKCS7

    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;

CommonReturn:
    TestFree(pSignerCertInfo);
    TestFree(pSignerInfo);
    *pdwSrcIndex = dwSrcIndex;
    return fResult;
}

BOOL NamedSignerVerify(IN HCRYPTMSG hMsg, IN BOOL fInnerNonData)
{
    BOOL fResult;

#ifdef CMS_PKCS7
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    CERT_CHAIN_PARA ChainPara;
    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

    // Build a chain. This is necessary for DSA with public key algorithm
    // parameter inheritance.

    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    if (!CertGetCertificateChain(
            NULL,                   // hChainEngine
            pNamedSigner,
            NULL,                   // pTime
            hSignerStore,
            &ChainPara,
            CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
            NULL,                   // pvReserved
            &pChainContext
            )) {
        PrintLastError(
            "NamedSignerVerify::CertGetCertificateChain");
        return FALSE;
    }

    // Test that we can verify a certificate signature using a chain
    if (2 <= pChainContext->rgpChain[0]->cElement) {
        PCCERT_CONTEXT pIssuer =
            pChainContext->rgpChain[0]->rgpElement[1]->pCertContext;
        PCCERT_CHAIN_CONTEXT pIssuerChainContext = NULL;

        if (!CertGetCertificateChain(
                NULL,                   // hChainEngine
                pIssuer,
                NULL,                   // pTime
                hSignerStore,
                &ChainPara,
                CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                NULL,                   // pvReserved
                &pIssuerChainContext
                )) {
            PrintLastError(
                "NamedSignerVerify::CertGetCertificateChain(Issuer)");
        } else {
            if (!CryptVerifyCertificateSignatureEx(
                    0,                                  // hCryptProv
                    dwCertEncodingType,
                    CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
                    (void *) pNamedSigner,
                    CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN,
                    (void *) pIssuerChainContext,
                    0,                                  // dwFlags
                    NULL                                // pvReserved
                    )) {
                PrintLastError(
                    "NamedSignerVerify::CryptVerifyCertificateSignatureEx(Chain)");
            }
            CertFreeCertificateChain(pIssuerChainContext);
        }
    }

    memset(&CtrlPara, 0, sizeof(CtrlPara));
    CtrlPara.cbSize = sizeof(CtrlPara);
    CtrlPara.hCryptProv = hNamedSignerCryptProv;
    CtrlPara.dwSignerIndex = 0;
    CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CHAIN;
    CtrlPara.pvSigner = (void *) pChainContext;

    fResult = CryptMsgControl(
        hMsg,
        0,
        CMSG_CTRL_VERIFY_SIGNATURE_EX,
        &CtrlPara
        );
    if (!fResult) {
        PrintLastError(
            "NamedSignerVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE_EX)");
    }

    CertFreeCertificateChain(pChainContext);

    return fResult;
#else
    fResult = CryptMsgControl(
        hMsg,
        0,                  // dwFlags
        CMSG_CTRL_VERIFY_SIGNATURE,
        pNamedSigner->pCertInfo
        );
    if (!fResult) {
        PrintLastError(
            "NamedSignerVerify::CryptMsgControl(CMSG_CTRL_VERIFY_SIGNATURE)");
    }
    return fResult;
#endif  // CMS_PKCS7
}

//+-------------------------------------------------------------------------
//  Get signer info and verify the signed message
//--------------------------------------------------------------------------
BOOL GetSignerInfoAndVerify(IN HCRYPTMSG hMsg, IN BOOL fInnerNonData)
{
    BOOL fResult;
    DWORD dwSrcIndex;

    if (pNamedSigner)
        fResult = NamedSignerVerify(hMsg, fInnerNonData);
    else
        fResult = GetSignerInfoAndVerify(hMsg, fInnerNonData, 0, &dwSrcIndex);

#ifdef CMS_PKCS7
    if (fMultiSigner) {
        DWORD dwSrcIndex1;

        fResult &= GetSignerInfoAndVerify(hMsg, fInnerNonData, 1, &dwSrcIndex1);
        if (fResult && dwSrcIndex == dwSrcIndex1)
            PrintError("Multiple signer:: Didn't get different signers");
    }
#endif  // CMS_PKCS7
    return fResult;
}


#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_CMS_RECIPIENT_INFO_PARAM 
// from the message
//--------------------------------------------------------------------------
PCMSG_CMS_RECIPIENT_INFO GetCmsRecipientFromMsg(
    IN HCRYPTMSG hMsg,
    IN DWORD dwIndex
    )
{
    PCMSG_CMS_RECIPIENT_INFO pRecipientInfo;
    DWORD cbData;

    if (!TCM_AllocGetParam(
            hMsg,
            CMSG_CMS_RECIPIENT_INFO_PARAM,
            dwIndex,
            (PBYTE *)&pRecipientInfo,
            &cbData))
        return NULL;

    return pRecipientInfo;
}

BOOL blobcmp(
    IN PCRYPT_DATA_BLOB pBlob1,
    IN PCRYPT_DATA_BLOB pBlob2
    )
{
    if (pBlob1->cbData != pBlob2->cbData)
        return FALSE;
    else if (0 == pBlob1->cbData)
        return TRUE;
    else if (0 == memcmp(pBlob1->pbData, pBlob2->pbData, pBlob1->cbData))
        return TRUE;
    else
        return FALSE;
}

BOOL bitblobcmp(
    IN PCRYPT_BIT_BLOB pBlob1,
    IN PCRYPT_BIT_BLOB pBlob2
    )
{
    if (pBlob1->cbData != pBlob2->cbData)
        return FALSE;
    else if (0 == pBlob1->cbData)
        return TRUE;
    else if (0 == memcmp(pBlob1->pbData, pBlob2->pbData, pBlob1->cbData))
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
// Get CMS Recipient info and decrypt the message.
//--------------------------------------------------------------------------
BOOL GetCmsRecipientInfoAndDecrypt(IN HCRYPTMSG hMsg)
{
    BOOL                    fResult;
    PCMSG_CMS_RECIPIENT_INFO pRecipientInfo = NULL;
    DWORD                   cRecipient;
    DWORD                   cbData;
    DWORD                   dwIndex;

    // Get # of CMS recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_CMS_RECIPIENT_COUNT_PARAM,
        0,                      // dwIndex
        &cRecipient,
        &cbData
        );
    if (!fResult) {
        PrintLastError(
            "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_COUNT_PARAM)");
        goto ErrorReturn;
    }
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_CMS_RECIPIENT_COUNT_PARAM,
            0,                      // dwIndex
            &cRecipient,
            cbData))
        goto CheckGetCmsRecipientCountError;
    if (cRecipient != cCmsRecipients) {
        PrintError("GetCmsRecipientInfoAndDecrypt::cRecipient != cCmsRecipients");
        goto ErrorReturn;
    }

    // Get all the recipients and verify
    for (dwIndex = 0; dwIndex < cRecipient; dwIndex++) {
        pRecipientInfo = GetCmsRecipientFromMsg(
            hMsg,
            dwIndex
            );

        if (pRecipientInfo == NULL) {
            PrintLastError(
                "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_INFO_PARAM)");
            goto ErrorReturn;
        }

        if (pRecipientInfo->dwRecipientChoice  !=
                rgCmsRecipient[dwIndex].dwRecipientChoice) {
            PrintError("GetCmsRecipientInfoAndDecrypt::Bad RecipientChoice");
            goto ErrorReturn;
        }

        switch (pRecipientInfo->dwRecipientChoice) {
        case CMSG_KEY_TRANS_RECIPIENT:
            {
                PCMSG_KEY_TRANS_RECIPIENT_INFO pDecode =
                    pRecipientInfo->pKeyTrans;
                PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pEncode =
                    &rgKeyTrans[dwIndex];

                if (0 != strcmp(pDecode->KeyEncryptionAlgorithm.pszObjId,
                        pEncode->KeyEncryptionAlgorithm.pszObjId))
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyEncryptionAlgorithm");
                if (pDecode->RecipientId.dwIdChoice != 
                        pEncode->RecipientId.dwIdChoice)
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad dwIdChoice");
                else {
                    switch (pDecode->RecipientId.dwIdChoice) {
                    case CERT_ID_ISSUER_SERIAL_NUMBER:
                        {
                            PCERT_ISSUER_SERIAL_NUMBER pDecodeRid =
                                &pDecode->RecipientId.IssuerSerialNumber;
                            PCERT_ISSUER_SERIAL_NUMBER pEncodeRid =
                                &pEncode->RecipientId.IssuerSerialNumber;
                        
                            if (CMSG_KEY_TRANS_PKCS_1_5_VERSION !=
                                    pDecode->dwVersion)
                                PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyTransPkcsVersion");
                            if (!blobcmp(&pDecodeRid->Issuer,
                                    &pEncodeRid->Issuer) ||
                                !blobcmp(&pDecodeRid->SerialNumber,
                                    &pEncodeRid->SerialNumber))
                                PrintError("GetCmsRecipientInfoAndDecrypt::Bad IssuerSerialNumber");
                        }
                        break;
                    case CERT_ID_KEY_IDENTIFIER:
                        {
                            PCRYPT_HASH_BLOB pDecodeRid =
                                &pDecode->RecipientId.KeyId;
                            PCRYPT_HASH_BLOB pEncodeRid =
                                &pEncode->RecipientId.KeyId;
                        
                            if (CMSG_KEY_TRANS_CMS_VERSION !=
                                    pDecode->dwVersion)
                                PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyTransCmsVersion");
                            if (!blobcmp(pDecodeRid, pEncodeRid))
                                PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyId");
                        }
                        break;
                    default:
                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad dwIdChoice");
                    }
                }
            }
            break;
        case CMSG_KEY_AGREE_RECIPIENT:
            {
                PCMSG_KEY_AGREE_RECIPIENT_INFO pDecode =
                    pRecipientInfo->pKeyAgree;
                PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pEncode =
                    &rgKeyAgree[dwIndex];

                if (CMSG_KEY_AGREE_VERSION != pDecode->dwVersion)
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyAgreePkcsVersion");

                if (!blobcmp(&pEncode->UserKeyingMaterial,
                        &pDecode->UserKeyingMaterial))
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad UserKeyingMaterial");

                if (0 != strcmp(pDecode->KeyEncryptionAlgorithm.pszObjId,
                        pEncode->KeyEncryptionAlgorithm.pszObjId))
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyEncryptionAlgorithm");

#if 0
                if (0 == _stricmp(pszEncryptName, "rc2")) {
                    if (0 == pDecode->KeyEncryptionAlgorithm.Parameters.cbData)
                        PrintError("GetCmsRecipientInfoAndDecrypt::Missing rc2 KeyEncryptionAlgorithm Parameters");
                    else {
                        int iVersion;
                        DWORD cbData;

                        cbData = sizeof(iVersion);
                        if (!CryptDecodeObject(
                                PKCS_7_ASN_ENCODING,
                                X509_INTEGER,
                                pDecode->KeyEncryptionAlgorithm.Parameters.pbData,
                                pDecode->KeyEncryptionAlgorithm.Parameters.cbData,
                                0,                              // dwFlags
                                &iVersion,
                                &cbData))
                            PrintLastError("GetCmsRecipientInfoAndDecrypt::CryptDecodeObject(rc2 KeyEncryptionAlgorithm Parameters)");
                        else {
                            DWORD dwEncodeBitLen;
                            DWORD dwDecodeBitLen;

                            dwEncodeBitLen = dwEncryptBitLen;
                            if (0 == dwEncodeBitLen)
                                dwEncodeBitLen = 40;

                            switch (iVersion) {
                                case CRYPT_RC2_40BIT_VERSION:
                                    dwDecodeBitLen = 40;
                                    break;
                                case CRYPT_RC2_56BIT_VERSION:
                                    dwDecodeBitLen = 56;
                                    break;
                                case CRYPT_RC2_64BIT_VERSION:
                                    dwDecodeBitLen = 64;
                                    break;
                                case CRYPT_RC2_128BIT_VERSION:
                                    dwDecodeBitLen = 128;
                                    break;
                                default:
                                    dwDecodeBitLen = 0;
                                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad Decode BitLen");
                            }
                            if (dwDecodeBitLen != dwEncodeBitLen)
                                    PrintError("GetCmsRecipientInfoAndDecrypt::Decode != Encode BitLen");
                        }
                    }
                } else {
                    BYTE rgbNull[] = {0x5, 0x0};
                    CRYPT_DATA_BLOB NullBlob = {sizeof(rgbNull), rgbNull};

                    if (!blobcmp(&NullBlob,
                            &pDecode->KeyEncryptionAlgorithm.Parameters))
                        PrintError("GetCmsRecipientInfoAndDecrypt::Expected NULL KeyEncryptionAlgorithm Parameters");
                }
#endif

                if (CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY !=
                        pDecode->dwOriginatorChoice)
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad dwOriginatorChoice");
                else {
                    if (0 != strcmp(
                            pDecode->OriginatorPublicKeyInfo.Algorithm.pszObjId,
                            pEncode->pEphemeralAlgorithm->pszObjId))
                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad Originator public key Algorithm");
                    if (0 != pDecode->OriginatorPublicKeyInfo.Algorithm.Parameters.cbData)
                        PrintError("GetCmsRecipientInfoAndDecrypt::Not NO Originator public key Parameters");
                }

                if (pEncode->cRecipientEncryptedKeys !=
                        pDecode->cRecipientEncryptedKeys)
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad Encrypted Key Agree Count");
                else {
                    DWORD i;
                    for (i = 0; i < pEncode->cRecipientEncryptedKeys; i++) {
                        PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO pEncodeKey =
                            pEncode->rgpRecipientEncryptedKeys[i];

                        PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO pDecodeKey =
                            pDecode->rgpRecipientEncryptedKeys[i];

                        if (pDecodeKey->RecipientId.dwIdChoice != 
                                pEncodeKey->RecipientId.dwIdChoice)
                            PrintError("GetCmsRecipientInfoAndDecrypt::Bad dwIdChoice");
                        else {
                            switch (pDecodeKey->RecipientId.dwIdChoice) {
                            case CERT_ID_ISSUER_SERIAL_NUMBER:
                                {
                                    PCERT_ISSUER_SERIAL_NUMBER pDecodeRid =
                                        &pDecodeKey->RecipientId.IssuerSerialNumber;
                                    PCERT_ISSUER_SERIAL_NUMBER pEncodeRid =
                                        &pEncodeKey->RecipientId.IssuerSerialNumber;
                                
                                    if (!blobcmp(&pDecodeRid->Issuer,
                                            &pEncodeRid->Issuer) ||
                                        !blobcmp(&pDecodeRid->SerialNumber,
                                            &pEncodeRid->SerialNumber))
                                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad IssuerSerialNumber");
                                }
                                break;
                            case CERT_ID_KEY_IDENTIFIER:
                                {
                                    PCRYPT_HASH_BLOB pDecodeRid =
                                        &pDecodeKey->RecipientId.KeyId;
                                    PCRYPT_HASH_BLOB pEncodeRid =
                                        &pEncodeKey->RecipientId.KeyId;
                                
                                    if (!blobcmp(pDecodeRid, pEncodeRid))
                                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyId");

                                    if (0 != CompareFileTime(&pDecodeKey->Date,
                                            &pEncodeKey->Date))
                                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad Date");

                                    if (NULL == pEncodeKey->pOtherAttr) {
                                        if (NULL != pDecodeKey->pOtherAttr)
                                            PrintError("GetCmsRecipientInfoAndDecrypt::Unexpected OtherAttr");
                                    } else if (NULL == pDecodeKey->pOtherAttr) {
                                        PrintError("GetCmsRecipientInfoAndDecrypt::Missing OtherAttr");
                                    } else {
                                        PCRYPT_ATTRIBUTE_TYPE_VALUE
                                            pDecodeOther =
                                                pDecodeKey->pOtherAttr;
                                        PCRYPT_ATTRIBUTE_TYPE_VALUE
                                            pEncodeOther =
                                                pEncodeKey->pOtherAttr;

                                        if (0 != strcmp(pDecodeOther->pszObjId,
                                                pEncodeOther->pszObjId))
                                            PrintError("GetCmsRecipientInfoAndDecrypt::Bad OtherAttr OID");
                                        if (!blobcmp(&pDecodeOther->Value, &pEncodeOther->Value))
                                            PrintError("GetCmsRecipientInfoAndDecrypt::Bad OtherAttr Value");
                                    }
                                }
                                break;
                            default:
                                PrintError("GetCmsRecipientInfoAndDecrypt::Bad dwIdChoice");
                            }
                        }
                    }
                }
            }
            break;
        case CMSG_MAIL_LIST_RECIPIENT:
            {
                PCMSG_MAIL_LIST_RECIPIENT_INFO pDecode =
                    pRecipientInfo->pMailList;
                PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pEncode =
                    &rgMailList[dwIndex];

                if (CMSG_MAIL_LIST_VERSION != pDecode->dwVersion)
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad MailListVersion");
                {
                    PCRYPT_HASH_BLOB pDecodeKeyId =
                        &pDecode->KeyId;
                    PCRYPT_HASH_BLOB pEncodeKeyId =
                        &pEncode->KeyId;
                
                    if (!blobcmp(pDecodeKeyId, pEncodeKeyId))
                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyId");
                }
                if (0 != strcmp(pDecode->KeyEncryptionAlgorithm.pszObjId,
                        pEncode->KeyEncryptionAlgorithm.pszObjId))
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad KeyEncryptionAlgorithm");
                if (0 == _stricmp(pszEncryptName, "rc2")) {
                    if (0 == pDecode->KeyEncryptionAlgorithm.Parameters.cbData)
                        PrintError("GetCmsRecipientInfoAndDecrypt::Missing rc2 KeyEncryptionAlgorithm Parameters");
                    else {
                        int iVersion;
                        DWORD cbData;

                        cbData = sizeof(iVersion);
                        if (!CryptDecodeObject(
                                PKCS_7_ASN_ENCODING,
                                X509_INTEGER,
                                pDecode->KeyEncryptionAlgorithm.Parameters.pbData,
                                pDecode->KeyEncryptionAlgorithm.Parameters.cbData,
                                0,                              // dwFlags
                                &iVersion,
                                &cbData))
                            PrintLastError("GetCmsRecipientInfoAndDecrypt::CryptDecodeObject(rc2 KeyEncryptionAlgorithm Parameters)");
                        else {
                            DWORD dwEncodeBitLen;
                            DWORD dwDecodeBitLen;

                            dwEncodeBitLen = dwEncryptBitLen;
                            if (0 == dwEncodeBitLen)
                                dwEncodeBitLen = 40;

                            switch (iVersion) {
                                case CRYPT_RC2_40BIT_VERSION:
                                    dwDecodeBitLen = 40;
                                    break;
                                case CRYPT_RC2_56BIT_VERSION:
                                    dwDecodeBitLen = 56;
                                    break;
                                case CRYPT_RC2_64BIT_VERSION:
                                    dwDecodeBitLen = 64;
                                    break;
                                case CRYPT_RC2_128BIT_VERSION:
                                    dwDecodeBitLen = 128;
                                    break;
                                default:
                                    dwDecodeBitLen = 0;
                                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad Decode BitLen");
                            }
                            if (dwDecodeBitLen != dwEncodeBitLen)
                                    PrintError("GetCmsRecipientInfoAndDecrypt::Decode != Encode BitLen");
                        }
                    }
                } else {
                    if (0 != pDecode->KeyEncryptionAlgorithm.Parameters.cbData)
                        PrintError("GetCmsRecipientInfoAndDecrypt::Expected NO, NULL KeyEncryptionAlgorithm Parameters");
                }

                if (0 != CompareFileTime(&pDecode->Date, &pEncode->Date))
                    PrintError("GetCmsRecipientInfoAndDecrypt::Bad Date");

                if (NULL == pEncode->pOtherAttr) {
                    if (NULL != pDecode->pOtherAttr)
                        PrintError("GetCmsRecipientInfoAndDecrypt::Unexpected OtherAttr");
                } else if (NULL == pDecode->pOtherAttr) {
                    PrintError("GetCmsRecipientInfoAndDecrypt::Missing OtherAttr");
                } else {
                    PCRYPT_ATTRIBUTE_TYPE_VALUE pDecodeOther =
                        pDecode->pOtherAttr;
                    PCRYPT_ATTRIBUTE_TYPE_VALUE pEncodeOther =
                        pEncode->pOtherAttr;

                    if (0 != strcmp(pDecodeOther->pszObjId,
                            pEncodeOther->pszObjId))
                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad OtherAttr OID");
                    if (!blobcmp(&pDecodeOther->Value, &pEncodeOther->Value))
                        PrintError("GetCmsRecipientInfoAndDecrypt::Bad OtherAttr Value");
                }
            }
            break;
        default:
            PrintError( "GetCmsRecipientInfoAndDecrypt::Bad RecipientChoice");
            goto ErrorReturn;

        }

        TestFree(pRecipientInfo);
        pRecipientInfo = NULL;
    }

    pRecipientInfo = GetCmsRecipientFromMsg(hMsg, cRecipient -1);
    if (pRecipientInfo == NULL) {
        PrintLastError(
            "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_INFO_PARAM)");
        goto ErrorReturn;
    }

    switch (pRecipientInfo->dwRecipientChoice) {
    case CMSG_KEY_TRANS_RECIPIENT:
        {
            CMSG_CTRL_KEY_TRANS_DECRYPT_PARA  DecryptPara;
            DWORD dwDecryptIndex;

            DecryptPara.cbSize = sizeof(DecryptPara);
            DecryptPara.hCryptProv = hCryptProv;
            DecryptPara.dwKeySpec = 0;
            DecryptPara.pKeyTrans = pRecipientInfo->pKeyTrans;
            DecryptPara.dwRecipientIndex = cRecipient -1;
            fResult = CryptMsgControl(
                hMsg,
                0,                  // dwFlags
                CMSG_CTRL_KEY_TRANS_DECRYPT,
                &DecryptPara
                );
            if (!fResult) {
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgControl(CMSG_CTRL_KEY_TRANS_DECRYPT)");
                goto ErrorReturn;
            }

            cbData = sizeof(dwDecryptIndex);
            dwDecryptIndex = 0;
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CMS_RECIPIENT_INDEX_PARAM,
                0,                      // dwIndex
                &dwDecryptIndex,
                &cbData
                );
            if (!fResult)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_INDEX_PARAM)");
            else if (dwDecryptIndex != cRecipient -1)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::Bad CMS decrypt Index");

            cbData = sizeof(dwDecryptIndex);
            dwDecryptIndex = 0;
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_RECIPIENT_INDEX_PARAM,
                0,                      // dwIndex
                &dwDecryptIndex,
                &cbData
                );
            if (!fResult)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_RECIPIENT_INDEX_PARAM)");
            else if (dwDecryptIndex != PkcsRecipientCount -1)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::Bad PKCS decrypt Index");
        }
        break;
    case CMSG_KEY_AGREE_RECIPIENT:
        {
            CMSG_CTRL_KEY_AGREE_DECRYPT_PARA  DecryptPara;
            DWORD dwDecryptIndex;

            DecryptPara.cbSize = sizeof(DecryptPara);
            DecryptPara.hCryptProv = hKeyAgreeProv;
            DecryptPara.dwKeySpec = AT_KEYEXCHANGE;
            DecryptPara.pKeyAgree = pRecipientInfo->pKeyAgree;
            DecryptPara.dwRecipientIndex = cRecipient -1;
            DecryptPara.dwRecipientEncryptedKeyIndex =
                pRecipientInfo->pKeyAgree->cRecipientEncryptedKeys -1;
            DecryptPara.OriginatorPublicKey =
                pRecipientInfo->pKeyAgree->OriginatorPublicKeyInfo.PublicKey;
            fResult = CryptMsgControl(
                hMsg,
                0,                  // dwFlags
                CMSG_CTRL_KEY_AGREE_DECRYPT,
                &DecryptPara
                );
            if (!fResult) {
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgControl(CMSG_CTRL_KEY_AGREE_DECRYPT)");
                goto ErrorReturn;
            }

            cbData = sizeof(dwDecryptIndex);
            dwDecryptIndex = 0;
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CMS_RECIPIENT_INDEX_PARAM,
                0,                      // dwIndex
                &dwDecryptIndex,
                &cbData
                );
            if (!fResult)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_INDEX_PARAM)");
            else if (dwDecryptIndex != cRecipient -1)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::Bad CMS decrypt Index");

            cbData = sizeof(dwDecryptIndex);
            dwDecryptIndex = 0;
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM,
                0,                      // dwIndex
                &dwDecryptIndex,
                &cbData
                );
            if (!fResult)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM)");
            else if (dwDecryptIndex !=  DecryptPara.dwRecipientEncryptedKeyIndex)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::Bad CMS encrypted key Index");
        }
        break;
    case CMSG_MAIL_LIST_RECIPIENT:
        {
            CMSG_CTRL_MAIL_LIST_DECRYPT_PARA  DecryptPara;
            DWORD dwDecryptIndex;

            DecryptPara.cbSize = sizeof(DecryptPara);
            DecryptPara.pMailList = pRecipientInfo->pMailList;
            DecryptPara.dwRecipientIndex = cRecipient -1;
            DecryptPara.dwKeyChoice = CMSG_MAIL_LIST_HANDLE_KEY_CHOICE;
            if (fRecipientProv)
                DecryptPara.hCryptProv = GetCryptProv();
            else
                DecryptPara.hCryptProv = hCryptProv;

            DecryptPara.hKeyEncryptionKey = GenerateMailListKey(
                DecryptPara.hCryptProv,
                &DecryptPara.pMailList->KeyId
                );

            printf("Decrypting using MailList recipient\n");
            fResult = CryptMsgControl(
                hMsg,
                fRecipientProv ? CMSG_CRYPT_RELEASE_CONTEXT_FLAG : 0,
                CMSG_CTRL_MAIL_LIST_DECRYPT,
                &DecryptPara
                );
            if (DecryptPara.hKeyEncryptionKey) {
                DWORD dwErr = GetLastError();
                CryptDestroyKey(DecryptPara.hKeyEncryptionKey); 
                SetLastError(dwErr);
            }
            if (!fResult) {
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgControl(CMSG_CTRL_MAIL_LIST_DECRYPT)");
                goto ErrorReturn;
            }

            cbData = sizeof(dwDecryptIndex);
            dwDecryptIndex = 0;
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CMS_RECIPIENT_INDEX_PARAM,
                0,                      // dwIndex
                &dwDecryptIndex,
                &cbData
                );
            if (!fResult)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_CMS_RECIPIENT_INDEX_PARAM)");
            else if (dwDecryptIndex != cRecipient -1)
                PrintLastError(
                    "GetCmsRecipientInfoAndDecrypt::Bad CMS decrypt Index");
        }
        break;
    default:
        PrintError("GetCmsRecipientInfoAndDecrypt::Bad RecipientChoice");
        goto ErrorReturn;

    }

CommonReturn:
    TestFree(pRecipientInfo);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
PRINT_ERROR(GetCmsRecipientInfoAndDecrypt,CheckGetCmsRecipientCountError)
}

BOOL VerifyUnprotectedAttr(IN HCRYPTMSG hMsg)
{
    BOOL    fResult;
    DWORD   cbAttrs;
    DWORD   i;
    PCRYPT_ATTRIBUTES pAttrs = NULL;
    PCRYPT_ATTRIBUTE patr1;
    PCRYPT_ATTRIBUTE patr2;

    if (!TCM_AllocGetParam(
            hMsg,
            CMSG_UNPROTECTED_ATTR_PARAM,
            0,                      // dwIndex
            (PBYTE *) &pAttrs,
            &cbAttrs)) {
        goto GetAttrError;
    }

    if (pAttrs->cAttr != EnvelopedMsgEncodeInfo.cUnprotectedAttr)
        goto AttrCountError; 


    for (i=pAttrs->cAttr,
            patr1=EnvelopedMsgEncodeInfo.rgUnprotectedAttr,
            patr2=pAttrs->rgAttr;
                i>0;
                i--, patr1++, patr2++) {
        if (!EqualAttribute( patr1, patr2))
            goto AttrValueError;
    }

    fResult = TRUE;
CommonReturn:
    TestFree(pAttrs);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

PRINT_ERROR(VerifyUnprotectedAttr,GetAttrError)
PRINT_ERROR(VerifyUnprotectedAttr,AttrCountError)
PRINT_ERROR(VerifyUnprotectedAttr,AttrValueError)
}

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
// Get recipient info and decrypt the message.
//--------------------------------------------------------------------------
BOOL GetRecipientInfoAndDecrypt(IN HCRYPTMSG hMsg)
{
    BOOL                    fResult;
    PCERT_INFO              pRecipientInfo = NULL;
    DWORD                   cRecipient;
    DWORD                   cbData;
    DWORD                   dwIndex;
    CMSG_CTRL_DECRYPT_PARA  DecryptPara;
#ifdef CMS_PKCS7
    BYTE                    *pbCiphertext = NULL;
    DWORD                   cbCiphertext;
#endif  // CMS_PKCS7
    DWORD                   cKeyIdRecipient;

    // Get # of recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_RECIPIENT_COUNT_PARAM,
        0,                      // dwIndex
        &cRecipient,
        &cbData
        );
    if (!fResult) {
        PrintLastError(
            "GetRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_RECIPIENT_COUNT_PARAM)");
        goto ErrorReturn;
    }
    if (!TCM_CheckGetParam(
            hMsg,
            CMSG_RECIPIENT_COUNT_PARAM,
            0,                      // dwIndex
            &cRecipient,
            cbData))
        goto CheckGetRecipientCountError;
    if (fNoRecipients
#ifdef CMS_PKCS7
            || ((fMailList || fKeyAgree) && !fKeyTrans)
#endif  // CMS_PKCS7
            ) {
        if (cRecipient != 0) {
            PrintError("GetRecipientInfoAndDecrypt::cRecipient != 0");
            goto ErrorReturn;
        }
    } else {
        if (cRecipient != PkcsRecipientCount) {
            PrintError("GetRecipientInfoAndDecrypt::cRecipient != PkcsRecipientCount");
            goto ErrorReturn;
        }
    }

#ifdef CMS_PKCS7
    if (fKeyTrans && fRecipientKeyId && !fNoRecipients) {
        // The first RECIPIENT_COUNT recipients should be KeyId recipients
        cKeyIdRecipient = RECIPIENT_COUNT;

        // Get all the KeyId recipients and verify
        for (dwIndex = 0; dwIndex < RECIPIENT_COUNT; dwIndex++) {
            // Allocate and get the CERT_INFO containing the Special
            // KeyId RecipientId
            PCERT_NAME_INFO pKeyIdName = NULL;
            DWORD cbKeyIdName;
            CRYPT_HASH_BLOB KeyId;

            pRecipientInfo = GetCertIdFromMsg(
                hMsg,
                CMSG_RECIPIENT_INFO_PARAM,
                dwIndex
                );

            if (pRecipientInfo == NULL) {
                PrintLastError(
                    "GetRecipientInfoAndDecrypt::CryptMsgGetParam(KEYID CMSG_RECIPIENT_INFO_PARAM)");
                goto ErrorReturn;
            }

            if (pRecipientInfo->SerialNumber.cbData != 1 ||
                    *pRecipientInfo->SerialNumber.pbData != 0)
                PrintError("GetRecipientInfoAndDecrypt::Bad KeyId SerialNumber");

            // Decode the Issuer Name. It should contain the special KeyId
            // RDN

            if (AllocAndDecodeObject(
                    X509_NAME,
                    pRecipientInfo->Issuer.pbData,
                    pRecipientInfo->Issuer.cbData,
                    (void **) &pKeyIdName,
                    &cbKeyIdName
                    )) {

                    if (pKeyIdName->cRDN != 1 ||
                            pKeyIdName->rgRDN[0].cRDNAttr != 1)
                        PrintError("GetRecipientInfoAndDecrypt::Bad KeyId Issuer");
                    else {
                        PCERT_RDN_ATTR pAttr = pKeyIdName->rgRDN[0].rgRDNAttr;

                        if (0 != strcmp(pAttr->pszObjId, szOID_KEYID_RDN) ||
                                pAttr->dwValueType != CERT_RDN_OCTET_STRING ||
                                pAttr->Value.cbData !=
                                    strlen(rgpszRecipientIssuerFileName[dwIndex]) ||
                                0 != memcmp(pAttr->Value.pbData,
                                    rgpszRecipientIssuerFileName[dwIndex],
                                    pAttr->Value.cbData))
                            PrintError("GetRecipientInfoAndDecrypt::Bad KeyId Issuer");
                    }

                TestFree(pKeyIdName);
            }

            if (!Asn1UtilExtractKeyIdFromCertInfo(
                    pRecipientInfo,
                    &KeyId))
                PrintError("GetRecipientInfoAndDecrypt::Asn1UtilExtractKeyIdFromCertInfo failed");
            else if (KeyId.cbData !=
                        strlen(rgpszRecipientIssuerFileName[dwIndex]) ||
                    0 != memcmp(KeyId.pbData,
                        rgpszRecipientIssuerFileName[dwIndex], KeyId.cbData))
                PrintError("GetRecipientInfoAndDecrypt::Asn1UtilExtractKeyIdFromCertInfo compare failed");

            TestFree(pRecipientInfo);
            pRecipientInfo = NULL;
        }
    } else
#endif  // CMS_PKCS7
        cKeyIdRecipient = 0;

    // Get all the non KeyId recipients and verify
    for (dwIndex = 0; dwIndex < cRecipient - cKeyIdRecipient; dwIndex++) {
        // Allocate and get the CERT_INFO containing the RecipientId
        // (Issuer and SerialNumber)

#ifdef CMS_PKCS7
        CRYPT_HASH_BLOB KeyId;
        BOOL fExtractKeyId;
#endif  // CMS_PKCS7

        pRecipientInfo = GetCertIdFromMsg(
            hMsg,
            CMSG_RECIPIENT_INFO_PARAM,
            cKeyIdRecipient + dwIndex
            );

        if (pRecipientInfo == NULL) {
            PrintLastError(
                "GetRecipientInfoAndDecrypt::CryptMsgGetParam(CMSG_RECIPIENT_INFO_PARAM)");
            goto ErrorReturn;
        }
        if (pRecipientInfo->Issuer.cbData !=
                rgRecipientCertInfo[dwIndex].Issuer.cbData ||
            memcmp(pRecipientInfo->Issuer.pbData,
                rgRecipientCertInfo[dwIndex].Issuer.pbData,
                pRecipientInfo->Issuer.cbData) != 0 ||
            pRecipientInfo->SerialNumber.cbData !=
                rgRecipientCertInfo[dwIndex].SerialNumber.cbData ||
            memcmp(pRecipientInfo->SerialNumber.pbData,
                rgRecipientCertInfo[dwIndex].SerialNumber.pbData,
                pRecipientInfo->SerialNumber.cbData) != 0) {
            PrintError("GetRecipientInfoAndDecrypt::Bad RecipientInfo");
        }

#ifdef CMS_PKCS7
        fExtractKeyId = Asn1UtilExtractKeyIdFromCertInfo(
                pRecipientInfo,
                &KeyId);
        if (fCertInfoKeyId) {
            if (!fExtractKeyId)
                PrintError("GetRecipientInfoAndDecrypt::Asn1UtilExtractKeyIdFromCertInfo failed for CertInfoKeyId");
        } else if (fExtractKeyId)
            PrintError("GetRecipientInfoAndDecrypt::Asn1UtilExtractKeyIdFromCertInfo should have failed for nonKeyId");
#endif  // CMS_PKCS7

        TestFree(pRecipientInfo);
        pRecipientInfo = NULL;
    }

#ifdef CMS_PKCS7
    if (fOriginatorInfo)
        VerifyCerts(hMsg);

    if (fAuthAttr)
        VerifyUnprotectedAttr(hMsg);

    // Get ciphertext
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_CONTENT_PARAM,
        0,                      // dwIndex
        NULL,                   // pvData
        &cbCiphertext
        );
    if (!fResult)
        PrintLastError("GetRecipientInfoAndDecrypt::CryptMsgGetParam(ciphertext length)");
    else {
        if (pbCiphertext = (BYTE *) TestAlloc(cbCiphertext)) {
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CONTENT_PARAM,
                0,                      // dwIndex
                pbCiphertext,
                &cbCiphertext
                );
            if (!fResult)
                PrintLastError("GetRecipientInfoAndDecrypt::CryptMsgGetParam(ciphertext content)");
            TestFree(pbCiphertext);
            pbCiphertext = NULL;
        }
    }

    if (fCmsRecipient) {
        fResult = GetCmsRecipientInfoAndDecrypt(hMsg);
        goto CommonReturn;
    }
#endif  // CMS_PKCS7

    if (fNoRecipients) {
        fResult = TRUE;
        goto CommonReturn;
    }

    DecryptPara.cbSize = sizeof(DecryptPara);
    DecryptPara.hCryptProv = hCryptProv;
    DecryptPara.dwKeySpec = 0;
    DecryptPara.dwRecipientIndex = RECIPIENT_COUNT -1;
    fResult = CryptMsgControl(
        hMsg,
        0,                  // dwFlags
        CMSG_CTRL_DECRYPT,
        &DecryptPara
        );
    if (!fResult) {
        PrintLastError(
            "GetRecipientInfoAndDecrypt::CryptMsgControl(CMSG_CTRL_DECRYPT)");
        goto ErrorReturn;
    }

    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;

CommonReturn:
    TestFree(pRecipientInfo);

    return fResult;
PRINT_ERROR(GetRecipientInfoAndDecrypt,CheckGetRecipientCountError)
}

void CompareCertIdWithCertInfo(
    IN PCERT_ID pCertId,
    IN PCERT_INFO pCertInfo
    )
{
    BOOL fKeyId;
    CRYPT_HASH_BLOB KeyId;
    
    fKeyId = Asn1UtilExtractKeyIdFromCertInfo(pCertInfo, &KeyId);
    switch(pCertId->dwIdChoice) {
        case CERT_ID_ISSUER_SERIAL_NUMBER:
            if (fKeyId)
                printf("CompareCertIdWithCertInfo:: failed => bad IssuerSerialNumber choice\n");
            else if (pCertInfo->Issuer.cbData !=
                pCertId->IssuerSerialNumber.Issuer.cbData ||
                    0 != memcmp(pCertInfo->Issuer.pbData,
                        pCertId->IssuerSerialNumber.Issuer.pbData,
                        pCertInfo->Issuer.cbData) ||
                pCertInfo->SerialNumber.cbData !=
                    pCertId->IssuerSerialNumber.SerialNumber.cbData ||
                        0 != memcmp(pCertInfo->SerialNumber.pbData,
                            pCertId->IssuerSerialNumber.SerialNumber.pbData,
                            pCertInfo->SerialNumber.cbData))
                printf("CompareCertIdWithCertInfo:: failed => bad IssuerSerialNumber comparison\n");
            break;
        case CERT_ID_KEY_IDENTIFIER:
            if (!fKeyId)
                printf("CompareCertIdWithCertInfo:: failed => bad KeyId choice\n");
            else if (KeyId.cbData != pCertId->KeyId.cbData ||
                    0 != memcmp(KeyId.pbData,
                        pCertId->KeyId.pbData,
                        KeyId.cbData))
                printf("CompareCertIdWithCertInfo:: failed => bad KeyId comparison\n");
            break;
        default:
            printf("CompareCertIdWithCertInfo:: failed => invalid dwIdChoice\n");
            break;
    }
}

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_SIGNER_INFO_PARAM from the message
//--------------------------------------------------------------------------
PCMSG_SIGNER_INFO GetSignerInfoFromMsg(
    IN HCRYPTMSG hMsg,
    IN DWORD dwIndex
    )
{
    PCMSG_SIGNER_INFO    psi;
    DWORD           cbData;

    if (!TCM_AllocGetParam(
            hMsg,
            CMSG_SIGNER_INFO_PARAM,
            dwIndex,
            (PBYTE *)&psi,
            &cbData))
        return NULL;

#ifdef CMS_PKCS7
    PCMSG_CMS_SIGNER_INFO    pCMSsi;

    if (TCM_AllocGetParam(
            hMsg,
            CMSG_CMS_SIGNER_INFO_PARAM,
            dwIndex,
            (PBYTE *)&pCMSsi,
            &cbData)) {
        CERT_INFO CertInfo;
        CertInfo.Issuer = psi->Issuer;
        CertInfo.SerialNumber = psi->SerialNumber;
        CompareCertIdWithCertInfo(&pCMSsi->SignerId, &CertInfo);
        TestFree(pCMSsi);
    }
#endif  // CMS_PKCS7

    return psi;
}

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_SIGNER_CERT_INFO_PARAM or CMSG_RECIPIENT_INFO_PARAM
// from the message
//--------------------------------------------------------------------------
PCERT_INFO GetCertIdFromMsg(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    )
{
    PCERT_INFO pCertId;
    DWORD cbData;

    if (!TCM_AllocGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            (PBYTE *)&pCertId,
            &cbData))
        return NULL;

#ifdef CMS_PKCS7
    if (CMSG_SIGNER_CERT_INFO_PARAM == dwParamType) {
        PCERT_ID pSignerId;

        if (TCM_AllocGetParam(
                hMsg,
                CMSG_SIGNER_CERT_ID_PARAM,
                dwIndex,
                (PBYTE *)&pSignerId,
                &cbData)) {
            CompareCertIdWithCertInfo(pSignerId, pCertId);
            TestFree(pSignerId);
        }
    }
#endif  // CMS_PKCS7

    return pCertId;
}


//+-------------------------------------------------------------------------
// Get computed digest and digest data from a decoded CMSG_HASHED
//--------------------------------------------------------------------------
BOOL Undigest(IN HCRYPTMSG hMsg)
{
    return CryptMsgControl( hMsg, 0, CMSG_CTRL_VERIFY_HASH, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tchain\tchain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tchain.cpp
//
//  Contents:   Chain threading tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    28-Mar-00   philh   created
//--------------------------------------------------------------------------

#define CERT_CHAIN_PARA_HAS_EXTRA_FIELDS    1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


#define CTRL_THR_CNT                3
#define RESYNC_THR_IDX              0
#define DELETE_THR_IDX              1
#define REPLACE_THR_IDX             2

HANDLE rghCtrlThread[CTRL_THR_CNT];
DWORD rgdwCtrlIterations[CTRL_THR_CNT];
DWORD rgdwCtrlSleepMilliSeconds[CTRL_THR_CNT];

#define MAX_CHAIN_THR_CNT           16
HANDLE rghChainThread[MAX_CHAIN_THR_CNT];
DWORD rgdwChainIterations[MAX_CHAIN_THR_CNT];

LONG lIterations = -1;
BOOL fCreateEndCert = FALSE;

HCERTSTORE hStore = NULL;
HCERTSTORE hCaStore = NULL;
HCERTSTORE hAdditionalChainStore = NULL;
PCCERT_CONTEXT pReplaceCertContext = NULL;
PCCERT_CONTEXT pDeleteCertContext = NULL;
HCERTCHAINENGINE hChainEngine = NULL;

#define MAX_USAGE_CNT               16
LPSTR rgpszUsageOID[MAX_USAGE_CNT];
DWORD cUsageOID = 0;
CERT_CHAIN_PARA ChainPara;

DWORD dwChainFlags = 0;
BOOL fDone = FALSE;


static void Usage(void)
{
    printf("Usage: tchain [options] <StoreName>\n");
    printf("\n");
    printf("  -CreateEndCert    - Create new end cert for each chain\n");
    printf("  -LocalMachine     - Defaults to CurrentUser\n");
    printf("  -Pause\n");
    printf("\n");
    printf("Options are:\n");
    printf("  -u<OID String>    - Usage OID string -u1.3.6.1.5.5.7.3.3\n");
    printf("  -t<number>        - Threads (defaults to 4)\n");
    printf("  -i<number>        - Iterations (defaults to -1, infinite)\n");
    printf("  -l<number>        - Lru cache count, enable end cert caching\n");
    printf("  -f<Number>        - Chain Flags\n");
    printf("  -T<number>        - Url Timeout (milliseconds)\n");
    printf("  -F<number>        - Revocation Freshness (seconds)\n");
    printf("  -r[<number>]      - Resync engine, defaults to 2K millisecs\n");
    printf("  -d[<num>] <cert>  - Delete cert from CA store\n");
    printf("  -R[<num>] <cert>  - Replace cert in CA store\n");
    printf("  -s                - Open the \"StoreName\" System store\n");
    printf("  -a<filename>      - Additional chain store filename\n");
    printf("  -A<filename>      - Additional engine store filename\n");
    printf("  -h                - This message\n");
    printf("\n");
}


DWORD WINAPI ChainThreadProc(
    LPVOID lpThreadParameter
    )
{
    DWORD dwThrIdx = (DWORD) ((DWORD_PTR) lpThreadParameter);

    if (dwThrIdx >= MAX_CHAIN_THR_CNT) {
        printf("Invalid dwThrIdx\n");
        return 0;
    }

    while (TRUE) {
        PCCERT_CONTEXT pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
            PCCERT_CONTEXT pCreateCert = NULL;
            PCCERT_CHAIN_CONTEXT pChainContext = NULL;

            if (fCreateEndCert) {
                pCreateCert = CertCreateCertificateContext(
                    pCert->dwCertEncodingType,
                    pCert->pbCertEncoded,
                    pCert->cbCertEncoded
                    );
                if (NULL == pCreateCert) {
                    PrintLastError("CertCreateCertificateContext");
                    return 0;
                }
            }


            if (!CertGetCertificateChain(
                    hChainEngine,
                    fCreateEndCert ? pCreateCert : pCert,
                    NULL,                                   // pTime
                    hAdditionalChainStore,
                    &ChainPara,
                    dwChainFlags,
                    NULL,                                   // pvReserved
                    &pChainContext
                    )) {
                PrintLastError("CertGetCertificateChain");
                return 0;
            }

            CertFreeCertificateChain(pChainContext);
            if (pCreateCert)
                CertFreeCertificateContext(pCreateCert);
        }

        rgdwChainIterations[dwThrIdx]++;
        if (lIterations > 0 &&
                rgdwChainIterations[dwThrIdx] >= (DWORD) lIterations)
            break;
    }

    return 0;
}

DWORD WINAPI ResyncThreadProc(
    LPVOID lpThreadParameter
    )
{
    while (TRUE) {
        if (fDone)
            break;

        if (!CertResyncCertificateChainEngine(hChainEngine)) {
            PrintLastError("CertResyncCertificateChainEngine");
            return 0;
        }

        rgdwCtrlIterations[RESYNC_THR_IDX]++;
        Sleep(rgdwCtrlSleepMilliSeconds[RESYNC_THR_IDX]);
    }

    return 0;
}

DWORD WINAPI DeleteThreadProc(
    LPVOID lpThreadParameter
    )
{
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB HashBlob;

    HashBlob.cbData = MAX_HASH_LEN;
    HashBlob.pbData = rgbHash;

    if (!CertGetCertificateContextProperty(
            pDeleteCertContext,
            CERT_MD5_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            )) {
        PrintLastError("CertGetCertificateContextProperty");
        return 0;
    }

    while (TRUE) {
        PCCERT_CONTEXT pFound = NULL;

        if (fDone)
            break;

        pFound = CertFindCertificateInStore(
            hCaStore,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            0,
            CERT_FIND_MD5_HASH,
            &HashBlob,
            NULL
            );

        if (pFound) {
            CertDeleteCertificateFromStore(pFound);
            rgdwCtrlIterations[DELETE_THR_IDX]++;
        }

        Sleep(rgdwCtrlSleepMilliSeconds[DELETE_THR_IDX]);
    }

    return 0;
}

DWORD WINAPI ReplaceThreadProc(
    LPVOID lpThreadParameter
    )
{
    while (TRUE) {
        if (fDone)
            break;

        if (!CertAddCertificateContextToStore(
                hCaStore,
                pReplaceCertContext,
                CERT_STORE_ADD_REPLACE_EXISTING,
                NULL                                // ppStoreContext
                )) {
            PrintLastError("CertAddCertificateContextToStore");
            return 0;
        }

        rgdwCtrlIterations[REPLACE_THR_IDX]++;
        Sleep(rgdwCtrlSleepMilliSeconds[REPLACE_THR_IDX]);
    }

    return 0;
}



PCCERT_CONTEXT ReadCert(
    IN LPSTR pszCert
    )
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszCert, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCert");
        return NULL;
    }

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL)
        PrintLastError("CertCreateCertificateContext");

    TestFree(pbEncoded);
    return pCert;
}

int _cdecl main(int argc, char * argv[]) 
{
    int status;

    LPSTR pszAdditionalChainStore = NULL;
    LPSTR pszAdditionalEngineStore = NULL;
    BOOL fResync = FALSE;
    DWORD dwLruCnt = 0;
    LPSTR pszDeleteCert = NULL;
    LPSTR pszReplaceCert = NULL;
    BOOL fSystemStore = FALSE;
    LPSTR pszStoreFilename = NULL;
    BOOL fPause = FALSE;
    DWORD dwThrCnt = 4;

    HCERTSTORE hAdditionalEngineStore = NULL;

    DWORD dwThreadId;
    DWORD dwIterations;
    DWORD i;

    for (i = 0; i < CTRL_THR_CNT; i ++)
        rgdwCtrlSleepMilliSeconds[i] = 2000;    // 2 second

    // Initialize the chain parameters
    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    while (--argc>0) {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "CreateEndCert")) {
                fCreateEndCert = TRUE;
            } else if (0 == _stricmp(argv[0]+1, "LocalMachine")) {
                hChainEngine = HCCE_LOCAL_MACHINE;
            } else if (0 == _stricmp(argv[0]+1, "Pause")) {
                fPause = TRUE;

            } else {
                switch(argv[0][1])
                {
                case 'u':
                    if (MAX_USAGE_CNT <= cUsageOID) {
                        printf("Too many usages\n");
                        goto BadUsage;
                    }

                    rgpszUsageOID[cUsageOID++] = argv[0]+2;
                    break;
                case 'i':
                    lIterations = strtol(argv[0]+2, NULL, 0);
                    break;
                case 't':
                    dwThrCnt = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    if (dwThrCnt > MAX_CHAIN_THR_CNT) {
                        printf("exceeded max thread count of %d\n",
                            MAX_CHAIN_THR_CNT);
                        goto BadUsage;
                    }
                    break;
                case 'l':
                    dwLruCnt = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'r':
                    fResync = TRUE;
                    if (argv[0][2]) {
                        rgdwCtrlSleepMilliSeconds[RESYNC_THR_IDX] =
                            (DWORD) strtoul(argv[0]+2, NULL, 0);
                    }
                    break;
                case 'd':
                    if (argv[0][2]) {
                        rgdwCtrlSleepMilliSeconds[DELETE_THR_IDX] =
                            (DWORD) strtoul(argv[0]+2, NULL, 0);
                    }

                    ++argv;
                    if (--argc <= 0 || argv[0][0] == '-') {
                        printf("Missing Delete cert\n");
                        goto BadUsage;
                    }
                    pszDeleteCert = argv[0];
                    break;
                case 'R':
                    if (argv[0][2]) {
                        rgdwCtrlSleepMilliSeconds[REPLACE_THR_IDX] =
                            (DWORD) strtoul(argv[0]+2, NULL, 0);
                    }

                    ++argv;
                    if (--argc <= 0 || argv[0][0] == '-') {
                        printf("Missing Replace cert\n");
                        goto BadUsage;
                    }
                    pszReplaceCert = argv[0];
                    break;
                case 'f':
                    dwChainFlags = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 's':
                    fSystemStore = TRUE;
                    break;
                case 'a':
                    pszAdditionalChainStore = argv[0]+2;
                    if (*pszAdditionalChainStore == '\0') {
                        printf("Need to specify filename\n");
                        goto BadUsage;
                    }
                    break;
                case 'A':
                    pszAdditionalEngineStore = argv[0]+2;
                    if (*pszAdditionalEngineStore == '\0') {
                        printf("Need to specify filename\n");
                        goto BadUsage;
                    }
                    break;
                case 'T':
                    ChainPara.dwUrlRetrievalTimeout =
                        (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'F':
                    ChainPara.fCheckRevocationFreshnessTime = TRUE;
                    ChainPara.dwRevocationFreshnessTime =
                        (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszStoreFilename) {
                printf("Multiple StoreNames\n");
                goto BadUsage;
            }
            pszStoreFilename = argv[0];
        }
    }


    printf("command line: %s\n", GetCommandLine());

    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        goto BadUsage;
    }

    // Attempt to open the store
    printf("Store :: %s\n", pszStoreFilename);
    hStore = OpenSystemStoreOrFile(fSystemStore, pszStoreFilename, 0);
    if (hStore == NULL) {
        printf("failed to open the store\n");
        goto ErrorReturn;
    }

    // Attempt to open the 'CA' store
    hCaStore = OpenSystemStoreOrFile(TRUE, "Ca", 0);
    if (hCaStore == NULL) {
        printf("failed to open the CA store\n");
        goto ErrorReturn;
    }

    if (!CertControlStore(
            hCaStore,
            0,              // dwFlags
            CERT_STORE_CTRL_AUTO_RESYNC,
            NULL            // pvCtrlPara
            )) {
        PrintLastError("CertControlStore(AUTO_RESYNC)");
        goto ErrorReturn;
    }

    if (pszAdditionalChainStore) {
        printf("AdditionalChainStore :: %s\n", pszAdditionalChainStore);
        hAdditionalChainStore =
            OpenSystemStoreOrFile(FALSE, pszAdditionalChainStore, 0);
        if (hAdditionalChainStore == NULL) {
            printf("failed to open the AdditionalChainStore\n");
            goto ErrorReturn;
        }
    }

    if (pszAdditionalEngineStore) {
        printf("AdditionalEngineStore :: %s\n", pszAdditionalEngineStore);
        hAdditionalEngineStore =
            OpenSystemStoreOrFile(FALSE, pszAdditionalEngineStore, 0);
        if (hAdditionalEngineStore == NULL) {
            printf("failed to open the AdditionalEngineStore\n");
            goto ErrorReturn;
        }
    }

    if (fResync) {
        printf("Resync :: Sleep: %d (milliseconds)\n",
            rgdwCtrlSleepMilliSeconds[RESYNC_THR_IDX]);
    }

    if (pszDeleteCert) {
        printf("Delete :: Sleep: %d (milliseconds) Cert: %s\n",
            rgdwCtrlSleepMilliSeconds[DELETE_THR_IDX],
            pszDeleteCert);
        pDeleteCertContext = ReadCert(pszDeleteCert);
        if (NULL == pDeleteCertContext) {
            printf("failed to read the DeleteCert\n");
            goto ErrorReturn;
        }
    }

    if (pszReplaceCert) {
        printf("Replace :: Sleep: %d (milliseconds) Cert: %s\n",
            rgdwCtrlSleepMilliSeconds[REPLACE_THR_IDX],
            pszReplaceCert);
        pReplaceCertContext = ReadCert(pszReplaceCert);
        if (NULL == pReplaceCertContext) {
            printf("failed to read the ReplaceCert\n");
            goto ErrorReturn;
        }
    }

    // Determine if we need to create our own engine

    if (dwLruCnt != 0 || hAdditionalEngineStore != NULL) {
        CERT_CHAIN_ENGINE_CONFIG ChainEngineConfig;

        printf("Create chain engine ::");
        if (hAdditionalEngineStore)
            printf(" AdditionalStore : %s", pszAdditionalEngineStore);
        if (dwLruCnt != 0)
            printf(" Lru Count : %d", dwLruCnt);
        printf("\n");

        memset(&ChainEngineConfig, 0, sizeof(ChainEngineConfig));
        ChainEngineConfig.cbSize = sizeof(ChainEngineConfig);
        if (hAdditionalEngineStore) {
            ChainEngineConfig.cAdditionalStore = 1;
            ChainEngineConfig.rghAdditionalStore = &hAdditionalEngineStore;
        }

        ChainEngineConfig.dwFlags =
            CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE |
            CERT_CHAIN_ENABLE_SHARE_STORE;

        if (dwLruCnt != 0) {
            ChainEngineConfig.MaximumCachedCertificates = dwLruCnt;
            ChainEngineConfig.dwFlags |= CERT_CHAIN_CACHE_END_CERT;
        }

        if (!CertCreateCertificateChainEngine(
                &ChainEngineConfig, &hChainEngine)) {
            PrintLastError("CertCreateCertificateChainEngine");
            goto ErrorReturn;
        }
    } else if (HCCE_LOCAL_MACHINE == hChainEngine) {
        printf("Using LocalMachine chain engine\n");
    }


    // Update the chain usage parameters
    ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainPara.RequestedUsage.Usage.cUsageIdentifier = cUsageOID;
    ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier =
        rgpszUsageOID;

    for (i = 0; i < cUsageOID; i++) {
        printf("Usage[%d] : %s\n", i, rgpszUsageOID[i]);
    }

    if (0 >= lIterations) {
        lIterations = -1;
        printf("Infinite iterations\n");
    } else
        printf("%d iterations\n", lIterations);

    if (fPause) {
        int c;
        fputs("Waiting to start ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();
    }


    // Create the control threads
    if (fResync) {
        if (NULL == (rghCtrlThread[RESYNC_THR_IDX] = CreateThread(
                NULL,           // lpThreadAttributes
                0,              // dwStackSize
                ResyncThreadProc,
                NULL,           // lpParameters
                0,              // dwCreationFlags
                &dwThreadId
                ))) {
            PrintLastError("CreateThread(Resync)");
        }
    }

    if (pDeleteCertContext) {
        if (NULL == (rghCtrlThread[DELETE_THR_IDX] = CreateThread(
                NULL,           // lpThreadAttributes
                0,              // dwStackSize
                DeleteThreadProc,
                NULL,           // lpParameters
                0,              // dwCreationFlags
                &dwThreadId
                ))) {
            PrintLastError("CreateThread(Delete)");
        }
    }

    if (pReplaceCertContext) {
        if (NULL == (rghCtrlThread[REPLACE_THR_IDX] = CreateThread(
                NULL,           // lpThreadAttributes
                0,              // dwStackSize
                ReplaceThreadProc,
                NULL,           // lpParameters
                0,              // dwCreationFlags
                &dwThreadId
                ))) {
            PrintLastError("CreateThread(Replace)");
        }
    }

    // Create the chain threads
    for (i = 0; i < dwThrCnt; i++) {
        if (NULL == (rghChainThread[i] = CreateThread(
                NULL,           // lpThreadAttributes
                0,              // dwStackSize
                ChainThreadProc,
                (LPVOID) ((DWORD_PTR) i),  // lpParameters
                0,              // dwCreationFlags
                &dwThreadId
                ))) {
            PrintLastError("CreateThread(Chain)");
            dwThrCnt = i;
            break;
        }
    }

    dwIterations = 0;
    while(TRUE) {
        dwIterations++;

        printf("%d - ", dwIterations);

        for (i = 0; i < dwThrCnt; i++)
            printf("%d ", rgdwChainIterations[i]);

        if (rghCtrlThread[RESYNC_THR_IDX])
            printf("r:%d ", rgdwCtrlIterations[RESYNC_THR_IDX]);
        if (rghCtrlThread[DELETE_THR_IDX])
            printf("d:%d ", rgdwCtrlIterations[DELETE_THR_IDX]);
        if (rghCtrlThread[REPLACE_THR_IDX])
            printf("R:%d ", rgdwCtrlIterations[REPLACE_THR_IDX]);

        printf("\n");

        if (0 == dwThrCnt)
            break;

        // Check if all the chain threads have completed
        if (WAIT_OBJECT_0 == WaitForMultipleObjects(
                dwThrCnt,
                rghChainThread,
                TRUE,               // bWaitAll
                0                   // dwMilliseconds
                ))
            break;

        if (dwThrCnt <= 5)
            Sleep(1000);
        else
            Sleep(5000);
    }

    // Signal the control threads to exit
    fDone = TRUE;

    // Close all the chain thread handles
    for (i = 0; i < dwThrCnt; i++)
        CloseHandle(rghChainThread[i]);

    // Wait for the control threads to exit
    for (i = 0; i < CTRL_THR_CNT; i++) {
        if (rghCtrlThread[i]) {
            WaitForSingleObject(rghCtrlThread[i], INFINITE);
            CloseHandle(rghCtrlThread[i]);
        }
    }


    status = 0;
CommonReturn:
    // This does a flush for CurrentUser or LocalMachine
    CertFreeCertificateChainEngine(hChainEngine);

    if (pReplaceCertContext)
        CertFreeCertificateContext(pReplaceCertContext);
    if (pDeleteCertContext)
        CertFreeCertificateContext(pDeleteCertContext);
    if (hAdditionalChainStore)
        CertCloseStore(hAdditionalChainStore, 0);
    if (hAdditionalEngineStore)
        CertCloseStore(hAdditionalEngineStore, 0);

    if (hCaStore)
        CertCloseStore(hCaStore, 0);
    if (hStore)
        CertCloseStore(hStore, 0);

    if (fPause) {
        int c;
        fputs("Waiting to exit ->", stdout);
        fflush(stdin);
        fflush(stdout);
        c = getchar();
    }

    return status;

ErrorReturn:
    status = -1;
    goto CommonReturn;

BadUsage:
    Usage();
    status = -1;
    goto CommonReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tcrobu\tcrobu.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       tcrobu.cpp
//
//  Contents:   CryptRetrieveObjectByUrl tests
//
//  History:    27-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include <wininet.h>
#include <md5.h>

#include <cryptnet.h>
typedef BYTE CRYPT_ORIGIN_IDENTIFIER[MD5DIGESTLEN];
BYTE Foo[300];
BYTE Bar[300];

DWORD	g_dwCount = 0;
//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   prints the usage statement
//
//----------------------------------------------------------------------------
static void Usage(void)
{
    printf("Usage: tcrobu URL [ObjectOid] [-m] [-c] [-s] [-w] [-l]\n");
    printf("              URL, locator to retrieve from\n");
    printf("              ObjectOid, a cert, crl, or ctl, if omitted, retrieve bits\n");
    printf("              -m, retrieve multiple objects\n");
    printf("              -c, cache only retrieval\n");
    printf("              -d, do not cache the result\n");
    printf("              -w, wire only retrieval\n");
    printf("              -u, CryptGetObjectUrl on the result context\n");
    printf("              -l, logon user credentials <user> <password>\n");
    printf("              -t, timeout\n");
	printf("              -f, install cancel function\n");
	printf("              -n, install and uninstall cancel function\n");
	printf("              -r, the # of times the cancel function should be called\n");
	printf("              -v, verbose display\n");
	printf("              -q, quiet display\n");
	printf("              -s, save to serialized store file\n");
	printf("              -7, save to PKCS7 store file\n");
	printf("              -a, get AuxInfo\n");
	printf("              -p, sticky persist\n");
	printf("              -e, prepend LDAP entry and attribute\n");
	printf("              -k, Kerberos Signing for LDAP\n");
	printf("              -i, inhibit authentication\n");
    printf("              -Error, expected error\n");
    printf("              -Flags, retrieval flags to be OR'ed\n");
    printf("              -Size, maximum retrieval byte count\n");
}

//+---------------------------------------------------------------------------
//
//  Function:   CertGetOriginIdentifier
//
//  Synopsis:   get the origin identifier for a certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertGetOriginIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                )
{
    MD5_CTX    md5ctx;
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
    PCERT_INFO pIssuerCertInfo = pIssuer->pCertInfo;

    MD5Init( &md5ctx );

    MD5Update( &md5ctx, pCertInfo->Issuer.pbData, pCertInfo->Issuer.cbData );
    MD5Update( &md5ctx, pCertInfo->Subject.pbData, pCertInfo->Subject.cbData );

    MD5Update(
       &md5ctx,
       (LPBYTE)pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
       strlen( pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId )
       );

    MD5Update(
       &md5ctx,
       pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
       pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData
       );

    // We assume that the unused public key bits are zero
    MD5Update(
       &md5ctx,
       pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Final( &md5ctx );

    memcpy( OriginIdentifier, md5ctx.digest, MD5DIGESTLEN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   MyCancelFunction
//
//  Synopsis:   The call back function to cancel the object retrieval.
//				The cancellation happens when it is called for the 3rd time.
//
//----------------------------------------------------------------------------
BOOL WINAPI MyCancelFunction(DWORD dwFlags, void *pvArg)
{
	DWORD *pCount=NULL;

	pCount=(DWORD *)pvArg;
							   
	if(*pCount == g_dwCount)
		return TRUE;

	(*pCount)++;  

	return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   main program entry point
//
//----------------------------------------------------------------------------
int _cdecl main(int argc, char * argv[])
{
#if 0
    BOOL      fResult;
    HINTERNET hInetSession;

    hInetSession = InternetOpen(
                           "foo",
                           INTERNET_OPEN_TYPE_PRECONFIG,
                           NULL,
                           NULL,
                           0
                           );

    if ( hInetSession == NULL )
    {
        printf("Error opening internet session %lx\n", GetLastError());
        return( 1 );
    }

    fResult = InternetSetOption(
                      hInetSession,
                      INTERNET_OPTION_USERNAME,
                      "foo",
                      strlen( "foo" ) + 1
                      );

    if ( fResult == TRUE )
    {
        fResult = InternetSetOption(
                          hInetSession,
                          INTERNET_OPTION_PROXY_USERNAME,
                          "bar",
                          strlen( "bar" ) + 1
                          );
    }

    if ( fResult == TRUE )
    {
        fResult = InternetSetOption(
                          hInetSession,
                          INTERNET_OPTION_PASSWORD,
                          "gamma",
                          strlen( "gamma" ) + 1
                          );

        if ( fResult == TRUE )
        {
            fResult = InternetSetOption(
                              hInetSession,
                              INTERNET_OPTION_PROXY_PASSWORD,
                              "beta",
                              strlen( "beta" ) + 1
                              );
        }
    }

    InternetCloseHandle( hInetSession );

    return( 0 );
#endif

#if 0

    LPWSTR pwszUrl = NULL;

    if ( I_CryptNetGetUserDsStoreUrl( L"X509Certificate", &pwszUrl ) == TRUE )
    {
        wprintf(L"User DS Store URL = <%s>\n", pwszUrl);
        CryptMemFree( pwszUrl );
    }
    else
    {
        printf("I_CryptNetGetUserDsStoreUrl failed <%lx>\n", GetLastError());
    }

    return( 0 );

#endif

#if 1
    ULONG                       cCount;
    PCRYPT_BLOB_ARRAY           pcba;
    LPVOID                      pv;
    LPSTR                       pszObjectOid = NULL;
    LPSTR                       pszUrl = NULL;
    LPSTR                       pszUsername = NULL;
    LPSTR                       pszPassword = NULL;
    DWORD                       dwRetrievalFlags = 0;
    BOOL                        fGetObjectUrl = FALSE;
    PCRYPT_CREDENTIALS          pCredentials = NULL;
    CRYPT_CREDENTIALS           Credentials;
    CRYPT_PASSWORD_CREDENTIALSA PasswordCredentials;
    CRYPT_PASSWORD_CREDENTIALSW UnicodePasswordCredentials;
    BOOL                        fUnicodeCredentials = FALSE;
    LPWSTR                      pwszUsername = NULL;
    LPWSTR                      pwszPassword = NULL;
    DWORD                       dwTimeout = 0;
	BOOL						fCancel = FALSE;
	BOOL						fUninstall = FALSE;
	DWORD						dwCount = 0;
    BOOL                        fQuiet = FALSE;
    DWORD                       dwDisplayFlags = 0;
    BOOL                        fSave = FALSE;
    BOOL                        fPKCS7Save = FALSE;
    LPSTR                       pszSaveFilename = NULL;
    DWORD                       dwExpectedError = 0;

    PCRYPT_RETRIEVE_AUX_INFO    pAuxInfo = NULL;
    FILETIME                    LastSyncTime = { 0, 0 };
    CRYPT_RETRIEVE_AUX_INFO     AuxInfo;

    memset(&AuxInfo, 0, sizeof(AuxInfo));
    AuxInfo.cbSize = sizeof(AuxInfo);

    if ( argc < 2 )
    {
        Usage();
        return( 1 );
    }

    argv++;
    argc--;

    printf( "command line: %s\n", GetCommandLineA() );

    pszUrl = argv[0];

    while ( --argc > 0 )
    {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "Error")) {
                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                dwExpectedError = (DWORD) strtoul(argv[1], NULL, 0);
                argc -= 1;
                argv++;
            } else if (0 == _stricmp(argv[0]+1, "Flags")) {
                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                dwRetrievalFlags |= (DWORD) strtoul(argv[1], NULL, 0);
                argc -= 1;
                argv++;
            } else if (0 == _stricmp(argv[0]+1, "Size")) {
                if ( argc < 2 )
                {
                    Usage();
                    return( 1 );
                }

                pAuxInfo = &AuxInfo;
                AuxInfo.dwMaxUrlRetrievalByteCount =
                    (DWORD) strtoul(argv[1], NULL, 0);
                argc -= 1;
                argv++;

            } else {
                switch(argv[0][1])
                {
                case 'm':
                case 'M':
                    dwRetrievalFlags |= CRYPT_RETRIEVE_MULTIPLE_OBJECTS;
                    break;
                case 'c':
                case 'C':
                    dwRetrievalFlags |= CRYPT_CACHE_ONLY_RETRIEVAL;
                    break;
                case 'w':
                case 'W':
                    dwRetrievalFlags |= CRYPT_WIRE_ONLY_RETRIEVAL;
                    break;
                case 'f':
                case 'F':
                    fCancel = TRUE;
                    break;
                case 'n':
                case 'N':
                    fUninstall = TRUE;
                    break;
                case 'd':
                case 'D':
                    dwRetrievalFlags |= CRYPT_DONT_CACHE_RESULT;
                    break;
                case 'u':
                case 'U':
                    fGetObjectUrl = TRUE;
                    break;
                case 't':
                case 'T':

                    if ( argc < 2 )
                    {
                        Usage();
                        return( 1 );
                    }

                    dwTimeout = atol( argv[1] );
                    argc -= 1;
                    argv++;
                    break;
                case 'r':
                case 'R':

                    if ( argc < 2 )
                    {
                        Usage();
                        return( 1 );
                    }

                    g_dwCount = atol( argv[1] );
                    argc -= 1;
                    argv++;
                    break;
                case 'L':
                    fUnicodeCredentials = TRUE;
                case 'l':

                    if ( argc < 2 )
                    {
                        Usage();
                        return( 1 );
                    }

                    pszUsername = argv[1];

                    if ( argc > 2 )
                    {
                        pszPassword = argv[2];
                        argc--;
                        argv++;
                    }

                    argc -= 1;
                    argv++;
                    break;
                case 'q':
                case 'Q':
                    fQuiet = TRUE;
                    break;
                case 'v':
                case 'V':
                    dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                    break;
                case '7':
                    fPKCS7Save = TRUE;
                case 's':
                case 'S':
                    fSave = TRUE;
                    if ( argc < 2 )
                    {
                        Usage();
                        return( 1 );
                    }

                    pszSaveFilename = argv[1];
                    argc -= 1;
                    argv++;
                    break;
                case 'a':
                case 'A':
                    pAuxInfo = &AuxInfo;
                    AuxInfo.pLastSyncTime = &LastSyncTime;
                    break;
                case 'p':
                case 'P':
                    dwRetrievalFlags |= CRYPT_STICKY_CACHE_RETRIEVAL;
                    break;
                case 'e':
                case 'E':
                    dwRetrievalFlags |= CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE;
                    break;
                case 'k':
                case 'K':
                    dwRetrievalFlags |= CRYPT_LDAP_SIGN_RETRIEVAL;
                    break;
                case 'i':
                case 'I':
                    dwRetrievalFlags |= CRYPT_NO_AUTH_RETRIEVAL;
                    break;
                default:
                    Usage();
                    return -1;
                }
            }
        }
        else
        {
            if ( _stricmp( argv[0], "cert" ) == 0 )
            {
                pszObjectOid = (LPSTR)CONTEXT_OID_CERTIFICATE;
            }
            else if ( _stricmp( argv[0], "ctl" ) == 0 )
            {
                pszObjectOid = (LPSTR)CONTEXT_OID_CTL;
            }
            else if ( _stricmp( argv[0], "crl" ) == 0 )
            {
                pszObjectOid = (LPSTR)CONTEXT_OID_CRL;
            }
            else if ( _stricmp( argv[0], "pkcs7" ) == 0 )
            {
                pszObjectOid = (LPSTR)CONTEXT_OID_PKCS7;
            }
            else if ( _stricmp( argv[0], "any" ) == 0 )
            {
                pszObjectOid = (LPSTR)CONTEXT_OID_CAPI2_ANY;
            }
            else
            {
                Usage();
                return( -1 );
            }
        }
    }

    if ( pszUsername != NULL )
    {
        if (fUnicodeCredentials)
        {
            pwszUsername = AllocAndSzToWsz(pszUsername);
            if ( pszPassword != NULL )
            {
                pwszPassword = AllocAndSzToWsz(pszPassword);
            }
            UnicodePasswordCredentials.cbSize =
                sizeof( UnicodePasswordCredentials );
            UnicodePasswordCredentials.pszUsername = pwszUsername;
            UnicodePasswordCredentials.pszPassword = pwszPassword;

            Credentials.cbSize = sizeof( Credentials );
            Credentials.pszCredentialsOid =
                CREDENTIAL_OID_PASSWORD_CREDENTIALS_W;
            Credentials.pvCredentials = (LPVOID)&UnicodePasswordCredentials;

            pCredentials = &Credentials;

            printf("Using Unicode credentials %S <%S>\n",
                pwszUsername, pwszPassword);
        }
        else
        {
            PasswordCredentials.cbSize = sizeof( PasswordCredentials );
            PasswordCredentials.pszUsername = pszUsername;
            PasswordCredentials.pszPassword = pszPassword;

            Credentials.cbSize = sizeof( Credentials );
            Credentials.pszCredentialsOid = CREDENTIAL_OID_PASSWORD_CREDENTIALS_A;
            Credentials.pvCredentials = (LPVOID)&PasswordCredentials;

            pCredentials = &Credentials;

            printf("Using credentials %s <%s>\n", pszUsername, pszPassword);
        }
    }

	if(fCancel)
	{
		if(!CryptInstallCancelRetrieval(
						MyCancelFunction,
						&dwCount,
						0,
						NULL))
			printf("Install cancel function failed!\n");


		if(fUninstall)
		{
			if(!CryptUninstallCancelRetrieval(
							0,
							NULL))
				printf("Uninstall cancel function failed!\n");
		}
	}

    if ( CryptRetrieveObjectByUrlA(
              pszUrl,
              pszObjectOid,
              dwRetrievalFlags,
              dwTimeout,
              &pv,
              NULL,
              pCredentials,
              NULL,
              pAuxInfo
              ) == FALSE )
    {
        DWORD dwLastErr = GetLastError();
        if (0 == dwExpectedError)
            printf( "CryptRetrieveObjectByUrl FAILED! <0x%x %d>\n", dwLastErr, dwLastErr );
        else if (dwLastErr != dwExpectedError)
            printf( "CryptRetrieveObjectByUrl FAILED! Expected: 0x%x Actual: <0x%x %d>\n", dwExpectedError, dwLastErr, dwLastErr );
        else
            printf( "CryptRetrieveObjectByUrl SUCCEEDED! Got Expected: <0x%x %d>\n", dwLastErr, dwLastErr );
            

		if(fCancel)
		{
			if(!fUninstall)
			{
				if(!CryptUninstallCancelRetrieval(
								0,
								NULL))
					printf("Uninstall cancel function failed!\n");
			}
		}

        if (pwszUsername)
            TestFree(pwszUsername);
        if (pwszPassword)
            TestFree(pwszPassword);

        return( -1 );
    }

    if (0 == dwExpectedError)
        printf( "CryptRetrieveObjectByUrl SUCCEEDED!\n" );
    else 
        printf( "CryptRetrieveObjectByUrl FAILED! Expected: 0x%x Actual: 0x0\n", dwExpectedError );

    if (pAuxInfo)
    {
        printf("  LastSyncTime:: %s\n",
            FileTimeText(&LastSyncTime));
    }

	if(fCancel)
	{
		if(!fUninstall)
		{
			if(!CryptUninstallCancelRetrieval(
							0,
							NULL))
				printf("Uninstall cancel function failed!\n");
		}
	}

    if ( pszObjectOid == NULL )
    {
        pcba = (PCRYPT_BLOB_ARRAY)pv;

        for ( cCount = 0; cCount < pcba->cBlob; cCount++ )
        {
            PBYTE pb = pcba->rgBlob[cCount].pbData;
            DWORD cb = pcba->rgBlob[cCount].cbData;

            printf( "\nObject#%d ", cCount+1);
            if (dwRetrievalFlags & CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE)
            {
                DWORD cbPrefix;
                LPCSTR pszIndex;
                LPCSTR pszAttr;

                pszIndex = (LPCSTR) pb;
                cbPrefix = strlen(pszIndex) + 1;
                pb += cbPrefix;
                cb -= cbPrefix;

                pszAttr = (LPCSTR) pb;
                cbPrefix = strlen(pszAttr) + 1;
                pb += cbPrefix;
                cb -= cbPrefix;

                printf("[%s, %s] ", pszIndex, pszAttr);
            }

            printf( "- Length=0x%lx\n", cb );
            PrintBytes(
                 "",
                 pb,
                 cb
                 );
        }

        CryptMemFree( pv );
    }
    else if ( pszObjectOid == CONTEXT_OID_CERTIFICATE )
    {
        if ( !( dwRetrievalFlags & CRYPT_RETRIEVE_MULTIPLE_OBJECTS ) )
        {
            DisplayCert( (PCCERT_CONTEXT)pv, dwDisplayFlags );

            if ( fGetObjectUrl == TRUE )
            {
#if 1
                DWORD cbUrlArray;

                if ( CryptGetObjectUrl(
                          URL_OID_CERTIFICATE_CRL_DIST_POINT,
                          pv,
                          0,
                          NULL,
                          &cbUrlArray,
                          NULL,
                          NULL,
                          NULL
                          ) == FALSE )
                {
                    printf("GetObjectUrl failed %lx\n", GetLastError());
                }
                else
                {
                    printf("cbUrlArray = %ld\n", cbUrlArray);
                }
#else
                DWORD                   cCount;
                LARGE_INTEGER           TickCount1;
                LARGE_INTEGER           TickCount2;
                LARGE_INTEGER           TickCount;
                CRYPT_ORIGIN_IDENTIFIER OriginIdentifier;

                #define NUM_ITER 1000000

                GetSystemTimeAsFileTime( (LPFILETIME)&TickCount1 );
                for ( cCount = 0; cCount < NUM_ITER; cCount++ )
                {
                    if ( memcmp( Foo, Bar, 100 ) != 0 )
                    {
                        Foo[0] = 1;
                        Bar[0] = 1;
                    }
                    if ( memcmp( Foo, Bar, 200 ) != 0 )
                    {
                        Foo[0] = 1;
                        Bar[0] = 1;
                    }
                    if ( memcmp( Foo, Bar, 64 ) != 0 )
                    {
                        Foo[0] = 1;
                        Bar[0] = 1;
                    }
                    if ( memcmp( Foo, Bar, 128 ) != 0 )
                    {
                        Foo[0] = 1;
                        Bar[0] = 1;
                    }

                    //CertGetOriginIdentifier(
                    //    (PCCERT_CONTEXT)pv,
                    //   (PCCERT_CONTEXT)pv,
                    //    0,
                    //    OriginIdentifier
                    //    );
                }
                GetSystemTimeAsFileTime( (LPFILETIME)&TickCount2 );
                TickCount.QuadPart = ( TickCount2.QuadPart - TickCount1.QuadPart );
                printf("PerIter = %ld ns. Total = %ld s.\n", (((LPFILETIME)&TickCount)->dwLowDateTime / NUM_ITER) * 100, ((LPFILETIME)&TickCount)->dwLowDateTime / 10000000);
#endif
            }

            CertFreeCertificateContext( (PCCERT_CONTEXT)pv );
        }
        else
        {
            if (!fQuiet)
                DisplayStore( (HCERTSTORE)pv, dwDisplayFlags );
            if (fSave && pszSaveFilename)
                SaveStoreEx( (HCERTSTORE)pv, fPKCS7Save, pszSaveFilename);
            CertCloseStore( (HCERTSTORE)pv, 0 );
        }
    }
    else if ( pszObjectOid == CONTEXT_OID_CTL )
    {
        if ( !( dwRetrievalFlags & CRYPT_RETRIEVE_MULTIPLE_OBJECTS ) )
        {
            DisplayCtl( (PCCTL_CONTEXT)pv, dwDisplayFlags );
            CertFreeCTLContext( (PCCTL_CONTEXT)pv );
        }
        else
        {
            if (!fQuiet)
                DisplayStore( (HCERTSTORE)pv, dwDisplayFlags );
            if (fSave && pszSaveFilename)
                SaveStoreEx( (HCERTSTORE)pv, fPKCS7Save, pszSaveFilename);
            CertCloseStore( (HCERTSTORE)pv, 0 );
        }
    }
    else if ( pszObjectOid == CONTEXT_OID_CRL )
    {
        if ( !( dwRetrievalFlags & CRYPT_RETRIEVE_MULTIPLE_OBJECTS ) )
        {
            DisplayCrl( (PCCRL_CONTEXT)pv, dwDisplayFlags );
            CertFreeCRLContext( (PCCRL_CONTEXT)pv );
        }
        else
        {
            if (!fQuiet)
                DisplayStore( (HCERTSTORE)pv,  dwDisplayFlags );
            if (fSave && pszSaveFilename)
                SaveStoreEx( (HCERTSTORE)pv, fPKCS7Save, pszSaveFilename);
            CertCloseStore( (HCERTSTORE)pv, 0 );
        }
    }
    else if ( ( pszObjectOid == CONTEXT_OID_CAPI2_ANY ) ||
              ( pszObjectOid == CONTEXT_OID_PKCS7 ) )
    {
        if (!fQuiet)
            DisplayStore( (HCERTSTORE)pv,  dwDisplayFlags );
        if (fSave && pszSaveFilename)
            SaveStoreEx( (HCERTSTORE)pv, fPKCS7Save, pszSaveFilename);
        CertCloseStore( (HCERTSTORE)pv, 0 );
    }


    if (pwszUsername)
        TestFree(pwszUsername);
    if (pwszPassword)
        TestFree(pwszPassword);

    return( 0 );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tdecode\tdecode.cpp ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tdecode.cpp
//
//  Contents:   API testing of CryptEncodeObject/CryptDecodeObject.  
//
//  History:    22-January-97   xiaohs   created
//              
//--------------------------------------------------------------------------


#include "tdecode.h"

//--------------------------------------------------------------------------
//	 Globals
//--------------------------------------------------------------------------

//the count of errors in the program
DWORD				g_dwErrCnt=0; 	

HCRYPTPROV			g_hProv=NULL;


//--------------------------------------------------------------------------
//	The utility function to display the parameters for the input.
//--------------------------------------------------------------------------
static void Usage(void)
{
	printf("\n");
    printf("Usage: tdecode [options] <FileTypes><Filename>\n");
	printf("\n");
	printf("FileTypes are(case sensitive):\n");
	printf("  C                -This is a certificate file\n");
	printf("  R                -This is a certificate request blob file\n");
	printf("  S                -This is a signed message file\n");
	printf("\n");
    printf("Options are(case sensitive):\n");
    printf("  -i               - A complete test on cbEncoded in CryptDecodeObject\n");
	printf("                     Default does not do the check\n");
    printf("  -o               - A complete test on *pcbStructInfo on CryptDecodeObject\n");
	printf("                     Default does not do the check\n");
	printf("  -b               - A complete test on *pcbStructInfo and cbEncoded\n");
	printf("                     Default does not do the check\n");
    printf("\n");

	return;
}

//--------------------------------------------------------------------------
//	The utility function to display a message that the test is not exeucted
//--------------------------------------------------------------------------
static void NotExecuted(void)
{	
	printf("*****************************************************\n");
	printf("  Summary information for TDecode Test	\n");
	printf("*****************************************************\n"); \
	printf("\n");
	printf("The test is not executed!\n");

	return;
}

//--------------------------------------------------------------------------
//	 The main program that Decode/Encode Certifitcate, Certificate Request,
//	 and CRL.
//--------------------------------------------------------------------------
void _cdecl main(int argc, char * argv[])
{		  
	BOOL				fStructLengthCheck=FALSE;
	BOOL				fBLOBLengthCheck=FALSE;
	DWORD				dwFileType=0;
	LPSTR				pszFilename=NULL;
	BYTE				pbByte[100]=
						{0x00, 0xa1, 0x23, 0x45, 0x56, 0x78, 0x9a, 0xbc,0xdf,0xee, 
						 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0XFF, 0xA6, 0x8f,0xe4, 0x0f,
						 0x00, 0xa1, 0x23, 0x45, 0x56, 0x78, 0x9a, 0xbc,0xdf,0xee, 
						 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0XFF, 0xA6, 0x8f,0xe4, 0x0f,
						 0x00, 0xa1, 0x23, 0x45, 0x56, 0x78, 0x9a, 0xbc,0xdf,0xee, 
						 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0XFF, 0xA6, 0x8f,0xe4, 0x0f,
					     0x00, 0xa1, 0x23, 0x45, 0x56, 0x78, 0x9a, 0xbc,0xdf,0xee, 
						 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0XFF, 0xA6, 0x8f,0xe4, 0x0f,
						 0x00, 0xa1, 0x23, 0x45, 0x56, 0x78, 0x9a, 0xbc,0xdf,0xee, 
						 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0XFF, 0xA6, 0x8f,0xe4, 0x0f};



    //parsing through the command line input parameters
	while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
				case 'i':
						fBLOBLengthCheck=TRUE;
					break;

				case 'o':
						fStructLengthCheck=TRUE;
					break;

				case 'b':
						fBLOBLengthCheck=TRUE;
						fStructLengthCheck=TRUE;
					break;

				default:
					Usage();
					NotExecuted();
					return;
            }
        } 
		else
		{
			//parsing through the file name
            switch(**argv)
            {
				case 'C':
						dwFileType=CERT_CRL_FILE;
					break;

				case 'R':
						dwFileType=CERT_REQUEST_FILE;
					break;

				case 'S':
						dwFileType=SIGNED_MSG_FILE;
					break;

				default:
					Usage();
					NotExecuted();
					return;
            }

			//make sure there is a file name specified
			if(argv[0][1]=='\0')
			{
				Usage();
				NotExecuted();
				return;
			}

			//get the file name
            pszFilename = &(argv[0][1]);
		}
    }


	//if the file name is NULL, something is wrong in the input parameter
	if(!pszFilename)
	{
		Usage();
		NotExecuted();
		return;
	}

   	
	//acquireContext
	TESTC(CryptAcquireContext(&g_hProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT),TRUE)

	//test PKCS_UTC_TIME
	TESTC(VerifyPKCS_UTC_TIME(fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//test PKCS_TIME_REQUEST
	TESTC(VerifyPKCS_TIME_REQUEST(fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//decode the corresponding file types.
	switch(dwFileType)
	{
		case CERT_CRL_FILE:
				TESTC(DecodeCertFile(pszFilename,fStructLengthCheck,
					fBLOBLengthCheck),TRUE)
			break;

		case CERT_REQUEST_FILE:
				TESTC(DecodeCertReqFile(pszFilename,fStructLengthCheck,
					fBLOBLengthCheck),TRUE)
			break;

		case SIGNED_MSG_FILE:
				TESTC(DecodeSignedMsgFile(pszFilename,fStructLengthCheck,
					fBLOBLengthCheck),TRUE)
			break;

		default:
			break;
	}


TCLEANUP: 
	
	//release the CSP
	if(g_hProv)
		TCHECK(CryptReleaseContext(g_hProv,0),TRUE);

	//print out the test result
	DisplayTestResult(g_dwErrCnt);
}

//--------------------------------------------------------------------------
//	 Local Functions
//--------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////////// 
//Error Manipulations
//--------------------------------------------------------------------------
//	 DisplayTestResult
//--------------------------------------------------------------------------

void	DisplayTestResult(DWORD	dwErrCnt)
{	   

		printf("*****************************************************\n");
		printf("  Summary information for TDecode Test	\n");
		printf("*****************************************************\n");
		printf("\n");

		if(!dwErrCnt)
			printf("This test succeeded!\n");
		else
			printf("This test failed with total %d errors!\n",dwErrCnt);

		return;
}

//--------------------------------------------------------------------------
//	Validate the return code is the same as expected.  If they are not the 
//  same, increment the error count and print out the file name and the line
//  number.
//--------------------------------------------------------------------------
BOOL	Validate(DWORD dwErr, BOOL	fSame, char *szFile, DWORD	dwLine)
{

	if(fSame)
		return TRUE;
	printf("*****************************************************\n");
	printf("Error: %d 0x%x occurred at file %s line %d\n\n",
        dwErr, dwErr, szFile, dwLine);
	g_dwErrCnt++;
	return FALSE;
}


//--------------------------------------------------------------------------
//	Output the two BLOBs.  One is the original one, the other is the
// BLOB encoded by pvStructInfo.
//--------------------------------------------------------------------------
void	OutputError(LPCSTR	lpszStructType, DWORD cbSecondEncoded, DWORD cbEncoded,
					BYTE *pbSecondEncoded, BYTE *pbEncoded)
{		
		DWORD	cbMin=0;

		printf("------------------------------------------------------\n");
		printf("An inconsistency in BLOBs has been found!\n");

		//print out the lpszStructType
		if(((DWORD_PTR)lpszStructType)>>8 == 0)
			printf("The lpszStructType is %d.\n",(DWORD)(DWORD_PTR)lpszStructType);
		else
			printf("The lpszStructType is %s.\n",lpszStructType);

		printf("\n");

		//print out the size of BLOBs
		printf("The original cbEncoded is %d.\n",cbEncoded);
		printf("The new cbEncoded is %d.\n",cbSecondEncoded);
		printf("\n");

		//see if the min of cbEncoded and cbSecondEncoded is the same
		if(cbSecondEncoded>cbEncoded)
			cbMin=cbEncoded;
		else
			cbMin=cbSecondEncoded;

		if(memcmp(pbSecondEncoded,pbEncoded,cbMin)==0)
			printf("The two blobs are the same up to %dth byte.\n",cbMin);

		//print out all the bytes in the BLOBs
		printf("The original BLOB is:\n");

		PrintBytes("    ", pbEncoded, cbEncoded);
		
		printf("\n");

		printf("The new BLOB is:\n");

		PrintBytes("   ",pbSecondEncoded, cbSecondEncoded);

		return;
}

//--------------------------------------------------------------------------
//	Print out the Byte in 16 bytes per row and their corresponding HEX.
//--------------------------------------------------------------------------
void PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;

    while (cbSize > 0)
    {
        printf("%s", pszHdr);
        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i<cb; i++)
            printf(" %02X", pb[i]);
        for (i = cb; i<CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i<cb; i++)
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        pb += cb;
        printf("'\n");
    }
}


///////////////////////////////////////////////////////////////////////////
//General Testing routings

//--------------------------------------------------------------------------
//	Validate CryptEncodeObject/CryptDecodeObject handle the NULL or invalid 
//	parameters correctly.
//--------------------------------------------------------------------------
BOOL	ParameterTest(LPCSTR lpszStructType, DWORD cbEncoded, BYTE *pbEncoded)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbStructInfo=0;
	void		*pvStructInfo=NULL;	 
	DWORD		cbCorrectSize=0;
	DWORD		cbLengthOnly=0;
	DWORD		cbSecondEncoded=0;
	BYTE		*pbSecondEncoded=NULL;
	DWORD		dwReturn=0;
	DWORD		dwEncodingType=CRYPT_ENCODE_TYPE;


	//init
	assert(cbEncoded);
	assert(pbEncoded);
	assert(lpszStructType);

	//We have different decoding type for PKCS7_SIGNER_INFO
	if((DWORD_PTR)(lpszStructType)==(DWORD_PTR)(PKCS7_SIGNER_INFO))
		dwEncodingType=MSG_ENCODING_TYPE;


	cbSecondEncoded=cbEncoded;
	pbSecondEncoded=(BYTE *)SAFE_ALLOC(cbEncoded);
	CHECK_POINTER(pbSecondEncoded)

	//Decode the BLOB correctly

	cbStructInfo=1000;

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,NULL,&cbStructInfo),TRUE)

	cbLengthOnly=cbStructInfo;

	//allocate the memory
	pvStructInfo=SAFE_ALLOC(cbStructInfo);
	CHECK_POINTER(pvStructInfo);

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),TRUE)

	cbCorrectSize=cbStructInfo;

	//Test incorrect ENCODING type
	//pass X509_NDR_ENCODING
	TESTC(CryptDecodeObject(X509_NDR_ENCODING,lpszStructType,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	//	Since we do not know the correct return code, make sure at least
	//S_OK is not returned.

	TCHECK(GetLastError()!=S_OK, TRUE);

	TESTC(CryptEncodeObject(X509_NDR_ENCODING, lpszStructType,pvStructInfo,
		pbSecondEncoded,&cbSecondEncoded),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	//pass X509_NDR_ENCODING|X509_ASN_ENCODING
	TESTC(CryptDecodeObject(X509_NDR_ENCODING|X509_ASN_ENCODING,lpszStructType,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	TESTC(CryptEncodeObject(X509_NDR_ENCODING|X509_ASN_ENCODING, lpszStructType,pvStructInfo,
		pbSecondEncoded,&cbSecondEncoded),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	//Test invalid/unsupported lpszStructType
	//passing NULL for lpszStructType
	TESTC(CryptDecodeObject(dwEncodingType,CRYPT_ENCODE_DECODE_NONE,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	TESTC(CryptEncodeObject(dwEncodingType, CRYPT_ENCODE_DECODE_NONE,pvStructInfo,
		pbSecondEncoded,&cbSecondEncoded),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	//passing invalid lpszStructType
	TESTC(CryptDecodeObject(dwEncodingType,INVALID_LPSZSTRUCTTYPE,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	TESTC(CryptEncodeObject(dwEncodingType, INVALID_LPSZSTRUCTTYPE,pvStructInfo,
		pbSecondEncoded,&cbSecondEncoded),FALSE)

	TCHECK(GetLastError()!=S_OK, TRUE);

	// CryptEncodeObject:	pbEncoded is not NULL while cbEncoded is 0.
	cbSecondEncoded=0;
	TESTC(CryptEncodeObject(dwEncodingType, lpszStructType,pvStructInfo,
		pbSecondEncoded,&cbSecondEncoded),FALSE)

	TCHECK(GetLastError(),ERROR_MORE_DATA);

	//CryptDecodeObject:	pvStructInfo is not NULL while pcbStructInfo is 0
	 cbStructInfo=0;
	 TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,
		cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	TCHECK(cbStructInfo,cbCorrectSize);

	TCHECK(GetLastError(),ERROR_MORE_DATA);


	//CryptDecodeObject: Pass invalid blobs
	cbSecondEncoded=(DWORD)(cbEncoded/2);

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,
		cbEncoded-cbSecondEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	dwReturn=GetLastError();
    // Ignore ASN1_ERR_EOD
    if (dwReturn != 0x80093102) {
        TCHECKALL(dwReturn,CRYPT_E_BAD_ENCODE, CRYPT_E_OSS_ERROR+DATA_ERROR);
    }

	//CryptDecodeObject: Pass cbEncoded=0
	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,
		0,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

	dwReturn=GetLastError();
    if (dwReturn != 0x80093102) {
        TCHECKALL(dwReturn,CRYPT_E_BAD_ENCODE, CRYPT_E_OSS_ERROR+MORE_INPUT);
    }


	//CryptDecodeObject: lpszStructType mismatches pbEncoded
	TESTC(MismatchTest(lpszStructType, cbEncoded, pbEncoded,cbLengthOnly),TRUE)

	fSucceeded=TRUE;


TCLEANUP:
	//release memory
	SAFE_FREE(pbSecondEncoded)

	SAFE_FREE(pvStructInfo)

	return fSucceeded;
}




//--------------------------------------------------------------------------
//	The routine to test CryptDecodeObject() handles the mismatch between
//	lpszStructType and pbEncoded  
//
//	PreCondition:	This routine assumes that lpszStructType's high-order
//					word is 0 and the low order word specifies the integer
//					identifier for the type of the given structure.
//
//	cbCorrectStructInfo is the correct size for pvStructInfo in CryptDecodeObject
//--------------------------------------------------------------------------

BOOL	MismatchTest(LPCSTR lpszStructType, DWORD cbEncoded, BYTE *pbEncoded,
					 	DWORD	cbCorrectStructInfo)
{
	BOOL		fSucceeded=FALSE;
	DWORD		dwrgSize=0;
	DWORD		dwError=0;
	ULONG		iIndex=0;
	void		*pvStructInfo=NULL;
	DWORD		cbStructInfo=cbCorrectStructInfo;
	DWORD		dwEncodingType=CRYPT_ENCODE_TYPE;
	LPCSTR		rglpszStructType[]={X509_CERT_TO_BE_SIGNED,
									X509_CERT_CRL_TO_BE_SIGNED,      
									X509_CERT_REQUEST_TO_BE_SIGNED,  
									X509_EXTENSIONS,
									X509_NAME_VALUE,
									X509_NAME,                       
									X509_PUBLIC_KEY_INFO,            
									X509_AUTHORITY_KEY_ID,        
									X509_KEY_ATTRIBUTES,          
									X509_KEY_USAGE_RESTRICTION,   
									X509_ALTERNATE_NAME,          
									X509_BASIC_CONSTRAINTS,       
									X509_KEY_USAGE,               
									X509_BASIC_CONSTRAINTS2,      
									X509_CERT_POLICIES,           
									PKCS_UTC_TIME,        
									PKCS_TIME_REQUEST,    
									RSA_CSP_PUBLICKEYBLOB,
									PKCS7_SIGNER_INFO};



	//init	
	dwrgSize=sizeof(rglpszStructType)/sizeof(rglpszStructType[0]);

	//We have different decoding type for PKCS7_SIGNER_INFO
	if((DWORD_PTR)(lpszStructType)==(DWORD_PTR)(PKCS7_SIGNER_INFO))
		dwEncodingType=MSG_ENCODING_TYPE;

	pvStructInfo=SAFE_ALLOC(cbCorrectStructInfo);
	CHECK_POINTER(pvStructInfo);

	//start to decode the BLOB.  Should fail when lpszStructType mismatches pbEncoded
	for(iIndex=0; iIndex<dwrgSize; iIndex++)
	{
		cbStructInfo=cbCorrectStructInfo;

		//skip the test if lpszStructType==X509_NAME_VALUE since the X509_NAME_VALUE 
		//allows any encoded type. It has the dwValueType CERT_RDN_ENCODED_BLOB.
	    if((DWORD_PTR)(rglpszStructType[iIndex])==(DWORD_PTR)X509_NAME_VALUE)
			continue;

		//if lpszStructType is the correct type, TRUE should be returned.
		if((DWORD_PTR)lpszStructType==(DWORD_PTR)(rglpszStructType[iIndex]))
		{
		   	TESTC(CryptDecodeObject(dwEncodingType, rglpszStructType[iIndex],
				pbEncoded,cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),TRUE)

		}
		else
		{
			//error should occur
			TESTC(CryptDecodeObject(dwEncodingType, rglpszStructType[iIndex],
				pbEncoded,cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),FALSE)

			//test the return code 
			dwError=GetLastError();

			//we are not sure that should be expected here.  The following error has 
			//occurred:
			//E_INVALIDARG, CRYPT_E_OSS_ERROR+PDU_MISMATCH, +DATA_ERROR, or
			//+MORE_INPUT
			
			//make sure at lease S_OK is not returned
			TCHECK(dwError!=S_OK, TRUE);
		}
	}


	fSucceeded=TRUE;

TCLEANUP:

	//release the memory
	SAFE_FREE(pvStructInfo)

	return	fSucceeded;

}
///////////////////////////////////////////////////////////////////////////////
//General Decode/Encode Testing routines

//--------------------------------------------------------------------------
//	Get a BLOB based on an input file.  
//
//--------------------------------------------------------------------------
BOOL	RetrieveBLOBfromFile(LPSTR	pszFileName,DWORD *pcbEncoded,BYTE **ppbEncoded)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cCount=0;
	HANDLE	hFile=NULL;

	assert(pszFileName);
	assert(pcbEncoded);
	assert(ppbEncoded);


	if((hFile = CreateFile(pszFileName,
            GENERIC_READ,
            0, NULL, OPEN_EXISTING, 0, NULL))==INVALID_HANDLE_VALUE)
	   PROCESS_ERR_GOTO("Can not open the file!\n");


	//Get the size of the file
	cCount=GetFileSize(hFile, NULL);

	//make sure the file is not empty
	TESTC(cCount!=0, TRUE)				   
	 	 
	//allocate memory
	*ppbEncoded=(BYTE *)SAFE_ALLOC(cCount);
	*pcbEncoded=cCount;

	//fill the buffer
	TESTC(ReadFile( hFile,*ppbEncoded, *pcbEncoded,&cCount,NULL),TRUE)

	//make sure that we have the right number of bytes
	TESTC(cCount,*pcbEncoded) 
	
	fSucceeded=TRUE;

TCLEANUP:
	
	if(hFile)
		CloseHandle(hFile);

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	A general routine to encode the singer info struct and 
//  add Attributes to the structur if there was none
//
//--------------------------------------------------------------------------
BOOL	EncodeSignerInfoWAttr(PCMSG_SIGNER_INFO pSignerInfo,DWORD *pbSignerEncoded,
								BYTE **ppbSignerEncoded)
{

	BOOL	fSucceeded=FALSE;
	//add attribute to the CMSG_SINGER_INFO struct if necessary
	//make up the attributes
	BYTE							rgAttribValue1[]={0x02, 0x02, 0x11, 0x11};
	BYTE							rgAttribValue2[]={0x02, 0x02, 0x11, 0x11};

	//make 3 CRYPT_ATTRIBUTE
	CRYPT_ATTRIBUTE					rgCryptAttribute[3];
	CRYPT_ATTR_BLOB					rgAttribBlob[3];
	
	rgAttribBlob[0].cbData=sizeof(rgAttribValue2);
	rgAttribBlob[0].pbData=rgAttribValue2;

	rgAttribBlob[1].cbData=sizeof(rgAttribValue2);
	rgAttribBlob[1].pbData=rgAttribValue2;

	rgAttribBlob[2].cbData=sizeof(rgAttribValue1);
	rgAttribBlob[2].pbData=rgAttribValue1;


	rgCryptAttribute[0].pszObjId="1.2.3.4";
	rgCryptAttribute[0].cValue=0;
	rgCryptAttribute[0].rgValue=NULL;

	rgCryptAttribute[1].pszObjId="1.2.3.4";
	rgCryptAttribute[1].cValue=1;
	rgCryptAttribute[1].rgValue=rgAttribBlob;

	rgCryptAttribute[2].pszObjId="1.2.3.4";
	rgCryptAttribute[2].cValue=3;
	rgCryptAttribute[2].rgValue=rgAttribBlob;

	//if pSingerInfo does not include any attributes, add attributes
	//to the struct
	if(pSignerInfo->AuthAttrs.cAttr==0)
	{
		pSignerInfo->AuthAttrs.cAttr=1;
		pSignerInfo->AuthAttrs.rgAttr=rgCryptAttribute;
	}

	if(pSignerInfo->UnauthAttrs.cAttr==0)
	{
		pSignerInfo->AuthAttrs.cAttr=3;
		pSignerInfo->AuthAttrs.rgAttr=rgCryptAttribute;
	}	

	//encode the struct
	TESTC(CryptEncodeObject(MSG_ENCODING_TYPE,PKCS7_SIGNER_INFO,
			pSignerInfo,NULL,pbSignerEncoded),TRUE)
			
	//allocate memory
	*ppbSignerEncoded=(BYTE *)SAFE_ALLOC(*pbSignerEncoded);
	CHECK_POINTER(*ppbSignerEncoded);

	//encode
	TESTC(CryptEncodeObject(MSG_ENCODING_TYPE,PKCS7_SIGNER_INFO,
			pSignerInfo,*ppbSignerEncoded,pbSignerEncoded),TRUE)



	fSucceeded=TRUE;

TCLEANUP:

	return fSucceeded;

}


//--------------------------------------------------------------------------
//	A general routine compare two time stamp request
//
//--------------------------------------------------------------------------
BOOL	CompareTimeStampRequest(CRYPT_TIME_STAMP_REQUEST_INFO *pReqNew,
								CRYPT_TIME_STAMP_REQUEST_INFO *pReqOld)
{

	BOOL	fSucceeded=FALSE;
	DWORD	iIndex=0;
	DWORD	iValue=0;


    TESTC(_stricmp(pReqNew->pszTimeStampAlgorithm, 
		pReqOld->pszTimeStampAlgorithm),0)
		
	TESTC(_stricmp(pReqNew->pszContentType, pReqOld->pszContentType),0)
	
    TESTC(pReqNew->Content.cbData, pReqOld->Content.cbData)
	
	
	TESTC(memcmp(pReqNew->Content.pbData,pReqOld->Content.pbData,
				 pReqNew->Content.cbData),0)

	TESTC(pReqNew->cAttribute, pReqOld->cAttribute)


	for(iIndex=0; iIndex<pReqNew->cAttribute;iIndex++)
	{
		TESTC(_stricmp(pReqNew->rgAttribute[iIndex].pszObjId,
			   pReqOld->rgAttribute[iIndex].pszObjId),0)

		TESTC(pReqNew->rgAttribute[iIndex].cValue,
			   pReqOld->rgAttribute[iIndex].cValue)


		for(iValue=0;iValue<pReqNew->rgAttribute[iIndex].cValue;iValue++)
		{
			TESTC(pReqNew->rgAttribute[iIndex].rgValue[iValue].cbData,
			pReqOld->rgAttribute[iIndex].rgValue[iValue].cbData)

			TESTC(memcmp(pReqNew->rgAttribute[iIndex].rgValue[iValue].pbData,
			pReqOld->rgAttribute[iIndex].rgValue[iValue].pbData,
			pReqOld->rgAttribute[iIndex].rgValue[iValue].cbData),0)

		}

	}

	fSucceeded=TRUE;

TCLEANUP:
   return fSucceeded;

}

//--------------------------------------------------------------------------
//	A general routine to verify the algorithm parameters is NULL.
//
//	cbData==2 and pbData=0x05 0x00 
//--------------------------------------------------------------------------
BOOL	VerifyAlgorithParam(PCRYPT_ALGORITHM_IDENTIFIER pAlgorithm)
{
	BOOL	fSucceeded=FALSE;				   

	TESTC((pAlgorithm->Parameters).cbData, 2);

	TESTC((BYTE)((pAlgorithm->Parameters).pbData[0])==(BYTE)5,TRUE);

	TESTC((BYTE)((pAlgorithm->Parameters).pbData[1])==(BYTE)0,TRUE);


	fSucceeded=TRUE;

TCLEANUP:
	return fSucceeded;

}

//--------------------------------------------------------------------------
//	A general routine to verify the PKCS_UTC_TIME
//
//--------------------------------------------------------------------------
BOOL	VerifyPKCS_UTC_TIME(BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbEncoded=0;
	BYTE		*pbEncoded=NULL;
	DWORD		dwError;

	FILETIME	FileTime;

	//setup the struct
	FileTime.dwLowDateTime=0;
	FileTime.dwHighDateTime=31457160;

	//encode the struct into a BLOB
	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,PKCS_UTC_TIME,
		&FileTime,NULL,&cbEncoded),TRUE)



	pbEncoded=(BYTE *)SAFE_ALLOC(cbEncoded);
	CHECK_POINTER(pbEncoded)

	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,PKCS_UTC_TIME,
		&FileTime,pbEncoded,&cbEncoded),TRUE)

   //decode the struct with COPY and NOCOPY options
	TESTC(DecodeGenericBLOB(PKCS_UTC_TIME,cbEncoded, pbEncoded, CRYPT_DECODE_COPY_FLAG, 
						TRUE,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	TESTC(DecodeGenericBLOB(PKCS_UTC_TIME,cbEncoded, pbEncoded, CRYPT_DECODE_NOCOPY_FLAG, 
						TRUE,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	fSucceeded=TRUE;


TCLEANUP:

	//print out the errors
	if(!fSucceeded)
	{
		dwError=GetLastError();
		printf("********The last error is %d\n",dwError);

		//print out the pbEncoded
		printf("The cbEncoded is %d, and pbEncoded is:\n",cbEncoded);

		PrintBytes("        ",pbEncoded,cbEncoded);
		printf("\n");
	}

	SAFE_FREE(pbEncoded);

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	A general routine to verify the PKCS_TIME_REQUEST
//
//--------------------------------------------------------------------------
BOOL	VerifyPKCS_TIME_REQUEST(BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL							fSucceeded=TRUE;
	CRYPT_TIME_STAMP_REQUEST_INFO	TimeStampRequest;
	void							*pvStructInfo=NULL;
	DWORD							cbStructInfo=0;
	DWORD							cbEncoded=0;
	BYTE							*pbEncoded=NULL;
	
	//make a hard-coded timestamp request
	BYTE							rgTestData[] = {
        0x1b, 0xf6, 0x92, 0xee, 0x6c, 0x44, 0xc5, 0xed, 0x51};

	BYTE							rgAttribValue1[]={
		0x02, 0x02, 0x11, 0x11};

	BYTE							rgAttribValue2[]={
		0x02, 0x02, 0x11, 0x11};


	//make 3 CRYPT_ATTRIBUTE
	CRYPT_ATTRIBUTE					rgCryptAttribute[3];
	CRYPT_ATTR_BLOB					rgAttribBlob[3];
	
	rgAttribBlob[0].cbData=sizeof(rgAttribValue2);
	rgAttribBlob[0].pbData=rgAttribValue2;

	rgAttribBlob[1].cbData=sizeof(rgAttribValue2);
	rgAttribBlob[1].pbData=rgAttribValue2;

	rgAttribBlob[2].cbData=sizeof(rgAttribValue1);
	rgAttribBlob[2].pbData=rgAttribValue1;


	rgCryptAttribute[0].pszObjId="1.2.3.4";
	rgCryptAttribute[0].cValue=0;
	rgCryptAttribute[0].rgValue=NULL;

	rgCryptAttribute[1].pszObjId="1.2.3.4";
	rgCryptAttribute[1].cValue=1;
	rgCryptAttribute[1].rgValue=rgAttribBlob;

	rgCryptAttribute[2].pszObjId="1.2.3.4";
	rgCryptAttribute[2].cValue=3;
	rgCryptAttribute[2].rgValue=rgAttribBlob;

    // initialize the timestamp structure
    TimeStampRequest.pszTimeStampAlgorithm = szOID_RSA_signingTime;
    TimeStampRequest.pszContentType = szOID_RSA_data;
    TimeStampRequest.Content.cbData = sizeof(rgTestData);
    TimeStampRequest.Content.pbData = rgTestData;
    TimeStampRequest.cAttribute = 3; 
    TimeStampRequest.rgAttribute = rgCryptAttribute;



	//encode the struct into a BLOB
	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,PKCS_TIME_REQUEST,
		&TimeStampRequest,NULL,&cbEncoded),TRUE)

	pbEncoded=(BYTE *)SAFE_ALLOC(cbEncoded);
	CHECK_POINTER(pbEncoded)

	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,PKCS_TIME_REQUEST,
		&TimeStampRequest,pbEncoded,&cbEncoded),TRUE)

   //decode the struct with COPY and NOCOPY options
	TESTC(DecodePKCS_TIME_REQUEST(cbEncoded, pbEncoded, CRYPT_DECODE_COPY_FLAG, 
						TRUE,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	TESTC(DecodePKCS_TIME_REQUEST(cbEncoded, pbEncoded, CRYPT_DECODE_NOCOPY_FLAG, 
						TRUE,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//decode the struct and compare it with the original
	TESTC(CryptDecodeObject(CRYPT_ENCODE_TYPE,PKCS_TIME_REQUEST,
	pbEncoded, cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,NULL,&cbStructInfo),TRUE)

	pvStructInfo=SAFE_ALLOC(cbStructInfo);
	CHECK_POINTER(pvStructInfo);

	TESTC(CryptDecodeObject(CRYPT_ENCODE_TYPE,PKCS_TIME_REQUEST,
	pbEncoded, cbEncoded,CRYPT_DECODE_NOCOPY_FLAG,pvStructInfo,&cbStructInfo),TRUE)

	//compare two timstamp request
	TESTC(CompareTimeStampRequest(&TimeStampRequest,
	(CRYPT_TIME_STAMP_REQUEST_INFO *)pvStructInfo),TRUE)

	fSucceeded=TRUE;


TCLEANUP:

	SAFE_FREE(pbEncoded);

	SAFE_FREE(pvStructInfo);

	return fSucceeded;
}


//--------------------------------------------------------------------------
//	A general routine to verify the CERT_PUBLIB_KEY_INFO.
//
//	Encode and decode the structure.  Call CryptImportPublicKeyInfo and 
//	CryptImportKey.
//--------------------------------------------------------------------------
BOOL	VerifyPublicKeyInfo(PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
							DWORD dwDecodeFlags,	BOOL fEncode,
							BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL			fSucceeded=FALSE;
	HCRYPTKEY		hKey=NULL;
	DWORD			cbEncoded=0;
	BYTE			*pbEncoded=NULL;

	//call CryptImportPublicKeyInfo
	TESTC(CryptImportPublicKeyInfo(g_hProv,CRYPT_ENCODE_TYPE,
		pPublicKeyInfo,&hKey),TRUE)

	//verify the algorithm
	TESTC(VerifyAlgorithParam(&(pPublicKeyInfo->Algorithm)),TRUE)

	//encode CERT_PUBLIC_KEY_INFO
	TESTC(EncodeStruct(X509_PUBLIC_KEY_INFO, pPublicKeyInfo,&cbEncoded,
					 &pbEncoded),TRUE)

	//decode/encode the publicKeyInfo
	TESTC(DecodeGenericBLOB(X509_PUBLIC_KEY_INFO, cbEncoded, pbEncoded, dwDecodeFlags, 
						fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

	//decode/encode the RSA_CSP_PUBLICKEYBLOB
	TESTC(DecodeRSA_CSP_PUBLICKEYBLOB(pPublicKeyInfo->PublicKey.cbData,
			pPublicKeyInfo->PublicKey.pbData,dwDecodeFlags,fEncode,fStructLengthCheck,
			fBLOBLengthCheck),TRUE)

	fSucceeded=TRUE;

TCLEANUP:
	if(hKey)
		TCHECK(CryptDestroyKey(hKey),TRUE);

	SAFE_FREE(pbEncoded)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	A general routine to verify the extentions in a cert.
//
//--------------------------------------------------------------------------
BOOL	VerifyCertExtensions(DWORD	cExtension, PCERT_EXTENSION rgExtension,
							 DWORD  dwDecodeFlags,	BOOL fEncode,
							 BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL				fSucceeded=FALSE;
	DWORD				cbEncoded=0;
	BYTE				*pbEncoded=NULL;
	CERT_EXTENSIONS		CertExtensions;
	DWORD				cbTestEncoded=0;
	BYTE				*pbTestEncoded=NULL;
	DWORD				cbStructInfo=sizeof(CERT_EXTENSIONS);
	CERT_EXTENSIONS		CertTestExtensions;

	//init
	CertExtensions.cExtension=0;
	CertExtensions.rgExtension=NULL;

	//Check the NULL case 

   	//length only calculation
	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,X509_EXTENSIONS, &CertExtensions,NULL,
			&cbTestEncoded),TRUE)

	//allocate memory
	pbTestEncoded=(BYTE *)SAFE_ALLOC(cbTestEncoded);
	CHECK_POINTER(pbTestEncoded);

	//EncodeObject
	TESTC(CryptEncodeObject(CRYPT_ENCODE_TYPE,X509_EXTENSIONS, &CertExtensions,
		pbTestEncoded, &cbTestEncoded),TRUE)

	//DecodeObject
	TESTC(CryptDecodeObject(CRYPT_ENCODE_TYPE,X509_EXTENSIONS,
	pbTestEncoded,cbTestEncoded,dwDecodeFlags,&CertTestExtensions,&cbStructInfo),TRUE)

	//Verify CertTestExtensions
	TESTC(CertTestExtensions.cExtension, CertExtensions.cExtension)


	//init again
	CertExtensions.cExtension=cExtension;
	CertExtensions.rgExtension=rgExtension;

	//encode CERT_EXTENSIONS
	TESTC(EncodeStruct(X509_EXTENSIONS, &CertExtensions,&cbEncoded,
					 &pbEncoded),TRUE)

	//decode/encode X509_EXTENSIONS
	TESTC(DecodeX509_EXTENSIONS(cbEncoded,
			pbEncoded,dwDecodeFlags,fEncode,fStructLengthCheck,
			fBLOBLengthCheck),TRUE)

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pbEncoded)

	SAFE_FREE(pbTestEncoded)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Return the corresponding lpStructInfo based on the objectID passed in
//--------------------------------------------------------------------------
LPCSTR	MapObjID2StructType(LPSTR	szObjectID)
{
	if(szObjectID==NULL)
		return NULL;
	
	if(strcmp(szObjectID,szOID_AUTHORITY_KEY_IDENTIFIER)==0)
		return X509_AUTHORITY_KEY_ID;

	if(strcmp(szObjectID,szOID_KEY_ATTRIBUTES)==0)
		return X509_KEY_ATTRIBUTES;

	if(strcmp(szObjectID,szOID_KEY_USAGE_RESTRICTION)==0)
		return X509_KEY_USAGE_RESTRICTION;

	if(strcmp(szObjectID,szOID_SUBJECT_ALT_NAME)==0)
		return X509_ALTERNATE_NAME;

	if(strcmp(szObjectID,szOID_ISSUER_ALT_NAME)==0)
		return X509_ALTERNATE_NAME;

	if(strcmp(szObjectID,szOID_BASIC_CONSTRAINTS)==0)
		return X509_BASIC_CONSTRAINTS;

	if(strcmp(szObjectID,szOID_KEY_USAGE)==0)
		return X509_KEY_USAGE;

	if(strcmp(szObjectID,szOID_BASIC_CONSTRAINTS2)==0)
		return X509_BASIC_CONSTRAINTS2;

	if(strcmp(szObjectID,szOID_CERT_POLICIES)==0)
		return X509_CERT_POLICIES;

	return NULL;
}

///////////////////////////////////////////////////////////////////////////
//Certificate Manipulation Functions
//--------------------------------------------------------------------------
//	Decode a storefile what has CRL and certificates
//--------------------------------------------------------------------------
BOOL	DecodeCertFile(LPSTR	pszFileName,BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck)
{
	BOOL				fSucceeded=FALSE;
	HCERTSTORE			hCertStore=NULL;
	DWORD				cbCertEncoded=0;
	BYTE				*pbCertEncoded=NULL;
	PCCERT_CONTEXT		pCertContext=NULL;
	PCCERT_CONTEXT		pPrevCertContext=NULL;
	PCCRL_CONTEXT		pCrlContext=NULL;
	PCCRL_CONTEXT		pPrevCrlContext=NULL;
	DWORD				dwFlags=0;
	DWORD				cCount=0;



	//open cert store
	if(!(hCertStore=CertOpenStore(CERT_STORE_PROV_FILENAME_A, CRYPT_ENCODE_TYPE,
		g_hProv,CERT_STORE_NO_CRYPT_RELEASE_FLAG,pszFileName)))
		PROCESS_ERR_GOTO("Failed to open a store!\n")	

	//get a cert from the store one at a time
	while((pCertContext=CertEnumCertificatesInStore(hCertStore,pPrevCertContext)))
	{
		cCount++;

		printf("//-----------------------------------------\n");
		printf("Decoding the %dth Certificate\n",cCount);

		//retrieve the encoded X_509 BLOBs
		cbCertEncoded=pCertContext->cbCertEncoded;
		pbCertEncoded=pCertContext->pbCertEncoded;

		//verify the hCertStore is connect
		TESTC(hCertStore==pCertContext->hCertStore, TRUE)

		//NULL/invalid parameter testing only once
		if(cCount==1)
			TESTC(ParameterTest(X509_CERT_TO_BE_SIGNED, cbCertEncoded, pbCertEncoded),TRUE)
	
		//decode/encode the certificate blob with NOCOPY option
		TESTC(DecodeX509_CERT(CERT_INFO_STRUCT,cbCertEncoded,pbCertEncoded, CRYPT_DECODE_NOCOPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,pCertContext->pCertInfo),TRUE)


		//decode/encode the certificate blob with COPY option
		TESTC(DecodeX509_CERT(CERT_INFO_STRUCT,cbCertEncoded,pbCertEncoded, CRYPT_DECODE_COPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,pCertContext->pCertInfo),TRUE)


		pPrevCertContext=pCertContext;
	}

	cCount=0;

	//get a CRL from the store one at a time
   	while((pCrlContext=CertGetCRLFromStore(hCertStore,NULL,pPrevCrlContext,&dwFlags)))
	{
		cCount++;

		printf("//-----------------------------------------\n");
		printf("Decoding the %dth CRL\n",cCount);

		//retrieve the encoded X_509 BLOBs
		cbCertEncoded=pCrlContext->cbCrlEncoded;
		pbCertEncoded=pCrlContext->pbCrlEncoded;

		//verify the hCertStore is connect
		TESTC(hCertStore==pCrlContext->hCertStore, TRUE)

		//NULL/invalid parameter testing only once
		if(cCount==1)
			TESTC(ParameterTest(X509_CERT_CRL_TO_BE_SIGNED, cbCertEncoded, pbCertEncoded),TRUE)
	
		//decode/encode the certificate blob with NOCOPY option
		TESTC(DecodeX509_CERT(CRL_INFO_STRUCT,cbCertEncoded,pbCertEncoded, CRYPT_DECODE_NOCOPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,pCrlContext->pCrlInfo),TRUE)


		//decode/encode the certificate blob with COPY option
		TESTC(DecodeX509_CERT(CRL_INFO_STRUCT,cbCertEncoded,pbCertEncoded, CRYPT_DECODE_COPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,pCrlContext->pCrlInfo),TRUE)


		pPrevCrlContext=pCrlContext;
	}


	fSucceeded=TRUE;

TCLEANUP:
		
	//release the cert context
	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	//we do not need to free pPreCertContext since it is always freed by
	//CertEnumCertificatesInStore.

	//release the CRL contest
	if(pCrlContext)
		CertFreeCRLContext(pCrlContext);

	//release the cert store
	if(hCertStore)
		TCHECK(CertCloseStore(hCertStore,CERT_CLOSE_STORE_FORCE_FLAG),TRUE);

	return fSucceeded;


}

//--------------------------------------------------------------------------
//	Decode a BLOB file that is an encoded certificate request
//--------------------------------------------------------------------------
BOOL	DecodeCertReqFile(LPSTR	pszFileName,BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbEncoded=0;
	BYTE	*pbEncoded=NULL;


	//Get the cbEncoded and pEncoded BLOB from the file
	TESTC(RetrieveBLOBfromFile(pszFileName,&cbEncoded,&pbEncoded),TRUE)

	//do a parameter testing
	TESTC(ParameterTest(X509_CERT_REQUEST_TO_BE_SIGNED, cbEncoded, pbEncoded),TRUE)

	//decode the BLOB as X509_CERT with COPY option
	TESTC(DecodeX509_CERT(CERT_REQUEST_INFO_STRUCT,cbEncoded,pbEncoded, CRYPT_DECODE_COPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,NULL),TRUE)

	//decode the BLOB as X509_CERT wiht NOCOPY option
	TESTC(DecodeX509_CERT(CERT_REQUEST_INFO_STRUCT,cbEncoded,pbEncoded, CRYPT_DECODE_NOCOPY_FLAG,
		TRUE,fStructLengthCheck,fBLOBLengthCheck,NULL),TRUE)

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pbEncoded)

	return fSucceeded;


}

//--------------------------------------------------------------------------
//	Decode a BLOB file that is an signed message
//--------------------------------------------------------------------------
BOOL	DecodeSignedMsgFile(LPSTR	pszFileName,BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck)
{
	BOOL				fSucceeded=FALSE;
	DWORD				cbEncoded=0;
	BYTE				*pbEncoded=NULL;
	DWORD				cbSignerEncoded=0;
	BYTE				*pbSignerEncoded=NULL;
	HCRYPTMSG			hCryptMsg=NULL;
	PCMSG_SIGNER_INFO	pSignerInfo=NULL;	
	DWORD				cbSize=0;
	DWORD				iIndex=0;
	DWORD				cSignerCount=0;



	//Get the cbEncoded and pEncoded BLOB from the file
	TESTC(RetrieveBLOBfromFile(pszFileName,&cbEncoded,&pbEncoded),TRUE)

	//Get the SIGNER_INFO BLOB from the file BLOB
	hCryptMsg=CryptMsgOpenToDecode(MSG_ENCODING_TYPE,0,0,g_hProv,NULL,NULL);

	if(!hCryptMsg)
		goto TCLEANUP;

	TESTC(CryptMsgUpdate(hCryptMsg,pbEncoded,cbEncoded,TRUE),TRUE)

	//Get the count of signer in the message
	cbSize=sizeof(cSignerCount);

	TESTC(CryptMsgGetParam(hCryptMsg,CMSG_SIGNER_COUNT_PARAM,
	0,&cSignerCount,&cbSize),TRUE)

	//go through the list of all signers
	for(iIndex=0;iIndex<cSignerCount;iIndex++)
	{
		//get the CMSG_SINGER_INFO struct
		TESTC(CryptMsgGetParam(hCryptMsg,CMSG_SIGNER_INFO_PARAM,
		iIndex,NULL,&cbSize),TRUE)

		//allocation memory
		pSignerInfo=(PCMSG_SIGNER_INFO)SAFE_ALLOC(cbSize);
		CHECK_POINTER(pSignerInfo);

		TESTC(CryptMsgGetParam(hCryptMsg,CMSG_SIGNER_INFO_PARAM,
		iIndex,pSignerInfo,&cbSize),TRUE)

		//encode the struct info a BLOB.  Add Attributes if possible
		TESTC(EncodeSignerInfoWAttr(pSignerInfo,&cbSignerEncoded,
		&pbSignerEncoded),TRUE)

		//do a parameter testing for the 1st round
		if(iIndex==0)
		{
			TESTC(ParameterTest(PKCS7_SIGNER_INFO, cbSignerEncoded, pbSignerEncoded),TRUE)
		}

		//decode the BLOB as PKCS7_SIGNER_INFO with COPY option
		TESTC(DecodePKCS7_SIGNER_INFO(cbSignerEncoded,pbSignerEncoded, CRYPT_DECODE_COPY_FLAG,
			TRUE,fStructLengthCheck,fBLOBLengthCheck),TRUE)

		//decode the BLOB as PKCS7_SIGNER_INFO wiht NOCOPY option
		TESTC(DecodePKCS7_SIGNER_INFO(cbSignerEncoded,pbSignerEncoded, CRYPT_DECODE_NOCOPY_FLAG,
			TRUE,fStructLengthCheck,fBLOBLengthCheck),TRUE)

		//release the memory
		SAFE_FREE(pSignerInfo);

		SAFE_FREE(pbSignerEncoded);

	}



	fSucceeded=TRUE;

TCLEANUP:
	//close the msg handle
	CryptMsgClose(hCryptMsg);

	SAFE_FREE(pbEncoded)

	SAFE_FREE(pbSignerEncoded)

	SAFE_FREE(pSignerInfo)

	return fSucceeded;


}



//--------------------------------------------------------------------------
//	A general routine to encode a struct based on lpszStructType
//--------------------------------------------------------------------------
BOOL	EncodeStruct(LPCSTR	lpszStructType, void *pStructInfo,DWORD *pcbEncoded,
					 BYTE **ppbEncoded)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbEncoded=NULL;
	BYTE	*pbTestEncoded=NULL;
	DWORD	cbTestEncoded=0;
	DWORD	dwEncodingType=CRYPT_ENCODE_TYPE;

	//init
	*pcbEncoded=0;
	*ppbEncoded=NULL;

	assert(lpszStructType);
	assert(pStructInfo);

	//We have different decoding type for PKCS7_SIGNER_INFO
	if((DWORD_PTR)(lpszStructType)==(DWORD_PTR)(PKCS7_SIGNER_INFO))
		dwEncodingType=MSG_ENCODING_TYPE;

	//length only calculation
	TESTC(CryptEncodeObject(dwEncodingType,lpszStructType, pStructInfo,NULL,
			&cbEncoded),TRUE)

	//the struct has to be more than 0 byte
	assert(cbEncoded);

	//allocate the correct amount of memory
	*ppbEncoded=(BYTE *)SAFE_ALLOC(cbEncoded);
	CHECK_POINTER(*ppbEncoded);

	//Encode the strcut with *pcbEncoded == the correct length
	*pcbEncoded=cbEncoded;

	//Encode the struct
	TESTC(CryptEncodeObject(dwEncodingType,lpszStructType,pStructInfo,*ppbEncoded,
		pcbEncoded),TRUE)

	//the length returned has to be less or equal to cbEncoded
	TESTC(cbEncoded>=(*pcbEncoded),TRUE)


	//allocate memory to LENGTH_DELTA byte more than necessary to pbTestEncoded
	pbTestEncoded=(BYTE *)SAFE_ALLOC(cbEncoded+LENGTH_MORE);
	CHECK_POINTER(pbTestEncoded)

  	//Encode the struct with *pcbEncoded > the correct length
	cbTestEncoded=cbEncoded+LENGTH_MORE;

	TESTC(CryptEncodeObject(dwEncodingType,lpszStructType,pStructInfo,pbTestEncoded,
		&cbTestEncoded),TRUE)

	//*pcbEncoded should be the same as cbEncoded
	TESTC(cbTestEncoded, *pcbEncoded)

	//Verify the pbTestEncoded contain the same bytes as pcbEncoded, starting 
	//at the 1st byte of the BLOB
	TESTC(memcmp(pbTestEncoded, *ppbEncoded,*pcbEncoded),0)

	//Encode the struct with *pcbEncoded < the correct length
	cbTestEncoded=(*pcbEncoded)-LENGTH_LESS;

	TESTC(CryptEncodeObject(dwEncodingType,lpszStructType,pStructInfo,pbTestEncoded,
		&cbTestEncoded),FALSE)

	//*pcbEncoded should be the same as cbEncoded
	TESTC(cbTestEncoded, *pcbEncoded)

	//GetLastError should be ERROR_MORE_DATA
	TESTC(GetLastError(),ERROR_MORE_DATA)

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pbTestEncoded)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	EncodeAndVerify 
//
//	Encode the pStructInfo and verify the encoded BLOB is the same
//	as expected.
//--------------------------------------------------------------------------
BOOL	EncodeAndVerify(LPCSTR	lpszStructType, void *pvStructInfo, DWORD cbEncoded, 
						BYTE *pbEncoded)
{
	DWORD	cbSecondEncoded=0;
	BYTE	*pbSecondEncoded=0;	
	BOOL	fSucceeded=FALSE;

	
	assert(lpszStructType);
	assert(pvStructInfo);
	assert(cbEncoded);
	assert(pbEncoded);

	//encode the struct back to a BLOB
	TESTC(EncodeStruct(lpszStructType,pvStructInfo,&cbSecondEncoded,&pbSecondEncoded),
		TRUE)

	//make sure the returned encoded BLOB is the same as the original BLOB
	//the two encoded BLOB has to of the same length
	if(!TCHECK(cbSecondEncoded, cbEncoded))
	{
		PROCESS_ERR(szEncodedSizeInconsistent)

		OutputError(lpszStructType,cbSecondEncoded, cbEncoded,pbSecondEncoded,pbEncoded);
	}
		
    if (0 != memcmp(pbSecondEncoded,pbEncoded,cbEncoded)) {
        if (X509_KEY_USAGE == lpszStructType) {
            // Force the unused bits to be the same
            if (3 <= cbSecondEncoded && 3 <= cbEncoded) {
                BYTE bUnusedBits = pbSecondEncoded[2];

                pbSecondEncoded[2] = pbEncoded[2];
                if (0 == memcmp(pbSecondEncoded,pbEncoded,cbEncoded))
                    printf("Warning, difference in reencoded KeyUsage UnusedBit Count\n");
                else
                    pbSecondEncoded[2] = bUnusedBits;
            }
        }
    }

	//the two encoded BLOB has to be of the same content
	if(!TCHECK(memcmp(pbSecondEncoded,pbEncoded,cbEncoded),0))
	{
		PROCESS_ERR(szEncodedContentInconsistent)
		OutputError(lpszStructType,cbSecondEncoded, cbEncoded,pbSecondEncoded,pbEncoded);
	}


	fSucceeded=TRUE;

TCLEANUP:
	
	SAFE_FREE(pbSecondEncoded)

	return fSucceeded;

}


//--------------------------------------------------------------------------
//	A general routine to decode a BLOB based on lpszStructType
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//
//--------------------------------------------------------------------------
BOOL  DecodeBLOB(LPCSTR	lpszStructType,DWORD cbEncoded, BYTE *pbEncoded,
				  DWORD	dwDecodeFlags, DWORD	*pcbStructInfo, void **ppvStructInfo,
				  BOOL	fStructLengthCheck,BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	LONG	iIndex=0;
	LONG	cbUpperLimit=0;
	DWORD	cbTestStructInfo=0;
	void	*pvTestStructInfo=NULL;
	DWORD	dwEncodingType=CRYPT_ENCODE_TYPE;

	//init
	*pcbStructInfo=0;
	*ppvStructInfo=NULL;

	assert(lpszStructType);
	assert(pbEncoded);
	assert(cbEncoded);

	//Decode 
	if((DWORD_PTR)(lpszStructType)==(DWORD_PTR)(PKCS7_SIGNER_INFO))
		dwEncodingType=MSG_ENCODING_TYPE;

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,cbEncoded,
		dwDecodeFlags,NULL,&cbStructInfo),TRUE)

	//the struct has to be more than 0 byte
	assert(cbStructInfo);

	*ppvStructInfo=(BYTE *)SAFE_ALLOC(cbStructInfo);
	CHECK_POINTER(*ppvStructInfo);

	//Decode the BLOB with *pcbStructInfo==correct length
	*pcbStructInfo=cbStructInfo;

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,cbEncoded,
	dwDecodeFlags,*ppvStructInfo,pcbStructInfo),TRUE)


	//make sure the correct length is less than cbStructInfo
	TESTC(cbStructInfo>=(*pcbStructInfo),TRUE);


	//Decode the BLOB with *pcbStructInfo>correct length

	//allocate memory to be LENGTH_DELTA more byte than the correct length
	pvTestStructInfo=SAFE_ALLOC(cbStructInfo+LENGTH_MORE);
	CHECK_POINTER(pvTestStructInfo);

	cbTestStructInfo=cbStructInfo+LENGTH_MORE;

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,cbEncoded,
	dwDecodeFlags,pvTestStructInfo,&cbTestStructInfo),TRUE)

	//make sure the length is the same
	TESTC(cbTestStructInfo, (*pcbStructInfo));

	//Decode the BLOB with *pcbStructInfo < correct length
	 cbTestStructInfo=(*pcbStructInfo)-LENGTH_LESS;

	TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,cbEncoded,
	dwDecodeFlags,pvTestStructInfo,&cbTestStructInfo),FALSE)

	TESTC(GetLastError(), ERROR_MORE_DATA)

	//make sure the length is the same
	TESTC(cbTestStructInfo, (*pcbStructInfo));

	//if fStructLengthCheck is TRUE, we need to do a more rigorous test of *pcbStructInfo
	if(fStructLengthCheck)
	{
	   
	   cbUpperLimit=(*pcbStructInfo)-1;

	   for(iIndex=cbUpperLimit; iIndex>=0; iIndex--)
	   {
			cbTestStructInfo=iIndex;

			//decode the BLOB with *pcbStructInfo<correct bytes
			TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,cbEncoded,
			dwDecodeFlags,pvTestStructInfo,&cbTestStructInfo),FALSE)

			TESTC(GetLastError(), ERROR_MORE_DATA)

			//make sure the length is the same
			TESTC(cbTestStructInfo, *pcbStructInfo);
	  }
	}


	//if fBLOBLengthCheck is TRUE, we need to do a more rigorous test of cbEncoded
	if(fBLOBLengthCheck)
	{
	   
	   cbUpperLimit=cbEncoded-1;

	   for(iIndex=cbUpperLimit; iIndex>=0; iIndex--)
	   {
		   	cbTestStructInfo=cbStructInfo;

			//decode the BLOB with cbEncoded < correct byte
			TESTC(CryptDecodeObject(dwEncodingType,lpszStructType,pbEncoded,iIndex,
			dwDecodeFlags,pvTestStructInfo,&cbTestStructInfo),FALSE)

			//we are not sure that should be expected here.  The following error has 
			//occurred:
			//E_INVALIDARG, CRYPT_E_OSS_ERROR+PDU_MISMATCH, +DATA_ERROR, or
			//+MORE_INPUT
			
			//make sure at lease S_OK is not returned
			TCHECK(GetLastError()!=S_OK, TRUE);
	  }
	}

						
	fSucceeded=TRUE;

TCLEANUP:

	//reallocate memory
	SAFE_FREE(pvTestStructInfo);


	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode X509_CERT BLOBs 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_CERT(DWORD	dwCertType,DWORD cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags,BOOL fEncode,
						BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						void *pInfoStruct)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;
	LPCSTR  lpszStructType=NULL;

	//init
	lpszStructType=X509_CERT;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//verify the algorithm
	TESTC(VerifyAlgorithParam(&(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->SignatureAlgorithm)),TRUE)

	//Further Decode the X509_CERT_TO_BE_SIGNED
	//Notice we should use the original cbData and pbData passed in for Decode
	//but use ToBeSigned in CERT_SIGNED_CONTENT_INFO for encode purpose
	switch(dwCertType)
	{
		case CERT_INFO_STRUCT:
				TESTC(DecodeX509_CERT_TO_BE_SIGNED(cbEncoded,
				pbEncoded,dwDecodeFlags,fEncode,
				fStructLengthCheck, fBLOBLengthCheck,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData
				),TRUE)	

				//verify the pCertInfo should be encoded correctly
				TCHECK(EncodeAndVerify(X509_CERT_TO_BE_SIGNED, pInfoStruct, 
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData, 
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData),TRUE);

			break;

		case CRL_INFO_STRUCT:
				TESTC(DecodeX509_CERT_CRL_TO_BE_SIGNED(cbEncoded,
				pbEncoded,dwDecodeFlags,fEncode,
				fStructLengthCheck, fBLOBLengthCheck,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData
				),TRUE)
				
				//verify the pCrlInfo should be encoded correctly
				TCHECK(EncodeAndVerify(X509_CERT_CRL_TO_BE_SIGNED, pInfoStruct, 
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData, 
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData),TRUE);

			break;

		case CERT_REQUEST_INFO_STRUCT:
				TESTC(DecodeX509_CERT_REQUEST_TO_BE_SIGNED(cbEncoded,
				pbEncoded,dwDecodeFlags,fEncode,
				fStructLengthCheck, fBLOBLengthCheck,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).cbData,
				(((PCERT_SIGNED_CONTENT_INFO)pStructInfo)->ToBeSigned).pbData
				),TRUE)	
			break;


	}
	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, pbEncoded),TRUE);


	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}		 



//--------------------------------------------------------------------------
//	Decode X509_CERT_TO_BE_SIGNED BLOBs 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_CERT_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded)
{

	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;
	LPCSTR  lpszStructType=NULL;

	//init
	lpszStructType=X509_CERT_TO_BE_SIGNED;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Verify the signaure algorithm 
	TESTC(VerifyAlgorithParam(&(((PCERT_INFO)pStructInfo)->SignatureAlgorithm)),TRUE)

	//Verify the public Key information
	TESTC(VerifyPublicKeyInfo(&(((PCERT_INFO)pStructInfo)->SubjectPublicKeyInfo),
	dwDecodeFlags, fEncode,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Decode Issuer in CERT_INFO struct
	TESTC(DecodeX509_NAME((((PCERT_INFO)pStructInfo)->Issuer).cbData,
	(((PCERT_INFO)pStructInfo)->Issuer).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode Issuer to X509_UNICODE_NAME
	TESTC(DecodeX509_UNICODE_NAME((((PCERT_INFO)pStructInfo)->Issuer).cbData,
	(((PCERT_INFO)pStructInfo)->Issuer).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode Subject in CERT_INFO struct
	TESTC(DecodeX509_NAME((((PCERT_INFO)pStructInfo)->Subject).cbData,
	(((PCERT_INFO)pStructInfo)->Subject).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode Subject to X509_UNICODE_NAME
	TESTC(DecodeX509_UNICODE_NAME((((PCERT_INFO)pStructInfo)->Subject).cbData,
	(((PCERT_INFO)pStructInfo)->Subject).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Verify the extensions
	TESTC(VerifyCertExtensions(((PCERT_INFO)pStructInfo)->cExtension, 
	((PCERT_INFO)pStructInfo)->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)
	
	//decode the extensions one by one
	TESTC(DecodeCertExtensions(((PCERT_INFO)pStructInfo)->cExtension, 
	((PCERT_INFO)pStructInfo)->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbExpectedEncoded, 
		pbExpectedEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode X509_CERT_CRL_TO_BE_SIGNED BLOBs 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_CERT_CRL_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbStructInfo=0;
	void		*pStructInfo=NULL;
	DWORD		iIndex=0;
	PCRL_ENTRY	pCrlEntry=NULL;
	LPCSTR  lpszStructType=NULL;

	//init
	lpszStructType=X509_CERT_CRL_TO_BE_SIGNED;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Verify the signaure algorithm 
	TESTC(VerifyAlgorithParam(&(((PCRL_INFO)pStructInfo)->SignatureAlgorithm)),TRUE)


	//Decode Issuer in CRL_INFO struct
	TESTC(DecodeX509_NAME((((PCRL_INFO)pStructInfo)->Issuer).cbData,
	(((PCRL_INFO)pStructInfo)->Issuer).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode Issuer to the X509_UNICODE_NAME 
	TESTC(DecodeX509_UNICODE_NAME((((PCRL_INFO)pStructInfo)->Issuer).cbData,
	(((PCRL_INFO)pStructInfo)->Issuer).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Verify the CRL_ENTRY
	for(iIndex=0; iIndex<((PCRL_INFO)pStructInfo)->cCRLEntry; iIndex++)
	{
		pCrlEntry=&(((PCRL_INFO)pStructInfo)->rgCRLEntry[iIndex]);

		TESTC(DecodeCRLEntry(pCrlEntry,dwDecodeFlags,fEncode,
			fStructLengthCheck, fBLOBLengthCheck),TRUE)
	}

	//Verify the extensions
	TESTC(VerifyCertExtensions(((PCRL_INFO)pStructInfo)->cExtension, 
	((PCRL_INFO)pStructInfo)->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)
	
	//decode the extensions one by one
	TESTC(DecodeCertExtensions(((PCRL_INFO)pStructInfo)->cExtension, 
	((PCRL_INFO)pStructInfo)->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbExpectedEncoded, 
		pbExpectedEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode 509_CERT_REQUEST_TO_BE_SIGNED BLOBS
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_CERT_REQUEST_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded)
{

	BOOL				fSucceeded=FALSE;
	DWORD				cbStructInfo=0;
	void				*pStructInfo=NULL;
	DWORD				cCount=0;
	DWORD				iIndex=0;
	PCRYPT_ATTRIBUTE	pCryptAttribute=NULL;
	LPCSTR				lpszStructType=NULL;

	//init
	lpszStructType=X509_CERT_REQUEST_TO_BE_SIGNED;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Verify the public Key information
//	TESTC(VerifyPublicKeyInfo(&(((PCERT_REQUEST_INFO)pStructInfo)->SubjectPublicKeyInfo),
//	dwDecodeFlags, fEncode,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Decode Subject in CERT_REQUEST_INFO struct
	TESTC(DecodeX509_NAME((((PCERT_REQUEST_INFO)pStructInfo)->Subject).cbData,
	(((PCERT_REQUEST_INFO)pStructInfo)->Subject).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode Subject in CERT_REQUEST_INFO struct for X509_UNICODE_NAME
	TESTC(DecodeX509_UNICODE_NAME((((PCERT_REQUEST_INFO)pStructInfo)->Subject).cbData,
	(((PCERT_REQUEST_INFO)pStructInfo)->Subject).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode the rgAttribute in CERT_REQUEST_INFO
	cCount=((PCERT_REQUEST_INFO)pStructInfo)->cAttribute;
	
	for(iIndex=0; iIndex<cCount; iIndex++)
	{
		pCryptAttribute=&(((PCERT_REQUEST_INFO)pStructInfo)->rgAttribute[iIndex]);

		TESTC(DecodeCryptAttribute(pCryptAttribute,dwDecodeFlags,fEncode,
			fStructLengthCheck, fBLOBLengthCheck),TRUE)
	}


	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbExpectedEncoded, 
		pbExpectedEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}
//--------------------------------------------------------------------------
//	Decode RSA_CSP_PUBLICKEYBLOB
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeRSA_CSP_PUBLICKEYBLOB(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbStructInfo=0;
	void		*pStructInfo=NULL;
	LPCSTR		lpszStructType=NULL;
	HCRYPTKEY	hKey=NULL;	

	//init
	lpszStructType=RSA_CSP_PUBLICKEYBLOB;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)


	//Make sure the pStructInfo can be used by CryptImportKey
	TESTC(CryptImportKey(g_hProv,(BYTE *)pStructInfo,cbStructInfo,
	0,0,&hKey),TRUE)

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, 
		pbEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	if(hKey)
		TCHECK(CryptDestroyKey(hKey),TRUE);

	SAFE_FREE(pStructInfo)

	return fSucceeded;
}


//--------------------------------------------------------------------------
//	Decode PKCS_TIME_REQUEST
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodePKCS_TIME_REQUEST(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbStructInfo=0;
	void		*pStructInfo=NULL;
	LPCSTR		lpszStructType=NULL;

	//init
	lpszStructType=PKCS_TIME_REQUEST;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, 
		pbEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;
}



//--------------------------------------------------------------------------
//	Decode a genanric BLOB, encode is back to make sure that the same
//  BLOB is returned. 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeGenericBLOB(LPCSTR	lpszStructType, DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;

	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, 
		pbEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}


//--------------------------------------------------------------------------
//	Decode X509_NAME BLOBs 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_NAME(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{

	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;
	LPCSTR  lpszStructType=NULL;
	DWORD	cRDN=0;
	DWORD	cRDNAttr=0;
	DWORD	cRDNCount=0;
	DWORD	cRDNAttrCount=0;
	

	//init
	lpszStructType=X509_NAME;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//We need to further decode CERT_RDN_ATTR if dwValueType is CERT_RDN_ENCODED_BLOB
	cRDNCount=((PCERT_NAME_INFO)pStructInfo)->cRDN;

	for(cRDN=0;cRDN<cRDNCount;cRDN++)
	{
		cRDNAttrCount=(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).cRDNAttr;

		for(cRDNAttr=0; cRDNAttr<cRDNAttrCount; cRDNAttr++)
		{
			//no need to do a length checking since the routine is written and 
			//installed by third party 
			if( (((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].dwValueType==
				CERT_RDN_ENCODED_BLOB)
				TESTC(DecodeBasedOnObjID(
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].pszObjId,
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].Value.cbData,
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].Value.pbData,
				dwDecodeFlags, fEncode,fStructLengthCheck, fBLOBLengthCheck),TRUE)
		}

	}


	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, pbEncoded),TRUE);

		
	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode PKCS7_SIGNER_INFO
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodePKCS7_SIGNER_INFO(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;
	LPCSTR  lpszStructType=NULL;

	//init
	lpszStructType=PKCS7_SIGNER_INFO;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//further decode the issuser name
	TESTC(DecodeX509_NAME((((PCMSG_SIGNER_INFO)pStructInfo)->Issuer).cbData,
	(((PCMSG_SIGNER_INFO)pStructInfo)->Issuer).pbData,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//further decode the attributes 
	TESTC(VerifyAttributes(((PCMSG_SIGNER_INFO)pStructInfo)->AuthAttrs.cAttr,
		 ((PCMSG_SIGNER_INFO)pStructInfo)->AuthAttrs.rgAttr,
		 dwDecodeFlags,fEncode,
		fStructLengthCheck, fBLOBLengthCheck),TRUE)

	TESTC(VerifyAttributes(((PCMSG_SIGNER_INFO)pStructInfo)->UnauthAttrs.cAttr,
		 ((PCMSG_SIGNER_INFO)pStructInfo)->UnauthAttrs.rgAttr,
		 dwDecodeFlags,fEncode,
		fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, 
		pbEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;

}


//--------------------------------------------------------------------------
//	Decode an array of attributes
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	VerifyAttributes(DWORD	cAttr, PCRYPT_ATTRIBUTE	rgAttr,					
			DWORD dwDecodeFlags, BOOL fEncode, BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;
	ULONG	iIndex=0;

	for(iIndex=0;iIndex<cAttr;iIndex++)
	{
		TESTC(DecodeCryptAttribute(&(rgAttr[iIndex]),dwDecodeFlags,fEncode,
				 fStructLengthCheck,fBLOBLengthCheck),TRUE)
	}

	fSucceeded=TRUE;

TCLEANUP:

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode X509_UNICODE_NAME BLOBs 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_UNICODE_NAME(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{

	BOOL	fSucceeded=FALSE;
	DWORD	cbStructInfo=0;
	void	*pStructInfo=NULL;
	LPCSTR  lpszStructType=NULL;
	DWORD	cRDN=0;
	DWORD	cRDNAttr=0;
	DWORD	cRDNCount=0;
	DWORD	cRDNAttrCount=0;
	

	//init
	lpszStructType=X509_UNICODE_NAME;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//We need to further decode CERT_RDN_ATTR if dwValueType is CERT_RDN_ENCODED_BLOB
	cRDNCount=((PCERT_NAME_INFO)pStructInfo)->cRDN;

	for(cRDN=0;cRDN<cRDNCount;cRDN++)
	{
		cRDNAttrCount=(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).cRDNAttr;

		for(cRDNAttr=0; cRDNAttr<cRDNAttrCount; cRDNAttr++)
		{
			//no need to do a length checking since the routine is written and 
			//installed by third party 
			if( (((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].dwValueType==
				CERT_RDN_ENCODED_BLOB)
				TESTC(DecodeBasedOnObjID(
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].pszObjId,
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].Value.cbData,
				(((PCERT_NAME_INFO)pStructInfo)->rgRDN[cRDN]).rgRDNAttr[cRDNAttr].Value.pbData,
				dwDecodeFlags, fEncode,fStructLengthCheck, fBLOBLengthCheck),TRUE)
		}

	}


	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, pbEncoded),TRUE);

		
	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;


}



//--------------------------------------------------------------------------
//	Decode X509_EXTENSIONS BLOB 
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeX509_EXTENSIONS(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL		fSucceeded=FALSE;
	DWORD		cbStructInfo=0;
	void		*pStructInfo=NULL;
	LPCSTR		lpszStructType=NULL;

	//init
	lpszStructType=X509_EXTENSIONS;


	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbEncoded, pbEncoded,dwDecodeFlags,&cbStructInfo,
		&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//Decode further the pStructInfo which points to an array of CERT_EXTENSION
	TESTC(DecodeCertExtensions(((PCERT_EXTENSIONS)pStructInfo)->cExtension,
	  ((PCERT_EXTENSIONS)pStructInfo)->rgExtension,dwDecodeFlags, fEncode,
	  fStructLengthCheck,fBLOBLengthCheck),TRUE)

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbEncoded, 
		pbEncoded),TRUE);

	fSucceeded=TRUE;

TCLEANUP:

	SAFE_FREE(pStructInfo)

	return fSucceeded;
}
 
//--------------------------------------------------------------------------
//	Decode an array of X509 cert extensions
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeCertExtensions(DWORD	cExtension, PCERT_EXTENSION rgExtension, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	DWORD	iIndex=0;
	BOOL	fSucceeded=FALSE;

	for(iIndex=0; iIndex<cExtension; iIndex++)
	{
		TESTC(DecodeBasedOnObjID((rgExtension[iIndex]).pszObjId,
			(rgExtension[iIndex]).Value.cbData,  (rgExtension[iIndex]).Value.pbData,
			dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)
	}

	fSucceeded=TRUE;

TCLEANUP:
	
	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode CRYPT_ATTRIBUTE struct and encode
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeCryptAttribute(PCRYPT_ATTRIBUTE pCryptAttribute,DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;	
	DWORD	iIndex=0;

	for(iIndex=0; iIndex<pCryptAttribute->cValue;iIndex++)
	{
		TESTC(DecodeBasedOnObjID(pCryptAttribute->pszObjId,
			(pCryptAttribute->rgValue)[iIndex].cbData,
			(pCryptAttribute->rgValue)[iIndex].pbData,
			dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

	}


	fSucceeded=TRUE;

TCLEANUP:

	return fSucceeded;
}


//--------------------------------------------------------------------------
//	Decode CRL_ENTRY struct and encode
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeCRLEntry(PCRL_ENTRY pCrlEntry, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL	fSucceeded=FALSE;

	//Verify the extensions
	TESTC(VerifyCertExtensions(pCrlEntry->cExtension, 
	pCrlEntry->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)
	
	//decode the extensions one by one
	TESTC(DecodeCertExtensions(pCrlEntry->cExtension, 
	pCrlEntry->rgExtension,dwDecodeFlags,fEncode,
	fStructLengthCheck, fBLOBLengthCheck),TRUE)

	fSucceeded=TRUE;

TCLEANUP:

	return fSucceeded;

}

//--------------------------------------------------------------------------
//	Decode one X509 cert extension
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeBasedOnObjID(LPSTR	szObjId,	DWORD	cbData, BYTE	*pbData,
						DWORD dwDecodeFlags,		BOOL fEncode,
						BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL						fSucceeded=FALSE;
	DWORD						cbStructInfo=0;
	void						*pStructInfo=NULL;
	DWORD						iIndex=0;
	DWORD						cCount=0;
	DWORD						iIndexInner=0;
	DWORD						cCountInner=0;
	CERT_NAME_BLOB				*pBlob=NULL;
	PCERT_ALT_NAME_ENTRY		pCertAltNameEntry=NULL;
	PCERT_POLICY_INFO			pCertPolicyInfo=NULL;
	PCERT_POLICY_QUALIFIER_INFO	pCertPolicyQualifierInfo=NULL;	
	LPCSTR						lpszStructType=NULL;

	//init
	lpszStructType=MapObjID2StructType(szObjId);

	//return TRUE if we can not recognize the object ID.  We can no longer
	//go any further.
	if(!lpszStructType)
		return TRUE;

	//Decode the encoded BLOB
	TESTC(DecodeBLOB(lpszStructType,cbData, pbData,
		dwDecodeFlags,&cbStructInfo,&pStructInfo,fStructLengthCheck, fBLOBLengthCheck),TRUE)

	//further decode the extension if we know what the struct look like
	switch((DWORD_PTR)lpszStructType)
	{
		//we need to further decode CertIssuer in CERT_AUTHORITY_KEY_ID_INFO
		case	(DWORD_PTR)(X509_AUTHORITY_KEY_ID):
						
						pBlob=&(((PCERT_AUTHORITY_KEY_ID_INFO)pStructInfo)->CertIssuer);

						TESTC(DecodeX509_NAME(pBlob->cbData, pBlob->pbData,
						dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

						//further decode the BLOB to X509_UNICODE_NAME
						TESTC(DecodeX509_UNICODE_NAME(pBlob->cbData, pBlob->pbData,
						dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)
				
					break;

		//we need to further decode the CERT_ALT_NAME_ENTRY array
		case	(DWORD_PTR)(X509_ALTERNATE_NAME):
		
				
			/*	cCount=((PCERT_ALT_NAME_INFO)pStructInfo)->cAltEntry;

					for(iIndex=0; iIndex<cCount; iIndex++)
					{
						pCertAltNameEntry=&(((PCERT_ALT_NAME_INFO)pStructInfo)->rgAltEntry[iIndex]);

						TESTC(DecodeCertAltNameEntry(pCertAltNameEntry,dwDecodeFlags,	fEncode,
						fStructLengthCheck, fBLOBLengthCheck),TRUE)

					} 
						  */
					break;
	   											  
		//we need to further decode CERT_BASIC_CONSTRAINTS_INFO
		case	(DWORD_PTR)(X509_BASIC_CONSTRAINTS):

						cCount=((PCERT_BASIC_CONSTRAINTS_INFO)pStructInfo)->cSubtreesConstraint;

						//decode the array of CERT_NAME_BLOB in rgSubtreesConstraint 
						//of CERT_BASIC_CONSTRAINTS_INFO
						for(iIndex=0; iIndex<cCount; iIndex++)
						{
							pBlob=&((((PCERT_BASIC_CONSTRAINTS_INFO)pStructInfo)->rgSubtreesConstraint)[iIndex]);

							TESTC(DecodeX509_NAME(pBlob->cbData, pBlob->pbData,
							dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

							//further decode as X509_UNICODE_NAME
							TESTC(DecodeX509_UNICODE_NAME(pBlob->cbData, pBlob->pbData,
							dwDecodeFlags, fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)
						}
					break;

		case	(DWORD_PTR)(X509_CERT_POLICIES ):

						cCount=((PCERT_POLICIES_INFO)pStructInfo)->cPolicyInfo;
						
						for(iIndex=0; iIndex<cCount;iIndex++)
						{
							pCertPolicyInfo=&(((PCERT_POLICIES_INFO)pStructInfo)->rgPolicyInfo[iIndex]);

							cCountInner=pCertPolicyInfo->cPolicyQualifier;

							for(iIndexInner=0; iIndexInner<cCountInner; iIndexInner++)
							{

								pCertPolicyQualifierInfo=&((pCertPolicyInfo->rgPolicyQualifier)[iIndexInner]);

								//Although DecodeBasedOnObjID is called here, we have
								//no risk of an infinite loop.  
								//This is a recursive call, which should
								//end when there is no further decodable code, that is, 
								//the pszObjID should not be szOID_CERT_POLICIES

								TESTC(DecodeBasedOnObjID(pCertPolicyQualifierInfo->pszPolicyQualifierId,
								pCertPolicyQualifierInfo->Qualifier.cbData,
								pCertPolicyQualifierInfo->Qualifier.pbData,
								dwDecodeFlags, fEncode,fStructLengthCheck,
								fBLOBLengthCheck),TRUE)

							}
						}
					break;

		default:
				
					break;
	}	

	//if requested, encode the BLOB back to what it was.  Make sure no data is lost
	//by checking the size of the encoded blob and do a memcmp.
	if(fEncode)
		TCHECK(EncodeAndVerify(lpszStructType, pStructInfo,cbData, 
		pbData),TRUE);

	fSucceeded=TRUE;

TCLEANUP:


	SAFE_FREE(pStructInfo)

	return fSucceeded;
}


//--------------------------------------------------------------------------
//	Decode one X509 cert extension
//
//		fStructLengthCheck: Flag to indicate whether a length checking is necessary
//					 for *pcbStructInfo from 0 .. CorrectLength-1
//
//		fBLOBLengthCheck:	Flag to indicate whether a length checking is necessary
//					for cbEncoded from 0 .. CorrentLength-1
//--------------------------------------------------------------------------
BOOL	DecodeCertAltNameEntry(PCERT_ALT_NAME_ENTRY	pCertAltNameEntry,
						DWORD dwDecodeFlags,		BOOL fEncode,
						BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck)
{
	BOOL						fSucceeded=FALSE;
	PCRYPT_ATTRIBUTE_TYPE_VALUE	pAttributeTypeValue=NULL;

	assert(pCertAltNameEntry);

	switch(pCertAltNameEntry->dwAltNameChoice)
	{
		case	CERT_ALT_NAME_DIRECTORY_NAME:

					//further decode the NAME_BLOB in DirectoryName
					TESTC(DecodeX509_NAME(pCertAltNameEntry->DirectoryName.cbData,
					pCertAltNameEntry->DirectoryName.pbData,
					dwDecodeFlags,fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

					//decode it as UNICODE
					TESTC(DecodeX509_UNICODE_NAME(pCertAltNameEntry->DirectoryName.cbData,
					pCertAltNameEntry->DirectoryName.pbData,
					dwDecodeFlags,fEncode,fStructLengthCheck,fBLOBLengthCheck),TRUE)

				break;

		default:
				break;
	}

	fSucceeded=TRUE;

TCLEANUP:

	return fSucceeded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tctlfunc\tctlfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tctlfunc.cpp
//
//  Contents:   CertVerifyCTLUsage Function Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    08-May-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static void Usage(void)
{
    printf("Usage: tctlfunc [options] <SubjectCertFile1> <SubjectCertFile2> ...\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -U<ObjectID>          - Usage Identifier\n");
    printf("  -L<text>              - List Identifier\n");
    printf("  -A                    - Test via AnySubjectType\n");
    printf("  -c<filename>          - CTL store file\n");
    printf("  -C<storename>         - CTL system store\n");
    printf("  -s<filename>          - Signer store file\n");
    printf("  -S<storename>         - Signer system store\n");
    printf("  -e<Expected Error>    - For example, -e0x0\n");
    printf("  -f<number>            - Verify dwFlags\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("\n");
}

static HCERTSTORE OpenSignerStore(
    LPSTR pszStore,
    BOOL fSystemStore
    )
{
    HCERTSTORE hStore;

    if (fSystemStore)
        hStore = CertOpenSystemStore(NULL, pszStore);
    else
        hStore = CertOpenStore(
                CERT_STORE_PROV_FILENAME_A,
                dwMsgAndCertEncodingType,
                0,                      // hCryptProv
                0,                      // dwFlags
                (const void *) pszStore
                );
    return hStore;
}


// Attempt to read as a file containing an encoded CTL.
static HCERTSTORE OpenCtlStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (!ReadDERFromFile(pszStoreFilename, &pbEncoded, &cbEncoded))
        return NULL;
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCTLToStore(
            hStore,
            dwMsgAndCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCtlContext
            )) {
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
    TestFree(pbEncoded);
    return hStore;
}

static HCERTSTORE OpenCtlStore(
    LPSTR pszStore,
    BOOL fSystemStore
    )
{
    HCERTSTORE hStore;

    if (!fSystemStore)
        hStore = OpenCtlStoreFile(pszStore);
    else
        hStore = NULL;

    if (NULL == hStore)
        hStore = OpenSignerStore(pszStore, fSystemStore);
    return hStore;
}

static PCCERT_CONTEXT OpenSubjectCert(
    LPSTR pszFilename
    )
{
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszFilename, &pbEncoded, &cbEncoded))
        return NULL;

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    TestFree(pbEncoded);
    return pCert;
}


int _cdecl main(int argc, char * argv[]) 
{
    int status;

    DWORD dwError = 0;
    DWORD dwFlags = 0;
    DWORD dwSubjectType = CTL_CERT_SUBJECT_TYPE;
    DWORD dwDisplayFlags = 0;

#define MAX_USAGE_ID 20
    LPSTR rgpszUsageId[MAX_USAGE_ID];
    CTL_USAGE SubjectUsage = {0, rgpszUsageId};

#define MAX_CTL_STORE_COUNT     16
    HCERTSTORE rghCtlStore[MAX_CTL_STORE_COUNT];
#define MAX_SIGNER_STORE_COUNT  16
    HCERTSTORE rghSignerStore[MAX_SIGNER_STORE_COUNT];
#define MAX_SUBJECT_COUNT       16
    PCCERT_CONTEXT rgpSubject[MAX_SUBJECT_COUNT];
    DWORD cSubject = 0;

    CTL_VERIFY_USAGE_PARA VerifyPara;
    CTL_VERIFY_USAGE_STATUS VerifyStatus;
    CTL_ANY_SUBJECT_INFO AnySubjectInfo;
    BYTE rgbHash[MAX_HASH_LEN];

    PCCTL_CONTEXT pCtl = NULL;
    PCCERT_CONTEXT pSigner = NULL;

    memset(&VerifyPara, 0, sizeof(VerifyPara));
    VerifyPara.cbSize = sizeof(VerifyPara); 
    VerifyPara.rghCtlStore = rghCtlStore;
    VerifyPara.rghSignerStore = rghSignerStore;

    memset(&VerifyStatus, 0, sizeof(VerifyStatus));
    VerifyStatus.cbSize = sizeof(VerifyStatus); 
    VerifyStatus.ppCtl = &pCtl;
    VerifyStatus.ppSigner = &pSigner;

    DWORD i;

    while (--argc>0) {
        if (**++argv == '-')
        {
            BOOL fSystemStore = FALSE;

            switch(argv[0][1])
            {
            case 'U':
                if (SubjectUsage.cUsageIdentifier >= MAX_USAGE_ID) {
                    printf("Maximum number of Usage Identifiers: %d\n",
                        MAX_USAGE_ID);
            		goto BadUsage;
                }
                rgpszUsageId[SubjectUsage.cUsageIdentifier++] = argv[0] + 2;
                break;
            case 'L':
                if (0 == strlen(argv[0] + 2))
                    VerifyPara.ListIdentifier.cbData =
                        CTL_FIND_NO_LIST_ID_CBDATA;
                else {
                    VerifyPara.ListIdentifier.cbData = strlen(argv[0] + 2);
                    VerifyPara.ListIdentifier.pbData = (BYTE *) argv[0] + 2;
                }
                break;
            case 'A':
                dwSubjectType = CTL_ANY_SUBJECT_TYPE;
                break;
            case 'C':
                fSystemStore = TRUE;
            case 'c':
                if (VerifyPara.cCtlStore >= MAX_CTL_STORE_COUNT) {
                    printf("Maximum number of CTL Stores: %d\n",
                        MAX_CTL_STORE_COUNT);
            		goto BadUsage;
                }
                
                if (rghCtlStore[VerifyPara.cCtlStore] = OpenCtlStore(
                        argv[0] + 2, fSystemStore))
                    VerifyPara.cCtlStore++;
                else {
                    printf("OpenCtlStore(%s) failed\n", argv[0] + 2);
                    goto BadUsage;
                }
                break;
            case 'S':
                fSystemStore = TRUE;
            case 's':
                if (VerifyPara.cSignerStore >= MAX_SIGNER_STORE_COUNT) {
                    printf("Maximum number of Signer Stores: %d\n",
                        MAX_SIGNER_STORE_COUNT);
            		goto BadUsage;
                }
                
                if (rghSignerStore[VerifyPara.cSignerStore] = OpenSignerStore(
                        argv[0] + 2, fSystemStore))
                    VerifyPara.cSignerStore++;
                else {
                    printf("OpenSignerStore(%s) failed\n", argv[0] + 2);
                    goto BadUsage;
                }
                break;
            case 'e':
                dwError = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'f':
                dwFlags = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'b':
                dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                break;
            case 'v':
                dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (cSubject >= MAX_SUBJECT_COUNT) {
                printf("Exceeded maximum Subject count of %d\n",
                    MAX_SUBJECT_COUNT);
                goto BadUsage;
            }
            if (rgpSubject[cSubject] = OpenSubjectCert(argv[0]))
                cSubject++;
            else {
                printf("OpenSubjectCert(%s) failed\n", argv[0]);
                goto BadUsage;
            }
        }
    }

    if (cSubject == 0) {
        printf("Missing Subject Filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    for (i = 0; i < cSubject; i++) {
        BOOL fResult;
        void *pvSubject;

        printf("=====  Subject[%d]  =====\n", i);

        if (CTL_ANY_SUBJECT_TYPE == dwSubjectType) {
            memset(&AnySubjectInfo, 0, sizeof(AnySubjectInfo));
            AnySubjectInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;

            AnySubjectInfo.SubjectIdentifier.cbData = MAX_HASH_LEN;
            if (!CertGetCertificateContextProperty(
                    rgpSubject[i],
                    CERT_SHA1_HASH_PROP_ID,
                    rgbHash,
                    &AnySubjectInfo.SubjectIdentifier.cbData) ||
                        0 == AnySubjectInfo.SubjectIdentifier.cbData) {
                printf("failed => unable to get SHA1 hash for Subject[%d]\n",
                    i);
                continue;
            }
            AnySubjectInfo.SubjectIdentifier.pbData = rgbHash;

            pvSubject = &AnySubjectInfo;
        } else
            pvSubject = (void *) rgpSubject[i];


        fResult = CertVerifyCTLUsage(
            dwCertEncodingType,
            dwSubjectType,
            pvSubject,
            &SubjectUsage,
            dwFlags,
            &VerifyPara,
            &VerifyStatus);
        if (fResult) {
            if (pCtl) {
                printf("-----  CTL  -----\n");
                DisplayCtl(pCtl, dwDisplayFlags | DISPLAY_NO_ISSUER_FLAG, 0);
                printf("\nSubject Index:: %d\n", VerifyStatus.dwCtlEntryIndex);
            } else
                printf("Failed, CertVerifyCTLUsage didn't return CTL\n");

            if (pSigner) {
                printf("-----  Signer [%d]  -----\n",
                    VerifyStatus.dwSignerIndex);
                DisplayCert(pSigner, 0);
                if (pCtl && (dwDisplayFlags & DISPLAY_VERBOSE_FLAG))
                    DisplaySignerInfo(
                        pCtl->hCryptMsg,
                        VerifyStatus.dwSignerIndex,
                        dwDisplayFlags);
                CertFreeCertificateContext(pSigner);
                pSigner = NULL;
            } else
                printf("Failed, CertVerifyCTLUsage didn't return Signer\n");

            if (pCtl) {
                CertFreeCTLContext(pCtl);
                pCtl = NULL;
            }

            if (0 != VerifyStatus.dwError)
                printf("CertVerifyCTLUsage returned dwError: 0x%x (%d)\n",
                    VerifyStatus.dwError, VerifyStatus.dwError);
            if (0 != VerifyStatus.dwFlags)
                printf("CertVerifyCTLUsage returned dwFlags: 0x%x\n",
                    VerifyStatus.dwFlags);


            if (0 != dwError)
                printf("Failed, CertVerifyCTLUsage returned Success, not the expected dwError: 0x%x (%d)\n",
                    dwError, dwError);
        } else {
            printf("CertVerifyCTLUsage:: dwError: 0x%x (%d)\n",
                VerifyStatus.dwError, VerifyStatus.dwError);
            if (dwError != VerifyStatus.dwError)
                printf("Failed, CertVerifyCTLUsage didn't return the expected dwError: 0x%x (%d)\n",
                    dwError, dwError);
        }
    }

    printf("Passed\n");
    status = 0;

CommonReturn:
    while (cSubject--)
        CertFreeCertificateContext(rgpSubject[cSubject]);
    while (VerifyPara.cCtlStore--) {
        if (!CertCloseStore(VerifyPara.rghCtlStore[VerifyPara.cCtlStore],
                 CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore(CtlStore)");
    }
    while (VerifyPara.cSignerStore--) {
        if (!CertCloseStore(VerifyPara.rghSignerStore[VerifyPara.cSignerStore],
                 CERT_CLOSE_STORE_CHECK_FLAG))
            PrintLastError("CertCloseStore(SignerStore)");
    }
        

    return status;

BadUsage:
    Usage();
    printf("Failed\n");
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tencode\tencode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tencode.cpp
//
//  Contents:   Test the encode/decode APIs. Test all the different length
//              cases.
//
//
//  Functions:  main
//
//  History:    17-Dec-96   philh   created
//              
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

#define DELTA_MORE_LENGTH    32
#define DELTA_LESS_LENGTH    8

static CRYPT_ENCODE_PARA TestEncodePara = {
    offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(TestEncodePara.pfnFree),
    TestAlloc,
    TestFree
};

static BOOL AllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded,
    IN DWORD dwFlags = 0,
    IN BOOL fIgnoreError = FALSE
    )
{
    BOOL fResult;

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        dwFlags | CRYPT_ENCODE_ALLOC_FLAG,
        &TestEncodePara,
        (void *) ppbEncoded,
        pcbEncoded
        );

    if (!fResult && !fIgnoreError) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
    }

    return fResult;
}

static CRYPT_DECODE_PARA TestDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(TestDecodePara.pfnFree),
    TestAlloc,
    TestFree
};

static void *AllocAndDecodeObject(
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    OUT DWORD       *pcbStructInfo = NULL,
    IN DWORD        dwFlags = 0
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags | CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &TestDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    if (pcbStructInfo)
        *pcbStructInfo = cbStructInfo;
    return pvStructInfo;

ErrorReturn:
    if ((DWORD_PTR) lpszStructType <= 0xFFFF)
        printf("CryptDecodeObject(StructType: %d)",
            (DWORD)(DWORD_PTR) lpszStructType);
    else
        printf("CryptDecodeObject(StructType: %s)",
            lpszStructType);
    PrintLastError("");

    pvStructInfo = NULL;
    goto CommonReturn;
}


static void TestX942OtherInfo()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_X942_OTHER_INFO pInfo = NULL;

    CRYPT_X942_OTHER_INFO X942OtherInfo;
    LPCSTR pszObjId = "1.2.33.44.55";
    BYTE rgbPubInfo[] = {0x11, 0x22, 0x33, 0x44, 0x55};

    X942OtherInfo.pszContentEncryptionObjId = (LPSTR) pszObjId;
    X942OtherInfo.rgbCounter[0] = 0x00;
    X942OtherInfo.rgbCounter[1] = 0x11;
    X942OtherInfo.rgbCounter[2] = 0x22;
    X942OtherInfo.rgbCounter[3] = 0x33;
    X942OtherInfo.rgbKeyLength[0] = 192;
    X942OtherInfo.rgbKeyLength[1] = 0x00;
    X942OtherInfo.rgbKeyLength[2] = 0x00;
    X942OtherInfo.rgbKeyLength[3] = 0x00;
    X942OtherInfo.PubInfo.cbData = sizeof(rgbPubInfo);
    X942OtherInfo.PubInfo.pbData = rgbPubInfo;

    printf("Test encode/decode X942_OTHER_INFO\n");
    if (!AllocAndEncodeObject(
            X942_OTHER_INFO,
            &X942OtherInfo,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_X942_OTHER_INFO) AllocAndDecodeObject(
            X942_OTHER_INFO,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszContentEncryptionObjId, pszObjId) ||
            pInfo->PubInfo.cbData != sizeof(rgbPubInfo) ||
            0 != memcmp(pInfo->PubInfo.pbData, rgbPubInfo,
                sizeof(rgbPubInfo)) ||
            0 != memcmp(X942OtherInfo.rgbCounter, pInfo->rgbCounter,
                sizeof(X942OtherInfo.rgbCounter)) ||
            0 != memcmp(X942OtherInfo.rgbKeyLength, pInfo->rgbKeyLength,
                sizeof(X942OtherInfo.rgbKeyLength)))
        printf("X942_OTHER_INFO failed => decode != encode input\n");


    printf("Test encode/decode X942_OTHER_INFO with No PubInfo\n");
    X942OtherInfo.PubInfo.cbData = 0;
    X942OtherInfo.PubInfo.pbData = NULL;

    TestFree(pbEncoded);
    if (!AllocAndEncodeObject(
            X942_OTHER_INFO,
            &X942OtherInfo,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    TestFree(pInfo);
    if (NULL == (pInfo = (PCRYPT_X942_OTHER_INFO) AllocAndDecodeObject(
            X942_OTHER_INFO,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszContentEncryptionObjId, pszObjId) ||
            pInfo->PubInfo.cbData != 0 ||
            0 != memcmp(X942OtherInfo.rgbCounter, pInfo->rgbCounter,
                sizeof(X942OtherInfo.rgbCounter)) ||
            0 != memcmp(X942OtherInfo.rgbKeyLength, pInfo->rgbKeyLength,
                sizeof(X942OtherInfo.rgbKeyLength)))
        printf("X942_OTHER_INFO failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}


static void TestExtensions()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbT61Encoded = NULL;
    DWORD cbT61Encoded;

    PCERT_EXTENSIONS pInfo = NULL;

    BYTE rgbExt[] = {0x1, 0x2, 0x3};
    CERT_EXTENSION Ext[2] = {
        "1.2.3.4.5", TRUE, sizeof(rgbExt), rgbExt,
        "1.2.3.6.7", FALSE, sizeof(rgbExt), rgbExt
    };
    CERT_EXTENSIONS ExtsInfo;
    CERT_NAME_VALUE T61ExtsInfo;

    ExtsInfo.cExtension = 2;
    ExtsInfo.rgExtension = Ext;

    printf("Test encode/decode X509_EXTENSIONS\n");
    if (!AllocAndEncodeObject(
            X509_EXTENSIONS,
            &ExtsInfo,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCERT_EXTENSIONS) AllocAndDecodeObject(
            X509_EXTENSIONS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->cExtension != ExtsInfo.cExtension ||
        0 != strcmp(pInfo->rgExtension[0].pszObjId,
            ExtsInfo.rgExtension[0].pszObjId))
        printf("X509_EXTENSIONS failed => decode != encode input\n");

    TestFree(pInfo);
    pInfo = NULL;

    printf("Test encode/decode T61 wrapped X509_EXTENSIONS\n");

    T61ExtsInfo.dwValueType = CERT_RDN_T61_STRING;
    T61ExtsInfo.Value.cbData = cbEncoded;
    T61ExtsInfo.Value.pbData = pbEncoded;

    if (!AllocAndEncodeObject(
            X509_ANY_STRING,
            &T61ExtsInfo,
            &pbT61Encoded,
            &cbT61Encoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCERT_EXTENSIONS) AllocAndDecodeObject(
            X509_EXTENSIONS,
            pbT61Encoded,
            cbT61Encoded
            ))) goto CommonReturn;

    if (pInfo->cExtension != ExtsInfo.cExtension ||
        0 != strcmp(pInfo->rgExtension[0].pszObjId,
            ExtsInfo.rgExtension[0].pszObjId))
        printf("T61 wrapped X509_EXTENSIONS failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pbT61Encoded)
        TestFree(pbT61Encoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestPKCSAttribute()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_ATTRIBUTE pInfo = NULL;

    CRYPT_ATTRIBUTE Attribute;
    LPCSTR pszObjId = "1.2.33.44.55";
    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    BYTE rgb1[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    CRYPT_ATTR_BLOB rgValue[2] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1
    };

    Attribute.pszObjId = (LPSTR) pszObjId;
    Attribute.cValue = 2;
    Attribute.rgValue = rgValue;

    printf("Test encode/decode PKCS_ATTRIBUTE\n");
    if (!AllocAndEncodeObject(
            PKCS_ATTRIBUTE,
            &Attribute,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_ATTRIBUTE) AllocAndDecodeObject(
            PKCS_ATTRIBUTE,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszObjId, pszObjId) ||
            pInfo->cValue != 2 ||
            pInfo->rgValue[0].cbData != sizeof(rgb0) ||
            0 != memcmp(pInfo->rgValue[0].pbData, rgb0, sizeof(rgb0)) ||
            pInfo->rgValue[1].cbData != sizeof(rgb1) ||
            0 != memcmp(pInfo->rgValue[1].pbData, rgb1, sizeof(rgb1)))
        printf("PKCS_ATTRIBUTE failed => decode != encode input\n");


    printf("Test encode/decode PKCS_ATTRIBUTE with empty OID\n");
    TestFree(pbEncoded);
    Attribute.pszObjId = "";
    if (AllocAndEncodeObject(
            PKCS_ATTRIBUTE,
            &Attribute,
            &pbEncoded,
            &cbEncoded,
            0,                  // dwFlags
            TRUE))              // fIgnoreError
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        printf("  Got LastError: 0x%x (%d)\n",  dwErr, dwErr);
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestPKCSAttributes()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_ATTRIBUTES pInfo = NULL;
    DWORD i;

#define ATTRIBUTE_CNT   3
    CRYPT_ATTRIBUTES Attributes;
    CRYPT_ATTRIBUTE rgAttribute[ATTRIBUTE_CNT];
    LPCSTR pszObjId = "1.2.33.44.55";
    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    BYTE rgb1[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    CRYPT_ATTR_BLOB rgValue[2] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1
    };

    for (i = 0; i < ATTRIBUTE_CNT; i++) {
        rgAttribute[i].pszObjId = (LPSTR) pszObjId;
        rgAttribute[i].cValue = 2;
        rgAttribute[i].rgValue = rgValue;
    }

    Attributes.cAttr = ATTRIBUTE_CNT;
    Attributes.rgAttr = rgAttribute;

    printf("Test encode/decode PKCS_ATTRIBUTES\n");
    if (!AllocAndEncodeObject(
            PKCS_ATTRIBUTES,
            &Attributes,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_ATTRIBUTES) AllocAndDecodeObject(
            PKCS_ATTRIBUTES,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    // Note, ATTRIBUTES is a SET OF. Entries are re-ordered
    if (pInfo->cAttr != ATTRIBUTE_CNT)
        printf("PKCS_ATTRIBUTES failed => decode != encode attr count\n");
    else {
        for (i = 0; i < ATTRIBUTE_CNT; i++) {
            PCRYPT_ATTRIBUTE pAttr = &pInfo->rgAttr[i];
            if (0 != strcmp(pAttr->pszObjId, pszObjId) ||
                    pAttr->cValue != 2 ||
                    pAttr->rgValue[0].cbData != sizeof(rgb0) ||
                    0 != memcmp(pAttr->rgValue[0].pbData, rgb0, sizeof(rgb0)) ||
                    pAttr->rgValue[1].cbData != sizeof(rgb1) ||
                    0 != memcmp(pAttr->rgValue[1].pbData, rgb1, sizeof(rgb1))) {
                printf("PKCS_ATTRIBUTES failed => decode != encode input\n");
                break;
            }
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestContentInfoSequenceOfAny()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY pInfo = NULL;

    CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY SeqOfAny;
    BYTE rgb0[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    BYTE rgb1[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    CRYPT_DER_BLOB rgValue[2] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1
    };

    SeqOfAny.pszObjId = szOID_NETSCAPE_CERT_SEQUENCE;
    SeqOfAny.cValue = 2;
    SeqOfAny.rgValue = rgValue;


    printf("Test encode/decode PKCS_CONTENT_INFO_SEQUENCE_OF_ANY\n");
    if (!AllocAndEncodeObject(
            PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
            &SeqOfAny,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY) AllocAndDecodeObject(
        PKCS_CONTENT_INFO_SEQUENCE_OF_ANY,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszObjId, szOID_NETSCAPE_CERT_SEQUENCE) ||
            pInfo->cValue != 2 ||
            pInfo->rgValue[0].cbData != sizeof(rgb0) ||
            0 != memcmp(pInfo->rgValue[0].pbData, rgb0, sizeof(rgb0)) ||
            pInfo->rgValue[1].cbData != sizeof(rgb1) ||
            0 != memcmp(pInfo->rgValue[1].pbData, rgb1, sizeof(rgb1)))
        printf("PKCS_CONTENT_INFO_SEQUENCE_OF_ANY failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestSequenceOfAny()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_SEQUENCE_OF_ANY pInfo = NULL;

    CRYPT_SEQUENCE_OF_ANY SeqOfAny;
    BYTE rgb0[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    BYTE rgb1[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    CRYPT_DER_BLOB rgValue[2] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1
    };

    SeqOfAny.cValue = 2;
    SeqOfAny.rgValue = rgValue;


    printf("Test encode/decode X509_SEQUENCE_OF_ANY\n");
    if (!AllocAndEncodeObject(
            X509_SEQUENCE_OF_ANY,
            &SeqOfAny,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCRYPT_SEQUENCE_OF_ANY) AllocAndDecodeObject(
        X509_SEQUENCE_OF_ANY,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (pInfo->cValue != 2 ||
            pInfo->rgValue[0].cbData != sizeof(rgb0) ||
            0 != memcmp(pInfo->rgValue[0].pbData, rgb0, sizeof(rgb0)) ||
            pInfo->rgValue[1].cbData != sizeof(rgb1) ||
            0 != memcmp(pInfo->rgValue[1].pbData, rgb1, sizeof(rgb1)))
        printf("X509_SEQUENCE_OF_ANY failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestInteger(
        int iEncode
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    int iDecode = 0;
    DWORD cbInfo;

    printf("Test encode/decode X509_INTEGER: 0x%x (%d)\n", iEncode, iEncode);

    if (!AllocAndEncodeObject(
            X509_INTEGER,
            &iEncode,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    cbInfo = sizeof(iDecode);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_INTEGER,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &iDecode,
            &cbInfo
            )) {
        PrintLastError("CryptDecodeObject(X509_INTEGER)");
        goto CommonReturn;
    }

    if (cbInfo != sizeof(iDecode))
        printf("X509_INTEGER failed => unexpected decode length\n");

    if (iEncode != iDecode)
        printf("X509_INTEGER failed => decoded output (%d) != encode input\n",
            iDecode);

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
}

static void TestInteger()
{
    TestInteger(0);
    TestInteger(0x12345678);
    TestInteger(-1234);
    TestInteger(123);
}

static void TestMultiByteInteger(
    BYTE *pb,
    DWORD cb
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_INTEGER_BLOB pInfo = NULL;

    CRYPT_INTEGER_BLOB MultiByteInteger = {cb, pb };

    printf("Test encode/decode X509_MULTI_BYTE_INTEGER\n");
    PrintBytes("  ", pb, cb);
    if (!AllocAndEncodeObject(
            X509_MULTI_BYTE_INTEGER,
            &MultiByteInteger,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_INTEGER_BLOB) AllocAndDecodeObject(
            X509_MULTI_BYTE_INTEGER,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (!CertCompareIntegerBlob(pInfo, &MultiByteInteger))
        printf("X509_MULTI_BYTE_INTEGER failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestMultiByteInteger()
{
    BYTE rgb1[] = {0x11, 0x22, 0x33, 0x44, 0x55};
    BYTE rgb2[] = {0x11, 0x22, 0x33, 0x44, 0x55, 0xFF, 0x00};
    BYTE rgb3[] = {0x11, 0x22, 0x33, 0x44, 0x55, 0xFF, 0xFF};
    BYTE rgb4[] = {0x11, 0x22, 0x33, 0x44, 0x80, 0xFF, 0xFF};
    BYTE rgb5[] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x00};
    BYTE rgb6[] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x00, 0x00, 0x00};

    TestMultiByteInteger(rgb1, sizeof(rgb1));
    TestMultiByteInteger(rgb2, sizeof(rgb2));
    TestMultiByteInteger(rgb3, sizeof(rgb2));
    TestMultiByteInteger(rgb4, sizeof(rgb2));
    TestMultiByteInteger(rgb5, sizeof(rgb2));
    TestMultiByteInteger(rgb6, sizeof(rgb2));
}

static const BYTE rgbUnusedAndMask[8] =
    {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

static void TestBits(
    PCRYPT_BIT_BLOB pBits
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_BIT_BLOB pInfo = NULL;

    printf("Test encode/decode X509_BITS(cb:%d, cUnused: %d)\n",
        pBits->cbData, pBits->cUnusedBits);
    PrintBytes("  ", pBits->pbData, pBits->cbData);
    if (!AllocAndEncodeObject(
            X509_BITS,
            pBits,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_BIT_BLOB) AllocAndDecodeObject(
            X509_BITS,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (pInfo->cbData != pBits->cbData ||
            pInfo->cUnusedBits != pBits->cUnusedBits)
        printf("X509_BITS failed => decode != encode (cbData or cUnusedBits)\n");
    else {
        DWORD cbData = pInfo->cbData;

        if (cbData > 1) {
            if (0 != memcmp(pInfo->pbData, pBits->pbData, cbData - 1))
                printf("X509_BITS failed => decode != encode input\n");
        }

        if (cbData > 0) {
            if ((pBits->pbData[cbData - 1] &
                        rgbUnusedAndMask[pInfo->cUnusedBits]) !=
                    pInfo->pbData[cbData - 1])
                printf("X509_BITS failed => decode != encode (last byte)\n");
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestBits()
{
    BYTE rgb1[] = {0xFF, 0x00, 0x00, 0x00};
    BYTE rgb2[] = {0x00, 0xFE, 0xFC};
    CRYPT_BIT_BLOB Bits;

    memset(&Bits, 0, sizeof(Bits));
    TestBits(&Bits);

    Bits.pbData = rgb1;
    TestBits(&Bits);
    Bits.cbData = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 7;
    TestBits(&Bits);

    Bits.cbData = sizeof(rgb1);
    Bits.cUnusedBits = 0;
    TestBits(&Bits);
    Bits.cUnusedBits = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 7;
    TestBits(&Bits);

    Bits.pbData = rgb2;
    Bits.cUnusedBits = 0;
    Bits.cbData = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 7;
    TestBits(&Bits);

    Bits.cbData = sizeof(rgb2);
    Bits.cUnusedBits = 0;
    TestBits(&Bits);
    Bits.cUnusedBits = 1;
    TestBits(&Bits);
    Bits.cUnusedBits = 7;
    TestBits(&Bits);
}


static void TestBitsWithoutTrailingZeroes(
    PCRYPT_BIT_BLOB pBits,
    DWORD cbData,
    DWORD cUnusedBits
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_BIT_BLOB pInfo = NULL;

    printf("Test encode/decode X509_BITS_WO_ZEROES(cb:%d, cUnused: %d) Expected(cb:%d, cUnused:%d)\n",
        pBits->cbData, pBits->cUnusedBits, cbData, cUnusedBits);
    PrintBytes("    Input:: ", pBits->pbData, pBits->cbData);
    if (!AllocAndEncodeObject(
            X509_BITS_WITHOUT_TRAILING_ZEROES,
            pBits,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_BIT_BLOB) AllocAndDecodeObject(
            X509_BITS_WITHOUT_TRAILING_ZEROES,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;
    PrintBytes("  Encoded:: ", pbEncoded, cbEncoded);

    if (pInfo->cbData != cbData ||
            pInfo->cUnusedBits != cUnusedBits)
        printf("X509_BITS_WO_ZEROES failed => decode != encode (cbData or cUnusedBits)\n");
    else {
        if (cbData > 1) {
            if (0 != memcmp(pInfo->pbData, pBits->pbData, cbData - 1))
                printf("X509_BITS_WO_ZEROES failed => decode != encode input\n");
        }

        if (cbData > 0) {
            if ((pBits->pbData[cbData - 1] &
                        rgbUnusedAndMask[cUnusedBits]) !=
                    pInfo->pbData[cbData - 1])
                printf("X509_BITS_WO_ZEROES failed => decode != encode (last byte)\n");
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestBitsWithoutTrailingZeroes()
{
    BYTE rgb1[] = {0xFF, 0x00, 0x00, 0x00};
    BYTE rgb2[] = {0x00, 0xFE, 0xFC};
    BYTE rgb3[] = {0x00, 0x18, 0x00, 0x20};
    CRYPT_BIT_BLOB Bits;
    int i;
    BYTE b;

    memset(&Bits, 0, sizeof(Bits));
    TestBitsWithoutTrailingZeroes(&Bits, 0,0);

    Bits.pbData = rgb1;
    TestBitsWithoutTrailingZeroes(&Bits, 0,0);
    Bits.cbData = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 1,0);
    Bits.cUnusedBits = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 1,1);
    Bits.cUnusedBits = 7;
    TestBitsWithoutTrailingZeroes(&Bits, 1,7);

    Bits.cbData = sizeof(rgb1);
    Bits.cUnusedBits = 0;
    TestBitsWithoutTrailingZeroes(&Bits, 1,0);
    Bits.cUnusedBits = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 1,0);
    Bits.cUnusedBits = 7;
    TestBitsWithoutTrailingZeroes(&Bits, 1,0);

    Bits.pbData = rgb2;
    Bits.cUnusedBits = 0;
    Bits.cbData = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 0,0);
    Bits.cUnusedBits = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 0,0);
    Bits.cUnusedBits = 7;
    TestBitsWithoutTrailingZeroes(&Bits, 0,0);

    Bits.cbData = sizeof(rgb2);
    Bits.cUnusedBits = 0;
    TestBitsWithoutTrailingZeroes(&Bits, 3,2);
    Bits.cUnusedBits = 1;
    TestBitsWithoutTrailingZeroes(&Bits, 3,2);
    Bits.cUnusedBits = 2;
    TestBitsWithoutTrailingZeroes(&Bits, 3,2);
    Bits.cUnusedBits = 4;
    TestBitsWithoutTrailingZeroes(&Bits, 3,4);
    Bits.cUnusedBits = 7;
    TestBitsWithoutTrailingZeroes(&Bits, 3,7);

    Bits.pbData = rgb3;
    Bits.cbData = sizeof(rgb3);
    Bits.cUnusedBits = 0;
    TestBitsWithoutTrailingZeroes(&Bits, 4,5);
    Bits.cUnusedBits = 3;
    TestBitsWithoutTrailingZeroes(&Bits, 4,5);
    Bits.cUnusedBits = 4;
    TestBitsWithoutTrailingZeroes(&Bits, 4,5);
    Bits.cUnusedBits = 5;
    TestBitsWithoutTrailingZeroes(&Bits, 4,5);
    Bits.cUnusedBits = 6;
    TestBitsWithoutTrailingZeroes(&Bits, 2,3);
    Bits.cUnusedBits = 7;
    TestBitsWithoutTrailingZeroes(&Bits, 2,3);

    Bits.pbData = &b;
    Bits.cbData = 1;
    for (i = 0; i <= 7; i++) {
        b = 1 << i;
        Bits.cUnusedBits = 0;
        TestBitsWithoutTrailingZeroes(&Bits, 1,i);
        Bits.cUnusedBits = i;
        TestBitsWithoutTrailingZeroes(&Bits, 1,i);
    }
}

static void TestOID(
    IN LPCSTR pszObjId
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCRYPT_ATTRIBUTE pInfo = NULL;

    CRYPT_ATTRIBUTE Attribute;
    memset(&Attribute, 0, sizeof(Attribute));

    Attribute.pszObjId = (LPSTR) pszObjId;
    printf("Test encode/decode OID: %s\n", pszObjId);
    if (!AllocAndEncodeObject(
            PKCS_ATTRIBUTE,
            &Attribute,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo = (PCRYPT_ATTRIBUTE) AllocAndDecodeObject(
            PKCS_ATTRIBUTE,
            pbEncoded,
            cbEncoded
            ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszObjId, pszObjId))
        printf("OID failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestOID()
{
    TestOID("0.1");
    TestOID("0.9.2342.19200300.100.1.25");
    TestOID("1.2.3.111111111144444444444");
    TestOID("1.2.3.111111111144444444444.55555555555555555.666666666666666");
    TestOID("1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20");
}


static void TestUnicodeAnyString(
        DWORD dwValueType,
        LPCWSTR pwszValue,
        DWORD dwExpectedErr,
        DWORD dwExpectedErrLocation,
        DWORD dwFlags = 0
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_NAME_VALUE pInfo = NULL;

    CERT_NAME_VALUE NameValue;

    memset(&NameValue, 0, sizeof(NameValue));
    NameValue.dwValueType = dwValueType;
    NameValue.Value.pbData = (BYTE *) pwszValue;

    if (dwExpectedErr ) {
        printf("Test encode X509_UNICODE_ANY_STRING:: dwValueType: %d 0x%x Expected Err: 0x%x Location: %d\n",
            dwValueType, dwValueType, dwExpectedErr, dwExpectedErrLocation);
        if (CryptEncodeObject(
                dwCertEncodingType,
                X509_UNICODE_ANY_STRING,
                &NameValue,
                NULL,               // pbEncoded
                &cbEncoded
                ))
            printf("  failed => expected error\n");
        else {
            DWORD dwErr = GetLastError();
            if (dwErr != dwExpectedErr)
                printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                    dwExpectedErr, dwExpectedErr, dwErr, dwErr);
            if (dwExpectedErrLocation != cbEncoded)
                printf("  ErrLocation failed => expected: %d, got: %d\n", 
                    dwExpectedErrLocation, cbEncoded);
        }
    }

    printf("Test alloc encode/decode X509_UNICODE_ANY_STRING:: dwValueType: %d 0x%x string: %S\n",
        dwValueType, dwValueType, pwszValue);
    if (!AllocAndEncodeObject(
            X509_UNICODE_ANY_STRING,
            &NameValue,
            &pbEncoded,
            &cbEncoded,
            dwFlags,
            dwExpectedErr != 0   // fIgnoreError
            )) {
        if (dwExpectedErr) {
            DWORD dwErr = GetLastError();
            if (dwErr != dwExpectedErr)
                printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                    dwExpectedErr, dwExpectedErr, dwErr, dwErr);
            if (dwExpectedErrLocation != cbEncoded)
                printf("  ErrLocation failed => expected: %d, got: %d\n", 
                    dwExpectedErrLocation, cbEncoded);
        }
        goto CommonReturn;
    } else if (dwExpectedErr)
        printf("  failed => expected error\n");

    if (NULL == (pInfo = (PCERT_NAME_VALUE) AllocAndDecodeObject(
            X509_UNICODE_ANY_STRING,
            pbEncoded,
            cbEncoded,
            NULL,
            dwFlags
            ))) goto CommonReturn;

    if (wcslen(pwszValue) != wcslen((LPWSTR) pInfo->Value.pbData) ||
            wcslen(pwszValue) * 2 != pInfo->Value.cbData ||
            0 != wcscmp(pwszValue, (LPWSTR) pInfo->Value.pbData))
        printf("X509_UNICODE_ANY_STRING failed => decoded output (%S) != encode input\n",
            (LPWSTR) pInfo->Value.pbData);

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestUnicodeAnyString(
        DWORD dwValueType,
        PCRYPT_DATA_BLOB pDataBlob,
        DWORD dwExpectedErr
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    DWORD cbInfo;

    CERT_NAME_VALUE NameValue;

    memset(&NameValue, 0, sizeof(NameValue));
    NameValue.dwValueType = dwValueType;
    NameValue.Value.pbData = pDataBlob->pbData;
    NameValue.Value.cbData = pDataBlob->cbData;

    printf("Test encode/decode X509_UNICODE_ANY_STRING:: dwValueType: %d Expected Err: 0x%x\n",
        dwValueType, dwExpectedErr);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_UNICODE_ANY_STRING,
            &NameValue,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  Encode failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (dwErr != dwExpectedErr)
            printf("  Encode LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                dwExpectedErr, dwExpectedErr, dwErr, dwErr);
    }

    if (!AllocAndEncodeObject(
            X509_ANY_STRING,
            &NameValue,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (CryptDecodeObject(
            dwCertEncodingType,
            X509_UNICODE_ANY_STRING,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            NULL,               // pInfo
            &cbInfo
            ))
        printf("  Decode failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (dwErr != dwExpectedErr)
            printf("  Decode LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                dwExpectedErr, dwExpectedErr, dwErr, dwErr);
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
}

static void TestUnicodeAnyString()
{
    DWORD dwValueType;
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x80, 0x33, 0x00};

    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // Encoded INTEGER
    CRYPT_DATA_BLOB EncodedBlob = {sizeof(rgb0), rgb0};

    BYTE rgb1[] = {0, 0x11, 0x22, 0x33, 0x44, 0x55};
    CRYPT_DATA_BLOB OctetString = {sizeof(rgb1), rgb1};

    TestUnicodeAnyString(CERT_RDN_ENCODED_BLOB, &EncodedBlob,
        (DWORD) CRYPT_E_NOT_CHAR_STRING);
    TestUnicodeAnyString(CERT_RDN_OCTET_STRING, &OctetString,
        (DWORD) CRYPT_E_NOT_CHAR_STRING);

    TestUnicodeAnyString(CERT_RDN_NUMERIC_STRING,
        L"0123456789 ",
        0, 0);

    for (dwValueType = CERT_RDN_PRINTABLE_STRING;
                        dwValueType <= CERT_RDN_BMP_STRING; dwValueType++)
        TestUnicodeAnyString(dwValueType,
            L"UNICODE string to be encoded",
            0, 0);

    TestUnicodeAnyString(CERT_RDN_ANY_TYPE, L"InvalidArg",
        (DWORD) CRYPT_E_NOT_CHAR_STRING, 0);

    TestUnicodeAnyString(CERT_RDN_NUMERIC_STRING,
//        0123456789012345678901234567890
        L"0123456789a013",
        (DWORD) CRYPT_E_INVALID_NUMERIC_STRING, 10);
    TestUnicodeAnyString(CERT_RDN_PRINTABLE_STRING,
//        0123456789012345678901234567890
        L"Invalid printable ### az AZ 09 \'()+,-./:=?",
        (DWORD) CRYPT_E_INVALID_PRINTABLE_STRING, 18);

    TestUnicodeAnyString(CERT_RDN_DISABLE_CHECK_TYPE_FLAG |
        CERT_RDN_PRINTABLE_STRING,
//        0123456789012345678901234567890
        L"Invalid printable ### az AZ 09 \'()+,-./:=?",
        0, 0);

    TestUnicodeAnyString(CERT_RDN_PRINTABLE_STRING,
//        0123456789012345678901234567890
        L"Invalid printable ### az AZ 09 \'()+,-./:=?",
        0, 0,
        CRYPT_UNICODE_NAME_ENCODE_DISABLE_CHECK_TYPE_FLAG);

    TestUnicodeAnyString(CERT_RDN_T61_STRING,
//        0123456789012345678901234567890
        L"T61 ### az AZ 09 \'()+,-./:=?",
        0, 0, 0);

    TestUnicodeAnyString(CERT_RDN_T61_STRING,
//        0123456789012345678901234567890
        L"T61 ### az AZ 09 \'()+,-./:=?",
        0, 0, CERT_RDN_DISABLE_IE4_UTF8_FLAG);

    TestUnicodeAnyString(CERT_RDN_IA5_STRING,
        rgwBadIA5,
        (DWORD) CRYPT_E_INVALID_IA5_STRING, 3);

}

static void TestUniversalString()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_NAME_VALUE pInfo = NULL;

    CERT_NAME_VALUE NameValue;

    DWORD rgdwUniversal[] = {
        0x00ffff,
        0x110000,
        0x010000,
        0xffffffff,
        0x110001,
        0x10FFFF,
        };

    LPWSTR pwszExpectedUniversal =
        L"\xffff"
        L"\xfffd"
        L"\xd800\xdc00"
        L"\xfffd"
        L"\xfffd"
        L"\xdbff\xdfff"
        ;

    TestUnicodeAnyString(CERT_RDN_UNIVERSAL_STRING,
        L"SPECIAL UNIVERSAL with Surrogate Pairs: "
        L"\xd800\xdc00\xdbff\xdfff"
        L"\xdbfe\xdc03\xd801\xdfcf"
        L"\xd801\x0081\xdc01\xdc02"
        L"\xd805\xd806\xd807\xdc04"
        L"\xd802\xd803\xfffe\xd804",
        0, 0, 0);


    // Encode a universal string containing characters > 0x10FFFF. These
    // Should be converted to 0xFFFD

    memset(&NameValue, 0, sizeof(NameValue));
    NameValue.dwValueType = CERT_RDN_UNIVERSAL_STRING;
    NameValue.Value.pbData = (BYTE *) rgdwUniversal;
    NameValue.Value.cbData = sizeof(rgdwUniversal);

    if (!AllocAndEncodeObject(
            X509_ANY_STRING,
            &NameValue,
            &pbEncoded,
            &cbEncoded
            )) {
        goto CommonReturn;
    }

    if (NULL == (pInfo = (PCERT_NAME_VALUE) AllocAndDecodeObject(
            X509_UNICODE_ANY_STRING,
            pbEncoded,
            cbEncoded,
            NULL
            ))) goto CommonReturn;

    if (wcslen(pwszExpectedUniversal) != wcslen((LPWSTR) pInfo->Value.pbData) ||
            wcslen(pwszExpectedUniversal) * 2 != pInfo->Value.cbData ||
            0 != wcscmp(pwszExpectedUniversal, (LPWSTR) pInfo->Value.pbData))
        printf("UniversalString encode/decode failed\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestChoiceOfTime(
        FILETIME *pftEncode
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    FILETIME ftDecode;
    DWORD cbInfo;

    printf("Test encode/decode X509_CHOICE_OF_TIME: %s\n",
        FileTimeText(pftEncode));
    if (!AllocAndEncodeObject(
            X509_CHOICE_OF_TIME,
            pftEncode,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    cbInfo = sizeof(ftDecode);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_CHOICE_OF_TIME,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &ftDecode,
            &cbInfo
            )) {
        PrintLastError("CryptDecodeObject(X509_CHOICE_OF_TIME)");
        goto CommonReturn;
    }

    if (cbInfo != sizeof(ftDecode))
        printf("X509_CHOICE_OF_TIME failed => unexpected decode length\n");

    if (0 != memcmp(pftEncode, &ftDecode, sizeof(ftDecode)))
        printf("X509_CHOICE_OF_TIME failed => decode (%s) != encode input\n",
            FileTimeText(&ftDecode));

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
}

static void TestChoiceOfTime()
{
    FILETIME ft;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = 2000;
    t.wMonth  = 1;
    t.wDay    = 2;
    t.wHour   = 3;
    t.wMinute = 4;
    t.wSecond = 5;

    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestChoiceOfTime(&ft);

    t.wYear   = 1900;
    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestChoiceOfTime(&ft);

    t.wYear   = 2080;
    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestChoiceOfTime(&ft);
}

static void TestUtcTime(
        FILETIME *pftEncode
        )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    FILETIME ftDecode;
    DWORD cbInfo;

    printf("Test encode/decode PKCS_UTC_TIME: %s\n",
        FileTimeText(pftEncode));
    if (!AllocAndEncodeObject(
            PKCS_UTC_TIME,
            pftEncode,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    cbInfo = sizeof(ftDecode);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            PKCS_UTC_TIME,
            pbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &ftDecode,
            &cbInfo
            )) {
        PrintLastError("CryptDecodeObject(PKCS_UTC_TIME)");
        goto CommonReturn;
    }

    if (cbInfo != sizeof(ftDecode))
        printf("PKCS_UTC_TIME failed => unexpected decode length\n");

    if (0 != memcmp(pftEncode, &ftDecode, sizeof(ftDecode)))
        printf("PKCS_UTC_TIME failed => decode (%s) != encode input\n",
            FileTimeText(&ftDecode));

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
}

static void TestUtcTime()
{
    FILETIME ft;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = 1950;
    t.wMonth  = 1;
    t.wDay    = 2;
    t.wHour   = 3;
    t.wMinute = 4;
    t.wSecond = 5;

    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestUtcTime(&ft);

    t.wYear   = 2049;
    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestUtcTime(&ft);

    t.wMonth  = 1;
    t.wDay    = 1;
    t.wHour   = 0;
    t.wMinute = 0;
    t.wSecond = 0;

    if (!SystemTimeToFileTime(&t, &ft)) {
        PrintLastError("SystemTimeToFileTime");
        return;
    }
    TestUtcTime(&ft);
}

static void TestBadAltName(
        PCERT_ALT_NAME_INFO pInfo,
        DWORD dwEntryIndex,
        DWORD dwValueIndex
        )
{
    DWORD cbEncoded;

    printf("Test encode X509_ALTERNATE_NAME:: Bad Entry: %d Value: %d\n",
        dwEntryIndex, dwValueIndex);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_ALTERNATE_NAME,
            pInfo,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_INVALID_IA5_STRING != dwErr)
            printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                CRYPT_E_INVALID_IA5_STRING, CRYPT_E_INVALID_IA5_STRING,
                dwErr, dwErr);
        if (dwEntryIndex != GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded))
            printf("  EntryIndex failed => expected: %d, got: %d\n", 
                dwEntryIndex, GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded));
        if (dwValueIndex != GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded))
            printf("  ValueIndex failed => expected: %d, got: %d\n", 
                dwValueIndex, GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded));
    }
}

static void TestBadAltName()
{
    CERT_ALT_NAME_INFO AltNameInfo;
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x33, 0x80, 0x35, 0x00};

#define ALT_NAME_ENTRY_CNT  4
    CERT_ALT_NAME_ENTRY rgAltNameEntry[ALT_NAME_ENTRY_CNT];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAltNameEntry[0].pwszRfc822Name = L"RFC822";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = L"URL string";
    rgAltNameEntry[2].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[2].pwszURL = rgwBadIA5;
    rgAltNameEntry[3].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAltNameEntry[3].pwszRfc822Name = L"RFC822";

    AltNameInfo.cAltEntry = ALT_NAME_ENTRY_CNT;
    AltNameInfo.rgAltEntry = rgAltNameEntry;
    TestBadAltName(&AltNameInfo, 2, 4);
}

static void TestBadAuthorityInfoAccess(
        PCERT_AUTHORITY_INFO_ACCESS pInfo,
        DWORD dwEntryIndex,
        DWORD dwValueIndex
        )
{
    DWORD cbEncoded;

    printf("Test encode X509_AUTHORITY_INFO_ACCESS:: Bad Entry: %d Value: %d\n",
        dwEntryIndex, dwValueIndex);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_AUTHORITY_INFO_ACCESS,
            pInfo,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_INVALID_IA5_STRING != dwErr)
            printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                CRYPT_E_INVALID_IA5_STRING, CRYPT_E_INVALID_IA5_STRING,
                dwErr, dwErr);
        if (dwEntryIndex != GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded))
            printf("  EntryIndex failed => expected: %d, got: %d\n", 
                dwEntryIndex, GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded));
        if (dwValueIndex != GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded))
            printf("  ValueIndex failed => expected: %d, got: %d\n", 
                dwValueIndex, GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded));
    }
}

static void TestBadAuthorityInfoAccess()
{
    CERT_AUTHORITY_INFO_ACCESS AuthorityInfoAccess;
    CERT_ACCESS_DESCRIPTION rgAccess[5];
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x80, 0x37, 0x00};

    rgAccess[0].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[0].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[0].AccessLocation.pwszURL = L"URL to the stars";
    rgAccess[1].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[1].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[1].AccessLocation.pwszURL = L"URL to the stars";
    rgAccess[2].pszAccessMethod = szOID_PKIX_CA_ISSUERS;
    rgAccess[2].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAccess[2].AccessLocation.pwszRfc822Name = L"issuer@mail.com";

    rgAccess[3].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[3].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[3].AccessLocation.pwszURL = rgwBadIA5;

    rgAccess[4].pszAccessMethod = szOID_PKIX_OCSP;
    rgAccess[4].AccessLocation.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAccess[4].AccessLocation.pwszURL = L"URL to the POLICY";

    AuthorityInfoAccess.cAccDescr = 5;
    AuthorityInfoAccess.rgAccDescr = rgAccess;
    TestBadAuthorityInfoAccess(&AuthorityInfoAccess, 3, 6);
}

static void TestBadAuthorityKeyId2(
        PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        DWORD dwEntryIndex,
        DWORD dwValueIndex
        )
{
    DWORD cbEncoded;

    printf("Test encode X509_AUTHORITY_KEY_ID2:: Bad Entry: %d Value: %d\n",
        dwEntryIndex, dwValueIndex);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_AUTHORITY_KEY_ID2,
            pInfo,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_INVALID_IA5_STRING != dwErr)
            printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                CRYPT_E_INVALID_IA5_STRING, CRYPT_E_INVALID_IA5_STRING,
                dwErr, dwErr);
        if (dwEntryIndex != GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded))
            printf("  EntryIndex failed => expected: %d, got: %d\n", 
                dwEntryIndex, GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded));
        if (dwValueIndex != GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded))
            printf("  ValueIndex failed => expected: %d, got: %d\n", 
                dwValueIndex, GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded));
    }
}

static void TestBadAuthorityKeyId2()
{
    CERT_AUTHORITY_KEY_ID2_INFO KeyId2Info;
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x33, 0x80, 0x35, 0x00};

#define KEY_ID_ALT_NAME_ENTRY_CNT  2
    CERT_ALT_NAME_ENTRY rgAltNameEntry[KEY_ID_ALT_NAME_ENTRY_CNT];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAltNameEntry[0].pwszRfc822Name = L"RFC822";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = rgwBadIA5;

    memset(&KeyId2Info, 0, sizeof(KeyId2Info));
    KeyId2Info.AuthorityCertIssuer.cAltEntry = KEY_ID_ALT_NAME_ENTRY_CNT;
    KeyId2Info.AuthorityCertIssuer.rgAltEntry = rgAltNameEntry;
    TestBadAuthorityKeyId2(&KeyId2Info, 1, 4);
}


static void TestBadNameConstraints(
        PCERT_NAME_CONSTRAINTS_INFO pInfo,
        DWORD dwEntryIndex,
        DWORD dwValueIndex,
        BOOL fExcludedSubtree
        )
{
    DWORD cbEncoded;

    printf("Test encode NAME_CONSTRAINTS:: Bad Entry: %d Value: %d fExcluded: %d\n",
        dwEntryIndex, dwValueIndex, fExcludedSubtree);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME_CONSTRAINTS,
            pInfo,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_INVALID_IA5_STRING != dwErr)
            printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                CRYPT_E_INVALID_IA5_STRING, CRYPT_E_INVALID_IA5_STRING,
                dwErr, dwErr);
        if (dwEntryIndex != GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded))
            printf("  EntryIndex failed => expected: %d, got: %d\n", 
                dwEntryIndex, GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded));
        if (dwValueIndex != GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded))
            printf("  ValueIndex failed => expected: %d, got: %d\n", 
                dwValueIndex, GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded));
        if (fExcludedSubtree != IS_CERT_EXCLUDED_SUBTREE(cbEncoded))
            printf("  fExcludedSubtree failed => expected: %d, got: %d\n", 
                fExcludedSubtree, IS_CERT_EXCLUDED_SUBTREE(cbEncoded));
    }
}

static void TestBadNameConstraints()
{
    CERT_NAME_CONSTRAINTS_INFO Info;
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x33, 0x80, 0x35, 0x00};

#define NAME_CONSTRAINTS_SUBTREE_CNT  2
    CERT_GENERAL_SUBTREE rgSubtree[NAME_CONSTRAINTS_SUBTREE_CNT];

    memset(rgSubtree, 0, sizeof(rgSubtree));
    rgSubtree[0].Base.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgSubtree[0].Base.pwszRfc822Name = L"RFC822";
    rgSubtree[1].Base.dwAltNameChoice = CERT_ALT_NAME_URL;
    rgSubtree[1].Base.pwszURL = rgwBadIA5;

    memset(&Info, 0, sizeof(Info));
    Info.cPermittedSubtree = NAME_CONSTRAINTS_SUBTREE_CNT;
    Info.rgPermittedSubtree = rgSubtree;
    TestBadNameConstraints(&Info, 1, 4, FALSE);

    memset(&Info, 0, sizeof(Info));
    Info.cExcludedSubtree = NAME_CONSTRAINTS_SUBTREE_CNT;
    Info.rgExcludedSubtree = rgSubtree;
    TestBadNameConstraints(&Info, 1, 4, TRUE);
}


static void TestBadIssuingDistPoint(
        PCRL_ISSUING_DIST_POINT pInfo,
        DWORD dwEntryIndex,
        DWORD dwValueIndex
        )
{
    DWORD cbEncoded;

    printf("Test encode ISSUING_DIST_POINT:: Bad Entry: %d Value: %d\n",
        dwEntryIndex, dwValueIndex);
    if (CryptEncodeObject(
            dwCertEncodingType,
            X509_ISSUING_DIST_POINT,
            pInfo,
            NULL,               // pbEncoded
            &cbEncoded
            ))
        printf("  failed => expected error\n");
    else {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_INVALID_IA5_STRING != dwErr)
            printf("  LastError failed => expected: 0x%x (%d), got: 0x%x (%d)\n", 
                CRYPT_E_INVALID_IA5_STRING, CRYPT_E_INVALID_IA5_STRING,
                dwErr, dwErr);
        if (dwEntryIndex != GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded))
            printf("  EntryIndex failed => expected: %d, got: %d\n", 
                dwEntryIndex, GET_CERT_ALT_NAME_ENTRY_ERR_INDEX(cbEncoded));
        if (dwValueIndex != GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded))
            printf("  ValueIndex failed => expected: %d, got: %d\n", 
                dwValueIndex, GET_CERT_ALT_NAME_VALUE_ERR_INDEX(cbEncoded));
    }
}

static void TestBadIssuingDistPoint()
{
    CRL_ISSUING_DIST_POINT Info;
    WORD rgwBadIA5[] = {0x30, 0x31, 0x32, 0x33, 0x80, 0x35, 0x00};

#define IDP_ALT_NAME_ENTRY_CNT  2
    CERT_ALT_NAME_ENTRY rgAltNameEntry[IDP_ALT_NAME_ENTRY_CNT];

    rgAltNameEntry[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
    rgAltNameEntry[0].pwszRfc822Name = L"RFC822";
    rgAltNameEntry[1].dwAltNameChoice = CERT_ALT_NAME_URL;
    rgAltNameEntry[1].pwszURL = rgwBadIA5;

    memset(&Info, 0, sizeof(Info));
    Info.DistPointName.dwDistPointNameChoice = CRL_DIST_POINT_FULL_NAME;
    Info.DistPointName.FullName.cAltEntry = IDP_ALT_NAME_ENTRY_CNT;
    Info.DistPointName.FullName.rgAltEntry = rgAltNameEntry;
    TestBadIssuingDistPoint(&Info, 1, 4);
}

static void TestCryptExportPublicKeyInfo()
{
    BOOL fResult;
    LPCSTR pszResult;

    HCRYPTPROV hProv = 0;
    PCERT_PUBLIC_KEY_INFO pCorrectInfo = NULL;
    DWORD cbCorrectInfo;
    PCERT_PUBLIC_KEY_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cbTotal;

    printf("\n");
    if (0 == (hProv = GetCryptProv()))
        goto ErrorReturn;

    // Test: cbInfo == correct length
    if (!CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            NULL,               // pInfo
            &cbCorrectInfo
            )) {
        PrintLastError("CryptExportPublicKeyInfo(pInfo == NULL)");
        goto ErrorReturn;
    }

    if (NULL == (pCorrectInfo = (PCERT_PUBLIC_KEY_INFO) TestAlloc(
            cbCorrectInfo)))
        goto ErrorReturn;

    cbTotal = cbCorrectInfo + DELTA_MORE_LENGTH;
    if (NULL == (pInfo = (PCERT_PUBLIC_KEY_INFO) TestAlloc(cbTotal)))
        goto ErrorReturn;

    memset(pCorrectInfo, 0, cbCorrectInfo);
    if (!CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            pCorrectInfo,
            &cbCorrectInfo
            )) {
        PrintLastError("CryptExportPublicKeyInfo(cbInfo == correct length)");
        goto ErrorReturn;
    }

    printf("For cbInfo == correct length\n");
    printf("Info Length = %d (0x%x)  Content::\n",
        cbCorrectInfo, cbCorrectInfo);
    PrintBytes("  ", (BYTE *)pCorrectInfo, cbCorrectInfo);

    // Test: cbInfo < correct length
    printf("\n");
    memset(pInfo, 0, cbTotal);
    cbInfo = cbCorrectInfo - DELTA_LESS_LENGTH;
    fResult = CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            pInfo,
            &cbInfo
            );
    if (fResult) {
        pszResult = "TRUE";
        printf("failed => CryptExportPublicKeyInfo(cbInfo < correct length) returned success\n");
    } else {
        DWORD dwErr = GetLastError();
        pszResult = "FALSE";
        if (0 == dwErr)
            printf("failed => CryptExportPublicKey(cbInfo < correct length) LastError == 0\n");
        else
            printf(
                "CryptExportPublicKey(cbInfo < correct length) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }

    printf("For cbInfo < correct length, fResult = %s\n", pszResult);
    printf("Info Length = %d (0x%x)  Content::\n", cbInfo, cbInfo);
    PrintBytes("  ", (BYTE *) pInfo, cbTotal);
    if (cbInfo != cbCorrectInfo)
        printf("failed => for cbInfo < correct length::  wrong cbInfo\n");

    // Test: cbInfo > correct length
    printf("\n");
    memset(pInfo, 0, cbTotal);
    cbInfo = cbTotal;
    fResult = CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            pInfo,
            &cbInfo
            );
    if (fResult)
        pszResult = "TRUE";
    else {
        pszResult = "FALSE";
        PrintLastError("CryptExportPublicKeyInfo(cbInfo > correct length)");
    }

    printf("For cbInfo > correct length, fResult = %s\n", pszResult);
    printf("Info Length = %d (0x%x)  Content::\n", cbInfo, cbInfo);
    PrintBytes("  ", (BYTE *) pInfo, cbTotal);

    if (cbInfo != cbCorrectInfo)
        printf("failed => for cbInfo > correct length::  wrong cbInfo\n");

    // Test: pInfo != NULL, cbInfo == 0
    printf("\n");
    memset(pInfo, 0, cbTotal);
    cbInfo = 0;
    fResult = CryptExportPublicKeyInfo(
            hProv,
            AT_SIGNATURE,
            dwCertEncodingType,
            pInfo,
            &cbInfo
            );
    if (fResult) {
        pszResult = "TRUE";
        printf("failed => CryptExportPublicKeyInfo(pInfo != NULL, cbInfo == 0) returned success\n");
    } else {
        DWORD dwErr = GetLastError();
        pszResult = "FALSE";
        if (0 == dwErr)
            printf("failed => CryptExportPublicKeyInfo(pInfo != NULL, cbInfo == 0) LastError == 0\n");
        else
            printf(
                "CryptExportPublicKeyInfo(pInfo != NULL, cbInfo == 0) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }

    printf("For pInfo != NULL, cbInfo == 0, fResult = %s\n", pszResult);
    printf("Info Length = %d (0x%x)  Content::\n", cbInfo, cbInfo);
    PrintBytes("  ", (BYTE *) pInfo, cbTotal);

CommonReturn:
    if (pInfo)
        TestFree(pInfo);
    if (pCorrectInfo)
        TestFree(pCorrectInfo);
    if (hProv)
        CryptReleaseContext(hProv, 0);

    return;
ErrorReturn:
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Compare 2 CRYPT_DATA_BLOB structs.
//
//  Returns: FALSE iff differ
//--------------------------------------------------------------------------
BOOL
WINAPI
EqualCryptDataBlob(
    IN PCRYPT_DATA_BLOB    p1,
    IN PCRYPT_DATA_BLOB    p2)
{
    if (p1->cbData != p2->cbData)
        return FALSE;

    if (p1->cbData == 0)
        return TRUE;

    return (0 == memcmp(p1->pbData, p2->pbData, p1->cbData));
}

//+-------------------------------------------------------------------------
//  Compare 2 CRYPT_ATTRIBUTE structs.
//
//  Returns: FALSE iff differ
//--------------------------------------------------------------------------
BOOL
WINAPI
EqualAttribute(
    IN PCRYPT_ATTRIBUTE    patr1,
    IN PCRYPT_ATTRIBUTE    patr2)
{
    BOOL        fRet;
    DWORD       i;
    PCRYPT_ATTR_BLOB  pabl1;
    PCRYPT_ATTR_BLOB  pabl2;

    fRet  = (0 == strcmp( patr1->pszObjId, patr2->pszObjId));
    fRet &= (patr1->cValue == patr2->cValue);
    if (fRet) {
        for (i=patr1->cValue, pabl1=patr1->rgValue, pabl2=patr2->rgValue;
                i>0;
                i--, pabl1++, pabl2++) {
            fRet &= (pabl1->cbData == pabl2->cbData);
            if (fRet) {
                fRet &= (0 == memcmp( pabl1->pbData, 
                                      pabl2->pbData,
                                      pabl1->cbData));
            }
        }
    }

	return fRet;
}

static void TestCmcData()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCMC_DATA_INFO pInfo = NULL;
    CMC_DATA_INFO CmcData;

    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    BYTE rgb1[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    BYTE rgb2[] = {0x30, 0x0};                              // Empty SEQUENCE
    CRYPT_ATTR_BLOB rgValue[3] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1,
        sizeof(rgb2), rgb2
    };

    CMC_TAGGED_ATTRIBUTE rgTagAttr[2];
    CMC_TAGGED_CERT_REQUEST rgTagCertReq[3];
    CMC_TAGGED_REQUEST rgTagReq[3];
    CMC_TAGGED_CONTENT_INFO rgTagContentInfo[2];
    CMC_TAGGED_OTHER_MSG rgTagOtherMsg[2];

    DWORD i;

    rgTagAttr[0].dwBodyPartID = 0x7FFFFFFF;
    rgTagAttr[0].Attribute.pszObjId = "1.2.3.4";
    rgTagAttr[0].Attribute.cValue = 2;
    rgTagAttr[0].Attribute.rgValue = rgValue;
    rgTagAttr[1].dwBodyPartID = 0x80000001;
    rgTagAttr[1].Attribute.pszObjId = "1.2.3.5";
    rgTagAttr[1].Attribute.cValue = 0;
    rgTagAttr[1].Attribute.rgValue = NULL;
    CmcData.cTaggedAttribute = 2;
    CmcData.rgTaggedAttribute = rgTagAttr;

    rgTagCertReq[0].dwBodyPartID = 0x12345678;
    rgTagCertReq[0].SignedCertRequest = rgValue[0];
    rgTagCertReq[1].dwBodyPartID = 0x87654321;
    rgTagCertReq[1].SignedCertRequest = rgValue[1];
    rgTagCertReq[2].dwBodyPartID = 0x1;
    rgTagCertReq[2].SignedCertRequest = rgValue[2];
    rgTagReq[0].dwTaggedRequestChoice = CMC_TAGGED_CERT_REQUEST_CHOICE;
    rgTagReq[0].pTaggedCertRequest = &rgTagCertReq[0];
    rgTagReq[1].dwTaggedRequestChoice = CMC_TAGGED_CERT_REQUEST_CHOICE;
    rgTagReq[1].pTaggedCertRequest = &rgTagCertReq[1];
    rgTagReq[2].dwTaggedRequestChoice = CMC_TAGGED_CERT_REQUEST_CHOICE;
    rgTagReq[2].pTaggedCertRequest = &rgTagCertReq[2];
    CmcData.cTaggedRequest = 3;
    CmcData.rgTaggedRequest = rgTagReq;

    rgTagContentInfo[0].dwBodyPartID = 2;
    rgTagContentInfo[0].EncodedContentInfo = rgValue[0];
    rgTagContentInfo[1].dwBodyPartID = 3;
    rgTagContentInfo[1].EncodedContentInfo = rgValue[2];
    CmcData.cTaggedContentInfo = 2;
    CmcData.rgTaggedContentInfo = rgTagContentInfo;

    rgTagOtherMsg[0].dwBodyPartID = 14;
    rgTagOtherMsg[0].pszObjId = "1.2.44.55.66";
    rgTagOtherMsg[0].Value = rgValue[0];
    rgTagOtherMsg[1].dwBodyPartID = 15;
    rgTagOtherMsg[1].pszObjId = "1.2.44.55.66.77";
    rgTagOtherMsg[1].Value = rgValue[1];
    CmcData.cTaggedOtherMsg = 2;
    CmcData.rgTaggedOtherMsg = rgTagOtherMsg;

    printf("Test encode/decode CMC_DATA\n");
    if (!AllocAndEncodeObject(
            CMC_DATA,
            &CmcData,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_DATA_INFO) AllocAndDecodeObject(
        CMC_DATA,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (pInfo->cTaggedAttribute != CmcData.cTaggedAttribute ||
            pInfo->cTaggedRequest != CmcData.cTaggedRequest ||
            pInfo->cTaggedContentInfo != CmcData.cTaggedContentInfo ||
            pInfo->cTaggedOtherMsg != CmcData.cTaggedOtherMsg) {
        printf("CMC_DATA failed => invalid decoded tag counts\n");
        goto CommonReturn;
    }

    for (i = 0; i < CmcData.cTaggedAttribute; i++) {
        if (CmcData.rgTaggedAttribute[i].dwBodyPartID !=
                pInfo->rgTaggedAttribute[i].dwBodyPartID ||
                !EqualAttribute(&CmcData.rgTaggedAttribute[i].Attribute,
                    &pInfo->rgTaggedAttribute[i].Attribute)) {
            printf("CMC_DATA failed => invalid decoded tagged attribute\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcData.cTaggedRequest; i++) {
        PCMC_TAGGED_CERT_REQUEST pEncodeTagReq;
        PCMC_TAGGED_CERT_REQUEST pDecodeTagReq;
        if (CMC_TAGGED_CERT_REQUEST_CHOICE !=
                pInfo->rgTaggedRequest[i].dwTaggedRequestChoice) {
            printf("CMC_DATA failed => invalid decoded tagged request\n");
            goto CommonReturn;
        }

        pEncodeTagReq = CmcData.rgTaggedRequest[i].pTaggedCertRequest;
        pDecodeTagReq = pInfo->rgTaggedRequest[i].pTaggedCertRequest;
        if (pEncodeTagReq->dwBodyPartID != pDecodeTagReq->dwBodyPartID ||
                !EqualCryptDataBlob(&pEncodeTagReq->SignedCertRequest,
                    &pDecodeTagReq->SignedCertRequest)) {
            printf("CMC_DATA failed => invalid decoded tagged request\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcData.cTaggedContentInfo; i++) {
        if (CmcData.rgTaggedContentInfo[i].dwBodyPartID !=
                pInfo->rgTaggedContentInfo[i].dwBodyPartID ||
                !EqualCryptDataBlob(
                    &CmcData.rgTaggedContentInfo[i].EncodedContentInfo,
                    &pInfo->rgTaggedContentInfo[i].EncodedContentInfo)) {
            printf("CMC_DATA failed => invalid decoded tagged ContentInfo\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcData.cTaggedOtherMsg; i++) {
        if (CmcData.rgTaggedOtherMsg[i].dwBodyPartID !=
                pInfo->rgTaggedOtherMsg[i].dwBodyPartID ||
                0 != strcmp(CmcData.rgTaggedOtherMsg[i].pszObjId,
                    pInfo->rgTaggedOtherMsg[i].pszObjId) ||
                !EqualCryptDataBlob(&CmcData.rgTaggedOtherMsg[i].Value,
                    &pInfo->rgTaggedOtherMsg[i].Value)) {
            printf("CMC_DATA failed => invalid decoded tagged OtherMsg\n");
            goto CommonReturn;
        }
    }

    TestFree(pbEncoded);
    pbEncoded = NULL;
    TestFree(pInfo);
    pInfo = NULL;

    // Do and encode/decode without any tagged entries
    memset(&CmcData, 0, sizeof(CmcData));

    printf("Test encode/decode CMC_DATA(No Tagged Entries)\n");
    if (!AllocAndEncodeObject(
            CMC_DATA,
            &CmcData,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_DATA_INFO) AllocAndDecodeObject(
        CMC_DATA,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (pInfo->cTaggedAttribute != 0 ||
            pInfo->cTaggedRequest != 0 ||
            pInfo->cTaggedContentInfo != 0 ||
            pInfo->cTaggedOtherMsg != 0) {
        printf("CMC_DATA failed => invalid decoded tag counts\n");
        goto CommonReturn;
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestCmcResponse()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCMC_RESPONSE_INFO pInfo = NULL;
    CMC_RESPONSE_INFO CmcResponse;

    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    BYTE rgb1[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    BYTE rgb2[] = {0x30, 0x0};                              // Empty SEQUENCE
    CRYPT_ATTR_BLOB rgValue[3] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1,
        sizeof(rgb2), rgb2
    };

    CMC_TAGGED_ATTRIBUTE rgTagAttr[2];
    CMC_TAGGED_CONTENT_INFO rgTagContentInfo[2];
    CMC_TAGGED_OTHER_MSG rgTagOtherMsg[2];

    DWORD i;

    rgTagAttr[0].dwBodyPartID = 0x7FFFFFFF;
    rgTagAttr[0].Attribute.pszObjId = "1.2.3.4";
    rgTagAttr[0].Attribute.cValue = 2;
    rgTagAttr[0].Attribute.rgValue = rgValue;
    rgTagAttr[1].dwBodyPartID = 0x80000001;
    rgTagAttr[1].Attribute.pszObjId = "1.2.3.5";
    rgTagAttr[1].Attribute.cValue = 0;
    rgTagAttr[1].Attribute.rgValue = NULL;
    CmcResponse.cTaggedAttribute = 2;
    CmcResponse.rgTaggedAttribute = rgTagAttr;

    rgTagContentInfo[0].dwBodyPartID = 2;
    rgTagContentInfo[0].EncodedContentInfo = rgValue[0];
    rgTagContentInfo[1].dwBodyPartID = 3;
    rgTagContentInfo[1].EncodedContentInfo = rgValue[2];
    CmcResponse.cTaggedContentInfo = 2;
    CmcResponse.rgTaggedContentInfo = rgTagContentInfo;

    rgTagOtherMsg[0].dwBodyPartID = 14;
    rgTagOtherMsg[0].pszObjId = "1.2.44.55.66";
    rgTagOtherMsg[0].Value = rgValue[0];
    rgTagOtherMsg[1].dwBodyPartID = 15;
    rgTagOtherMsg[1].pszObjId = "1.2.44.55.66.77";
    rgTagOtherMsg[1].Value = rgValue[1];
    CmcResponse.cTaggedOtherMsg = 2;
    CmcResponse.rgTaggedOtherMsg = rgTagOtherMsg;

    printf("Test encode/decode CMC_RESPONSE\n");
    if (!AllocAndEncodeObject(
            CMC_RESPONSE,
            &CmcResponse,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_RESPONSE_INFO) AllocAndDecodeObject(
        CMC_RESPONSE,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (pInfo->cTaggedAttribute != CmcResponse.cTaggedAttribute ||
            pInfo->cTaggedContentInfo != CmcResponse.cTaggedContentInfo ||
            pInfo->cTaggedOtherMsg != CmcResponse.cTaggedOtherMsg) {
        printf("CMC_RESPONSE failed => invalid decoded tag counts\n");
        goto CommonReturn;
    }

    for (i = 0; i < CmcResponse.cTaggedAttribute; i++) {
        if (CmcResponse.rgTaggedAttribute[i].dwBodyPartID !=
                pInfo->rgTaggedAttribute[i].dwBodyPartID ||
                !EqualAttribute(&CmcResponse.rgTaggedAttribute[i].Attribute,
                    &pInfo->rgTaggedAttribute[i].Attribute)) {
            printf("CMC_RESPONSE failed => invalid decoded tagged attribute\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcResponse.cTaggedContentInfo; i++) {
        if (CmcResponse.rgTaggedContentInfo[i].dwBodyPartID !=
                pInfo->rgTaggedContentInfo[i].dwBodyPartID ||
                !EqualCryptDataBlob(
                    &CmcResponse.rgTaggedContentInfo[i].EncodedContentInfo,
                    &pInfo->rgTaggedContentInfo[i].EncodedContentInfo)) {
            printf("CMC_RESPONSE failed => invalid decoded tagged ContentInfo\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcResponse.cTaggedOtherMsg; i++) {
        if (CmcResponse.rgTaggedOtherMsg[i].dwBodyPartID !=
                pInfo->rgTaggedOtherMsg[i].dwBodyPartID ||
                0 != strcmp(CmcResponse.rgTaggedOtherMsg[i].pszObjId,
                    pInfo->rgTaggedOtherMsg[i].pszObjId) ||
                !EqualCryptDataBlob(&CmcResponse.rgTaggedOtherMsg[i].Value,
                    &pInfo->rgTaggedOtherMsg[i].Value)) {
            printf("CMC_RESPONSE failed => invalid decoded tagged OtherMsg\n");
            goto CommonReturn;
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}


static void TestCmcStatus(
    DWORD dwOtherInfoChoice
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCMC_STATUS_INFO pInfo = NULL;
    CMC_STATUS_INFO CmcStatus;

    DWORD rgdwBodyList[3] = {0x80000000, 0x7FFFFFFF, 0x123 };

    BYTE rgbPendToken[] = {1,2,3,4,5};
    CMC_PEND_INFO PendInfo;
    SYSTEMTIME  t;
    DWORD i;

    CmcStatus.dwStatus = 0x12345678;
    CmcStatus.cBodyList = 3;
    CmcStatus.rgdwBodyList = rgdwBodyList;

    switch (dwOtherInfoChoice) {
        case CMC_OTHER_INFO_FAIL_CHOICE:
            CmcStatus.pwszStatusString = L"\0";
            CmcStatus.dwOtherInfoChoice = CMC_OTHER_INFO_FAIL_CHOICE;
            CmcStatus.dwFailInfo = 0x11223344;
            break;

        case CMC_OTHER_INFO_PEND_CHOICE:
            CmcStatus.pwszStatusString = L"Status String";
            CmcStatus.dwOtherInfoChoice = CMC_OTHER_INFO_PEND_CHOICE;
            CmcStatus.pPendInfo = &PendInfo;
            PendInfo.PendToken.cbData = sizeof(rgbPendToken);
            PendInfo.PendToken.pbData = rgbPendToken;

            memset(&t, 0, sizeof(t));
            t.wYear   = 2000;
            t.wMonth  = 1;
            t.wDay    = 2;
            t.wHour   = 3;
            t.wMinute = 4;
            t.wSecond = 5;
            t.wMilliseconds = 678;
            if (!SystemTimeToFileTime(&t, &PendInfo.PendTime)) {
                PrintLastError("SystemTimeToFileTime");
                return;
            }
            break;

        case CMC_OTHER_INFO_NO_CHOICE:
        default:
            CmcStatus.pwszStatusString = NULL;
            CmcStatus.dwOtherInfoChoice = CMC_OTHER_INFO_NO_CHOICE;
            CmcStatus.cBodyList = 0;
            CmcStatus.rgdwBodyList = NULL;
    }

    printf("Test encode/decode CMC_STATUS(OtherInfoChoice:%d)\n",
        dwOtherInfoChoice);
    if (!AllocAndEncodeObject(
            CMC_STATUS,
            &CmcStatus,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_STATUS_INFO) AllocAndDecodeObject(
        CMC_STATUS,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (CmcStatus.dwStatus != pInfo->dwStatus ||
            CmcStatus.cBodyList != pInfo->cBodyList ||
            CmcStatus.dwOtherInfoChoice != pInfo->dwOtherInfoChoice) {
        printf("CMC_STATUS failed => encode/decode mismatch\n");
        goto CommonReturn;
    }

    switch (CmcStatus.dwOtherInfoChoice) {
        case CMC_OTHER_INFO_FAIL_CHOICE:
            if (pInfo->pwszStatusString != NULL)
                printf("CMC_STATUS failed => expected NULL StatusString\n");

            if (CmcStatus.dwFailInfo != pInfo->dwFailInfo)
                printf("CMC_STATUS failed => bad FailInfo\n");
            break;

        case CMC_OTHER_INFO_PEND_CHOICE:
            {
                PCMC_PEND_INFO pEncodePendInfo;
                PCMC_PEND_INFO pDecodePendInfo;
                
                if (pInfo->pwszStatusString == NULL ||
                        0 != wcscmp(CmcStatus.pwszStatusString,
                                pInfo->pwszStatusString))
                    printf("CMC_STATUS failed => bad StatusString\n");

                pEncodePendInfo = CmcStatus.pPendInfo;
                pDecodePendInfo = pInfo->pPendInfo;
                if (!EqualCryptDataBlob(
                        &pEncodePendInfo->PendToken,
                        &pDecodePendInfo->PendToken))
                    printf("CMC_STATUS failed => bad PendToken\n");

                if (0 != memcmp(&pEncodePendInfo->PendTime,
                        &pDecodePendInfo->PendTime,
                            sizeof(pDecodePendInfo->PendTime)))
                    printf("CMC_STATUS failed => bad PendTime\n");
            }
            break;

        case CMC_OTHER_INFO_NO_CHOICE:
        default:
            if (pInfo->pwszStatusString != NULL)
                printf("CMC_STATUS failed => expected NULL StatusString\n");
    }

    for (i = 0; i < CmcStatus.cBodyList; i++) {
        if (CmcStatus.rgdwBodyList[i] != pInfo->rgdwBodyList[i]) {
            printf("CMC_STATUS failed => invalid decoded tagged BodyList\n");
            goto CommonReturn;
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestCmcAddExtensions()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCMC_ADD_EXTENSIONS_INFO pInfo = NULL;
    CMC_ADD_EXTENSIONS_INFO CmcAddExtensions;

    DWORD rgdwCertReference[3] = {0x80000000, 0x7FFFFFFF, 0x123 };
    BYTE rgbExt[] = {0x1, 0x2, 0x3};
    CERT_EXTENSION rgExt[2] = {
        "1.2.3.4.5", TRUE, sizeof(rgbExt), rgbExt,
        "1.2.3.6.7", FALSE, sizeof(rgbExt), rgbExt
    };

    DWORD i;

    CmcAddExtensions.dwCmcDataReference = 0x12345678;
    CmcAddExtensions.cCertReference = 3;
    CmcAddExtensions.rgdwCertReference = rgdwCertReference;
    CmcAddExtensions.cExtension = 2;
    CmcAddExtensions.rgExtension = rgExt;

    printf("Test encode/decode CMC_ADD_EXTENSIONS\n");
    if (!AllocAndEncodeObject(
            CMC_ADD_EXTENSIONS,
            &CmcAddExtensions,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_ADD_EXTENSIONS_INFO) AllocAndDecodeObject(
        CMC_ADD_EXTENSIONS,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (CmcAddExtensions.dwCmcDataReference != pInfo->dwCmcDataReference ||
            CmcAddExtensions.cCertReference != pInfo->cCertReference ||
            CmcAddExtensions.cExtension != pInfo->cExtension) {
        printf("CMC_ADD_EXTENSIONS failed => encode/decode mismatch\n");
        goto CommonReturn;
    }


    for (i = 0; i < CmcAddExtensions.cCertReference; i++) {
        if (CmcAddExtensions.rgdwCertReference[i] !=
                pInfo->rgdwCertReference[i]) {
            printf("CMC_ADD_EXTENSIONS failed => invalid decoded CertReference\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcAddExtensions.cExtension; i++) {
        PCERT_EXTENSION pEncodeExt = &CmcAddExtensions.rgExtension[i];
        PCERT_EXTENSION pDecodeExt = &pInfo->rgExtension[i];
        if (0 != strcmp(pEncodeExt->pszObjId, pDecodeExt->pszObjId) ||
                pEncodeExt->fCritical != pDecodeExt->fCritical ||
                !EqualCryptDataBlob(&pEncodeExt->Value, &pEncodeExt->Value)) {
            printf("CMC_ADD_EXTENSIONS failed => invalid decoded Extensions\n");
            goto CommonReturn;
        }
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestCmcAddAttributes()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCMC_ADD_ATTRIBUTES_INFO pInfo = NULL;
    CMC_ADD_ATTRIBUTES_INFO CmcAddAttributes;

    DWORD rgdwCertReference[3] = {0x80000000, 0x7FFFFFFF, 0x123 };
    BYTE rgb0[] = {0x2, 0x2, 0x11, 0x22};                   // INTEGER
    BYTE rgb1[] = {0x4, 0x5, 0x11, 0x22, 0x33, 0x44, 0x55}; // OCTET STRING
    CRYPT_ATTR_BLOB rgValue[2] = {
        sizeof(rgb0), rgb0,
        sizeof(rgb1), rgb1
    };

    CRYPT_ATTRIBUTE rgAttr[3] = {
        "1.2.3.6.8", 0, NULL,
        "1.2.3.6.7", 1, rgValue,
        "1.2.3.4.5", 2, rgValue,
    };

    DWORD i;

    CmcAddAttributes.dwCmcDataReference = 0x12345678;
    CmcAddAttributes.cCertReference = 3;
    CmcAddAttributes.rgdwCertReference = rgdwCertReference;
    CmcAddAttributes.cAttribute = 3;
    CmcAddAttributes.rgAttribute = rgAttr;

    printf("Test encode/decode CMC_ADD_ATTRIBUTES\n");
    if (!AllocAndEncodeObject(
            CMC_ADD_ATTRIBUTES,
            &CmcAddAttributes,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCMC_ADD_ATTRIBUTES_INFO) AllocAndDecodeObject(
        CMC_ADD_ATTRIBUTES,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (CmcAddAttributes.dwCmcDataReference != pInfo->dwCmcDataReference ||
            CmcAddAttributes.cCertReference != pInfo->cCertReference ||
            CmcAddAttributes.cAttribute != pInfo->cAttribute) {
        printf("CMC_ADD_ATTRIBUTES failed => encode/decode mismatch\n");
        goto CommonReturn;
    }


    for (i = 0; i < CmcAddAttributes.cCertReference; i++) {
        if (CmcAddAttributes.rgdwCertReference[i] !=
                pInfo->rgdwCertReference[i]) {
            printf("CMC_ADD_ATTRIBUTES failed => invalid decoded CertReference\n");
            goto CommonReturn;
        }
    }

    for (i = 0; i < CmcAddAttributes.cAttribute; i++) {
        PCRYPT_ATTRIBUTE pEncodeAttr = &CmcAddAttributes.rgAttribute[i];
        PCRYPT_ATTRIBUTE pDecodeAttr = &pInfo->rgAttribute[i];

        if (!EqualAttribute(pEncodeAttr, pDecodeAttr))
            printf("CMC_ADD_ATTRIBUTES failed => invalid decoded Attributes\n");
    }

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

static void TestCertTemplate()
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    PCERT_TEMPLATE_EXT pInfo = NULL;

    CERT_TEMPLATE_EXT CertTemplate;

    CertTemplate.pszObjId = "1.2.3.4.5.6.7.8.9";
    CertTemplate.dwMajorVersion = 0x11223344;
    CertTemplate.fMinorVersion = FALSE;


    printf("Test encode/decode X509_CERTIFICATE_TEMPLATE\n");
    if (!AllocAndEncodeObject(
            X509_CERTIFICATE_TEMPLATE,
            &CertTemplate,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCERT_TEMPLATE_EXT) AllocAndDecodeObject(
        X509_CERTIFICATE_TEMPLATE,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszObjId, CertTemplate.pszObjId) ||
            pInfo->dwMajorVersion != CertTemplate.dwMajorVersion ||
            pInfo->fMinorVersion != CertTemplate.fMinorVersion)
        printf("X509_CERTIFICATE_TEMPLATE failed => decode != encode input\n");

    TestFree(pbEncoded);
    pbEncoded = NULL;

    TestFree(pInfo);
    pInfo = NULL;

    CertTemplate.fMinorVersion = TRUE;
    CertTemplate.dwMinorVersion = 12345678;

    if (!AllocAndEncodeObject(
            szOID_CERTIFICATE_TEMPLATE,
            &CertTemplate,
            &pbEncoded,
            &cbEncoded))
        goto CommonReturn;

    if (NULL == (pInfo =
            (PCERT_TEMPLATE_EXT) AllocAndDecodeObject(
        szOID_CERTIFICATE_TEMPLATE,
        pbEncoded,
        cbEncoded
        ))) goto CommonReturn;

    if (0 != strcmp(pInfo->pszObjId, CertTemplate.pszObjId) ||
            pInfo->dwMajorVersion != CertTemplate.dwMajorVersion ||
            pInfo->fMinorVersion != CertTemplate.fMinorVersion ||
            pInfo->dwMinorVersion != CertTemplate.dwMinorVersion)
        printf("szOID_CERTIFICATE_TEMPLATE failed => decode != encode input\n");

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pInfo)
        TestFree(pInfo);
}

int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    LPCSTR pszResult;

    CERT_NAME_INFO Name;
    CERT_RDN Rdn[2];
    CERT_RDN_ATTR RdnAttr[2];

#define ATTR_VALUE0 "Name 0"
    RdnAttr[0].pszObjId = "1.2.3.4";
    RdnAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    RdnAttr[0].Value.pbData = (BYTE *) ATTR_VALUE0;
    RdnAttr[0].Value.cbData = strlen(ATTR_VALUE0);
#define ATTR_VALUE1 "Name 11111"
    RdnAttr[1].pszObjId = "1.2.3.4.1";
    RdnAttr[1].dwValueType = CERT_RDN_PRINTABLE_STRING;
    RdnAttr[1].Value.pbData = (BYTE *) ATTR_VALUE1;
    RdnAttr[1].Value.cbData = strlen(ATTR_VALUE1);

    Rdn[0].cRDNAttr = 2;
    Rdn[0].rgRDNAttr = RdnAttr;
    Rdn[1].cRDNAttr = 1;
    Rdn[1].rgRDNAttr = &RdnAttr[1];

    Name.cRDN = 2;
    Name.rgRDN = Rdn;


    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbCorrectEncoded = NULL;
    DWORD cbCorrectEncoded;
    DWORD cbTotal;

    PCERT_NAME_INFO pDecodedInfo = NULL;
    DWORD cbDecodedInfo;
    PCERT_NAME_INFO pCorrectDecodedInfo = NULL;
    DWORD cbCorrectDecodedInfo;

    printf("command line: %s\n", GetCommandLine());

    TestExtensions();
    TestX942OtherInfo();
    TestPKCSAttribute();
    TestPKCSAttributes();
    TestContentInfoSequenceOfAny();
    TestSequenceOfAny();
    TestInteger();
    TestMultiByteInteger();
    TestBits();
    TestBitsWithoutTrailingZeroes();
    TestOID();
    TestUnicodeAnyString();
    TestUniversalString();
    TestChoiceOfTime();
    TestUtcTime();
    TestBadAltName();
    TestBadAuthorityInfoAccess();
    TestBadAuthorityKeyId2();
    TestBadNameConstraints();
    TestBadIssuingDistPoint();
    TestCmcData();
    TestCmcResponse();
    TestCmcStatus(CMC_OTHER_INFO_NO_CHOICE);
    TestCmcStatus(CMC_OTHER_INFO_FAIL_CHOICE);
    TestCmcStatus(CMC_OTHER_INFO_PEND_CHOICE);
    TestCmcAddExtensions();
    TestCmcAddAttributes();
    TestCertTemplate();

    TestCryptExportPublicKeyInfo();

    // Test: cbEncoded == correct length
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            NULL,               // pbEncoded
            &cbCorrectEncoded
            )) {
        PrintLastError("CryptEncodeObject(pbEncoded == NULL)");
        goto ErrorReturn;
    }

    if (NULL == (pbCorrectEncoded = (BYTE *) TestAlloc(cbCorrectEncoded)))
        goto ErrorReturn;

    cbTotal = cbCorrectEncoded + DELTA_MORE_LENGTH;
    if (NULL == (pbEncoded = (BYTE *) TestAlloc(cbTotal)))
        goto ErrorReturn;

    memset(pbCorrectEncoded, 0, cbCorrectEncoded);
    if (!CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbCorrectEncoded,
            &cbCorrectEncoded
            )) {
        PrintLastError("CryptEncodeObject(cbEncoded == correct length)");
        goto ErrorReturn;
    }

    printf("For cbEncoded == correct length\n");
    printf("Encoded Length = %d (0x%x)  Content::\n",
        cbCorrectEncoded, cbCorrectEncoded);
    PrintBytes("  ", pbCorrectEncoded, cbCorrectEncoded);

    // Test: cbEncoded < correct length
    printf("\n");
    memset(pbEncoded, 0, cbTotal);
    cbEncoded = cbCorrectEncoded - DELTA_LESS_LENGTH;
    fResult = CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbEncoded,
            &cbEncoded
            );
    if (fResult) {
        pszResult = "TRUE";
        printf("failed => CryptEncodeObject(cbEncoded < correct length) returned success\n");
    } else {
        DWORD dwErr = GetLastError();
        pszResult = "FALSE";
        if (0 == dwErr)
            printf("failed => CryptEncodeObject(cbEncoded < correct length) LastError == 0\n");
        else
            printf(
                "CryptEncodeObject(cbEncoded < correct length) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }

    printf("For cbEncoded < correct length, fResult = %s\n", pszResult);
    printf("Encoded Length = %d (0x%x)  Content::\n", cbEncoded, cbEncoded);
    PrintBytes("  ", pbEncoded, cbTotal);
    if (cbEncoded != cbCorrectEncoded)
        printf("failed => for cbEncoded < correct length::  wrong cbEncoded\n");

    // Test: cbEncoded > correct length
    printf("\n");
    memset(pbEncoded, 0, cbTotal);
    cbEncoded = cbTotal;
    fResult = CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbEncoded,
            &cbEncoded
            );
    if (fResult)
        pszResult = "TRUE";
    else {
        pszResult = "FALSE";
        PrintLastError("CryptEncodeObject(cbEncoded > correct length)");
    }

    printf("For cbEncoded > correct length, fResult = %s\n", pszResult);
    printf("Encoded Length = %d (0x%x)  Content::\n", cbEncoded, cbEncoded);
    PrintBytes("  ", pbEncoded, cbTotal);

    if (cbEncoded != cbCorrectEncoded)
        printf("failed => for cbEncoded > correct length::  wrong cbEncoded\n");
    else if (0 != memcmp(pbEncoded, pbCorrectEncoded, cbCorrectEncoded))
        printf("failed => for cbEncoded > correct length:: bad pbEncoded content\n");

    // Test: pbEncoded != NULL, cbEncoded == 0
    printf("\n");
    memset(pbEncoded, 0, cbTotal);
    cbEncoded = 0;
    fResult = CryptEncodeObject(
            dwCertEncodingType,
            X509_NAME,
            &Name,
            pbEncoded,
            &cbEncoded
            );
    if (fResult) {
        pszResult = "TRUE";
        printf("failed => CryptEncodeObject(pbEncoded != NULL, cbEncoded == 0) returned success\n");
    } else {
        DWORD dwErr = GetLastError();
        pszResult = "FALSE";
        if (0 == dwErr)
            printf("failed => CryptEncodeObject(pbEncoded != NULL, cbEncoded == 0) LastError == 0\n");
        else
            printf(
                "CryptEncodeObject(pbEncoded != NULL, cbEncoded == 0) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }

    printf("For pbEncoded != NULL, cbEncoded == 0, fResult = %s\n", pszResult);
    printf("Encoded Length = %d (0x%x)  Content::\n", cbEncoded, cbEncoded);
    PrintBytes("  ", pbEncoded, cbTotal);

    printf("\n");
    // Test: cbDecodedInfo == correct length
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded,
            0,                  // dwFlags
            NULL,               // pvStructInfo
            &cbCorrectDecodedInfo
            )) {
        PrintLastError("CryptDecodeObject(pvStructInfo == NULL)");
        goto ErrorReturn;
    }

    if (NULL == (pCorrectDecodedInfo = (PCERT_NAME_INFO) TestAlloc(
            cbCorrectDecodedInfo)))
        goto ErrorReturn;

    cbTotal = cbCorrectDecodedInfo + DELTA_MORE_LENGTH;
    if (NULL == (pDecodedInfo = (PCERT_NAME_INFO) TestAlloc(cbTotal)))
        goto ErrorReturn;

    memset(pCorrectDecodedInfo, 0, cbCorrectDecodedInfo);
    if (!CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded,
            0,                              // dwFlags
            pCorrectDecodedInfo,
            &cbCorrectDecodedInfo
            )) {
        PrintLastError("CryptDecodeObject(cbStructInfo == correct length)");
        goto ErrorReturn;
    }

    // Test: cbDecodedInfo > correct length
    memset(pDecodedInfo, 0, cbTotal);
    cbDecodedInfo = cbTotal;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded,
            0,                              // dwFlags
            pDecodedInfo,
            &cbDecodedInfo
            );
    if (!fResult)
        PrintLastError("CryptDecodeObject(cbStructInfo > correct length)");

    if (cbDecodedInfo != cbCorrectDecodedInfo)
        printf("failed => for cbStructInfo > correct length::  wrong cbStructInfo\n");

    // Test: cbDecodedInfo < correct length
    memset(pDecodedInfo, 0, cbTotal);
    cbDecodedInfo = cbCorrectDecodedInfo - DELTA_LESS_LENGTH;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded,
            0,                              // dwFlags
            pDecodedInfo,
            &cbDecodedInfo
            );
    if (fResult)
        printf("failed => CryptDecodeObject(cbStructInfo < correct length) returned success\n");
    else {
        DWORD dwErr = GetLastError();
        if (0 == dwErr)
            printf("failed => CryptDecodeObject(cbStructInfo < correct length) LastError == 0\n");
        else
            printf(
                "CryptDecodeObject(cbStructInfo < correct length) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }
    if (cbDecodedInfo != cbCorrectDecodedInfo)
        printf("failed => for cbStructInfo < correct length::  wrong cbStructInfo\n");


    // Test: pvStructInfo != NULL, cbStructInfo == 0
    memset(pDecodedInfo, 0, cbTotal);
    cbDecodedInfo = 0;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded,
            0,                              // dwFlags
            pDecodedInfo,
            &cbDecodedInfo
            );
    if (fResult)
        printf("failed => CryptDecodeObject(pvStructInfo != NULL, cbStructInfo == 0) returned success\n");
    else {
        DWORD dwErr = GetLastError();
        if (0 == dwErr)
            printf("failed => CryptDecodeObject(pvStructInfo != NULL, cbStructInfo == 0) LastError == 0\n");
        else
            printf(
                "CryptDecodeObject(pvStructInfo != NULL, cbStructInfo == 0) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }

    // Test decoding missing the last bytes
    memset(pDecodedInfo, 0, cbTotal);
    cbDecodedInfo = cbCorrectDecodedInfo;
    fResult = CryptDecodeObject(
            dwCertEncodingType,
            X509_NAME,
            pbCorrectEncoded,
            cbCorrectEncoded -30,
            0,                              // dwFlags
            pDecodedInfo,
            &cbDecodedInfo
            );
    if (fResult)
        printf("failed => CryptDecodeObject(incomplete cbEncoded) returned success\n");
    else {
        DWORD dwErr = GetLastError();
        if (0 == dwErr)
            printf("failed => CryptDecodeObject(incomplete cbEncoded) LastError == 0\n");
        else
            printf(
                "CryptDecodeObject(incomplete cbEncoded) LastError = 0x%x (%d)\n",
                dwErr, dwErr);
    }



ErrorReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pbCorrectEncoded)
        TestFree(pbCorrectEncoded);
    if (pDecodedInfo)
        TestFree(pDecodedInfo);
    if (pCorrectDecodedInfo)
        TestFree(pCorrectDecodedInfo);

    printf("Done.\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\teku\teku.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       teku.cpp
//
//  Contents:   Cert Enhanced Key Usage tests
//
//  History:    27-May-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#define szOID_STUFF1 "2.2.2.4"
#define szOID_STUFF2 "2.2.2.5"
//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   prints the usage statement
//
//----------------------------------------------------------------------------
static void Usage(void)
{
    printf("Usage: teku [options]\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -f<filename>          - Cert file (.CER)\n");
    printf("  -s<store name>        - Place cert in store\n");
    printf("\n");
}

//+---------------------------------------------------------------------------
//
//  Function:   GetAndDisplayEKU
//
//  Synopsis:   gets and displays enhanced key usage
//
//----------------------------------------------------------------------------
static void GetAndDisplayEKU (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    DWORD              cbUsage;
    DWORD              cCount;
    PCERT_ENHKEY_USAGE pUsage;

    //
    // Get the usage
    //

    if ( CertGetEnhancedKeyUsage(
                pCertContext,
                dwFlags,
                NULL,
                &cbUsage
                ) == FALSE )
    {
        if ( GetLastError() == CRYPT_E_NOT_FOUND )
        {
            printf("No enhanced key usage present\n\n");
        }
        else
        {
            printf(
               "Error: Could not get enhanced key usage %x\n\n",
               GetLastError()
               );
        }

        return;
    }

    pUsage = (PCERT_ENHKEY_USAGE)new BYTE [cbUsage];
    if ( pUsage != NULL )
    {
        if ( CertGetEnhancedKeyUsage(
                    pCertContext,
                    dwFlags,
                    pUsage,
                    &cbUsage
                    ) == FALSE )
        {
            if ( GetLastError() == CRYPT_E_NOT_FOUND )
            {
                printf("No enhanced key usage present\n\n");
            }
            else
            {
                printf(
                   "Error: Could not get enhanced key usage %x\n\n",
                   GetLastError()
                   );
            }

            delete pUsage;
            return;
        }
    }
    else
    {
        printf("Out of Memory!\n\n");
        return;
    }

    //
    // Display the usage
    //

    printf(
       "%d enhanced key usage OID(s) present:\n",
       pUsage->cUsageIdentifier
       );

    for ( cCount = 0; cCount < pUsage->cUsageIdentifier; cCount++ )
    {
        printf("\t%s\n", pUsage->rgpszUsageIdentifier[cCount]);
    }
    printf("\n");

    //
    // Cleanup
    //

    delete pUsage;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetAndDisplayAllEKUForms
//
//  Synopsis:   displays all EKU forms
//
//----------------------------------------------------------------------------
static void GetAndDisplayAllEKUForms (PCCERT_CONTEXT pCertContext)
{
    //
    // Get and display EKU extension
    //

    printf("Certificate EKU extension\n\n");
    GetAndDisplayEKU(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG);

    //
    // Get and display EKU property
    //

    printf("Certificate EKU property\n\n");
    GetAndDisplayEKU(pCertContext, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG);

    //
    // Get and display both EKU extension and property
    //

    printf("Certificate EKU extension and property\n\n");
    GetAndDisplayEKU(
          pCertContext,
          CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG |
          CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG
          );
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   main program entry point
//
//----------------------------------------------------------------------------
int _cdecl main(int argc, char * argv[])
{
    LPSTR          pszCertFile = NULL;
    DWORD          cbEncoded;
    LPBYTE         pbEncoded;
    PCCERT_CONTEXT pCertContext;
    PCCERT_CONTEXT pContextToUse;
    LPSTR          pszStore = NULL;
    HCERTSTORE     hStore;

    while ( --argc > 0 )
    {
        if ( **++argv == '-' )
        {
            switch( argv[0][1] )
            {
            case 'f':
            case 'F':
                pszCertFile = argv[0]+2;
                if ( *pszCertFile == '\0' )
                {
                    printf("Need to specify filename\n");
                    Usage();
                    return( -1 );
                }
                break;
            case 's':
            case 'S':
                pszStore = argv[0]+2;
                if ( *pszStore == '\0' )
                {
                    printf("Need to specify store name\n");
                    Usage();
                    return( -1 );
                }
                break;
            default:
                Usage();
                return -1;
            }
        }
    }

    printf("command line: %s\n", GetCommandLineA());

    //
    // For now we must have a certificate file to process
    //

    if ( pszCertFile == NULL )
    {
        printf("Must specify a certificate file to process\n");
        Usage();
        return( -1 );
    }

    //
    // Use our input to get a certificate context to play with
    //

    if ( ReadDERFromFile(pszCertFile, &pbEncoded, &cbEncoded) == FALSE )
    {
        printf("Error reading CERT!\n");
        return(-1);
    }

    pCertContext = CertCreateCertificateContext(
                             X509_ASN_ENCODING,
                             pbEncoded,
                             cbEncoded
                             );

    TestFree(pbEncoded);

    if ( pCertContext == NULL )
    {
        printf( "Error create certificate context\n" );
        return( -1 );
    }

    //
    // If store action is requested ...
    //

    if ( pszStore != NULL )
    {
        hStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_A,
                     0,
                     NULL,
                     CERT_SYSTEM_STORE_CURRENT_USER,
                     pszStore
                     );

        if ( hStore == NULL )
        {
            CertFreeCertificateContext( pCertContext );
            printf( "Error creating system store %lx\n", GetLastError() );
            return( -1 );
        }

        if ( CertEnumCertificatesInStore( hStore, NULL ) != NULL )
        {
            CertFreeCertificateContext( pCertContext );
            CertCloseStore( hStore, 0 );
            printf( "Must be a new or empty store\n" );
            return( -1 );
        }

        if ( CertAddCertificateContextToStore(
                 hStore,
                 pCertContext,
                 CERT_STORE_ADD_NEW,
                 NULL
                 ) == FALSE )
        {
            CertFreeCertificateContext( pCertContext );
            CertCloseStore( hStore, 0 );
            printf( "Error creating system store %lx\n", GetLastError() );
            return( -1 );
        }

        CertFreeCertificateContext( pCertContext );

        pCertContext = CertEnumCertificatesInStore( hStore, NULL );
        if ( pCertContext == NULL )
        {
            CertCloseStore( hStore, 0 );
            printf( "Error finding certificate from store\n" );
            return( -1 );
        }

        printf( "hStore = %p\n", hStore );
        printf( "pCertContext->hCertStore = %p\n", pCertContext->hCertStore );

        pContextToUse = CertDuplicateCertificateContext( pCertContext );

        printf( "pContextToUse->hCertStore = %p\n", pContextToUse->hCertStore );

        CertCloseStore( hStore, 0 );

        printf( "pContextToUse->hCertStore = %p\n", pContextToUse->hCertStore );
    }
    else
    {
        pContextToUse = CertDuplicateCertificateContext( pCertContext );
        CertFreeCertificateContext( pCertContext );
    }

    //
    // Get and display all EKU forms
    //

    GetAndDisplayAllEKUForms(pContextToUse);

    //
    // Add a identifier property
    //

    printf("Adding %s enhanced key usage OID to the cert\n", szOID_STUFF1);

    if ( CertAddEnhancedKeyUsageIdentifier(
                pContextToUse,
                szOID_STUFF1
                ) == FALSE )
    {
        printf("Error adding key usage identifier %x\n", GetLastError());
        CertFreeCertificateContext(pContextToUse);
        return( -1 );
    }

    //
    // Get and display all forms
    //

    GetAndDisplayAllEKUForms(pContextToUse);

    //
    // Add another identifier property
    //

    printf("Adding %s enhanced key usage OID to the cert\n", szOID_STUFF2);

    if ( CertAddEnhancedKeyUsageIdentifier(
                pContextToUse,
                szOID_STUFF2
                ) == FALSE )
    {
        printf("Error adding key usage identifier %x\n", GetLastError());
        CertFreeCertificateContext(pContextToUse);
        return( -1 );
    }

    //
    // Get and display all forms
    //

    GetAndDisplayAllEKUForms(pContextToUse);

    if ( pszStore != NULL )
    {
        CertFreeCertificateContext( pContextToUse );

        hStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_A,
                     0,
                     NULL,
                     CERT_SYSTEM_STORE_CURRENT_USER,
                     pszStore
                     );

        if ( hStore == NULL )
        {
            printf( "Error creating system store %lx\n", GetLastError() );
            return( -1 );
        }

        pContextToUse = CertEnumCertificatesInStore( hStore, NULL );
        if ( pContextToUse != NULL )
        {
            pContextToUse = CertDuplicateCertificateContext( pContextToUse );
        }
        else
        {
            printf( "Error enumerating certificate in store\n" );
            CertCloseStore( hStore, 0 );
            return( -1 );
        }

        CertCloseStore( hStore, 0 );

        printf( "Check EKUs after playing with store\n" );
        GetAndDisplayAllEKUForms(pContextToUse);
    }


    //
    // Remove an OID
    //

    printf("Removing %s enhanced key usage OID from the cert\n", szOID_STUFF2);

    if ( CertRemoveEnhancedKeyUsageIdentifier(
                   pContextToUse,
                   szOID_STUFF2
                   ) == FALSE )
    {
        printf("Error removing key usage identifier %x\n", GetLastError());
        CertFreeCertificateContext(pContextToUse);
        return( -1 );
    }

    //
    // Get and display all forms
    //

    GetAndDisplayAllEKUForms(pContextToUse);

    //
    // Remove an OID
    //

    printf("Removing %s enhanced key usage OID from the cert\n", szOID_STUFF1);

    if ( CertRemoveEnhancedKeyUsageIdentifier(
                   pContextToUse,
                   szOID_STUFF1
                   ) == FALSE )
    {
        printf("Error removing key usage identifier %x\n", GetLastError());
        CertFreeCertificateContext(pContextToUse);
        return( -1 );
    }

    //
    // Get and display all forms
    //

    GetAndDisplayAllEKUForms(pContextToUse);

    //
    // Free the certificate context
    //

    if ( pszStore != NULL )
    {
        CertDeleteCertificateFromStore( pContextToUse );
    }

    CertFreeCertificateContext(pContextToUse);

    printf("Test succeeded\n");

    return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\textstor\textstor.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       textstor.cpp
//
//  Contents:   Test External Certificate Store Provider
//
//  Functions:  DllRegisterServer
//              DllUnregisterServer
//              DllMain
//              DllCanUnloadNow
//              I_CertDllOpenTestExtStoreProvW
//
//  History:    09-Sep-97    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// # of bytes for a hash. Such as, SHA (20) or MD5 (16)
#define MAX_HASH_LEN                20

static HMODULE hMyModule;

#define sz_CERT_STORE_PROV_TEST_EXT     "TestExt"
#define TEST_EXT_OPEN_STORE_PROV_FUNC   "I_CertDllOpenTestExtStoreProvW"


//+-------------------------------------------------------------------------
//  External Store Provider handle information
//--------------------------------------------------------------------------


typedef struct _FIND_EXT_INFO FIND_EXT_INFO, *PFIND_EXT_INFO;
struct _FIND_EXT_INFO {
    DWORD               dwContextType;
    void                *pvContext;
};

typedef struct _EXT_STORE {
    HCERTSTORE          hExtCertStore;
} EXT_STORE, *PEXT_STORE;



//+-------------------------------------------------------------------------
//  External Store Provider Functions.
//--------------------------------------------------------------------------
static void WINAPI ExtStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvReadCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pStoreCertContext,
        IN DWORD dwFlags,
        OUT PCCERT_CONTEXT *ppProvCertContext
        );
static BOOL WINAPI ExtStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

static BOOL WINAPI ExtStoreProvReadCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pStoreCrlContext,
        IN DWORD dwFlags,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        );
static BOOL WINAPI ExtStoreProvWriteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvDeleteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvSetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

static BOOL WINAPI ExtStoreProvReadCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pStoreCtlContext,
        IN DWORD dwFlags,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        );
static BOOL WINAPI ExtStoreProvWriteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvDeleteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        );
static BOOL WINAPI ExtStoreProvSetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        );

static BOOL WINAPI ExtStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        );

static BOOL WINAPI ExtStoreProvFindCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCERT_CONTEXT pPrevCertContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCERT_CONTEXT *ppProvCertContext
        );

static BOOL WINAPI ExtStoreProvFreeFindCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        );

static BOOL WINAPI ExtStoreProvGetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        );

static BOOL WINAPI ExtStoreProvFindCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCRL_CONTEXT pPrevCrlContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        );

static BOOL WINAPI ExtStoreProvFreeFindCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        );

static BOOL WINAPI ExtStoreProvGetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        );

static BOOL WINAPI ExtStoreProvFindCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCTL_CONTEXT pPrevCtlContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        );

static BOOL WINAPI ExtStoreProvFreeFindCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        );

static BOOL WINAPI ExtStoreProvGetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        );

static void * const rgpvExtStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    ExtStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    ExtStoreProvReadCert,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    ExtStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    ExtStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    ExtStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    ExtStoreProvReadCrl,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    ExtStoreProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    ExtStoreProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    ExtStoreProvSetCrlProperty,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    ExtStoreProvReadCtl,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    ExtStoreProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    ExtStoreProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    ExtStoreProvSetCtlProperty,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    ExtStoreProvControl,
    // CERT_STORE_PROV_FIND_CERT_FUNC          14
    ExtStoreProvFindCert,
    // CERT_STORE_PROV_FREE_FIND_CERT_FUNC     15
    ExtStoreProvFreeFindCert,
    // CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC  16
    ExtStoreProvGetCertProperty,
    // CERT_STORE_PROV_FIND_CRL_FUNC           17
    ExtStoreProvFindCrl,
    // CERT_STORE_PROV_FREE_FIND_CRL_FUNC      18
    ExtStoreProvFreeFindCrl,
    // CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC   19
    ExtStoreProvGetCrlProperty,
    // CERT_STORE_PROV_FIND_CTL_FUNC           20
    ExtStoreProvFindCtl,
    // CERT_STORE_PROV_FREE_FIND_CTL_FUNC      21
    ExtStoreProvFreeFindCtl,
    // CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC   22
    ExtStoreProvGetCtlProperty
};
#define EXT_STORE_PROV_FUNC_COUNT (sizeof(rgpvExtStoreProvFunc) / \
                                    sizeof(rgpvExtStoreProvFunc[0]))



//+-------------------------------------------------------------------------
//  CertStore allocation and free functions
//--------------------------------------------------------------------------
static void *CSAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void *CSRealloc(
    IN void *pvOrg,
    IN size_t cbBytes
    )
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void CSFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}

//+-------------------------------------------------------------------------
//  Create, add, remove and free external store find info functions
//--------------------------------------------------------------------------


static PFIND_EXT_INFO CreateExtInfo(
    IN DWORD dwContextType,
    IN void *pvContext              // already AddRef'ed
    )
{
    PFIND_EXT_INFO pFindExtInfo;

    if (pFindExtInfo = (PFIND_EXT_INFO) CSAlloc(sizeof(FIND_EXT_INFO))) {
        pFindExtInfo->dwContextType = dwContextType;
        pFindExtInfo->pvContext = pvContext;
    }
    return pFindExtInfo;
}

static void FreeExtInfo(
    IN PFIND_EXT_INFO pFindExtInfo
    )
{
    void *pvContext;

    if (NULL == pFindExtInfo)
        return;

    pvContext = pFindExtInfo->pvContext;
    if (pvContext) {
        switch (pFindExtInfo->dwContextType) {
            case (CERT_STORE_CERTIFICATE_CONTEXT - 1):
                CertFreeCertificateContext((PCCERT_CONTEXT) pvContext);
                break;
            case (CERT_STORE_CRL_CONTEXT - 1):
                CertFreeCRLContext((PCCRL_CONTEXT) pvContext);
                break;
            case (CERT_STORE_CTL_CONTEXT - 1):
                CertFreeCTLContext((PCCTL_CONTEXT) pvContext);
                break;
            default:
                assert(pFindExtInfo->dwContextType < CERT_STORE_CTL_CONTEXT);
        }
    }

    CSFree(pFindExtInfo);
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
        HMODULE hModule,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        hMyModule = hModule;
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        break;
    default:
        break;
    }

    return TRUE;
}

STDAPI  DllCanUnloadNow(void)
{
    // Return S_FALSE inhibit unloading.
    // return S_FALSE;
    return S_OK;
}

static HRESULT HError()
{
    DWORD dw = GetLastError();

    HRESULT hr;
    if ( dw <= 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;

    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}

static HRESULT GetDllFilename(
    OUT WCHAR wszModule[_MAX_PATH]
    )
{
    char szModule[_MAX_PATH];
    LPSTR pszModule;
    int cchModule;

    // Get name of this DLL.
    if (0 == GetModuleFileNameA(hMyModule, szModule, _MAX_PATH))
        return HError();

    // Strip off the Dll filename's directory components
    cchModule = strlen(szModule);
    pszModule = szModule + cchModule;
    while (cchModule-- > 0) {
        pszModule--;
        if ('\\' == *pszModule || ':' == *pszModule) {
            pszModule++;
            break;
        }
    }
    if (0 >= MultiByteToWideChar(
            CP_ACP,
            0,                      // dwFlags
            pszModule,
            -1,                     // null terminated
            wszModule,
            _MAX_PATH))
        return HError();

    return S_OK;
}

//+-------------------------------------------------------------------------
//  DllRegisterServer
//--------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    HRESULT hr;
    WCHAR wszModule[_MAX_PATH];

    if (FAILED(hr = GetDllFilename(wszModule)))
        return hr;

    if (!CryptRegisterOIDFunction(
            0,                                // dwEncodingType
            CRYPT_OID_OPEN_STORE_PROV_FUNC,
            sz_CERT_STORE_PROV_TEST_EXT,
            wszModule,
            TEST_EXT_OPEN_STORE_PROV_FUNC
            )) {
        if (ERROR_FILE_EXISTS != GetLastError())
            return HError();
    }

    return S_OK;
}

//+-------------------------------------------------------------------------
//  DllUnregisterServer
//--------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    WCHAR wszModule[_MAX_PATH];

    if (FAILED(hr = GetDllFilename(wszModule)))
        return hr;
    if (!CryptUnregisterOIDFunction(
            0,                                // dwEncodingType
            CRYPT_OID_OPEN_STORE_PROV_FUNC,
            sz_CERT_STORE_PROV_TEST_EXT
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            return HError();
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//  Implement the "test" external store by opening the corresponding system
//  registry store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenTestExtStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    PEXT_STORE pExtStore = NULL;

    if (0 == (dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK))
        dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
    dwFlags |= CERT_STORE_NO_CRYPT_RELEASE_FLAG;

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvPara
            );
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_DELETED_FLAG;
        if (0 == GetLastError())
            return TRUE;
        else
            return FALSE;
    }

    if (NULL == (pExtStore = (PEXT_STORE) CSAlloc(sizeof(EXT_STORE))))
        goto OutOfMemory;
    memset(pExtStore, 0, sizeof(EXT_STORE));

    if (NULL == (pExtStore->hExtCertStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvPara
            )))
        goto OpenStoreError;

    pStoreProvInfo->cStoreProvFunc = EXT_STORE_PROV_FUNC_COUNT;
    pStoreProvInfo->rgpvStoreProvFunc = (void **) rgpvExtStoreProvFunc;
    pStoreProvInfo->hStoreProv = (HCERTSTOREPROV) pExtStore;
    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_EXTERNAL_FLAG;
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    ExtStoreProvClose((HCERTSTOREPROV) pExtStore, 0);
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(OpenStoreError)
}


//+-------------------------------------------------------------------------
//  Close the registry's store by closing its opened registry subkeys
//--------------------------------------------------------------------------
static void WINAPI ExtStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    if (pExtStore) {
        if (pExtStore->hExtCertStore)
            CertCloseStore(pExtStore->hExtCertStore, 0);
        CSFree(pExtStore);
    }
}

//+---------------------------------------------------------------------------
//  Find certificate in system store corresponding to pCertContext
//----------------------------------------------------------------------------
static PCCERT_CONTEXT FindCorrespondingCertificate (
    IN HCERTSTORE hExtCertStore,
    IN PCCERT_CONTEXT pCertContext
    )
{
    DWORD           cbHash = MAX_HASH_LEN;
    BYTE            aHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB HashBlob;

    if ( CertGetCertificateContextProperty(
             pCertContext,
             CERT_HASH_PROP_ID,
             aHash,
             &cbHash
             ) == FALSE )
    {
        return( NULL );
    }

    HashBlob.cbData = cbHash;
    HashBlob.pbData = aHash;

    return( CertFindCertificateInStore(
                hExtCertStore,
                X509_ASN_ENCODING,
                0,
                CERT_FIND_HASH,
                &HashBlob,
                NULL
                ) );
}

//+---------------------------------------------------------------------------
//  Find CRL in system store corresponding to pCrlContext
//----------------------------------------------------------------------------
static PCCRL_CONTEXT FindCorrespondingCrl (
    IN HCERTSTORE hExtCertStore,
    IN PCCRL_CONTEXT pCrlContext
    )
{
    DWORD         cbHash = MAX_HASH_LEN;
    BYTE          aHash[MAX_HASH_LEN];
    DWORD         cbFindHash = MAX_HASH_LEN;
    BYTE          aFindHash[MAX_HASH_LEN];
    PCCRL_CONTEXT pFindCrl = NULL;
    DWORD         dwFlags = 0;

    if ( CertGetCRLContextProperty(
             pCrlContext,
             CERT_HASH_PROP_ID,
             aHash,
             &cbHash
             ) == FALSE )
    {
        return( NULL );
    }

    while ( ( pFindCrl = CertGetCRLFromStore(
                             hExtCertStore,
                             NULL,
                             pFindCrl,
                             &dwFlags
                             ) ) != NULL )
    {
        if ( CertGetCRLContextProperty(
                 pFindCrl,
                 CERT_HASH_PROP_ID,
                 aFindHash,
                 &cbFindHash
                 ) == TRUE )
        {
            if ( cbHash == cbFindHash )
            {
                if ( memcmp( aHash, aFindHash, cbHash ) == 0 )
                {
                    return( pFindCrl );
                }
            }
        }
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//  Find CTL in system store corresponding to pCtlContext
//----------------------------------------------------------------------------
static PCCTL_CONTEXT FindCorrespondingCtl (
    IN HCERTSTORE hExtCertStore,
    IN PCCTL_CONTEXT pCtlContext
    )
{
    DWORD           cbHash = MAX_HASH_LEN;
    BYTE            aHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB HashBlob;

    if ( CertGetCTLContextProperty(
             pCtlContext,
             CERT_SHA1_HASH_PROP_ID,
             aHash,
             &cbHash
             ) == FALSE )
    {
        return( NULL );
    }

    HashBlob.cbData = cbHash;
    HashBlob.pbData = aHash;

    return( CertFindCTLInStore(
                hExtCertStore,
                X509_ASN_ENCODING,
                0,
                CTL_FIND_SHA1_HASH,
                &HashBlob,
                NULL
                ) );
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the certificate and its properties from
//  the registry and create a new certificate context.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvReadCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pStoreCertContext,
        IN DWORD dwFlags,
        OUT PCCERT_CONTEXT *ppProvCertContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCERT_CONTEXT pProvCertContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    pProvCertContext = FindCorrespondingCertificate(
        pExtStore->hExtCertStore, pStoreCertContext);

    *ppProvCertContext = pProvCertContext;
    return NULL != pProvCertContext;
}

//+-------------------------------------------------------------------------
//  Serialize the encoded certificate and its properties and write to
//  the registry.
//
//  Called before the certificate is written to the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    DWORD dwAddDisposition;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (dwFlags & CERT_STORE_PROV_WRITE_ADD_FLAG)
        dwAddDisposition = (dwFlags >> 16) & 0xFFFF;
    else
        dwAddDisposition = 0;

    return CertAddCertificateContextToStore(
        pExtStore->hExtCertStore,
        pCertContext,
        dwAddDisposition,
        NULL                // ppStoreContext
        );
}


//+-------------------------------------------------------------------------
//  Delete the specified certificate from the registry.
//
//  Called before the certificate is deleted from the store.
//+-------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCERT_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCertificate(
            pExtStore->hExtCertStore, pCertContext))
        return CertDeleteCertificateFromStore(pExtContext);
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Read the specified certificate from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the certificate to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the certificate in the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCERT_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCertificate(
            pExtStore->hExtCertStore, pCertContext)) {
        BOOL fResult;

        fResult = CertSetCertificateContextProperty(
            pExtContext,
            dwPropId,
            dwFlags,
            pvData
            );
        CertFreeCertificateContext(pExtContext);
        return fResult;
    } else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the CRL and its properties from
//  the registry and create a new CRL context.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvReadCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pStoreCrlContext,
        IN DWORD dwFlags,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCRL_CONTEXT pProvCrlContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    pProvCrlContext = FindCorrespondingCrl(
        pExtStore->hExtCertStore, pStoreCrlContext);

    *ppProvCrlContext = pProvCrlContext;
    return NULL != pProvCrlContext;
}

//+-------------------------------------------------------------------------
//  Serialize the encoded CRL and its properties and write to
//  the registry.
//
//  Called before the CRL is written to the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvWriteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    DWORD dwAddDisposition;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (dwFlags & CERT_STORE_PROV_WRITE_ADD_FLAG)
        dwAddDisposition = (dwFlags >> 16) & 0xFFFF;
    else
        dwAddDisposition = 0;

    return CertAddCRLContextToStore(
        pExtStore->hExtCertStore,
        pCrlContext,
        dwAddDisposition,
        NULL                // ppStoreContext
        );
}


//+-------------------------------------------------------------------------
//  Delete the specified CRL from the registry.
//
//  Called before the CRL is deleted from the store.
//+-------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvDeleteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCRL_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCrl(
            pExtStore->hExtCertStore, pCrlContext))
        return CertDeleteCRLFromStore(pExtContext);
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Read the specified CRL from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the CRL to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the CRL in the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvSetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCRL_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCrl(
            pExtStore->hExtCertStore, pCrlContext)) {
        BOOL fResult;

        fResult = CertSetCRLContextProperty(
            pExtContext,
            dwPropId,
            dwFlags,
            pvData
            );
        CertFreeCRLContext(pExtContext);
        return fResult;
    } else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the CTL and its properties from
//  the registry and create a new CTL context.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvReadCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pStoreCtlContext,
        IN DWORD dwFlags,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCTL_CONTEXT pProvCtlContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    pProvCtlContext = FindCorrespondingCtl(
        pExtStore->hExtCertStore, pStoreCtlContext);

    *ppProvCtlContext = pProvCtlContext;
    return NULL != pProvCtlContext;
}

//+-------------------------------------------------------------------------
//  Serialize the encoded CTL and its properties and write to
//  the registry.
//
//  Called before the CTL is written to the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvWriteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    DWORD dwAddDisposition;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (dwFlags & CERT_STORE_PROV_WRITE_ADD_FLAG)
        dwAddDisposition = (dwFlags >> 16) & 0xFFFF;
    else
        dwAddDisposition = 0;

    return CertAddCTLContextToStore(
        pExtStore->hExtCertStore,
        pCtlContext,
        dwAddDisposition,
        NULL                // ppStoreContext
        );
}


//+-------------------------------------------------------------------------
//  Delete the specified CTL from the registry.
//
//  Called before the CTL is deleted from the store.
//+-------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvDeleteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCTL_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCtl(
            pExtStore->hExtCertStore, pCtlContext))
        return CertDeleteCTLFromStore(pExtContext);
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Read the specified CTL from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the CTL to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the CTL in the store.
//--------------------------------------------------------------------------
static BOOL WINAPI ExtStoreProvSetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PCCTL_CONTEXT pExtContext;

    assert(pExtStore && pExtStore->hExtCertStore);
    if (pExtContext = FindCorrespondingCtl(
            pExtStore->hExtCertStore, pCtlContext)) {
        BOOL fResult;

        fResult = CertSetCTLContextProperty(
            pExtContext,
            dwPropId,
            dwFlags,
            pvData
            );
        CertFreeCTLContext(pExtContext);
        return fResult;
    } else
        return FALSE;
}


static BOOL WINAPI ExtStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    assert(pExtStore && pExtStore->hExtCertStore);
    return CertControlStore(
        pExtStore->hExtCertStore,
        dwFlags,
        dwCtrlType,
        pvCtrlPara
        );
}

static BOOL WINAPI ExtStoreProvFindCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCERT_CONTEXT pPrevCertContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCERT_CONTEXT *ppProvCertContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) *ppvStoreProvFindInfo;
    PCCERT_CONTEXT pPrevExtContext;
    PCCERT_CONTEXT pProvCertContext;

    if (pFindExtInfo) {
        assert((CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        pPrevExtContext = (PCCERT_CONTEXT) pFindExtInfo->pvContext;
        pFindExtInfo->pvContext = NULL;
    } else
        pPrevExtContext = NULL;

    assert(pExtStore);
    assert(pPrevCertContext == pPrevExtContext);

    if (pProvCertContext = CertFindCertificateInStore(
            pExtStore->hExtCertStore,
            pFindInfo->dwMsgAndCertEncodingType,
            pFindInfo->dwFindFlags,
            pFindInfo->dwFindType,
            pFindInfo->pvFindPara,
            pPrevExtContext
            )) {
        if (pFindExtInfo)
            // Re-use existing Find Info
            pFindExtInfo->pvContext = (void *) CertDuplicateCertificateContext(
                pProvCertContext);
        else {
            if (pFindExtInfo = CreateExtInfo(
                    CERT_STORE_CERTIFICATE_CONTEXT - 1,
                    (void *) pProvCertContext
                    ))
                pProvCertContext = CertDuplicateCertificateContext(
                    pProvCertContext);
            else {
                CertFreeCertificateContext(pProvCertContext);
                pProvCertContext = NULL;
            }
        }
    } else if (pFindExtInfo) {
        ExtStoreProvFreeFindCert(
            hStoreProv,
            pPrevCertContext,
            pFindExtInfo,
            0                       // dwFlags
            );
        pFindExtInfo = NULL;
    }

    *ppProvCertContext = pProvCertContext;
    *ppvStoreProvFindInfo = pFindExtInfo;
    return NULL != pProvCertContext;
}

static BOOL WINAPI ExtStoreProvFreeFindCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        )
{
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) pvStoreProvFindInfo;

    assert(pFindExtInfo);
    if (pFindExtInfo) {
        assert((CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        FreeExtInfo(pFindExtInfo);
    }
    return TRUE;
}

static BOOL WINAPI ExtStoreProvGetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        )
{
    *pcbData = 0;
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
    return FALSE;
}

static PCCRL_CONTEXT WINAPI FindCrlInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCRL_CONTEXT pPrevCrlContext
    )
{
    DWORD dwFlags = 0;

    switch (dwFindType) {
        case CRL_FIND_ANY:
            return CertGetCRLFromStore(
                hCertStore,
                NULL,               // pIssuerContext,
                pPrevCrlContext,
                &dwFlags
                );
            break;

        case CRL_FIND_ISSUED_BY:
            {
                PCCERT_CONTEXT pIssuer = (PCCERT_CONTEXT) pvFindPara;

                return CertGetCRLFromStore(
                    hCertStore,
                    pIssuer,
                    pPrevCrlContext,
                    &dwFlags
                    );
            }
            break;

        case CRL_FIND_EXISTING:
            {
                PCCRL_CONTEXT pCrl = pPrevCrlContext;

                while (pCrl = CertGetCRLFromStore(
                        hCertStore,
                        NULL,               // pIssuerContext,
                        pCrl,
                        &dwFlags)) {
                    PCCRL_CONTEXT pNew = (PCCRL_CONTEXT) pvFindPara;
                    if (pNew->dwCertEncodingType == pCrl->dwCertEncodingType &&
                            CertCompareCertificateName(
                                pNew->dwCertEncodingType,
                                &pCrl->pCrlInfo->Issuer,
                                &pNew->pCrlInfo->Issuer))
                        return pCrl;
                }
                return NULL;
            }
            break;

        default:
            SetLastError((DWORD) ERROR_NOT_SUPPORTED);
            return NULL;
    }

}

static BOOL WINAPI ExtStoreProvFindCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCRL_CONTEXT pPrevCrlContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) *ppvStoreProvFindInfo;
    PCCRL_CONTEXT pPrevExtContext;
    PCCRL_CONTEXT pProvCrlContext;

    if (pFindExtInfo) {
        assert((CERT_STORE_CRL_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        pPrevExtContext = (PCCRL_CONTEXT) pFindExtInfo->pvContext;
        pFindExtInfo->pvContext = NULL;
    } else
        pPrevExtContext = NULL;

    assert(pExtStore);
    assert(pPrevCrlContext == pPrevExtContext);

    if (pProvCrlContext = FindCrlInStore(
            pExtStore->hExtCertStore,
            pFindInfo->dwMsgAndCertEncodingType,
            pFindInfo->dwFindFlags,
            pFindInfo->dwFindType,
            pFindInfo->pvFindPara,
            pPrevExtContext
            )) {
        if (pFindExtInfo)
            // Re-use existing Find Info
            pFindExtInfo->pvContext = (void *) CertDuplicateCRLContext(
                pProvCrlContext);
        else {
            if (pFindExtInfo = CreateExtInfo(
                    CERT_STORE_CRL_CONTEXT - 1,
                    (void *) pProvCrlContext
                    ))
                pProvCrlContext = CertDuplicateCRLContext(
                    pProvCrlContext);
            else {
                CertFreeCRLContext(pProvCrlContext);
                pProvCrlContext = NULL;
            }
        }
    } else if (pFindExtInfo) {
        ExtStoreProvFreeFindCrl(
            hStoreProv,
            pPrevCrlContext,
            pFindExtInfo,
            0                       // dwFlags
            );
        pFindExtInfo = NULL;
    }

    *ppProvCrlContext = pProvCrlContext;
    *ppvStoreProvFindInfo = pFindExtInfo;
    return NULL != pProvCrlContext;
}

static BOOL WINAPI ExtStoreProvFreeFindCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        )
{
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) pvStoreProvFindInfo;

    assert(pFindExtInfo);
    if (pFindExtInfo) {
        assert((CERT_STORE_CRL_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        FreeExtInfo(pFindExtInfo);
    }
    return TRUE;
}

static BOOL WINAPI ExtStoreProvGetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        )
{
    *pcbData = 0;
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
    return FALSE;
}

static BOOL WINAPI ExtStoreProvFindCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
        IN PCCTL_CONTEXT pPrevCtlContext,
        IN DWORD dwFlags,
        IN OUT void **ppvStoreProvFindInfo,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        )
{
    PEXT_STORE pExtStore = (PEXT_STORE) hStoreProv;
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) *ppvStoreProvFindInfo;
    PCCTL_CONTEXT pPrevExtContext;
    PCCTL_CONTEXT pProvCtlContext;

    if (pFindExtInfo) {
        assert((CERT_STORE_CTL_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        pPrevExtContext = (PCCTL_CONTEXT) pFindExtInfo->pvContext;
        pFindExtInfo->pvContext = NULL;
    } else
        pPrevExtContext = NULL;

    assert(pExtStore);
    assert(pPrevCtlContext == pPrevExtContext);

    if (pProvCtlContext = CertFindCTLInStore(
            pExtStore->hExtCertStore,
            pFindInfo->dwMsgAndCertEncodingType,
            pFindInfo->dwFindFlags,
            pFindInfo->dwFindType,
            pFindInfo->pvFindPara,
            pPrevExtContext
            )) {
        if (pFindExtInfo)
            // Re-use existing Find Info
            pFindExtInfo->pvContext = (void *) CertDuplicateCTLContext(
                pProvCtlContext);
        else {
            if (pFindExtInfo = CreateExtInfo(
                    CERT_STORE_CTL_CONTEXT - 1,
                    (void *) pProvCtlContext
                    ))
                pProvCtlContext = CertDuplicateCTLContext(pProvCtlContext);
            else {
                CertFreeCTLContext(pProvCtlContext);
                pProvCtlContext = NULL;
            }
        }
    } else if (pFindExtInfo) {
        ExtStoreProvFreeFindCtl(
            hStoreProv,
            pPrevCtlContext,
            pFindExtInfo,
            0                       // dwFlags
            );
        pFindExtInfo = NULL;
    }

    *ppProvCtlContext = pProvCtlContext;
    *ppvStoreProvFindInfo = pFindExtInfo;
    return NULL != pProvCtlContext;
}

static BOOL WINAPI ExtStoreProvFreeFindCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN void *pvStoreProvFindInfo,
        IN DWORD dwFlags
        )
{
    PFIND_EXT_INFO pFindExtInfo = (PFIND_EXT_INFO) pvStoreProvFindInfo;

    assert(pFindExtInfo);
    if (pFindExtInfo) {
        assert((CERT_STORE_CTL_CONTEXT - 1) ==
            pFindExtInfo->dwContextType);
        FreeExtInfo(pFindExtInfo);
    }
    return TRUE;
}

static BOOL WINAPI ExtStoreProvGetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        OUT void *pvData,
        IN OUT DWORD *pcbData
        )
{
    *pcbData = 0;
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tdecode\tdecode.h ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tdecode.h
//
//  Contents:   The header of tdecode.cpp.  The API testing of CryptEncodeObject/CryptDecodeObject.  
//
//  History:    22-January-97   xiaohs   created
//              
//--------------------------------------------------------------------------

#ifndef __TDECODE_H__
#define __TDECODE_H__


#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <assert.h>


#include "wincrypt.h"
#include "asn1code.h"


//--------------------------------------------------------------------------
//	  Contant Defines
//--------------------------------------------------------------------------
#define	CRYPT_DECODE_COPY_FLAG			0 
#define	MSG_ENCODING_TYPE				PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING
#define	CRYPT_ENCODE_TYPE				X509_ASN_ENCODING	
#define	LENGTH_LESS						1
#define	LENGTH_MORE						100
#define INVALID_LPSZSTRUCTTYPE			((LPCSTR) 5000)

#define	CERT_CRL_FILE					0x1
#define	CERT_REQUEST_FILE				0x2
#define	SIGNED_MSG_FILE					0x4

#define	CERT_INFO_STRUCT				0x1
#define	CRL_INFO_STRUCT					0x2
#define	CERT_REQUEST_INFO_STRUCT		0x4

#define	CROW							16

char	szSubsystemProtocol[] = "MY";
char	szEncodedSizeInconsistent[] = "The two encoded BLOBs have different size!\n";
char	szEncodedContentInconsistent[] = "The two encoded BLOBs have different content!\n";

//--------------------------------------------------------------------------
//	 Macros
//--------------------------------------------------------------------------

//Macros for memory management
#define SAFE_FREE(p1)	{if(p1) {free(p1);p1=NULL;}}  
#define SAFE_ALLOC(p1) malloc(p1)
#define	CHECK_POINTER(pv) { if(!pv) goto TCLEANUP;}


//Macros for error checking
#define TESTC(rev,exp)   {if(!TCHECK(rev,exp)) goto TCLEANUP; }
#define TCHECK(rev,exp)	 (Validate(GetLastError(), (rev)==(exp), (char *)(__FILE__), __LINE__))
#define TCHECKALL(rev, exp1, exp2) (Validate((DWORD) (rev), ((rev)==(exp1)||(rev)==(exp2)), (char *)(__FILE__), __LINE__))	
#define	PROCESS_ERR(ErrMsg) {printf(ErrMsg);g_dwErrCnt++;}
#define	PROCESS_ERR_GOTO(ErrMsg)	{PROCESS_ERR(ErrMsg); goto TCLEANUP;}




//--------------------------------------------------------------------------
//	Inline Function 
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//	 Function Prototype
//--------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//Error Manipulations
void	DisplayTestResult(DWORD	dwErrCnt);
BOOL	Validate(DWORD dwErr, BOOL	fSame, char *szFile, DWORD	dwLine);
static	void Usage(void);
void	OutputError(LPCSTR	lpszStructType, DWORD cbSecondEncoded, DWORD cbEncoded,
					BYTE *pbSecondEncoded, BYTE *pbEncoded);

void	PrintBytes(LPCSTR pszHdr, BYTE *pb, DWORD cbSize);

///////////////////////////////////////////////////////////////////////////////
//Certificate Manipulations
BOOL	DecodeCertFile(LPSTR	pszFileName,BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck);

BOOL	DecodeCertReqFile(LPSTR	pszFileName,BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck);

BOOL	DecodeSignedMsgFile(LPSTR	pszFileName, BOOL	fStructLengthCheck,
					BOOL	fBLOBLengthCheck);


BOOL	DecodeBLOB(LPCSTR	lpszStructType,DWORD cbEncoded, BYTE *pbEncoded,
				   DWORD	dwDecodeFlags, DWORD	*pcbStructInfo, void **ppvStructInfo,
				   BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	EncodeStruct(LPCSTR	lpszStructType, void *pStructInfo,DWORD *pcbEncoded,
					 BYTE **ppbEncoded);

BOOL	EncodeAndVerify(LPCSTR	lpszStructType, void *pvStructInfo, DWORD cbEncoded, 
						BYTE *pbEncoded);

BOOL	DecodeX509_CERT(DWORD	dwCertType,DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						void *pInfoStruct);

BOOL	DecodeX509_CERT_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded);

BOOL	DecodeX509_CERT_REQUEST_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded);

BOOL	DecodeX509_CERT_CRL_TO_BE_SIGNED(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck,
						BOOL	cbExpectedEncoded, BYTE *pbExpectedEncoded);

BOOL	DecodeRSA_CSP_PUBLICKEYBLOB(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodePKCS_TIME_REQUEST(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);


BOOL	DecodeX509_NAME(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodePKCS7_SIGNER_INFO(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodeX509_UNICODE_NAME(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);


BOOL	DecodeX509_EXTENSIONS(DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodeCertExtensions(DWORD	cExtension, PCERT_EXTENSION rgExtension, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodeCryptAttribute(PCRYPT_ATTRIBUTE pCryptAttribute,DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);


BOOL	DecodeCRLEntry(PCRL_ENTRY pCrlEntry, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);


BOOL	DecodeBasedOnObjID(LPSTR	szObjId,	DWORD	cbData, BYTE	*pbData,
						DWORD dwDecodeFlags,		BOOL fEncode,
						BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodeCertAltNameEntry(PCERT_ALT_NAME_ENTRY	pCertAltNameEntry,
						DWORD dwDecodeFlags,		BOOL fEncode,
						BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	DecodeGenericBLOB(LPCSTR	lpszStructInfo, DWORD	cbEncoded, BYTE *pbEncoded, DWORD dwDecodeFlags, 
						BOOL fEncode,BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

///////////////////////////////////////////////////////////////////////////////
//General Parameter Testing routines
BOOL	ParameterTest(LPCSTR lpszStructType, DWORD cbEncoded, BYTE *pbEncoded);
BOOL	MismatchTest(LPCSTR lpszStructType, DWORD cbEncoded, BYTE *pbEncoded,
						DWORD	cbStructInfo);

///////////////////////////////////////////////////////////////////////////////
//General Decode/Encode Testing routines
BOOL	RetrieveBLOBfromFile(LPSTR	pszFileName,DWORD *pcbEncoded,BYTE **ppbEncoded);

BOOL	EncodeSignerInfoWAttr(PCMSG_SIGNER_INFO pSignerInfo,DWORD *pbSignerEncoded,
								BYTE **ppbSignerEncoded);

BOOL	CompareTimeStampRequest(CRYPT_TIME_STAMP_REQUEST_INFO *pReqNew,
								CRYPT_TIME_STAMP_REQUEST_INFO *pReqOld);

BOOL	VerifyAlgorithParam(PCRYPT_ALGORITHM_IDENTIFIER pAlgorithm);

BOOL	VerifyPKCS_UTC_TIME(BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	VerifyPKCS_TIME_REQUEST(BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	VerifyAttributes(DWORD	cAttr, PCRYPT_ATTRIBUTE	rgAttr,					
			DWORD dwDecodeFlags, BOOL fEncode, BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	VerifyPublicKeyInfo(PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
							DWORD dwDecodeFlags,	BOOL fEncode,
							BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

BOOL	VerifyCertExtensions(DWORD	cExtension, PCERT_EXTENSION rgExtension,
							 DWORD  dwDecodeFlags,	BOOL fEncode,
							 BOOL	fStructLengthCheck, BOOL	fBLOBLengthCheck);

LPCSTR	MapObjID2StructType(LPSTR	szObjectID);

#endif // __TDECODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tdotoid\tdotoid.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tdotoid.cpp
//
//  Contents:   Convert Dot OID ("1.2.3") to ASN.1 encoded content octets.
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    04-Jan-01   philh   created
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>

#include "wincrypt.h"
#include "certtest.h"
#include "unicode.h"
#include "asn1util.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

const BYTE rgbSeqTag[] = {ASN1UTIL_TAG_SEQ, 0};
const BYTE rgbOIDTag[] = {ASN1UTIL_TAG_OID, 0};

const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractAttrPara[] = {
    // 0 - Attribute ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - type EncodedObjectID,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
};

#define ATTR_OID_VALUE_INDEX        1
#define ATTR_VALUE_COUNT            \
    (sizeof(rgExtractAttrPara) / sizeof(rgExtractAttrPara[0]))

BOOL fDecode = FALSE;

void DotValToEncodedOid(
    LPCSTR pszDotVal
    )
{
    CRYPT_ATTRIBUTE Attr;
    BYTE rgbEncoded[512];
    DWORD cbEncoded;
    CRYPT_DER_BLOB rgValueBlob[ATTR_VALUE_COUNT];
    DWORD cValue;
    DWORD i;
    BYTE *pb;
    DWORD cb;

    // Encode an Attribute that only has the OID.
    Attr.pszObjId = (LPSTR) pszDotVal;
    Attr.cValue = 0;
    Attr.rgValue = NULL;

    cbEncoded = sizeof(rgbEncoded);
    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            PKCS_ATTRIBUTE,
            &Attr,
            rgbEncoded,
            &cbEncoded
            )) {
        printf("\n");
        printf("Asn1Encode(%s)", pszDotVal);
        PrintLastError("");
        return;
    }

    cValue = ATTR_VALUE_COUNT;
    if (0 >= Asn1UtilExtractValues(
            rgbEncoded,
            cbEncoded,
            0,                  // dwFlags
            &cValue,
            rgExtractAttrPara,
            rgValueBlob
            ) || ATTR_OID_VALUE_INDEX >= cValue) {
        printf("\n");
        printf("ExtractValues(%s)", pszDotVal);
        PrintLastError("");
        return;
    }

    pb = rgValueBlob[ATTR_OID_VALUE_INDEX].pbData;
    cb = rgValueBlob[ATTR_OID_VALUE_INDEX].cbData;

    printf("\n// \"%s\"\n{", pszDotVal);
    for (i = 0; i < cb; i++) {
        printf("0x%02X", pb[i]);
        if ((i+1) < cb)
            printf(", ");
    }
    printf("};\n\n");

    if (fDecode) {
        PCRYPT_ATTRIBUTE pDecodedAttr = NULL;
        DWORD cbDecodedAttr;

        if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                PKCS_ATTRIBUTE,
                rgbEncoded,
                cbEncoded,
                CRYPT_DECODE_ALLOC_FLAG,
                (void *) &pDecodedAttr,
                &cbDecodedAttr
                ))
            PrintLastError("CryptDecodeObject");
        else {
            printf("Decoded OID:: %s\n", pDecodedAttr->pszObjId);
            LocalFree(pDecodedAttr);
        }
    }
}


void Usage(void)
{
    int i;

    printf("Usage: tdotoid <OID String 1> <OID String 2> ...\n");
    printf("Options are:\n");
    printf("  -d                    - Decode after encoding\n");
    printf("  -h                    - This message\n");
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{

    int ReturnStatus;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
                case 'd':
                    fDecode = TRUE;
                    break;
                case 'h':
                default:
                    goto BadUsage;
            }
        } else
            DotValToEncodedOid(argv[0]);
    }

    ReturnStatus = 0;
CommonReturn:
    return ReturnStatus;

BadUsage:
    Usage();
    ReturnStatus = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tfindclt\tfindclt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tfindclt.cpp
//
//  Contents:   FindCertsByIssuer, CertFindChainInStore APIs test
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    21-May-96   philh   created
//				07-Jun-96   HelleS	Added printing the command line
//									and Failed or Passed at the end.
//              01-Mar-98   philh   Added to call CertFindChainInStore
//
//--------------------------------------------------------------------------

#define CERT_CHAIN_FIND_BY_ISSUER_PARA_HAS_EXTRA_FIELDS 1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static struct
{
    LPCSTR      pszName;
    DWORD       dwKeySpec;
} KeyTypes[] = {
    "Sign",     AT_SIGNATURE,
    "Xchg",     AT_KEYEXCHANGE
};
#define NKEYTYPES (sizeof(KeyTypes)/sizeof(KeyTypes[0]))

static DWORD dwDisplayFlags = 0;


static void Usage(void)
{
    printf("Usage: tfindclt [options] [<Issuer CertFilename> [<KeyType>]]\n");
    printf("Options are:\n");
    printf("  -CompareKey\n");
    printf("  -ComplexChain\n");
    printf("  -CacheOnly\n");
    printf("  -NoKey\n");
    printf("\n");
    printf("  -c<SystemStore>       - Chain System Store\n");
    printf("  -C<FileSystemStore>   - Chain File System Store\n");
    printf("  -u<OID String>        - Usage OID string -u1.3.6.1.5.5.7.3.3\n");
    printf("  -S[<FileName>]        - Use issuer cert's subject name (default)\n");
    printf("  -I[<FileName>]        - Use issuer cert's issuer name\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("  -h                    - This message\n");
    printf("\n");
    printf("KeyType (case insensitive):\n");

    int i;
    for (i = 0; i < NKEYTYPES; i++)
        printf("  %s\n", KeyTypes[i].pszName);
    printf("\n");
}

//+---------------------------------------------------------------------------
//
//  Synopsis:   Chain Display Functions
//
//----------------------------------------------------------------------------
LPSTR rgszErrorStatus[] = {

    "CERT_TRUST_IS_NOT_TIME_VALID",
    "CERT_TRUST_IS_NOT_TIME_NESTED",
    "CERT_TRUST_IS_REVOKED",
    "CERT_TRUST_IS_NOT_SIGNATURE_VALID",
    "CERT_TRUST_IS_NOT_VALID_FOR_USAGE",
    "CERT_TRUST_IS_UNTRUSTED_ROOT",
    "CERT_TRUST_REVOCATION_STATUS_UNKNOWN",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "CERT_TRUST_IS_PARTIAL_CHAIN",
    "CERT_TRUST_CTL_IS_NOT_TIME_VALID",
    "CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID",
    "CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status",
    "Unknown Error Status"
};

LPSTR rgszInfoStatus[] = {

    "CERT_TRUST_HAS_EXACT_MATCH_ISSUER",// 0x00000001
    "CERT_TRUST_HAS_KEY_MATCH_ISSUER",  // 0x00000002
    "CERT_TRUST_HAS_NAME_MATCH_ISSUER", // 0x00000004
    "Unknown Info Status",              // 0x00000008
    "Unknown Info Status",              // 0x00000010
    "Unknown Info Status",              // 0x00000020
    "Unknown Info Status",              // 0x00000040
    "Unknown Info Status",              // 0x00000080
    "Unknown Info Status",              // 0x00000100
    "Unknown Info Status",              // 0x00000200
    "Unknown Info Status",              // 0x00000400
    "Unknown Info Status",              // 0x00000800
    "Unknown Info Status",              // 0x00001000
    "Unknown Info Status",              // 0x00002000
    "Unknown Info Status",              // 0x00004000
    "Unknown Info Status",              // 0x00008000
    "CERT_TRUST_IS_SELF_SIGNED",        // 0x00010000
    "Unknown Info Status",              // 0x00020000
    "Unknown Info Status",              // 0x00040000
    "Unknown Info Status",              // 0x00080000
    "Unknown Info Status",              // 0x00100000
    "Unknown Info Status",              // 0x00200000
    "Unknown Info Status",              // 0x00400000
    "Unknown Info Status",              // 0x00800000
    "Unknown Info Status",              // 0x01000000
    "Unknown Info Status",              // 0x02000000
    "Unknown Info Status",              // 0x04000000
    "Unknown Info Status",              // 0x08000000
    "CERT_TRUST_IS_COMPLEX_CHAIN",      // 0x10000000
    "Unknown Info Status",              // 0x20000000
    "Unknown Info Status",              // 0x40000000
    "Unknown Info Status"               // 0x80000000
};

void DisplayTrustStatus(
    IN const CERT_TRUST_STATUS *pStatus
    )
{
    DWORD dwMask;
    DWORD cCount;

    printf(
       "Trust Status (E=0x%lx,I=0x%lx)\n\n",
       pStatus->dwErrorStatus,
       pStatus->dwInfoStatus
       );

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwErrorStatus & dwMask )
        {
            if ( strcmp( rgszErrorStatus[ cCount ], "Unknown Error Status" ) != 0 )
            {
                printf("%s\n", rgszErrorStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    dwMask = 1;
    for ( cCount = 0; cCount < 32; cCount++ )
    {
        if ( pStatus->dwInfoStatus & dwMask )
        {
            if ( strcmp( rgszInfoStatus[ cCount ], "Unknown Info Status" ) != 0 )
            {
                printf("%s\n", rgszInfoStatus[ cCount ]);
            }
        }

        dwMask = dwMask << 1;
    }

    printf("\n");
}

void DisplayChainElement(
    IN PCERT_CHAIN_ELEMENT pElement
    )
{
    DisplayCert( pElement->pCertContext, dwDisplayFlags );
    printf("\n");
    DisplayTrustStatus( &pElement->TrustStatus );
}

void DisplaySimpleChain(
    IN PCERT_SIMPLE_CHAIN pChain
    )
{
    DWORD cElement;

    DisplayTrustStatus( &pChain->TrustStatus );
    printf("Chain Element Count = %d\n", pChain->cElement);
    for ( cElement = 0; cElement < pChain->cElement; cElement++ )
    {
        printf("Chain Element [%d]\n", cElement);
        DisplayChainElement( pChain->rgpElement[ cElement ]);
    }
}

void DisplayComplexChain(
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    DWORD cChain;

    if (NULL == pChainContext)
        return;

    DisplayTrustStatus(&pChainContext->TrustStatus );
    printf("\n");
    printf("Simple Chain Count = %d\n\n", pChainContext->cChain );

    for ( cChain = 0; cChain < pChainContext->cChain; cChain++ )
    {
        printf("Simple Chain [%d]\n", cChain);
        DisplaySimpleChain( pChainContext->rgpChain[ cChain ]);
    }
}

#define FIND_BY_ISSUER_ARG    0x1539beef
BOOL WINAPI FindByIssuerCallback(
    IN PCCERT_CONTEXT pCert,
    IN void *pvFindArg
    )
{
    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        printf(">>>>>  FindByIssuerCallback  <<<<<\n");
    if (pvFindArg != (void *) FIND_BY_ISSUER_ARG)
        printf("failed => wrong pvFindArg\n");

    return TRUE;
}

static BOOL CreateChainByIssuer(
    IN HCERTSTORE hChainStore,
    IN DWORD dwFindFlags,
    IN LPCSTR pszUsageIdentifier,
    IN DWORD dwKeySpec,
    IN DWORD cIssuer,
    IN PCERT_NAME_BLOB rgIssuer
    )
{
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    DWORD dwChainIndex = 0;
    DWORD dwIssuerChainIndex = 0;
    DWORD dwIssuerElementIndex = 0;

    CERT_CHAIN_FIND_BY_ISSUER_PARA FindPara;
    memset(&FindPara, 0, sizeof(FindPara));
    FindPara.cbSize = sizeof(FindPara);
    FindPara.pszUsageIdentifier = pszUsageIdentifier;
    FindPara.dwKeySpec = dwKeySpec;
    FindPara.cIssuer = cIssuer;
    FindPara.rgIssuer = rgIssuer;
    FindPara.pfnFindCallback = FindByIssuerCallback;
    FindPara.pvFindArg = (void *) FIND_BY_ISSUER_ARG;
    FindPara.pdwIssuerChainIndex = &dwIssuerChainIndex;
    FindPara.pdwIssuerElementIndex = &dwIssuerElementIndex;

    while (pChainContext = CertFindChainInStore(
            hChainStore,
            dwCertEncodingType,
            dwFindFlags,
            CERT_CHAIN_FIND_BY_ISSUER,
            &FindPara,
            pChainContext
            )) {
        printf("\n");
        printf("=======================   CHAIN[%d,%d] %d   =======================\n",
            dwIssuerChainIndex, dwIssuerElementIndex, dwChainIndex);
        dwChainIndex++;

        DisplayComplexChain(pChainContext);
        dwIssuerChainIndex = 0;
        dwIssuerElementIndex = 0;
    }

    if (0 == dwChainIndex)
        printf(">>>>  No Chains  <<<<\n");

    return TRUE;
}


static BOOL AllocAndGetEncodedIssuer(
    LPSTR pszCertFilename,
    BOOL fUseIssuerName,
    PCERT_NAME_BLOB pIssuer
    )
{
    BOOL fResult;
    BYTE *pbEncodedCert = NULL;
    DWORD cbEncodedCert;
    PCCERT_CONTEXT pCert = NULL;
    BYTE *pbEncodedIssuer;
    DWORD cbEncodedIssuer;


    if (!ReadDERFromFile(pszCertFilename, &pbEncodedCert, &cbEncodedCert)) {
        PrintLastError("AllocAndGetEncodedIssuer::ReadDERFromFile");
        goto ErrorReturn;
    }
    if (NULL == (pCert = CertCreateCertificateContext(
            dwCertEncodingType,
            pbEncodedCert,
            cbEncodedCert
            ))) {
        PrintLastError("AllocAndGetEncodedIssuer::CertCreateCertificateContext");
        goto ErrorReturn;
    }
    if (fUseIssuerName) {
        cbEncodedIssuer = pCert->pCertInfo->Issuer.cbData;
        pbEncodedIssuer = pCert->pCertInfo->Issuer.pbData;
    } else {
        cbEncodedIssuer = pCert->pCertInfo->Subject.cbData;
        pbEncodedIssuer = pCert->pCertInfo->Subject.pbData;
    }
    pIssuer->pbData = (BYTE *) TestAlloc(cbEncodedIssuer);
    if (pIssuer->pbData == NULL) goto ErrorReturn;
    memcpy(pIssuer->pbData, pbEncodedIssuer, cbEncodedIssuer);
    pIssuer->cbData = cbEncodedIssuer;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbEncodedCert)
        TestFree(pbEncodedCert);
    if (pCert)
        CertFreeCertificateContext(pCert);
    return fResult;
}

int _cdecl main(int argc, char * argv[])
{
    HRESULT hr;
    int ReturnStatus;
    BOOL fUseIssuerName = FALSE;
    LPSTR pszCertFilename = NULL;
    LPSTR pszKeyType = NULL;
    DWORD dwKeySpec;

#define MAX_ISSUER_CNT      32
    DWORD cIssuer = 0;
    CERT_NAME_BLOB rgIssuer[MAX_ISSUER_CNT];

    PCERT_CHAIN pCertChains = NULL;
    DWORD cbCertChains;
    DWORD cCertChains;
    DWORD i,j;

    HCERTSTORE hChainStore = NULL;
    LPSTR pszUsageIdentifier = NULL;
    DWORD dwFindFlags = 0;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            if (0 == _stricmp(argv[0]+1, "CompareKey")) {
                dwFindFlags |= CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "ComplexChain")) {
                dwFindFlags |= CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "CacheOnly")) {
                dwFindFlags |= CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG;
            } else if (0 == _stricmp(argv[0]+1, "NoKey")) {
                dwFindFlags |= CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG;
            } else {
                switch(argv[0][1])
                {
                case 'c':
                case 'C':
                    if (hChainStore) {
                        printf("Only one chain store allowed\n");
                        goto BadUsage;
                    }
                    if (NULL == (hChainStore =
                            OpenSystemStoreOrFile(
                                argv[0][1] == 'c',  // fSystemStore
                                argv[0]+2,
                                0                   // dwFlags
                                )))
                        goto BadUsage;
                    break;
                case 'S':
                case 'I':
                    if ('S' == argv[0][1])
                        fUseIssuerName = FALSE;
                    else
                        fUseIssuerName = TRUE;
                    if (argv[0][2]) {
                        if (MAX_ISSUER_CNT <= cIssuer) {
                            printf("Exceeded Maximum Issuer Count %d\n",
                                MAX_ISSUER_CNT);
                            goto BadUsage;
                        } else  {
                            if (!AllocAndGetEncodedIssuer(argv[0]+2,
                                    fUseIssuerName, &rgIssuer[cIssuer]))
                                goto ErrorReturn;
                            cIssuer++;
                        }
                    }
                    break;
                case 'u':
                    pszUsageIdentifier = argv[0]+2;
                    break;
                case 'b':
                    dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                    break;
                case 'v':
                    dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszCertFilename == NULL)
                pszCertFilename = argv[0];
            else if(pszKeyType == NULL)
                pszKeyType = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    printf("command line: %s\n", GetCommandLine());


    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        dwDisplayFlags &= ~DISPLAY_BRIEF_FLAG;


    if (pszCertFilename == NULL || *pszCertFilename == '\0') {
        if (0 == cIssuer) {
            rgIssuer[0].cbData = 0;
            rgIssuer[0].pbData = NULL;
            printf("Match any Issuer\n");
        }
    } else if (MAX_ISSUER_CNT <= cIssuer) {
        printf("Exceeded Maximum Issuer Count %d\n", MAX_ISSUER_CNT);
        goto BadUsage;
    } else  {
        if (!AllocAndGetEncodedIssuer(pszCertFilename, fUseIssuerName,
                &rgIssuer[cIssuer]))
            goto ErrorReturn;
        cIssuer++;
    }

    if (NULL == hChainStore && 1 < cIssuer) {
        printf("Only one issuer for FindCertsByIssuer\n");
        goto BadUsage;
    }

    dwKeySpec = 0;
    if (pszKeyType) {
        DWORD KeyIdx;
        for (KeyIdx = 0; KeyIdx < NKEYTYPES; KeyIdx++) {
            if (_stricmp(pszKeyType, KeyTypes[KeyIdx].pszName) == 0) {
                dwKeySpec = KeyTypes[KeyIdx].dwKeySpec;
                break;
            }
        }
        if (dwKeySpec == 0) {
            printf("Bad KeyType: %s\n", pszKeyType);
            goto BadUsage;
        }
    } else
        printf("Match any key type\n");

    if (hChainStore) {
        if (CreateChainByIssuer(
                hChainStore,
                dwFindFlags,
                pszUsageIdentifier,
                dwKeySpec,
                cIssuer,
                rgIssuer
                ))
            goto SuccessReturn;
        else
            goto ErrorReturn;
    }


    cbCertChains = 0;
    hr = FindCertsByIssuer(
        NULL,               // pCertChains
        &cbCertChains,
        &cCertChains,
        rgIssuer[0].pbData,
        rgIssuer[0].cbData,
        NULL,               // pwszPurpose   "ClientAuth" or "CodeSigning"
        dwKeySpec
        );
    if (cbCertChains == 0) {
        if (hr == CRYPT_E_NOT_FOUND)
            printf("NO Certificate Chains\n");
        else {
            SetLastError((DWORD) hr);
            PrintLastError("FindCertsByIssuer");
        }
        goto ErrorReturn;
    }

    if (NULL == (pCertChains = (PCERT_CHAIN) TestAlloc(cbCertChains)))
        goto ErrorReturn;
    if (FAILED(hr = FindCertsByIssuer(
            pCertChains,
            &cbCertChains,
            &cCertChains,
            rgIssuer[0].pbData,
            rgIssuer[0].cbData,
            NULL,               // pwszPurpose   "ClientAuth" or "CodeSigning"
            dwKeySpec
            ))) {
        SetLastError((DWORD) hr);
        PrintLastError("FindCertsByIssuer");
        goto ErrorReturn;
    }

    for (i = 0; i < cCertChains; i++) {
        PCRYPT_KEY_PROV_INFO pKeyInfo = &pCertChains[i].keyLocatorInfo;
        printf("\n");
        printf("#####  Chain %d  #####\n", i);
        printf("Key Provider:: %d", pKeyInfo->dwProvType);
        if (pKeyInfo->pwszProvName)
            printf(" %S", pKeyInfo->pwszProvName);
        if (pKeyInfo->dwFlags)
            printf(" Flags: 0x%x", pKeyInfo->dwFlags);
        if (pKeyInfo->pwszContainerName)
            printf(" Container: %S", pKeyInfo->pwszContainerName);
        if (pKeyInfo->cProvParam)
            printf(" Params: %d", pKeyInfo->cProvParam);
        if (pKeyInfo->dwKeySpec)
            printf(" KeySpec: %d", pKeyInfo->dwKeySpec);
        printf("\n");
        for (j = 0; j < pCertChains[i].cCerts; j++) {
            PCCERT_CONTEXT pCert;
            if (pCert = CertCreateCertificateContext(
                    dwCertEncodingType,
                    pCertChains[i].certs[j].pbData,
                    pCertChains[i].certs[j].cbData
                    )) {
                printf("=====  %d  =====\n", j);
                DisplayCert(pCert, dwDisplayFlags);
                CertFreeCertificateContext(pCert);
            } else {
                printf("Unable to decode cert %d\n", j);
                PrintLastError("CertCreateCertificateContext");
            }
        }
    }

SuccessReturn:
    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    while (cIssuer--)
        TestFree(rgIssuer[cIssuer].pbData);
    if (pCertChains)
        TestFree(pCertChains);
    if (hChainStore) {
        if (!CertCloseStore(hChainStore, 0))
            PrintLastError("CertCloseStore(ChainStore)");
    }
    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tfindcer\tfindcer.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tfindcer.cpp
//
//  Contents:   Cert Store Find API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    11-Apr-96   philh   created
//				07-Jun-96   HelleS	Added printing the command line
//									and Failed or Passed at the end.
//              20-Aug-96   jeffspel name changes
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "cryptuiapi.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <memory.h>
#include <time.h>
#include <stddef.h>

static CRYPT_ENCODE_PARA TestEncodePara = {
    offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(TestEncodePara.pfnFree),
    TestAlloc,
    TestFree
};

static BOOL AllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;

    fResult = CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        CRYPT_ENCODE_ALLOC_FLAG,
        &TestEncodePara,
        (void *) ppbEncoded,
        pcbEncoded
        );

    if (!fResult) {
        if ((DWORD_PTR) lpszStructType <= 0xFFFF)
            printf("CryptEncodeObject(StructType: %d)",
                (DWORD)(DWORD_PTR) lpszStructType);
        else
            printf("CryptEncodeObject(StructType: %s)",
                lpszStructType);
        PrintLastError("");
    }

    return fResult;
}


static void Usage(void)
{
    printf("Usage: tfindcer [options] <StoreName> [<Name String>]\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -D<digest>            - Find cert matching Digest (Hash)\n");
    printf("  -S                    - Find cert matching Subject\n");
    printf("  -I                    - Find cert matching Issuer\n");
    printf("  -U<ObjectID>          - Find cert matching Usage Identifiers\n");
    printf("  -F<number>            - Find Flags\n");
    printf("  -f<filename>          - Get matching Name from cert file\n");
    printf("  -o<ObjectID>          - Object Identifier (1.2.3.4)\n");
    printf("  -t<ValueType>         - Attribute value type (printableString - %d)\n", CERT_RDN_PRINTABLE_STRING);
    printf("  -a[<attributeString>] - Attribute value match\n");
    printf("  -A[<attributeString>] - Attribute value match (test unicode)\n");
    printf("  -C                    - Case Insensitive Attribute value match\n");
    printf("  -e<number>            - Cert encoding type\n");
    printf("  -s                    - Open the \"StoreName\" System store\n");
    printf("  -p<filename>          - Put encoded cert to file\n");
    printf("  -d                    - Delete cert\n");
    printf("  -7[<SaveFilename>]    - PKCS# 7 formated save for delete\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("  -u                    - UI Dialog Viewer//Selection\n");
    printf("  -c                    - Verify checks enabled\n");
    printf("  -q                    - Quiet. Don't display certs\n");
    printf("  -xDelete              - Delete CrossCertDistPoint property\n");
    printf("  -x<number>            - CrossCertDistPoint sync delta seconds\n");
    printf("  -x<Url>               - CrossCertDistPoint Url\n");
    printf("  -X<Url>               - CrossCertDistPoint Alternate Url\n");
    printf("\n");
    printf("Default: find all certs in the store\n");
}

static BOOL AllocAndGetEncodedName(
    LPSTR pszCertFilename,
    DWORD dwFindInfo,
    BYTE **ppbEncodedName,
    DWORD *pcbEncodedName)
{
    BOOL fResult;
    BYTE *pbEncodedCert = NULL;
    DWORD cbEncodedCert;
    PCCERT_CONTEXT pCert = NULL;
    BYTE *pbAllocEncodedName = NULL;
    BYTE *pbEncodedName;
    DWORD cbEncodedName;


    if (!ReadDERFromFile(pszCertFilename, &pbEncodedCert, &cbEncodedCert)) {
        PrintLastError("AllocAndGetEncodedName::ReadDERFromFile");
        goto ErrorReturn;
    }
    if (NULL == (pCert = CertCreateCertificateContext(
            dwCertEncodingType,
            pbEncodedCert,
            cbEncodedCert
            ))) {
        PrintLastError("AllocAndGetEncodedName::CertCreateCertificateContext");
        goto ErrorReturn;
    }
    if (dwFindInfo == CERT_INFO_SUBJECT_FLAG) {
        cbEncodedName = pCert->pCertInfo->Subject.cbData;
        pbEncodedName = pCert->pCertInfo->Subject.pbData;
    } else {
        cbEncodedName = pCert->pCertInfo->Issuer.cbData;
        pbEncodedName = pCert->pCertInfo->Issuer.pbData;
    }
    pbAllocEncodedName = (BYTE *) TestAlloc(cbEncodedName);
    if (pbAllocEncodedName == NULL) goto ErrorReturn;
    memcpy(pbAllocEncodedName, pbEncodedName, cbEncodedName);

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (pbAllocEncodedName) {
        TestFree(pbAllocEncodedName);
        pbAllocEncodedName = NULL;
    }
    cbEncodedName = 0;
    fResult = FALSE;
CommonReturn:
    if (pbEncodedCert)
        TestFree(pbEncodedCert);
    if (pCert)
        CertFreeCertificateContext(pCert);
    *ppbEncodedName = pbAllocEncodedName;
    *pcbEncodedName = cbEncodedName;
    return fResult;
}

static void DisplayFindAttr(DWORD cRDNAttr, CERT_RDN_ATTR rgRDNAttr[])
{
    DWORD i;

    for (i = 0; i < cRDNAttr; i++) {
        LPSTR pszObjId = rgRDNAttr[i].pszObjId;
        LPSTR pszValue = (LPSTR) rgRDNAttr[i].Value.pbData;
        printf("  [%d] ", i);
        if (pszObjId)
            printf("%s ", pszObjId);
        if (rgRDNAttr[i].dwValueType)
            printf("ValueType: %d ", rgRDNAttr[i].dwValueType);
        if (pszValue == NULL)
            pszValue = "<NONE>";
        else {
            if (rgRDNAttr[i].Value.cbData)
                printf("Value: %s\n", pszValue);
            else
                // For UNICODE, cbData is 0.
                printf("Value: %S\n", (LPCSTR) pszValue);
        }
    }
}

typedef PCCERT_CONTEXT (WINAPI *PFN_CRYPT_UI_DLG_SELECT_CERTIFICATE_FROM_STORE)(
    IN HCERTSTORE hCertStore,
    IN OPTIONAL HWND hwnd,              // Defaults to the desktop window
    IN OPTIONAL LPCWSTR pwszTitle,
    IN OPTIONAL LPCWSTR pwszDisplaystring,
    IN DWORD dwDontUseColumn,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

void SelectCertficateFromStoreUI(
    IN HCERTSTORE hStore,
    IN DWORD dwDisplayFlags
    )
{
    HMODULE hDll = NULL;
    PCCERT_CONTEXT pCert = NULL;
    PFN_CRYPT_UI_DLG_SELECT_CERTIFICATE_FROM_STORE
        pfnCryptUIDlgSelectCertificateFromStore;

    if (NULL == (hDll = LoadLibraryA("cryptui.dll"))) {
        PrintLastError("LoadLibraryA(cryptui.dll)");
        goto CommonReturn;
    }

    if (NULL == (pfnCryptUIDlgSelectCertificateFromStore =
            (PFN_CRYPT_UI_DLG_SELECT_CERTIFICATE_FROM_STORE)
                GetProcAddress(hDll, "CryptUIDlgSelectCertificateFromStore"))) {
        PrintLastError("GetProcAddress(CryptUIDlgSelectCertificateFromStore)");
        goto CommonReturn;
    }

    pCert = pfnCryptUIDlgSelectCertificateFromStore(
        hStore,
        NULL,       // hwnd
        NULL,       // pwszTitle
        NULL,       // pwszDisplaystring
        CRYPTUI_SELECT_INTENDEDUSE_COLUMN |
            CRYPTUI_SELECT_FRIENDLYNAME_COLUMN |
            CRYPTUI_SELECT_LOCATION_COLUMN,
        0,          // dwFlags
        NULL        // pvReserved
        );

    if (NULL == pCert)
        PrintLastError("CryptUIDlgSelectCertificateFromStore");
    else {
        printf("=====  Selected Certificate  =====\n");
        DisplayCert(pCert, dwDisplayFlags & ~DISPLAY_UI_FLAG);
    }

CommonReturn:
    if (pCert)
        CertFreeCertificateContext(pCert);
    if (hDll)
        FreeLibrary(hDll);
}


int _cdecl main(int argc, char * argv[])
{
    int ReturnStatus;

    DWORD dwFindCmp = CERT_COMPARE_ANY;
    DWORD dwFindInfo = 0;
    LPSTR pszFindInfo = NULL;
    DWORD dwFindType;
    DWORD dwFindFlags = 0;
    void *pvFindPara = NULL;

    DWORD cbHash = 0;
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB HashBlob;

    CERT_NAME_BLOB NameBlob;
    BYTE *pbEncodedName = NULL;
    DWORD cbEncodedName;

#define MAX_RDN_ATTR 20
    DWORD cRDNAttr = 0;
    CERT_RDN_ATTR rgRDNAttr[MAX_RDN_ATTR + 1];
    memset (rgRDNAttr, 0, sizeof(rgRDNAttr));
    CERT_RDN NameRDN;

#define MAX_USAGE_ID 20
    LPSTR rgpszUsageId[MAX_USAGE_ID];
    CTL_USAGE CtlUsage = {0, rgpszUsageId};

    BOOL fSystemStore = FALSE;
    BOOL fDelete = FALSE;
    LPSTR pszCertFilename = NULL;
    LPSTR pszStoreFilename = NULL;
    LPSTR pszPutFilename = NULL;
    LPSTR pszFindStr = NULL;
    DWORD dwDisplayFlags = 0;
    BOOL fQuiet = FALSE;

    BOOL fPKCS7Save = FALSE;
    LPSTR pszSaveFilename = NULL;

#define MAX_DIST_POINT                  10
#define MAX_DIST_POINT_ALT_NAME_ENTRY   20
    CERT_ALT_NAME_INFO rgDistPoint[MAX_DIST_POINT];
    CERT_ALT_NAME_ENTRY rgDistPointAltNameEntry[MAX_DIST_POINT_ALT_NAME_ENTRY];
    CROSS_CERT_DIST_POINTS_INFO XCertInfo = {0, 0, rgDistPoint};
    DWORD cDistPointAltNameEntry = 0;
    BOOL fAddXCertProp = FALSE;
    BOOL fDeleteXCertProp = FALSE;
    BYTE *pbEncodedXCert = NULL;
    DWORD cbEncodedXCert;

    HANDLE hStore;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'D':
                {
                    char *pszHash = argv[0]+2;
                    int cchHash = strlen(pszHash);
                    char rgch[3];
                    if (!(cchHash == 32 || cchHash == 40)) {
                        printf("Need 32 digits (MD5) or 40 digits (SHA) ");
                        printf("for hash , not %d digits\n", cchHash);
            			goto BadUsage;
                    }
                    if (32 == cchHash)
                        dwFindCmp = CERT_COMPARE_MD5_HASH;
                    else
                        dwFindCmp = CERT_COMPARE_SHA1_HASH;
                    cbHash = 0;
                    while (cchHash > 0) {
                        rgch[0] = *pszHash++;
                        rgch[1] = *pszHash++;
                        rgch[2] = '\0';
                        rgbHash[cbHash++] = (BYTE) strtoul(rgch, NULL, 16);
                        cchHash -= 2;
                    }
                }
                break;
            case 'S':
                dwFindInfo = CERT_INFO_SUBJECT_FLAG;
                pszFindInfo = "subject";
                break;
            case 'I':
                dwFindInfo = CERT_INFO_ISSUER_FLAG;
                pszFindInfo = "issuer";
                break;
            case 'f':
                pszCertFilename = argv[0]+2;
                if (*pszCertFilename == '\0') {
                    printf("Need to specify filename\n");
            		goto BadUsage;
                }
                dwFindCmp = CERT_COMPARE_NAME;
                break;
            case 'o':
                rgRDNAttr[cRDNAttr].pszObjId = argv[0] + 2;
                break;
            case 't':
                rgRDNAttr[cRDNAttr].dwValueType =
                    (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'a':
                if (cRDNAttr >= MAX_RDN_ATTR) {
                    printf("Maximum number of attributes: %d\n", MAX_RDN_ATTR);
            		goto BadUsage;
                }
                rgRDNAttr[cRDNAttr].Value.cbData = strlen(argv[0] + 2);
                if (rgRDNAttr[cRDNAttr].Value.cbData == 0)
                    rgRDNAttr[cRDNAttr].Value.pbData = NULL;
                else
                    rgRDNAttr[cRDNAttr].Value.pbData = (BYTE *) (argv[0] + 2);
                cRDNAttr++;
                dwFindCmp = CERT_COMPARE_ATTR;
                break;
            case 'A':
                if (cRDNAttr >= MAX_RDN_ATTR) {
                    printf("Maximum number of attributes: %d\n", MAX_RDN_ATTR);
            		goto BadUsage;
                }
                rgRDNAttr[cRDNAttr].Value.pbData =
                    (BYTE *) AllocAndSzToWsz(argv[0]+2);
                rgRDNAttr[cRDNAttr].Value.cbData = 0;
                cRDNAttr++;
                dwFindFlags |= CERT_UNICODE_IS_RDN_ATTRS_FLAG;
                dwFindCmp = CERT_COMPARE_ATTR;
                break;
            case 'C':
                dwFindFlags |= CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG;
                break;
            case 'U':
                if (CtlUsage.cUsageIdentifier >= MAX_USAGE_ID) {
                    printf("Maximum number of Usage Identifiers: %d\n",
                        MAX_USAGE_ID);
            		goto BadUsage;
                }
                if (0 < strlen(argv[0] + 2))
                    rgpszUsageId[CtlUsage.cUsageIdentifier++] = argv[0] + 2;
                dwFindCmp = CERT_COMPARE_CTL_USAGE;
                break;
            case 'F':
                dwFindFlags = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'p':
                pszPutFilename = argv[0]+2;
                if (*pszPutFilename == '\0') {
                    printf("Need to specify filename\n");
            		goto BadUsage;
                }
                break;
            case 'd':
                fDelete = TRUE;
                break;
            case '7':
                fPKCS7Save = TRUE;
                if (argv[0][2])
                    pszSaveFilename = argv[0]+2;
                break;
            case 'b':
                dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                break;
            case 'v':
                dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                break;
            case 'u':
                dwDisplayFlags |= DISPLAY_UI_FLAG;
                break;
            case 'c':
                dwDisplayFlags |= DISPLAY_CHECK_FLAG;
                break;
            case 'q':
                fQuiet = TRUE;
                break;
            case 's':
                fSystemStore = TRUE;
                break;
            case 'e':
                dwCertEncodingType = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;

            case 'x':
            case 'X':
                fAddXCertProp = TRUE;
                if (argv[0][2] == 0)
                    ;
                else if (0 == _stricmp(argv[0]+2, "Delete"))
                    fDeleteXCertProp = TRUE;
                else if (isdigit(argv[0][2]))
                    XCertInfo.dwSyncDeltaTime =
                        (DWORD) strtoul(argv[0]+2, NULL, 0);
                else {
                    if (cDistPointAltNameEntry >=
                            MAX_DIST_POINT_ALT_NAME_ENTRY) {
                        printf("Exceeded DistPointAltNameEntry MaxCount(%d)\n",
                            MAX_DIST_POINT_ALT_NAME_ENTRY);
                        goto BadUsage;
                    }
                    if (XCertInfo.cDistPoint == 0 ||
                            argv[0][1] == 'x') {
                        if (XCertInfo.cDistPoint >= MAX_DIST_POINT) {
                            printf("Exceeded DistPoint MaxCount(%d)\n",
                                MAX_DIST_POINT);
                            goto BadUsage;
                        }
                        XCertInfo.rgDistPoint[XCertInfo.cDistPoint].cAltEntry =
                            0;
                        XCertInfo.rgDistPoint[XCertInfo.cDistPoint].rgAltEntry =
                            &rgDistPointAltNameEntry[cDistPointAltNameEntry];
                        XCertInfo.cDistPoint++;
                    }

                    rgDistPointAltNameEntry[cDistPointAltNameEntry].dwAltNameChoice =
                        CERT_ALT_NAME_URL;
                    rgDistPointAltNameEntry[cDistPointAltNameEntry].pwszURL =
                        AllocAndSzToWsz(argv[0]+2);
                    cDistPointAltNameEntry++;
                    XCertInfo.rgDistPoint[XCertInfo.cDistPoint - 1].cAltEntry++;


                }
                break;
                
            case 'h':
            default:
            	goto BadUsage;
            }
        } else {
            if (pszStoreFilename == NULL)
                pszStoreFilename = argv[0];
            else if (pszFindStr == NULL) {
                if (dwFindCmp != CERT_COMPARE_ANY) {
                    printf("Invalid options for <Name String>\n");
                    goto BadUsage;
                }
                dwFindCmp = CERT_COMPARE_NAME_STR_A;
                if (dwFindInfo == 0) {
                    dwFindInfo = CERT_INFO_SUBJECT_FLAG;
                    pszFindInfo = "subject";
                }
                pszFindStr = argv[0];
            } else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }
    
    printf("command line: %s\n", GetCommandLine());

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        dwDisplayFlags &= ~DISPLAY_BRIEF_FLAG;


    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        goto BadUsage;
    }

    if (pszSaveFilename == NULL) {
        if (!fSystemStore)
            pszSaveFilename = pszStoreFilename;
    }

    dwFindType = dwFindCmp << CERT_COMPARE_SHIFT | dwFindInfo;
    switch (dwFindType) {
        case CERT_FIND_ANY:
            if (dwDisplayFlags & DISPLAY_UI_FLAG)
                printf("UI certificate selection\n");
            else
                printf("Finding all certificates\n");
            break;
        case CERT_FIND_MD5_HASH:
        case CERT_FIND_SHA1_HASH:
            {
                if (CERT_FIND_MD5_HASH == dwFindType)
                    printf("Finding MD5 hash:: ");
                else
                    printf("Finding SHA1 hash:: ");

                DWORD cb = cbHash;
                BYTE *pb = rgbHash;
                for (; cb > 0; cb--, pb++)
                    printf("%02X", *pb);
                printf("\n");
            }
            HashBlob.pbData = rgbHash;
            HashBlob.cbData = cbHash;
            pvFindPara = &HashBlob;
            break;
        case CERT_FIND_SUBJECT_NAME:
        case CERT_FIND_ISSUER_NAME:
            printf("Finding %s name using CertFile %s\n",
                pszFindInfo, pszCertFilename);
            if (!AllocAndGetEncodedName(pszCertFilename, dwFindInfo,
                    &pbEncodedName, &cbEncodedName))
                goto ErrorReturn;
            NameBlob.pbData = pbEncodedName;
            NameBlob.cbData = cbEncodedName;
            pvFindPara = &NameBlob;
            break;
        case CERT_FIND_SUBJECT_ATTR:
        case CERT_FIND_ISSUER_ATTR:
            printf("Finding %s name using attributes::\n", pszFindInfo);
            DisplayFindAttr(cRDNAttr, rgRDNAttr);
            NameRDN.cRDNAttr = cRDNAttr;
            NameRDN.rgRDNAttr = rgRDNAttr;
            pvFindPara = &NameRDN;
            break;
        case CERT_FIND_SUBJECT_STR_A:
        case CERT_FIND_ISSUER_STR_A:
            printf("Finding %s name matching:: %s\n", pszFindInfo, pszFindStr);
            pvFindPara = pszFindStr;
            break;
        case CERT_FIND_CTL_USAGE:
            if (dwFindFlags & CERT_FIND_OPTIONAL_CTL_USAGE_FLAG)
                printf("Enabled:: CERT_FIND_OPTIONAL_CTL_USAGE_FLAG\n");
            if (dwFindFlags & CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG)
                printf("Enabled:: CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG\n");
            if (dwFindFlags & CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG)
                printf("Enabled:: CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG\n");
            if (dwFindFlags & CERT_FIND_NO_CTL_USAGE_FLAG)
                printf("Enabled:: CERT_FIND_NO_CTL_USAGE_FLAG\n");
            if (0 == CtlUsage.cUsageIdentifier) {
                printf("No Usage Identifiers\n");
                pvFindPara = NULL;
            } else {
                LPSTR *ppszId = CtlUsage.rgpszUsageIdentifier;
                DWORD i;

                printf("Usage Identifiers::\n");
                for (i = 0; i < CtlUsage.cUsageIdentifier; i++, ppszId++)
                    printf(" [%d] %s\n", i, *ppszId);

                pvFindPara = &CtlUsage;
            }
            break;
        default:
            printf("Bad dwFindType: %x\n", dwFindType);
            goto BadUsage;
    }

    if (fAddXCertProp && !fDeleteXCertProp) {
        printf("Encoding Cross Certificate Property\n");
        if (!AllocAndEncodeObject(
                X509_CROSS_CERT_DIST_POINTS,
                &XCertInfo,
                &pbEncodedXCert,
                &cbEncodedXCert))
            goto ErrorReturn;
    }
        

    // Attempt to open the store
    hStore = OpenStore(fSystemStore, pszStoreFilename);
    if (hStore == NULL)
        return -1;

    if (CERT_FIND_ANY == dwFindType && (dwDisplayFlags & DISPLAY_UI_FLAG)) {
        SelectCertficateFromStoreUI(hStore, dwDisplayFlags);
    } else {
        int i;
        PCCERT_CONTEXT pCert = NULL;
        PCCERT_CONTEXT pDeleteCert = NULL;

        for (i = 0;; i++) {
            pCert = CertFindCertificateInStore(
                hStore,
                dwCertEncodingType,
                dwFindFlags,
                dwFindType,
                pvFindPara,
                pCert
                );
            if (pCert == NULL) {
                if (i == 0) {
                    if (GetLastError() == CRYPT_E_NOT_FOUND)
                        printf(
                            "CertFindCertificateInStore warning => cert not found\n");
                    else
                        PrintLastError("CertFindCertificateInStore");
                }
                break;
            }

            if (fDeleteXCertProp) {
                printf("Deleting Cross Certificate Property from following =>\n");

                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_CROSS_CERT_DIST_POINTS_PROP_ID,
                        0,                          // dwFlags
                        NULL
                        ))
                    PrintLastError("CertSetCertificateContextProperty(Delete)");
            } else if (fAddXCertProp) {
                CRYPT_DATA_BLOB Data;

                printf("Adding Cross Certificate Property to following =>\n");

                Data.pbData = pbEncodedXCert;
                Data.cbData = cbEncodedXCert;
                if (!CertSetCertificateContextProperty(
                        pCert,
                        CERT_CROSS_CERT_DIST_POINTS_PROP_ID,
                        0,                          // dwFlags
                        &Data
                        ))
                    PrintLastError("CertSetCertificateContextProperty");
            }

            if (!fQuiet) {
                printf("=====  %d  =====\n", i);
                DisplayCert(pCert, dwDisplayFlags);
            }

            if (pszPutFilename) {
                printf("Putting\n");
                if (!WriteDERToFile(
                        pszPutFilename,
                        pCert->pbCertEncoded,
                        pCert->cbCertEncoded
                        ))
                    PrintLastError("Put Cert::WriteDERToFile");
            }

            if (fDelete) {
                printf("Deleting\n");
                if (pDeleteCert) {
                    if (!CertDeleteCertificateFromStore(pDeleteCert))
                        PrintLastError("CertDeleteCertificateFromStore");
                }
                pDeleteCert = CertDuplicateCertificateContext(pCert);
            }
        }

        if (pDeleteCert) {
            if (!CertDeleteCertificateFromStore(pDeleteCert))
                PrintLastError("CertDeleteCertificateFromStore");

            if (!fSystemStore)
                SaveStoreEx(hStore, fPKCS7Save, pszSaveFilename);
        } else if (fAddXCertProp || fDeleteXCertProp) {
            if (!fSystemStore)
                SaveStoreEx(hStore, fPKCS7Save, pszSaveFilename);
        }


    }

    if (!CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG))
        PrintLastError("CertCloseStore");
    if (pbEncodedName)
        TestFree(pbEncodedName);

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    while (cRDNAttr--) {
        if (0 == rgRDNAttr[cRDNAttr].Value.cbData &&
                rgRDNAttr[cRDNAttr].Value.pbData)
            // Allocated for unicode
            TestFree(rgRDNAttr[cRDNAttr].Value.pbData);
    }

    while (cDistPointAltNameEntry--)
        TestFree(rgDistPointAltNameEntry[cDistPointAltNameEntry].pwszURL);
    TestFree(pbEncodedXCert);

    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");
            
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tfindctl\tfindctl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       tfindctl.cpp
//
//  Contents:   Find CTL in Cert Store API Tests
//
//              See Usage() for list of test options.
//
//
//  Functions:  main
//
//  History:    06-May-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    printf("Usage: tfindctl [options] <StoreName>\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -D<digest>            - Find CTL matching Digest (Hash)\n");
    printf("  -S<filename>          - Subject certificate file\n");
    printf("  -I<filename>          - CTL issuer certificate file\n");
    printf("  -U<ObjectID>          - Usage Identifiers\n");
    printf("  -L<text>              - List Identifier\n");
    printf("  -A                    - Test via AnySubjectType\n");
    printf("  -e<number>            - Cert encoding type\n");
    printf("  -s                    - Open the \"StoreName\" System store\n");
    printf("  -p<filename>          - Put encoded CTL to file\n");
    printf("  -d                    - Delete CTL\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("  -c                    - Verify checks enabled\n");
    printf("  -q                    - Quiet. Don't display CTLs\n");
    printf("  -fTimeValid           - Only Time Valid CTLs\n");
    printf("  -fTimeInvalid         - Only Time Invalid CTLs\n");
    printf("  -fSameUsage           - Only CTLs with same -U<ObjectID>'s\n");
    printf("\n");
    printf("Default: find all CTLs in the store\n");
}

static PCCERT_CONTEXT GetCertFromFile(
    LPSTR pszCertFilename
    )
{
    BYTE *pbEncodedCert = NULL;
    DWORD cbEncodedCert;
    PCCERT_CONTEXT pCert = NULL;


    if (!ReadDERFromFile(pszCertFilename, &pbEncodedCert, &cbEncodedCert)) {
        PrintLastError("GetCertFromFile::ReadDERFromFile");
        goto ErrorReturn;
    }
    if (NULL == (pCert = CertCreateCertificateContext(
            dwCertEncodingType,
            pbEncodedCert,
            cbEncodedCert
            ))) {
        PrintLastError("GetCertFromFile::CertCreateCertificateContext");
        goto ErrorReturn;
    }

ErrorReturn:
    if (pbEncodedCert)
        TestFree(pbEncodedCert);
    return pCert;
}

// Attempt to read as a file containing an encoded CTL.
static HCERTSTORE OpenCtlStoreFile(
    LPSTR pszStoreFilename)
{
    HCERTSTORE hStore;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (!ReadDERFromFile(pszStoreFilename, &pbEncoded, &cbEncoded))
        return NULL;
    if (NULL == (hStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            )))
        goto CommonReturn;

    if (!CertAddEncodedCTLToStore(
            hStore,
            dwMsgAndCertEncodingType,
            pbEncoded,
            cbEncoded,
            CERT_STORE_ADD_ALWAYS,
            NULL                    // ppCtlContext
            )) {
        CertCloseStore(hStore, 0);
        hStore = NULL;
    }

CommonReturn:
    TestFree(pbEncoded);
    return hStore;
}


int _cdecl main(int argc, char * argv[])
{
    int ReturnStatus;

    DWORD dwFindType = CTL_FIND_ANY;
    DWORD dwFindFlags = 0;
    void *pvFindPara = NULL;

    DWORD cbHash = 0;
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB HashBlob;

    LPSTR pszSubjectFilename = NULL;        // not allocated
    PCCERT_CONTEXT pSubjectCert = NULL;

    LPSTR pszIssuerFilename = NULL;         // not allocated
    PCCERT_CONTEXT pIssuerCert = NULL;

#define MAX_USAGE_ID 20
    LPSTR rgpszUsageId[MAX_USAGE_ID];

    CTL_FIND_USAGE_PARA FindUsagePara;
    CTL_FIND_SUBJECT_PARA FindSubjectPara;

    CTL_ANY_SUBJECT_INFO AnySubjectInfo;

    BOOL fFindUsagePara = FALSE;
    BOOL fFindSubjectPara = FALSE;
    BOOL fAnySubjectType = FALSE;

    BOOL fSystemStore = FALSE;
    BOOL fDelete = FALSE;
    BOOL fTimeValid = FALSE;
    BOOL fTimeInvalid = FALSE;
    LPSTR pszStoreFilename = NULL;          // not allocated
    LPSTR pszPutFilename = NULL;            // not allocated
    DWORD dwDisplayFlags = 0;
    BOOL fQuiet = FALSE;
    HCERTSTORE hStore = NULL;

    memset(&FindUsagePara, 0, sizeof(FindUsagePara));
    FindUsagePara.cbSize = sizeof(FindUsagePara);
    memset(&FindSubjectPara, 0, sizeof(FindSubjectPara));
    FindSubjectPara.cbSize = sizeof(FindSubjectPara);

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'D':
                {
                    char *pszHash = argv[0]+2;
                    int cchHash = strlen(pszHash);
                    char rgch[3];
                    if (!(cchHash == 32 || cchHash == 40)) {
                        printf("Need 32 digits (MD5) or 40 digits (SHA) ");
                        printf("for hash , not %d digits\n", cchHash);
            			goto BadUsage;
                    }
                    if (32 == cchHash)
                        dwFindType = CTL_FIND_MD5_HASH;
                    else
                        dwFindType = CTL_FIND_SHA1_HASH;
                    cbHash = 0;
                    while (cchHash > 0) {
                        rgch[0] = *pszHash++;
                        rgch[1] = *pszHash++;
                        rgch[2] = '\0';
                        rgbHash[cbHash++] = (BYTE) strtoul(rgch, NULL, 16);
                        cchHash -= 2;
                    }
                }
                break;
            case 'U':
                if (FindUsagePara.SubjectUsage.cUsageIdentifier >=
                        MAX_USAGE_ID) {
                    printf("Maximum number of Usage Identifiers: %d\n",
                        MAX_USAGE_ID);
            		goto BadUsage;
                }
                FindUsagePara.SubjectUsage.rgpszUsageIdentifier = rgpszUsageId;
                rgpszUsageId[FindUsagePara.SubjectUsage.cUsageIdentifier++] =
                    argv[0] + 2;
                fFindUsagePara = TRUE;
                break;
            case 'L':
                if (0 == strlen(argv[0] + 2))
                    FindUsagePara.ListIdentifier.cbData =
                        CTL_FIND_NO_LIST_ID_CBDATA;
                else {
                    FindUsagePara.ListIdentifier.cbData = strlen(argv[0] + 2);
                    FindUsagePara.ListIdentifier.pbData = (BYTE *) argv[0] + 2;
                }
                fFindUsagePara = TRUE;
                break;
            case 'I':
                if (0 == strlen(argv[0] + 2))
                    FindUsagePara.pSigner = CTL_FIND_NO_SIGNER_PTR;
                else
                    pszIssuerFilename = argv[0]+2;
                fFindUsagePara = TRUE;
                break;
            case 'S':
                pszSubjectFilename = argv[0]+2;
                if (*pszSubjectFilename == '\0') {
                    printf("Need to specify SubjectFilename\n");
            		goto BadUsage;
                }
                fFindSubjectPara = TRUE;
                break;
            case 'p':
                pszPutFilename = argv[0]+2;
                if (*pszPutFilename == '\0') {
                    printf("Need to specify filename\n");
            		goto BadUsage;
                }
                break;
            case 'A':
                fAnySubjectType = TRUE;
                break;
            case 'd':
                fDelete = TRUE;
                break;
            case 'f':
                if (argv[0][2]) {
                    if (0 == _stricmp(argv[0]+2, "TimeValid"))
                        fTimeValid = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "TimeInvalid"))
                        fTimeInvalid = TRUE;
                    else if (0 == _stricmp(argv[0]+2, "SameUsage"))
                        dwFindFlags |= CTL_FIND_SAME_USAGE_FLAG;
                    else {
                        printf("Need to specify -fTimeValid | -fTimeInvalid | -fSameUsage\n");
                        goto BadUsage;
                    }
                } else {
                    printf("Need to specify -fTimeValid | -fTimeInvalid | -fSameUsage\n");
                    goto BadUsage;
                }
                break;
            case 'b':
                dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                break;
            case 'v':
                dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                break;
            case 'c':
                dwDisplayFlags |= DISPLAY_CHECK_FLAG;
                break;
            case 'q':
                fQuiet = TRUE;
                break;
            case 's':
                fSystemStore = TRUE;
                break;
            case 'e':
                dwCertEncodingType = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'h':
            default:
            	goto BadUsage;
            }
        } else {
            if (pszStoreFilename == NULL)
                pszStoreFilename = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }
    
    printf("command line: %s\n", GetCommandLine());

    if (dwDisplayFlags & DISPLAY_VERBOSE_FLAG)
        dwDisplayFlags &= ~DISPLAY_BRIEF_FLAG;

    if (pszStoreFilename == NULL) {
        printf("missing store filename\n");
        goto BadUsage;
    }

    if (pszIssuerFilename) {
        if (NULL == (pIssuerCert = GetCertFromFile(pszIssuerFilename))) {
            printf("Unable to read/decode IssuerFilename\n");
            goto ErrorReturn;
        }
        FindUsagePara.pSigner = pIssuerCert->pCertInfo;
    }

    if (pszSubjectFilename) {
        if (NULL == (pSubjectCert = GetCertFromFile(pszSubjectFilename))) {
            printf("Unable to read/decode SubjectFilename\n");
            goto ErrorReturn;
        }

        if (fAnySubjectType) {
            memset(&AnySubjectInfo, 0, sizeof(AnySubjectInfo));
            AnySubjectInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;

            AnySubjectInfo.SubjectIdentifier.cbData = MAX_HASH_LEN;
            if (!CertGetCertificateContextProperty(
                    pSubjectCert,
                    CERT_SHA1_HASH_PROP_ID,
                    rgbHash,
                    &AnySubjectInfo.SubjectIdentifier.cbData) ||
                        0 == AnySubjectInfo.SubjectIdentifier.cbData) {
                printf("failed => unable to get SHA1 hash for Subject Cert\n");
                goto ErrorReturn;;
            }
            AnySubjectInfo.SubjectIdentifier.pbData = rgbHash;

            FindSubjectPara.dwSubjectType = CTL_ANY_SUBJECT_TYPE;
            FindSubjectPara.pvSubject = &AnySubjectInfo;
        } else {
            FindSubjectPara.dwSubjectType = CTL_CERT_SUBJECT_TYPE;
            FindSubjectPara.pvSubject = (void *) pSubjectCert;
        }
    }

    if (fFindSubjectPara) {
        if (fFindUsagePara)
            FindSubjectPara.pUsagePara = &FindUsagePara;
        dwFindType = CTL_FIND_SUBJECT;
    } else if (fFindUsagePara)
        dwFindType = CTL_FIND_USAGE;

    switch (dwFindType) {
        case CTL_FIND_ANY:
            printf("Finding all CTLs\n");
            break;
        case CTL_FIND_MD5_HASH:
        case CTL_FIND_SHA1_HASH:
            {
                if (CTL_FIND_MD5_HASH == dwFindType)
                    printf("Finding MD5 hash:: ");
                else
                    printf("Finding SHA1 hash:: ");

                DWORD cb = cbHash;
                BYTE *pb = rgbHash;
                for (; cb > 0; cb--, pb++)
                    printf("%02X", *pb);
                printf("\n");
            }
            HashBlob.pbData = rgbHash;
            HashBlob.cbData = cbHash;
            pvFindPara = &HashBlob;
            break;
        case CTL_FIND_USAGE:
            printf("Finding by Usage\n");
            pvFindPara = &FindUsagePara;
            break;
        case CTL_FIND_SUBJECT:
            if (FindSubjectPara.pUsagePara)
                printf("Finding by Usage and Subject\n");
            else
                printf("Finding by Subject\n");
            pvFindPara = &FindSubjectPara;
            break;
        default:
            printf("Bad dwFindType: %x\n", dwFindType);
            goto BadUsage;
    }

    if (fFindUsagePara) {
        DWORD cUsageId = FindUsagePara.SubjectUsage.cUsageIdentifier;
        if (0 == cUsageId)
            printf("No Usage Identifiers\n");
        else {
            LPSTR *ppszId = FindUsagePara.SubjectUsage.rgpszUsageIdentifier;
            DWORD i;

            printf("Usage Identifiers::\n");
            for (i = 0; i < cUsageId; i++, ppszId++)
                printf(" [%d] %s\n", i, *ppszId);
        }

        if (CTL_FIND_NO_LIST_ID_CBDATA == FindUsagePara.ListIdentifier.cbData)
            printf("Enabled:: CTL_FIND_NO_LIST_ID_CBDATA\n");
        else if (0 == FindUsagePara.ListIdentifier.cbData)
            printf("Matching any ListIdentifier\n");
        else
            printf("Matching ListIdentifier: %s\n",
                FindUsagePara.ListIdentifier.pbData);

        if (CTL_FIND_NO_SIGNER_PTR == FindUsagePara.pSigner)
            printf("Enabled:: CTL_FIND_NO_SIGNER_PTR\n");
        else if (NULL == FindUsagePara.pSigner)
            printf("Matching any Signer\n");
        else
            printf("Matching signer with certificate from %s\n",
                pszIssuerFilename);
    }

    if (fFindSubjectPara) {
        printf("Matching subject with certificate from %s", pszSubjectFilename);
        if (FindSubjectPara.dwSubjectType == CTL_ANY_SUBJECT_TYPE)
            printf("Using CTL_ANY_SUBJECT_TYPE\n");
        else
            printf("\n");
    }
        

    if (!fSystemStore)
        // Attempt to open as encoded CTL file
        hStore = OpenCtlStoreFile(pszStoreFilename);
    else
        hStore = NULL;

    if (NULL == hStore) {
        // Attempt to open the store
        hStore = OpenStore(fSystemStore, pszStoreFilename);
        if (hStore == NULL)
            goto ErrorReturn;
    }

    {
        PCCTL_CONTEXT pCtl = NULL;
        DWORD i = 0;
        while (pCtl = CertFindCTLInStore(
                hStore,
                dwMsgAndCertEncodingType,
                dwFindFlags,
                dwFindType,
                pvFindPara,
                pCtl
                )) {
            if (fTimeValid && !IsTimeValidCtl(pCtl))
                continue;
            if (fTimeInvalid && IsTimeValidCtl(pCtl))
                continue;

            if (!fQuiet) {
                printf("=====  %d  =====\n", i);
                DisplayCtl(pCtl, dwDisplayFlags, hStore);
                if (fFindSubjectPara) {
                    PCTL_ENTRY pEntry;
                
                    pEntry = CertFindSubjectInCTL(
                        dwMsgAndCertEncodingType,
                        FindSubjectPara.dwSubjectType,
                        FindSubjectPara.pvSubject,
                        pCtl,
                        0                           // dwFlags
                        );
                    printf("\n");
                    if (pEntry)
                        printf("Subject Index:: %d\n",
                            pEntry - pCtl->pCtlInfo->rgCTLEntry);
                    else
                        PrintLastError("CertFindSubjectInCTL");
                }
            }
            i++;

            if (pszPutFilename) {
                printf("Putting\n");
                if (!WriteDERToFile(
                        pszPutFilename,
                        pCtl->pbCtlEncoded,
                        pCtl->cbCtlEncoded
                        ))
                    PrintLastError("Put Ctl::WriteDERToFile");
            }

            if (fDelete) {
                PCCTL_CONTEXT pDeleteCtl;
                printf("Deleting\n");
                pDeleteCtl = CertDuplicateCTLContext(pCtl);
                if (!CertDeleteCTLFromStore(pDeleteCtl))
                    PrintLastError("CertDeleteCTLFromStore");
            }
        }

        if (i == 0) {
            if (GetLastError() == CRYPT_E_NOT_FOUND)
                printf("CertFindCTLsInStore warning => CTL not found\n");
            else
                PrintLastError("CertFindCTLsInStore");
        } else if (fDelete && !fSystemStore)
            SaveStore(hStore, pszStoreFilename);
    }

    if (!CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG))
        PrintLastError("CertCloseStore");

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    if (pSubjectCert)
        CertFreeCertificateContext(pSubjectCert);
    if (pIssuerCert)
        CertFreeCertificateContext(pIssuerCert);

    if (!ReturnStatus)
        printf("Passed\n");
    else
        printf("Failed\n");
            
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tkeyid\tkeyid.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       tkeyid.cpp
//
//  Contents:   Key Identifier Property Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    15-Mar-98   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "unicode.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static BOOL fVerify = FALSE;

static void Usage(void)
{
    printf("Usage: tkeyid [options] <TestName>\n");
    printf("\n");
    printf("Options are:\n");
    printf("  -c<Cert Filename>     - Key Identifier obtained from cert\n");
    printf("  -k<Hash>              - Key Identifier Hash\n");
    printf("  -s<SystemStore>       - Get cert properties from system store\n");
    printf("  -S<FileSystemStore>   - Get cert properties from file store\n");
    printf("  -p<Number>            - Property Id\n");
    printf("  -M[<ComputerName>]    - LocalMachine Key Identifiers\n");
    printf("  -f<Number>            - Flags\n");
    printf("  -V                    - Verify KeyProvInfo property\n");
    printf("  -h                    - This message\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("\n");
    printf("TestNames (case insensitive):\n");
    printf("  Set\n");
    printf("  Get\n");
    printf("  Delete\n");
    printf("  DeleteAll\n");
    printf("  DeleteWithoutCert\n");
    printf("  Enum\n");
    printf("\n");
}

static PCCERT_CONTEXT ReadCert(
    IN LPSTR pszCert
    )
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    PCCERT_CONTEXT pCert;

    if (!ReadDERFromFile(pszCert, &pbEncoded, &cbEncoded)) {
        PrintLastError("ReadCert");
        return NULL;
    }

    pCert = CertCreateCertificateContext(
        dwCertEncodingType,
        pbEncoded,
        cbEncoded
        );
    if (pCert == NULL)
        PrintLastError("CertCreateCertificateContext");

    TestFree(pbEncoded);
    return pCert;
}

static BOOL TestSet(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    BOOL fResult = TRUE;

    if (0 == dwPropId) {
        BOOL fProp = FALSE;

        // Copy all the certificate properties to the KeyIdentifier
        while (dwPropId = CertEnumCertificateContextProperties(
                pCert, dwPropId)) {
            fProp = TRUE;
            fResult &= TestSet(
                pKeyIdentifier,
                pCert,
                dwPropId,
                dwFlags,
                pwszComputerName
                );
        }

        if (!fProp)
            printf("Certificate doesn't have any properties\n");
    } else {
        // Attempt to get and copy the specified certificate property
        // to the KeyIdentifier.

        void *pvData = NULL;
        DWORD cbData;
        CRYPT_DATA_BLOB DataBlob;
        void *pvSetData;

        printf("Setting PropId %d (0x%x)\n", dwPropId, dwPropId);
        if (!CertGetCertificateContextProperty(
                pCert,
                dwPropId,
                NULL,                           // pvData
                &cbData
                )) {
            PrintLastError("CertGetCertificateContextProperty");
            goto ErrorReturn;
        }

        if (cbData) {
            if (NULL == (pvData = TestAlloc(cbData)))
                goto ErrorReturn;
            if (!CertGetCertificateContextProperty(
                    pCert,
                    dwPropId,
                    pvData,
                    &cbData
                    )) {
                PrintLastError("CertGetCertificateContextProperty");
                TestFree(pvData);
                goto ErrorReturn;
            }
        }

        if (CERT_KEY_PROV_INFO_PROP_ID != dwPropId) {
            DataBlob.pbData = (BYTE *) pvData;
            DataBlob.cbData = cbData;
            pvSetData = &DataBlob;
        } else
            pvSetData = pvData;

        fResult = CryptSetKeyIdentifierProperty(
            pKeyIdentifier,
            dwPropId,
            dwFlags,
            pwszComputerName,
            NULL,                   // pvReserved
            pvSetData
            );
        TestFree(pvData);
        if (!fResult)
            PrintLastError("CryptSetKeyIdentifierProperty");
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

static BOOL TestDelete(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    BOOL fResult;

    if (0 == dwPropId) {
        printf("Deleting KeyIdentifier and all its properties\n");
        dwFlags |= CRYPT_KEYID_DELETE_FLAG;
    } else
        printf("Deleting PropId %d (0x%x)\n", dwPropId, dwPropId);

    fResult = CryptSetKeyIdentifierProperty(
        pKeyIdentifier,
        dwPropId,
        dwFlags,
        pwszComputerName,
        NULL,                   // pvReserved
        NULL                    // pvData
        );
    if (!fResult) {
        DWORD dwErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwErr)
            fResult = TRUE;
        if (!fResult)
            PrintLastError("CryptSetKeyIdentifierProperty");
    }

    return fResult;
}

static void VerifyKeyProvInfo(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN PCRYPT_KEY_PROV_INFO pKeyProvInfo
    )
{
    BOOL fResult;
    DWORD dwErr;
    DWORD dwAcquireFlags;
    HCRYPTPROV hCryptProv = 0;
    HCRYPTKEY hPubKey = 0;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;

    BYTE rgbHash[MAX_HASH_LEN];
    DWORD cbHash;

    dwAcquireFlags = pKeyProvInfo->dwFlags & ~CERT_SET_KEY_CONTEXT_PROP_ID;

    fResult = CryptAcquireContextU(
            &hCryptProv,
            pKeyProvInfo->pwszContainerName,
            pKeyProvInfo->pwszProvName,
            pKeyProvInfo->dwProvType,
            dwAcquireFlags
            );
    if (!fResult && PROV_RSA_FULL == pKeyProvInfo->dwProvType &&
                (NULL == pKeyProvInfo->pwszProvName ||
                    L'\0' == *pKeyProvInfo->pwszProvName)) {
        dwErr = GetLastError();
        fResult = CryptAcquireContextU(
            &hCryptProv,
            pKeyProvInfo->pwszContainerName,
            MS_ENHANCED_PROV_W,
            PROV_RSA_FULL,
            dwAcquireFlags
            );
        if (!fResult)
            SetLastError(dwErr);
    }

    if (!fResult) {
        PrintLastError("CryptAcquireContext");
        return;
    }


    if (!CryptGetUserKey(
            hCryptProv,
            pKeyProvInfo->dwKeySpec,
            &hPubKey
            )) {
        hPubKey = 0;
        PrintLastError("CryptGetUserKey");
        goto ErrorReturn;
    }

    cbPubKeyStruc = 0;
    if (!CryptExportKey(
            hPubKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            NULL,           // pbData
            &cbPubKeyStruc
            ) || (cbPubKeyStruc == 0)) {
        PrintLastError("CryptExportKey");
        goto ErrorReturn;
    }

    if (NULL == (pPubKeyStruc = (PUBLICKEYSTRUC *) TestAlloc(
            cbPubKeyStruc)))
        goto ErrorReturn;
    if (!CryptExportKey(
            hPubKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            (BYTE *) pPubKeyStruc,
            &cbPubKeyStruc
            )) {
        PrintLastError("CryptExportKey");
        goto ErrorReturn;
    }

    cbHash = sizeof(rgbHash);
    if (!CryptCreateKeyIdentifierFromCSP(
            dwCertEncodingType,
            NULL,                           // pszPubKeyOID
            pPubKeyStruc,
            cbPubKeyStruc,
            0,                              // dwFlags
            NULL,                           // pvReserved
            rgbHash,
            &cbHash
            )) {
        PrintLastError("CryptCreateKeyIdentifierFromCSP");
        goto ErrorReturn;
    }

    if (pKeyIdentifier->cbData == cbHash &&
            0 == memcmp(pKeyIdentifier->pbData, rgbHash, cbHash))
        printf("  Verified KeyIdentifier with CSP\n");
    else {
        printf("  KeyIdentifier mismatch with CSP provider hash::\n");
        PrintBytes("    ", rgbHash, cbHash);
    }

ErrorReturn:
    TestFree(pPubKeyStruc);

    if (hPubKey)
        CryptDestroyKey(hPubKey);
    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);
}

static void DisplayProperty(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN const void *pvData,
    IN DWORD cbData
    )
{
    if (CERT_KEY_PROV_INFO_PROP_ID == dwPropId) {
        PCRYPT_KEY_PROV_INFO pInfo = (PCRYPT_KEY_PROV_INFO) pvData;
        
        printf("  Key Provider:: Type: %d", pInfo->dwProvType);
        if (pInfo->pwszProvName)
            printf(" Name: %S", pInfo->pwszProvName);
        if (pInfo->dwFlags) {
            printf(" Flags: 0x%x", pInfo->dwFlags);
            if (pInfo->dwFlags & CRYPT_MACHINE_KEYSET)
                printf(" (MACHINE_KEYSET)");
            if (pInfo->dwFlags & CERT_SET_KEY_CONTEXT_PROP_ID)
                printf(" (SET_KEY_CONTEXT_PROP)");
            printf(" ");
        }
        if (pInfo->pwszContainerName)
            printf(" Container: %S", pInfo->pwszContainerName);
        if (pInfo->cProvParam)
            printf(" Params: %d", pInfo->cProvParam);
        if (pInfo->dwKeySpec)
            printf(" KeySpec: %d", pInfo->dwKeySpec);
        printf("\n");

        if (fVerify) {
            VerifyKeyProvInfo(pKeyIdentifier, pInfo);
        }
    } else {
        printf("  PropId %d (0x%x) ::\n", dwPropId, dwPropId);
        PrintBytes("    ", (BYTE *) pvData, cbData);
    }
}

static void DisplayKeyIdentifier(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier
    )
{
    DWORD cbKeyId = pKeyIdentifier->cbData;
    BYTE *pbKeyId = pKeyIdentifier->pbData;
    printf("KeyIdentifier:: ");
    if (cbKeyId == 0)
        printf("???");
    else {
        ULONG cb;

        while (cbKeyId > 0) {
            cb = min(4, cbKeyId);
            cbKeyId -= cb;
            for (; cb > 0; cb--, pbKeyId++)
                printf("%02X", *pbKeyId);
            printf(" ");
        }
    }
    printf("\n");
}

static void DisplayKeyIdentifierCerts(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN HCERTSTORE hStore
    )
{
    if (NULL == hStore)
        return;

    PCCERT_CONTEXT pCert = NULL;
    DWORD i = 0;
    while (pCert = CertFindCertificateInStore(
            hStore,
            0,                      // dwCertEncodingType
            0,                      // dwFindFlags
            CERT_FIND_KEY_IDENTIFIER,
            pKeyIdentifier,
            pCert
            )) {
        DWORD cbData = 0;

        printf("\n");

        if (CertGetCertificateContextProperty(
                pCert,
                CERT_ARCHIVED_PROP_ID,
                NULL,                           // pvData
                &cbData
                ))
            printf("----------   ARCHIVED Cert [%d]   ----------\n", i);
        else
            printf("----------   Cert [%d]   ----------\n", i);
        i++;
        DisplayCert(pCert, 0);
    }

    if (0 == i)
        printf(">>>>  No Key Identifier Certificates  <<<<\n");
}

typedef struct _TEST_ENUM_ARG {
    HCERTSTORE  hStore;
    DWORD       dwDisplayFlags;
} TEST_ENUM_ARG, *PTEST_ENUM_ARG;


static BOOL WINAPI TestEnumCallback(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwFlags,
    IN void *pvReserved,
    IN void *pvArg,
    IN DWORD cProp,
    IN DWORD *rgdwPropId,
    IN void **rgpvData,
    IN DWORD *rgcbData
    )
{
    PTEST_ENUM_ARG pArg = (PTEST_ENUM_ARG) pvArg;

    if (pArg->dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        printf("\n");
        printf(
"=========================================================================\n");
    }
    DisplayKeyIdentifier(pKeyIdentifier);

    if (pArg->dwDisplayFlags & DISPLAY_BRIEF_FLAG)
        return TRUE;

    if (0 == cProp)
        printf("No Properties\n");
    else {
        DWORD i;
        for (i = 0; i < cProp; i++) {
            DWORD dwPropId = rgdwPropId[i];
            DisplayProperty(pKeyIdentifier, dwPropId, rgpvData[i], rgcbData[i]);
        }
    }

    if (pArg->dwDisplayFlags & DISPLAY_VERBOSE_FLAG) {
        DisplayKeyIdentifierCerts(pKeyIdentifier, pArg->hStore);
    }

    return TRUE;
}

static HCERTSTORE OpenMyStore(
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    DWORD dwOpenFlags;
    LPWSTR pwszAllocStore = NULL;
    LPWSTR pwszStore;
    HCERTSTORE hStore = NULL;

    pwszStore = L"My";
    if (dwFlags & CRYPT_KEYID_MACHINE_FLAG) {
        if (pwszComputerName) {
            DWORD cchStore;

            cchStore = wcslen(pwszComputerName) + 1 + wcslen(pwszStore) + 1;
            if (pwszAllocStore = (LPWSTR) TestAlloc(
                    cchStore * sizeof(WCHAR))) {
                wcscpy(pwszAllocStore, pwszComputerName);
                wcscat(pwszAllocStore, L"\\");
                wcscat(pwszAllocStore, pwszStore);
                pwszStore = pwszAllocStore;
            }
        }
        dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    } else
        dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;

    dwOpenFlags |= CERT_STORE_READONLY_FLAG | CERT_STORE_ENUM_ARCHIVED_FLAG;

    hStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0,                      // dwCertEncodingType
        0,                      // hCryptProv
        dwOpenFlags,
        (const void *) pwszStore
        );
    if (NULL == hStore) {
        if (dwFlags & CRYPT_KEYID_MACHINE_FLAG)
            printf("Unable to open LocalMachine store: %S\n", pwszStore);
        else
            printf("Unable to open CurrentUser store: %S\n", pwszStore);
        PrintLastError("CertOpenStore");
    }

    TestFree(pwszAllocStore);
    return hStore;
}

static BOOL TestEnum(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN DWORD dwDisplayFlags
    )
{
    BOOL fResult;
    TEST_ENUM_ARG TestArg;
    HCERTSTORE hStore;

    hStore = OpenMyStore(dwFlags, pwszComputerName);
    TestArg.hStore = hStore;
    TestArg.dwDisplayFlags = dwDisplayFlags;

    fResult = CryptEnumKeyIdentifierProperties(
        pKeyIdentifier,
        dwPropId,
        dwFlags,
        pwszComputerName,
        NULL,                   // pvReserved
        &TestArg,
        TestEnumCallback
        );
    if (!fResult)
        PrintLastError("CryptEnumKeyIdentifierProperty");

    if (hStore)
        CertCloseStore(hStore, 0);
    return fResult;
}

typedef struct _TEST_DELETE_ENUM_ARG {
    HCERTSTORE          hStore;
    LPCSTR              pszTestName;
    DWORD               cKeyIdentifier;
    PCRYPT_HASH_BLOB    rgKeyIdentifier;
} TEST_DELETE_ENUM_ARG, *PTEST_DELETE_ENUM_ARG;


static BOOL WINAPI TestDeleteEnumCallback(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwFlags,
    IN void *pvReserved,
    IN void *pvArg,
    IN DWORD cProp,
    IN DWORD *rgdwPropId,
    IN void **rgpvData,
    IN DWORD *rgcbData
    )
{
    PTEST_DELETE_ENUM_ARG pArg = (PTEST_DELETE_ENUM_ARG) pvArg;
    BYTE *pbCopy = NULL;
    PCRYPT_HASH_BLOB pNewKeyIdentifier;
    DWORD cKeyIdentifier;


    if (0 == _stricmp("DeleteWithoutCert", pArg->pszTestName)) {
        PCCERT_CONTEXT pCert = NULL;
        if (pCert = CertFindCertificateInStore(
                pArg->hStore,
                0,                      // dwCertEncodingType
                0,                      // dwFindFlags
                CERT_FIND_KEY_IDENTIFIER,
                pKeyIdentifier,
                NULL                    // pPrevCert
                )) {
            CertFreeCertificateContext(pCert);
            return TRUE;
        }
    }

    if (NULL == (pbCopy = (BYTE *) TestAlloc(pKeyIdentifier->cbData)))
        return TRUE;
    memcpy(pbCopy, pKeyIdentifier->pbData, pKeyIdentifier->cbData);

    cKeyIdentifier = pArg->cKeyIdentifier;
    if (NULL == (pNewKeyIdentifier = (PCRYPT_HASH_BLOB) TestRealloc(
            pArg->rgKeyIdentifier,sizeof(CRYPT_HASH_BLOB) *
                (cKeyIdentifier + 1)))) {
        TestFree(pbCopy);
        return TRUE;
    }

    pNewKeyIdentifier[cKeyIdentifier].pbData = pbCopy;
    pNewKeyIdentifier[cKeyIdentifier].cbData = pKeyIdentifier->cbData;
    pArg->cKeyIdentifier = cKeyIdentifier + 1;
    pArg->rgKeyIdentifier = pNewKeyIdentifier;

    return TRUE;
}

static BOOL TestDeleteEnum(
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN LPCSTR pszTestName
    )
{
    BOOL fResult;
    TEST_DELETE_ENUM_ARG TestArg;
    HCERTSTORE hStore = NULL;
    DWORD cKeyIdentifier;
    PCRYPT_HASH_BLOB pKeyIdentifier;

    memset(&TestArg, 0, sizeof(TestArg));
    TestArg.pszTestName = pszTestName;
    if (0 == _stricmp("DeleteWithoutCert", pszTestName)) {
        hStore = OpenMyStore(dwFlags, pwszComputerName);
        if (NULL == hStore)
            return FALSE;
        TestArg.hStore = hStore;
    }

    fResult = CryptEnumKeyIdentifierProperties(
        NULL,                   // pKeyIdentifier
        0,                      // dwPropId
        dwFlags,
        pwszComputerName,
        NULL,                   // pvReserved
        &TestArg,
        TestDeleteEnumCallback
        );
    if (!fResult)
        PrintLastError("CryptEnumKeyIdentifierProperty");

    cKeyIdentifier = TestArg.cKeyIdentifier;
    pKeyIdentifier = TestArg.rgKeyIdentifier;
    printf("Deleting %d Key Identifiers\n", cKeyIdentifier);
    for ( ; cKeyIdentifier > 0; cKeyIdentifier--, pKeyIdentifier++) {
        if (!CryptSetKeyIdentifierProperty(
            pKeyIdentifier,
            0,                  // dwPropId
            dwFlags | CRYPT_KEYID_DELETE_FLAG,
            pwszComputerName,
            NULL,                   // pvReserved
            NULL                    // pvData
            ))
        PrintLastError("CryptSetKeyIdentifierProperty(Delete)");

        TestFree(pKeyIdentifier->pbData);
    }
    TestFree(TestArg.rgKeyIdentifier);


    if (hStore)
        CertCloseStore(hStore, 0);
    return fResult;
}

static BOOL TestGet(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN DWORD dwDisplayFlags
    )
{
    BOOL fResult;
    void *pvData = NULL;
    DWORD cbData;
    if (0 == dwPropId)
        return TestEnum(
            pKeyIdentifier,
            dwPropId,
            dwFlags,
            pwszComputerName,
            dwDisplayFlags
            );

    dwFlags |= CRYPT_KEYID_ALLOC_FLAG;
    fResult = CryptGetKeyIdentifierProperty(
        pKeyIdentifier,
        dwPropId,
        dwFlags,
        pwszComputerName,
        NULL,               // pvReserved,
        &pvData,
        &cbData
        );

    if (!fResult)
        PrintLastError("CryptGetKeyIdentifierProperty");
    else {
        DisplayProperty(pKeyIdentifier, dwPropId, pvData, cbData);
    }

    if (pvData && cbData) {
        BOOL fResult2;
        DWORD cbData2;

        dwFlags &= ~CRYPT_KEYID_ALLOC_FLAG;

        cbData2 = cbData;
        fResult2 = CryptGetKeyIdentifierProperty(
            pKeyIdentifier,
            dwPropId,
            dwFlags,
            pwszComputerName,
            NULL,               // pvReserved,
            NULL,               // pvData
            &cbData2
            );

        if (!fResult2)
            PrintLastError("CryptGetKeyIdentifierProperty");
        else if (cbData2 != cbData)
            printf("failed => wrong cbData for nonAlloc\n");

        cbData2 = cbData - 1;
        fResult2 = CryptGetKeyIdentifierProperty(
            pKeyIdentifier,
            dwPropId,
            dwFlags,
            pwszComputerName,
            NULL,               // pvReserved,
            pvData,
            &cbData2
            );
        if (fResult2)
            printf("failed => returned success for too small buffer\n");
        else {
            DWORD dwErr = GetLastError();
            if (ERROR_MORE_DATA != dwErr)
                printf("failed => returned: %d 0x%x instead of ERROR_MORE_DATA\n", dwErr, dwErr);
        }
        if (cbData2 != cbData)
            printf("failed => wrong size returned for small buffer\n");
    }

    if (pvData)
        LocalFree((HLOCAL) pvData);
    return fResult;
}

#define SHA1_HASH_LEN  20
#define MAX_KEY_ID_LEN SHA1_HASH_LEN
#define SHA1_CHAR_LEN  (SHA1_HASH_LEN * 2)

//+-------------------------------------------------------------------------
//  Converts the ASCII HEX to an array of bytes
//--------------------------------------------------------------------------
static void StrToBytes(
    IN LPCSTR psz,
    OUT BYTE rgb[MAX_KEY_ID_LEN],
    OUT DWORD *pcb
    )
{
    BOOL fUpperNibble = TRUE;
    DWORD cb = 0;
    char ch;

    while (cb < MAX_KEY_ID_LEN && (ch = *psz++)) {
        BYTE b;

        // only convert ascii hex characters 0..9, a..f, A..F
        // silently ignore all others
        if (ch >= '0' && ch <= '9')
            b = ch - '0';
        else if (ch >= 'a' && ch <= 'f')
            b = 10 + ch - 'a';
        else if (ch >= 'A' && ch <= 'F')
            b = 10 + ch - 'A';
        else
            continue;

        if (fUpperNibble) {
            rgb[cb] = b << 4;
            fUpperNibble = FALSE;
        } else {
            rgb[cb] = rgb[cb] | b;
            cb++;
            fUpperNibble = TRUE;
        }
    }

    *pcb = cb;
}

int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    int status;
    LONG lStatus;
    LPSTR pszTestName = NULL;
    LPSTR pszCertFilename = NULL;
    BOOL fPropSystemStore = FALSE;
    LPSTR pszPropStore = NULL;
    PCCERT_CONTEXT pCert = NULL;
    BOOL fMachine = FALSE;
    LPWSTR pwszComputerName = NULL;
    DWORD dwDisplayFlags = 0;
    DWORD dwPropId = 0;
    DWORD dwFlags = 0;
    DWORD i;

    HCERTSTORE hPropStore = NULL;

    BYTE rgbKeyIdentifier[SHA1_HASH_LEN];
    DWORD cbKeyIdentifier;
    CRYPT_HASH_BLOB KeyIdentifier = { 0, NULL };

    while (--argc>0) {
        if (**++argv == '-')
        {
            {
                switch(argv[0][1])
                {
                case 'c':
                    pszCertFilename = argv[0]+2;
                    break;
                case 's':
                    pszPropStore = argv[0]+2;
                    fPropSystemStore = TRUE;
                    break;
                case 'S':
                    pszPropStore = argv[0]+2;
                    fPropSystemStore = FALSE;
                    break;
                case 'b':
                    dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                    break;
                case 'v':
                    dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                    break;
                case 'p':
                    dwPropId = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'f':
                    dwFlags = (DWORD) strtoul(argv[0]+2, NULL, 0);
                    break;
                case 'V':
                    fVerify = TRUE;
                    break;
                case 'M':
                    fMachine = TRUE;
                    if (argv[0][2])
                        pwszComputerName = AllocAndSzToWsz(argv[0]+2);
                    break;
                case 'k':
                    StrToBytes(
                        argv[0]+2,
                        rgbKeyIdentifier,
                        &cbKeyIdentifier
                        );
                    if (0 == cbKeyIdentifier) {
                        printf("No Hash digits\n");
                        goto BadUsage;
                    }
                    KeyIdentifier.pbData = rgbKeyIdentifier;
                    KeyIdentifier.cbData = cbKeyIdentifier;
                    break;
                case 'h':
                default:
                    goto BadUsage;
                }
            }
        } else {
            if (pszTestName) {
                printf("Multiple TestNames:: %s %s\n", pszTestName, argv[0]);
                goto BadUsage;
            }
            pszTestName = argv[0];
        }
    }

    if (pszTestName == NULL) {
        printf("Missing TestName\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (pszPropStore) {
        if (NULL == (hPropStore = OpenSystemStoreOrFile(
                fPropSystemStore,
                pszPropStore,
                0                   // dwFlags
                )))
            goto BadUsage;
    }

    if (pszCertFilename) {
        if (KeyIdentifier.cbData) {
            printf("-c option invalid with -k option\n");
            goto BadUsage;
        }
        if (NULL == (pCert = ReadCert(pszCertFilename)))
            goto ErrorReturn;

        if (hPropStore) {
            PCCERT_CONTEXT pPropCert = NULL;

            // Try to find the certificate in the specified store
            pPropCert = CertFindCertificateInStore(
                hPropStore,
                0,          // dwCertEncodingType
                0,          // dwFindFlags
                CERT_FIND_EXISTING,
                pCert,
                NULL        // pPrevCertContext
                );
            if (NULL == pPropCert) {
                printf("Failed, unable to find certificate in store\n");
                goto BadUsage;
            }

            CertFreeCertificateContext(pCert);
            pCert = pPropCert;
        }

        cbKeyIdentifier = MAX_KEY_ID_LEN;
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_KEY_IDENTIFIER_PROP_ID,
                rgbKeyIdentifier,
                &cbKeyIdentifier
                )) {
            KeyIdentifier.pbData = rgbKeyIdentifier;
            KeyIdentifier.cbData = cbKeyIdentifier;
        } else {
            PrintLastError(
                "CertGetCertificateContextProperty(KEY_IDENTIFIER)");
            goto ErrorReturn;
        }
    }

    if (fMachine)
        dwFlags |= CRYPT_KEYID_MACHINE_FLAG;

    if (0 == _stricmp("Set", pszTestName)) {
        if (NULL == pCert) {
            printf("Set: requires -c option\n");
            goto BadUsage;
        }

        if (!TestSet(
                &KeyIdentifier,
                pCert,
                dwPropId,
                dwFlags,
                pwszComputerName
                ))
            goto ErrorReturn;
    } else if (0 == _stricmp("Get", pszTestName)) {
        if (0 == KeyIdentifier.cbData) {
            printf("Get: requires -c or -k option\n");
            goto BadUsage;
        }

        if (!TestGet(
                &KeyIdentifier,
                dwPropId,
                dwFlags,
                pwszComputerName,
                dwDisplayFlags
                ))
            goto ErrorReturn;
    } else if (0 == _stricmp("Delete", pszTestName)) {
        if (0 == KeyIdentifier.cbData) {
            printf("Delete: requires -c or -k option\n");
            goto BadUsage;
        }

        if (!TestDelete(
                &KeyIdentifier,
                dwPropId,
                dwFlags,
                pwszComputerName
                ))
            goto ErrorReturn;
    } else if (0 == _stricmp("Enum", pszTestName)) {
        if (!TestEnum(
                (0 == KeyIdentifier.cbData) ? NULL : &KeyIdentifier,
                dwPropId,
                dwFlags,
                pwszComputerName,
                dwDisplayFlags
                ))
            goto ErrorReturn;
    } else if (0 == _stricmp("DeleteAll", pszTestName) ||
            0 == _stricmp("DeleteWithoutCert", pszTestName)) {
        if (!TestDeleteEnum(
                dwFlags,
                pwszComputerName,
                pszTestName
                ))
            goto ErrorReturn;
    } else {
        printf("Invalid TestName: %s\n", pszTestName);
        goto BadUsage;
    }

    printf("Passed\n");
    status = 0;

CommonReturn:
    CertCloseStore(hPropStore, 0);
    CertFreeCertificateContext(pCert);
    TestFree(pwszComputerName);

    return status;
ErrorReturn:
    status = -1;
    printf("Failed\n");
    goto CommonReturn;

BadUsage:
    Usage();
    goto ErrorReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tgetopus\tgetopus.cpp ===
//+-------------------------------------------------------------------------
//  File:       tgetopus.cpp
//
//  Contents:   Example code to get OPUS info from an authenticode signed
//              file. The OPUS info contains the publisher specified
//              program name and more info URL.
//--------------------------------------------------------------------------

#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>


//+-------------------------------------------------------------------------
//  The returned OPUS info must be freed via LocalFree().
//
//  NULL is returned if unable to extract the OPUS info from the file.
//  Call GetLastError() to get additional error info.
//
//  Interesting fields:
//      pOpusInfo->pwszProgramName
//      pOpusInfo->pMoreInfo, where normally
//          pOpusInfo->pMoreInfo->dwLinkChoice == SPC_URL_LINK_CHOICE
//          pOpusInfo->pMoreInfo->pwszUrl
//
//--------------------------------------------------------------------------
PSPC_SP_OPUS_INFO
GetOpusInfoFromSignedFile(
    IN LPCWSTR pwszFilename
    )
{
    DWORD dwLastError = 0;
    PSPC_SP_OPUS_INFO pOpusInfo = NULL;
    HCRYPTMSG hCryptMsg = NULL;
    PCMSG_SIGNER_INFO pSignerInfo = NULL;
    DWORD cbInfo;
    PCRYPT_ATTRIBUTE pOpusAttr;             // not allocated

    // Extract the PKCS 7 message from the signed file
    if (!CryptQueryObject(
            CERT_QUERY_OBJECT_FILE,
            (const void *) pwszFilename,
            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
            CERT_QUERY_FORMAT_FLAG_BINARY,
            0,                                  // dwFlags
            NULL,                               // pdwMsgAndCertEncodingType
            NULL,                               // pdwContentType
            NULL,                               // pdwFormatType
            NULL,                               // phCertStore
            &hCryptMsg,
            NULL                                // ppvContext
            ))
        goto ExtractPKCS7FromSignedFileError;

    // Get the signer info for the first signer. Note, authenticode
    // currently only has one signer.
    cbInfo = 0;
    if (!CryptMsgGetParam(
            hCryptMsg,
            CMSG_SIGNER_INFO_PARAM,
            0,                          // dwSignerIndex
            NULL,                       // pvData
            &cbInfo
            ))
        goto GetSignerInfoError;
    if (NULL == (pSignerInfo = (PCMSG_SIGNER_INFO) LocalAlloc(LPTR, cbInfo)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            hCryptMsg,
            CMSG_SIGNER_INFO_PARAM,
            0,                          // dwSignerIndex
            pSignerInfo,
            &cbInfo
            ))
        goto GetSignerInfoError;

    // If present, the OPUS info is an authenticated signer attribute
    if (NULL == (pOpusAttr = CertFindAttribute(
            SPC_SP_OPUS_INFO_OBJID,
            pSignerInfo->AuthAttrs.cAttr,
            pSignerInfo->AuthAttrs.rgAttr
            )) || 0 == pOpusAttr->cValue) {
        SetLastError(CRYPT_E_ATTRIBUTES_MISSING);
        goto NoOpusAttr;
    }

    // Simply allocate and decode the OPUS info stored in the above
    // authenticated attribute. Note, the returned allocated structure
    // must be freed via LocalAlloc()
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            SPC_SP_OPUS_INFO_STRUCT,
            pOpusAttr->rgValue[0].pbData,
            pOpusAttr->rgValue[0].cbData,
            CRYPT_DECODE_ALLOC_FLAG,
            (void *) &pOpusInfo,
            &cbInfo
            ))
        goto DecodeOpusInfoError;

CommonReturn:
    if (hCryptMsg)
        CryptMsgClose(hCryptMsg);
    if (pSignerInfo)
        LocalFree(pSignerInfo);

    if (dwLastError)
        SetLastError(dwLastError);
    return pOpusInfo;

ExtractPKCS7FromSignedFileError:
GetSignerInfoError:
OutOfMemory:
NoOpusAttr:
DecodeOpusInfoError:
    goto CommonReturn;
}


void Usage(void)
{
    printf("Usage: tgetopus <filename>\n");
}


void PrintLastError(LPCSTR pszMsg)
{
    DWORD dwErr = GetLastError();
    printf("%s failed => 0x%x (%d) \n", pszMsg, dwErr, dwErr);
}

//+-------------------------------------------------------------------------
//  Allocate and convert a multi-byte string to a wide string
//--------------------------------------------------------------------------
LPWSTR AllocAndSzToWsz(LPCSTR psz)
{
    size_t  cb;
    LPWSTR  pwsz = NULL;

    if (-1 == (cb = mbstowcs( NULL, psz, strlen(psz))))
        goto bad_param;
    cb += 1;        // terminating NULL
    if (NULL == (pwsz = (LPWSTR) LocalAlloc(LPTR, cb * sizeof(WCHAR)))) {
        PrintLastError("AllocAndSzToWsz");
        goto failed;
    }
    if (-1 == mbstowcs( pwsz, psz, cb))
        goto bad_param;
    goto common_return;

bad_param:
    printf("Bad AllocAndSzToWsz\n");
failed:
    if (pwsz) {
        LocalFree(pwsz);
        pwsz = NULL;
    }
common_return:
    return pwsz;
}

int _cdecl main(int argc, char * argv[]) 
{
    int iStatus = 0;
    LPCSTR pszFilename = NULL;      // not allocated
    LPWSTR pwszFilename = NULL;
    PSPC_SP_OPUS_INFO pOpusInfo = NULL;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
                case 'h':
                default:
                    goto BadUsage;
            }
        } else {
            if (pszFilename == NULL)
                pszFilename = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    if (pszFilename == NULL) {
        printf("missing Filename \n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (NULL == (pwszFilename = AllocAndSzToWsz(pszFilename)))
        goto ErrorReturn;

    if (NULL == (pOpusInfo = GetOpusInfoFromSignedFile(pwszFilename))) {
        PrintLastError("GetOpusInfoFromSignedFile");
        goto ErrorReturn;
    }

    if (pOpusInfo->pwszProgramName)
        printf("ProgramName:: %S\n", pOpusInfo->pwszProgramName);
    else
        printf("NO ProgramName\n");

    if (pOpusInfo->pMoreInfo &&
            SPC_URL_LINK_CHOICE == pOpusInfo->pMoreInfo->dwLinkChoice)
        printf("ProgramUrl:: %S\n", pOpusInfo->pMoreInfo->pwszUrl);
    else
        printf("NO ProgramUrl\n");


    printf("Passed\n");
    iStatus = 0;

CommonReturn:
    if (pwszFilename)
        LocalFree(pwszFilename);
    if (pOpusInfo)
        LocalFree(pOpusInfo);

    return iStatus;
ErrorReturn:
    iStatus = -1;
    printf("Failed\n");
    goto CommonReturn;

BadUsage:
    Usage();
    goto ErrorReturn;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\toidfunc\toidfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       toidfunc.cpp
//
//  Contents:   OID Function Tests: Register, Unregister or Enum
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    24-Nov-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static void Usage(void)
{
    printf("Usage: toidfunc [options] <TestName>\n");
    printf("Options are:\n");
    printf("  -h                        - This message\n");
    printf("  -o<OID string>            - For example, -o1.2.3.4\n");
    printf("  -o%s                      - Default Dlls\n", CRYPT_DEFAULT_OID);
    printf("  -O<OID number>            - For example, -O1000\n");
    printf("  -f<FuncName>              - For example, -fCryptDllEncodeObject\n");
    printf("  -F<FuncName Override>     - For example, -FMyEncodeObject\n");
    printf("  -e<EncodeType Number>     - For example, -e1 (X509_ASN)\n");
    printf("  -i<index number>          - Default Dlls index\n");
    printf("  -d<Dll filename>          - For example, -dsetx509.dll\n");
    printf("  -G<Group number>          - For example, -G7\n");
    printf("  -v[RegType] <name> <data> - Registry value\n");
    printf("\n");
    printf("TestNames (case insensitive):\n");
    printf("  Enum          options: [-o|-O] [-f] [-e], defaults to any\n");
    printf("  Register      options: -o|-O -f [-F] [-e] [-d] [-v] [-v] ...\n");
    printf("  Unregister    options: -o|-O -f [-e]\n");
    printf("  EnumInfo      options: [-G], defaults to all groups\n");
    printf("\n");
    printf("  Register      options: -o%s -f [-i] -d [-v] [-v] ...\n",
        CRYPT_DEFAULT_OID);
    printf("  Unregister    options: -o%s -f -d\n", CRYPT_DEFAULT_OID);
    printf("\n");
    printf("Defaults:\n");
    printf("  -e%d (X509_ASN_ENCODING)\n", X509_ASN_ENCODING);
    printf("  -i0x%x\n", CRYPT_REGISTER_LAST_INDEX);
    printf("\n");
    printf("RegTypes: REG_SZ | REG_EXPAND_SZ | REG_DWORD\n");
    printf("\n");
    printf("OID number range: 1 .. 0xFFFF\n");
    printf("\n");
    printf("-v option: the next two arguments contain Registry Value name and data\n");
    printf("  For example, -vREG_SZ FuncName MyDllDecodeObject\n");
    printf("\n");
}

static DWORD ToRegType(
    IN LPCSTR pszOption,
    IN LPCSTR pszRegType
    )
{
    DWORD RegType;
    if (NULL == pszRegType || '\0' == *pszRegType ||
            0 == _stricmp("REG_SZ", pszRegType))
        RegType = REG_SZ;
    else if (0 == _stricmp("REG_EXPAND_SZ", pszRegType))
        RegType = REG_EXPAND_SZ;
    else if (0 == _stricmp("REG_DWORD", pszRegType))
        RegType = REG_DWORD;
    else if (0 == _stricmp("REG_MULTI_SZ", pszRegType))
        RegType = REG_MULTI_SZ;
    else {
        printf("Option (%s) : has an invalid RegType: %s\n",
            pszOption, pszRegType);
        RegType = REG_NONE;
    }
    return RegType;
}

static LPCSTR FromRegType(
    IN DWORD dwType
    )
{
    LPCSTR pszType;
    switch (dwType) {
        case REG_DWORD:
            pszType = "REG_DWORD";
            break;
        case REG_SZ:
            pszType = "REG_SZ";
            break;
        case REG_EXPAND_SZ:
            pszType = "REG_EXPAND_SZ";
            break;
        case REG_MULTI_SZ:
            pszType = "REG_MULTI_SZ";
            break;
        case REG_BINARY:
            pszType = "REG_BINARY";
            break;
        default:
            pszType = "REG_????";
    }
    return pszType;
}

#define ENUM_ARG "EnumCallback arg"

static BOOL WINAPI EnumCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    BOOL fResult = TRUE;
    if (NULL == pvArg || 0 != strcmp(ENUM_ARG, (LPCSTR) pvArg)) {
        fResult = FALSE;
        printf("CryptEnumOIDFunction failed: invalid pvArg passed to callback\n");
    }

    printf("  EncodingType %d\\%s\\%s\n", dwEncodingType, pszFuncName, pszOID);
    for (DWORD i = 0; i < cValue; i++) {
        DWORD dwType = rgdwValueType[i];
        if (REG_MULTI_SZ == dwType) {
            DWORD j;
            DWORD cch;
            LPWSTR pwszData = (LPWSTR) rgpbValueData[i];
            for (j = 0; 0 != (cch = wcslen(pwszData));
                                                j++, pwszData += cch + 1) {
                printf("    %S[%d] : %S\n", rgpwszValueName[i], j, pwszData);
            }
        } else if (REG_BINARY == dwType) {
            printf("    %S (REG_BINARY) :\n", rgpwszValueName[i]);
            PrintBytes("     ", (BYTE *) rgpbValueData[i], rgcbValueData[i]);
        } else {
            printf("    %S : ", rgpwszValueName[i]);
            if (rgpbValueData[i] && rgcbValueData[i]) {
                switch (dwType) {
                case REG_DWORD:
                    {
                        DWORD dwData = *((DWORD *) rgpbValueData[i]);
                        printf("0x%x (%d)", dwData, dwData);
                    }
                    break;
                case REG_SZ:
                case REG_EXPAND_SZ:
                    printf("%S", rgpbValueData[i]);
                    break;
                default:
                    printf("UNEXPECTED VALUE TYPE");
                }
                if (REG_SZ != dwType)
                    printf(" (%s)", FromRegType(dwType));
            } else
                printf("EMPTY");
            printf("\n");
        }
    }
    return fResult;
}

static BOOL WINAPI EnumInfoCallback(
    IN PCCRYPT_OID_INFO pInfo,
    IN void *pvArg
    )
{
    BOOL fResult = TRUE;
    DWORD cExtra;
    DWORD *pdwExtra;
    DWORD i;

    if (NULL == pvArg || 0 != strcmp(ENUM_ARG, (LPCSTR) pvArg)) {
        fResult = FALSE;
        printf("CryptEnumOIDInfo failed: invalid pvArg passed to callback\n");
    }

    printf("  Group: %d  OID: %s Name: %S  Algid: 0x%x",
        pInfo->dwGroupId, pInfo->pszOID, pInfo->pwszName, pInfo->Algid);

    cExtra = pInfo->ExtraInfo.cbData / sizeof(DWORD);
    pdwExtra = (DWORD *) pInfo->ExtraInfo.pbData;

    for (i = 0; i < cExtra; i++) 
        printf(" Extra[%d]: %d (0x%x)", i, pdwExtra[i], pdwExtra[i]);

    printf("\n");
    return fResult;
}


int _cdecl main(int argc, char * argv[]) 
{
    int status;
    LPSTR pszTestName = NULL;
    LPSTR pszOID = NULL;
    LPSTR pszFuncName = NULL;
    LPSTR pszOverrideFuncName = NULL;
    DWORD dwEncodingType = X509_ASN_ENCODING;
    BOOL fEncodingType = FALSE;
    LPWSTR pwszDllFile = NULL;
    DWORD dwDllIndex = CRYPT_REGISTER_LAST_INDEX;

    DWORD dwGroupId = 0;

#define MAX_VALUE_COUNT 16
    DWORD cValue = 0;
    DWORD rgdwValueType[MAX_VALUE_COUNT];
    LPWSTR rgpwszValueName[MAX_VALUE_COUNT];
    BYTE *rgpbValueData[MAX_VALUE_COUNT];
    DWORD rgcbValueData[MAX_VALUE_COUNT];
    DWORD rgdwValueData[MAX_VALUE_COUNT];

    DWORD RegType;
    DWORD i;

    while (--argc>0) {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'o':
                pszOID = argv[0]+2;
                break;
            case 'O':
                {
                    DWORD dwOID = strtoul(argv[0]+2, NULL, 0);
                    if (dwOID == 0 || dwOID > 0xFFFF) {
                        printf(
                            "Option (-O) : OID constant (%d,0x%x) out of range\n",
                                dwOID, dwOID);
                        goto BadUsage;
                    }
                    pszOID = (LPSTR)(ULONG_PTR) dwOID;
                }
                break;
            case 'f':
                pszFuncName = argv[0]+2;
                break;
            case 'F':
                pszOverrideFuncName = argv[0]+2;
                break;
            case 'e':
                dwEncodingType = strtoul(argv[0]+2, NULL, 0);
                fEncodingType = TRUE;
                break;
            case 'i':
                dwDllIndex = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'd':
                pwszDllFile = AllocAndSzToWsz(argv[0]+2);
                break;
            case 'v':
                if (argc < 3 || argv[1][0] == '-' || argv[2][0] == '-') {
                    printf("Option (-v) : missing name and data arguments\n");
                    goto BadUsage;
                }
                if (cValue >= MAX_VALUE_COUNT) {
                    printf("Exceeded maximum value count of %d\n",
                        MAX_VALUE_COUNT);
                    goto BadUsage;
                }
                if (REG_NONE == (RegType = ToRegType("-v", argv[0] + 2)))
                    goto BadUsage;
                rgdwValueType[cValue] = RegType;

                rgpwszValueName[cValue] = AllocAndSzToWsz(argv[1]);
                if (REG_DWORD == RegType) {
                    rgdwValueData[cValue] = strtoul(argv[2], NULL, 0);
                    rgpbValueData[cValue] =
                        (BYTE *) &rgdwValueData[cValue];
                    rgcbValueData[cValue] = sizeof(DWORD);
                } else {
                    LPWSTR pwsz = AllocAndSzToWsz(argv[2]);
                    if (pwsz) {
                        rgpbValueData[cValue] = (BYTE *) pwsz;
                        rgcbValueData[cValue] =
                            (wcslen(pwsz) + 1) * sizeof(WCHAR);
                    } else {
                        rgpbValueData[cValue] = NULL;
                        rgcbValueData[cValue] = 0;
                    }
                }
                cValue++;
                argc -= 2;
                argv += 2;
                break;
            case 'G':
                dwGroupId = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (pszTestName) {
                printf("Multiple TestNames:: %s %s\n", pszTestName, argv[0]);
                goto BadUsage;
            }
            pszTestName = argv[0];
        }
    }

    if (pszTestName == NULL) {
        printf("Missing TestName\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (0 == _stricmp("Register", pszTestName)) {
        if (pszOID == NULL) {
            printf("Register Test:: missing OID option (-o) or (-O)\n");
            goto BadUsage;
        }
        if (pszFuncName == NULL) {
            printf("Register Test:: missing function name option (-f)\n");
            goto BadUsage;
        }

        if ((DWORD_PTR) pszOID > 0xFFFF &&
                0 == _stricmp(CRYPT_DEFAULT_OID, pszOID)) {
            if (pwszDllFile == NULL) {
                printf("Register Test:: missing dll option (-d)\n");
                goto BadUsage;
            }

            if (!CryptRegisterDefaultOIDFunction(
                    dwEncodingType,
                    pszFuncName,
                    dwDllIndex,
                    pwszDllFile
                    )) {
                PrintLastError("CryptRegisterDefaultOIDFunction");
                goto ErrorReturn;
            }
        } else {
            if (!CryptRegisterOIDFunction(
                    dwEncodingType,
                    pszFuncName,
                    pszOID,
                    pwszDllFile,
                    pszOverrideFuncName
                    )) {
                PrintLastError("CryptRegisterOIDFunction");
                goto ErrorReturn;
            }
        }

        for (i = 0; i < cValue; i++) {
            if (!CryptSetOIDFunctionValue(
                    dwEncodingType,
                    pszFuncName,
                    pszOID,
                    rgpwszValueName[i],
                    rgdwValueType[i],
                    rgpbValueData[i],
                    rgcbValueData[i]
                    )) {
                PrintLastError("CryptSetOIDFunctionValue");
                goto ErrorReturn;
            }
        }
        printf("Successful Register\n");

    } else if (0 == _stricmp("Unregister", pszTestName)) {
        if (pszOID == NULL) {
            printf("Unregister test:: missing OID option (-o) or (-O)\n");
            goto BadUsage;
        }
        if (pszFuncName == NULL) {
            printf("Unregister test:: missing function name option (-f)\n");
            goto BadUsage;
        }

        if ((DWORD_PTR) pszOID > 0xFFFF &&
                0 == _stricmp(CRYPT_DEFAULT_OID, pszOID)) {
            if (pwszDllFile == NULL) {
                printf("Unregister Test:: missing dll option (-d)\n");
                goto BadUsage;
            }

            if (!CryptUnregisterDefaultOIDFunction(
                    dwEncodingType,
                    pszFuncName,
                    pwszDllFile
                    )) {
                PrintLastError("CryptUnregisterDefaultOIDFunction");
                goto ErrorReturn;
            }
        } else {
            if (!CryptUnregisterOIDFunction(
                    dwEncodingType,
                    pszFuncName,
                    pszOID
                    )) {
                PrintLastError("CryptUnregisterOIDFunction");
                goto ErrorReturn;
            }
        }
        printf("Successful Unregister\n");

    } else if (0 == _stricmp("Enum", pszTestName)) {
        if (!CryptEnumOIDFunction(
                fEncodingType ? dwEncodingType : CRYPT_MATCH_ANY_ENCODING_TYPE,
                pszFuncName,
                pszOID,
                0,              // dwFlags
                ENUM_ARG,
                EnumCallback
                )) {
            PrintLastError("CryptEnumOIDFunction");
            goto ErrorReturn;
        } else
            printf("Successful Enum\n");
    } else if (0 == _stricmp("EnumInfo", pszTestName)) {
        if (!CryptEnumOIDInfo(
                dwGroupId,
                0,              // dwFlags
                ENUM_ARG,
                EnumInfoCallback
                )) {
            PrintLastError("CryptEnumOIDInfo");
            goto ErrorReturn;
        } else
            printf("Successful EnumInfo\n");
    } else {
        printf("Invalid TestName: %s\n", pszTestName);
        goto BadUsage;
    }

    status = 0;

CommonReturn:
    if (pwszDllFile)
        TestFree(pwszDllFile);
    while(cValue--) {
        if (rgdwValueType[cValue] != REG_DWORD && rgpbValueData[cValue])
            TestFree(rgpbValueData[cValue]);
        if (rgpwszValueName[cValue])
            TestFree(rgpwszValueName[cValue]);
    }
    return status;

BadUsage:
    Usage();
    status = 0;
    goto CommonReturn;

ErrorReturn:
    printf("Failed\n");
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tpvkdel\tpvkdel.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tpvksave.cpp
//
//  Contents:   Private Key Delete Test
//
//              See Usage() for list of delete options.
//
//  Functions:  main
//
//  History:    11-May-96   philh   created
//				07-Jun-96   HelleS	Added printing the command line
//									and Failed or Passed at the end.
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void Usage(void)
{
    int i;

    printf("Usage: tpvkdel [options]\n");
    printf("Options are:\n");
    printf("  -p<number>            - Crypto provider type number\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -d                    - Delete from provider\n");
    printf("  -h                    - This message\n");
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    HCRYPTPROV hProv = 0;
    DWORD dwProvType = PROV_RSA_FULL;
    LPSTR pszContainer = NULL;
    BOOL fDelete = FALSE;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'p':
                dwProvType = strtoul( argv[0]+2, NULL, 10);
                break;
            case 'c':
                pszContainer = argv[0]+2;
                if (*pszContainer == '\0') {
                    printf("Need to specify crypto key container name\n");
                    goto BadUsage;
                }
                break;
            case 'd':
                fDelete = TRUE;
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            printf("Too many arguments\n");
            goto BadUsage;
        }
    }

    if (!fDelete) 
        goto BadUsage;

    printf("command line: %s\n", GetCommandLine());

    printf("Deleting existing private keys\n");

    // Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined
    // and must not be released.
    if (!CryptAcquireContext(
            &hProv,
            pszContainer,
            NULL,           // pszProvider
            dwProvType,
            CRYPT_DELETEKEYSET
            ))
    {        
        PrintLastError("CryptAcquireContext(CRYPT_DELETEKEYSET)");
    	ReturnStatus = -1;
	}
	else
    	ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
    ReturnStatus = -1;
CommonReturn:
    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");
            
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tprov\tprov.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tprov.cpp
//
//  Contents:   Get provider information
//
//
//  Functions:  main
//
//  History:    10-Jun-97   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"
#include "unicode.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>


static void DisplayProvContainers(
    IN HCRYPTPROV hProv,
    IN LPWSTR pwszProvName,
    IN DWORD dwProvType,
    IN DWORD dwProvFlags
    )
{

    LPSTR pszContainerName = NULL;
    DWORD cchContainerName;
    DWORD cchMaxContainerName;
    LPWSTR pwszContainerName = NULL;
    DWORD dwEnumFlags;

    // Get maximum container name length
    dwEnumFlags = CRYPT_FIRST;
    cchMaxContainerName = 0;
    if (!CryptGetProvParam(
            hProv,
            PP_ENUMCONTAINERS,
            NULL,           // pbData
            &cchMaxContainerName,
            dwEnumFlags
            )) {
        DWORD dwErr = GetLastError();
        if (ERROR_MORE_DATA != dwErr) {
            if (ERROR_FILE_NOT_FOUND == dwErr || ERROR_NO_MORE_ITEMS == dwErr)
                printf("    <No Containers>\n");
            else if (ERROR_INVALID_PARAMETER == dwErr)
                printf("    <Invalid Parameter>\n");
            else
                PrintLastError("CryptGetProvParam(PP_ENUMCONTAINERS)");
            goto ErrorReturn;
        }
    }

    if (0 == cchMaxContainerName) {
        printf("   MaxContainerName length = 0\n");
        goto ErrorReturn;
    }


    if (NULL == (pszContainerName = (LPSTR) TestAlloc(
            cchMaxContainerName + 1)))
        goto ErrorReturn;

    while (TRUE) {
        HCRYPTPROV hContainerProv;

        cchContainerName = cchMaxContainerName;
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMCONTAINERS,
                (BYTE *) pszContainerName,
                &cchContainerName,
                dwEnumFlags
                )) {
            DWORD dwEnumErr = GetLastError();
            if (!(ERROR_NO_MORE_ITEMS == dwEnumErr ||
                    ERROR_FILE_NOT_FOUND == dwEnumErr)) {
                PrintLastError("CryptGetProvParam(PP_ENUMCONTAINERS)");
            }
            break;
        }
        dwEnumFlags = 0;        // CRYPT_NEXT

        if (NULL == (pwszContainerName = MkWStr(pszContainerName))) {
            PrintLastError("MkWStr");
            goto ErrorReturn;
        }

        printf("   %S\n", pwszContainerName);

        if (!CryptAcquireContextU(
                &hContainerProv,
                pwszContainerName,
                pwszProvName,
                dwProvType,
                dwProvFlags
                )) {
            DWORD dwErr = GetLastError();
            if (PROV_RSA_FULL == dwProvType &&
                    0 == _wcsicmp(pwszProvName, MS_DEF_PROV_W))
                printf(
                  "     CryptAcquireContext(MS_DEF_PROV) returned 0x%x (%d)\n",
                    dwErr, dwErr); 
            else if (PROV_DSS == dwProvType && 
		    0 == _wcsicmp(pwszProvName, MS_DEF_DSS_PROV_W))
                printf(
                  "     CryptAcquireContext(MS_DEF_DSS_PROV) returned 0x%x (%d)\n",
                    dwErr, dwErr); 
	    else if (PROV_DSS_DH == dwProvType && 
		    0 == _wcsicmp(pwszProvName, MS_DEF_DSS_DH_PROV_W))
                printf(
                  "     CryptAcquireContext(MS_DEF_DSS_DH_PROV) returned 0x%x (%d)\n",
                    dwErr, dwErr); 
            else
                PrintLastError("CryptAcquireContextU(Container)");
        } else
            CryptReleaseContext(hContainerProv, 0);
        FreeWStr(pwszContainerName);
        pwszContainerName = NULL;
    }


ErrorReturn:
    TestFree(pszContainerName);
    FreeWStr(pwszContainerName);
}

static void DisplayProvAlgidEx(HCRYPTPROV hProv)
{
    DWORD i;
    CHAR *pszAlgType = NULL;
    PROV_ENUMALGS_EX Data;
    DWORD cbData;
    DWORD dwFlags;

    dwFlags = CRYPT_FIRST;
    for (i = 0; TRUE; i++) {

        cbData = sizeof(Data);
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMALGS_EX,
                (BYTE *) &Data,
                &cbData,
                dwFlags
                )) {
            DWORD dwErr = GetLastError();
            if (ERROR_INVALID_PARAMETER == dwErr)
                printf("    <Invalid Parameter>\n");
            else if (NTE_BAD_TYPE == dwErr)
                printf("    <Bad Parameter Type>\n");
            else if (ERROR_NO_MORE_ITEMS != dwErr)
                PrintLastError("CryptGetProvParam(PP_ENUMALGS_EX)");
            break;
        }

        dwFlags = 0;    // CRYPT_NEXT

        // Determine the algorithm type.
        switch(GET_ALG_CLASS(Data.aiAlgid)) {
            case ALG_CLASS_DATA_ENCRYPT: pszAlgType = "Encrypt  ";
                                         break;
            case ALG_CLASS_HASH:         pszAlgType = "Hash     ";
                                         break;
            case ALG_CLASS_KEY_EXCHANGE: pszAlgType = "Exchange ";
                                         break;
            case ALG_CLASS_SIGNATURE:    pszAlgType = "Signature";
                                         break;
            default:                     pszAlgType = "Unknown  ";
        }

        // Print information about the algorithm.
        printf("Algid:%8.8xh, Bits:%-4d, %-4d - %-4d, Type:%s\n",
            Data.aiAlgid, Data.dwDefaultLen, Data.dwMinLen, Data.dwMaxLen,
            pszAlgType
            );

        printf("  Name: %s  LongName: %s Protocols: 0x%x\n",
            Data.szName, Data.szLongName, Data.dwProtocols
            );
    }

    printf("\n");
}

static void DisplayProvAlgid(HCRYPTPROV hProv)
{
    DWORD i;
    CHAR *pszAlgType = NULL;
    PROV_ENUMALGS Data;
    DWORD cbData;
    DWORD dwFlags;

    dwFlags = CRYPT_FIRST;
    for (i = 0; TRUE; i++) {

        cbData = sizeof(Data);
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMALGS,
                (BYTE *) &Data,
                &cbData,
                dwFlags
                )) {
            if (ERROR_NO_MORE_ITEMS != GetLastError())
                PrintLastError("CryptGetProvParam(PP_ENUMALGS)");
            break;
        }

        dwFlags = 0;    // CRYPT_NEXT

        // Determine the algorithm type.
        switch(GET_ALG_CLASS(Data.aiAlgid)) {
            case ALG_CLASS_DATA_ENCRYPT: pszAlgType = "Encrypt  ";
                                         break;
            case ALG_CLASS_HASH:         pszAlgType = "Hash     ";
                                         break;
            case ALG_CLASS_KEY_EXCHANGE: pszAlgType = "Exchange ";
                                         break;
            case ALG_CLASS_SIGNATURE:    pszAlgType = "Signature";
                                         break;
            default:                     pszAlgType = "Unknown  ";
        }

        // Print information about the algorithm.
        printf("Algid:%8.8xh, Bits:%-4d, Type:%s, NameLen:%-2d, Name:%s\n",
            Data.aiAlgid, Data.dwBitLen, pszAlgType, Data.dwNameLen,
            Data.szName
        );
    }

    printf("\n");
}

#if 0
static void DisplayProvAlgid(HCRYPTPROV hProv)
{
    BYTE *ptr = NULL;
    DWORD i;
    ALG_ID aiAlgid;
    DWORD dwBits;
    DWORD dwNameLen;
    CHAR szName[100];         // Often allocated dynamically
    CHAR *pszAlgType = NULL;

    BYTE *pbData = NULL;
    DWORD cbMaxData;
    DWORD cbData;
    DWORD dwFlags;

    // Get maximum length of provider algorithm parameter data
    cbMaxData = 0;
    if (!CryptGetProvParam(
            hProv,
            PP_ENUMALGS,
            NULL,           // pbData
            &cbMaxData,
            CRYPT_FIRST     // dwFlags
            ) || 0 == cbMaxData) {
        PrintLastError("CryptGetProvParam(PP_ENUMALGS)");
        goto ErrorReturn;
    }
    if (NULL == (pbData = (BYTE *) TestAlloc(cbMaxData)))
        goto ErrorReturn;

    dwFlags = CRYPT_FIRST;
    for (i = 0; TRUE; i++) {
        ALG_ID aiProv;

        cbData = cbMaxData;
        if (!CryptGetProvParam(
                hProv,
                PP_ENUMALGS,
                pbData,
                &cbData,
                dwFlags
                )) {
            if (ERROR_NO_MORE_ITEMS != GetLastError())
                PrintLastError("CryptGetProvParam(PP_ENUMALGS)");
            break;
        }

        dwFlags = 0;    // CRYPT_NEXT

        // Extract algorithm information from the 'pbData' buffer.
        ptr = pbData;
        aiAlgid = *(ALG_ID *)ptr;
        ptr += sizeof(ALG_ID);
        dwBits = *(DWORD *)ptr;
        ptr += sizeof(DWORD);
        dwNameLen = *(DWORD *)ptr;
        ptr += sizeof(DWORD);
        strncpy(szName, (LPSTR) ptr, dwNameLen);

        // Determine the algorithm type.
        switch(GET_ALG_CLASS(aiAlgid)) {
            case ALG_CLASS_DATA_ENCRYPT: pszAlgType = "Encrypt  ";
                                         break;
            case ALG_CLASS_HASH:         pszAlgType = "Hash     ";
                                         break;
            case ALG_CLASS_KEY_EXCHANGE: pszAlgType = "Exchange ";
                                         break;
            case ALG_CLASS_SIGNATURE:    pszAlgType = "Signature";
                                         break;
            default:                     pszAlgType = "Unknown  ";
        }

        // Print information about the algorithm.
        printf("Algid:%8.8xh, Bits:%-4d, Type:%s, NameLen:%-2d, Name:%s\n",
            aiAlgid, dwBits, pszAlgType, dwNameLen, szName
        );
    }

ErrorReturn:
    TestFree(pbData);
}
#endif


int _cdecl main(int argc, char * argv[]) 
{
    DWORD dwProvIndex;
    printf("command line: %s\n", GetCommandLine());

    for (dwProvIndex = 0; TRUE; dwProvIndex++) {
        BOOL fResult;
        LPWSTR pwszProvName;
        DWORD cbProvName;
        HCRYPTPROV hProv;
        DWORD dwProvType;

        cbProvName = 0;
        dwProvType = 0;
        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                NULL,               // pwszProvName,
                &cbProvName
                ) || 0 == cbProvName) {
            if (ERROR_NO_MORE_ITEMS != GetLastError())
                PrintLastError("CryptEnumProvidersU");
            break;
        }
        if (NULL == (pwszProvName = (LPWSTR) TestAlloc(
                (cbProvName + 1) * sizeof(WCHAR))))
            break;
        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                pwszProvName,
                &cbProvName
                )) {
            TestFree(pwszProvName);
            PrintLastError("CryptEnumProvidersU");
            break;
        }

        printf("\n============   [%d]   ============\n", dwProvIndex);
        printf("Provider:: Type(%d) %S\n\n", dwProvType, pwszProvName);

        fResult = FALSE;
        if (!CryptAcquireContextU(
                &hProv,
                NULL,               // pwszContainerName,
                pwszProvName,
                dwProvType,
                CRYPT_VERIFYCONTEXT // dwFlags
                )) {
            PrintLastError("CryptAcquireContextU");
        } else {
            DisplayProvAlgidEx(hProv);
            DisplayProvAlgid(hProv);
            printf("\nCurrentUser Containers::\n");
            DisplayProvContainers(hProv, pwszProvName, dwProvType, 0);

            CryptReleaseContext(hProv, 0);
        }

        if (!CryptAcquireContextU(
                &hProv,
                NULL,               // pwszContainerName,
                pwszProvName,
                dwProvType,
                CRYPT_VERIFYCONTEXT | CRYPT_MACHINE_KEYSET // dwFlags
                )) {
            DWORD dwErr = GetLastError();
            
            if (NTE_BAD_FLAGS == dwErr) {
                printf("CryptAcquireContextU(CRYPT_MACHINE_KEYSET) returned NTE_BAD_FLAGS\n");
            }
            else {
                PrintLastError("CryptAcquireContextU(CRYPT_MACHINE_KEYSET)");
            }
        } else {
            printf("\nLocalMachine Containers::\n");
            DisplayProvContainers(hProv, pwszProvName, dwProvType,
                CRYPT_MACHINE_KEYSET);
            CryptReleaseContext(hProv, 0);
        }

        TestFree(pwszProvName);
    }

    printf("Done.\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tpvkload\tpvkload.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tpvkload.cpp
//
//  Contents:   Private Key Load Test
//
//              See Usage() for list of load options.
//
//  Functions:  main
//
//  History:    11-May-96   philh   created
//              31-May-96   helles  Removed check for a particular error code,
//                                  NTE_BAD_KEYSET, since this can get
//                                  overwritten due to known problem with
//                                  the msvcr40d.dll on Win95.
//              07-Jun-96   HelleS  Added printing the command line
//                                  and Failed or Passed at the end.
//
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "pvkhlpr.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static struct
{
    LPCSTR      pszName;
    LPCWSTR     pwszKeyTitle;
    DWORD       dwKeySpec;
} KeyTypes[] = {
    "Sign",     L"Signature",   AT_SIGNATURE,
    "Xchg",     L"Exchange",    AT_KEYEXCHANGE
};
#define NKEYTYPES (sizeof(KeyTypes)/sizeof(KeyTypes[0]))


static void Usage(void)
{
    int i;

    printf("Usage: tpvkload [options] <Filename> <KeyType>\n");
    printf("Options are:\n");
    printf("  -p<number>            - Crypto provider type number\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -F                    - Force load if keys already exist\n");
    printf("  -E                    - Exportable private keys\n");
    printf("  -m                    - test memory version of API\n");
    printf("  -h                    - This message\n");
    printf("\n");
    printf("KeyType (case insensitive):\n");
    for (i = 0; i < NKEYTYPES; i++)
        printf("  %s\n", KeyTypes[i].pszName);
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    HCRYPTPROV hProv = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwProvType = PROV_RSA_FULL;
    BOOL fMem = FALSE;
    BOOL fForce = FALSE;
    BOOL fExportable = FALSE;
    BYTE *pbKey = NULL;
    LPSTR pszContainer = NULL;
    LPSTR pszFilename = NULL;
    LPSTR pszKeyType = NULL;
    int KeyIdx = 0;
    DWORD dwKeySpec;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'F':
                fForce = TRUE;
                break;
            case 'E':
                fExportable = TRUE;
                break;
            case 'm':
                fMem = TRUE;
                break;
            case 'p':
                dwProvType = strtoul( argv[0]+2, NULL, 10);
                break;
            case 'c':
                pszContainer = argv[0]+2;
                if (*pszContainer == '\0') {
                    printf("Need to specify crypto key container name\n");
                    goto BadUsage;
                }
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (pszFilename == NULL)
                pszFilename = argv[0];
            else if(pszKeyType == NULL)
                pszKeyType = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    if (pszFilename == NULL) {
        printf("missing Filename\n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());
    
    if (pszKeyType) {
        for (KeyIdx = 0; KeyIdx < NKEYTYPES; KeyIdx++) {
            if (_stricmp(pszKeyType, KeyTypes[KeyIdx].pszName) == 0)
                break;
        }
        if (KeyIdx >= NKEYTYPES) {
            printf("Bad KeyType: %s\n", pszKeyType);
            goto BadUsage;
        }
    } else {
        printf("missing KeyType\n");
        goto BadUsage;
    }

    hFile = CreateFileA(
            pszFilename,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,                   // lpsa
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL                    // hTemplateFile
            );
    if (hFile == INVALID_HANDLE_VALUE) {
        printf( "can't open %s\n", pszFilename);
        goto ErrorReturn;
    }

    if (!CryptAcquireContext(
            &hProv,
            pszContainer,
            NULL,           // pszProvider
            dwProvType,
            0               // dwFlags
            )) {

//  Removed check for a particular error code,
//  NTE_BAD_KEYSET, since this can get overwritten due to known problem 
//  with the msvcr40d.dll on Win95. 
//        if (GetLastError() != NTE_BAD_KEYSET) {
//            PrintLastError("CryptAcquireContext");
//            goto ErrorReturn;
//        }

        hProv = 0;
        if (!CryptAcquireContext(
                &hProv,
                pszContainer,
                NULL,           // pszProvider
                dwProvType,
                CRYPT_NEWKEYSET
                ) || hProv == 0) {
            PrintLastError("CryptAcquireContext(CRYPT_NEWKEYSET)");
            goto ErrorReturn;
        }
    } else {
        HCRYPTKEY hKey = 0;
        if (!CryptGetUserKey(hProv, KeyTypes[KeyIdx].dwKeySpec, &hKey)) {
            if (GetLastError() != NTE_NO_KEY) {
                PrintLastError("CryptGetUserKey");
                goto ErrorReturn;
            }
        } else {
            CryptDestroyKey(hKey);
            if (!fForce) {
                printf("Private key already exists, use -F to delete private keys\n");
                goto ErrorReturn;
            }

            // Delete the existing keys
            CryptReleaseContext(hProv, 0);
            printf("Deleting existing private keys\n");

            // Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined
            // and must not be released.
            if (!CryptAcquireContext(
                    &hProv,
                    pszContainer,
                    NULL,           // pszProvider
                    dwProvType,
                    CRYPT_DELETEKEYSET
                    ))
                PrintLastError("CryptAcquireContext(CRYPT_DELETEKEYSET)");

            // Create new keyset
            hProv = 0;
            if (!CryptAcquireContext(
                    &hProv,
                    pszContainer,
                    NULL,           // pszProvider
                    dwProvType,
                    CRYPT_NEWKEYSET
                    ) || hProv == 0) {
                PrintLastError("CryptAcquireContext(CRYPT_NEWKEYSET)");
                goto ErrorReturn;
            }
        }
    }

    dwKeySpec = KeyTypes[KeyIdx].dwKeySpec;
    if (fMem) {
        DWORD cbKey;
        DWORD cbRead;

        cbKey = GetFileSize(hFile, NULL);
        if (cbKey == 0) {
            printf( "empty file %s\n", pszFilename);
            goto ErrorReturn;
        }
        if (NULL == (pbKey = (PBYTE)TestAlloc(cbKey)))
            goto ErrorReturn;

        if (!ReadFile(hFile, pbKey, cbKey, &cbRead, NULL) ||
                (cbRead != cbKey)) {
            printf( "can't read %s\n", pszFilename);
            goto ErrorReturn;
        }
        if (!PvkPrivateKeyLoadFromMemory(
                hProv,
                pbKey,
                cbKey,
                NULL,       // hwndOwner
                KeyTypes[KeyIdx].pwszKeyTitle,
                fExportable ? CRYPT_EXPORTABLE : 0, // dwFlags
                &dwKeySpec
                )) {
            PrintLastError("PrivateKeyLoadFromMemory");
            goto ErrorReturn;
        }
    } else {
        if (!PvkPrivateKeyLoad(
                hProv,
                hFile,
                NULL,       // hwndOwner
                KeyTypes[KeyIdx].pwszKeyTitle,
                fExportable ? CRYPT_EXPORTABLE : 0, // dwFlags
                &dwKeySpec
                )) {
            PrintLastError("PrivateKeyLoad");
            goto ErrorReturn;
        }
    }

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
CommonReturn:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (pbKey)
        TestFree(pbKey);
    if (!ReturnStatus)
            printf("Passed\n");
    else
            printf("Failed\n");

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\tpvksave\tpvksave.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       tpvksave.cpp
//
//  Contents:   Private Key Save Test
//
//              See Usage() for list of save options.
//
//  Functions:  main
//
//  History:    11-May-96   philh   created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "pvkhlpr.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static struct
{
    LPCSTR      pszName;
    LPCWSTR     pwszKeyTitle;
    DWORD       dwKeySpec;
} KeyTypes[] = {
    "Sign",     L"Signature",   AT_SIGNATURE,
    "Xchg",     L"Exchange",    AT_KEYEXCHANGE
};
#define NKEYTYPES (sizeof(KeyTypes)/sizeof(KeyTypes[0]))


static void Usage(void)
{
    int i;

    printf("Usage: tpvksave [options] <Filename> <KeyType>\n");
    printf("Options are:\n");
    printf("  -p<number>            - Crypto provider type number\n");
    printf("  -c<name>              - Crypto key container name\n");
    printf("  -d                    - Delete from provider after saving\n");
    printf("  -m                    - Test memory version of API\n");
	printf("  -n                    - Use machine key\n");
	printf("  -3                    - Export as VER3 blob\n");
    printf("  -h                    - This message\n");
    printf("\n");
    printf("KeyType (case insensitive):\n");
    for (i = 0; i < NKEYTYPES; i++)
        printf("  %s\n", KeyTypes[i].pszName);
    printf("\n");
}


int _cdecl main(int argc, char * argv[]) 
{
    int ReturnStatus;
    HCRYPTPROV hProv = 0;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwProvType = PROV_RSA_FULL;
    BOOL fDelete = FALSE;
    BOOL fMem = FALSE;
    LPSTR pszContainer = NULL;
    LPSTR pszFilename = NULL;
    BYTE *pbKey = NULL;
    LPSTR pszKeyType = NULL;
    int KeyIdx = 0;
	DWORD dwFlags = 0;
    DWORD dwSaveFlags = 0;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'd':
                fDelete = TRUE;
                break;
            case 'm':
                fMem = TRUE;
                break;
            case 'p':
                dwProvType = strtoul( argv[0]+2, NULL, 10);
                break;
            case 'c':
                pszContainer = argv[0]+2;
                if (*pszContainer == '\0') {
                    printf("Need to specify crypto key container name\n");
                    goto BadUsage;
                }
                break;
			case 'n':
				dwFlags = CRYPT_MACHINE_KEYSET;
				break;
			case '3':
				dwSaveFlags |= CRYPT_BLOB_VER3;
				break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (pszFilename == NULL)
                pszFilename = argv[0];
            else if(pszKeyType == NULL)
                pszKeyType = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    if (pszFilename == NULL) {
        printf("missing Filename\n");
        goto BadUsage;
    }


    if (pszKeyType) {
        for (KeyIdx = 0; KeyIdx < NKEYTYPES; KeyIdx++) {
            if (_stricmp(pszKeyType, KeyTypes[KeyIdx].pszName) == 0)
                break;
        }
        if (KeyIdx >= NKEYTYPES) {
            printf("Bad KeyType: %s\n", pszKeyType);
            goto BadUsage;
        }
    } else {
        printf("missing KeyType\n");
        goto BadUsage;
    }

    if (!CryptAcquireContext(
            &hProv,
            pszContainer,
            NULL,           // pszProvider
            dwProvType,
            dwFlags        // dwFlags
            )) {
        PrintLastError("CryptAcquireContext");
        goto ErrorReturn;
    }

    hFile = CreateFileA(
            pszFilename,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,                   // lpsa
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL                    // hTemplateFile
            );
    if (hFile == INVALID_HANDLE_VALUE) {
        printf( "can't open %s\n", pszFilename);
        goto ErrorReturn;
    }

    if (fMem) {
        DWORD cbKey;
        DWORD cbWritten;

        cbKey = 0;
        PvkPrivateKeySaveToMemory(
                hProv,
                KeyTypes[KeyIdx].dwKeySpec,
                NULL,       // hwndOwner
                KeyTypes[KeyIdx].pwszKeyTitle,
                dwSaveFlags,
                NULL,                           // pbKey
                &cbKey
                );
        if (cbKey == 0) {
            PrintLastError("PrivateKeySaveToMemory(cbKey == 0)");
            goto ErrorReturn;
        }
        if (NULL == (pbKey = (PBYTE)TestAlloc(cbKey)))
            goto ErrorReturn;
        if (!PvkPrivateKeySaveToMemory(
                hProv,
                KeyTypes[KeyIdx].dwKeySpec,
                NULL,       // hwndOwner
                KeyTypes[KeyIdx].pwszKeyTitle,
                dwSaveFlags,
                pbKey,
                &cbKey
                )) {
            PrintLastError("PrivateKeySaveToMemory");
            goto ErrorReturn;
        }

        if (!WriteFile(hFile, pbKey, cbKey, &cbWritten, NULL)) {
            PrintLastError("WriteFile");
            goto ErrorReturn;
        }
    } else {
        if (!PvkPrivateKeySave(
                hProv,
                hFile,
                KeyTypes[KeyIdx].dwKeySpec,
                NULL,       // hwndOwner
                KeyTypes[KeyIdx].pwszKeyTitle,
                dwSaveFlags
                )) {
            PrintLastError("PrivateKeySave");
            goto ErrorReturn;
        }
    }

    if (fDelete) {
        // Delete the existing keys
        CryptReleaseContext(hProv, 0);
        printf("Deleting existing private keys\n");

        // Note: for CRYPT_DELETEKEYSET, the returned hProv is undefined
        // and must not be released.
        if (!CryptAcquireContext(
                &hProv,
                pszContainer,
                NULL,           // pszProvider
                dwProvType,
                CRYPT_DELETEKEYSET
                ))
            PrintLastError("CryptAcquireContext(CRYPT_DELETEKEYSET)");
        hProv = 0;
    }
            

    ReturnStatus = 0;
    goto CommonReturn;

BadUsage:
    Usage();
ErrorReturn:
    ReturnStatus = -1;
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        DeleteFile(pszFilename);
    }
CommonReturn:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (pbKey)
        TestFree(pbKey);

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trpfx\cmdargs.h ===
//--------------------------------------------------------------------
// CmdArgs - header
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 11-12-2001
//
// stuff to deal with command line arguments
//

#ifndef CMD_ARGS_H
#define CMD_ARGS_H

struct CmdArgs {
    WCHAR ** rgwszArgs;
    unsigned int nArgs;
    unsigned int nNextArg;
};

bool CheckNextArg(IN CmdArgs * pca, IN WCHAR * wszTag, OUT WCHAR ** pwszParam);
bool FindArg(IN CmdArgs * pca, IN WCHAR * wszTag, OUT WCHAR ** pwszParam, OUT unsigned int * pnIndex);
void MarkArgUsed(IN CmdArgs * pca, IN unsigned int nIndex);
HRESULT VerifyAllArgsUsed(IN CmdArgs * pca);

#endif //CMD_ARGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trpfx\cmdargs.cpp ===
//--------------------------------------------------------------------
// CmdArgs - implementation
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 11-11-2001
//
// stuff to deal with command line arguments
//

#include "pch.h"

//--------------------------------------------------------------------
bool CheckNextArg(CmdArgs * pca, WCHAR * wszTag, WCHAR ** pwszParam) {

    // make sure there are more arguments to look at
    if (pca->nNextArg==pca->nArgs) {
        return false;
    }

    WCHAR * wszArg=pca->rgwszArgs[pca->nNextArg];

    // our args must always start with a switch char
    if (L'/'!=wszArg[0] && L'-'!=wszArg[0]) {
        return false;
    }

    wszArg++;
    WCHAR * pwchColon=NULL;
    // if it is supposed to have a parameter, make sure it does
    if (NULL!=pwszParam) {
        pwchColon=wcschr(wszArg, L':');
        if (NULL==pwchColon) {
            return false;
        }
        *pwchColon=L'\0';
    }

    // is this the one we're looking for?
    if (0!=_wcsicmp(wszTag, wszArg)) {
        // no. 
        // put colon back if there was one
        if (NULL!=pwchColon) {
            *pwchColon=L':';
        }
        return false;
    } else {
        // yes.
        // put colon back, and point at the parameter, if necessary
        if (NULL!=pwszParam) {
            *pwchColon=L':';
            *pwszParam=pwchColon+1;
        }
        pca->nNextArg++;
        return true;
    }
}

//--------------------------------------------------------------------
bool FindArg(CmdArgs * pca, WCHAR * wszTag, WCHAR ** pwszParam, unsigned int * pnIndex) {
    unsigned int nOrigNextArg=pca->nNextArg;
    bool bFound=false;

    // check each arg to see if it matches
    unsigned int nIndex;
    for (nIndex=nOrigNextArg; nIndex<pca->nArgs; nIndex++) {
        pca->nNextArg=nIndex;
        if (CheckNextArg(pca, wszTag, pwszParam)) {
            *pnIndex=nIndex;
            bFound=true;
            break;
        }
    }
    pca->nNextArg=nOrigNextArg;
    return bFound;
}

//--------------------------------------------------------------------
void MarkArgUsed(CmdArgs * pca, unsigned int nIndex) {
    if (nIndex<pca->nNextArg || nIndex>=pca->nArgs) {
        return;
    }
    for (; nIndex>pca->nNextArg; nIndex--) {
        WCHAR * wszTemp=pca->rgwszArgs[nIndex];
        pca->rgwszArgs[nIndex]=pca->rgwszArgs[nIndex-1];
        pca->rgwszArgs[nIndex-1]=wszTemp;
    }
    pca->nNextArg++;

}

//--------------------------------------------------------------------
HRESULT VerifyAllArgsUsed(CmdArgs * pca) {
    HRESULT hr;

    if (pca->nArgs!=pca->nNextArg) {
        DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_ERROR_UNEXPECTED_PARAMS);
        for(; pca->nArgs!=pca->nNextArg; pca->nNextArg++) {
            wprintf(L" %s", pca->rgwszArgs[pca->nNextArg]);
        }
        wprintf(L"\n");
        hr=E_INVALIDARG;
        _JumpError(hr, error, "command line parsing");
    }
    hr=S_OK;
error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trpfx\errorhandling.cpp ===
//--------------------------------------------------------------------
// ErrorHandling - implementation
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 11-11-2001
//

#include "pch.h"

//--------------------------------------------------------------------
HRESULT GetSystemErrorString(HRESULT hrIn, WCHAR ** pwszError) {
    HRESULT hr=S_OK;
    DWORD dwResult;
    WCHAR * rgParams[2]={
        NULL,
        (WCHAR *)(ULONG_PTR)hrIn
    };

    // must be cleaned up
    WCHAR * wszErrorMessage=NULL;
    WCHAR * wszFullErrorMessage=NULL;

    // initialize input params
    *pwszError=NULL;

    // get the message from the system
    dwResult=FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
        NULL/*ignored*/, hrIn, 0/*language*/, (WCHAR *)&wszErrorMessage, 0/*min-size*/, NULL/*valist*/);
    if (0==dwResult) {
        if (ERROR_MR_MID_NOT_FOUND==GetLastError()) {
            rgParams[0]=L"";
        } else {
            _JumpLastError(hr, error, "FormatMessage");
        }
    } else {
        rgParams[0]=wszErrorMessage;

        // trim off \r\n if it exists
        if (L'\r'==wszErrorMessage[wcslen(wszErrorMessage)-2]) {
            wszErrorMessage[wcslen(wszErrorMessage)-2]=L'\0';
        }
    }

    // add the error number
    dwResult=FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY, 
        L"%1 (0x%2!08X!)", 0, 0/*language*/, (WCHAR *)&wszFullErrorMessage, 0/*min-size*/, (va_list *)rgParams);
    if (0==dwResult) {
        _JumpLastError(hr, error, "FormatMessage");
    }

    // success
    *pwszError=wszFullErrorMessage;
    wszFullErrorMessage=NULL;
    hr=S_OK;
error:
    if (NULL!=wszErrorMessage) {
        LocalFree(wszErrorMessage);
    }
    if (NULL!=wszFullErrorMessage) {
        LocalFree(wszFullErrorMessage);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trevfunc\trevfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       trevfunc.cpp
//
//  Contents:   CertVerifyRevocation Function Tests
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    21-Dec-96   philh   created
//--------------------------------------------------------------------------


#define CERT_REVOCATION_PARA_HAS_EXTRA_FIELDS   1

#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static void Usage(void)
{
    printf("Usage: trevfunc [options] <FileName1> <FileName2> ...\n");
    printf("Options are:\n");
    printf("  -h                        - This message\n");
    printf("  -r<RevocationType Number> - For example, -r1 (Certificate)\n");
    printf("  -e<Expected Error>        - For example, -e0x0\n");
    printf("  -i<Expected Index>        - For example, -i0\n");
    printf("  -s<SystemStore>           - Additional System Store\n");
    printf("  -S<FileSystemStore>       - Additional File System Store\n");
    printf("  -L<Loop Count>            - Defaults to 1 iteration\n");
    printf("  -t<Number>                - Url timeout (milliseconds)\n");
    printf("  -T<Number>                - Accumulative Url timeout (milliseconds)\n");
    printf("  -f<Number>                - Freshness (seconds)\n");
    printf("\n");
    printf("Defaults:\n");
    printf("  -r%d (Certificate)\n", CERT_CONTEXT_REVOCATION_TYPE);
    printf("  -e0 (All files successfully verified)\n");
    printf("\n");
}



int _cdecl main(int argc, char * argv[])
{
    int status;
    BOOL fResult;

    DWORD dwError = 0;
    DWORD dwIndex = 0;
    DWORD dwRevType = CERT_CONTEXT_REVOCATION_TYPE;

#define MAX_CONTEXT_COUNT 16
    DWORD cFileName = 0;
    LPSTR rgpszFileName[MAX_CONTEXT_COUNT];
    DWORD cContext = 0;
    PVOID rgpvContext[MAX_CONTEXT_COUNT];

    CERT_REVOCATION_STATUS RevStatus;
    CERT_REVOCATION_PARA RevPara;
    PCERT_REVOCATION_PARA pRevPara = NULL;
    HCERTSTORE hAdditionalStore = NULL;

    DWORD i;
    DWORD dwLoopCnt = 1;

    DWORD dwUrlRetrievalTimeout = 0;
    BOOL fCheckFreshnessTime = FALSE;
    DWORD dwFreshnessTime;
    DWORD dwFlags = 0;

    while (--argc>0) {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case 'r':
                dwRevType = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'e':
                dwError = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'i':
                dwIndex = strtoul(argv[0]+2, NULL, 0);
                break;
            case 's':
            case 'S':
                if (NULL == (hAdditionalStore =
                        OpenSystemStoreOrFile(
                            argv[0][1] == 's',  // fSystemStore
                            argv[0]+2,
                            0                   // dwFlags
                            )))
                    goto BadUsage;
                break;
            case 'L':
                dwLoopCnt = strtoul(argv[0]+2, NULL, 0);
                break;
            case 'T':
                dwFlags |= CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG;
            case 't':
                dwUrlRetrievalTimeout = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'f':
                fCheckFreshnessTime = TRUE;
                dwFreshnessTime = (DWORD) strtoul(argv[0]+2, NULL, 0);
                break;
            case 'h':
            default:
                goto BadUsage;
            }
        } else {
            if (cFileName >= MAX_CONTEXT_COUNT) {
                printf("Exceeded maximum FileName count of %d\n",
                        MAX_CONTEXT_COUNT);
                goto BadUsage;
            }
            rgpszFileName[cFileName++] = argv[0];
        }
    }

    if (cFileName == 0) {
        printf("Missing FileNames\n");
        goto BadUsage;
    }

    if (dwRevType != CERT_CONTEXT_REVOCATION_TYPE) {
        printf("Currently only support revocation type (-r%d) (certificates)\n",
            CERT_CONTEXT_REVOCATION_TYPE);
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    for (i = 0; i < cFileName; i++) {
        BYTE *pbDER;
        DWORD cbDER;
        PCCERT_CONTEXT pCert;

        if (!ReadDERFromFile(
                rgpszFileName[i],
                &pbDER,
                &cbDER)) goto ErrorReturn;
        pCert = CertCreateCertificateContext(dwCertEncodingType, pbDER, cbDER);
        TestFree(pbDER);
        if (pCert == NULL) {
            printf("Unable to create certificate context for: %s\n",
                rgpszFileName[i]);
            PrintLastError("CertCreateCertificateContext");
            goto ErrorReturn;
        }
        rgpvContext[cContext++] = (void *) pCert;
    }

    memset(&RevPara, 0, sizeof(RevPara));
    RevPara.cbSize = sizeof(RevPara);

    if ( hAdditionalStore != NULL )
    {
        RevPara.cCertStore = 1;
        RevPara.rgCertStore = &hAdditionalStore;
        RevPara.hCrlStore = hAdditionalStore;
        pRevPara = &RevPara;
    }

    if (dwUrlRetrievalTimeout  || fCheckFreshnessTime) {
        RevPara.dwUrlRetrievalTimeout = dwUrlRetrievalTimeout;
        RevPara.fCheckFreshnessTime = fCheckFreshnessTime;
        RevPara.dwFreshnessTime = dwFreshnessTime;
        pRevPara = &RevPara;
    }

  while (dwLoopCnt--)
  {
    memset(&RevStatus, 0, sizeof(RevStatus));
    RevStatus.cbSize = sizeof(RevStatus);

    fResult = CertVerifyRevocation(
        dwCertEncodingType | dwMsgEncodingType,
        dwRevType,
        cContext,
        rgpvContext,
        dwFlags,
        pRevPara,               // pvReserved
        &RevStatus);

    if (fResult) {
        if (0 == dwError) {
            printf("CertVerifyRevocation:: verified all files\n");
            if (RevStatus.fHasFreshnessTime)
                printf("FreshnessTime: %d\n", RevStatus.dwFreshnessTime);
        } else {
            printf("Failed, CertVerifyRevocation returned Success, not the expected dwError: 0x%x (%d)\n",
                dwError, dwError);
            if (dwLoopCnt == 0)
                goto ErrorReturn;
        }
    } else {
        printf("CertVerifyRevocation:: dwIndex: %d dwError: 0x%x (%d), dwReason: %d\n",
            RevStatus.dwIndex, RevStatus.dwError, RevStatus.dwError,
            RevStatus.dwReason);
        if (RevStatus.fHasFreshnessTime)
            printf("FreshnessTime: %d\n", RevStatus.dwFreshnessTime);
        if (dwError != RevStatus.dwError || dwIndex != RevStatus.dwIndex) {
            printf("Failed, CertVerifyRevocation didn't return the expected dwIndex: %d or dwError: 0x%x (%d)\n",
                dwIndex, dwError, dwError);
            if (dwLoopCnt == 0)
                goto ErrorReturn;
        }
    }
  }

    printf("Passed\n");
    status = 0;

CommonReturn:
    while (cContext--)
        CertFreeCertificateContext((PCCERT_CONTEXT) rgpvContext[cContext]);
    if (hAdditionalStore)
        CertCloseStore(hAdditionalStore, 0);

    return status;

BadUsage:
    Usage();
    status = 0;
    goto CommonReturn;

ErrorReturn:
    printf("Failed\n");
    status = -1;
    goto CommonReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trpfx\errorhandling.h ===
//--------------------------------------------------------------------
// ErrorHandling - header
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 11-11-2001
//
// Macro definitions for CertSrv style error handling
//

#ifndef ERROR_HANDLING_H
#define ERROR_HANDLING_H

#include <memory>
#include <exception>
using namespace std; 


//----------------------------------------------------------------------
// Easy wrapper for FormatMessage()
//----------------------------------------------------------------------
HRESULT GetSystemErrorString(HRESULT hrIn, WCHAR ** pwszError);

//----------------------------------------------------------------------
// Exception handling translation code.
// Translates SEH to C++-style exceptions.
//----------------------------------------------------------------------
class SeException : public std::exception
{
 public:
    SeException(unsigned int code) : m_code(code) { } 
    unsigned int getSECode() { return m_code; } 

 private:
    unsigned int m_code; 
}; 

void __cdecl SeTransFunc(unsigned int u, EXCEPTION_POINTERS* pExp);

//----------------------------------------------------------------------
// C-style error-handling routines.
//----------------------------------------------------------------------
#ifdef DBG
#define _MyAssert(expression) \
    {\
        if (!(expression)) { \
            DebugWPrintf1(L"*** Assert failed: '%s' is false.\n", L## #expression); \
            DebugBreak(); \
        }\
    }
#else  //DBG
#define _MyAssert(expression)
#endif //DBG

#define _Verify(expression, hr, label) \
    {\
        if (!(expression)) { \
            DebugWPrintf1(L"Verify failed: '%s' is false.\n", L## #expression); \
            hr=E_UNEXPECTED; \
            goto label; \
        }\
    }

#define _IgnoreError(hr, errorsource) \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X, ignored.\n", hr);

#define _IgnoreErrorStr(hr, errorsource, wstr) \
    DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X, ignored.\n", wstr, hr);

#define _IgnoreLastError(errorsource) \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X, ignored.\n", HRESULT_FROM_WIN32(GetLastError()));

#define _IgnoreIfError(hr, errorsource) \
    {\
        if (FAILED(hr)) { \
            DebugWPrintf1(L##errorsource L" failed with 0x%08X, ignored.\n", hr); \
        }\
    }

#define _JumpError(hr, label, errorsource) \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X.\n", hr); \
    goto label;

#define _JumpErrorStr(hr, label, errorsource, wstr) \
    DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X.\n", wstr, hr); \
    goto label;

#define _JumpLastError(hr, label, errorsource) \
    hr=HRESULT_FROM_WIN32(GetLastError()); \
    DebugWPrintf1(L##errorsource L" failed with 0x%08X.\n", hr); \
    goto label;

#define _JumpLastErrorStr(hr, label, errorsource, wstr) \
    hr=HRESULT_FROM_WIN32(GetLastError()); \
    DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X.\n", wstr, hr); \
    goto label;

#define _JumpIfError(hr, label, errorsource) \
    {\
        if (FAILED(hr)) { \
            DebugWPrintf1(L##errorsource L" failed with 0x%08X.\n", hr); \
            goto label; \
        }\
    }

#define _JumpIfErrorStr(hr, label, errorsource, wstr) \
    {\
        if (FAILED(hr)) { \
            DebugWPrintf2(L##errorsource L"(%s) failed with 0x%08X.\n", wstr, hr); \
            goto label; \
        }\
    }

#define _JumpIfOutOfMemory(hr, label, pointer) \
    {\
        if (NULL==(pointer)) { \
            hr=E_OUTOFMEMORY; \
            DebugWPrintf0(L"Out of memory ('" L## #pointer L"').\n"); \
            goto label; \
        }\
    }


// Save the old se translator so we can restore it when we're done 
#define _BeginTryWith(hr) \
    { \
        _se_translator_function  fnSeTranslatorOld = _set_se_translator(SeTransFunc); \
        hr=S_OK; \
        try 

#define _TrapException(hr) \
        catch (SeException see) { \
            hr = HRESULT_FROM_WIN32(see.getSECode()); \
        } \
        catch (std::bad_alloc bae) { \
            hr = E_OUTOFMEMORY; \
        } \
        catch (...) { \
            hr = E_UNEXPECTED; \
        } \
        _set_se_translator(fnSeTranslatorOld); \
    }

#define _TeardownError(hr, hr2, errorsource) \
    {\
        if (FAILED(hr2)) { \
            DebugWPrintf1(L##errorsource L" failed with 0x%08X during teardown.\n", hr2); \
            if (!FAILED(hr)) { \
                hr=hr2; \
            } \
        }\
    }

#define _SafeStlCall(func, hr, error, errorsource) \
    {\
        _BeginTryWith(hr) {\
            (func); \
        } _TrapException(hr); \
        if (FAILED(hr)) { \
            _JumpError(hr, error, errorsource); \
        } \
    }


#define _AcquireResourceSharedOrFail(lock, bAcquiredResource, hr, error) \
{ \
    BOOLEAN bSuccess = FALSE; \
    HRESULT hr2 = myRtlAcquireResourceShared((lock), TRUE, &bSuccess);  \
    if (FAILED(hr2)) { \
        hr = hr2; \
        _JumpError(hr, error, "myRtlAcquireResourceShared"); \
    } else if (!bSuccess) { \
        hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR); \
        _JumpError(hr, error, "myRtlAcquireResourceShared: couldn't acquire resource"); \
    } \
    bAcquiredResource = true; \
}

#define _AcquireResourceExclusiveOrFail(lock, bAcquiredResource, hr, error) \
{ \
    BOOLEAN bSuccess = FALSE; \
    HRESULT hr2 = myRtlAcquireResourceExclusive((lock), TRUE, &bSuccess);  \
    if (FAILED(hr2)) { \
        hr = hr2; \
        _JumpError(hr, error, "myRtlAcquireResourceShared"); \
    } else if (!bSuccess) { \
        hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR); \
        _JumpError(hr, error, "myRtlAcquireResourceShared: couldn't acquire resource"); \
    } \
    bAcquiredResource = true; \
}

#define _ReleaseResource(lock, bAcquiredResource) \
{ \
    if (bAcquiredResource) { \
        HRESULT hr2 = myRtlReleaseResource(lock); \
        _IgnoreIfError(hr2, "myRtlReleaseResource"); \
        if (SUCCEEDED(hr2)) { \
            bAcquiredResource = false; \
        } \
    } \
} 

#define _EnterCriticalSectionOrFail(lock, bAcquiredResource, hr, error) \
{ \
    hr = myEnterCriticalSection(lock);  \
    _JumpIfError(hr, error, "myEnterCriticalSection"); \
    bAcquiredResource = true; \
}

#define _LeaveCriticalSection(lock, bAcquiredResource, hr) \
{ \
    if (bAcquiredResource) { \
        HRESULT hr2 = myLeaveCriticalSection(lock); \
        _TeardownError(hr, hr2, "myLeaveCriticalSection"); \
    } \
}

#endif ERROR_HANDLING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trootlist\trootlist.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       trootlist.cpp
//
//  Contents:   Test for the Signed List of Trusted Roots APIs
//
//              See Usage() for a list of test options.
//
//
//  Functions:  main
//
//  History:    01-Aug-99   philh    created
//--------------------------------------------------------------------------


#include <windows.h>
#include <assert.h>
#include "wincrypt.h"
#include "certtest.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

static void Usage(void)
{
    printf("Usage: trootlist [options] <FileOrUrl>\n");
    printf("Options are:\n");
    printf("  -h                    - This message\n");
    printf("  -b                    - Brief\n");
    printf("  -v                    - Verbose\n");
    printf("  -U                    - URL (file default)\n");
    printf("  -C                    - Intermediate CAs\n");
    printf("\n");
}

int _cdecl main(int argc, char * argv[]) 
{
    BOOL fResult;
    int status;
    LPCSTR pszFileOrUrl = NULL;     // Not allocated
    LPWSTR pwszUrl = NULL;          // TestAlloc()'ed
    BYTE *pbEncoded = NULL;         // TestAlloc()'ed
    DWORD cbEncoded;
    DWORD dwDisplayFlags = 0;
    BOOL fUrl = FALSE;
    BOOL fCAs = FALSE;

    CRYPT_DATA_BLOB EncodedBlob;
    void *pvList;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
                case 'U':
                    fUrl = TRUE;
                    break;
                case 'C':
                    fCAs = TRUE;
                    break;
                case 'b':
                    dwDisplayFlags |= DISPLAY_BRIEF_FLAG;
                    break;
                case 'v':
                    dwDisplayFlags |= DISPLAY_VERBOSE_FLAG;
                    break;
                case 'h':
                default:
                    goto BadUsage;
            }
        } else {
            if (pszFileOrUrl == NULL)
                pszFileOrUrl = argv[0];
            else {
                printf("Too many arguments\n");
                goto BadUsage;
            }
        }
    }

    if (pszFileOrUrl == NULL) {
        printf("missing FileOrUrl \n");
        goto BadUsage;
    }

    printf("command line: %s\n", GetCommandLine());

    if (fUrl) {
        pwszUrl = AllocAndSzToWsz(pszFileOrUrl);
        pvList = (void *) pwszUrl;
    } else {
        if (!ReadDERFromFile(pszFileOrUrl, &pbEncoded, &cbEncoded))
            goto ErrorReturn;
        EncodedBlob.pbData = pbEncoded;
        EncodedBlob.cbData = cbEncoded;
        pvList = (void *) &EncodedBlob;
    }

    if (fCAs) {
        fResult = CertInstallIntermediateCAs(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            fUrl ? CERT_INSTALL_CA_FORMAT_URL : CERT_INSTALL_CA_FORMAT_BLOB,
            pvList,
            0,                  // dwFlags
            NULL                // pvReserved
            );
        if (!fResult)
            PrintLastError("CertInstallIntermediateCAs");
        else
            printf("Successful CertInstallIntermediateCAs\n");
    } else {
        fResult = CertInstallSignedListOfTrustedCertificates(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            CERT_INSTALL_SIGNED_LIST_PURPOSE_TRUSTED_ROOTS,
            fUrl ? CERT_INSTALL_SIGNED_LIST_FORMAT_URL :
                   CERT_INSTALL_SIGNED_LIST_FORMAT_BLOB,
            pvList,
            0,                  // dwFlags
            NULL                // pvReserved
            );
        if (!fResult)
            PrintLastError("CertInstallSignedListOfTrustedCertificates");
        else
            printf("Successful CertInstallSignedListOfTrustedCertificates\n");
    }

    printf("Passed\n");
    status = 0;

CommonReturn:
    if (pbEncoded)
        TestFree(pbEncoded);
    if (pwszUrl)
        TestFree(pwszUrl);

    return status;
ErrorReturn:
    status = -1;
    printf("Failed\n");
    goto CommonReturn;

BadUsage:
    Usage();
    goto ErrorReturn;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trpfx\pch.h ===
//--------------------------------------------------------------------
// pch - header
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 11-12-2001
//
// Precompiled header for rpfx
//

#include <windows.h>
#include <eh.h>
#include <malloc.h>
#include <vector>
#include <list>
#include <algorithm>
#include <exception>
#include <wchar.h>
#include <wincrypt.h>
#include <rkeysvcc.h>
#include <shellapi.h>
#include "rpfxmsg.h"
#include "printlib.h"
#include "ErrorHandling.h"
#include "CmdArgs.h"
#include "utils.h"

using namespace std;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trpfx\printlib.h ===
//--------------------------------------------------------------------
// printlib - header
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 11-11-2001
//
// Various print routines
//

#ifndef PRINTLIB_H
#define PRINTLIB_H

#ifndef DBG

#define DebugWPrintf0(wszFormat)
#define DebugWPrintf1(wszFormat,a)
#define DebugWPrintf2(wszFormat,a,b)
#define DebugWPrintf3(wszFormat,a,b,c)
#define DebugWPrintf4(wszFormat,a,b,c,d)
#define DebugWPrintf5(wszFormat,a,b,c,d,e)
#define DebugWPrintf6(wszFormat,a,b,c,d,e,f)
#define DebugWPrintf7(wszFormat,a,b,c,d,e,f,g)
#define DebugWPrintf8(wszFormat,a,b,c,d,e,f,g,h)
#define DebugWPrintf9(wszFormat,a,b,c,d,e,f,g,h,i)

#else //DBG

#define DebugWPrintf0(wszFormat)                   DebugWPrintf_((wszFormat))
#define DebugWPrintf1(wszFormat,a)                 DebugWPrintf_((wszFormat),(a))
#define DebugWPrintf2(wszFormat,a,b)               DebugWPrintf_((wszFormat),(a),(b))
#define DebugWPrintf3(wszFormat,a,b,c)             DebugWPrintf_((wszFormat),(a),(b),(c))
#define DebugWPrintf4(wszFormat,a,b,c,d)           DebugWPrintf_((wszFormat),(a),(b),(c),(d))
#define DebugWPrintf5(wszFormat,a,b,c,d,e)         DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e))
#define DebugWPrintf6(wszFormat,a,b,c,d,e,f)       DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f))
#define DebugWPrintf7(wszFormat,a,b,c,d,e,f,g)     DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f),(g))
#define DebugWPrintf8(wszFormat,a,b,c,d,e,f,g,h)   DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h))
#define DebugWPrintf9(wszFormat,a,b,c,d,e,f,g,h,i) DebugWPrintf_((wszFormat),(a),(b),(c),(d),(e),(f),(g),(h),(i))

void DebugWPrintf_(const WCHAR * wszFormat, ...);

#endif //DBG

HRESULT InitializeConsoleOutput(); 
VOID DisplayMsg(DWORD dwSource, DWORD dwMsgId, ... ); 

#endif // PRINTLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trpfx\utils.h ===
//--------------------------------------------------------------------
// utils - header
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 11-11-2001
//
// Various utility functions


#ifndef UTILS_H
#define UTILS_H


HRESULT MyMapFile(LPWSTR wszFileName, LPBYTE *ppbFile, DWORD *pcbFile);
HRESULT MyUnmapFile(LPCVOID pvBaseAddress);

void  InitKeysvcUnicodeString(PKEYSVC_UNICODE_STRING pUnicodeString, LPCWSTR wszString);
LPSTR MBFromWide(LPCWSTR wsz);

typedef vector<LPWSTR>        StringList;
typedef StringList::iterator  StringIter;

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


#endif // UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\test\capi20\trpfx\rpfx.cpp ===
//depot/Lab03_DEV/Ds/security/cryptoapi/test/capi20/trpfx/rpfx.cpp#2 - edit change 21738 (text)
//--------------------------------------------------------------------
// rpfx - implementation
// Copyright (C) Microsoft Corporation, 2001
//
// Created by: Duncan Bryce (duncanb), 11-11-2001
//
// Core functionality of the rpfx tool 


#include "pch.h"

HINSTANCE g_hThisModule = NULL;


//--------------------------------------------------------------------------
void __cdecl SeTransFunc(unsigned int u, EXCEPTION_POINTERS* pExp) { 
    throw SeException(u); 
}

//--------------------------------------------------------------------------
void PrintHelp() { 
    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_HELP); 
}

//--------------------------------------------------------------------------
extern "C" LPVOID MIDL_user_allocate(size_t cb) {
    return LocalAlloc(LPTR, cb); 
}

//--------------------------------------------------------------------------
extern "C" void MIDL_user_free(LPVOID pvBuffer) {
    LocalFree(pvBuffer); 
}

//--------------------------------------------------------------------------
HRESULT ParseServerFile(LPWSTR wszFileName, StringList & vServers) { 
    FILE     *pFile             = NULL; 
    HRESULT   hr; 
    WCHAR    *wszCurrent        = NULL; 
    WCHAR     wszServer[1024]; 

    ZeroMemory(&wszServer, sizeof(wszServer)); 
    
    pFile = _wfopen(wszFileName, L"r");
    if(NULL == pFile) { 
	_JumpLastError(hr, error, "_wfopen"); 
    }

    while (1 == fwscanf(pFile, L"%s", wszServer)) { 
	if (L'\0' != *wszServer) { 
	    // Not worth bothering to do more than this for a simple command-line tool like this
	    _MyAssert(wcslen(wszServer) < ARRAYSIZE(wszServer)); 
	    
	    wszCurrent = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(wszServer)+1)); 
	    _JumpIfOutOfMemory(hr, error, wszCurrent); 
	    wcscpy(wszCurrent, wszServer); 

	    _SafeStlCall(vServers.push_back(wszCurrent), hr, error, "vServers.push_back(wszServer)"); 
	    wszCurrent = NULL; 
	}

	fgetwc(pFile); 
    }

    hr = S_OK;
 error:
    if (NULL != pFile) { 
	fclose(pFile); 
    }
    if (NULL != wszCurrent) { 
	LocalFree(wszCurrent); 
    }
    // Caller is responsible for freeing strings in vServers. 

    return hr;
}


//---------------------------------------------------------------------------------
HRESULT RemoteInstall(CmdArgs *pca) { 
    bool                   bExportable        = false; 
    bool                   bFreeServerList    = false; 
    bool                   bImpersonated      = false; 
    DWORD                  dwResult; 
    HANDLE                 hToken             = NULL; 
    HRESULT                hr; 
    KEYSVC_BLOB            blobPFX; 
    KEYSVC_UNICODE_STRING  strPassword; 
    KEYSVCC_HANDLE         hKeySvcCli         = NULL; 
    LPSTR                  szMachineName      = NULL; 
    LPWSTR                 wszDomainName      = NULL;  // doesn't need to be freed
    LPWSTR                 wszFileName        = NULL;  // doesn't need to be freed
    LPWSTR                 wszPassword        = NULL;  // doesn't need to be freed
    LPWSTR                 wszPFXPassword     = NULL;  // doesn't need to be freed
    LPWSTR                 wszServerName      = NULL;  // doesn't need to be freed
    LPWSTR                 wszServerFileName  = NULL;  // doesn't need to be freed
    LPWSTR                 wszUserAndDomain   = NULL;  // doesn't need to be freed
    LPWSTR                 wszUserName        = NULL;  // doesn't need to be freed
    StringList             vServers; 
    ULONG                  ulPFXImportFlags; 
    unsigned int           nArgID;

    ZeroMemory(&blobPFX,      sizeof(blobPFX)); 
    ZeroMemory(&strPassword,  sizeof(strPassword)); 

    // We're doing a remote PFX install.  Attempt to parse the information
    // we need from the command line.  We need:
    //
    // a) The path to the PFX file to install
    //

    if (FindArg(pca, L"file", &wszFileName, &nArgID)) { 
	MarkArgUsed(pca, nArgID); 
    } else { 
	DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_ERROR_PARAMETER_MISSING, L"pfxfile"); 
	hr = E_INVALIDARG; 
	_JumpError(hr, error, "RemoteInstall: pfxfile missing"); 
    }

    // b) Either a machine name to install the file on, or a file which contains
    //    a carriage-return delimted list of machines to install the file on
    //

    if (FindArg(pca, L"server", &wszServerName, &nArgID)) { 
	MarkArgUsed(pca, nArgID); 
	
	_SafeStlCall(vServers.push_back(wszServerName), hr, error, "vServers.push_back"); 
	wszServerName = NULL;  // we'll clean up all strings in vServers
    } else { 
	// No remote machine was specified.  See if they specified a server file: 
	if (FindArg(pca, L"serverlist", &wszServerFileName, &nArgID)) { 
	    MarkArgUsed(pca, nArgID); 
	    
	    bFreeServerList = true; 
	    hr = ParseServerFile(wszServerFileName, vServers); 
	    _JumpIfError(hr, error, "ParseServerFile"); 
	} else { 
	  DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_ERROR_ONEOF_2_PARAMETERS_MISSING, L"server", L"serverfile"); 
	    hr = E_INVALIDARG; 
	    _JumpError(hr, error, "RemoteInstall: pfx destination missing"); 
	}
    }

    // c) The password to use when importing the pfx file: 
    // 

    if (FindArg(pca, L"pfxpwd", &wszPFXPassword, &nArgID)) { 
	MarkArgUsed(pca, nArgID); 
	InitKeysvcUnicodeString(&strPassword, wszPFXPassword); 
    } else { 
	DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_ERROR_PARAMETER_MISSING, L"pfxpassword"); 
	hr = E_INVALIDARG; 
	_JumpError(hr, error, "RemoteInstall: pfxpassword missing"); 
    }

    // d) Optionally, flags controlling key creation on the remote machine.  
    //    Only CRYPT_EXPORTABLE may be currently specified
    // 

    if (FindArg(pca, L"exportable", NULL, &nArgID)) { 
	MarkArgUsed(pca, nArgID); 
	bExportable = true; 
    }
    
    // e) Optionally, a username & password combination to use when authenticating to the remote machines
    //
    
    if (FindArg(pca, L"user", &wszUserAndDomain, &nArgID)) { 
	MarkArgUsed(pca, nArgID); 

	if (FindArg(pca, L"pwd", &wszPassword, &nArgID)) { 
	    MarkArgUsed(pca, nArgID); 
	    
	    // Parse the username string to see if we have UPN or NT4 style.
	    WCHAR *wszSplit = wcschr(wszUserAndDomain, L'\\'); 
	    if (NULL != wszSplit) {
		wszDomainName = wszUserAndDomain; 
		*wszSplit = L'\0'; 
		wszUserName = wszSplit+1; 
	    } else { 
		wszUserName = wszUserAndDomain; 
	    }

	    if (!LogonUser(wszUserName, wszDomainName, wszPassword, LOGON32_LOGON_NEW_CREDENTIALS, LOGON32_PROVIDER_WINNT50, &hToken)) { 
		_JumpLastError(hr, error, "LogonUser"); 
	    }

	    if (!ImpersonateLoggedOnUser(hToken)) { 
		_JumpLastError(hr, error, "ImpersonateLoggedOnUser"); 
	    }
	    bImpersonated = true; 

	} else { 
	    DisplayMsg(FORMAT_MESSAGE_FROM_HMODULE, IDS_ERROR_PARAMETER_MISSING, L"password"); 
	    hr = E_INVALIDARG; 
	    _JumpError(hr, error, "RemoteInstall: password missing"); 
	}
    }

    hr = VerifyAllArgsUsed(pca);
    _JumpIfError(hr, error, "VerifyAllArgsUsed"); 

    // Calculate the import flags we're going to use based on the command line options:
    // 
    ulPFXImportFlags = CRYPT_MACHINE_KEYSET; 
    if (bExportable) { 
	ulPFXImportFlags |= CRYPT_EXPORTABLE; 
    }
    
    for (StringIter wszIter = vServers.begin(); wszIter != vServers.end(); wszIter++) { 
	szMachineName = MBFromWide(*wszIter); 
	if (NULL == szMachineName) { 
	    _JumpLastError(hr, error, "MBFromWide"); 
	}

	// Attempt to bind to the remote machine: 
	dwResult = RKeyOpenKeyService(szMachineName, KeySvcMachine, NULL, (void *)0 /*allow insecure connection*/, NULL, &hKeySvcCli); 
	if (ERROR_SUCCESS != dwResult) { 
	    hKeySvcCli = NULL; // handle is invalid on error
	    hr = HRESULT_FROM_WIN32(dwResult); 
	    _JumpError(hr, NextServer, "RKeyOpenKeyService"); 
	}

	// If we haven't yet, map the PFX file: 
	if (NULL == blobPFX.pb) { 
	    hr = MyMapFile(wszFileName, &blobPFX.pb, &blobPFX.cb); 
	    _JumpIfError(hr, error, "MyMapFile"); 
	}
	
	// Install the PFX file on the remote machine: 
	dwResult = RKeyPFXInstall(hKeySvcCli, &blobPFX, &strPassword, ulPFXImportFlags);
	if (ERROR_SUCCESS != dwResult) { 
	    hr = HRESULT_FROM_WIN32(dwResult);
	    _JumpError(hr, NextServer, "RKeyPFXInstall"); 
	}

    NextServ