EAD, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)))
            {
                GetFullPathName(szCurDirFile,cbSize/sizeof(TCHAR),lpszPath,&pszFilePart);
                f = TRUE;
                goto DidOpen;
            }
        }

        //AnsiToOem((LPTSTR)szTmpFile, (LPTSTR)szTmpFile);
        if (-1 != (HFILE)HandleToUlong(CreateFile(szTmpFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)))
        {
            if (fHadEnvStrings)
                lstrcpyn(lpszPath, lpszFile, cbSize);
            else
                GetFullPathName(szTmpFile,cbSize/sizeof(TCHAR),lpszPath,&pszFilePart);
            f = TRUE;
        }
        else if (fTryCurDir && !fTriedCurDir)
        {
            TCHAR szCurDirFile[MAXSTR];

            //OemToAnsi((LPTSTR)szTmpFile, (LPTSTR)szTmpFile);
            lstrcpy (szCurDirFile, gszCurDir);
            lstrcat (szCurDirFile, cszSlash);
            lstrcat (szCurDirFile, szTmpFile);
            lstrcpy((LPTSTR)szTmpFile, (LPTSTR)szCurDirFile);
            fTriedCurDir = TRUE;
            goto  TryOpen;
        }
    }

DidOpen:
    SetErrorMode(fErrMode);
    return f;
}



/*
 ***************************************************************
 * ChangeSoundMapping
 *
 * Description:
 *      Change the sound file associated with a sound
 *
 * Parameters:
 *      HWND    hDlg   - handle to dialog window.
 *      LPTSTR    lpszFile    - New filename for current event
 *      LPTSTR    lpszDir    - New foldername for current event     
 *      LPTSTR    lpszPath    - New absolute path for file
 *
 * Returns:        BOOL
 *      
 ***************************************************************
 */
BOOL PASCAL ChangeSoundMapping(HWND hDlg, LPTSTR lpszPath, PEVENT pEvent)
{
    TCHAR    szValue[MAXSTR];    
    
    if (!pEvent)
    {
        if(!ghse)
            EnableWindow(GetDlgItem(hDlg, ID_PLAY), FALSE);            
        EnableWindow(GetDlgItem(hDlg, IDC_SOUND_FILES), FALSE);
        ShowSoundMapping(hDlg,NULL);
        return TRUE;
    }
    szValue[0] = TEXT('\0');
    if (!ChangeSetting((LPTSTR *)&(pEvent->pszPath), lpszPath))
        return FALSE;        
    if(!ghse)
        EnableWindow(GetDlgItem(hDlg, ID_PLAY), TRUE);            
    EnableWindow(GetDlgItem(hDlg, IDC_SOUND_FILES), TRUE);            
    ShowSoundMapping(hDlg,pEvent);
    gfChanged = TRUE;
    gfNewScheme = TRUE;
    PropSheet_Changed(GetParent(hDlg),hDlg);
    return TRUE;
}

STATIC void SetTreeStateIcon(HWND hDlg, int iImage)
{
    TV_ITEM tvi;
    HWND hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);
    HTREEITEM hti;

    if (ghOldItem)
        hti = ghOldItem;
    else
        hti = TreeView_GetSelection(hwndTree);
    if (hti)
    {
        tvi.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
        tvi.hItem = hti;
        tvi.iImage = tvi.iSelectedImage = iImage;
        TreeView_SetItem(hwndTree, &tvi);
        RedrawWindow(hwndTree, NULL, NULL, RDW_ERASE|RDW_ERASENOW|RDW_INTERNALPAINT|RDW_INVALIDATE | RDW_UPDATENOW);
    }
}

/*
 ***************************************************************
 * ShowSoundMapping
 *
 * Description:
 *      Highlights the label and calls ShowSoundDib to display the Dib 
 *        associated with the current event.
 *
 * Parameters:
 *    HWND    hDlg   - handle to dialog window.
 *
 * Returns:    BOOL
 *      
 ***************************************************************
 */
BOOL PASCAL ShowSoundMapping(HWND hDlg, PEVENT pEvent)
{
    TCHAR    szOut[MAXSTR];            

    if (!pEvent)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SOUND_FILES), FALSE);            
        EnableWindow(GetDlgItem(hDlg, ID_BROWSE), FALSE);            
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_NAME), FALSE);    
    //    wsprintf((LPTSTR)szCurSound, (LPTSTR)gszSoundGrpStr, (LPTSTR)gszNull);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SOUND_FILES), TRUE);            
        EnableWindow(GetDlgItem(hDlg, ID_BROWSE), TRUE);            
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_NAME), TRUE);    
    //    wsprintf((LPTSTR)szCurSound, (LPTSTR)gszSoundGrpStr, (LPTSTR)pEvent->pszEventLabel);
    }
    //SetWindowText(GetDlgItem(hDlg, IDC_SOUNDGRP), (LPTSTR)szCurSound);
    //RedrawWindow(GetDlgItem(hDlg, IDC_EVENT_TREE), NULL, NULL, RDW_ERASE|RDW_ERASENOW|RDW_INTERNALPAINT|RDW_INVALIDATE | RDW_UPDATENOW);

    if (!pEvent || !QualifyFileName(pEvent->pszPath, szOut, sizeof(szOut), FALSE))
    {
        int iLen;

        if(!ghse)
            EnableWindow(GetDlgItem(hDlg, ID_PLAY), FALSE);
        
        if(pEvent)
            iLen = lstrlen(pEvent->pszPath);
        if (pEvent && iLen > 0)
        {
            if (iLen < 5)
            {
                lstrcpy(pEvent->pszPath, gszNull);
                gfChanged = TRUE;
                gfNewScheme = TRUE;
                PropSheet_Changed(GetParent(hDlg),hDlg);
            }
            else
            {
                TCHAR szMsg[MAXSTR];
                TCHAR szTitle[MAXSTR];

                LoadString(ghInstance, IDS_NOSNDFILE, szTitle, sizeof(szTitle)/sizeof(TCHAR));
                wsprintf(szMsg, szTitle, pEvent->pszPath);
                LoadString(ghInstance, IDS_NOSNDFILETITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR));
                if (MessageBox(hDlg, szMsg, szTitle, MB_YESNO) == IDNO)
                {
                    lstrcpy(pEvent->pszPath, gszNull);
                    ComboBox_SetText(GetDlgItem(hDlg, IDC_SOUND_FILES), gszNone);                
                    gfChanged = TRUE;
                    gfNewScheme = TRUE;
                    PropSheet_Changed(GetParent(hDlg),hDlg);
                    if (pEvent && pEvent->fHasSound)
                    {
                        SetTreeStateIcon(hDlg, 2);
                        pEvent->fHasSound = FALSE;
                    }
                }
                else
                {
                    lstrcpy(szOut ,pEvent->pszPath); 
                    ChopPath((LPTSTR)szOut);
                    NiceName((LPTSTR)szOut, FALSE);
                    ComboBox_SetText(GetDlgItem(hDlg, IDC_SOUND_FILES), szOut);
                    if (!pEvent->fHasSound)
                    {
                        SetTreeStateIcon(hDlg, 1);
                        pEvent->fHasSound = TRUE;
                    }
                }
            }
        }
        else
        {
            ComboBox_SetText(GetDlgItem(hDlg, IDC_SOUND_FILES), gszNone);                
            if (pEvent && pEvent->fHasSound)
            {
                SetTreeStateIcon(hDlg, 2);
                pEvent->fHasSound = FALSE;
            }
        }
    }
    else
    {
        if(!ghse)
            EnableWindow(GetDlgItem(hDlg, ID_PLAY),gfWaveExists);
        ChopPath((LPTSTR)szOut);
        NiceName((LPTSTR)szOut, FALSE);
        ComboBox_SetText(GetDlgItem(hDlg, IDC_SOUND_FILES), szOut);
        if (!pEvent->fHasSound)
        {
            SetTreeStateIcon(hDlg, 1);
            pEvent->fHasSound = TRUE;
        }

    }
    return TRUE;
}

/*
 ***************************************************************
 * PlaySoundFile
 *
 * Description:
 *        Plays the given sound file.
 *
 * Parameters:
 *    HWND  hDlg   - Window handle
 *      LPTSTR    lpszFile - absolute path of File to play.
 *
 * Returns:    BOOL 
 *  
 ***************************************************************
 */
BOOL PASCAL PlaySoundFile(HWND hDlg, LPTSTR lpszFile)
{
        
    TCHAR     szOut[MAXSTR];            
    TCHAR     szTemp[MAXSTR]; 
	BOOL      rb = TRUE;
        
    if (!QualifyFileName(lpszFile, szTemp, sizeof(szTemp), FALSE))
	{
        ErrorBox(hDlg, IDS_ERRORPLAY, lpszFile);
		rb = FALSE;
	}
    else{
        MMRESULT err = MMSYSERR_NOERROR;

        ExpandEnvironmentStrings (szTemp, szOut, MAXSTR);

        if((soundOpen(szOut, hDlg, &ghse) != MMSYSERR_NOERROR) || ((err = soundPlay(ghse)) != MMSYSERR_NOERROR))
        {
            if (err >= (MMRESULT)MMSYSERR_LASTERROR)
                ErrorBox(hDlg, IDS_ERRORUNKNOWNPLAY, lpszFile);
            else if (err ==  (MMRESULT)MMSYSERR_ALLOCATED)
                ErrorBox(hDlg, IDS_ERRORDEVBUSY, lpszFile);
            else
                ErrorBox(hDlg, IDS_ERRORFILEPLAY, lpszFile);
            ghse = NULL;
			rb = FALSE;
        }
    }
    return rb;    
}

/*
 ***************************************************************
 * ChangeSetting
 *
 * Description:
 *        Displays the labels of all the links present in the lpszDir folder
 *        in the LB_SOUNDS listbox
 *
 * Parameters:
 *    HWND  hDlg   - Window handle
 *      LPTSTR lpszDir -  Name of sound folder whose files must be displayed.
 *
 * Returns:    BOOL
 *  
 ***************************************************************
 */
BOOL PASCAL ChangeSetting(LPTSTR *npOldString, LPTSTR lpszNew)
{
    int len =  (lstrlen(lpszNew)*sizeof(TCHAR))+sizeof(TCHAR);

    if (*npOldString) 
    {
        LocalFree(*npOldString);
    }
    
    *npOldString = (LPTSTR)LocalAlloc(LPTR, len);
 
    if (*npOldString == NULL)
    {
        DPF("LocalAlloc Failed\n");        
        return FALSE;            
    }                                                
    lstrcpy(*npOldString, lpszNew);
    DPF("New file is %s\n", (LPTSTR)*npOldString);    
    return TRUE;
}



STATIC HANDLE PASCAL GetRiffDisp(HMMIO hmmio)
{
    MMCKINFO    ck;
    MMCKINFO    ckRIFF;
    HANDLE    h = NULL;
    LONG        lSize;
    DWORD       dw;

    mmioSeek(hmmio, 0, SEEK_SET);

    /* descend the input file into the RIFF chunk */
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
        goto error;

    if (ckRIFF.ckid != FOURCC_RIFF)
        goto error;

    while (!mmioDescend(hmmio, &ck, &ckRIFF, 0))
    {
        if (ck.ckid == FOURCC_DISP)
        {
            /* Read dword into dw, break if read unsuccessful */
            if (mmioRead(hmmio, (LPVOID)&dw, sizeof(dw)) != (LONG)sizeof(dw))
                goto error;

            /* Find out how much memory to allocate */
            lSize = ck.cksize - sizeof(dw);

            if ((int)dw == CF_DIB && h == NULL)
            {
                /* get a handle to memory to hold the description and 
                    lock it down */
                
                if ((h = GlobalAlloc(GHND, lSize+4)) == NULL)
                    goto error;

                if (mmioRead(hmmio, GlobalLock(h), lSize) != lSize)
                    goto error;
            }
        }
        //
        // if we have both a picture and a title, then exit.
        //
        if (h != NULL)
            break;

        /* Ascend so that we can descend into next chunk
         */
        if (mmioAscend(hmmio, &ck, 0))
            break;
    }

    goto exit;

error:
    if (h)
    {
        GlobalUnlock(h);
        GlobalFree(h);
    }
    h = NULL;

exit:
    return h;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\start.h ===
//--------------------------------------------------------------------------;
//
//  File: start.h
//
//  Copyright (c) 2002 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;

#ifndef AUDIOSTART_HEADER
#define AUDIOSTART_HEADER

#define REGSTR_TEMP_REBOOT TEXT("SYSTEM\\Setup\\OptionalComponents\\AudStart")

#define CREDUI_TITLE_MAX_LENGTH             128
#define CREDUI_PROMPT_MAX_LENGTH            512
#define CREDUI_REBOOT_TITLE_MAX_LENGTH      128
#define CREDUI_REBOOT_PROMPT_MAX_LENGTH     1024

extern BOOL AudioServiceStarted(void);
extern BOOL RebootNeeded(void);
extern DWORD RebootSystem(HWND hDlg, BOOL fUseThreadToken, BOOL fAskUser, BOOL fDisplayPrivilegeError);
extern HANDLE GetAdminPrivilege(UINT);
extern void ReleaseAdminPrivilege(HANDLE hToken);

#endif // AUDIOSTART_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\speakers.h ===
//--------------------------------------------------------------------------;
//
//  File: speakers.h
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved
//
//
//--------------------------------------------------------------------------;

#ifndef SPEAKERS_HEADER
#define SPEAKERS_HEADER

#define TYPE_NOSPEAKERS        0
#define TYPE_HEADPHONES        1
#define TYPE_STEREODESKTOP     2
#define TYPE_MONOLAPTOP        3
#define TYPE_STEREOLAPTOP      4
#define TYPE_STEREOMONITOR     5
#define TYPE_STEREOCPU         6
#define TYPE_MOUNTEDSTEREO     7
#define TYPE_STEREOKEYBOARD    8
#define TYPE_QUADRAPHONIC      9
#define TYPE_SURROUND          10
#define TYPE_SURROUND_5_1      11
#define TYPE_SURROUND_7_1      12
#define MAX_SPEAKER_TYPE       TYPE_SURROUND_7_1


INT_PTR CALLBACK SpeakerHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
void VerifySpeakerConfig(DWORD dwSpeakerConfig, LPDWORD pdwSpeakerType);
DWORD GetSpeakerConfigFromType(DWORD dwType);

#define SPEAKERS_DEFAULT_CONFIG      DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_WIDE)
#define SPEAKERS_DEFAULT_TYPE        TYPE_STEREODESKTOP


#endif // SPEAKERS_HEADER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\speakers.cpp ===
//--------------------------------------------------------------------------;
//
//  File: speakers.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All rights reserved 
//
//--------------------------------------------------------------------------;

#include "mmcpl.h"
#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "utils.h"
#include "medhelp.h"

#include <dsound.h>
#include "advaudio.h"
#include "speakers.h" 
#include "dslevel.h"

/////////////
// defines
/////////////

#define NUMCONFIG   (MAX_SPEAKER_TYPE + 1)


//////////                                           
// Globals
//////////

DWORD gdwSpeakerTable[NUMCONFIG] =
{ 
    DSSPEAKER_DIRECTOUT,
    DSSPEAKER_HEADPHONE,
    SPEAKERS_DEFAULT_CONFIG,
    DSSPEAKER_MONO,
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_WIDE),
    DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_NARROW),
    DSSPEAKER_QUAD,
    DSSPEAKER_SURROUND,
    DSSPEAKER_5POINT1,
    DSSPEAKER_7POINT1
};

DWORD gdwImageID[NUMCONFIG] =     
{ 
    IDB_NOSPEAKERS,
    IDB_HEADPHONES,
    IDB_STEREODESKTOP,
    IDB_MONOLAPTOP,
    IDB_STEREOLAPTOP,
    IDB_STEREOMONITOR, 
    IDB_STEREOCPU,
    IDB_MOUNTEDSTEREO,
    IDB_STEREOKEYBOARD,
    IDB_QUADRAPHONIC,
    IDB_SURROUND,
    IDB_SURROUND_5_1,
    IDB_SURROUND_7_1
};

HBITMAP ghBitmaps[NUMCONFIG];



//////////////
// Help ID's
//////////////


#pragma data_seg(".text")
const static DWORD aAdvSpeakerHelp[] = 
{
    IDC_SPEAKERCONFIG,      IDH_SPEAKERS_PICKER,
    IDC_IMAGEFRAME,         IDH_SPEAKERS_IMAGE,
    IDC_ICON_4,             IDH_COMM_GROUPBOX,
    IDC_TEXT_22,            IDH_COMM_GROUPBOX,
    IDC_TEXT_23,            IDH_SPEAKERS_PICKER,
    0, 0
};
#pragma data_seg()



//////////////
// Functions
//////////////

// 
// Verifies that the speakers type and config match, if not, change type to match config using default type
//
void VerifySpeakerConfig(DWORD dwSpeakerConfig, LPDWORD pdwSpeakerType)
{
    if (pdwSpeakerType)
    {
        DWORD dwType = *pdwSpeakerType;

        if (gdwSpeakerTable[dwType] != dwSpeakerConfig)     // the type doesn't match the config, pick a default type
        {
            switch (dwSpeakerConfig)
            {
                case DSSPEAKER_DIRECTOUT:
                    *pdwSpeakerType = TYPE_NOSPEAKERS;
                break;

                case DSSPEAKER_HEADPHONE:
                    *pdwSpeakerType = TYPE_HEADPHONES;
                break;

                case DSSPEAKER_MONO:
                    *pdwSpeakerType = TYPE_MONOLAPTOP;
                break;

                case DSSPEAKER_STEREO:
                    *pdwSpeakerType = TYPE_STEREODESKTOP;
                break;

                case DSSPEAKER_QUAD:
                    *pdwSpeakerType = TYPE_QUADRAPHONIC;
                break;

                case DSSPEAKER_SURROUND:
                    *pdwSpeakerType = TYPE_SURROUND;
                break;

                case DSSPEAKER_5POINT1:
                    *pdwSpeakerType = TYPE_SURROUND_5_1;
                break;

                case DSSPEAKER_7POINT1:
                    *pdwSpeakerType = TYPE_SURROUND_7_1;
                break;

                default:
                {
                    if (DSSPEAKER_CONFIG(dwSpeakerConfig) == DSSPEAKER_STEREO)
                    {
                        DWORD dwAngle = DSSPEAKER_GEOMETRY(dwSpeakerConfig);
                        DWORD dwMiddle = DSSPEAKER_GEOMETRY_NARROW + 
                                        ((DSSPEAKER_GEOMETRY_WIDE - DSSPEAKER_GEOMETRY_NARROW) >> 1);
                        if (dwAngle <= dwMiddle)
                        {
                            *pdwSpeakerType = TYPE_STEREOCPU;        
                        }
                        else
                        {
                            *pdwSpeakerType = TYPE_STEREODESKTOP;        
                        }
                    }
                }

                break;
            }
        }
    }
}

//
// Given a speaker type, returns the DirectSound config for it
//

DWORD GetSpeakerConfigFromType(DWORD dwType)
{
    DWORD dwConfig = SPEAKERS_DEFAULT_CONFIG;

    if (dwType < (DWORD)NUMCONFIG)
    {
        dwConfig = gdwSpeakerTable[dwType];     
    }

    return(dwConfig);
}



//
// Called when first started up, it determines the current state of the device's speaker state
// and fills out the controls as appropriate
//

BOOL InitSpeakerDlg(HWND hwnd, BOOL fImagesOnly)
{
    TCHAR    str[255];
    int     item;
    DWORD   dwIndex;
    HWND    hwndCombo;

    if (!fImagesOnly)
    {
        SendDlgItemMessage(hwnd, IDC_SPEAKERCONFIG, CB_RESETCONTENT,0,0);
    }

    for (item = 0; item < NUMCONFIG; item++)
    {
        if (!fImagesOnly)
        {
            LoadString( ghInst, IDS_SPEAKER1 + item, str, sizeof( str )/sizeof(TCHAR) );
            SendDlgItemMessage(hwnd, IDC_SPEAKERCONFIG, CB_INSERTSTRING,  (WPARAM) -1, (LPARAM) str); 
        }
         
        if (ghBitmaps[item] != NULL)
        {
            DeleteObject( (HGDIOBJ) ghBitmaps[item]);
            ghBitmaps[item] = NULL; 
        }
        
        ghBitmaps[item] = (HBITMAP) LoadImage(ghInst,MAKEINTATOM(gdwImageID[item]), IMAGE_BITMAP, 
                                    0, 0, LR_LOADMAP3DCOLORS);
    }
    
    dwIndex = gAudData.current.dwSpeakerType;
                    
    SendDlgItemMessage(hwnd, IDC_SPEAKERCONFIG, CB_SETCURSEL,  (WPARAM) dwIndex, 0);                
    SendDlgItemMessage(hwnd, IDC_IMAGEFRAME, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) ghBitmaps[dwIndex]);
    
    // Enable/disable the combo box appropriately
    hwndCombo = GetDlgItem( hwnd, IDC_SPEAKERCONFIG );
    if (hwndCombo)
    {
        // Check if we can set the speaker configuration
        if (FAILED(CheckDSSpeakerConfigPriv(gAudData.devGuid, gAudData.fRecord, NULL)))
        {
            // No - disable the combo box
            EnableWindow( hwndCombo, FALSE );
        }
        else
        {
            // Yes - enable the combo box
            EnableWindow( hwndCombo, TRUE );
        }
    }

    return(TRUE);
}

//
// called to delete all loaded bitmaps
//

void DumpBitmaps(void)
{
    int item;

    for (item = 0; item < NUMCONFIG; item++)
    {         
        if (ghBitmaps[item] != NULL)
        {
            DeleteObject( (HGDIOBJ) ghBitmaps[item]);
            ghBitmaps[item] = NULL; 
        }
    }
}


//
// called by dialog handler when speaker type is changed
//

void ChangeSpeakers(HWND hwnd)
{
    DWORD dwIndex;

    dwIndex = (DWORD)SendDlgItemMessage(hwnd, IDC_SPEAKERCONFIG, CB_GETCURSEL,0,0);

	if (dwIndex != CB_ERR)
    {
        gAudData.current.dwSpeakerType = dwIndex;
        gAudData.current.dwSpeakerConfig = GetSpeakerConfigFromType(gAudData.current.dwSpeakerType);
    
        SendDlgItemMessage(hwnd, IDC_IMAGEFRAME, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) ghBitmaps[dwIndex]);

        ToggleApplyButton(hwnd);
    }
}


//
// Dialog event handler
//

INT_PTR CALLBACK SpeakerHandler(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fReturnVal = TRUE;
        
    switch (msg) 
    { 
        default:
            fReturnVal = FALSE;
        break;
        
        case WM_INITDIALOG:
        {
            fReturnVal = InitSpeakerDlg(hDlg, FALSE);
        }        
        break;

        case WM_DESTROY:
        {
            DumpBitmaps();
        }
        break;

        case WM_CONTEXTMENU:
        {      
            WinHelp((HWND)wParam, gszHelpFile, HELP_CONTEXTMENU, (UINT_PTR)(LPTSTR)aAdvSpeakerHelp);
            fReturnVal = TRUE;
        }
        break;
           
        case WM_HELP:
        {        
            WinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, gszHelpFile, HELP_WM_HELP, (UINT_PTR)(LPTSTR)aAdvSpeakerHelp);
            fReturnVal = TRUE;
        }
        break;

        case WM_SYSCOLORCHANGE:
        {
            fReturnVal = InitSpeakerDlg(hDlg, TRUE);
        }
        break;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDC_SPEAKERCONFIG:
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        ChangeSpeakers(hDlg);
                    }
                }
                break;
                
                default:
                    fReturnVal = FALSE;
                break;
            }
            break;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code)
            {
                case PSN_APPLY:
                {
                    ApplyCurrentSettings(&gAudData);
                }
            }
        }
    }

    return fReturnVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\sound.h ===
/*	-	-	-	-	-	-	-	-	*/
//
//	sound.h
//
//	Copyright (C) 1994 Microsoft Corporation.  All Rights Reserved.
//
/*	-	-	-	-	-	-	-	-	*/

DECLARE_HANDLE(HSOUND);
typedef HSOUND * PHSOUND;

/*	-	-	-	-	-	-	-	-	*/
void FAR PASCAL soundOnDone(
	HSOUND	hs);
MMRESULT FAR PASCAL soundOpen(
	LPCTSTR	pszSound,
	HWND	hwndNotify,
	PHSOUND	phs);
MMRESULT FAR PASCAL soundClose(
	HSOUND	hs);
MMRESULT FAR PASCAL soundPlay(
	HSOUND	hs);
MMRESULT FAR PASCAL soundStop(
	HSOUND	hs);

/*	-	-	-	-	-	-	-	-	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\subobj.h ===
//****************************************************************************
//
//  Module:     mmsys.cpl
//  File:       subobj.h
//  Content:    This file contains the subobject (our own object)
//              storage space and manipulation mechanisms.
//
//  History:
//  06/94	VijR      Created
//
//  Copyright (c) Microsoft Corporation 1991-1994
//
//****************************************************************************

#ifndef _SUBOBJ_H_
#define _SUBOBJ_H_

// This structure is used as the LPITEMIDLIST that
// the shell uses to identify objects in a folder.  The
// first two bytes are required to indicate the size,
// the rest of the data is opaque to the shell.
typedef struct _SUBOBJ
    {
    USHORT  cbSize;             // Size of this struct
    UINT    uFlags;             // One of SOF_ values
	short nIconIndex;
	short iSort;
	short iOffsetIconFile;
	short iOffsetDesc;
	short iOffsetClass;
	short iOffsetExtPropFile;
	short iOffsetExtPropFunc;
	short iOffsetExtCLSID;
	short iOffsetPlayCmdLn;
	short iOffsetOpenCmdLn;
	short iOffsetNewCmdLn;
	HICON	hClassIcon;
    struct _SUBOBJ FAR * psoNext;
    TCHAR    szName[1];          // Display name
    } SUBOBJ, FAR * PSUBOBJ;


//  LPCTSTR Subobj_GetName(PSUBOBJ pso);
//
//   Gets the subobject name.
//
#define Subobj_GetName(pso)     ((pso)->szName)

//  UINT Subobj_GetFlags(PSUBOBJ pso);
//
//   Gets the subobject flags.
//
#define Subobj_GetFlags(pso)     ((pso)->uFlags)


//  int Subobj_GetIconIndex(PSUBOBJ pso);
//
//   Gets the subobject icon.
//
#define Subobj_GetIconIndex(pso)     ((pso)->nIconIndex)

//  LPTSTR Subobj_GetIconFile(PSUBOBJ pso);
//
//   Gets the subobject icon Index in file.
//
#define Subobj_GetIconFile(pso)     ((LPTSTR)((pso)->szName + (pso)->iOffsetIconFile))

//  LPTSTR Subobj_GetDesc(PSUBOBJ pso);
//
//   Gets the subobject IconFile name.
//
#define Subobj_GetDesc(pso)     ((LPTSTR)((pso)->szName + (pso)->iOffsetDesc))

//  LPTSTR Subobj_GetClass(PSUBOBJ pso);
//
//   Gets the subobject Clas Name
//
#define Subobj_GetClass(pso)     ((LPTSTR)((pso)->szName + (pso)->iOffsetClass))

//  int Subobj_GetSortIndex(PSUBOBJ pso);
//
//   Gets the subobject Sort order.
//
#define Subobj_GetSortIndex(pso)     ((pso)->iSort)

//  HICON Subobj_GetClassIcon(PSUBOBJ pso);
//
//   Gets the subobject Object Icon.
//
#define Subobj_GetClassIcon(pso)     ((pso)->hClassIcon)

//  LPTSTR Subobj_GetExtPropFile(PSUBOBJ pso);
//
//   Gets the subobject External Class File.
//
#define Subobj_GetExtPropFile(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetExtPropFile))

//  LPTSTR Subobj_GetExtPropFunc(PSUBOBJ pso);
//
//   Gets the subobject External Class Func.
//
#define Subobj_GetExtPropFunc(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetExtPropFunc))

//  LPTSTR Subobj_GetExtCLSID(PSUBOBJ pso);
//
//   Gets the subobject external CLSID.
//
#define Subobj_GetExtCLSID(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetExtCLSID))

//  LPTSTR Subobj_GetPlayCmdLn(PSUBOBJ pso);
//
//   Gets the subobject command line
//
#define Subobj_GetPlayCmdLn(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetPlayCmdLn))

//  LPTSTR Subobj_GetOpenCmdLn(PSUBOBJ pso);
//
//   Gets the subobject command line
//
#define Subobj_GetOpenCmdLn(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetOpenCmdLn))

//  LPTSTR Subobj_GetNewCmdLn(PSUBOBJ pso);
//
//   Gets the subobject command line.
//
#define Subobj_GetNewCmdLn(pso)    ((LPTSTR)((pso)->szName + (pso)->iOffsetNewCmdLn))

// Some other Subobj functions...
//
BOOL    PUBLIC Subobj_New(PSUBOBJ FAR * ppso, LPCTSTR pszClass, LPCTSTR pszName, 	LPCTSTR pszDesc, LPCTSTR pszIconFile, 	LPCTSTR pszExtPropFile, 
							LPCTSTR pszExtPropFunc,LPCTSTR pszExtCLSID, LPCTSTR pszPlayCmdLn, LPCTSTR pszOpenCmdLn,
							LPCTSTR pszNewCmdLn,short nIconIndex, UINT uFlags, short iSort);
void    PUBLIC Subobj_Destroy(PSUBOBJ pso);
BOOL    PUBLIC Subobj_Dup(PSUBOBJ FAR * ppso, PSUBOBJ psoArgs);

#ifdef DEBUG

void PUBLIC Subobj_Dump(PSUBOBJ pso);

#endif

typedef struct _SUBOBJSPACE
    {
    PSUBOBJ     psoFirst;
    PSUBOBJ     psoLast;
    int         cItems;
	int			cRef;

    } SUBOBJSPACE, FAR * PSUBOBJSPACE;

//  PSUBOBJ Sos_FirstItem(void);
//
//   Returns the first object in the subobject space.  NULL if empty.
//
#define Sos_FirstItem(psos)         (psos->psoFirst)

//  PSUBOBJ Sos_NextItem(PSUBOBJ pso);
//
//   Returns the next object in the subobject space.  NULL if no more 
//   objects.
//
#define Sos_NextItem(pso)       (pso ? pso->psoNext : NULL)


// Other subobject space functions
//
PSUBOBJ PUBLIC Sos_FindItem(PSUBOBJSPACE psos, LPCTSTR pszName);
BOOL    PUBLIC Sos_AddItem(PSUBOBJSPACE psos, PSUBOBJ pso);
USHORT  PUBLIC Sos_GetMaxSize(PSUBOBJSPACE psos);
PSUBOBJ PUBLIC Sos_RemoveItem(PSUBOBJSPACE psos, LPCTSTR pszName);
void    PUBLIC Sos_Destroy(PSUBOBJSPACE psos);
int     PUBLIC Sos_FillFromRegistry(PSUBOBJSPACE psos, LPITEMIDLIST pidl);
BOOL    PUBLIC Sos_Init(PSUBOBJSPACE psos, LPITEMIDLIST pidl, BOOL fAdvancedFolder);
HRESULT PUBLIC Sos_AddRef(PSUBOBJSPACE psos, LPITEMIDLIST pidl, BOOL fAdvancedFolder);
void    PUBLIC Sos_Release(PSUBOBJSPACE psos);


#define SOF_ISFOLDER		0x0001
#define SOF_ISDROPTARGET	0x0002
#define SOF_CANDELETE		0x0004
#define SOF_HASEXTPROPSHEET	0x0008
#define SOF_ISEXTOBJECT		0x0010
#define SOF_DOESPLAY		0x0020
#define SOF_DOESOPEN		0x0040
#define SOF_DOESNEW			0x0080


#define SOUNDEVENTS TEXT("Sound Events")
#define WAVE		TEXT("Wave")
#define MIDI		TEXT("MIDI")
#define MIXER		TEXT("Mixer")
#define AUX			TEXT("Aux")
#define ACM			TEXT("ACM")
#define ICM			TEXT("ICM")
#define MCI			TEXT("MCI")
#define AUDIO		TEXT("Audio")
#define CDAUDIO		TEXT("CDAudio")
#define VIDEO		TEXT("Video")
#define VOICE		TEXT("Voice")
#define ADVANCEDFOLDER TEXT("Advanced Folder")

#ifdef DEBUG

void PUBLIC Sos_DumpList(void);

#endif

//extern SUBOBJSPACE g_sos;

//
// Other prototypes...
//

HRESULT PUBLIC mmseObj_CreateInstance(LPSHELLFOLDER psf, UINT cidl, BOOL fInAdvancedFolder, LPCITEMIDLIST FAR * ppidl, LPCITEMIDLIST pidlRoot, LPSHELLVIEW csv, REFIID riid, LPVOID FAR * ppvOut);
HRESULT NEAR PASCAL mmseView_Command(LPSHELLVIEW psv, HWND hwnd,  UINT uID);


LPTSTR   PUBLIC lmemset(LPTSTR dst, char val, UINT count);
LPTSTR   PUBLIC lmemmove(LPTSTR dst, LPTSTR src, int count);
int     PUBLIC AnsiToInt(LPCTSTR pszString);

int     PUBLIC DoModal (HWND hwndParent, DLGPROC lpfnDlgProc, UINT uID, LPARAM lParam);

HMENU   PUBLIC LoadPopupMenu(UINT id, UINT uSubOffset);
UINT    PUBLIC MergePopupMenu(HMENU FAR *phMenu, UINT idResource, UINT uSubOffset, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast);
HMENU   PUBLIC GetMenuFromID(HMENU hmMain, UINT uID);

#endif // _SUBOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\sndsel.c ===
/*
 ***************************************************************
 *  sndsel.c
 *
 *  This file contains the dialogproc and the dialog initialization code
 *
 *  Copyright 1993, Microsoft Corporation
 *
 *  History:
 *
 *    07/94 - VijR (Created)
 *
 ***************************************************************
 */

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include <cpl.h>
#include <shellapi.h>
#include <ole2.h>
#include <commdlg.h>
#define NOSTATUSBAR
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <dbt.h>

#include <mmddkp.h>

#include <ks.h>
#include <ksmedia.h>
#include "mmcpl.h"
#include "medhelp.h"
#include "sound.h"
#include "utils.h"
#include "rcids.h"

/*
 ***************************************************************
 * Defines
 ***************************************************************
 */
#define DF_PM_SETBITMAP    (WM_USER+1)

/*
 ***************************************************************
 * Globals
 ***************************************************************
 */

SZCODE      gszWindowsHlp[]    = TEXT("windows.hlp");
SZCODE      gszNull[2]         = TEXT("\0");
SZCODE      gszNullScheme[]    = TEXT(".none");

TCHAR        gszCurDir[MAXSTR]     = TEXT("\0");
TCHAR        gszNone[32];
TCHAR        gszRemoveScheme[MAXSTR];
TCHAR        gszChangeScheme[MAXSTR];
TCHAR        gszMediaDir[MAXSTR];
TCHAR        gszDefaultApp[32];

int                             giScheme;
BOOL                            gfChanged;                    //set to TRUE if sound info change
BOOL                            gfNewScheme;
BOOL                            gfDeletingTree;
HWND                            ghWnd;
OPENFILENAME                    ofn;

/*
 ***************************************************************
 * Globals used in painting disp chunk display.
 ***************************************************************
*/
BOOL        gfWaveExists = FALSE;   // indicates wave device in system.

HTREEITEM ghOldItem = NULL;

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */

static TCHAR        aszFileName[MAXSTR] = TEXT("\0");
static TCHAR        aszPath[MAXSTR]     = TEXT("\0");

static TCHAR        aszBrowse[MAXSTR];
static TCHAR        aszBrowseStr[64];
static TCHAR        aszNullSchemeLabel[MAXSTR];

static TCHAR        aszFilter[MAXSTR];
static TCHAR        aszNullChar[2];

static SZCODE   aszLnk[] = TEXT(".lnk");
static SZCODE   aszWavFilter[] = TEXT("*.wav");
static SZCODE   aszDefaultScheme[]    = TEXT("Appevents\\schemes");
static SZCODE   aszNames[]            = TEXT("Appevents\\schemes\\Names");
static SZCODE   aszDefault[]        = TEXT(".default");
static SZCODE   aszCurrent[]        = TEXT(".current");
static INTCODE  aKeyWordIds[] =
{
    CB_SCHEMES,         IDH_EVENT_SCHEME,
    IDC_TEXT_14,        IDH_EVENT_SCHEME,
    ID_SAVE_SCHEME,     IDH_EVENT_SAVEAS_BUTTON,
    ID_REMOVE_SCHEME,   IDH_EVENT_DELETE_BUTTON,
    IDC_EVENT_TREE,     IDH_EVENT_EVENT,
    IDC_SOUNDGRP,       IDH_COMM_GROUPBOX,
    ID_PLAY,            IDH_EVENT_PLAY,
    IDC_STATIC_EVENT,   IDH_COMM_GROUPBOX,
    IDC_STATIC_NAME,    IDH_EVENT_FILE,
    IDC_SOUND_FILES,    IDH_EVENT_FILE,
    ID_BROWSE,          IDH_EVENT_BROWSE,
    0,0
};

BOOL        gfEditBoxChanged;
BOOL        gfSubClassedEditWindow;
BOOL        gfSoundPlaying;

HBITMAP     hBitmapPlay;
HBITMAP     hBitmapStop;

HIMAGELIST  hSndImagelist;

/*
 ***************************************************************
 * extern
 ***************************************************************
 */

extern      HSOUND ghse;
extern      BOOL    gfNukeExt;
/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */
BOOL PASCAL DoCommand           (HWND, int, HWND, UINT);
BOOL PASCAL InitDialog          (HWND);
BOOL PASCAL InitStringTable     (void);
BOOL PASCAL InitFileOpen        (HWND, LPOPENFILENAME);
BOOL PASCAL SoundCleanup        (HWND);
LPTSTR PASCAL NiceName           (LPTSTR, BOOL);
BOOL ResolveLink                (LPTSTR, LPTSTR, LONG);
void CreateTooltip (HWND hwnd, LPTSTR lpszTip);

// stuff in sndfile.c
//
BOOL PASCAL ShowSoundMapping    (HWND, PEVENT);
BOOL PASCAL ChangeSoundMapping  (HWND, LPTSTR, PEVENT);
BOOL PASCAL PlaySoundFile       (HWND, LPTSTR);
BOOL PASCAL QualifyFileName     (LPTSTR, LPTSTR, int, BOOL);

// Stuff in scheme.c
//
INT_PTR CALLBACK  SaveSchemeDlg(HWND, UINT, WPARAM, LPARAM);
BOOL PASCAL RegNewScheme        (HWND, LPTSTR, LPTSTR, BOOL);
BOOL PASCAL RegSetDefault       (LPTSTR);
BOOL PASCAL ClearModules        (HWND, HWND, BOOL);
BOOL PASCAL LoadModules         (HWND, LPTSTR);
BOOL PASCAL RemoveScheme        (HWND);
BOOL PASCAL AddScheme           (HWND, LPTSTR, LPTSTR, BOOL, int);
BOOL PASCAL RegDeleteScheme(HWND hWndC, int iIndex);

/*
 ***************************************************************
 ***************************************************************
 */


void AddExt(LPTSTR sz, LPCTSTR x)
{
    UINT  cb;

    for (cb = lstrlen(sz); cb; --cb)
    {
        if (TEXT('.') == sz[cb])
            return;

        if (TEXT('\\') == sz[cb])
            break;
    }
    lstrcat (sz, x);
}


static void AddFilesToLB(HWND hwndList, LPTSTR pszDir, LPCTSTR szSpec)
{
    WIN32_FIND_DATA fd;
    HANDLE h;
    TCHAR szBuf[MAXSTR];

    ComboBox_ResetContent(hwndList);

    if ((lstrlen(pszDir)+ lstrlen(cszSlash)+ lstrlen(szSpec)) < ARRAYSIZE(szBuf))
    {
        lstrcpyn(szBuf, pszDir, ARRAYSIZE(szBuf));
        lstrcat(szBuf, cszSlash);           
        lstrcat(szBuf, szSpec);
        
        h = FindFirstFile(szBuf, &fd);

        if (h != INVALID_HANDLE_VALUE)
        {
            // If we have only a short name, make it pretty.
            do 
            {
                    NiceName(fd.cFileName, TRUE);
                    SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)fd.cFileName);
            }
            while (FindNextFile(h, &fd));

            FindClose(h);
        }
    }
    ComboBox_InsertString(hwndList, 0, (LPARAM)(LPTSTR)gszNone);
}

static void SetCurDir(HWND hDlg, LPTSTR lpszPath, BOOL fParse, BOOL fChangeDir)
{
    TCHAR szTmp[MAX_PATH];
    TCHAR szOldDir[MAXSTR];
    LPTSTR lpszTmp;

    lstrcpy (szOldDir, gszCurDir);
    if (!fParse)
    {
        lstrcpy(gszCurDir, lpszPath);
        goto AddFiles;
    }
    lstrcpy(szTmp, lpszPath);
    for (lpszTmp = (LPTSTR)(szTmp + lstrlen(szTmp)); lpszTmp > szTmp; lpszTmp = CharPrev(szTmp, lpszTmp))
    {
        if (*lpszTmp == TEXT('\\'))
        {
            *lpszTmp = TEXT('\0');
            lstrcpy(gszCurDir, szTmp);
            break;
        }
    }
    if (lpszTmp <= szTmp)
        lstrcpy(gszCurDir, gszMediaDir);
AddFiles:
    if (fChangeDir)
    {
        if (!SetCurrentDirectory(gszCurDir))
        {
            if (lstrcmp (gszMediaDir, lpszPath))
                SetCurrentDirectory (gszMediaDir);
            else
            {
                if (GetWindowsDirectory (gszCurDir, sizeof(gszCurDir)/sizeof(TCHAR)))
					SetCurrentDirectory (gszCurDir);
            }
        }
    }
    if (lstrcmpi (szOldDir, gszCurDir))
    {
        AddFilesToLB(GetDlgItem(hDlg, IDC_SOUND_FILES),gszCurDir, aszWavFilter);
    }
}

static BOOL TranslateDir(HWND hDlg, LPTSTR pszPath)
{
    TCHAR szCurDir[MAX_PATH];
    int nFileOffset = lstrlen(pszPath);

    lstrcpy(szCurDir, pszPath);
    if (szCurDir[nFileOffset - 1] == TEXT('\\'))
        szCurDir[--nFileOffset] = 0;
    if (SetCurrentDirectory(szCurDir))
    {
        if (GetCurrentDirectory(sizeof(szCurDir)/sizeof(TCHAR), szCurDir))
        {
            SetCurDir(hDlg, szCurDir, FALSE, FALSE);
            return TRUE;
        }
    }
    return FALSE;
}





///HACK ALERT!!!! HACK ALERT !!! HACK ALERT !!!!
// BEGIN (HACKING)

HHOOK gfnKBHookScheme = NULL;
HWND ghwndDlg = NULL;
WNDPROC gfnEditWndProc = NULL;

#define WM_NEWEVENTFILE (WM_USER + 1000)
#define WM_RESTOREEVENTFILE (WM_USER + 1001)

LRESULT CALLBACK SchemeKBHookProc(int code, WPARAM wParam, LPARAM lParam)
{
    if (wParam == VK_RETURN || wParam == VK_ESCAPE)
    {
        HWND hwndFocus = GetFocus();
        if (IsWindow(hwndFocus))
        {
            if (lParam & 0x80000000) //Key Up
            {
                DPF("*****WM_KEYUP for VK_RETURN/ESC\r\n");
                if (wParam == VK_RETURN)
                {
                    if (SendMessage(ghwndDlg, WM_NEWEVENTFILE, 0, 0L))
                    {
                        SetFocus(hwndFocus);
                        gfEditBoxChanged = TRUE;
                        return 1;
                    }
                }
                else
                    SendMessage(ghwndDlg, WM_RESTOREEVENTFILE, 0, 0L);
            }
        }
        if (gfnKBHookScheme && (lParam & 0x80000000))
        {
            UnhookWindowsHookEx(gfnKBHookScheme);
            gfnKBHookScheme = NULL;
        }
        return 1;       //remove message
    }
    return CallNextHookEx(gfnKBHookScheme, code, wParam, lParam);
}

STATIC void SetSchemesKBHook(HWND hwnd)
{
    if (gfnKBHookScheme)
        return;
    gfnKBHookScheme = SetWindowsHookEx(WH_KEYBOARD, (HOOKPROC)SchemeKBHookProc, ghInstance,0);
}

LRESULT CALLBACK SubClassedEditWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch(wMsg)
    {
        case WM_SETFOCUS:
            DPF("*****WM_SETFOCUS\r\n");
            SetSchemesKBHook(hwnd);
            gfEditBoxChanged = FALSE;
            break;
        case WM_KILLFOCUS:
            if (gfnKBHookScheme)
            {
                DPF("*****WM_KILLFOCUS\r\n");
                UnhookWindowsHookEx(gfnKBHookScheme);
                gfnKBHookScheme = NULL;
                if (gfEditBoxChanged)
                    SendMessage(ghwndDlg, WM_NEWEVENTFILE, 0, 1L);
            }
            break;
    }
    return CallWindowProc((WNDPROC)gfnEditWndProc, hwnd, wMsg, wParam, lParam);
}

STATIC void SubClassEditWindow(HWND hwndEdit)
{
    gfnEditWndProc = (WNDPROC)GetWindowLongPtr(hwndEdit, GWLP_WNDPROC);
    SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)SubClassedEditWndProc);
}



// END (HACKING)

STATIC void EndSound(HSOUND * phse)
{
    if (*phse)
    {
        HSOUND hse = *phse;

        *phse = NULL;
        soundStop(hse);
        soundOnDone(hse);
        soundClose(hse);
    }
}

// Create a tooltip for the passed window
void CreateTooltip (HWND hwnd, LPTSTR lpszTip)
{

    HWND hwndTT;
    TOOLINFO ti;
    INITCOMMONCONTROLSEX iccex; 

    // Init Common Controls
    iccex.dwICC = ICC_WIN95_CLASSES;
    iccex.dwSize = sizeof (INITCOMMONCONTROLSEX);
    InitCommonControlsEx (&iccex);
	
    // Create Window
    hwndTT = CreateWindowEx (WS_EX_TOPMOST, TOOLTIPS_CLASS, NULL,
        WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP, CW_USEDEFAULT,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, hwnd,
        NULL, ghInstance, NULL);
    SetWindowPos (hwndTT, HWND_TOPMOST, 0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

    // Get Tip Area (entire window)
    GetClientRect (hwnd, &(ti.rect));
	
    // Init Tip
    ti.cbSize   = sizeof(TOOLINFO);
    ti.uFlags   = TTF_SUBCLASS;
    ti.hwnd     = hwnd;
    ti.hinst    = ghInstance;
    ti.uId      = 0;
    ti.lpszText = lpszTip;
    
    // Add Tip
    SendMessage (hwndTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
    
} 

/*
 ***************************************************************
 *  SoundDlg
 *
 *  Description:
 *        DialogProc for sound control panel applet.
 *
 *  Parameters:
 *   HWND        hDlg            window handle of dialog window
 *   UINT        uiMessage       message number
 *   WPARAM        wParam          message-dependent
 *   LPARAM        lParam          message-dependent
 *
 *  Returns:    BOOL
 *      TRUE if message has been processed, else FALSE
 *
 ***************************************************************
 */
BOOL CALLBACK  SoundDlg(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    NMHDR FAR       *lpnm;
    TCHAR           szBuf[MAXSTR];
    static BOOL     fClosingDlg = FALSE;
    PEVENT          pEvent;

    switch (uMsg)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                    break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;

                case TVN_SELCHANGED:
                {
                    TV_ITEM tvi;
                    LPNM_TREEVIEW lpnmtv = (LPNM_TREEVIEW)lParam;

                    if (fClosingDlg || gfDeletingTree)
                        break;
                    if (gfnKBHookScheme)
                    {
                        UnhookWindowsHookEx(gfnKBHookScheme);
                        gfnKBHookScheme = NULL;
                        if (gfEditBoxChanged)
                        {
                            ghOldItem = lpnmtv->itemOld.hItem;
                            SendMessage(ghwndDlg, WM_NEWEVENTFILE, 0, 1L);
                            ghOldItem = NULL;
                        }
                    }

                    tvi = lpnmtv->itemNew;
                    if (tvi.lParam)
                    {
                        if (*((short NEAR *)tvi.lParam) == 2)
                        {
                            pEvent =  (PEVENT)tvi.lParam;
                            ShowSoundMapping(hDlg, pEvent);
                            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)tvi.lParam);
                        }
                        else
                        {
                            ShowSoundMapping(hDlg, NULL);
                            SetWindowLongPtr(hDlg, DWLP_USER, 0L);
                        }
                    }
                    else
                    {
                        ShowSoundMapping(hDlg, NULL);
                        SetWindowLongPtr(hDlg, DWLP_USER, 0L);
                    }
                    break;
                }

                case TVN_ITEMEXPANDING:
                {
                    LPNM_TREEVIEW lpnmtv = (LPNM_TREEVIEW)lParam;

                    if (lpnmtv->action == TVE_COLLAPSE)
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)TRUE);
                        return TRUE;
                    }
                    break;
                }


            }
            break;

        case WM_INITDIALOG:
        {
            InitStringTable();

            giScheme = 0;
            ghWnd = hDlg;
            gfChanged = FALSE;
            gfNewScheme = FALSE;
            
            hBitmapStop = LoadBitmap(ghInstance, MAKEINTRESOURCE(IDB_STOP));
            if (!hBitmapStop)
                DPF("loadbitmap failed\n");
            hBitmapPlay = LoadBitmap(ghInstance, MAKEINTRESOURCE(IDB_PLAY));
            if (!hBitmapPlay)
                DPF("loadbitmap failed\n");

            SendMessage(GetDlgItem(hDlg, ID_PLAY), BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapPlay);
            ShowSoundMapping(hDlg, NULL);
            gfSoundPlaying = FALSE;
            // Add tool tip
            LoadString (ghInstance, IDS_TIP_PLAY, szBuf, sizeof(szBuf)/sizeof(TCHAR));
            CreateTooltip (GetDlgItem (hDlg, ID_PLAY), szBuf);

            /* Determine if there is a wave device
             */
            FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
            InitFileOpen(hDlg, &ofn);
            ghwndDlg = hDlg;
            DragAcceptFiles(hDlg, TRUE);
            gfSubClassedEditWindow = FALSE;
            fClosingDlg = FALSE;
            gfDeletingTree = FALSE;

       }
        break;

        case WM_DESTROY:
        {
            DWORD i = 0;
            LPTSTR pszKey = NULL;
            fClosingDlg = TRUE;
            if (gfnKBHookScheme)
            {
                UnhookWindowsHookEx(gfnKBHookScheme);
                gfnKBHookScheme = NULL;
            }
            SoundCleanup(hDlg);
            
            //delete item data in tree
            ClearModules(hDlg,GetDlgItem(hDlg, IDC_EVENT_TREE),TRUE);

            //delete item data in combobox
            for (i = 0; i < ComboBox_GetCount(GetDlgItem(hDlg, CB_SCHEMES)); i++)
            {
                pszKey = (LPTSTR)ComboBox_GetItemData(GetDlgItem(hDlg, CB_SCHEMES), i);
                if (pszKey)
                {
                    //can't free a couple of these, as they point to static mem
                    if ((pszKey != aszDefault) && (pszKey != aszCurrent))
                    {
                        LocalFree(pszKey);
                    }
                }
            }

            break;
        }

        case WM_DROPFILES:
        {
            TV_HITTESTINFO ht;
            HWND hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);

            DragQueryFile((HDROP)wParam, 0, szBuf, MAXSTR - 1);

            if (IsLink(szBuf, aszLnk))
                if (!ResolveLink(szBuf, szBuf, sizeof(szBuf)))
                    goto EndDrag;

            if (lstrcmpi((LPTSTR)(szBuf+lstrlen(szBuf)-4), cszWavExt))
                goto EndDrag;

            GetCursorPos((LPPOINT)&ht.pt);
            MapWindowPoints(NULL, hwndTree,(LPPOINT)&ht.pt, 2);
            TreeView_HitTest( hwndTree, &ht);
            if (ht.hItem && (ht.flags & TVHT_ONITEM))
            {
                TV_ITEM tvi;

                tvi.mask = TVIF_PARAM;
                   tvi.hItem = ht.hItem;
                   TreeView_GetItem(hwndTree, &tvi);

                if (*((short NEAR *)tvi.lParam) == 2)
                {
                    TreeView_SelectItem(hwndTree, ht.hItem);
                    pEvent =  (PEVENT)(tvi.lParam);
                    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)tvi.lParam);
                    SetFocus(hwndTree);
                }
            }
            pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));

            ChangeSoundMapping(hDlg, szBuf,pEvent);
            DragFinish((HDROP) wParam);
            break;
EndDrag:
            ErrorBox(hDlg, IDS_ISNOTSNDFILE, szBuf);
            DragFinish((HDROP) wParam);
            break;
        }
        case WM_NEWEVENTFILE:
        {
            DPF("*****WM_NEWEVENT\r\n");
            gfEditBoxChanged = FALSE;
            ComboBox_GetText(GetDlgItem(hDlg, IDC_SOUND_FILES), szBuf, sizeof(szBuf)/sizeof(TCHAR));
            pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));
            if (!lstrcmp (szBuf, gszNone))  // Selected "(None)" with keyboard?
            {
                lstrcpy(szBuf, gszNull);
                ChangeSoundMapping(hDlg, szBuf, pEvent);
                goto ReturnFocus;
            }

            if (TranslateDir(hDlg, szBuf))
            {
                ShowSoundMapping(hDlg, pEvent);
                goto ReturnFocus;
            }
            if (QualifyFileName((LPTSTR)szBuf, (LPTSTR)szBuf,    sizeof(szBuf), TRUE))
            {
                SetCurDir(hDlg, szBuf, TRUE, TRUE);
                ChangeSoundMapping(hDlg, szBuf,pEvent);
            }
            else
            {
                if (lParam)
                {
                    ErrorBox(hDlg, IDS_INVALIDFILE, NULL);
                    ShowSoundMapping(hDlg, pEvent);
                    goto ReturnFocus;
                }
                if (DisplayMessage(hDlg, IDS_NOSNDFILETITLE, IDS_INVALIDFILEQUERY, MB_YESNO) == IDYES)
                {
                    ShowSoundMapping(hDlg, pEvent);
                }
                else
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)TRUE);
                    return TRUE;
                }
            }
ReturnFocus:
            SetFocus(GetDlgItem(hDlg,IDC_EVENT_TREE));
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)(LRESULT)FALSE);
            return TRUE;
        }

        case WM_RESTOREEVENTFILE:
        {
            DPF("*****WM_RESTOREEVENT\r\n");
            pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));
            ShowSoundMapping(hDlg, pEvent);
            if (lParam == 0) //Don't keep focus
                SetFocus(GetDlgItem(hDlg,IDC_EVENT_TREE));
            break;
        }


        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU,
                                            (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aKeyWordIds);
            break;

        case MM_WOM_DONE:
        {
            HWND hwndFocus = GetFocus();
            HWND hwndPlay =  GetDlgItem(hDlg, ID_PLAY);

            gfSoundPlaying = FALSE;
            SendMessage(hwndPlay, BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapPlay);

            if (ghse)
            {
                soundOnDone(ghse);
                soundClose(ghse);
                ghse = NULL;
            }
            pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));
            ShowSoundMapping(hDlg, pEvent);

            if (hwndFocus == hwndPlay)
                if (IsWindowEnabled(hwndPlay))
                    SetFocus(hwndPlay);
                else
                    SetFocus(GetDlgItem(hDlg, IDC_EVENT_TREE));
            break;
        }

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoCommand);
            break;

        default:
            break;
    }
    return FALSE;
}


/*
 ***************************************************************
 *  doCommand
 *
 *  Description:
 *        Processes Control commands for main sound
 *      control panel dialog.
 *
 *  Parameters:
 *        HWND    hDlg  -   window handle of dialog window
 *        int        id     - Message ID
 *        HWND    hwndCtl - Handle of window control
 *        UINT    codeNotify - Notification code for window
 *
 *  Returns:    BOOL
 *      TRUE if message has been processed, else FALSE
 *
 ***************************************************************
 */
BOOL PASCAL DoCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    WAVEOUTCAPS woCaps;
    TCHAR        szBuf[MAXSTR];
    LPTSTR        pszKey;
    int         iIndex;
    HCURSOR     hcur;
    HWND        hWndC = GetDlgItem(hDlg, CB_SCHEMES);
    HWND        hWndF = GetDlgItem(hDlg, IDC_SOUND_FILES);
    HWND        hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);
    PEVENT        pEvent;
    static      BOOL fSchemeCBDroppedDown = FALSE;
    static      BOOL fFilesCBDroppedDown = FALSE;
    static      BOOL fSavingPrevScheme = FALSE;

    switch (id)
    {
        case ID_APPLY:
        {

            EndSound(&ghse);
            if (!gfChanged)
                break;
            hcur = SetCursor(LoadCursor(NULL,IDC_WAIT));
            if (gfNewScheme)
            {
                pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, NONE_ENTRY);
                if (lstrcmpi(pszKey, aszCurrent))
                {
                    ComboBox_InsertString(hWndC, NONE_ENTRY, gszNull);
                    ComboBox_SetItemData(hWndC, NONE_ENTRY, aszCurrent);
                    ComboBox_SetCurSel(hWndC, NONE_ENTRY);
                    giScheme = NONE_ENTRY;
                }
                gfNewScheme = FALSE;
            }
            iIndex = ComboBox_GetCurSel(hWndC);
            if (iIndex != CB_ERR)
            {
                pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, iIndex);
                if (pszKey)
                {
                    RegNewScheme(hDlg, (LPTSTR)aszCurrent, NULL, FALSE);
                }
                RegSetDefault(pszKey);
            }

            gfChanged = FALSE;
            SetCursor(hcur);

            return TRUE;
        }
        break;

        case IDOK:
        {
            EndSound(&ghse);
            break;
        }
        case IDCANCEL:
        {
            EndSound(&ghse);
            WinHelp(hDlg, gszWindowsHlp, HELP_QUIT, 0L);
            break;
        }
        case ID_INIT:
            hcur = SetCursor(LoadCursor(NULL,IDC_WAIT));
            gfWaveExists = waveOutGetNumDevs() > 0 &&
                            (waveOutGetDevCaps(WAVE_MAPPER,&woCaps,sizeof(woCaps)) == 0) &&
                                                    woCaps.dwFormats != 0L;
            ComboBox_ResetContent(hWndC);
            ComboBox_SetText(hWndF, gszNone);
            InitDialog(hDlg);
            giScheme = ComboBox_GetCurSel(hWndC);
            ghWnd = hDlg;
            SetCursor(hcur);
            break;

        case ID_BROWSE:
            aszFileName[0] = aszPath[0] = TEXT('\0');
            pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));

            wsprintf((LPTSTR)aszBrowse, (LPTSTR)aszBrowseStr, (LPTSTR)pEvent->pszEventLabel);
            if (GetOpenFileName(&ofn))
            {
                SetCurDir(hDlg, ofn.lpstrFile,TRUE, TRUE);
                ChangeSoundMapping(hDlg, ofn.lpstrFile, pEvent);
            }
            break;

        case ID_PLAY:
        {
            if (!gfSoundPlaying)
            {
                pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));
                if (pEvent)
                {
                    if (PlaySoundFile(hDlg, pEvent->pszPath))
					{
                        SendMessage(GetDlgItem(hDlg, ID_PLAY), BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapStop);
                        gfSoundPlaying = TRUE;
					}
                }
            }
            else
            {
                SendMessage(GetDlgItem(hDlg, ID_PLAY), BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapPlay);
                gfSoundPlaying = FALSE;

                EndSound(&ghse);
                SetFocus(GetDlgItem(hDlg, ID_PLAY));
            }
        }
        break;

        case CB_SCHEMES:
            switch (codeNotify)
            {
            case CBN_DROPDOWN:
                fSchemeCBDroppedDown = TRUE;
                break;

            case CBN_CLOSEUP:
                fSchemeCBDroppedDown = FALSE;
                break;

            case CBN_SELCHANGE:
                if (fSchemeCBDroppedDown)
                    break;
            case CBN_SELENDOK:
                if (fSavingPrevScheme)
                    break;
                iIndex = ComboBox_GetCurSel(hWndC);
                if (iIndex != giScheme)
                {
                    TCHAR szScheme[MAXSTR];
                    BOOL fDeletedCurrent = FALSE;

                    ComboBox_GetLBText(hWndC, iIndex, (LPTSTR)szScheme);
                    if (giScheme == NONE_ENTRY)
                    {
                        pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, giScheme);
                        if (!lstrcmpi(pszKey, aszCurrent))
                        {
                            int i;

                            i = DisplayMessage(hDlg, IDS_SAVESCHEME, IDS_SCHEMENOTSAVED, MB_YESNOCANCEL);
                            if (i == IDCANCEL)
                            {
                                ComboBox_SetCurSel(hWndC, giScheme);
                                break;
                            }
                            if (i == IDYES)
                            {
                                fSavingPrevScheme = TRUE;
                                if (DialogBoxParam(ghInstance, MAKEINTRESOURCE(SAVESCHEMEDLG),
                                    GetParent(hDlg), SaveSchemeDlg, (LPARAM)(LPTSTR)gszNull))
                                {
                                    fSavingPrevScheme = FALSE;
                                    ComboBox_SetCurSel(hWndC, iIndex);
                                }
                                else
                                {
                                    fSavingPrevScheme = FALSE;
                                    ComboBox_SetCurSel(hWndC, NONE_ENTRY);
                                    break;
                                }
                            }
                        }
                    }
                    pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, NONE_ENTRY);
                    if (!lstrcmpi(pszKey, aszCurrent))
                    {
                        ComboBox_DeleteString(hWndC, NONE_ENTRY);
                        fDeletedCurrent = TRUE;
                    }
                    iIndex = ComboBox_FindStringExact(hWndC, 0, szScheme);
                    pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, iIndex);

                    giScheme = iIndex;
                    EndSound(&ghse);
                    ShowSoundMapping(hDlg, NULL);
                    hcur = SetCursor(LoadCursor(NULL,IDC_WAIT));
                    if (LoadModules(hDlg, pszKey))
                    {
                        EnableWindow(GetDlgItem(hDlg, ID_SAVE_SCHEME), TRUE);
                    }
                    SetCursor(hcur);
                    if (!lstrcmpi((LPTSTR)pszKey, aszDefault) || !lstrcmpi((LPTSTR)pszKey, gszNullScheme))
                        EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME),
                                                                    FALSE);
                    else
                        EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME),TRUE);
                    gfChanged = TRUE;
                    gfNewScheme = FALSE;
                    if (fDeletedCurrent)
                        ComboBox_SetCurSel(hWndC, giScheme);
                    PropSheet_Changed(GetParent(hDlg),hDlg);
                }
                break;
            }
            break;

        case IDC_SOUND_FILES:
            switch (codeNotify)
            {
            case  CBN_SETFOCUS:
            {
                if (!gfSubClassedEditWindow)
                {
                    HWND hwndEdit = GetFocus();

                    SubClassEditWindow(hwndEdit);
                    gfSubClassedEditWindow = TRUE;
                    SetFocus(GetDlgItem(hDlg, IDC_EVENT_TREE)); //This setfocus hack is needed
                    SetFocus(hwndEdit);                         //to activate the hook.
                }
            }
            break;

            case CBN_EDITCHANGE:
                DPF("CBN_EDITCHANGE \r\n");
                if (!gfEditBoxChanged)
                    gfEditBoxChanged = TRUE;
                break;

            case CBN_DROPDOWN:
                DPF("CBN_DD\r\n");
                fFilesCBDroppedDown = TRUE;
                break;

            case CBN_CLOSEUP:
                DPF("CBN_CLOSEUP\r\n");
                fFilesCBDroppedDown = FALSE;
                break;

            case CBN_SELCHANGE:
                DPF("CBN_SELCHANGE\r\n");
                if (fFilesCBDroppedDown)
                    break;
            case CBN_SELENDOK:
            {
                HWND hwndS = GetDlgItem(hDlg, IDC_SOUND_FILES);
                DPF("CBN_SELENDOK\r\n");
                iIndex = ComboBox_GetCurSel(hwndS);
                if (iIndex >= 0)
                {
                    TCHAR szFile[MAX_PATH];

                    if (gfEditBoxChanged)
                        gfEditBoxChanged = FALSE;
                    lstrcpy(szFile, gszCurDir);
                    lstrcat(szFile, cszSlash);
                    ComboBox_GetLBText(hwndS, iIndex, (LPTSTR)(szFile + lstrlen(szFile)));
                    if (iIndex)
                    {
                        if (gfNukeExt)
                            AddExt(szFile, cszWavExt);
                    }
                    else
                    {
                        TCHAR szTmp[64];

                        ComboBox_GetText(hwndS, szTmp, sizeof(szTmp)/sizeof(TCHAR));
                        iIndex = ComboBox_FindStringExact(hwndS, 0, szTmp);
                        if (iIndex == CB_ERR)
                        {
                            if (DisplayMessage(hDlg, IDS_SOUND, IDS_NONECHOSEN, MB_YESNO) == IDNO)
                            {
                                PostMessage(ghwndDlg, WM_RESTOREEVENTFILE, 0, 1L);
                                break;
                            }
                        }
                        lstrcpy(szFile, gszNull);
                    }
                    pEvent = (PEVENT)(GetWindowLongPtr(hDlg, DWLP_USER));
                    ChangeSoundMapping(hDlg, szFile, pEvent);
                    SetFocus(GetDlgItem(hDlg, ID_PLAY));
                }
                break;
            }

        }
        break;

        case ID_SAVE_SCHEME:
            // Retrieve current scheme and pass it to the savescheme dialog.
            iIndex = ComboBox_GetCurSel(hWndC);
            if (iIndex != CB_ERR)
            {
                ComboBox_GetLBText(hWndC, iIndex, szBuf);
                if (DialogBoxParam(ghInstance, MAKEINTRESOURCE(SAVESCHEMEDLG),
                    GetParent(hDlg), SaveSchemeDlg, (LPARAM)(LPTSTR)szBuf))
                {
                    pszKey = (LPTSTR)ComboBox_GetItemData(hWndC, NONE_ENTRY);
                    if (!lstrcmpi(pszKey, aszCurrent))
                    {
                        ComboBox_DeleteString(hWndC, NONE_ENTRY);
                    }
                }
            }
            break;

        case ID_REMOVE_SCHEME:
            if (RemoveScheme(hDlg))
            {
                iIndex = ComboBox_FindStringExact(hWndC, 0, aszNullSchemeLabel);
                ComboBox_SetCurSel(hWndC, iIndex);
                giScheme = -1;
                FORWARD_WM_COMMAND(hDlg, CB_SCHEMES, hWndC, CBN_SELENDOK,SendMessage);
            }
            SetFocus(GetDlgItem(hDlg, CB_SCHEMES));
            break;

    }
    return FALSE;
}

void InitImageList(HWND hwndTree)
{
    HICON hIcon = NULL;
    UINT  uFlags;
    int  cxMiniIcon;
    int  cyMiniIcon;
    DWORD dwLayout;

    if (hSndImagelist)
    {
        TreeView_SetImageList(hwndTree, NULL, TVSIL_NORMAL);
        ImageList_Destroy(hSndImagelist);
        hSndImagelist = NULL;
    }
    cxMiniIcon = GetSystemMetrics(SM_CXSMICON);
    cyMiniIcon = GetSystemMetrics(SM_CYSMICON);

    uFlags = ILC_MASK | ILC_COLOR32;


    if (GetProcessDefaultLayout(&dwLayout) &&
            (dwLayout & LAYOUT_RTL)) 
    {
        uFlags |= ILC_MIRROR;
    }
 

    hSndImagelist = ImageList_Create(cxMiniIcon,cyMiniIcon, uFlags, 4, 2);
    if (!hSndImagelist)
        return;

    hIcon = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_PROGRAM),IMAGE_ICON,cxMiniIcon,cyMiniIcon,LR_DEFAULTCOLOR);
    ImageList_AddIcon(hSndImagelist, hIcon);
    DestroyIcon(hIcon);
    hIcon = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_AUDIO),IMAGE_ICON,cxMiniIcon,cyMiniIcon,LR_DEFAULTCOLOR);
    ImageList_AddIcon(hSndImagelist, hIcon);
    DestroyIcon(hIcon);
    hIcon = LoadImage(ghInstance, MAKEINTRESOURCE(IDI_BLANK),IMAGE_ICON,cxMiniIcon,cyMiniIcon,LR_DEFAULTCOLOR);
    ImageList_AddIcon(hSndImagelist, hIcon);
    DestroyIcon(hIcon);
    TreeView_SetImageList(hwndTree, hSndImagelist, TVSIL_NORMAL);

}

/*
 ***************************************************************
 *  InitDialog
 *
 * Description:
 *        Reads the current event names and mappings from  reg.db
 *
 *        Each entry in the [reg.db] section is in this form:
 *
 *        AppEvents
 *            |
 *            |___Schemes  = <SchemeKey>
 *                    |
 *                    |______Names
 *                    |         |
 *                    |         |______SchemeKey = <Name>
 *                    |
 *                    |______Apps
 *                             |
 *                             |______Module
 *                                      |
 *                                      |_____Event
 *                                             |
 *                                             |_____SchemeKey = <Path\filename>
 *                                                     |
 *                                                     |____Active = <1\0
 *
 *        The Module, Event and the file label are displayed in the
 *        comboboxes.
 *
 * Parameters:
 *      HWND hDlg - parent window.
 *
 * Return Value: BOOL
 *        True if entire initialization is ok.
 *
 ***************************************************************
 */
BOOL PASCAL InitDialog(HWND hDlg)
{
    TCHAR     szDefKey[MAXSTR];
    TCHAR     szScheme[MAXSTR];
    TCHAR     szLabel[MAXSTR];
    int      iVal;
    int         i;
    int      cAdded;
    HWND     hWndC;
    LONG     cbSize;
    HKEY     hkNames;
    HWND        hwndTree = GetDlgItem(hDlg, IDC_EVENT_TREE);
    hWndC = GetDlgItem(hDlg, CB_SCHEMES);

    InitImageList(hwndTree);

    EnableWindow(GetDlgItem(hDlg, ID_SAVE_SCHEME), FALSE);
    EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME), FALSE);
    EnableWindow(GetDlgItem(hDlg, ID_PLAY), FALSE);
    EnableWindow(GetDlgItem(hDlg, ID_BROWSE), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_SOUND_FILES), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_NAME), FALSE);

    SetCurDir(hDlg, gszMediaDir, FALSE, TRUE);

    if (RegOpenKey(HKEY_CURRENT_USER, aszNames, &hkNames) != ERROR_SUCCESS)
        DPF("Failed to open aszNames\n");
    else
        DPF("Opened HKEY_CURRENT_USERS\n");
    cAdded = 0;
    for (i = 0; !RegEnumKey(hkNames, i, szScheme, sizeof(szScheme)/sizeof(TCHAR)); i++)
    {
            // Don't add the windows default key yet
        if (lstrcmpi(szScheme, aszDefault))
        {
            cbSize = sizeof(szLabel);
            if ((RegQueryValue(hkNames, szScheme, szLabel, &cbSize) != ERROR_SUCCESS) || (cbSize < 2))
                lstrcpy(szLabel, szScheme);
            if (!lstrcmpi(szScheme, gszNullScheme))
                lstrcpy(aszNullSchemeLabel, szLabel);
            ++cAdded;
            AddScheme(hWndC, szLabel, szScheme, FALSE, 0);
        }
    }
    // Add the windows default key in the second position in the listbox
    cbSize = sizeof(szLabel);
    if ((RegQueryValue(hkNames, aszDefault, szLabel, &cbSize) != ERROR_SUCCESS) || (cbSize < 2))
    {
        LoadString(ghInstance, IDS_WINDOWSDEFAULT, szLabel, MAXSTR);
        if (RegSetValue(hkNames, aszDefault, REG_SZ, szLabel, 0) != ERROR_SUCCESS)
            DPF("Failed to add printable name for default\n");
    }

    if (cAdded == 0)
       AddScheme(hWndC, szLabel, (LPTSTR)aszDefault, TRUE, 0);
    else
       AddScheme(hWndC, szLabel, (LPTSTR)aszDefault, TRUE, WINDOWS_DEFAULTENTRY);

    cbSize = sizeof(szDefKey);
    if ((RegQueryValue(HKEY_CURRENT_USER, aszDefaultScheme, szDefKey,
                                &cbSize) != ERROR_SUCCESS) || (cbSize < 2))
    {
        ComboBox_SetCurSel(hWndC, 0);
        DPF("No default scheme found\n");
    }
    else
    {
        if (!lstrcmpi(szDefKey, aszCurrent))
        {
            ComboBox_InsertString(hWndC, NONE_ENTRY, gszNull);
            ComboBox_SetItemData(hWndC, NONE_ENTRY, aszCurrent);
            iVal = NONE_ENTRY;
            ComboBox_SetCurSel(hWndC, iVal);
        }
        else
        {
            cbSize = sizeof(szLabel);
            if ((RegQueryValue(hkNames, szDefKey, szLabel, &cbSize) != ERROR_SUCCESS) || (cbSize < 2))
            {
                DPF("No Name for default scheme key %s found\n", (LPTSTR)szDefKey);
                lstrcpy(szLabel, szDefKey);
            }

            if ((iVal = ComboBox_FindStringExact(hWndC, 0, szLabel)) != CB_ERR)
                ComboBox_SetCurSel(hWndC, iVal);
            else
                if (lstrcmpi(aszDefault, szDefKey))
                    ComboBox_SetCurSel(hWndC, iVal);
                else
                {
                    iVal = ComboBox_GetCount(hWndC);
                    AddScheme(hWndC, szLabel, szDefKey, TRUE, iVal);
                    ComboBox_SetCurSel(hWndC, iVal);
                }
        }
        giScheme = iVal;        //setting the current global scheme;
        if (LoadModules(hDlg, (LPTSTR)aszCurrent))
        {
            EnableWindow(GetDlgItem(hDlg, ID_SAVE_SCHEME), TRUE);
        }
        else
        {
            ClearModules(hDlg,  hwndTree, TRUE);
            ComboBox_SetCurSel(hWndC, 0);
            DPF("LoadModules failed\n");
            RegCloseKey(hkNames);
            return FALSE;
        }

        if (!lstrcmpi(szDefKey, aszDefault))
            EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME), FALSE);
        else
            EnableWindow(GetDlgItem(hDlg, ID_REMOVE_SCHEME), TRUE);
//        DPF("Finished doing init\n");
    }
    RegCloseKey(hkNames);
    return TRUE;
}


const static DWORD aOpenHelpIDs[] = {  // Context Help IDs
    IDC_STATIC_PREVIEW, IDH_EVENT_BROWSE_PREVIEW,
    ID_PLAY,            IDH_EVENT_PLAY,
    ID_STOP,            IDH_EVENT_STOP,

    0, 0
};

INT_PTR CALLBACK OpenDlgHook(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HSOUND hse;

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            TCHAR szOK[16];
            TCHAR szBuf[MAXSTR];
            LPTSTR   lpszFile;

            // lParam is lpOFN
            DPF("****WM_INITDIALOG in HOOK **** \r\n");
            LoadString(ghInstance, IDS_OK, szOK, sizeof(szOK)/sizeof(TCHAR));
            SetDlgItemText(GetParent(hDlg), IDOK, szOK);
            hse = NULL;

            if (gfWaveExists)
            {
                HWND hwndPlay = GetDlgItem(hDlg, ID_PLAY);
                HWND hwndStop = GetDlgItem(hDlg, ID_STOP);

                SendMessage(hwndStop, BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapStop);
                SendMessage(hwndPlay, BM_SETIMAGE,  IMAGE_BITMAP, (LPARAM)hBitmapPlay);
                EnableWindow(hwndStop, FALSE);
                EnableWindow(hwndPlay, FALSE);

                lpszFile = (LPTSTR)LocalAlloc(LPTR, MAX_PATH+sizeof(TCHAR));
                SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)lpszFile);

                LoadString (ghInstance, IDS_TIP_PLAY, szBuf, sizeof(szBuf)/sizeof(TCHAR));
                CreateTooltip (GetDlgItem (hDlg, ID_PLAY), szBuf);
            }
            break;
        }

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                HELP_WM_HELP, (UINT_PTR)(LPTSTR) aOpenHelpIDs);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                (UINT_PTR)(LPVOID) aOpenHelpIDs);
            break;

        case WM_COMMAND:
            if (!gfWaveExists)
                break;
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ID_PLAY:
                {
                    LPTSTR lpszFile = (LPTSTR)GetWindowLongPtr(hDlg, DWLP_USER);
                    MMRESULT err = MMSYSERR_NOERROR;

                    DPF("*****ID_PLAY in Dlg Hook ***\r\n");
                    if((soundOpen(lpszFile, hDlg, &hse) != MMSYSERR_NOERROR) || ((err = soundPlay(hse)) != MMSYSERR_NOERROR))
                    {
                        if (err == (MMRESULT)MMSYSERR_NOERROR || err != (MMRESULT)MMSYSERR_ALLOCATED)
                            ErrorBox(hDlg, IDS_ERRORFILEPLAY, lpszFile);
                        else
                            ErrorBox(hDlg, IDS_ERRORDEVBUSY, lpszFile);
                        hse = NULL;
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hDlg, ID_PLAY), FALSE);
                        EnableWindow(GetDlgItem(hDlg, ID_STOP), TRUE);
                    }
                    break;
                }
                case ID_STOP:
                {
                    DPF("*****ID_STOP in Dlg Hook ***\r\n");
                    EndSound(&hse);
                    EnableWindow(GetDlgItem(hDlg, ID_STOP), FALSE);
                    EnableWindow(GetDlgItem(hDlg, ID_PLAY), TRUE);

                    break;
                }
                default:
                    return(FALSE);
            }
            break;

        case MM_WOM_DONE:
            EnableWindow(GetDlgItem(hDlg, ID_STOP), FALSE);
            if (hse)
            {
                soundOnDone(hse);
                soundClose(hse);
                hse = NULL;
            }
            EnableWindow(GetDlgItem(hDlg, ID_PLAY), TRUE);
            break;

        case WM_DESTROY:
        {
            LPTSTR lpszFile;

            if (!gfWaveExists)
                break;

            lpszFile = (LPTSTR)GetWindowLongPtr(hDlg, DWLP_USER);
            DPF("**WM_DESTROY in Hook **\r\n");
            if (lpszFile)
                LocalFree((HLOCAL)lpszFile);
            EndSound(&hse);

            break;
        }
        case WM_NOTIFY:
        {
            LPOFNOTIFY pofn;

            if (!gfWaveExists)
                break;

            pofn = (LPOFNOTIFY)lParam;
            switch (pofn->hdr.code)
            {
                case CDN_SELCHANGE:
                {
                    TCHAR szCurSel[MAX_PATH];
                    HWND hwndPlay = GetDlgItem(hDlg, ID_PLAY);
                    LPTSTR lpszFile = (LPTSTR)GetWindowLongPtr(hDlg, DWLP_USER);
                    HFILE hFile;

                    EndSound(&hse);
                    if (CommDlg_OpenSave_GetFilePath(GetParent(hDlg),szCurSel, sizeof(szCurSel)/sizeof(TCHAR)) <= (int)(sizeof(szCurSel)/sizeof(TCHAR)))
                    {
                        OFSTRUCT of;

                        if (!lstrcmpi(szCurSel, lpszFile))
                            break;

                        DPF("****The current selection is %s ***\r\n", szCurSel);
                        hFile = (HFILE)HandleToUlong(CreateFile(szCurSel,GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
                        if (lstrcmpi((LPTSTR)(szCurSel+lstrlen(szCurSel)-4), cszWavExt) || (-1 == hFile))
                        {
                            if (lpszFile[0] == TEXT('\0'))
                                break;
                            lpszFile[0] = TEXT('\0');
                            EnableWindow(hwndPlay, FALSE);
                        }
                        else
                        {
                            CloseHandle(LongToHandle(hFile));
                            EnableWindow(hwndPlay, TRUE);
                            lstrcpy(lpszFile, szCurSel);
                        }
                    }
                    break;
                }

                case CDN_FOLDERCHANGE:
                {
                    EnableWindow(GetDlgItem(hDlg, ID_PLAY), FALSE);
                    break;
                }
                default:
                    break;
            }
            break;
        }

        default:
            return FALSE;

    }
    return TRUE;
}


/*
 ***************************************************************
 * InitFileOpen
 *
 * Description:
 *        Sets up the openfilestruct to read display .wav and .mid files
 *        and sets up global variables for the filename and path.
 *
 * Parameters:
 *    HWND            hDlg  - Window handle
 *    LPOPENFILENAME lpofn - pointer to openfilename struct
 *
 * Returns:            BOOL
 *
 ***************************************************************
 */
STATIC BOOL PASCAL InitFileOpen(HWND hDlg, LPOPENFILENAME lpofn)
{

    lpofn->lStructSize = sizeof(OPENFILENAME);
    lpofn->hwndOwner = hDlg;
    lpofn->hInstance = ghInstance;
    lpofn->lpstrFilter = aszFilter;
    lpofn->lpstrCustomFilter = NULL;
    lpofn->nMaxCustFilter = 0;
    lpofn->nFilterIndex = 0;
    lpofn->lpstrFile = aszPath;
    lpofn->nMaxFile = sizeof(aszPath)/sizeof(TCHAR);
    lpofn->lpstrFileTitle = aszFileName;
    lpofn->nMaxFileTitle = sizeof(aszFileName)/sizeof(TCHAR);
    lpofn->lpstrInitialDir = gszCurDir;
    lpofn->lpstrTitle = aszBrowse;
    lpofn->Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST |OFN_HIDEREADONLY |OFN_EXPLORER |OFN_ENABLEHOOK;
    if (gfWaveExists)
        lpofn->Flags |= OFN_ENABLETEMPLATE;
    lpofn->nFileOffset = 0;
    lpofn->nFileExtension = 0;
    lpofn->lpstrDefExt = NULL;
    lpofn->lCustData = 0;
    lpofn->lpfnHook = OpenDlgHook;
    if (gfWaveExists)
        lpofn->lpTemplateName = MAKEINTRESOURCE(BROWSEDLGTEMPLATE);
    else
        lpofn->lpTemplateName = NULL;
    return TRUE;
}

/* FixupNulls(chNull, p)
 *
 * To facilitate localization, we take a localized string with non-NULL
 * NULL substitutes and replacement with a real NULL.
 */
STATIC void NEAR PASCAL FixupNulls(
    TCHAR chNull,
    LPTSTR p)
{
    while (*p) {
        if (*p == chNull)
            *p++ = 0;
        else
            p = CharNext(p);
    }
} /* FixupNulls */


/* GetDefaultMediaDirectory
 *
 * Returns C:\WINNT\Media, or whatever it's called.
 *
 */
BOOL GetDefaultMediaDirectory(LPTSTR pDirectory, DWORD cbDirectory)
{
    static SZCODE szSetup[] = REGSTR_PATH_SETUP;
    static SZCODE szMedia[] = REGSTR_VAL_MEDIA;
    HKEY          hkeySetup;
    LONG          Result;

    Result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSetup,
                          REG_OPTION_RESERVED,
                          KEY_QUERY_VALUE, &hkeySetup);

    if (Result == ERROR_SUCCESS)
    {
        Result = RegQueryValueEx(hkeySetup, szMedia, NULL, REG_NONE,
                                 (LPBYTE)pDirectory, &cbDirectory);

        RegCloseKey(hkeySetup);
    }

    return (Result == ERROR_SUCCESS);
}


/*
 ***************************************************************
 * InitStringTable
 *
 * Description:
 *      Load the RC strings into the storage for them
 *
 * Parameters:
 *      void
 *
 * Returns:        BOOL
 ***************************************************************
 */
STATIC BOOL PASCAL InitStringTable(void)
{
    static SZCODE cszSetup[] = REGSTR_PATH_SETUP;
    static SZCODE cszMedia[] = REGSTR_VAL_MEDIA;

    LoadString(ghInstance, IDS_NONE, gszNone, sizeof(gszNone)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_BROWSEFORSOUND, aszBrowseStr, sizeof(aszBrowseStr)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_REMOVESCHEME, gszRemoveScheme,sizeof(gszRemoveScheme)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_CHANGESCHEME, gszChangeScheme,sizeof(gszChangeScheme)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_DEFAULTAPP, gszDefaultApp, sizeof(gszDefaultApp)/sizeof(TCHAR));

    LoadString(ghInstance, IDS_WAVFILES, aszFilter, sizeof(aszFilter)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_NULLCHAR, aszNullChar, sizeof(aszNullChar)/sizeof(TCHAR));
    FixupNulls(*aszNullChar, aszFilter);

    gszMediaDir[0] = TEXT('\0');

    if (!GetDefaultMediaDirectory(gszMediaDir, sizeof(gszMediaDir)/sizeof(TCHAR)))
    {
        if (!GetWindowsDirectory (gszMediaDir, sizeof(gszMediaDir)/sizeof(TCHAR)))
			return FALSE;
    }

    return TRUE;
}

/*
 ***************************************************************
 * SoundCleanup
 *
 * Description:
 *      Cleanup all the allocs and bitmaps when the sound page exists
 *
 * Parameters:
 *      void
 *
 * Returns:        BOOL
 ***************************************************************
 */
STATIC BOOL PASCAL SoundCleanup(HWND hDlg)
{

    DeleteObject(hBitmapStop);
    DeleteObject(hBitmapPlay);

    TreeView_SetImageList(GetDlgItem(hDlg, IDC_EVENT_TREE), NULL, TVSIL_NORMAL);
    ImageList_Destroy(hSndImagelist);
    hSndImagelist = NULL;

    DPF("ending sound cleanup\n");
    return TRUE;
}

/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\sound.c ===
/*    -    -    -    -    -    -    -    -    */
//
//    sound.c
//
//    Copyright (C) 1994 Microsoft Corporation.  All Rights Reserved.
//
/*    -    -    -    -    -    -    -    -    */

#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "sound.h"
#include <tchar.h>

/*    -    -    -    -    -    -    -    -    */
typedef struct tagSOUND FAR *PSOUND;
typedef struct tagSOUND 
{
    WAVEHDR        header;
    LPBYTE        pbData;
    DWORD        cbLength;
    LPWAVEFORMATEX    lpwfx;
    HGLOBAL        hgData;
    HWAVEOUT    hwave;
    HWND        hwndNotify;
} SOUND;

typedef struct 
{
    FOURCC    fccRiff;
    DWORD    cbSize;
    FOURCC    fccWave;
} FILEHEADER,  *LPFILEHEADER;


typedef struct 
{
    DWORD    dwCKID;
    DWORD    dwSize;
} CHUNKHEADER,  *LPCHUNKHEADER;

#define    RIFF_FILE    MAKEFOURCC('R','I','F','F')
#define    RIFF_WAVE    MAKEFOURCC('W','A','V','E')
#define    RIFF_FORMAT    MAKEFOURCC('f','m','t',' ')
#define    RIFF_DATA    MAKEFOURCC('d','a','t','a')

/*    -    -    -    -    -    -    -    -    */
#ifdef DEBUG
#define    STATIC
#else
#define    STATIC    static
#endif

typedef CHUNKHEADER UNALIGNED FAR *ULPCHUNKHEADER;
typedef WAVEFORMATEX UNALIGNED FAR *ULPWAVEFORMATEX;

/*    -    -    -    -    -    -    -    -    */
STATIC MMRESULT NEAR PASCAL soundInitWaveHeader(
    PSOUND    ps)
{
    size_t cbWFX;
    ULPWAVEFORMATEX    pwfx;
    ULPCHUNKHEADER    pckhdr;
    LPFILEHEADER    pfhdr;
    LPBYTE        pbData;
    DWORD        dwFileSize;
    DWORD        dwCurPos;

    if (ps->cbLength < sizeof(FILEHEADER))
        return MMSYSERR_INVALPARAM;
    pfhdr = (LPFILEHEADER)ps->pbData;
    if ((pfhdr->fccRiff != RIFF_FILE) || (pfhdr->fccWave != RIFF_WAVE))
        return MMSYSERR_NOTSUPPORTED;
    dwFileSize = pfhdr->cbSize;
    dwCurPos = sizeof(FILEHEADER);
    pbData = (LPBYTE)ps->pbData + sizeof(FILEHEADER);
    if (ps->cbLength < dwFileSize)
        return MMSYSERR_INVALPARAM;
    for (;;) 
    {
        pckhdr = (ULPCHUNKHEADER)pbData;
        if (pckhdr->dwCKID == RIFF_FORMAT)
            break;
        dwCurPos += pckhdr->dwSize + sizeof(CHUNKHEADER);
        if (dwCurPos >= dwFileSize)
            return MMSYSERR_INVALPARAM;
        pbData += pckhdr->dwSize + sizeof(CHUNKHEADER);
    }
    pwfx = (ULPWAVEFORMATEX)(pbData + sizeof(CHUNKHEADER));
    
    cbWFX = sizeof(WAVEFORMATEX);
    if (pwfx->wFormatTag!=WAVE_FORMAT_PCM)
    {
        cbWFX += pwfx->cbSize;
    }

    if ((ps->lpwfx = (LPWAVEFORMATEX)GlobalAlloc (GMEM_FIXED, cbWFX)) == 0)
        return MMSYSERR_NOMEM;

    memcpy ((char *)ps->lpwfx, pwfx, cbWFX);

    pbData = pbData + ((ULPCHUNKHEADER)pbData)->dwSize + sizeof(CHUNKHEADER);
    for (;;) 
    {
        pckhdr = (ULPCHUNKHEADER)pbData;
        if (pckhdr->dwCKID == RIFF_DATA)
            break;
        dwCurPos += pckhdr->dwSize + sizeof(CHUNKHEADER);
        if (dwCurPos >= dwFileSize) 
        {
            GlobalFree ((HGLOBAL)ps->lpwfx);
            ps->lpwfx = NULL;
            return MMSYSERR_INVALPARAM;
        }
        pbData += pckhdr->dwSize + sizeof(CHUNKHEADER);
    }
    ps->header.lpData = pbData + sizeof(CHUNKHEADER);
    ps->header.dwBufferLength = pckhdr->dwSize;
    ps->header.dwBytesRecorded = 0;
    ps->header.dwUser = (DWORD_PTR)ps;
    ps->header.dwFlags = 0;
    ps->header.dwLoops = 0;
    ps->header.lpNext = NULL;
    ps->header.reserved = 0;
    return MMSYSERR_NOERROR;
}

/*    -    -    -    -    -    -    -    -    */
STATIC MMRESULT NEAR PASCAL soundLoadFile(
    LPCTSTR    pszSound,
    HWND    hwndNotify,
    PSOUND    ps)
{
    HFILE        hf;
    MMRESULT    mmr;

    if ((hf = HandleToUlong(CreateFile(pszSound,GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))) != HFILE_ERROR) 
    {
        ps->cbLength = _llseek(hf, 0L, SEEK_END);
        _llseek(hf, 0L, SEEK_SET);
        if (ps->hgData = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, ps->cbLength)) 
        {
            if (ps->pbData = GlobalLock(ps->hgData)) 
            {
                if (_hread(hf, ps->pbData, ps->cbLength) == (LONG)ps->cbLength) 
                {
                    if (!(mmr = soundInitWaveHeader(ps))) 
                    {
                        _lclose(hf);
                        ps->hwndNotify = hwndNotify;
                        return MMSYSERR_NOERROR;
                    }
                } 
                else
                    mmr = MMSYSERR_ERROR;
                GlobalUnlock(ps->hgData);
            } 
            else
                mmr = MMSYSERR_ERROR;
            GlobalFree(ps->hgData);
        } 
        else
            mmr = MMSYSERR_NOMEM;
        _lclose(hf);
    } 
    else
        mmr = MMSYSERR_ERROR;

    return mmr;
}

/*    -    -    -    -    -    -    -    -    */
void FAR PASCAL soundOnDone(
    HSOUND    hs)
{
    PSOUND        ps;

    ps = (PSOUND)hs;
    waveOutUnprepareHeader(ps->hwave, &ps->header, sizeof(WAVEHDR));
    waveOutClose(ps->hwave);
    ps->hwave = NULL;
}

/*    -    -    -    -    -    -    -    -    */
MMRESULT FAR PASCAL soundOpen(
    LPCTSTR    pszSound,
    HWND    hwndNotify,
    PHSOUND    phs)
{
    MMRESULT    mmr;

    if (!(*phs = (HSOUND)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeof(SOUND))))
        return MMSYSERR_NOMEM;
    if (mmr = soundLoadFile(pszSound, hwndNotify, (PSOUND)*phs))
        LocalFree((HLOCAL)*phs);
    return mmr;
}

/*    -    -    -    -    -    -    -    -    */
MMRESULT FAR PASCAL soundClose(
    HSOUND    hs)
{
    PSOUND        ps;
    MMRESULT    mmr;

    if (mmr = soundStop(hs))
        return mmr;
    ps = (PSOUND)hs;
    if (ps->lpwfx != NULL) {
        GlobalFree ((HGLOBAL)ps->lpwfx);
        ps->lpwfx = NULL;
    }
    GlobalUnlock(ps->hgData);
    GlobalFree(ps->hgData);
    LocalFree((HLOCAL)hs);
    return MMSYSERR_NOERROR;
}

/*    -    -    -    -    -    -    -    -    */
MMRESULT FAR PASCAL soundPlay(
    HSOUND    hs)
{
    PSOUND        ps;
    MMRESULT    mmr;

    if (mmr = soundStop(hs))
        return mmr;
    ps = (PSOUND)hs;
    if (!(mmr = waveOutOpen(&ps->hwave, WAVE_MAPPER, ps->lpwfx, (DWORD_PTR)ps->hwndNotify, (DWORD_PTR)ps, CALLBACK_WINDOW | WAVE_ALLOWSYNC))) 
    {
        ps->header.dwFlags &= ~WHDR_DONE;
        if (!(mmr = waveOutPrepareHeader(ps->hwave, &ps->header, sizeof(WAVEHDR)))) 
        {
            if (!(mmr = waveOutWrite(ps->hwave, &ps->header, sizeof(WAVEHDR))))
                return MMSYSERR_NOERROR;
            waveOutUnprepareHeader(ps->hwave, &ps->header, sizeof(WAVEHDR));
        }
        waveOutClose(ps->hwave);
        ps->hwave = NULL;
    }
    return mmr;
}

/*    -    -    -    -    -    -    -    -    */
MMRESULT FAR PASCAL soundStop(
    HSOUND    hs)
{
    PSOUND        ps;
    MSG        msg;

    ps = (PSOUND)hs;
    if (ps->hwave)
        waveOutReset(ps->hwave);
    if (IsWindow(ps->hwndNotify))
    while (PeekMessage(&msg, ps->hwndNotify, MM_WOM_OPEN, MM_WOM_DONE, PM_REMOVE))
    {
        DispatchMessage(&msg);
    }
    return MMSYSERR_NOERROR;
}

/*    -    -    -    -    -    -    -    -    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\startaud.c ===
//==========================================================================;
//
//  startaud.c
//
//  Copyright (c) 1991-2002 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//
//
//  History:
//      07/02        tsharp  (Trey Sharp);
//
//
//==========================================================================;

#include "mmcpl.h"
#include <windowsx.h>
#include <mmsystem.h>
#include <dbt.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <msacmdlg.h>
#include <stdlib.h>
#include "gfxui.h"
#include "drivers.h"
#include "advaudio.h"
#include "roland.h"

#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <devguid.h>
#include <mmddkp.h>
#include <ks.h>
#include <ksmedia.h>

#include <memory.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "trayvol.h"

#include "utils.h"
#include "medhelp.h"
#include "start.h"

#include <wincred.h>
#include <strsafe.h>


/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
HWND        ghStartDlg;


/*
 ***************************************************************
 * extern
 ***************************************************************
 */


/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */

BOOL PASCAL DoStartPropCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
BOOL PASCAL DoStartCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
BOOL MarkRegistryForReboot(void);

//
//
//
BOOL QueryPnpAudioDeviceAvailable(void)
{
    HDEVINFO    hDevInfo;
	BOOL		fFound;
	int         i;
	GUID		guidAudio = KSCATEGORY_AUDIO;
	GUID		guidRender = KSCATEGORY_RENDER;
	GUID		guidCapture = KSCATEGORY_CAPTURE;

    hDevInfo = SetupDiGetClassDevs(&guidAudio, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (INVALID_HANDLE_VALUE == hDevInfo) return FALSE;

	for (i = 0, fFound = FALSE; !fFound; i++)
	{
        SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
        SP_DEVICE_INTERFACE_DATA AliasDeviceInterfaceData;
		BOOL fRender;
		BOOL fCapture;

        DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);

        if (!SetupDiEnumDeviceInterfaces(hDevInfo, NULL, &guidAudio, i, &DeviceInterfaceData)) break;

        AliasDeviceInterfaceData.cbSize = sizeof(AliasDeviceInterfaceData);
        fRender = SetupDiGetDeviceInterfaceAlias(hDevInfo, &DeviceInterfaceData, &guidRender, &AliasDeviceInterfaceData);

        AliasDeviceInterfaceData.cbSize = sizeof(AliasDeviceInterfaceData);
        fCapture = SetupDiGetDeviceInterfaceAlias(hDevInfo, &DeviceInterfaceData, &guidCapture, &AliasDeviceInterfaceData);

			fFound = (fRender || fCapture);

	}

    SetupDiDestroyDeviceInfoList(hDevInfo);

    return fFound;

}




//
// OUT pStartType is starttype of audiosrv.  Normally SERVICE_AUTO_START.
//
// Return value is a winerror.h code.
//
DWORD QueryAudiosrvStartType(OUT PDWORD pStartType)
{
	SC_HANDLE schScm;
	LONG error = NO_ERROR;
	HANDLE hHeap;

	hHeap = GetProcessHeap();
	if (!hHeap) return GetLastError();

    //
    // Attempt to start the AudioSrv Win32 service
    //
    schScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (schScm) {
        SC_HANDLE schAudioSrv;

        schAudioSrv = OpenService(schScm, TEXT("AudioSrv"), SERVICE_QUERY_CONFIG);
        if (schAudioSrv) {
			BOOL success;
			DWORD cbBytesNeeded;

			// Read the start type
			success = QueryServiceConfig(schAudioSrv, NULL, 0, &cbBytesNeeded);
			if (success) error = ERROR_INVALID_PARAMETER;	// Highly unexpected.
			else error = GetLastError();

			if (ERROR_INSUFFICIENT_BUFFER == error)
			{
				LPQUERY_SERVICE_CONFIG pServiceConfig;
				error = NO_ERROR;

				pServiceConfig = (LPQUERY_SERVICE_CONFIG)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbBytesNeeded);
				if (!pServiceConfig) error = ERROR_OUTOFMEMORY;

				if (!error)
				{
					success = QueryServiceConfig(schAudioSrv, pServiceConfig, cbBytesNeeded, &cbBytesNeeded);
					if (success)
					{
						*pStartType = pServiceConfig->dwStartType;
					}
					HeapFree(hHeap, 0, pServiceConfig);
				}
			}

            CloseServiceHandle(schAudioSrv);
        } else {
			error = GetLastError();
        }
        CloseServiceHandle(schScm);
	} else {
		error = GetLastError();
	}

	return error;
}

//
// Return value is a winerror.h code.
//   ERROR_ACCESS_DENIED - user hasn't proper credentials
//
DWORD SetAudiosrvAsAutoStart(void)
{
	SC_HANDLE schScm;
	LONG error = NO_ERROR;

    //
    // Attempt to start the AudioSrv Win32 service
    //
    schScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (schScm) {
        SC_HANDLE schAudioSrv;

        schAudioSrv = OpenService(schScm, TEXT("AudioSrv"), SERVICE_CHANGE_CONFIG);
        if (schAudioSrv) {
			BOOL success;

			// Change the start type to automatic
			success = ChangeServiceConfig(schAudioSrv,
				                          SERVICE_NO_CHANGE,		// ServiceType
										  SERVICE_AUTO_START,		// StartType
										  SERVICE_NO_CHANGE,		// ErrorControl
										  NULL,						// BinaryPathName
										  NULL,						// LoadOrderGroup
										  NULL,						// TagId
										  NULL,						// Dependencies
										  NULL,						// ServiceStartName
										  NULL,						// Password
										  NULL						// DisplayName
										  );

			if (!success) error = GetLastError();

            CloseServiceHandle(schAudioSrv);
        } else {
			error = GetLastError();
        }
        CloseServiceHandle(schScm);
	} else {
		error = GetLastError();
	}

	return error;
}


DWORD RetrieveCredentials( TCHAR* pszUserName, DWORD cbUserNameSize,
                           TCHAR* pszDomain, DWORD cbDomainSize,
                           TCHAR* pszPassword, DWORD cbPasswordSize,
                           UINT nPromptId )
{
    TCHAR achTitle[CREDUI_TITLE_MAX_LENGTH];
    TCHAR achPrompt[CREDUI_PROMPT_MAX_LENGTH];
    CREDUI_INFO uiInfo;
    TCHAR achUserName[CREDUI_MAX_USERNAME_LENGTH + 1];
    TCHAR achDomain[CREDUI_MAX_DOMAIN_TARGET_LENGTH + 1];
    TCHAR achPassword[CREDUI_MAX_PASSWORD_LENGTH + 1];
    DWORD dwError = ERROR_CANCELLED;

    if( pszUserName == NULL  ||  pszDomain == NULL  ||  pszPassword == NULL )
    {
        return ERROR_CANCELLED;
    }

    LoadString( ghInstance, IDS_CREDUI_TITLE, achTitle, CREDUI_TITLE_MAX_LENGTH );
    LoadString( ghInstance, nPromptId, achPrompt, CREDUI_PROMPT_MAX_LENGTH );
    ZeroMemory( &uiInfo, sizeof(uiInfo) );
    uiInfo.cbSize = sizeof(uiInfo);
    uiInfo.hwndParent = ghStartDlg;      
    uiInfo.pszMessageText = achPrompt;
    uiInfo.pszCaptionText = achTitle;

    ZeroMemory( achUserName, sizeof(achUserName) );
    ZeroMemory( achDomain, sizeof(achDomain) );
    ZeroMemory( achPassword, sizeof(achPassword) );

    dwError = CredUIPromptForCredentials( &uiInfo, NULL, NULL,
                                          NO_ERROR,
                                          achUserName, CREDUI_MAX_USERNAME_LENGTH + 1,
                                          achPassword, CREDUI_MAX_PASSWORD_LENGTH + 1,
                                          NULL,
                                          CREDUI_FLAGS_DO_NOT_PERSIST | \
                                          CREDUI_FLAGS_VALIDATE_USERNAME | \
                                          CREDUI_FLAGS_EXCLUDE_CERTIFICATES | \
                                          CREDUI_FLAGS_REQUEST_ADMINISTRATOR | \
                                          CREDUI_FLAGS_GENERIC_CREDENTIALS );

    if( dwError == NO_ERROR )
    {
        dwError = CredUIParseUserName( achUserName,
                                       pszUserName, (cbUserNameSize / sizeof(pszUserName[0])),
                                       pszDomain, (cbDomainSize / sizeof(pszDomain[0])) );
        if( dwError == NO_ERROR )
        {
            if( StringCbCopy(pszPassword, cbPasswordSize, achPassword) != S_OK )
            {
                dwError = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    }

    // Check to see if an error occurred along the way
    if( dwError != NO_ERROR )
    {
        // Clear domain/username/password from memory
        SecureZeroMemory( pszUserName, cbUserNameSize );
        SecureZeroMemory( pszDomain, cbDomainSize );
        SecureZeroMemory( pszPassword, cbPasswordSize );
        
        if( dwError != ERROR_CANCELLED )
        {
            TCHAR achTitle[CREDUI_TITLE_MAX_LENGTH];
            int nError = GetLastError();
            LPTSTR pszMessageBuffer;

            LoadString( ghInstance, IDS_CREDUI_TITLE, achTitle, CREDUI_TITLE_MAX_LENGTH );
            FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL, 
                           nError,
                           MAKELANGID(LANG_NEUTRAL, 
                           SUBLANG_DEFAULT),
                           (LPTSTR)&pszMessageBuffer, 
                           0,
                           NULL );

            MessageBox( ghStartDlg, pszMessageBuffer, achTitle, MB_OK );
            LocalFree( pszMessageBuffer );
        }
    }
    return dwError;
}

 

DWORD AttemptToGetAdminPrivilege( HANDLE* phToken, UINT nPromptId ) 
{
    TCHAR achUserName[CREDUI_MAX_USERNAME_LENGTH + 1];
    TCHAR achDomain[CREDUI_MAX_DOMAIN_TARGET_LENGTH + 1];
    TCHAR achPassword[CREDUI_MAX_PASSWORD_LENGTH + 1];
    DWORD dwError = ERROR_CANCELLED;

    if( phToken == NULL )
    {
        return ERROR_CANCELLED;
    }

    *phToken = NULL;

    // Ask for administrator credentials
    dwError = RetrieveCredentials( achUserName, sizeof(achUserName),
                                   achDomain, sizeof(achDomain),
                                   achPassword, sizeof(achPassword),
                                   nPromptId );

    if( dwError == NO_ERROR )
    {
        HANDLE hAdminToken;

        // Attempt to logon
        if( LogonUser(achUserName, achDomain, achPassword,
                      LOGON32_LOGON_INTERACTIVE, 
                      LOGON32_PROVIDER_DEFAULT, &hAdminToken) )
        {
            // Attempt to impersonate logged on user
            if( ImpersonateLoggedOnUser(hAdminToken) )
            {
                *phToken = hAdminToken;
            }
            else
            {
                // Impersonation failed
                CloseHandle( hAdminToken );
                dwError = ERROR_CANNOT_IMPERSONATE;
            }
        }
        else
        {
            // Logon failed
            dwError = ERROR_LOGON_FAILURE;
        }
        
        // Was logon successful?
        if( dwError != NO_ERROR )
        {
            // Logon failed
            TCHAR achTitle[CREDUI_TITLE_MAX_LENGTH];
            LPTSTR pszMessageBuffer;
            int nError;
            LoadString( ghInstance, IDS_CREDUI_TITLE, achTitle, CREDUI_TITLE_MAX_LENGTH );
            nError = GetLastError();
            FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL,
                           nError,
                           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                           (LPTSTR)&pszMessageBuffer,
                           0,
                           NULL );

            MessageBox( ghStartDlg, pszMessageBuffer, achTitle, MB_OK );
            LocalFree( pszMessageBuffer );
        }
    }

    // Clear domain/username/password from memory
    SecureZeroMemory( achUserName, sizeof(achUserName) );
    SecureZeroMemory( achDomain, sizeof(achDomain) );
    SecureZeroMemory( achPassword, sizeof(achPassword) );

    return dwError;
}


HANDLE GetAdminPrivilege( UINT nPromptId ) 
{
    HANDLE hToken = NULL;
    BOOL fDone = FALSE;

    do
    {
        DWORD dwError = AttemptToGetAdminPrivilege( &hToken, nPromptId );

        if( dwError == NO_ERROR  ||  dwError == ERROR_CANCELLED )
        {
            fDone = TRUE;
        }
    }
    while( fDone == FALSE );

    return hToken;
}


void ReleaseAdminPrivilege( HANDLE hToken ) 
{
    if( hToken )
    {
        RevertToSelf();
        CloseHandle( hToken );
    }
} 




STATIC void STARTAUDIOInit(HWND hDlg)
{
    ghStartDlg = hDlg;
}


const static DWORD aStartHelpIds[] = {  // Context Help IDs
    IDC_GROUPBOX_START_1,               NO_HELP,
    IDC_ICON_START_1,                   NO_HELP,
    IDC_TEXT_START_1,                   NO_HELP,
    IDC_START_CHECK,                    NO_HELP,
    IDC_TEXT_START_2,                   NO_HELP,
    IDC_TEXT_START_3,                   NO_HELP,
    IDC_TEXT_START_4,                   NO_HELP,
    
    0, 0
};


BOOL CALLBACK StartDlg(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam)
{
    NMHDR FAR   *lpnm;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                break;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            STARTAUDIOInit(hDlg);
        }
        break;

        case WM_DESTROY:
        {
        }
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aStartHelpIds);
            return TRUE;
        }
        break;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aStartHelpIds);
            return TRUE;
        }
        break;

        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoStartCommand);
        }
        break;

        default:
        {
        }
        break;
    }
    return FALSE;
}

void ErrorStartMsgBox(HWND hDlg, UINT uTitle, UINT uMessage)
{
    TCHAR szMsg[MAXSTR];
    TCHAR szTitle[MAXSTR];

    LoadString(ghInstance, uTitle, szTitle, sizeof(szTitle)/sizeof(TCHAR));
    LoadString(ghInstance, uMessage, szMsg, sizeof(szMsg)/sizeof(TCHAR));
    MessageBox(hDlg, szMsg,szTitle,MB_OK);
}

BOOL PASCAL DoStartCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{

    switch (id)
    {
        case IDOK:
        {  
            if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_START_CHECK))
            {
                DWORD   dwError;

                dwError = SetAudiosrvAsAutoStart();
                if( dwError == NO_ERROR )
                {
                    MarkRegistryForReboot();
                    RebootSystem( hDlg, FALSE, TRUE, TRUE );
                }
                else
                {
                    while( dwError == ERROR_ACCESS_DENIED )
                    {
                        HANDLE hToken = GetAdminPrivilege( IDS_CREDUI_PROMPT );

                        if( hToken )
                        {
                            dwError = SetAudiosrvAsAutoStart();
                            if( dwError == NO_ERROR )
                            {
                                MarkRegistryForReboot();
                                RebootSystem( hDlg, TRUE, TRUE, TRUE );
                            }
                            ReleaseAdminPrivilege( hToken );
                        }
                        else
                        {
                            // User cancelled credentials UI, so force CPL to remain open
                            gfRedisplayCPL = TRUE; 

                            // Force break from while statement
                            dwError = ERROR_CANCELLED;
                        }
                    }
                }
            }
        }
        break;
    }

    return FALSE;
}

BOOL MarkRegistryForReboot(void)
{
    HKEY    hkTmp;

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE
		            ,REGSTR_TEMP_REBOOT
		            ,0
		            ,NULL
		            ,REG_OPTION_VOLATILE
		            ,KEY_WRITE
		            ,NULL
		            ,&hkTmp
		            ,NULL ) == ERROR_SUCCESS)
    {
        RegCloseKey(hkTmp);
        return TRUE;
    }

    return FALSE;
}

BOOL AudioServiceStarted(void)
{
    if (QueryPnpAudioDeviceAvailable())
    {
        DWORD dwRetCode = 0;
        DWORD dwStartType = 0;

        dwRetCode = QueryAudiosrvStartType(&dwStartType);  // Check return nessesary?
        if (SERVICE_AUTO_START == dwStartType)
        {
            return TRUE;
        } else
        {
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\trayvol.h ===
#ifndef _systray_h_
#define _systray_h_
BOOL SetTrayVolumeEnabled(BOOL bEnable);
BOOL GetTrayVolumeEnabled(void);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\systrayp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:	SYSTRAY.H
*
*  VERSION:	2.1
*
*  AUTHOR:	Tracy Sharpe / RAL
*
*  DATE:        20 Feb 1994
*
*  Public definitions of the system tray applet (battery meter, PCMCIA, etc).
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  20 Feb 1994 TCS Original implementation.
*  11/8/94     RAL Converted to systray
*
*******************************************************************************/

#ifndef _INC_SYSTRAY
#define _INC_SYSTRAY

#define SYSTRAY_CLASSNAME	   TEXT("SystemTray_Main")

//  Private tray icon notification message sent to the BatteryMeter window.
#define STWM_NOTIFYPOWER		(WM_USER + 201)
#define STWM_NOTIFYPCMCIA		(WM_USER + 202)
#define STWM_NOTIFYVOLUME		(WM_USER + 203)

//  Private tray icon notification messages sent to the BatteryMeter window.
#define STWM_ENABLESERVICE		(WM_USER + 220)
#define STWM_GETSTATE			(WM_USER + 221)


_inline BOOL SysTray_EnableService(int idSTService, BOOL fEnable)
{
    if (fEnable)
    {
        STARTUPINFO si;
        PROCESS_INFORMATION pi;
	    static const TCHAR szSTExecFmt[] = TEXT("SYSTRAY.EXE %i");
	    TCHAR szEnableCmd[sizeof(szSTExecFmt)+10];
        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOWNOACTIVATE;
        si.dwFlags = STARTF_USESHOWWINDOW;
	    wsprintf(szEnableCmd, szSTExecFmt, idSTService);
	    if (CreateProcess(NULL,szEnableCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
        {
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
	    HWND hwndST = FindWindow(SYSTRAY_CLASSNAME, NULL);
	    if (hwndST)
        {
	        SendMessage(hwndST, STWM_ENABLESERVICE, idSTService, FALSE);
	    }
    }
    return TRUE;
}


_inline BOOL SysTray_IsServiceEnabled(WPARAM idSTService)
{
    HWND hwndST = FindWindow(SYSTRAY_CLASSNAME, NULL);
    if (hwndST) {
	return((BOOL)SendMessage(hwndST, STWM_GETSTATE, idSTService, 0));
    } else {
	return(FALSE);
    }
}

#define STSERVICE_POWER 		1
#define STSERVICE_PCMCIA		2
#define STSERVICE_VOLUME		4
#define STSERVICE_ALL			7   // Internal

//
//  Flags for the PCMCIA registry entry
//
#define PCMCIA_REGFLAG_NOWARN		1

#endif // _INC_SYSTRAY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\sulib.h ===
/*
 * SULIB.H - Windows/DOS Setup common code
 *
 *  Modification History:
 *
 *
 *  3/23/89  Toddla   combined common.h and prototypes into this file
 *  1/28/91  MichaelE Added AUDIO_CARDS_SECT for different audio card choices.
 *  4/17/91  Removed some DOS.ASM routines not used anywhere.
 *  5/29/91  JKLin added prototype for IsCDROMDrive function
 *
 */

#define FALLOC(n)                ((VOID *)GlobalAlloc(GPTR, n))
#define FFREE(n)                 GlobalFree(n)

#define ALLOC(n)                 (VOID *)LocalAlloc(LPTR,n)
#define FREE(p)                  LocalFree(p)
#define REALLOC(p,n)             LocalRealloc(p,n,LMEM_MOVEABLE)

#define SIZEOF(array)            (sizeof(array)/sizeof((array)[0]))

// INF_PARSE_XXX macros are to be used with the return code from InfParseField()
#define INF_PARSE_FAILED(n)		 ((n) != ERROR_SUCCESS && (n) != ERROR_NOT_FOUND)				 
#define INF_PARSE_SUCCESS(n)	 ((n) == ERROR_SUCCESS || (n) == ERROR_NOT_FOUND)			 

/* flags for _llseek */

#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define MAXFILESPECLEN       MAX_PATH /* drive: + path length max + Null Byte */
#define MAX_INF_LINE_LEN     256      /* Maximum length of any .inf line */
#define MAX_SYS_INF_LEN      256      /* ##: + 8.3 + NULL */
#define MAX_SECT_NAME_LEN    40       /* Max length of a section Name. */
#define MAX_FILE_SPEC        MAX_PATH // 8.3 + X: + NULL.

#define DISK_SECT              TEXT("disks")
#define OEMDISK_SECT           TEXT("oemdisks")



/* Return codes from 'file exists' dialog */

enum {
    CopyNeither,            // User wants to cancel if file exists
    CopyCurrent,            // User wants to use current file
    CopyNew                 // User wants to copy new file
};

#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))
#define CHSEPSTR                TEXT("\\")
#define COMMA   TEXT(',')
#define SPACE   TEXT(' ')

/* Globals and routines for .inf file parsing */

typedef LPTSTR    PINF;

extern PINF infOpen(LPTSTR szInf);
extern void infClose(PINF pinf);
extern PINF infSetDefault(PINF pinf);
extern PINF infFindSection(PINF pinf, LPTSTR szSection);
extern LONG infGetProfileString(PINF pinf, LPTSTR szSection, LPTSTR szItem, LPTSTR szBuf, size_t cchBuf);
extern LONG infParseField(PINF szData, int n, LPTSTR szBuf, size_t cchBuf);
extern PINF infNextLine(PINF pinf);
extern int  infLineCount(PINF pinf);
extern BOOL infLookup(LPTSTR szInf, LPTSTR szBuf);
extern PINF FindInstallableDriversSection(PINF pinf);

/* Message types for FileCopy callback function */

typedef BOOL (*FPFNCOPY) (int,DWORD_PTR,LPTSTR);
#define COPY_ERROR          0x0001
#define COPY_INSERTDISK     0x0003
#define COPY_QUERYCOPY      0x0004
#define COPY_START          0x0005
#define COPY_END            0x0006
#define COPY_EXISTS         0x0007

extern UINT FileCopy (LPTSTR szSource, LPTSTR szDir, FPFNCOPY fpfnCopy, UINT fCopy);

/* Option Flag values for FileCopy */

#define FC_FILE              0x0000
#define FC_LIST              0x0001
#define FC_SECTION           0x0002
#define FC_QUALIFIED         0x0008
#define FC_DEST_QUALIFIED    0x0010
#define FC_LISTTYPE          0x0020
#define FC_CALLBACK_WITH_VER 0x0040

#define FC_ABORT    0
#define FC_IGNORE   1
#define FC_RETRY    2
#define FC_ERROR_LOADED_DRIVER  0x80

/* External functions from copy.c */

extern LONG ExpandFileName(LPTSTR szFile, LPTSTR szPath);
extern void catpath(LPTSTR path, LPTSTR sz);
extern BOOL fnFindFile(TCHAR *);
extern LPTSTR FileName(LPTSTR szPath);
extern LPTSTR RemoveDiskId(LPTSTR szPath);
extern LPTSTR StripPathName(LPTSTR szPath);
extern BOOL IsFileKernelDriver(LPTSTR szPath);


/*******************************************************************
 *
 * Global Variables
 *
 *******************************************************************/

 // Path to the directory where we found the .inf file

 extern TCHAR szSetupPath[MAX_PATH];

 // Path to the user's disk(s)

 extern TCHAR szDiskPath[MAX_PATH];   // Path to the default drive -
                                     //
 extern BOOL bRetry;

 // Name of the driver being installed

 extern TCHAR szDrv[120];

 //

 extern TCHAR szFileError[50];

 // Parent window for file copy dialogues

 HWND hMesgBoxParent;

 // TRUE on copying first file to prompt user if file already exists
 // FALSE for subsequent copies

 extern BOOL bQueryExist;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\trayvol.c ===
#include <windows.h>
#include "systrayp.h"
#include "trayvol.h"

#define MMSYS_UPDATEMIXER	3000	//This message tells the systray that the preferred device has
									//changed.

// Helper functions for things we care about
BOOL SetTrayVolumeEnabled(BOOL bEnable)
{
    return SysTray_EnableService(STSERVICE_VOLUME,bEnable);
}

BOOL GetTrayVolumeEnabled(void)
{
    return SysTray_IsServiceEnabled(STSERVICE_VOLUME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\utils.h ===
//
// utils.h: Declares data, defines and struct types for common code
//            module.
//
//

#ifndef __UTILS_H__
#define __UTILS_H__



/////////////////////////////////////////////////////  DEFINES

#define BLOCK        
#define Unref(x)     x

#ifdef DEBUG
#define INLINE
#define DEBUG_CODE(x)   x
#else
#define INLINE          __inline
#define DEBUG_CODE(x)   
#endif


/////////////////////////////////////////////////////  MACROS

// Zero-initialize data-item
//
#define ZeroInit(pobj, type)        lmemset((LPTSTR)pobj, 0, sizeof(type))

// Copy chunk of memory
//
#define BltByte(pdest, psrc, cb)    lmemmove((LPTSTR)pdest, (LPTSTR)psrc, cb)

// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))  
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))  

//      void * GAlloc(DWORD cbBytes)
//          Alloc a chunk of memory, quickly, with no 64k limit on size of
//          individual objects or total object size.  Initialize to zero.
//
#define GAlloc(cbBytes)         GlobalAlloc(GPTR, cbBytes)

//      void * GReAlloc(void * pv, DWORD cbNewSize)
//          Realloc one of above.  If pv is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
#define GReAlloc(pv, cbNewSize) GlobalReAlloc(pv, GMEM_MOVEABLE | GMEM_ZEROINIT, cbNewSize)

//      void GFree(void *pv)
//          Free pv if it is nonzero.  Set pv to zero.  
//
#define GFree(pv)        do { (pv) ? GlobalFree(pv) : (void)0;  pv = NULL; } while (0)

//      DWORD GGetSize(void *pv)
//          Get the size of a block allocated by Alloc()
//
#define GGetSize(pv)            GlobalSize(pv)

//      type * GAllocType(type);                    (macro)
//          Alloc some memory the size of <type> and return pointer to <type>.
//
#define GAllocType(type)                (type *)GAlloc(sizeof(type))

//      type * GAllocArray(type, int cNum);         (macro)
//          Alloc an array of data the size of <type>.
//
#define GAllocArray(type, cNum)          (type *)GAlloc(sizeof(type) * (cNum))

//      type * GReAllocArray(type, void * pb, int cNum);
//
#define GReAllocArray(type, pb, cNum)    (type *)GReAlloc(pb, sizeof(type) * (cNum))

//      void Free(void _huge * pb);                      (macro)
//          Free pb if it is nonzero.  Set pb to zero.  (Overrides Free above.)
//
#define Free(pb)        do { (pb) ? Free(pb) : (void)0;  pb = NULL; } while (0)


// Color macros
//
#define ColorText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT)
#define ColorBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_WINDOW)
#define ColorMenuText(nState)   (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT)
#define ColorMenuBk(nState)     (((nState) & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_MENU)
#define GetImageDrawStyle(nState)   (((nState) & ODS_SELECTED) ? ILD_SELECTED : ILD_NORMAL)

// Sets the dialog handle in the given data struct on first
//  message that the dialog gets (WM_SETFONT).
//
#define SetDlgHandle(hwnd, msg, lp)     if((msg)==WM_SETFONT) (lp)->hdlg=(hwnd);



#endif // __UTILS_H__
#ifndef __STRING_H__
#define __STRING_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  MACROS

#define Bltbyte(rgbSrc,rgbDest,cb)  _fmemmove(rgbDest, rgbSrc, cb)

// Model independent, language-independent (DBCS aware) macros
//  taken from rcsys.h in Pen project and modified.
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsCaseSzEqual(sz1, sz2)     (BOOL)(lstrcmp(sz1, sz2) == 0)
#define SzFromInt(sz, n)            (wsprintf((LPTSTR)sz, (LPTSTR)TEXT("%d"), n), (LPTSTR)sz)

#define IsLink(sz, szLnk)			(!lstrcmpi((LPTSTR)(sz+lstrlen(sz)-4), szLnk))


/////////////////////////////////////////////////////  PROTOTYPES

LPTSTR PUBLIC SzStrTok(LPTSTR string, LPCTSTR control);
LPCTSTR PUBLIC SzStrCh(LPCTSTR string, char ch);

LPTSTR PUBLIC SzFromIDS (UINT ids, LPTSTR pszBuf, int cbBuf);

/////////////////////////////////////////////////////  MORE INCLUDES

#endif // __STRING_H__


typedef struct _PROC_INFO
{
    LPCSTR  Name;
    FARPROC Address;
}
PROC_INFO, *PPROC_INFO;

#define PROCS_LOADED( pProcInfo ) ( (pProcInfo)[0].Address != NULL )
#define LOAD_IF_NEEDED( Library, ProcInfo ) ( PROCS_LOADED( ProcInfo ) ||   \
                                    LoadLibraryAndProcs( Library, ProcInfo ) )


extern PROC_INFO ACMProcs[];
extern PROC_INFO VFWProcs[];
extern PROC_INFO AVIProcs[];
extern PROC_INFO VERSIONProcs[];

BOOL LoadACM();
BOOL FreeACM();
BOOL LoadAVI();
BOOL FreeAVI();
BOOL LoadVFW();
BOOL FreeVFW();
BOOL LoadVERSION();
BOOL FreeVERSION();

//#define DEBUG_BUILT_LINKED
#ifndef DEBUG_BUILT_LINKED

#define acmFormatDetailsW            	(*ACMProcs[0].Address)
#define acmFormatTagDetailsW         	(*ACMProcs[1].Address)
#define acmDriverDetailsW            	(*ACMProcs[2].Address)
#define acmDriverMessage            	(*ACMProcs[3].Address)
#define acmDriverAddW            		(*ACMProcs[4].Address)
#define acmDriverEnum            		(*ACMProcs[5].Address)
#define acmDriverPriority            	(*ACMProcs[6].Address)
#define acmDriverRemove            		(*ACMProcs[7].Address)
#define acmMetrics            			(*ACMProcs[8].Address)
#define acmFormatChooseW            	(*ACMProcs[9].Address)

#define ICClose			            	(*VFWProcs[0].Address)
#define ICGetInfo		            	(*VFWProcs[1].Address)
#define ICLocate		            	(*VFWProcs[2].Address)
#define MCIWndCreateW	            	(*VFWProcs[3].Address)

#define AVIFileRelease 	            	(*AVIProcs[0].Address)
#define AVIStreamRelease	           	(*AVIProcs[1].Address)
#define AVIStreamSampleToTime			(*AVIProcs[2].Address)
#define AVIStreamStart					(*AVIProcs[3].Address)
#define AVIStreamLength					(*AVIProcs[4].Address)
#define AVIStreamReadFormat				(*AVIProcs[5].Address)
#define AVIStreamInfoW					(*AVIProcs[6].Address)
#define AVIFileGetStream				(*AVIProcs[7].Address)
#define AVIFileOpenW   	            	(*AVIProcs[8].Address)
#define AVIFileInit   	            	(*AVIProcs[9].Address)
#define AVIFileExit   	            	(*AVIProcs[10].Address)

#define VerQueryValueW	            	(*VERSIONProcs[0].Address)
#define GetFileVersionInfoW            	(*VERSIONProcs[1].Address)
#define GetFileVersionInfoSizeW        	(*VERSIONProcs[2].Address)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\voicecpl.c ===
//==========================================================================;
//
//  cpl.c
//
//  Copyright (c) 1991-1993 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//
//
//  History:
//      07/94        VijR (Vij Rajarajan);
//
//      10/95        R Jernigan - removed link to Adv tab's treeview control
//      09/99        tsharp - Ported back from W2K
//
//==========================================================================;

#include "mmcpl.h"
#include <windowsx.h>
#include <mmsystem.h>
#include <dbt.h>
#include <ks.h>
#include <ksmedia.h>
#include <mmddkp.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>
#include <msacmdlg.h>
#include <stdlib.h>
#include "gfxui.h"
#include "drivers.h"
#include "advaudio.h"
#include "roland.h"

#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <devguid.h>

#define WM_ACMMAP_ACM_NOTIFY        (WM_USER + 100)

#include <memory.h>
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include "trayvol.h"

#include "utils.h"
#include "medhelp.h"

/****************************************************************************
 * WARNING - Hack Alert
 * The following declares are for DPLAY Voice
 ****************************************************************************/

#define _FACDPV  0x15
#define MAKE_DVHRESULT( code )	MAKE_HRESULT( 1, _FACDPV, code )

#define DV_FULLDUPLEX		MAKE_HRESULT( 0, _FACDPV,   5 )
#define DV_HALFDUPLEX		MAKE_HRESULT( 0, _FACDPV,  10 )
#define DVERR_COMMANDALREADYPENDING		MAKE_DVHRESULT( 371 )
#define DVERR_SOUNDINITFAILURE			MAKE_DVHRESULT( 372 )
#define DVERR_USERCANCEL				MAKE_DVHRESULT( 384 )


// {D26AF734-208B-41da-8224-E0CE79810BE1}
DEFINE_GUID(IID_IDirectPlayVoiceSetup, 
0xd26af734, 0x208b, 0x41da, 0x82, 0x24, 0xe0, 0xce, 0x79, 0x81, 0xb, 0xe1);

// {948CE83B-C4A2-44b3-99BF-279ED8DA7DF5}
DEFINE_GUID(CLSID_DIRECTPLAYVOICE, 
0x948ce83b, 0xc4a2, 0x44b3, 0x99, 0xbf, 0x27, 0x9e, 0xd8, 0xda, 0x7d, 0xf5);

// {0F0F094B-B01C-4091-A14D-DD0CD807711A}
DEFINE_GUID(CLSID_DirectPlayVoiceTest, 
0xf0f094b, 0xb01c, 0x4091, 0xa1, 0x4d, 0xdd, 0xc, 0xd8, 0x7, 0x71, 0x1a);


typedef struct IDirectPlayVoiceSetup FAR *LPDIRECTPLAYVOICESETUP, *PDIRECTPLAYVOICESETUP;

#define DVFLAGS_WAVEIDS						0x80000000

#define IDirectPlayVoiceSetup_QueryInterface(p,a,b)	(p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayVoiceSetup_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectPlayVoiceSetup_Release(p)               (p)->lpVtbl->Release(p)

#define IDirectPlayVoiceSetup_CheckAudioSetup(p,a,b,c,d)   (p)->lpVtbl->CheckAudioSetup(p,a,b,c,d)

#undef INTERFACE
#define INTERFACE IDirectPlayVoiceSetup
DECLARE_INTERFACE_( IDirectPlayVoiceSetup, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, PVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlayVoiceSetup methods ***/
    STDMETHOD_(HRESULT, CheckAudioSetup) (THIS_ LPGUID, LPGUID, HWND, DWORD ) PURE;
};

/****************************************************************************
 * WARNING - Hack Alert End
 ****************************************************************************/

/*
 ***************************************************************
 * Globals
 ***************************************************************
 */

BOOL        gfVocLoadedACM;
BOOL        gbVocSelectChanged = FALSE;
BOOL        gbVocCapPresent = FALSE;
BOOL        gbVocPlayPresent = FALSE;
UINT        giVocChange = 0;
WNDPROC     gfnVocPSProc = NULL;
HWND        ghVocDlg;

/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */


/*
 ***************************************************************
 * extern
 ***************************************************************
 */


/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */

BOOL PASCAL DoVocPropCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
BOOL PASCAL DoVoiceCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);

void VOICEOUTInit(HWND hDlg, PAUDIODLGINFO paiVoc);
void VOICECAPInit(HWND hDlg, PAUDIODLGINFO paiVoc);



///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetVoiceOutID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD           dwWaveID;
    DWORD           dwFlags = 0;
    
    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_CONSOLEVOICECOM_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(dwWaveID);
}

///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
BOOL SetVoiceOutID(DWORD dwWaveID, BOOL fPrefOnly)
{
    MMRESULT    mmr;
    DWORD       dwFlags = fPrefOnly ? 0x00000001 : 0x00000000;

    mmr = waveOutMessage(HWAVEOUT_MAPPER, DRVM_MAPPER_CONSOLEVOICECOM_SET, dwWaveID, dwFlags);
    return (!FAILED (mmr)); // TRUE;
}



///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetVoiceCapID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD           dwWaveID;
    DWORD           dwFlags = 0;
    
    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveInMessage(HWAVEIN_MAPPER, DRVM_MAPPER_CONSOLEVOICECOM_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(dwWaveID);
}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
BOOL SetVoiceCapID(DWORD dwWaveID, BOOL fPrefOnly)
{
    MMRESULT    mmr;
    DWORD       dwFlags = fPrefOnly ? 0x00000001 : 0x00000000;

    mmr = waveInMessage(HWAVEIN_MAPPER, DRVM_MAPPER_CONSOLEVOICECOM_SET, dwWaveID, dwFlags);
    return (!FAILED (mmr)); // TRUE;
}


void GetVocPrefInfo(PAUDIODLGINFO paiVoc, HWND hDlg )
{

    // Load VoiceOut Info
	paiVoc->cNumOutDevs = waveOutGetNumDevs();
    paiVoc->uPrefOut = GetVoiceOutID(&paiVoc->fPrefOnly);


    // Load VoiceCap Info
    paiVoc->cNumInDevs  = waveInGetNumDevs();
    paiVoc->uPrefIn = GetVoiceCapID(NULL);

}



STATIC void EnablePlayVoiceVolCtrls(HWND hDlg, BOOL fEnable)
{
    EnableWindow( GetDlgItem(hDlg, IDC_LAUNCH_VOCVOL) , fEnable);
    EnableWindow( GetDlgItem(hDlg, IDC_PLAYBACK_ADVVOC) , fEnable);
}

STATIC void EnableRecVoiceVolCtrls(HWND hDlg, BOOL fEnable, BOOL fControl)
{
    EnableWindow( GetDlgItem(hDlg, IDC_LAUNCH_CAPVOL) , fEnable);
    EnableWindow( GetDlgItem(hDlg, IDC_CAPTURE_ADVVOL) , fControl);
}


STATIC void SetVoiceOut(UINT uID, HWND hDlg)
{
    BOOL    fEnabled = FALSE;
    HMIXER  hMixer = NULL;
    UINT    uMixID;

    if(MMSYSERR_NOERROR == mixerGetID(HMIXEROBJ_INDEX(uID), &uMixID, MIXER_OBJECTF_WAVEOUT)) 
    {
        if(MMSYSERR_NOERROR == mixerOpen(&hMixer, uMixID, 0L, 0L, 0L))
        {
            fEnabled = TRUE;
            mixerClose(hMixer);
        }
	}

	EnablePlayVoiceVolCtrls(hDlg, fEnabled);
    gbVocPlayPresent = fEnabled;
}



DWORD CountVocInputs(DWORD dwMixID)
{
    MIXERCAPS   mc;
    MMRESULT    mmr;
    DWORD dwCount = 0;

    mmr = mixerGetDevCaps(dwMixID, &mc, sizeof(mc));

    if (mmr == MMSYSERR_NOERROR)
    {
        MIXERLINE   mlDst;
        DWORD       dwDestination;
        DWORD       cDestinations;

        cDestinations = mc.cDestinations;

        for (dwDestination = 0; dwDestination < cDestinations; dwDestination++)
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination = dwDestination;

            if (mixerGetLineInfo(HMIXEROBJ_INDEX(dwMixID), &mlDst, MIXER_GETLINEINFOF_DESTINATION  ) == MMSYSERR_NOERROR)
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_WAVEIN ||    // needs to be a likely output destination
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_VOICEIN)
                {
                    DWORD cConnections = mlDst.cConnections;

                    dwCount += mlDst.cControls;

                    if (cConnections)
                    {
                        DWORD dwSource; 

                        for (dwSource = 0; dwSource < cConnections; dwSource++)
                        {
                            mlDst.dwDestination = dwDestination;
                            mlDst.dwSource = dwSource;

                            if (mixerGetLineInfo(HMIXEROBJ_INDEX(dwMixID), &mlDst, MIXER_GETLINEINFOF_SOURCE ) == MMSYSERR_NOERROR)
                            {
                                dwCount += mlDst.cControls;
                            }
                        }
                    }
                }
            }
        }
    }

    return(dwCount);
}


STATIC void SetVoiceCap(UINT uID, HWND hDlg)
{
    BOOL    fEnabled = FALSE;
    BOOL    fControl = FALSE;
    HMIXER  hMixer = NULL;
    UINT    uMixID;

    gbVocCapPresent = FALSE;

    if( (MMSYSERR_NOERROR == mixerGetID(HMIXEROBJ_INDEX(uID),&uMixID, MIXER_OBJECTF_WAVEIN)))
    {
        if( MMSYSERR_NOERROR == mixerOpen(&hMixer, uMixID, 0L, 0L, 0L))
        {
            gbVocCapPresent = TRUE; // Even if the device has no inputs still enable test wizard
            if (CountVocInputs(uMixID))
            {
                fEnabled = TRUE;
                // If the capture device is not GFX capable, then there are no tabs to display
                fControl = GFXUI_CheckDevice(uMixID, GFXTYPE_CAPTURE);
            }

            mixerClose(hMixer);
        }
    }

    EnableRecVoiceVolCtrls(hDlg, fEnabled, fControl);
}


STATIC void SetVocPrefInfo(PAUDIODLGINFO paiVoc, HWND hDlg )
{
    HWND    hwndCBPlay   = GetDlgItem(hDlg, IDC_VOICE_CB_PLAY);
    HWND    hwndCBRec    = GetDlgItem(hDlg, IDC_VOICE_CB_REC);
    UINT    item, deviceID;

	GetVocPrefInfo(paiVoc, hDlg);

    if (gbVocSelectChanged == TRUE)
	{
		gbVocSelectChanged = FALSE;
        item = (UINT)ComboBox_GetCurSel(hwndCBPlay);

        if (item != CB_ERR)
		{
            deviceID = (UINT)ComboBox_GetItemData(hwndCBPlay, item);
        
		    if(deviceID != paiVoc->uPrefOut)             // Make sure device changed
			{
                if (SetVoiceOutID(deviceID, paiVoc->fPrefOnly))
                {
                    paiVoc->uPrefOut = deviceID;
                }
			}
		}

        item = (UINT)ComboBox_GetCurSel(hwndCBRec);

        if (item != CB_ERR)
		{
            deviceID = (UINT)ComboBox_GetItemData(hwndCBRec, item);

            if( deviceID != paiVoc->uPrefIn )            // Make sure device changed
			{
			    if (SetVoiceCapID(deviceID, paiVoc->fPrefOnly))
                {
                    paiVoc->uPrefIn = deviceID;
                }
			}
		}
	}

 
    if (gbVocCapPresent && gbVocPlayPresent) EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , TRUE);

    //  MIDI Devices are not remapped...
}



STATIC void VOICEOUTInit(HWND hDlg, PAUDIODLGINFO paiVoc)
{
    HWND        hwndCBPlay = GetDlgItem(hDlg, IDC_VOICE_CB_PLAY);
    UINT        device;
    TCHAR       szNoVoice[128];

    szNoVoice[0] = TEXT('\0');

	GetVocPrefInfo(paiVoc, hDlg);

    ComboBox_ResetContent(hwndCBPlay);
    gbVocPlayPresent = FALSE;

    if (paiVoc->cNumOutDevs == 0)
    {
        LoadString (ghInstance, IDS_NOAUDIOPLAY, szNoVoice, sizeof(szNoVoice)/sizeof(TCHAR));
        ComboBox_AddString(hwndCBPlay, szNoVoice);
        ComboBox_SetItemData(hwndCBPlay, 0, (LPARAM)-1);
        ComboBox_SetCurSel(hwndCBPlay, 0);
        EnableWindow( hwndCBPlay, FALSE );
        EnablePlayVoiceVolCtrls(hDlg, FALSE);
	}
    else
    {
        EnableWindow( hwndCBPlay, TRUE );

        for (device = 0; device < paiVoc->cNumOutDevs; device++)
        {
            WAVEOUTCAPS     woc;
            int newItem;

            woc.szPname[0]  = TEXT('\0');

            if (waveOutGetDevCaps(device, &woc, sizeof(woc)))
            {
                continue;
            }

            woc.szPname[sizeof(woc.szPname)/sizeof(TCHAR) - 1] = TEXT('\0');

	        newItem = ComboBox_AddString(hwndCBPlay, woc.szPname);

            if (newItem != CB_ERR && newItem != CB_ERRSPACE)
            {
                ComboBox_SetItemData(hwndCBPlay, newItem, (LPARAM)device);  

                if (device == paiVoc->uPrefOut)
                {
                    ComboBox_SetCurSel(hwndCBPlay, newItem);
                    SetVoiceOut(device, hDlg);
                }
            }
        }
    }
}

STATIC void VOICECAPInit(HWND hDlg, PAUDIODLGINFO paiVoc)
{
    HWND        hwndCBRec = GetDlgItem(hDlg, IDC_VOICE_CB_REC);
    UINT        device;
    TCHAR       szNoVoice[128];

    ComboBox_ResetContent(hwndCBRec);
    gbVocCapPresent = FALSE;

    if (paiVoc->cNumInDevs == 0)
    {
        LoadString (ghInstance, IDS_NOAUDIOREC, szNoVoice, sizeof(szNoVoice)/sizeof(TCHAR));
        ComboBox_AddString(hwndCBRec, szNoVoice);
        ComboBox_SetItemData(hwndCBRec, 0, (LPARAM)-1);
        ComboBox_SetCurSel(hwndCBRec, 0);
        EnableWindow( hwndCBRec, FALSE );
        EnableRecVoiceVolCtrls(hDlg, FALSE, FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , FALSE);
    }
    else
    {
        EnableWindow( hwndCBRec, TRUE );

        for (device = 0; device < paiVoc->cNumInDevs; device++)
        {
            WAVEINCAPS     wic;
            int newItem;

            wic.szPname[0]  = TEXT('\0');

            if (waveInGetDevCaps(device, &wic, sizeof(wic)))
            {
                continue;
            }

            wic.szPname[sizeof(wic.szPname)/sizeof(TCHAR) - 1] = TEXT('\0');

            newItem = ComboBox_AddString(hwndCBRec, wic.szPname);

            if (newItem != CB_ERR && newItem != CB_ERRSPACE)
            {
                ComboBox_SetItemData(hwndCBRec, newItem, (LPARAM)device);

                if (device == paiVoc->uPrefIn)
                {   
                    ComboBox_SetCurSel(hwndCBRec, newItem);
                    SetVoiceCap(device, hDlg);
                }  
            }
        }
    }
}



STATIC void VoiceDlgInit(HWND hDlg)
{
    PAUDIODLGINFO paiVoc = (PAUDIODLGINFO)LocalAlloc(LPTR, sizeof(AUDIODLGINFO));

	if (!paiVoc) return;
    
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)paiVoc);

    VOICEOUTInit(hDlg, paiVoc);
    VOICECAPInit(hDlg, paiVoc);
    if (gbVocCapPresent && gbVocPlayPresent) EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , TRUE);
}


const static DWORD aVoiceHelpIds[] = {  // Context Help IDs
    IDC_GROUPBOX_VOC_1,        IDH_COMM_GROUPBOX,
    IDC_VOICE_CB_PLAY,         IDH_VOICE_SPEAKERICON,
    IDC_LAUNCH_VOCVOL,         IDH_VOICE_LAUNCH_VOCVOL,
	IDC_PLAYBACK_ADVVOC,       IDH_VOICE_PLAYBACK_ADVVOC,
    IDC_ICON_VOC_1,            IDH_VOICE_SPEAKERICON,
    IDC_TEXT_32,               NO_HELP,
    IDC_TEXT_VOC_1,            IDH_VOICE_SPEAKERICON,
    IDC_TEXT_VOC_2,            IDH_VOICE_RECORDICON,
    IDC_GROUPBOX_VOC_2,        IDH_COMM_GROUPBOX,
    IDC_VOICE_CB_REC,          IDH_VOICE_RECORDICON,
    IDC_LAUNCH_CAPVOL,         IDH_VOICE_LAUNCH_CAPVOL,
	IDC_CAPTURE_ADVVOL,        IDH_VOICE_CAPTURE_ADVVOL,
    IDC_ICON_VOC_2,            IDH_VOICE_RECORDICON,
	IDC_ADVANCED_DIAG,         IDH_VOICE_ADVANCED_TEST,
    
    0, 0
};


void WinMMVoiceChange(HWND hDlg)
{
    PAUDIODLGINFO paiVoc = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    VOICEOUTInit(hDlg, paiVoc);
    VOICECAPInit(hDlg, paiVoc);
    if (gbVocCapPresent && gbVocPlayPresent) EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , TRUE);
}



LRESULT CALLBACK VoiceTabProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    if (iMsg == giVocChange)
    {
        WinMMVoiceChange(ghVocDlg);
    }
        
    return CallWindowProc(gfnVocPSProc,hwnd,iMsg,wParam,lParam);
}


void InitVoiceChange(HWND hDlg)
{
    gfnVocPSProc = (WNDPROC) SetWindowLongPtr(GetParent(hDlg),GWLP_WNDPROC,(LPARAM)VoiceTabProc);  
    giVocChange = RegisterWindowMessage(TEXT("winmm_devicechange"));
}

void UninitVoiceChange(HWND hDlg)
{
    SetWindowLongPtr(GetParent(hDlg),GWLP_WNDPROC,(LPARAM)gfnVocPSProc);  
}




BOOL CALLBACK VoiceDlg(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam)
{
    NMHDR FAR   *lpnm;
    PAUDIODLGINFO paiVoc;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                break;
            }
        }
        break;

        case WM_INITDIALOG:
        {
            ghVocDlg = hDlg;
			gfVoiceTab  = TRUE;

            InitVoiceChange(hDlg);

            if (!gfVocLoadedACM)
            {
                if (LoadACM())
                {
                    gfVocLoadedACM = TRUE;
                }
                else
                {
                    DPF("****Load ACM failed**\r\n");
                    ASSERT(FALSE);
                    ErrorBox(hDlg, IDS_CANTLOADACM, NULL);
                    ExitThread(0);
                }
            }

            VoiceDlgInit(hDlg);
        }
        break;

        case WM_DESTROY:
        {
            UninitVoiceChange(hDlg);

            paiVoc = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

            LocalFree((HLOCAL)paiVoc);

            if (gfVocLoadedACM)
            {
                if (!FreeACM())
                {
                    DPF("****Free ACM failed**\r\n");
                    ASSERT(FALSE);
                }

                gfVocLoadedACM = FALSE;
            }
        }
        break;

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aVoiceHelpIds);
            return TRUE;
        }
        break;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aVoiceHelpIds);
            return TRUE;
        }
        break;

        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoVoiceCommand);
        }
        break;

        default:
        {
        }
        break;
    }
    return FALSE;
}

void ErrorVocMsgBox(HWND hDlg, UINT uTitle, UINT uMessage)
{
    TCHAR szMsg[MAXSTR];
    TCHAR szTitle[MAXSTR];

    LoadString(ghInstance, uTitle, szTitle, sizeof(szTitle)/sizeof(TCHAR));
    LoadString(ghInstance, uMessage, szMsg, sizeof(szMsg)/sizeof(TCHAR));
    MessageBox(hDlg, szMsg,szTitle,MB_OK);
}


void LaunchVocPlaybackVolume(HWND hDlg)
{
    HWND    hwndCBPlay  = GetDlgItem(hDlg, IDC_VOICE_CB_PLAY);
    UINT    item;

    item = (UINT)ComboBox_GetCurSel(hwndCBPlay);

    if (item != CB_ERR)
    {
        TCHAR szCmd[MAXSTR];
        UINT uDeviceID;
        MMRESULT mmr;

        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        uDeviceID = (UINT)ComboBox_GetItemData(hwndCBPlay, item);
        mmr = mixerGetID(HMIXEROBJ_INDEX(uDeviceID), &uDeviceID, MIXER_OBJECTF_WAVEOUT);

        if (mmr == MMSYSERR_NOERROR)
        {
            wsprintf(szCmd,TEXT("sndvol32.exe -D %d"),uDeviceID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE,IDS_ERROR_NOVOCVOL);
            }
        }
        else
        {
            ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE,IDS_ERROR_NOMIXER);
        }
    }
}


void LaunchCaptureVolume(HWND hDlg)
{
    HWND    hwndCBRec  = GetDlgItem(hDlg, IDC_VOICE_CB_REC);
    UINT    item;

    item = (UINT)ComboBox_GetCurSel(hwndCBRec);

    if (item != CB_ERR)
    {
        TCHAR szCmd[MAXSTR];
        UINT uDeviceID;
        MMRESULT mmr;
        STARTUPINFO si;
        PROCESS_INFORMATION pi;

        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;
        si.dwFlags = STARTF_USESHOWWINDOW;

        uDeviceID = (UINT)ComboBox_GetItemData(hwndCBRec, item);

        mmr = mixerGetID(HMIXEROBJ_INDEX(uDeviceID), &uDeviceID, MIXER_OBJECTF_WAVEIN);


        if (mmr == MMSYSERR_NOERROR)
        {
            wsprintf(szCmd,TEXT("sndvol32.exe -R -D %d"),uDeviceID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE,IDS_ERROR_NOVOCVOL);
            }
        }
        else
        {
            ErrorVocMsgBox(hDlg,IDS_ERROR_TITLE,IDS_ERROR_NOMIXER);
        }
    }
}

void LaunchVoiceTest(HWND hDlg)
{
	HRESULT hr;
    GUID guidCapture;
    GUID guidPlayback;
    UINT    item;

    HWND    hwndVocPlay  = GetDlgItem(hDlg, IDC_VOICE_CB_PLAY);
    HWND    hwndVocCap  = GetDlgItem(hDlg, IDC_VOICE_CB_REC);
    LPDIRECTPLAYVOICESETUP lpdpvs;

	item = (UINT)ComboBox_GetCurSel(hwndVocPlay);
    if (item != CB_ERR)
    {
        guidPlayback.Data1 = item;
    }
    else
    {
        ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE,IDS_ERROR_NOMIXER);
        return;
	}

	item = (UINT)ComboBox_GetCurSel(hwndVocCap);
    if (item != CB_ERR)
    {
        guidCapture.Data1 = item;
    }
    else
    {
        ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE,IDS_ERROR_NOMIXER);
        return;
	}

	if (FAILED(CoInitialize(NULL))) return;

	if (FAILED(CoCreateInstance(&CLSID_DirectPlayVoiceTest, 0, CLSCTX_ALL, &IID_IDirectPlayVoiceSetup, (void**)&lpdpvs)))
	{
		CoUninitialize();
		ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE, IDS_ERROR_NOVOCDIAG); 
		return;
	}

    hr = IDirectPlayVoiceSetup_CheckAudioSetup(lpdpvs, &guidPlayback, &guidCapture, hDlg, DVFLAGS_WAVEIDS );

    if (FAILED(hr) && hr != DVERR_COMMANDALREADYPENDING && hr != DVERR_SOUNDINITFAILURE && hr != DVERR_USERCANCEL)
	{
        ErrorVocMsgBox(hDlg,IDS_ERROR_VOICE_TITLE, IDS_ERROR_NOVOCDIAG);
    }

	IDirectPlayVoiceSetup_Release(lpdpvs);
	CoUninitialize();

}


BOOL PASCAL DoVoiceCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    PAUDIODLGINFO paiVoc = (PAUDIODLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!gfVocLoadedACM)
    {
        return FALSE;
    }

    switch (id)
    {
        case ID_APPLY:
        {            
			SetVocPrefInfo(paiVoc, hDlg);
        }
        break;

        case IDC_VOICE_CB_PLAY:
        case IDC_VOICE_CB_REC:
        {
            switch (codeNotify)
            {
                case CBN_SELCHANGE:
                {
                    PropSheet_Changed(GetParent(hDlg),hDlg);

                    if ((id ==  IDC_VOICE_CB_PLAY) || (id ==  IDC_VOICE_CB_REC))
                    {
                        int iIndex;

                        iIndex = ComboBox_GetCurSel(hwndCtl);

                        if (iIndex != CB_ERR)
                        {
							gbVocSelectChanged = TRUE;
                            if (id ==  IDC_VOICE_CB_REC)
                                SetVoiceCap(iIndex, hDlg);
                            if (id ==  IDC_VOICE_CB_PLAY)
                                SetVoiceOut(iIndex, hDlg);
                            if (gbVocCapPresent && gbVocPlayPresent) 
                                EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , TRUE);
                            else
                                EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_DIAG) , FALSE);
                        }
                    }
                }
                break;
            }
        }
        break;

        
        case IDC_ADVANCED_DIAG:
        {
            LaunchVoiceTest(hDlg);
        }
        break;

        case IDC_LAUNCH_VOCVOL:
        {
            LaunchVocPlaybackVolume(hDlg);
        }
        break;

        case IDC_LAUNCH_CAPVOL:
        {
            LaunchCaptureVolume(hDlg);
        }
        break;

        case IDC_PLAYBACK_ADVVOC:
        {
            HWND    hwndVocPlay  = GetDlgItem(hDlg, IDC_VOICE_CB_PLAY);
            DWORD   dwDeviceID;
            UINT    u;
            TCHAR   szPrefOut[MAXSTR];

            u = (UINT)ComboBox_GetCurSel(hwndVocPlay);

            if (u != CB_ERR)
            {
                ComboBox_GetLBText(hwndVocPlay, u, (LPARAM)(LPVOID)szPrefOut);
                dwDeviceID = (DWORD)ComboBox_GetItemData(hwndVocPlay, u);
                AdvancedAudio(hDlg,  ghInstance, gszWindowsHlp, dwDeviceID, szPrefOut, FALSE);
            }
        }
        break;

        case IDC_CAPTURE_ADVVOL:
        {
            HWND    hwndVocCap  = GetDlgItem(hDlg, IDC_VOICE_CB_REC);
            DWORD   dwDeviceID;
            UINT    u;
            TCHAR   szPrefIn[MAXSTR];

            u = (UINT)ComboBox_GetCurSel(hwndVocCap);

            if (u != CB_ERR)
            {
                ComboBox_GetLBText(hwndVocCap, u, (LPARAM)(LPVOID)szPrefIn);
                dwDeviceID = (DWORD)ComboBox_GetItemData(hwndVocCap, u);
                AdvancedAudio(hDlg,  ghInstance, gszWindowsHlp, dwDeviceID, szPrefIn, TRUE);
            }
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\video.c ===
/*
 ***************************************************************
 *  video.c
 *
 *  Copyright (C) Microsoft, 1990, All Rights Reserved.
 *
 *  Displays the Simple media properties
 *
 *  History:
 *
 *  July 1994 -by- VijR (Created)
 *
 ***************************************************************
 */

#include "mmcpl.h"
#include <windowsx.h>
#ifdef DEBUG
#undef DEBUG
#include <mmsystem.h>
#define DEBUG
#else
#include <mmsystem.h>
#endif
#include <commctrl.h>
#include <prsht.h>
#include "utils.h"
#include "medhelp.h"

#include "profile.key" // For ROOTKEY and KEYNAME etc

#define Assert(f)

/*
 ***************************************************************
 * Defines
 ***************************************************************
 */
//
// !!! These actually live in mciavi\graphic.h
// !!! If MCIAVI changes these, we're hosed!
//
#define MCIAVIO_ZOOMBY2             0x00000100
#define MCIAVIO_USEVGABYDEFAULT     0x00000200
#define MCIAVIO_1QSCREENSIZE        0x00010000
#define MCIAVIO_2QSCREENSIZE        0x00020000
#define MCIAVIO_3QSCREENSIZE        0x00040000
#define MCIAVIO_MAXWINDOWSIZE       0x00080000
#define MCIAVIO_DEFWINDOWSIZE       0x00000000
#define MCIAVIO_WINDOWSIZEMASK      0x000f0000

// This bit is set in dwOptions if f16BitCompat, but doesn't get written back
// directly into the registry's version of that DWORD.
//
#define MCIAVIO_F16BITCOMPAT        0x00000001

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
static SZCODE aszMCIAVIOpt[] =    TEXT("Software\\Microsoft\\Multimedia\\Video For Windows\\MCIAVI");
static SZCODE aszDefVideoOpt[] = TEXT("DefaultOptions");
static SZCODE aszReject[] = TEXT("RejectWOWOpenCalls");
static SZCODE aszRejectSection[] = TEXT("MCIAVI");

HBITMAP g_hbmMonitor = NULL;    // monitor bitmap (original)
HBITMAP g_hbmScrSample = NULL;  // bitmap used for IDC_SCREENSAMPLE
HBITMAP g_hbmDefault = NULL;
HDC g_hdcMem = NULL;

/*
 ***************************************************************
 * Prototypes
 ***************************************************************
 */
BOOL PASCAL DoVideoCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);

/*
 ***************************************************************
 ***************************************************************
 */

// mmGetProfileInt/mmWriteProfileInt snitched from MCIAVI32
UINT
mmGetProfileInt(LPCTSTR appname, LPCTSTR valuename, INT uDefault)
{
    TCHAR achName[MAX_PATH];
    HKEY hkey;
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;

    lstrcpy(achName, KEYNAME);
    if (appname)
    {
        if ((lstrlen(achName)+lstrlen(appname))<ARRAYSIZE(achName))
        {
            lstrcat(achName, appname);
            if (RegOpenKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) 
            {

                cbData = sizeof(dwData);
                if (RegQueryValueEx(
                    hkey,
                    (LPTSTR)valuename,
                    NULL,
                    &dwType,
                    (PBYTE) &dwData,
                    &cbData) == ERROR_SUCCESS)
                {
                    if (dwType == REG_DWORD) 
                    {
                        value = (INT)dwData;
                    }
                }

                RegCloseKey(hkey);
            }
        }
    }

    return((UINT)value);
}


/*
 * write a UINT to the profile, if it is not the
 * same as the default or the value already there
 */
VOID
mmWriteProfileInt(LPCTSTR appname, LPCTSTR valuename, INT Value)
{
    // If we would write the same as already there... return.
    if (mmGetProfileInt(appname, valuename, !Value) == (UINT)Value) {
        return;
    }

    {
        TCHAR achName[MAX_PATH];
        HKEY hkey = NULL;

        lstrcpy(achName, KEYNAME);
        lstrcat(achName, appname);
        if ((RegCreateKey (ROOTKEY, achName, &hkey) == ERROR_SUCCESS) && hkey)
        {
            RegSetValueEx(
                hkey,
                valuename,
                0,
                REG_DWORD,
                (PBYTE) &Value,
                sizeof(Value)
            );

            RegCloseKey(hkey);
        }
    }

}

/*
 ***************************************************************
 ***************************************************************
 */

STATIC void WriteVideoOptions(DWORD dwOpt)
{
    HKEY hkVideoOpt;
    BOOL f16BitCompat;

    f16BitCompat = (dwOpt & MCIAVIO_F16BITCOMPAT) ? TRUE : FALSE;
    dwOpt &= ~MCIAVIO_F16BITCOMPAT;

    if(RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)aszMCIAVIOpt, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hkVideoOpt, NULL ))
        return;
    RegSetValueEx( hkVideoOpt, (LPTSTR)aszDefVideoOpt, 0, REG_DWORD,(LPBYTE)&dwOpt, sizeof(DWORD) );
    mmWriteProfileInt (aszRejectSection, aszReject, (int)f16BitCompat);

	RegCloseKey(hkVideoOpt);
}

STATIC DWORD ReadVideoOptions(void)
{
    HKEY hkVideoOpt;
    DWORD dwType;
    DWORD dwOpt;
    DWORD cbSize;

    if(RegCreateKeyEx( HKEY_CURRENT_USER, (LPTSTR)aszMCIAVIOpt, 0, NULL, 0,KEY_WRITE | KEY_READ, NULL, &hkVideoOpt, NULL ))
        return 0 ;

    cbSize = sizeof(DWORD);
    if (RegQueryValueEx( hkVideoOpt,(LPTSTR)aszDefVideoOpt,NULL,&dwType,(LPBYTE)&dwOpt,&cbSize ))
    {
        dwOpt = 0;
        RegSetValueEx( hkVideoOpt, (LPTSTR)aszDefVideoOpt, 0, REG_DWORD,(LPBYTE)&dwOpt, sizeof(DWORD) );
    }

    if (mmGetProfileInt (aszRejectSection, aszReject, 0))
    {
        dwOpt |= MCIAVIO_F16BITCOMPAT;
    }

	RegCloseKey(hkVideoOpt);

    return dwOpt;
}

STATIC void FillWindowSizeCB(DWORD dwOptions, HWND hCBWinSize)
{
    TCHAR sz1QScreenSize[64];
    TCHAR sz2QScreenSize[64];
    TCHAR sz3QScreenSize[64];
    TCHAR szMaxSize[64];
    TCHAR szOriginalSize[64];
    TCHAR szZoomedSize[64];
    int iIndex;
    LPTSTR  lpszCurDefSize;

    LoadString(ghInstance, IDS_NORMALSIZE, szOriginalSize, sizeof(szOriginalSize)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_ZOOMEDSIZE, szZoomedSize, sizeof(szZoomedSize)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_1QSCREENSIZE, sz1QScreenSize, sizeof(sz1QScreenSize)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_2QSCREENSIZE, sz2QScreenSize, sizeof(sz2QScreenSize)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_3QSCREENSIZE, sz3QScreenSize, sizeof(sz3QScreenSize)/sizeof(TCHAR));
    LoadString(ghInstance, IDS_VIDEOMAXIMIZED, szMaxSize, sizeof(szMaxSize)/sizeof(TCHAR));

    iIndex = ComboBox_AddString(hCBWinSize, szOriginalSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_DEFWINDOWSIZE);
    iIndex = ComboBox_AddString(hCBWinSize, szZoomedSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_ZOOMBY2);
    iIndex = ComboBox_AddString(hCBWinSize, sz1QScreenSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_1QSCREENSIZE);
    iIndex = ComboBox_AddString(hCBWinSize, sz2QScreenSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_2QSCREENSIZE);
    iIndex = ComboBox_AddString(hCBWinSize, sz3QScreenSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_3QSCREENSIZE);
    iIndex = ComboBox_AddString(hCBWinSize, szMaxSize);
    ComboBox_SetItemData(hCBWinSize, iIndex, (LPARAM)MCIAVIO_MAXWINDOWSIZE);

    switch(dwOptions & MCIAVIO_WINDOWSIZEMASK)
    {
        case MCIAVIO_DEFWINDOWSIZE:
            if (dwOptions & MCIAVIO_ZOOMBY2)
                lpszCurDefSize = szZoomedSize;
            else
                lpszCurDefSize = szOriginalSize;
            break;
        case MCIAVIO_1QSCREENSIZE:
            lpszCurDefSize =  sz1QScreenSize;
            break;
        case MCIAVIO_2QSCREENSIZE:
            lpszCurDefSize =  sz2QScreenSize;
            break;
        case MCIAVIO_3QSCREENSIZE:
            lpszCurDefSize =  sz3QScreenSize;
            break;
        case MCIAVIO_MAXWINDOWSIZE:
            lpszCurDefSize =  szMaxSize;
            break;
    }

    //
    // We should select string that matches exactly.
    //
    iIndex = ComboBox_FindStringExact(hCBWinSize, 0, lpszCurDefSize);
    ComboBox_SetCurSel(hCBWinSize, iIndex);

}

/*---------------------------------------------------------
**
**---------------------------------------------------------*/
// information about the monitor bitmap
// x, y, dx, dy define the size of the "screen" part of the bitmap
// the RGB is the color of the screen's desktop
// these numbers are VERY hard-coded to a monitor bitmap
#define MON_X    16
#define MON_Y    17
#define MON_DX    152
#define MON_DY    112

#define MON_IMAGE_X (MON_X + 46)
#define MON_IMAGE_Y (MON_Y + 33)
#define MON_IMAGE_DX 59
#define MON_IMAGE_DY 44

#define MON_TITLE 10
#define MON_BORDER 2

#define MON_TRAY 8


STATIC HBITMAP FAR LoadMonitorBitmap( BOOL bFillDesktop )
{
    HBITMAP hbm;

    hbm = (HBITMAP) LoadImage(ghInstance,MAKEINTATOM(IDB_MONITOR), IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);

    Assert(hbm);

    return hbm;
}

/*------------------------pixel resolution---------------------------
**
** show the sample screen with proper sizing
*/
STATIC void NEAR PASCAL ShowSampleScreen(HWND hDlg, int iMCIWindowSize)
{
    HBITMAP hbmOld;
    HBRUSH hbr;
    HDC hdcMem2;
    SIZE    dSrc = {MON_IMAGE_DX, MON_IMAGE_DY};
    POINT   ptSrc = {MON_IMAGE_X, MON_IMAGE_Y};
    SIZE    dDst;
    POINT   ptDst;
    RECT    rcImage = {MON_IMAGE_X, MON_IMAGE_Y, MON_IMAGE_X + MON_IMAGE_DX, MON_IMAGE_Y + MON_IMAGE_DY};

    if (!g_hbmMonitor || !g_hbmScrSample)
        return;

    switch(iMCIWindowSize)
    {
        case MCIAVIO_DEFWINDOWSIZE:
            dDst = dSrc;
            ptDst = ptSrc;
            break;

        case MCIAVIO_ZOOMBY2:
            dDst.cx = 2 * dSrc.cx;
            dDst.cy = 2 * dSrc.cy;
            ptDst.x = ptSrc.x - (int)(dSrc.cx/2);
            ptDst.y = ptSrc.y - (int)(dSrc.cy/2);
            break;

        case MCIAVIO_MAXWINDOWSIZE:
            ptDst.x = MON_X;
            ptDst.y = MON_Y;
            dDst.cx = MON_DX;
            dDst.cy = MON_DY - MON_TRAY;
            break;

        case MCIAVIO_1QSCREENSIZE:
            dDst.cx = MulDiv(MON_DX, 1, 4);
            dDst.cy = MulDiv(MON_DY, 1, 4);
            ptDst.x = MON_X + MulDiv((MON_DX - dDst.cx), 1 , 2);
            ptDst.y = MON_Y + MulDiv((MON_DY - dDst.cy - MON_TRAY), 1 , 2);
            break;

        case MCIAVIO_2QSCREENSIZE:
            dDst.cx = MulDiv(MON_DX, 1, 2);
            dDst.cy = MulDiv(MON_DY, 1, 2);
            ptDst.x = MON_X + MulDiv((MON_DX - dDst.cx), 1 , 2);
            ptDst.y = MON_Y + MulDiv((MON_DY - dDst.cy - MON_TRAY), 1 , 2);
            break;

        case MCIAVIO_3QSCREENSIZE:
            dDst.cx = MulDiv(MON_DX, 3, 4);
            dDst.cy = MulDiv(MON_DY, 3, 4);
            ptDst.x = MON_X + MulDiv((MON_DX - dDst.cx), 1 , 2);
            ptDst.y = MON_Y + MulDiv((MON_DY - dDst.cy - MON_TRAY), 1 , 2);
            break;

        case MCIAVIO_USEVGABYDEFAULT:
            dDst.cx = MON_DX;
            dDst.cy = MON_DY;
            ptDst.x = MON_X;
            ptDst.y = MON_Y;


            dSrc.cx = MON_IMAGE_DX - (2 * MON_BORDER);
            dSrc.cy = MON_IMAGE_DY - MON_TITLE - MON_BORDER;
            ptSrc.x = MON_IMAGE_X + MON_BORDER;
            ptSrc.y = MON_IMAGE_Y + MON_TITLE + MON_BORDER;
            break;

    }

    // set up a work area to play in
    hdcMem2 = CreateCompatibleDC(g_hdcMem);
    if (!hdcMem2)
        return;
    SelectObject(hdcMem2, g_hbmScrSample);
    hbmOld = SelectObject(g_hdcMem, g_hbmMonitor);

    //copy the whole bmp first and then start stretching
    BitBlt(hdcMem2, MON_X, MON_Y, MON_DX, MON_DY, g_hdcMem, MON_X, MON_Y, SRCCOPY);

    //Wipe out the existing Image
    hbr =   CreateSolidBrush( GetPixel( g_hdcMem, MON_X + 1, MON_Y + 1 ) );

	if (!hbr) 
	{
		DeleteObject( hdcMem2 );
		return;
	}
	
	FillRect(hdcMem2, &rcImage, hbr);
	DeleteObject( hbr );

    // stretch the image to reflect the new size
    SetStretchBltMode( hdcMem2, COLORONCOLOR );

    StretchBlt( hdcMem2, ptDst.x, ptDst.y, dDst.cx, dDst.cy,
        g_hdcMem, ptSrc.x, ptSrc.y, dSrc.cx, dSrc.cy, SRCCOPY );

    SelectObject( hdcMem2, g_hbmDefault );
    DeleteObject( hdcMem2 );
    SelectObject( g_hdcMem, hbmOld );
    InvalidateRect(GetDlgItem(hDlg, IDC_SCREENSAMPLE), NULL, FALSE);
}


STATIC void DoMonitorBmp(HWND hDlg)
{
    HDC hdc = GetDC(NULL);
    HBITMAP hbm;

    g_hdcMem = CreateCompatibleDC(hdc);
    ReleaseDC(NULL, hdc);

    if (!g_hdcMem)
        return;

    hbm = CreateBitmap(1,1,1,1,NULL);

	if (!hbm) return;

    g_hbmDefault = SelectObject(g_hdcMem, hbm);
    SelectObject(g_hdcMem, g_hbmDefault);
    DeleteObject(hbm);

    // set up bitmaps for sample screen
    g_hbmScrSample = LoadMonitorBitmap( TRUE ); // let them do the desktop
    SendDlgItemMessage(hDlg, IDC_SCREENSAMPLE, STM_SETIMAGE, IMAGE_BITMAP, (DWORD_PTR)g_hbmScrSample);

    // get a base copy of the bitmap for when the "internals" change
    g_hbmMonitor = LoadMonitorBitmap( FALSE ); // we'll do the desktop
}



const static DWORD aAdvVideoDlgHelpIds[] = {  // Context Help IDs
    (DWORD)IDC_STATIC,         IDH_VIDEO_ADVANCED_COMPAT,
    ID_ADVVIDEO_COMPAT,        IDH_VIDEO_ADVANCED_COMPAT,

    0, 0
};

INT_PTR AdvancedVideoDlgProc (HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL *pfCompat = NULL;

    switch (wMsg)
    {
        case WM_INITDIALOG:
        {
            if ((pfCompat = (BOOL *)lParam) == NULL)
                return -1;

            CheckDlgButton (hDlg, ID_ADVVIDEO_COMPAT, (*pfCompat));
            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    *pfCompat = IsDlgButtonChecked (hDlg, ID_ADVVIDEO_COMPAT);
                    // fall through

                case IDCANCEL:
                    EndDialog (hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                    break;
            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND)wParam, NULL, HELP_CONTEXTMENU,
                     (UINT_PTR)aAdvVideoDlgHelpIds);
            return TRUE;
        }

        case WM_HELP:
        {
            WinHelp (((LPHELPINFO)lParam)->hItemHandle, NULL,
                     HELP_WM_HELP, (UINT_PTR)aAdvVideoDlgHelpIds);
            return TRUE;
        }
    }

    return FALSE;
}


const static DWORD aVideoDlgHelpIds[] = {  // Context Help IDs
    IDC_GROUPBOX,              IDH_COMM_GROUPBOX,
    IDC_SCREENSAMPLE,          IDH_VIDEO_GRAPHIC,
    IDC_VIDEO_FULLSCREEN,      IDH_VIDEO_FULL_SCREEN,
    IDC_VIDEO_INWINDOW,        IDH_VIDEO_FIXED_WINDOW,
    IDC_VIDEO_CB_SIZE,         IDH_VIDEO_FIXED_WINDOW,
    ID_VIDEO_ADVANCED,         IDH_VIDEO_ADVANCED_BUTTON,

    0, 0
};

BOOL CALLBACK VideoDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR   *lpnm;

    switch (uMsg)
    {
        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hDlg, IDOK, 0, 0, SendMessage);
                    break;

                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hDlg, ID_APPLY, 0, 0, SendMessage);
                    break;

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hDlg, ID_INIT, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hDlg, IDCANCEL, 0, 0, SendMessage);
                    break;
            }
            break;

        case WM_INITDIALOG:
        {
            DWORD dwOptions;

            dwOptions = ReadVideoOptions();
            FillWindowSizeCB(dwOptions, GetDlgItem(hDlg, IDC_VIDEO_CB_SIZE));
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)dwOptions);
            DoMonitorBmp(hDlg);
            if (IsFlagSet(dwOptions, MCIAVIO_USEVGABYDEFAULT))
            {
                CheckRadioButton(hDlg, IDC_VIDEO_INWINDOW, IDC_VIDEO_FULLSCREEN, IDC_VIDEO_FULLSCREEN);
                EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CB_SIZE), FALSE);
                ShowSampleScreen(hDlg, MCIAVIO_USEVGABYDEFAULT);
                break;
            }
            else
            {
                CheckRadioButton(hDlg, IDC_VIDEO_INWINDOW, IDC_VIDEO_FULLSCREEN, IDC_VIDEO_INWINDOW);
                EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CB_SIZE), TRUE);
            }
            ShowSampleScreen(hDlg, dwOptions & (MCIAVIO_WINDOWSIZEMASK|MCIAVIO_ZOOMBY2));
            break;
        }
        case WM_DESTROY:
            if (g_hbmScrSample)
            {
                DeleteObject(g_hbmScrSample);
                g_hbmScrSample = NULL;
            }
            if (g_hbmMonitor)
            {
                DeleteObject(g_hbmMonitor);
                g_hbmMonitor = NULL;
            }
            if (g_hbmDefault)
            {
                DeleteObject(g_hbmDefault);
                g_hbmDefault = NULL;
            }
            if (g_hdcMem)
            {
                DeleteDC(g_hdcMem);
                g_hdcMem = NULL;
            }

            break;

        case WM_DROPFILES:
            break;

        case WM_CONTEXTMENU:
            WinHelp ((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (UINT_PTR) (LPTSTR) aVideoDlgHelpIds);
            return TRUE;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, NULL, HELP_WM_HELP,
                    (UINT_PTR) (LPTSTR) aVideoDlgHelpIds);
            return TRUE;
        }

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, DoVideoCommand);
            break;

    }
    return FALSE;
}

BOOL PASCAL DoVideoCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {

    case ID_APPLY:
    {
        int iIndex;
        HWND hCBWinSize = GetDlgItem(hDlg,IDC_VIDEO_CB_SIZE);
        DWORD dwOldOpt;
        DWORD dwNewOpt;

        dwOldOpt = (DWORD)GetWindowLongPtr(hDlg, DWLP_USER);
        if(Button_GetCheck(GetDlgItem(hDlg, IDC_VIDEO_FULLSCREEN)))
        {
            dwNewOpt = MCIAVIO_USEVGABYDEFAULT;
        }
        else
        {
            iIndex = ComboBox_GetCurSel(hCBWinSize);
            dwNewOpt = (DWORD)ComboBox_GetItemData(hCBWinSize, iIndex);
        }

        ClearFlag(dwOldOpt,MCIAVIO_WINDOWSIZEMASK|MCIAVIO_USEVGABYDEFAULT|MCIAVIO_ZOOMBY2);
        SetFlag(dwOldOpt, dwNewOpt);
        WriteVideoOptions(dwOldOpt);
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)dwOldOpt);
        return TRUE;
    }

    case IDOK:
        break;

    case IDCANCEL:
        break;

    case IDC_VIDEO_FULLSCREEN:
        EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CB_SIZE), FALSE);
        PropSheet_Changed(GetParent(hDlg),hDlg);
        ShowSampleScreen(hDlg, MCIAVIO_USEVGABYDEFAULT);
        break;

    case IDC_VIDEO_INWINDOW:
    {
        HWND hwndCB = GetDlgItem(hDlg,IDC_VIDEO_CB_SIZE);
        int iIndex = ComboBox_GetCurSel(hwndCB);
        int iOpt  = (int)ComboBox_GetItemData(hwndCB, iIndex);

        EnableWindow(GetDlgItem(hDlg, IDC_VIDEO_CB_SIZE), TRUE);
        PropSheet_Changed(GetParent(hDlg),hDlg);
        ShowSampleScreen(hDlg, iOpt);
        break;
    }

    case IDC_VIDEO_CB_SIZE:
        switch (codeNotify)
        {
            case CBN_SELCHANGE:
            {

                int iIndex = ComboBox_GetCurSel(hwndCtl);
                int iOpt  = (int)ComboBox_GetItemData(hwndCtl, iIndex);

                PropSheet_Changed(GetParent(hDlg),hDlg);
                ShowSampleScreen(hDlg, iOpt);
                break;
            }
            default:
                break;
        }
        break;

    case ID_VIDEO_ADVANCED:
    {
        INT_PTR  f16BitCompat;
        f16BitCompat = (GetWindowLongPtr(hDlg, DWLP_USER) & MCIAVIO_F16BITCOMPAT);

        if (DialogBoxParam (ghInstance,
                            MAKEINTRESOURCE(ADVVIDEODLG),
                            hDlg,
                            AdvancedVideoDlgProc,
                            (LPARAM)&f16BitCompat) == IDOK)
        {
            SetWindowLongPtr (hDlg, DWLP_USER,
                           GetWindowLongPtr (hDlg, DWLP_USER)
                               & (~MCIAVIO_F16BITCOMPAT)
                               | ((f16BitCompat) ? (MCIAVIO_F16BITCOMPAT) : 0));
            PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        break;
    }

    case ID_INIT:
        break;

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\utils.c ===
#include "mmcpl.h"
#include "utils.h"

/*
 ***************************************************************
 *  Typedefs
 ***************************************************************
 */
typedef struct _DYNLOAD_INFO
{
    LPCTSTR  pszLib;
    HMODULE hLib;
    short   iRefCnt;
}
DYNLOAD_INFO, *PDYNLOAD_INFO;

/*
 ***************************************************************
 * File Globals
 ***************************************************************
 */
static SZCODE aszMSACM32[] = TEXT("MSACM32.DLL");
static SZCODE aszAVIFIL32[] = TEXT("AVIFIL32.DLL");
static SZCODE aszMSVFW32[] = TEXT("MSVFW32.DLL");
static SZCODE aszVERSION[] = TEXT("VERSION.DLL");


DYNLOAD_INFO DynLoadInfo[] =
{
    aszMSACM32,   0, 0,
    aszAVIFIL32,  0, 0,
    aszMSVFW32,   0, 0,
    aszVERSION,   0, 0,
    NULL,         0, 0
};

static const char cszTacmFormatDetailsW[] = "acmFormatDetailsW";
static const char cszTacmFormatTagDetailsW[] = "acmFormatTagDetailsW";
static const char cszTacmDriverDetailsW[] = "acmDriverDetailsW";
static const char cszTacmDriverMessage[]  = "acmDriverMessage";
static const char cszTacmDriverAddW[]     = "acmDriverAddW";
static const char cszTacmDriverEnum[]     = "acmDriverEnum";
static const char cszTacmDriverPriority[] = "acmDriverPriority";
static const char cszTacmDriverRemove[]   = "acmDriverRemove";
static const char cszTacmMetrics[]        = "acmMetrics";
static const char cszTacmFormatChooseW[]  = "acmFormatChooseW";

PROC_INFO ACMProcs[] =
{
    cszTacmFormatDetailsW,    0,
    cszTacmFormatTagDetailsW, 0,
    cszTacmDriverDetailsW,    0,
    cszTacmDriverMessage,     0,
    cszTacmDriverAddW,        0,
    cszTacmDriverEnum,        0,
    cszTacmDriverPriority,    0,
    cszTacmDriverRemove,      0,
    cszTacmMetrics,           0,
    cszTacmFormatChooseW,     0,

    NULL, 0
};

static const char cszICClose[]       = "ICClose";
static const char cszICGetInfo[]     = "ICGetInfo";
static const char cszICLocate[]      = "ICLocate";
static const char cszMCIWndCreateW[] = "MCIWndCreateW";

PROC_INFO VFWProcs[] =
{
    cszICClose,             0,
    cszICGetInfo,           0,
    cszICLocate,            0,
    cszMCIWndCreateW,       0,

    NULL, 0
};

static const char cszAVIFileRelease[]         = "AVIFileRelease";
static const char cszAVIStreamRelease[]       = "AVIStreamRelease";
static const char cszAVIStreamSampleToTime[]  = "AVIStreamSampleToTime";
static const char cszAVIStreamStart[]         = "AVIStreamStart";
static const char cszAVIStreamLength[]        = "AVIStreamLength";
static const char cszAVIStreamReadFormat[]    = "AVIStreamReadFormat";
static const char cszAVIStreamInfoW[]         = "AVIStreamInfoW";
static const char cszAVIFileGetStream[]       = "AVIFileGetStream";
static const char cszAVIFileOpenW[]           = "AVIFileOpenW";
static const char cszAVIFileInit[]            = "AVIFileInit";
static const char cszAVIFileExit[]            = "AVIFileExit";


PROC_INFO AVIProcs[] =
{
    cszAVIFileRelease,          0,
    cszAVIStreamRelease,        0,
    cszAVIStreamSampleToTime,   0,
    cszAVIStreamStart,          0,
    cszAVIStreamLength,         0,
    cszAVIStreamReadFormat,     0,
    cszAVIStreamInfoW,          0,
    cszAVIFileGetStream,        0,
    cszAVIFileOpenW,            0,
    cszAVIFileInit,             0,
    cszAVIFileExit,             0,

    NULL, 0
};

static const char cszVerQueryValueW[]          = "VerQueryValueW";
static const char cszGetFileVersionInfoW[]     = "GetFileVersionInfoW";
static const char cszGetFileVersionInfoSizeW[] = "GetFileVersionInfoSizeW";

PROC_INFO VERSIONProcs[] =
{
    cszVerQueryValueW,          0,
    cszGetFileVersionInfoW,     0,
    cszGetFileVersionInfoSizeW, 0,

    NULL, 0
};

/*
 ***************************************************************
 ***************************************************************
 */
STATIC BOOL LoadLibraryAndProcs(LPCTSTR pLibrary, PPROC_INFO pProcInfo)
{
    HMODULE    hLibrary;
    PPROC_INFO p;
	PDYNLOAD_INFO pLib;
	BOOL	fPrevLoaded = FALSE;

#ifdef DEBUG_BUILT_LINKED
	return TRUE;
#endif

	if (pProcInfo->Address)	//Already loaded
	{
		fPrevLoaded = TRUE;
		goto UpdateDynLoadInfo;
	}	
    hLibrary = LoadLibrary(pLibrary);

    if (hLibrary == NULL)
    {
		DPF("LoadLibrary failed for %s \r\n", pLibrary);
		return FALSE;
    }

    p = pProcInfo;

    while (p->Name)
    {
        p->Address = GetProcAddress(hLibrary, p->Name);

        if (p->Address == NULL)
        {
			DPF("GetProcAddress failed for %s \r\n", p->Name);
			FreeLibrary(hLibrary);
			return FALSE;
        }

        p++;
    }

UpdateDynLoadInfo:
	pLib = DynLoadInfo;

	while (pLib->pszLib)
	{
		if (!lstrcmpi(pLib->pszLib, pLibrary))
		{
			pLib->iRefCnt++;
			if (!fPrevLoaded)
			{
				pLib->hLib = hLibrary;
			}
			break;
		}
		pLib++;
	}


    return TRUE;
}

STATIC BOOL FreeLibraryAndProcs(LPCTSTR pLibrary, PPROC_INFO pProcInfo)
{
	PDYNLOAD_INFO p;

#ifdef DEBUG_BUILT_LINKED    
	return TRUE;
#endif

	p = DynLoadInfo;

	while (p->pszLib)
	{
		if (!lstrcmpi(p->pszLib, pLibrary))
		{
		    PPROC_INFO ppi;

			p->iRefCnt--;
			if (p->iRefCnt > 0)
				return TRUE;
			if (!p->hLib)
				return FALSE;
			DPF("Freeing Library %s \r\n",p->pszLib);
			FreeLibrary(p->hLib);
			p->hLib = 0;
			
			ppi = pProcInfo;
			while (ppi->Name)
			{
				ppi->Address = 0;
				ppi++;
			}
			return TRUE;
		}
		p++;
	}
	return FALSE;
}

BOOL LoadACM()
{
	DPF("***LOADING ACM***\r\n");
	return LoadLibraryAndProcs(aszMSACM32, ACMProcs);	
}

BOOL FreeACM()
{
	DPF("***FREEING ACM***\r\n");
	return FreeLibraryAndProcs(aszMSACM32, ACMProcs);	
}


BOOL LoadAVI()
{
	DPF("***LOADING AVI***\r\n");
	return LoadLibraryAndProcs(aszAVIFIL32, AVIProcs);	
}

BOOL FreeAVI()
{
	DPF("***FREEING AVI***\r\n");
	return FreeLibraryAndProcs(aszAVIFIL32, AVIProcs);	
}

BOOL LoadVFW()
{
	DPF("***LOADING VFW***\r\n");
	return LoadLibraryAndProcs(aszMSVFW32, VFWProcs);	
}

BOOL FreeVFW()						 
{
	DPF("***FREEING VFW***\r\n");
	return FreeLibraryAndProcs(aszMSVFW32, VFWProcs);	
}

BOOL LoadVERSION()
{
	DPF("***LOADING VERSION***\r\n");
	return LoadLibraryAndProcs(aszVERSION, VERSIONProcs);	
}

BOOL FreeVERSION()
{
	DPF("***FREEING VERSION***\r\n");
	return FreeLibraryAndProcs(aszVERSION, VERSIONProcs);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\bezier\strings.h ===
#include "..\common\comstrin.h"

#define idsDescription    1
#define idsName         100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\bezier\bezdlg.h ===
#define     ID_VELOCITY         100
#define     ID_DENSITYARROW     102
#define     ID_VELOCITY_FAST    104
#define     ID_VELOCITY_SLOW    105


#define idsIniFile              1001
#define idsScreenSaver          1002
#define idsAppName              1007
#define idsNoHelpMemory         1008
#define idsHelpFile             1009

#define DLG_SCRNSAVECONFIGURE   2003

#define ID_LENGTH               2004
#define ID_LENGTHARROW          2005
#define ID_WIDTH		        2006
#define ID_WIDTHARROW		    2007
#define ID_LENGTH_LABEL         2008
#define ID_WIDTH_LABEL          2009

//
// Help IDs
//
#define IDH_DISPLAY_SCREENSAVER_BEZIERS_LENGTH          4213
#define IDH_DISPLAY_SCREENSAVER_BEZIERS_WIDTH           4214
#define IDH_DISPLAY_SCREENSAVER_BEZIERS_SPEED           4215
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\volume.h ===
typedef enum
{
    sndvolNotChecked,
	sndvolNotPresent,
	sndvolPresent,
} enumSndVol;

#define MAXMIXERLEN            256     // Maximum output string length

// Prototypes
STDAPI_(void) Multichannel (HWND hWnd, UINT uiMixID, DWORD dwDest, DWORD dwVolID);

BOOL OnInitDialog (HWND hDlg, HWND hwndFocus, LPARAM lParam);
void OnDestroy (HWND hDlg);
void OnNotify (HWND hDlg, LPNMHDR pnmh);

void InitVolume (HWND hDlg);
BOOL PASCAL OnCommand (HWND hDlg, int id, HWND hwndCtl, UINT codeNotify);
BOOL SndVolPresent ();
void MasterVolumeConfig (HWND hWnd, UINT* puiMixID);
BOOL SearchDevice (DWORD dwMixID, LPDWORD pdwDest, LPDWORD pdwVolID, LPDWORD pdwMuteID);
void SearchControls(int mxid, LPMIXERLINE pml, LPDWORD pdwVolID, LPDWORD pdwMuteID, BOOL *pfFound);
void DisplayVolumeControl (HWND hDlg);
void UpdateVolumeSlider(HWND hWnd, DWORD dwLine);
DWORD GetMaxVolume ();
HRESULT GetVolume ();
void SetVolume(DWORD dwVol);
BOOL GetMute ();
void SetMute(BOOL fMute);
void FreeMixer ();
void DeviceChange_Cleanup ();
BOOL DeviceChange_GetHandle(DWORD dwMixerID, HANDLE *phDevice);
void DeviceChange_Init(HWND hWnd, DWORD dwMixerID);
void DeviceChange_Change(HWND hDlg, WPARAM wParam, LPARAM lParam);
void MasterVolumeScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos);
void HandlePowerBroadcast (HWND hWnd, WPARAM wParam, LPARAM lParam);
void SetBranding (HWND hwnd, UINT uiMixID);
void ResetBranding (HWND hwnd);
void FreeBrandBmp ();
void CreateHotLink (BOOL fHotLink);
BOOL ValidateURL ();
HKEY OpenDeviceRegKey (UINT uiMixID, REGSAM sam);
PTCHAR GetInterfaceName (DWORD dwMixerID);
HKEY OpenDeviceBrandRegKey (UINT uiMixID);
void RefreshMixCache ();

// Globals
UINT                g_uiVolDevChange = 0;
WNDPROC             g_fnVolPSProc   = NULL;
HWND                g_hWnd          = NULL;
HMIXER              g_hMixer        = NULL;
enumSndVol          g_sndvolPresent = sndvolNotChecked;
BOOL                g_fMasterVolume = FALSE; // True if the master volume slider is enabled
BOOL                g_fMasterMute   = FALSE; // True if the master mute button is enabled
BOOL                g_fTrayIcon     = FALSE; // Current state of tray icon button
DWORD               g_dwVolID       = (DWORD) -1;
DWORD               g_dwMuteID      = (DWORD) -1;
LPVOID              g_pvPrevious    = NULL;
double*             g_pdblCacheMix  = NULL;
BOOL                g_fCacheCreated = FALSE;
BOOL                g_fPreviousMute = FALSE;
MIXERCONTROLDETAILS g_mcd;
static HDEVNOTIFY   g_hDeviceEventContext = NULL;
BOOL                g_fChanged            = FALSE;
BOOL                g_fInternalGenerated  = FALSE;
UINT                g_uiMixID             = 0;
DWORD               g_dwDest              = 0;
HBITMAP             g_hbmBrand            = NULL;
WCHAR*              g_szHotLinkURL        = NULL;
WCHAR               g_szDeviceName[MAX_PATH] = { L"\0" };
WCHAR               g_szNoAudioDevice[MAX_PATH] = { L"\0" };
MIXERLINE           g_mlDst;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\mmsys\volume.c ===
///////////////////////////////////////////////////////////////////////////////
//
//  File:  volume.c
//
//      This file defines the functions that drive the volume
//      tab of the Sounds & Multimedia control panel.
//
//  History:
//      06 March 2000 RogerW
//          Created.
//
//  Copyright (C) 2000 Microsoft Corporation  All Rights Reserved.
//
//                  Microsoft Confidential
//
///////////////////////////////////////////////////////////////////////////////

//=============================================================================
//                            Include files
//=============================================================================
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <regstr.h>
#include <dbt.h>
#include <mmsystem.h>
#include <mmddkp.h>
#include <shlwapi.h>
#include "volume.h"
#include "mmcpl.h"
#include "trayvol.h"
#include "advaudio.h"
#include "medhelp.h"
#include "multchan.h"

// Constants
const SIZE ksizeBrandMax = { 32, 32 }; // Max Branding Bitmap Size
static SZCODE     aszSndVolOptionKey[] = REGSTR_PATH_SETUP TEXT("\\SETUP\\OptionalComponents\\Vol");
static SZCODE     aszInstalled[]       = TEXT("Installed");
static const char aszSndVol32[]        = "sndvol32.exe";
#define     VOLUME_TICS         (500)
static INTCODE  aKeyWordIds[] =
{
    IDC_VOLUME_BRAND,           IDH_VOLUME_BRAND,
    IDC_VOLUME_MIXER,           IDH_VOLUME_MIXER,
    IDC_GROUPBOX,               IDH_SOUNDS_SYS_VOL_CONTROL,
    IDC_VOLUME_ICON,            IDH_COMM_GROUPBOX,
	IDC_VOLUME_LOW,		        IDH_SOUNDS_SYS_VOL_CONTROL,
    IDC_MASTERVOLUME,           IDH_SOUNDS_SYS_VOL_CONTROL,
	IDC_VOLUME_HIGH,	        IDH_SOUNDS_SYS_VOL_CONTROL,
    IDC_VOLUME_MUTE,            IDH_SOUNDS_VOL_MUTE_BUTTON,
    IDC_TASKBAR_VOLUME,         IDH_AUDIO_SHOW_INDICATOR,
    IDC_LAUNCH_SNDVOL,          IDH_AUDIO_PLAY_VOL,
    IDC_GROUPBOX_2,             IDH_COMM_GROUPBOX,
    IDC_VOLUME_SPEAKER_BITMAP,  IDH_COMM_GROUPBOX,
    IDC_LAUNCH_MULTICHANNEL,    IDH_LAUNCH_MULTICHANNEL,
    IDC_PLAYBACK_ADVSETUP,      IDH_ADV_AUDIO_PLAY_PROP,
    IDC_TEXT_31,                NO_HELP,
    0,0
};

// TODO: Move to "regstr.h"
#define REGSTR_KEY_BRANDING TEXT("Branding")
#define REGSTR_VAL_AUDIO_BITMAP TEXT("bitmap")
#define REGSTR_VAL_AUDIO_ICON TEXT("icon")
#define REGSTR_VAL_AUDIO_URL TEXT("url")

HBITMAP ghSpkBitmap;

///////////////////////////////////////////////////////////////////////////////
//
//  %%Function: VolumeTabProc
//
//  Parameters: hDlg = window handle of dialog window.
//              uiMessage = message ID.
//              wParam = message-dependent.
//              lParam = message-dependent.
//
//  Returns: TRUE if message has been processed, else FALSE
//
//  Description: Dialog proc for volume control panel page device change
//               message.
//
//
///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK VolumeTabProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    if (iMsg == g_uiVolDevChange)
    {
        InitVolume (g_hWnd);
    }
        
    return CallWindowProc (g_fnVolPSProc, hwnd, iMsg, wParam, lParam);
}


///////////////////////////////////////////////////////////////////////////////
//
//  %%Function: VolumeDlg
//
//  Parameters: hDlg = window handle of dialog window.
//              uiMessage = message ID.
//              wParam = message-dependent.
//              lParam = message-dependent.
//
//  Returns: TRUE if message has been processed, else FALSE
//
//  Description: Dialog proc for volume control panel page.
//
//
///////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK VolumeDlg (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            OnNotify (hDlg, (LPNMHDR) lParam);
        }
        break;

        case WM_INITDIALOG:
        {
            HANDLE_WM_INITDIALOG (hDlg, wParam, lParam, OnInitDialog);
        }
        break;

        case WM_DESTROY:
        {
            HANDLE_WM_DESTROY (hDlg, wParam, lParam, OnDestroy);
        }
        break;
         
        case WM_COMMAND:
        {
            HANDLE_WM_COMMAND (hDlg, wParam, lParam, OnCommand);
        }
        break;

        case WM_POWERBROADCAST:
        {
            HandlePowerBroadcast (hDlg, wParam, lParam);
        }
        break;

        case MM_MIXM_LINE_CHANGE:
        case MM_MIXM_CONTROL_CHANGE:
        {
            if (!g_fInternalGenerated)
            {
                RefreshMixCache ();
                DisplayVolumeControl(hDlg);
            }

            g_fInternalGenerated = FALSE;
        }
        break;

	    case WM_HSCROLL:
        {
	        HANDLE_WM_HSCROLL (hDlg, wParam, lParam, MasterVolumeScroll);
	    }
        break;
        
        case WM_CONTEXTMENU:
        {
            WinHelp ((HWND)wParam, NULL, HELP_CONTEXTMENU,
                                            (UINT_PTR)(LPTSTR)aKeyWordIds);
        }
        break;

        case WM_HELP:
        {
            WinHelp (((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP
                                    , (UINT_PTR)(LPTSTR)aKeyWordIds);
        }
        break;

        case WM_DEVICECHANGE:
        {
            DeviceChange_Change (hDlg, wParam, lParam);
        }
        break;

        case WM_SYSCOLORCHANGE:
        {
            if (ghSpkBitmap)
            {
                DeleteObject(ghSpkBitmap);
                ghSpkBitmap = NULL;
            }
            
            ghSpkBitmap = (HBITMAP) LoadImage(ghInstance,MAKEINTATOM(IDB_MULTICHANNEL_SPKR), IMAGE_BITMAP, 
                                    0, 0, LR_LOADMAP3DCOLORS);
    
            SendDlgItemMessage(hDlg, IDC_VOLUME_SPEAKER_BITMAP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) ghSpkBitmap);

        }
        break;

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE :
        {
            SendDlgItemMessage (hDlg, IDC_MASTERVOLUME, uMsg, wParam, lParam);
        }
        break;

        default:
        break;

    }

    return FALSE;

}



void OnNotify (HWND hDlg, LPNMHDR pnmh)
{
    if (!pnmh)
    {
        DPF ("bad WM_NOTIFY pointer\n");            
        return;
    }

    switch (pnmh->code)
    {
        case PSN_KILLACTIVE:
            FORWARD_WM_COMMAND (hDlg, IDOK, 0, 0, SendMessage);
            break;

        case PSN_APPLY:
            FORWARD_WM_COMMAND (hDlg, ID_APPLY, 0, 0, SendMessage);
            break;

        case PSN_RESET:
            FORWARD_WM_COMMAND (hDlg, IDCANCEL, 0, 0, SendMessage);
            break;
                
    }
}


void OnDestroy (HWND hDlg)
{
    // Unregister from notifications
    DeviceChange_Cleanup();
    SetWindowLongPtr (GetParent (hDlg), GWLP_WNDPROC, (LONG_PTR) g_fnVolPSProc);  
    // Free any mixer we have
    FreeMixer ();
    // Free any branding bitmap
    FreeBrandBmp ();
    // Free detail memory

    DeleteObject( ghSpkBitmap );

    if (g_mcd.paDetails)
    {
        LocalFree (g_mcd.paDetails);
        g_mcd.paDetails = NULL;
    }
    if (g_pvPrevious)
    {
        LocalFree (g_pvPrevious);
        g_pvPrevious = NULL;
    }
    if (g_pdblCacheMix)
    {
        LocalFree (g_pdblCacheMix);
        g_pdblCacheMix = NULL;
    }
    // Free URL memory
    if( g_szHotLinkURL )
    {
        LocalFree( g_szHotLinkURL );
        g_szHotLinkURL = NULL;
    }

    ZeroMemory (&g_mcd, sizeof (g_mcd));
    ZeroMemory (&g_mlDst, sizeof (g_mlDst));
}

void CreateHotLink (BOOL fHotLink)
{
    WCHAR   szMixerName[MAXMIXERLEN];
    WCHAR*  szLinkName;
    UINT    uiLinkSize = 0;

    // Underline the mixer name to appear like a browser hot-link.
    HWND hWndMixerName = GetDlgItem (g_hWnd, IDC_VOLUME_MIXER);
	DWORD dwStyle      = GetWindowLong (hWndMixerName, GWL_STYLE);

    if (fHotLink)
    {
        GetDlgItemText( g_hWnd, IDC_VOLUME_MIXER, szMixerName, MAXMIXERLEN);

        uiLinkSize = ((lstrlen(g_szHotLinkURL) * sizeof(WCHAR)) + (lstrlen(szMixerName) * sizeof(WCHAR)) 
            + (17 * sizeof(WCHAR))); //  The 17 is for extra characters plus a NULL

        szLinkName = (WCHAR *)LocalAlloc (LPTR, uiLinkSize);
        if (szLinkName)
        {
            wsprintf(szLinkName, TEXT("<A HREF=\"%s\">%s</A>"), g_szHotLinkURL, szMixerName);
            SetDlgItemText( g_hWnd, IDC_VOLUME_MIXER, szLinkName);
        
            LocalFree(szLinkName);
        }

        EnableWindow(hWndMixerName, TRUE);
        dwStyle |= WS_TABSTOP;
    }
    else
    {
        EnableWindow(hWndMixerName, FALSE);
        dwStyle &= ~WS_TABSTOP;
    }

    // Apply new style (remove/add tab stop)
	SetWindowLong (hWndMixerName, GWL_STYLE, dwStyle);

}


BOOL OnInitDialog (HWND hDlg, HWND hwndFocus, LPARAM lParam)
{

    // Init Globals
    g_hWnd               = hDlg;
    g_fChanged           = FALSE;
    g_fInternalGenerated = FALSE;
    // Set Device Change Notification
    g_fnVolPSProc = (WNDPROC) SetWindowLongPtr (GetParent (hDlg), GWLP_WNDPROC, (LONG_PTR) VolumeTabProc);
    g_uiVolDevChange = RegisterWindowMessage (_T("winmm_devicechange"));
    // Save the default "No Audio Device" string
    GetDlgItemText (hDlg, IDC_VOLUME_MIXER, g_szNoAudioDevice, sizeof(g_szNoAudioDevice)/sizeof(g_szNoAudioDevice[0]));

    // Init Volume
    InitVolume (hDlg);

    if (ghSpkBitmap)
    {
        DeleteObject(ghSpkBitmap);
        ghSpkBitmap = NULL;
    }

    ghSpkBitmap = (HBITMAP) LoadImage(ghInstance,MAKEINTATOM(IDB_MULTICHANNEL_SPKR), IMAGE_BITMAP, 
                                    0, 0, LR_LOADMAP3DCOLORS);
    SendDlgItemMessage(hDlg, IDC_VOLUME_SPEAKER_BITMAP, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) ghSpkBitmap);


    return FALSE;

}


BOOL PASCAL OnCommand (HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_TASKBAR_VOLUME:
        {
            if (Button_GetCheck (GetDlgItem (hDlg, IDC_TASKBAR_VOLUME)) && (!SndVolPresent ()))
            {
                CheckDlgButton (hDlg, IDC_TASKBAR_VOLUME, FALSE);
                ErrorBox (hDlg, IDS_NOSNDVOL, NULL);
                g_sndvolPresent = sndvolNotChecked; // Reset
            }
            else
            {
                g_fTrayIcon = Button_GetCheck (GetDlgItem (hDlg, IDC_TASKBAR_VOLUME));

                PropSheet_Changed(GetParent(hDlg),hDlg);
                g_fChanged = TRUE;
            }
        }
        break;

        case IDC_VOLUME_MUTE:
        {
            BOOL fMute = !GetMute ();
            SetMute(fMute);

            if ((g_fPreviousMute != fMute) && !g_fChanged)
            {
                g_fChanged = TRUE;
                PropSheet_Changed(GetParent(hDlg),hDlg);
            }
        }
        break;

        case ID_APPLY:
        {
            // Update Tray Icon
            BOOL fTrayIcon = Button_GetCheck (GetDlgItem (hDlg, IDC_TASKBAR_VOLUME));
            if (fTrayIcon != GetTrayVolumeEnabled ())
            {
                g_fTrayIcon = fTrayIcon;
                SetTrayVolumeEnabled(g_fTrayIcon);
            }

            if (SUCCEEDED (GetVolume ()) && g_pvPrevious && g_mcd.paDetails)
            {
                // Copy data so can undo volume changes
                memcpy (g_pvPrevious, g_mcd.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);
                DisplayVolumeControl (hDlg);
            }
            g_fPreviousMute = GetMute ();

            g_fChanged = FALSE;

            return TRUE;
        }
        break;

        case IDOK:
        {
            // OK processing handled in ID_APPLY because it is always
            // called from the property sheet's IDOK processing.
        }
        break;

        case IDCANCEL:
        {
            if (g_hMixer)
            {
                SetMute (g_fPreviousMute);
                if (g_pvPrevious && g_mcd.paDetails)
                {
                    // Undo volume changes
                    memcpy (g_mcd.paDetails, g_pvPrevious, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);
                    g_fInternalGenerated = TRUE;
                    mixerSetControlDetails ((HMIXEROBJ) g_hMixer, &g_mcd, MIXER_SETCONTROLDETAILSF_VALUE);
                    g_fInternalGenerated = FALSE;
                }
            }
            WinHelp (hDlg, gszWindowsHlp, HELP_QUIT, 0L);

        }
        break;

        case IDC_LAUNCH_SNDVOL:
        {
            TCHAR szCmd[MAXSTR];
            STARTUPINFO si;
            PROCESS_INFORMATION pi;

            memset(&si, 0, sizeof(si));
            si.cb = sizeof(si);
            si.wShowWindow = SW_SHOW;
            si.dwFlags = STARTF_USESHOWWINDOW;
            wsprintf(szCmd,TEXT("sndvol32.exe -D %d"), g_uiMixID);

            if (!CreateProcess(NULL,szCmd,NULL,NULL,FALSE,0,NULL,NULL,&si,&pi))
            {
                ErrorBox (hDlg, IDS_NOSNDVOL, NULL);
            }
        }
        break;

        case IDC_LAUNCH_MULTICHANNEL:
        {
            Multichannel (hDlg, g_uiMixID, g_dwDest, g_dwVolID);
        }
        break;

        case IDC_PLAYBACK_ADVSETUP: 
        {
            MIXERCAPS mc;
            DWORD   dwDeviceID = g_uiMixID;


            if (MMSYSERR_NOERROR == mixerGetDevCaps (g_uiMixID, &mc, sizeof (mc)))
            {
                AdvancedAudio (hDlg, ghInstance, gszWindowsHlp, dwDeviceID, mc.szPname, FALSE);
            }
        }
        break;
    }


   return FALSE;

}


void InitVolume (HWND hDlg)
{

    FreeMixer ();

    // Get the master volume & display
    MasterVolumeConfig (hDlg, &g_uiMixID);

    if (SUCCEEDED (GetVolume ()) && g_pvPrevious && g_mcd.paDetails)
    {
        RefreshMixCache ();
        // Copy data so can undo volume changes
        memcpy (g_pvPrevious, g_mcd.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);

        g_fPreviousMute = GetMute ();
    }
    DisplayVolumeControl (hDlg);

    DeviceChange_Init (hDlg, g_uiMixID);

 }

// returns current mute state
BOOL GetMute ()
{
    BOOL fMute = FALSE;

    if (g_hMixer && (g_dwMuteID != (DWORD) -1))
    {
        MIXERCONTROLDETAILS_UNSIGNED mcuMute;
        MIXERCONTROLDETAILS mcd = g_mcd;

        // Modify local copy for mute ...
        mcd.dwControlID = g_dwMuteID;
        mcd.cChannels = 1;
        mcd.paDetails = &mcuMute;
        mixerGetControlDetails ((HMIXEROBJ) g_hMixer, &mcd, MIXER_GETCONTROLDETAILSF_VALUE);

        fMute = (BOOL) mcuMute.dwValue;
    }

    return fMute;
}

BOOL SndVolPresent ()
{

    if (g_sndvolPresent == sndvolNotChecked)
    {
        OFSTRUCT of;
        if (HFILE_ERROR != OpenFile (aszSndVol32, &of, OF_EXIST | OF_SHARE_DENY_NONE))
        {
            g_sndvolPresent = sndvolPresent;
        }
        else
        {
            HKEY hkSndVol;
            g_sndvolPresent = sndvolNotPresent;

            if (!RegOpenKey (HKEY_LOCAL_MACHINE, aszSndVolOptionKey, &hkSndVol))
            {
                RegSetValueEx (hkSndVol, (LPTSTR) aszInstalled, 0L, REG_SZ, (LPBYTE)(TEXT("0")), 4);
                RegCloseKey (hkSndVol);
            }
        }
    }

    return (sndvolPresent == g_sndvolPresent);

}

void FreeMixer ()
{
    if (g_hMixer)
    {
        mixerClose (g_hMixer);
        g_hMixer = NULL;
    }
}

// Gets the primary audio device ID and find the mixer line for it
// It leaves it open so the slider can respond to other changes outside this app
//
void MasterVolumeConfig (HWND hWnd, UINT* puiMixID)
{

    UINT  uiWaveID;

    // Init
    g_fMasterVolume = g_fTrayIcon = g_fMasterMute = FALSE;
    g_dwDest = g_dwVolID = g_dwMuteID = 0;

    ResetBranding (hWnd);

    if (puiMixID && GetWaveID (&uiWaveID) == MMSYSERR_NOERROR)
    {
        if (MMSYSERR_NOERROR == mixerGetID (HMIXEROBJ_INDEX(uiWaveID), puiMixID, MIXER_OBJECTF_WAVEOUT))
        {
            SetBranding (hWnd, *puiMixID);

            if (SearchDevice (*puiMixID, &g_dwDest, &g_dwVolID, &g_dwMuteID))
            {
                FreeMixer ();

                if (MMSYSERR_NOERROR == mixerOpen (&g_hMixer, *puiMixID, (DWORD_PTR) hWnd, 0L, CALLBACK_WINDOW))
                {

                    ZeroMemory (&g_mlDst, sizeof (g_mlDst));
                    g_mlDst.cbStruct      = sizeof (g_mlDst);
                    g_mlDst.dwDestination = g_dwDest;
    
                    if (MMSYSERR_NOERROR == mixerGetLineInfo ((HMIXEROBJ)g_hMixer, &g_mlDst, MIXER_GETLINEINFOF_DESTINATION))
                    {
                        g_mcd.cbStruct       = sizeof (g_mcd);
                        g_mcd.dwControlID    = g_dwVolID;
                        g_mcd.cChannels      = g_mlDst.cChannels;
                        g_mcd.hwndOwner      = 0;
                        g_mcd.cMultipleItems = 0;
                        g_mcd.cbDetails      = sizeof (DWORD); // seems like it would be sizeof(g_mcd),
                                                               // but actually, it is the size of a single value
                                                               // and is multiplied by channel in the driver.
                        // TODO: Should Return Error on failure!
                        g_mcd.paDetails = (MIXERCONTROLDETAILS_UNSIGNED*) LocalAlloc (LPTR, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);
                        g_pvPrevious = (MIXERCONTROLDETAILS_UNSIGNED*) LocalAlloc (LPTR, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);
                        g_pdblCacheMix = (double*) LocalAlloc (LPTR, sizeof (double) * g_mlDst.cChannels);

                        g_fMasterVolume = TRUE;
                        g_fMasterMute = (g_dwMuteID != (DWORD) -1);
                        g_fTrayIcon = GetTrayVolumeEnabled ();
                    }
                }
            }
        }
    }
}

// Locates the master volume and mute controls for this mixer line
//
void SearchControls(int mxid, LPMIXERLINE pml, LPDWORD pdwVolID, LPDWORD pdwMuteID, BOOL *pfFound)
{
    MIXERLINECONTROLS mlc;
    DWORD dwControl;

    memset(&mlc, 0, sizeof(mlc));
    mlc.cbStruct = sizeof(mlc);
    mlc.dwLineID = pml->dwLineID;
    mlc.cControls = pml->cControls;
    mlc.cbmxctrl = sizeof(MIXERCONTROL);
    mlc.pamxctrl = (LPMIXERCONTROL) GlobalAlloc(GMEM_FIXED, sizeof(MIXERCONTROL) * pml->cControls);

    if (mlc.pamxctrl)
    {
        if (mixerGetLineControls(HMIXEROBJ_INDEX(mxid), &mlc, MIXER_GETLINECONTROLSF_ALL) == MMSYSERR_NOERROR)
        {
            for (dwControl = 0; dwControl < pml->cControls && !(*pfFound); dwControl++)
            {
                if (mlc.pamxctrl[dwControl].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_VOLUME)
                {
                    DWORD dwIndex;
                    DWORD dwVolID = (DWORD) -1;
                    DWORD dwMuteID = (DWORD) -1;

                    dwVolID = mlc.pamxctrl[dwControl].dwControlID;

                    for (dwIndex = 0; dwIndex < pml->cControls; dwIndex++)
                    {
                        if (mlc.pamxctrl[dwIndex].dwControlType == (DWORD)MIXERCONTROL_CONTROLTYPE_MUTE)
                        {
                            dwMuteID = mlc.pamxctrl[dwIndex].dwControlID;
                            break;
                        }
                    }

                    *pfFound = TRUE;
                    *pdwVolID = dwVolID;
                    *pdwMuteID = dwMuteID;
                }
            }
        }

        GlobalFree((HGLOBAL) mlc.pamxctrl);
    }
}


// Locates the volume slider control for this mixer device
//
BOOL SearchDevice (DWORD dwMixID, LPDWORD pdwDest, LPDWORD pdwVolID, LPDWORD pdwMuteID)
{
    MIXERCAPS   mc;
    MMRESULT    mmr;
    BOOL        fFound = FALSE;

    mmr = mixerGetDevCaps(dwMixID, &mc, sizeof(mc));

    if (mmr == MMSYSERR_NOERROR)
    {
        MIXERLINE   mlDst;
        DWORD       dwDestination;

        for (dwDestination = 0; dwDestination < mc.cDestinations && !fFound; dwDestination++)
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwDestination = dwDestination;

            if (mixerGetLineInfo(HMIXEROBJ_INDEX(dwMixID), &mlDst, MIXER_GETLINEINFOF_DESTINATION  ) == MMSYSERR_NOERROR)
            {
                if (mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_SPEAKERS ||    // needs to be a likely output destination
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_DST_HEADPHONES ||
                    mlDst.dwComponentType == (DWORD)MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT)
                {
                    if (!fFound && mlDst.cControls)     // If there are controls, we'll take the master
                    {
                        SearchControls(dwMixID, &mlDst, pdwVolID, pdwMuteID, &fFound);
                        *pdwDest = dwDestination;
                    }
                }
            }
        }
    }

    return(fFound);
}


// Call this function to configure to the current preferred device and reflect master volume
// settings on the slider
//
void DisplayVolumeControl (HWND hDlg)
{
    HWND hwndVol        = GetDlgItem(hDlg, IDC_MASTERVOLUME);
    BOOL fMute          = g_fMasterMute && GetMute ();

    SendMessage(hwndVol, TBM_SETTICFREQ, VOLUME_TICS / 10, 0);
    SendMessage(hwndVol, TBM_SETRANGE, FALSE, MAKELONG(0,VOLUME_TICS));

    EnableWindow(GetDlgItem(hDlg, IDC_MASTERVOLUME) , g_fMasterVolume);
    EnableWindow(GetDlgItem(hDlg, IDC_VOLUME_LOW) , g_fMasterVolume);
    EnableWindow(GetDlgItem(hDlg, IDC_VOLUME_HIGH) , g_fMasterVolume);
    EnableWindow(GetDlgItem(hDlg, IDC_TASKBAR_VOLUME),g_fMasterVolume);
    EnableWindow(GetDlgItem(hDlg, IDC_VOLUME_MUTE), g_fMasterMute);
    EnableWindow(GetDlgItem(hDlg, IDC_LAUNCH_SNDVOL), g_fMasterVolume && SndVolPresent ());
    EnableWindow(GetDlgItem(hDlg, IDC_LAUNCH_MULTICHANNEL), g_fMasterVolume);
    EnableWindow(GetDlgItem(hDlg, IDC_PLAYBACK_ADVSETUP), g_fMasterVolume);

    if (g_fMasterVolume)
    {
        UpdateVolumeSlider (hDlg, g_dwVolID);
    }
    else
    {
        SendMessage(GetDlgItem(hDlg, IDC_MASTERVOLUME), TBM_SETPOS, TRUE, 0 );
    }

    // Show if we are muted
    Button_SetCheck (GetDlgItem (hDlg, IDC_VOLUME_MUTE), fMute);

    // This displays the appropriate volume icon for the master mute state
    // This looks like a memory leak, but it's not.  LoadIcon just gets a handle to the already-loaded
    // icon if it was previously loaded.  See the docs for LoadIcon and DestroyIcon (which specifically
    // should not be called with a handle to an icon loaded via LoadIcon).
    if( fMute )
    {
        SendMessage (GetDlgItem (hDlg, IDC_VOLUME_ICON), STM_SETIMAGE, IMAGE_ICON, (LPARAM)LoadIcon(ghInstance, MAKEINTRESOURCE (IDI_MUTESPEAKERICON)) );
    }
    else
    {
        SendMessage (GetDlgItem (hDlg, IDC_VOLUME_ICON), STM_SETIMAGE, IMAGE_ICON, (LPARAM)LoadIcon(ghInstance, MAKEINTRESOURCE (IDI_SPEAKERICON)) );
    }
    CheckDlgButton (hDlg, IDC_TASKBAR_VOLUME, g_fTrayIcon);

}

// Called to update the slider when the volume is changed externally
//
void UpdateVolumeSlider(HWND hWnd, DWORD dwLine)
{
    if ((g_hMixer != NULL) && (g_dwVolID != (DWORD) -1) && (dwLine == g_dwVolID))
    {
        double volume = ((double) GetMaxVolume () / (double) 0xFFFF) * ((double) VOLUME_TICS);
        // The 0.5f forces rounding (instead of truncation)
        SendMessage(GetDlgItem(hWnd, IDC_MASTERVOLUME), TBM_SETPOS, TRUE, (DWORD) (volume+0.5f) );
    }
}


// returns current volume level
//
DWORD GetMaxVolume ()
{
    DWORD dwVol = 0;

    if (SUCCEEDED (GetVolume ()))
    {
        UINT uiIndx;
        MIXERCONTROLDETAILS_UNSIGNED* pmcuVolume;

        for (uiIndx = 0; uiIndx < g_mlDst.cChannels; uiIndx++)
        {
            pmcuVolume = ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcd.paDetails + uiIndx);
            dwVol = max (dwVol, pmcuVolume -> dwValue); 
        }
    }

    return dwVol;
}

HRESULT GetVolume ()
{
    HRESULT hr = E_FAIL;
    if (g_hMixer && g_mcd.paDetails)
    {
        g_mcd.dwControlID = g_dwVolID;
        ZeroMemory (g_mcd.paDetails, sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels);
        hr = mixerGetControlDetails ((HMIXEROBJ)g_hMixer, &g_mcd, MIXER_GETCONTROLDETAILSF_VALUE);
    }
    return hr;
}


void DeviceChange_Cleanup ()
{
   if (g_hDeviceEventContext) 
   {
       UnregisterDeviceNotification (g_hDeviceEventContext);
       g_hDeviceEventContext = NULL;
   }
}


BOOL DeviceChange_GetHandle(DWORD dwMixerID, HANDLE *phDevice)
{
	MMRESULT mmr;
	ULONG cbSize=0;
	TCHAR *szInterfaceName=NULL;

	//Query for the Device interface name
	mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
	if(MMSYSERR_NOERROR == mmr)
	{
		szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
		if(!szInterfaceName)
		{
			return FALSE;
		}

		mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
		if(MMSYSERR_NOERROR != mmr)
		{
			GlobalFreePtr(szInterfaceName);
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	//Get an handle on the device interface name.
	*phDevice = CreateFile(szInterfaceName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
						 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	GlobalFreePtr(szInterfaceName);
	if(INVALID_HANDLE_VALUE == *phDevice)
	{
		return FALSE;
	}

	return TRUE;
}

void DeviceChange_Init(HWND hWnd, DWORD dwMixerID)
{
	DEV_BROADCAST_HANDLE DevBrodHandle;
	HANDLE hMixerDevice=NULL;

	//If we had registered already for device notifications, unregister ourselves.
	DeviceChange_Cleanup();

	//If we get the device handle register for device notifications on it.
	if(DeviceChange_GetHandle(dwMixerID, &hMixerDevice))
	{
		memset(&DevBrodHandle, 0, sizeof(DEV_BROADCAST_HANDLE));

		DevBrodHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
		DevBrodHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
		DevBrodHandle.dbch_handle = hMixerDevice;

		g_hDeviceEventContext = RegisterDeviceNotification(hWnd, &DevBrodHandle, DEVICE_NOTIFY_WINDOW_HANDLE);

		if(hMixerDevice)
		{
			CloseHandle(hMixerDevice);
			hMixerDevice = NULL;
		}
	}
}


// Handle the case where we need to dump mixer handle so PnP can get rid of a device
// We assume we will get the WINMM_DEVICECHANGE handle when the dust settles after a remove or add
// except for DEVICEQUERYREMOVEFAILED which will not generate that message.
//
void DeviceChange_Change(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
	PDEV_BROADCAST_HANDLE bh = (PDEV_BROADCAST_HANDLE)lParam;

	if(!g_hDeviceEventContext || !bh || bh->dbch_devicetype != DBT_DEVTYP_HANDLE)
	{
		return;
	}
	
    switch (wParam)
    {
	    case DBT_DEVICEQUERYREMOVE:     // Must free up Mixer if they are trying to remove the device           
        {
            FreeMixer ();
        }
        break;

	    case DBT_DEVICEQUERYREMOVEFAILED:   // Didn't happen, need to re-acquire mixer
        {
            InitVolume (hDlg);
        }
        break; 
    }
}

// Sets the mute state
void SetMute(BOOL fMute)
{
    if (g_hMixer)
    {
        MIXERCONTROLDETAILS_UNSIGNED mcuMute;
        MIXERCONTROLDETAILS mcd = g_mcd;

        // Modify local copy for mute ...
        mcuMute.dwValue = (DWORD) fMute;
        mcd.dwControlID = g_dwMuteID;
        mcd.cChannels = 1;
        mcd.paDetails = &mcuMute;

        mixerSetControlDetails ((HMIXEROBJ)g_hMixer, &mcd, MIXER_SETCONTROLDETAILSF_VALUE);
    }
}


// Called in response to slider movement, computes new volume level and sets it
// it also controls the apply state (changed or not)
//
void MasterVolumeScroll (HWND hwnd, HWND hwndCtl, UINT code, int pos)
{
    DWORD dwVol = (DWORD) SendMessage(GetDlgItem(hwnd, IDC_MASTERVOLUME), TBM_GETPOS, 0, 0);

    dwVol = (DWORD) (((double) dwVol / (double) VOLUME_TICS) * (double) 0xFFFF);
    SetVolume(dwVol);

    if (!g_fChanged && (memcmp (g_pvPrevious, g_mcd.paDetails, 
                        sizeof (MIXERCONTROLDETAILS_UNSIGNED) * g_mlDst.cChannels)))
    {
        g_fChanged = TRUE;
        PropSheet_Changed(GetParent(hwnd),hwnd);
    }

    // Play a sound on for the master volume slider when the 
    // user ends the scroll and we are still in focus and the topmost app.
    if (code == SB_ENDSCROLL && hwndCtl == GetFocus() && GetParent (hwnd) == GetForegroundWindow ())
    {
        static const TCHAR cszDefSnd[] = TEXT(".Default");
        PlaySound(cszDefSnd, NULL, SND_ASYNC | SND_ALIAS);
    }

}

// Sets the volume level
//
void SetVolume (DWORD dwVol)
{

    if (g_hMixer && g_pdblCacheMix && g_mcd.paDetails)
    {
        UINT uiIndx;
        MIXERCONTROLDETAILS_UNSIGNED* pmcuVolume;

        // Caculate the new volume level for each of the channels. For volume levels 
        // at the current max, we simply set the newly requested level (in this case
        // the cache value is 1.0). For those less than the max, we set a value that 
        // is a percentage of the max. This maintains the relative distance of the 
        // channel levels from each other.
        for (uiIndx = 0; uiIndx < g_mlDst.cChannels; uiIndx++)
        {
            pmcuVolume = ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcd.paDetails + uiIndx);
            // The 0.5f forces rounding (instead of truncation)
            pmcuVolume -> dwValue = (DWORD)(*(g_pdblCacheMix + uiIndx) * (double) dwVol + 0.5f);
        }

        g_fInternalGenerated = TRUE;
        mixerSetControlDetails ((HMIXEROBJ)g_hMixer, &g_mcd, MIXER_SETCONTROLDETAILSF_VALUE);
        g_fInternalGenerated = FALSE;
    }

}


void HandlePowerBroadcast (HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    switch (wParam)
    {
	    case PBT_APMQUERYSUSPEND:
        {
            FreeMixer ();
        }
	    break;

	    case PBT_APMQUERYSUSPENDFAILED:
	    case PBT_APMRESUMESUSPEND:
        {
            InitVolume (hWnd);
        }
	    break;
    }
}



BOOL ChannelsAllMinimum()
{
    MIXERCONTROLDETAILS_UNSIGNED* pmcuVolume;

    if (g_hMixer && g_mcd.paDetails)
    {
        UINT uiIndx;
        for (uiIndx = 0; uiIndx < g_mlDst.cChannels; uiIndx++)
        {
           pmcuVolume =  (MIXERCONTROLDETAILS_UNSIGNED*)g_mcd.paDetails + uiIndx;
           if ( pmcuVolume->dwValue  != 0)
           {
               return (FALSE);
           }
        }
        return (TRUE);      // Volume of all channels equals zero since we haven't returned yet.
    }
    else return (FALSE);


}


void RefreshMixCache ()
{
    if (g_fCacheCreated && ChannelsAllMinimum())
    {
        return;
    }

    if (g_pdblCacheMix && g_hMixer && g_mcd.paDetails)
    {

        UINT uiIndx;
        double* pdblMixPercent;
        MIXERCONTROLDETAILS_UNSIGNED* pmcuVolume;
        // Note: This call does a GetVolume(), so no need to call it again...
        DWORD dwMaxVol = GetMaxVolume ();

        // Caculate the percentage distance each channel is away from the max
        // value. Creating this cache allows us to maintain the relative distance 
        // of the channel levels from each other as the user adjusts the master
        // volume level.
        for (uiIndx = 0; uiIndx < g_mlDst.cChannels; uiIndx++)
        {
            pmcuVolume     = ((MIXERCONTROLDETAILS_UNSIGNED*)g_mcd.paDetails + uiIndx);
            pdblMixPercent = (g_pdblCacheMix + uiIndx);

            // Caculate the percentage this value is from the max ...
            if (dwMaxVol == pmcuVolume -> dwValue)
            {
                *pdblMixPercent = 1.0F;
            }
            else
            {
                *pdblMixPercent = ((double) pmcuVolume -> dwValue / (double) dwMaxVol);
            }
        }
        g_fCacheCreated = TRUE;
    }
}


void FreeBrandBmp ()
{
    if (g_hbmBrand)
    {
        DeleteObject (g_hbmBrand);
        g_hbmBrand = NULL;
    }
}

void ResetBranding (HWND hwnd)
{
    FreeBrandBmp ();
    if( g_szHotLinkURL )
    {
        LocalFree( g_szHotLinkURL );
        g_szHotLinkURL = NULL;
    }

    // Initialize the Device Name Text
    SetDlgItemText (hwnd, IDC_VOLUME_MIXER, g_szNoAudioDevice);
    EnableWindow (GetDlgItem (hwnd, IDC_VOLUME_MIXER), FALSE);

    // Show the default icon window, and hide the custom bitmap window
    ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_ICON_BRAND), SW_SHOW);
    ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_BRAND), SW_HIDE);
}

void SetBranding (HWND hwnd, UINT uiMixID)
{
    
    HKEY hkeyBrand = NULL;
    MIXERCAPS mc;

    if (MMSYSERR_NOERROR != mixerGetDevCaps (uiMixID, &mc, sizeof (mc)))
        return; // bail

    ResetBranding (hwnd);

    // Device Name Text
    SetDlgItemText(hwnd, IDC_VOLUME_MIXER, mc.szPname);


    // Get Device Bitmap, if any.
    hkeyBrand = OpenDeviceBrandRegKey (uiMixID);
    if (hkeyBrand)
    {
        WCHAR szBuffer[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD cb     = sizeof (szBuffer);

        // Get Any Branding Bitmap
        if (ERROR_SUCCESS == RegQueryValueEx (hkeyBrand, REGSTR_VAL_AUDIO_BITMAP, NULL, &dwType, (LPBYTE)szBuffer, &cb))
        {
            BITMAP bm;
            WCHAR* pszComma = wcschr (szBuffer, L',');
            if (pszComma)
            {
                WCHAR* pszResourceID = pszComma + 1;
                HANDLE hResource;

                // Remove comma delimeter
                *pszComma = L'\0';

                // Should be a resource module and a resource ID
                hResource = LoadLibrary (szBuffer);
                if (!hResource)
                {
                    WCHAR szDriversPath[MAX_PATH+1];
                    szDriversPath[MAX_PATH] = 0;

                    // If we didn't find it on the normal search path, try looking
                    // in the "drivers" directory.
                    if (GetSystemDirectory (szDriversPath, MAX_PATH))
                    {
                        wcsncat (szDriversPath, TEXT("\\drivers\\"), MAX_PATH - wcslen(szDriversPath));
                        wcsncat (szDriversPath, szBuffer, MAX_PATH - wcslen(szDriversPath));
                        hResource = LoadLibrary (szDriversPath);
                    }

                }
                if (hResource)
                {
                    g_hbmBrand = LoadImage (hResource, MAKEINTRESOURCE(_wtoi (pszResourceID)), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE);
                    FreeLibrary (hResource);
                }
            }
            else
                // Should be an *.bmp file
                g_hbmBrand = LoadImage (NULL, szBuffer, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);

            // Verify that this bitmap is not larger than our defined maximum. Do NOT
            // use GetBitmapDimensionEx() here as it not set or used by the system.
            if (g_hbmBrand && GetObject (g_hbmBrand, sizeof (BITMAP), &bm))
            {
                if (bm.bmWidth > ksizeBrandMax.cx ||
                    bm.bmHeight > ksizeBrandMax.cy)
                {
                    // Too big, we will just show the standard one below
                    FreeBrandBmp ();
                }
            }
        }

        // Get Any Branding URL

        // Get the size of the URL
        if (ERROR_SUCCESS == RegQueryValueEx (hkeyBrand, REGSTR_VAL_AUDIO_URL, NULL, &dwType, NULL, &cb))
        {
            // Allocate a buffer to store the URL in, ensuring it is an integer number of WCHARs
            g_szHotLinkURL = (WCHAR *)LocalAlloc (LPTR, sizeof(WCHAR) * (cb + (sizeof(WCHAR)-1) / sizeof(WCHAR)));

            // Now, get the branding URL
            if (ERROR_SUCCESS != RegQueryValueEx (hkeyBrand, REGSTR_VAL_AUDIO_URL, NULL, &dwType, (LPBYTE)g_szHotLinkURL, &cb))
            {
                // If we failed, free up g_szHotLinkURL
                LocalFree( g_szHotLinkURL );
                g_szHotLinkURL = NULL;
            }
        }

        // Close the Branding key
        RegCloseKey (hkeyBrand);
    }

    // Apply any bitmap we have now.
    if (g_hbmBrand)
    {
        // Show the custom bitmap window, and hide the default icon window
        ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_BRAND), SW_SHOW);
        ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_ICON_BRAND), SW_HIDE);

        SendMessage (GetDlgItem (hwnd, IDC_VOLUME_BRAND), STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)g_hbmBrand);
    }
    else
    {
        // Show the default icon window, and hide the custom bitmap window
        ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_ICON_BRAND), SW_SHOW);
        ShowWindow (GetDlgItem (hwnd, IDC_VOLUME_BRAND), SW_HIDE);
    }

    // Create HotLink text if we have a valid internet address
    CreateHotLink (ValidateURL ());

}


BOOL ValidateURL ()
{

    BOOL fValid = FALSE;

    // Test basic validity
    if (g_szHotLinkURL && (0 < lstrlen (g_szHotLinkURL)))
    {
        // Test URL validity
        if (UrlIsW (g_szHotLinkURL, URLIS_URL))
        {

            WIN32_FIND_DATA fd;
            HANDLE hFile;

            // Make certain that the URL is not a local file!
            hFile = FindFirstFileW (g_szHotLinkURL, &fd);
            if (INVALID_HANDLE_VALUE == hFile)
                fValid = TRUE;
            else
                FindClose (hFile);
        }
    }

    // Clear any bogus info...
    if (!fValid && g_szHotLinkURL)
    {
        LocalFree (g_szHotLinkURL);
        g_szHotLinkURL = NULL;
    }

    return fValid;

}

STDAPI_(void) Multichannel (HWND hwnd, UINT uiMixID, DWORD dwDest, DWORD dwVolID)
{

    PROPSHEETHEADER psh;
    PROPSHEETPAGE   psp;
    TCHAR szWindowTitle[255];
    TCHAR szPageTitle[255];
    UINT uiTitle;

    // Save multichannel parameters for the multichannel page
    if (SUCCEEDED (SetDevice (uiMixID, dwDest, dwVolID))) 
    {
        // Load Page Title
        LoadString (ghInstance, GetPageStringID (), szPageTitle, sizeof (szPageTitle)/sizeof (TCHAR));

        ZeroMemory (&psp, sizeof (PROPSHEETPAGE));
        psp.dwSize      = sizeof (PROPSHEETPAGE);
        psp.dwFlags     = PSP_DEFAULT | PSP_USETITLE | PSP_USECALLBACK;
        psp.hInstance   = ghInstance;
        psp.pszTemplate = MAKEINTRESOURCE (IDD_MULTICHANNEL);
        psp.pszTitle    = szPageTitle;
        psp.pfnDlgProc  = MultichannelDlg;

        // Load Window Title (Same as page name now!)
        LoadString (ghInstance, GetPageStringID (), szWindowTitle, sizeof (szWindowTitle)/sizeof (TCHAR));

        ZeroMemory (&psh, sizeof (psh));
        psh.dwSize     = sizeof (psh);
        psh.dwFlags    = PSH_DEFAULT | PSH_PROPSHEETPAGE; 
        psh.hwndParent = hwnd;
        psh.hInstance  = ghInstance;
        psh.pszCaption = szWindowTitle;
        psh.nPages     = 1;
        psh.nStartPage = 0;
        psh.ppsp       = &psp;

        PropertySheet (&psh);
    }
}


HKEY OpenDeviceBrandRegKey (UINT uiMixID)
{

    HKEY hkeyBrand = NULL;
    HKEY hkeyDevice = OpenDeviceRegKey (uiMixID, KEY_READ);

    if (hkeyDevice)
    {
        if (ERROR_SUCCESS != RegOpenKey (hkeyDevice, REGSTR_KEY_BRANDING, &hkeyBrand))
            hkeyBrand = NULL; // Make sure NULL on failure

        // Close the Device key
        RegCloseKey (hkeyDevice);
    }

    return hkeyBrand;

}


///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
PTCHAR GetInterfaceName (DWORD dwMixerID)
{
	MMRESULT mmr;
	ULONG cbSize=0;
	TCHAR *szInterfaceName=NULL;

	//Query for the Device interface name
	mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
	if(MMSYSERR_NOERROR == mmr)
	{
		szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
		if(!szInterfaceName)
		{
			return NULL;
		}

		mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
		if(MMSYSERR_NOERROR != mmr)
		{
			GlobalFreePtr(szInterfaceName);
			return NULL;
		}
	}

    return szInterfaceName;
}


HKEY OpenDeviceRegKey (UINT uiMixID, REGSAM sam)
{

    HKEY hkeyDevice = NULL;
    PTCHAR szInterfaceName = GetInterfaceName (uiMixID);

    if (szInterfaceName)
    {
        HDEVINFO DeviceInfoSet = SetupDiCreateDeviceInfoList (NULL, NULL); 
        
        if (INVALID_HANDLE_VALUE != DeviceInfoSet)
        {
            SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
            DeviceInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

            if (SetupDiOpenDeviceInterface (DeviceInfoSet, szInterfaceName, 
                                            0, &DeviceInterfaceData))
            {
                DWORD dwRequiredSize;
                SP_DEVINFO_DATA DeviceInfoData;
                DeviceInfoData.cbSize = sizeof (SP_DEVINFO_DATA);

                // Ignore error, it always returns "ERROR_INSUFFICIENT_BUFFER" even though
                // the "SP_DEVICE_INTERFACE_DETAIL_DATA" parameter is supposed to be optional.
                (void) SetupDiGetDeviceInterfaceDetail (DeviceInfoSet, &DeviceInterfaceData,
                                                        NULL, 0, &dwRequiredSize, &DeviceInfoData);
                // Open device reg key
                hkeyDevice = SetupDiOpenDevRegKey (DeviceInfoSet, &DeviceInfoData,
                                                   DICS_FLAG_GLOBAL, 0,
                                                   DIREG_DRV, sam);

            }
            SetupDiDestroyDeviceInfoList (DeviceInfoSet);
        }
        GlobalFreePtr (szInterfaceName);
    }

    return hkeyDevice;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\bezier\ssbezier.c ===
/*

SSBEZIER.C

Bezier screensaver.

  History:
       10/14/91        kentd  Wrote for Windows NT.  Hacked from WinBez.

*/

#include <windows.h>
#include <commctrl.h>
#include <scrnsave.h>
#include "bezdlg.h"
#include "strings.h"
#include "uniconv.h"
#include "stdlib.h"

#undef OVERFLOW
#undef UNDERFLOW

#include "math.h"


#define INT int

#if !defined(_ALPHA_)
// floating point always initialized on ALPHA and ALPHA64
VOID _fltused(VOID) {}
#endif

// routines from bez.c

VOID vInitPoints();
VOID vRedraw();
VOID vNextBez();
LONG GetDlgItemLong(HWND hDlg, WORD wID, BOOL *pfTranslated, BOOL fSigned);
VOID GetIniEntries(VOID);
VOID vInitPalette(HDC);
VOID vNewColor(VOID);
LONG GetPrivateProfileLong(LPTSTR pszApp, LPTSTR pszKey, LONG lDefault);

typedef struct _STR
{
    PSZ     psz;
    SIZE    sz;
    SHORT   c;
    BYTE    f;
} STR;

typedef struct _inst
{
    ULONG i;
    POINT pt;
    POINT ptVel;
    LONG  c;
} INST, *PINST;


typedef struct _WINDOW {
    HWND hwnd;
    HDC hdc;
    HANDLE hWait;
    int xsize;
    int ysize;
    HPALETTE hpalette;

    // frame data

    HBITMAP hbitmap;
    HDC hdcBitmap;
    PBYTE pdata;
    RECT rcBlt;
    RECT rcDraw;
    int xDelta;
    int yDelta;

    // text data

    HBITMAP hbitmapText;
    HDC hdcText;
    PBYTE pdataText;
} WINDOW, *PWINDOW;

PWINDOW gpwindow;
BOOL fRepaint = TRUE;

//
// Length is the number of beziers in each loop
// Width is the number of times each bezier loop is drawn
//

#define MINLENGTH     1
#define MAXLENGTH     10
#define DEF_LENGTH    4
#define MINWIDTH      1
#define MAXWIDTH      100
#define DEF_WIDTH     30
#define MINVEL        2
#define DEFVEL        10
#define MAXVEL        20
#define MAX(a, b) (((a) >= (b)) ? (a) : (b))
#define NEWVEL (ulRandom() % (MAXVEL / 2 - MINVEL) + MINVEL)


HDC     ghdc;
HPEN    ghpenBez;
HPEN    ghpenErase;
HBRUSH  ghbrushBack;
DWORD   glSeed;
LONG    gcxScreen;
LONG    gcyScreen;
LONG    gczScreen;
LONG    gcPoints;
HDC     hdcBM;
HBITMAP hbm;
PINST   ainst;
BOOL    gbPointsDrawn;
LONG    giVelMax  =  DEFVEL;
LONG    gcBez     =  DEF_WIDTH;
LONG    gcRingLen =  DEF_LENGTH;
STR    *astr      = NULL;
BOOL    bInit     = FALSE;
int     cstr      = 0;
ULONG   ic        = 0;
BYTE    gf        = 0xff;
BOOL    gbCopy    = TRUE;
BOOL    gbPalette = FALSE;
HPALETTE ghpal    = 0;
HPALETTE ghpalOld = 0;

#define NUM_PALETTE_ENTRIES 10
#define FADE_RESOLUTION     24
#define MAX_TICKS_WIMPY     1000
#define MAX_TICKS_COOL      100

PALETTEENTRY gapal[NUM_PALETTE_ENTRIES * FADE_RESOLUTION];
PALETTEENTRY gapalDefault[NUM_PALETTE_ENTRIES + 1] =
                              { {255, 0,   0},   {128, 0,   0},
                                {0,   128, 0},   {128, 128, 0},
                                {0,   0,   128}, {128, 0,   128},
                                {0,   128, 128}, {128, 128, 128},
                                {192, 192, 192}, {255, 0,   0},
                                {0,   0,   0} };

LONG gipal;
LONG gcpal;
LONG gcTicker;
LONG gcMaxTicks;

// Structures:

typedef struct _BAND {
    POINT apt[2];
} BAND;

typedef struct _BEZ {
    BAND band[MAXLENGTH];
    BOOL bDrawn;
} BEZ, *PBEZ;

BEZ bezbuf[MAXWIDTH];
PBEZ gpBez;

POINT aPts[MAXLENGTH * 3 + 1];
POINT aVel[MAXLENGTH][2];

TCHAR  szLineSpeed [] = TEXT("LineSpeed");  // .INI Line Speed key

TCHAR  szNumBez [] = TEXT("Width");         // .INI Width key

TCHAR  szNumRings [] = TEXT("Length");      // .INI Length key

BOOL Init(HWND);

BYTE mask = 0;

//
// Help IDs
//
DWORD aBezDlgHelpIds[] = {
    65535,                  ((DWORD) -1),
    ID_LENGTH_LABEL,        IDH_DISPLAY_SCREENSAVER_BEZIERS_LENGTH,
    ID_LENGTH,              IDH_DISPLAY_SCREENSAVER_BEZIERS_LENGTH,
    ID_LENGTHARROW,         IDH_DISPLAY_SCREENSAVER_BEZIERS_LENGTH,
    ID_WIDTH_LABEL,         IDH_DISPLAY_SCREENSAVER_BEZIERS_WIDTH,
    ID_WIDTH,               IDH_DISPLAY_SCREENSAVER_BEZIERS_WIDTH,
    ID_WIDTHARROW,          IDH_DISPLAY_SCREENSAVER_BEZIERS_WIDTH,
    ID_VELOCITY,            IDH_DISPLAY_SCREENSAVER_BEZIERS_SPEED,
    ID_VELOCITY_SLOW,       IDH_DISPLAY_SCREENSAVER_BEZIERS_SPEED,
    ID_VELOCITY_FAST,       IDH_DISPLAY_SCREENSAVER_BEZIERS_SPEED,
    0,0
};

/* This is the main window procedure to be used when the screen saver is
    activated in a screen saver mode ( as opposed to configure mode ).  This
    function must be declared as an EXPORT in the EXPORTS section of the
    DEFinition file... */

LRESULT ScreenSaverProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static UINT_PTR  wTimer;
    TCHAR   szTemp[20];                     // Temporary string buffer
    int i;
    BYTE bit;

    switch (message)
    {
    case WM_CREATE:
        GetIniEntries ();
        glSeed = GetCurrentTime ();     // random number generator

        ghdc = GetDC(hWnd);

        gcxScreen =  ((LPCREATESTRUCT)lParam)->cx;
        gcyScreen =  ((LPCREATESTRUCT)lParam)->cy;

        vInitPoints();

        if (gczScreen & (1 << 14)) {
            Init(hWnd);
        } else {
            ghbrushBack = GetStockObject(BLACK_BRUSH);
            ghpenBez    = CreatePen(PS_SOLID, 0, 0xff);
            ghpenErase  = CreatePen(PS_SOLID, 0, 0);
            SelectObject(ghdc,ghpenBez);
            SelectObject(ghdc,ghbrushBack);

            vInitPalette(ghdc);
            wTimer = SetTimer (hWnd, 1, 1, NULL);
        }
        break;

    case WM_SIZE:
        gcxScreen = LOWORD(lParam);
        gcyScreen = HIWORD(lParam);
        break;

    case WM_PALETTECHANGED:
        RealizePalette(ghdc);
        break;

    case WM_QUERYNEWPALETTE:
        if (ghpal != 0)
        {
            SelectPalette(ghdc, ghpal, FALSE);
            RealizePalette(ghdc);
            InvalidateRect(hWnd, NULL, TRUE);

            return(TRUE);
        }
        else
            return(FALSE);

    case WM_PAINT:
        if (gczScreen & (1 << 14)) {
            PAINTSTRUCT paint;
            BeginPaint(hWnd, &paint);
            EndPaint(hWnd, &paint);
            fRepaint = TRUE;
        } else {
            vRedraw();
        }
        break;

    case WM_TIMER:
        if (gczScreen & (1 << 14)) {
            SetEvent(gpwindow->hWait);
        } else {
            vNextBez();
        }
        break;

    case WM_DESTROY:
        if (wTimer)
            KillTimer (hWnd, wTimer);

        if (ghpal != 0)
        {
            SelectPalette(ghdc, ghpalOld, FALSE);
            DeleteObject(ghpal);
        }
        ReleaseDC(hWnd, ghdc);
        break;
    }
    return (DefScreenSaverProc (hWnd, message, wParam, lParam));
}


//***************************************************************************

BOOL ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL    fError;                         // Error flag

    UINT    wTemp;
    TCHAR   szTemp[20];                     // Temporary string buffer
    char    szTemp2[20];                    // Temporary string buffer

    WORD    nCtlId;
    int     nVal, nOldVal;
    LONG   *plState = (LONG *) szTemp2;     // State buffer

    static HWND hVelocity,         // window handle of Speed scrollbar
                hIDOK,             // window handle of OK button
                hSetPassword,      // window handle of SetPassword button
                hNumBeziers,       // window handle of NumBezier EditControl
                hNumRings;         // window handle of NumBezier EditControl


    switch (message)
    {
    case WM_INITDIALOG:
        GetIniEntries ();        // Get initial values

        hVelocity = GetDlgItem (hDlg, ID_VELOCITY);
        hIDOK = GetDlgItem (hDlg, IDOK);
        hNumBeziers = GetDlgItem (hDlg, ID_WIDTH);
        hNumRings = GetDlgItem (hDlg, ID_LENGTH);

        SendMessage (hNumBeziers, EM_LIMITTEXT, 3, 0);
        SendMessage (hNumRings, EM_LIMITTEXT, 3, 0);
        SetScrollRange (hVelocity, SB_CTL, MINVEL, MAXVEL, FALSE);
        SetScrollPos (hVelocity, SB_CTL, giVelMax, TRUE);

        SetDlgItemInt (hDlg, ID_WIDTH, gcBez, FALSE);
        SetDlgItemInt (hDlg, ID_LENGTH, gcRingLen, FALSE);

        SendDlgItemMessage( hDlg, ID_LENGTHARROW, UDM_SETRANGE, 0, MAKELONG(MAXLENGTH, MINLENGTH));
        SendDlgItemMessage( hDlg, ID_WIDTHARROW, UDM_SETRANGE, 0, MAKELONG(MAXWIDTH, MINWIDTH));

        wsprintf (szTemp, TEXT("%d"), gcBez);
        WritePrivateProfileString (szAppName, szNumBez, szTemp, szIniFile);
        return TRUE;


    case WM_HSCROLL:
        switch (LOWORD(wParam))
        {
        case SB_PAGEUP:
            --giVelMax;
            break;

        case SB_LINEUP:
            --giVelMax;
            break;

        case SB_PAGEDOWN:
            ++giVelMax;
            break;

        case SB_LINEDOWN:
            ++giVelMax;
            break;

        case SB_THUMBPOSITION:
            giVelMax = HIWORD (wParam);
            break;

        case SB_BOTTOM:
            giVelMax = MAXVEL;
            break;

        case SB_TOP:
            giVelMax = MINVEL;
            break;

        case SB_THUMBTRACK:
        case SB_ENDSCROLL:
            return TRUE;
            break;
        }
        if ((int)giVelMax <= MINVEL)
            giVelMax = MINVEL;
        if ((int)giVelMax >= MAXVEL)
            giVelMax = MAXVEL;

        SetScrollPos ((HWND) lParam, SB_CTL, giVelMax, TRUE);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_LENGTH:
            if (HIWORD(wParam) == EN_UPDATE)
            {
                wTemp = GetDlgItemInt (hDlg, ID_LENGTH, &fError, FALSE);
                fError = ((wTemp <= MAXLENGTH) && (wTemp >= MINLENGTH));
                EnableWindow (GetDlgItem (hDlg, ID_LENGTHARROW), fError);
                EnableWindow (GetDlgItem (hDlg, IDOK), fError);
            }
            break;

        case ID_WIDTH:
            if (HIWORD(wParam) == EN_UPDATE)
            {
                wTemp = GetDlgItemInt (hDlg, ID_WIDTH, &fError, FALSE);
                fError = ((wTemp <= MAXWIDTH) && (wTemp >= MINWIDTH));
                EnableWindow (GetDlgItem (hDlg, ID_WIDTHARROW), fError);
                EnableWindow (GetDlgItem (hDlg, IDOK), fError);
            }
            break;


        case IDOK:
            wTemp = GetDlgItemInt (hDlg, ID_WIDTH, &fError, FALSE);
            wTemp |= GetPrivateProfileInt (szAppName, szNumBez, DEF_WIDTH, szIniFile) & (1 << 14);
            wsprintf (szTemp, TEXT("%d"), wTemp);

            WritePrivateProfileString (szAppName, szNumBez, szTemp, szIniFile);

            wTemp = GetDlgItemInt (hDlg, ID_LENGTH, &fError, FALSE);
            wsprintf (szTemp, TEXT("%d"), wTemp);
            WritePrivateProfileString (szAppName, szNumRings, szTemp, szIniFile);

            wsprintf (szTemp, TEXT("%d"), giVelMax);
            WritePrivateProfileString (szAppName, szLineSpeed, szTemp, szIniFile);

        case IDCANCEL:
            EndDialog (hDlg, LOWORD(wParam) == IDOK);
            return TRUE;

        }
        break;

    case WM_HELP: // F1
        WinHelp(
            (HWND) ((LPHELPINFO) lParam)->hItemHandle,
            szHelpFile,
            HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aBezDlgHelpIds
        );
        break;

    case WM_CONTEXTMENU:  // right mouse click
        WinHelp(
            (HWND) wParam,
            szHelpFile,
            HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aBezDlgHelpIds
        );
        break;

    default:
        break;
    }
    return FALSE;
}


/* This procedure is called right before the dialog box above is created in
   order to register any child windows that are custom controls.  If no
   custom controls need to be registered, then simply return TRUE.
   Otherwise, register the child controls however is convenient... */

BOOL RegisterDialogClasses (HANDLE hInst)
{
    InitCommonControls();
    return TRUE;
}


LONG GetDlgItemLong (HWND hDlg, WORD wID, BOOL *pfTranslated, BOOL fSigned)
{
    TCHAR szTemp[20];
    LPTSTR pszTemp;
    LONG lTemp = 0l;
    BOOL fNegative;

    if (!GetDlgItemText (hDlg, wID, szTemp, CharSizeOf(szTemp)))
        goto GetDlgItemLongError;

    szTemp[19] = TEXT('\0');
    pszTemp = szTemp;
    while (*pszTemp == TEXT(' ') || *pszTemp == TEXT('\t'))
        pszTemp++;
    if ((!fSigned && *pszTemp == TEXT('-')) || !*pszTemp)
        goto GetDlgItemLongError;
    fNegative = (*pszTemp == TEXT('-')) ? TRUE : FALSE;
    while (*pszTemp >= TEXT('0') && *pszTemp <= TEXT('9'))
        lTemp = lTemp * 10l + (LONG)(*(pszTemp++) - TEXT('0'));
    if (*pszTemp)
        goto GetDlgItemLongError;
    if (fNegative)
        lTemp *= -1;
    *pfTranslated = TRUE;
    return lTemp;

GetDlgItemLongError:
    *pfTranslated = FALSE;
    return 0l;
}


LONG GetPrivateProfileLong (LPTSTR pszApp, LPTSTR pszKey, LONG lDefault)
{
    LONG    lTemp = 0l;
    TCHAR   szTemp[20];
    LPTSTR  pszTemp;

    if (!GetPrivateProfileString (pszApp, pszKey, TEXT(""), szTemp, CharSizeOf(szTemp), szIniFile))
        goto GetProfileLongError;

    szTemp[19] = TEXT('\0');
    pszTemp = szTemp;
    while (*pszTemp >= TEXT('0') && *pszTemp <= TEXT('9'))
        lTemp = lTemp * 10l + (LONG)(*(pszTemp++) - TEXT('0'));
    if (*pszTemp)
        goto GetProfileLongError;
    return lTemp;

GetProfileLongError:
    return lDefault;
}


VOID GetIniEntries (VOID)
{
    LoadString (hMainInstance, idsName, szName, TITLEBARNAMELEN);
    LoadString (hMainInstance, idsAppName, szAppName, APPNAMEBUFFERLEN);

    //Load Common Strings from stringtable...
    LoadString (hMainInstance, idsIniFile, szIniFile, MAXFILELEN);
    LoadString (hMainInstance, idsScreenSaver, szScreenSaver, 22);
    LoadString (hMainInstance, idsHelpFile, szHelpFile, MAXFILELEN);
    LoadString (hMainInstance, idsNoHelpMemory, szNoHelpMemory, BUFFLEN);

    giVelMax = GetPrivateProfileInt (szAppName, szLineSpeed, DEFVEL, szIniFile);
    if (giVelMax > MAXVEL || giVelMax < MINVEL)
        giVelMax = DEFVEL;

    gcBez = GetPrivateProfileInt (szAppName, szNumBez, DEF_WIDTH, szIniFile);
    gcBez = (gczScreen = gcBez) & ~(1 << 14);

    if (gcBez > MAXWIDTH)
        gcBez = MAXWIDTH;
    if (gcBez < MINWIDTH)
        gcBez = MINWIDTH;

    gcRingLen = GetPrivateProfileInt (szAppName, szNumRings, DEF_LENGTH, szIniFile);
    if (gcRingLen > MAXLENGTH)
        gcRingLen = MAXLENGTH;
    if (gcRingLen < MINLENGTH)
        gcRingLen = MINLENGTH;
}



/************************************************************************
* Bezier code
*
* Created: 19-Oct-1990 10:18:45
* Author: Paul Butzi
*
* Copyright (c) 1990 Microsoft Corporation
*
* Generates random lines
*    Hacked from arcs.c
\**************************************************************************/


DWORD ulRandom()
{
    glSeed *= 69069;
    glSeed++;
    return(glSeed);
}


VOID vCLS()
{
    PatBlt(ghdc, 0, 0, gcxScreen, gcyScreen, PATCOPY);
}

int iNewVel(INT i)
{

    if ((gcRingLen != 1) || (i == 1) || (i == 2))
        return(ulRandom() % (giVelMax + 1 / 3) + MINVEL);
    else
        return(ulRandom() % giVelMax + MINVEL);
}



VOID vInitPoints()
{
    INT ii;

    for (ii = 0; ii < MAXLENGTH; ii++)
    {
        bezbuf[0].band[ii].apt[0].x = gcxScreen ? ulRandom() % gcxScreen : 0;
        bezbuf[0].band[ii].apt[0].y = gcyScreen ? ulRandom() % gcyScreen : 0;
        bezbuf[0].band[ii].apt[1].x = gcxScreen ? ulRandom() % gcxScreen : 0;
        bezbuf[0].band[ii].apt[1].y = gcyScreen ? ulRandom() % gcyScreen : 0;

        aVel[ii][0].x = iNewVel(ii) * ((ulRandom() & 0x10) ? 1 : -1);
        aVel[ii][0].y = iNewVel(ii) * ((ulRandom() & 0x10) ? 1 : -1);
        aVel[ii][1].x = iNewVel(ii) * ((ulRandom() & 0x11) ? 1 : -1);
        aVel[ii][1].y = iNewVel(ii) * ((ulRandom() & 0x10) ? 1 : -1);
    }

    gpBez = bezbuf;
}


VOID vRedraw()
{
    INT j;

    for ( j = 0; j < gcBez; j += 1 )
    {
        bezbuf[j].bDrawn = FALSE;
    }

    vCLS();
    gpBez = bezbuf;
    gbPointsDrawn = FALSE;
}


/******************************Public*Routine******************************\
* VOID vDrawBand(pbez)
*
* History:
*  14-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vDrawBand(PBEZ pbez)
{
    INT    ii;
    INT    iNext;
    PPOINT ppt;

// If only drawing one Bezier, special case it:

    if (gcRingLen == 1)
    {
        aPts[0] = pbez->band[0].apt[0];
        aPts[1] = pbez->band[0].apt[1];
        aPts[2] = pbez->band[1].apt[0];
        aPts[3] = pbez->band[1].apt[1];
    }
    else
    {

    // Do the elastic band effect, with 2nd order continuity:

        aPts[0].x = (pbez->band[0].apt[0].x + pbez->band[0].apt[1].x) >> 1;
        aPts[0].y = (pbez->band[0].apt[0].y + pbez->band[0].apt[1].y) >> 1;

        ppt = &aPts[1];

        for (ii = 0; ii < gcRingLen; ii++)
        {
            iNext = (ii + 1) % gcRingLen;

            *ppt++ = pbez->band[ii].apt[1];
            *ppt++ = pbez->band[iNext].apt[0];

            ppt->x = (pbez->band[iNext].apt[0].x + pbez->band[iNext].apt[1].x) >> 1;
            ppt->y = (pbez->band[iNext].apt[0].y + pbez->band[iNext].apt[1].y) >> 1;
            ppt++;
        }
    }

    PolyBezier(ghdc, aPts, gcRingLen * 3 + 1);
}


/******************************Public*Routine******************************\
* VOID vNextBez()
*
\**************************************************************************/

VOID vNextBez()
{
    INT ii;
    INT jj;

    PBEZ obp = gpBez++;

    if ( gpBez >= &bezbuf[gcBez] )
        gpBez = bezbuf;

// If bezier on screen, erase by redrawing:

    if (gpBez->bDrawn)
    {
        if (gbCopy)
            SelectObject(ghdc, ghpenErase);

        vDrawBand(gpBez);
    }

// Adjust points:

    for (ii = 0; ii < MAX(gcRingLen, 2); ii++)
    {
        for (jj = 0; jj < 2; jj++)
        {
            register INT x, y;

            x = obp->band[ii].apt[jj].x;
            y = obp->band[ii].apt[jj].y;

            x += aVel[ii][jj].x;
            y += aVel[ii][jj].y;

            if ( x >= gcxScreen )
            {
                x = gcxScreen - ((x - gcxScreen) + 1);
                aVel[ii][jj].x = - iNewVel(ii);
            }
            if ( x < 0 )
            {
                x = - x;
                aVel[ii][jj].x = iNewVel(ii);
            }
            if ( y >= gcyScreen )
            {
                y = gcyScreen - ((y - gcyScreen) + 1);
                aVel[ii][jj].y = - iNewVel(ii);
            }
            if ( y < 0 )
            {
                y = - y;
                aVel[ii][jj].y = iNewVel(ii);
            }

            gpBez->band[ii].apt[jj].x = x;
            gpBez->band[ii].apt[jj].y = y;
        }
    }

    vNewColor();

    if (gbCopy)
        SelectObject(ghdc, ghpenBez);

    vDrawBand(gpBez);
    gpBez->bDrawn = TRUE;
}


ULONG iGet()
{
    static int i = 0;
           int j;
    if (++i >= cstr)
        i = 1;
    j = i;
    while (astr[i].f == gf) {i = (i % (cstr - 1)) + 1; if (i == j) gf = ~gf;}
    astr[i].f = ~astr[i].f;
    return(i);
}

VOID vInitPalette(HDC hdc)
{
    LOGPALETTE    lp;
    HPALETTE      hpalOld = 0;
    PALETTEENTRY *ppal;
    LONG          cBitsPerPel;
    LONG          i;
    LONG          j;

    cBitsPerPel = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    gbPalette = (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) > 0;

    if (gbPalette)
    {
    // Try and realize a palette with one palette entry reserved:

        lp.palVersion             = 0x300;
        lp.palNumEntries          = 1;
        lp.palPalEntry[0].peFlags = PC_RESERVED;

        ghpal = CreatePalette(&lp);
        if (ghpal != 0)
        {
            ghpalOld = SelectPalette(hdc, ghpal, FALSE);
            RealizePalette(ghdc);
        }
    }

    if (!gbPalette && cBitsPerPel <= 4)
    {
    // If on a wimpy device, simply cycle through the 'dark' colors of
    // its palette, skipping black because it's boring:

        gcpal = GetSystemPaletteEntries(hdc, 1, NUM_PALETTE_ENTRIES, &gapal[0]);
        if (gcpal == 0)
        {
        // Worst comes to worst, always use a white pen:

            gcpal = 1;
            gapal[0].peRed   = 255;
            gapal[0].peGreen = 255;
            gapal[0].peBlue  = 255;
            gapal[0].peFlags = 0;
        }

        gipal      = 8 % gcpal;     // Start with red
        gcMaxTicks = MAX_TICKS_WIMPY;
        gcTicker   = 0;

        return;
    }

// At this point, we either have a palette managed or high color device.

    ppal = &gapal[0];
    for (i = 0; i < NUM_PALETTE_ENTRIES; i++)
    {
        for (j = 0; j < FADE_RESOLUTION; j++)
        {
            ppal->peRed   = (BYTE)(gapalDefault[i].peRed +
                (j * (gapalDefault[i + 1].peRed   - gapalDefault[i].peRed))
                / FADE_RESOLUTION);
            ppal->peGreen = (BYTE)(gapalDefault[i].peGreen +
                (j * (gapalDefault[i + 1].peGreen - gapalDefault[i].peGreen))
                / FADE_RESOLUTION);
            ppal->peBlue = (BYTE)(gapalDefault[i].peBlue +
                (j * (gapalDefault[i + 1].peBlue  - gapalDefault[i].peBlue))
                / FADE_RESOLUTION);
            ppal->peFlags = PC_RESERVED;
            ppal++;
        }
    }

    gcpal      = (NUM_PALETTE_ENTRIES - 1) * FADE_RESOLUTION;
    gipal      = 0;
    gcMaxTicks = MAX_TICKS_COOL;
    gcTicker   = 0;

    if (gbPalette)
    {
    // Create a pen that maps to logical palette index zero:

        SelectObject(hdc, GetStockObject(BLACK_PEN));
        DeleteObject(ghpenBez);
        ghpenBez = CreatePen(0, 0, PALETTEINDEX(0));
        SelectObject(hdc, ghpenBez);
    }

    return;
}

VOID vNewColor(VOID)
{
    HPEN hpen;

    if (--gcTicker <= 0)
    {
        if (gbPalette)
        {
            AnimatePalette(ghpal, 0, 1, &gapal[gipal]);
        }
        else
        {
            if (gbCopy)
            {
                hpen = CreatePen(0, 0, RGB(gapal[gipal].peRed,
                                           gapal[gipal].peGreen,
                                           gapal[gipal].peBlue));

                SelectObject(ghdc, hpen);
                DeleteObject(ghpenBez);
                ghpenBez = hpen;
            }
        }

        gcTicker = gcMaxTicks;
        if (--gipal < 0)
            gipal = gcpal - 1;
    }

    return;
}

/****************************************************************************/

typedef struct _DOT {
    int xm, ym, zm;
    int xn, yn, zn;
    int color;
} DOT, *PDOT;

typedef struct _LIST *PLIST;
typedef struct _LIST {
    PLIST pnext;
    PLIST plistComplete;
    PSZ psz;
} LIST;

#define MAXFIXED (65536)

#define AXISSIZE 150
#define XSIZE (gcxScreen)
#define YSIZE (gcyScreen)
#define XSIZE2 (XSIZE / 2)
#define YSIZE2 (YSIZE / 2)
#define SCANSIZE ((8 * XSIZE + 31) & ~31) / 8
#define PI (3.141529)

#define MAXANGLE (360 * 10)

/****************************************************************************/

int *icos;
int *isin;

/****************************************************************************/

void ClearRect(
    PBYTE pstart,
    PRECT prc)
{
    PBYTE pdst;
    int length, y;

    pdst = pstart + SCANSIZE * prc->top + prc->left;
    length = prc->right - prc->left;

    for (y = prc->top; y < prc->bottom; y++) {
         memset(pdst, 0, length);
         pdst += SCANSIZE;
    }
}

/****************************************************************************/

void UnionRects(
    PRECT prcDest,
    PRECT prc)
{
    if (prc->left   < prcDest->left)   prcDest->left = prc->left;
    if (prc->right  > prcDest->right)  prcDest->right = prc->right;
    if (prc->top    < prcDest->top)    prcDest->top = prc->top;
    if (prc->bottom > prcDest->bottom) prcDest->bottom = prc->bottom;
}

/****************************************************************************/

__inline int WrapPlus(
    int deg,
    int range)
{
    return  deg >= range
      ? deg - range
      : deg;
}

__inline int WrapMinus(
    int deg,
    int range)
{
    return   deg < 0
        ? deg + range
        : deg;
}

__inline int Bound(
    int deg,
    int range)
{
    return WrapMinus(WrapPlus(deg, range), range);
}

/****************************************************************************/

int RandomInt(
    int min,
    int max)
{
    int dx = max - min;
    int mask = 1;
    int value;

    while (mask < dx) {
        mask = (mask << 1) + 1;
    }

    while ((value = (rand() & mask) + min) > max) ;
    return value;
}

/****************************************************************************/

#define NUMDOTS 1500

PDOT adot;

void InitDrawShaded(
    PWINDOW pwindow)
{
    int d0, d1;
    int c0, c1, s0, s1;
    int i;
    int x, y, z;

    pwindow->rcDraw.left = 0;
    pwindow->rcDraw.right = 0;
    pwindow->rcDraw.top = 0;
    pwindow->rcDraw.bottom = 0;

    for (i = 0; i < NUMDOTS; i++) {
        PDOT pdot = adot + i;

        pdot->xm = 1 * AXISSIZE / 4;
        pdot->ym = 0;
        pdot->zm = 0;

        d0 = RandomInt(0, MAXANGLE / 2);
        d1 = RandomInt(0, MAXANGLE - 1);

        c0 = icos[d0];
        s0 = isin[d0];
        c1 = icos[d1];
        s1 = isin[d1];

        x = (pdot->zm * s0 + pdot->xm * c0) / MAXFIXED;
        z = (pdot->zm * c0 - pdot->xm * s0) / MAXFIXED;

        y = (z * s1 + pdot->ym * c1) / MAXFIXED;
        z = (z * c1 - pdot->ym * s1) / MAXFIXED;

        pdot->xm = x;
        pdot->ym = y;
        pdot->zm = z;

        pdot->xn = 0;
        pdot->yn = 0;
        pdot->zn = 0;
    }
}


/****************************************************************************/

#define DELTA0 47
#define DELTA1 30
#define DELTA2 40

void DrawFrameShaded(
    PWINDOW pwindow)
{
    static int deg0 = 0, deg1 = 0, deg2 = 0, deg3 = 0;
    int i, j;
    int c0, c1, sizetext;
    int s0, s1, sizeball;
    int x, y, z;
    int xs, ys, zs;
    PBYTE pdata = pwindow->pdata;
    BYTE color;
    int d0, d1, d2;
    PRECT prc = &(pwindow->rcDraw);

    ClearRect(pwindow->pdata, &(pwindow->rcDraw));

    pwindow->rcBlt = pwindow->rcDraw;

    prc->left = XSIZE;
    prc->right = 0;
    prc->top = YSIZE;
    prc->bottom = 0;

    //
    // draw this frame
    //

    for (j = 0; j < 1; j++) {
        d0 = WrapPlus(deg0 + j * DELTA0, MAXANGLE);
        d0 = Bound((icos[d0] * MAXANGLE / 2) / MAXFIXED, MAXANGLE);
        c0 = icos[d0];
        s0 = isin[d0];

        d1 = WrapPlus(deg1 + j * DELTA1, MAXANGLE);
        c1 = icos[d1];
        s1 = isin[d1];

        d2 = WrapPlus(deg2 + MAXANGLE * 3 / 4, MAXANGLE);

        sizeball = (icos[d2] + MAXFIXED) / 2;
        sizetext = (isin[d2] + MAXFIXED) / 2;

        color = 245;

        /*
         * rotate verticies
         */
        for (i = 0; i < NUMDOTS; i++) {
            PDOT pdot = adot + i;
            PBYTE pbyte;

            xs = pdot->xm;
            ys = pdot->ym;
            zs = pdot->zm;

            x = (zs * s0 + xs * c0) / MAXFIXED;
            z = (zs * c0 - xs * s0) / MAXFIXED;

            y = (z * s1 + ys * c1) / MAXFIXED;
            z = (z * c1 - ys * s1) / MAXFIXED;

            x = (x * sizeball + pdot->xn * sizetext) / MAXFIXED;
            y = (y * sizeball + pdot->yn * sizetext) / MAXFIXED;
            z = (z * sizeball + pdot->zn * sizetext) / MAXFIXED;

            x += XSIZE2;
            y += YSIZE2;

            if (x < 0)         x = 0;
            if (x > XSIZE - 2) x = XSIZE - 2;
            if (y < 0)         y = 0;
            if (y > YSIZE - 2) y = YSIZE - 2;

            if (x < prc->left) prc->left = x;
            if (x+2 > prc->right) prc->right = x+2;

            if (y < prc->top) prc->top = y;
            if (y+2 > prc->bottom) prc->bottom = y+2;

            pbyte = pdata + x + y * SCANSIZE;

            pbyte[0] = color;
            pbyte[1] = color;
            pbyte[SCANSIZE] = color;
            pbyte[SCANSIZE + 1] = color;
        }
    }

    //
    // next frame
    //

    deg0 = WrapPlus(deg0 + DELTA0, MAXANGLE);
    deg1 = WrapPlus(deg1 + DELTA1, MAXANGLE);

    deg2 -= DELTA2;
    if (deg2 < 0) {
        deg2 += MAXANGLE;
    }

    UnionRects(&(pwindow->rcBlt), &(pwindow->rcDraw));
    pwindow->xDelta = pwindow->rcBlt.left;
    pwindow->yDelta = pwindow->rcBlt.top;
}

/****************************************************************************/

void InitDrawingThread(
    PWINDOW pwindow)
{
    int i;

    for (i = 0; i < MAXANGLE; i++) {
        double rad = i * (2.0 * PI / MAXANGLE);
        icos[i] = (int)(cos(rad) * MAXFIXED);
        isin[i] = (int)(sin(rad) * MAXFIXED);
    }
}

/****************************************************************************/

void BltThread(
    PWINDOW pwindow)
{
    PRECT prc = &(pwindow->rcBlt);

    GdiSetBatchLimit(1);
    InitDrawingThread(pwindow);
    InitDrawShaded(pwindow);

    while (TRUE) {
        if (fRepaint) {
            RECT rc;
            rc.left = 0;
            rc.right = pwindow->xsize;
            rc.top = 0;
            rc.bottom = pwindow->ysize;
            FillRect(pwindow->hdc, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH));
            fRepaint = FALSE;
        }

        DrawFrameShaded(pwindow);

        BitBlt(
            pwindow->hdc,
            prc->left, prc->top,
            prc->right - prc->left, prc->bottom - prc->top,
            pwindow->hdcBitmap,
            pwindow->xDelta,
            pwindow->yDelta, SRCCOPY);

        WaitForSingleObject(pwindow->hWait, INFINITE);
    }
}

/****************************************************************************/

void vCleanSystemPalette(HDC hdc)
{
    HPALETTE hpal,hpalOld;
    DWORD aTemp[257];
    LPLOGPALETTE lpLogPal;
    UCHAR iTemp;

    lpLogPal = (LPLOGPALETTE) aTemp;
    lpLogPal->palVersion = 0x300;
    lpLogPal->palNumEntries = 256;

    for (iTemp = 0; iTemp < 256; iTemp++)
    {
        lpLogPal->palPalEntry[iTemp].peRed   = 0;
        lpLogPal->palPalEntry[iTemp].peGreen = 0;
        lpLogPal->palPalEntry[iTemp].peBlue  = iTemp;
        lpLogPal->palPalEntry[iTemp].peFlags = PC_RESERVED;
    }

    hpal = CreatePalette(lpLogPal);
    hpalOld = SelectPalette(hdc, hpal, 0);
    RealizePalette(hdc);
    SelectPalette(hdc, hpalOld, 0);
    DeleteObject(hpal);
}

/****************************************************************************/

BOOL InitDibSection(
    PWINDOW pwindow,
    RGBQUAD* ppal,
    BOOL fSystemPalette)
{
    LPLOGPALETTE plp = (LPLOGPALETTE)LocalAlloc(LPTR, sizeof(LOGPALETTE) + 4 * 256);
    LPBITMAPINFO pbmi = (LPBITMAPINFO)LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + 4 * 256);
    int i;
    UCHAR iTemp;
    PUSHORT pw;
    LOGFONT lf;
    HFONT hfont;

    if(plp == NULL || pbmi == NULL)
    {
        return FALSE;
    }

    plp->palVersion = 0x300;
    plp->palNumEntries = 256;

    if (fSystemPalette) {
        GetPaletteEntries((HPALETTE)GetStockObject(DEFAULT_PALETTE),
                          0, 1, plp->palPalEntry);
        GetPaletteEntries((HPALETTE)GetStockObject(DEFAULT_PALETTE),
                          255, 1, &plp->palPalEntry[255]);
        for (i = 1; i < 254; i++) {
            plp->palPalEntry[i].peRed   = ppal[i].rgbRed;
            plp->palPalEntry[i].peGreen = ppal[i].rgbGreen;
            plp->palPalEntry[i].peBlue  = ppal[i].rgbBlue;
            plp->palPalEntry[i].peFlags = PC_NOCOLLAPSE;
        }
        SetSystemPaletteUse(pwindow->hdc, SYSPAL_NOSTATIC);
    } else {
        GetPaletteEntries((HPALETTE)GetStockObject(DEFAULT_PALETTE),
                          0, 10, plp->palPalEntry);
        GetPaletteEntries((HPALETTE)GetStockObject(DEFAULT_PALETTE),
                          246, 10, &plp->palPalEntry[255]);

        for (i = 10; i < 246; i++) {
            plp->palPalEntry[i].peRed   = ppal[i].rgbRed;
            plp->palPalEntry[i].peGreen = ppal[i].rgbGreen;
            plp->palPalEntry[i].peBlue  = ppal[i].rgbBlue;
            plp->palPalEntry[i].peFlags = PC_NOCOLLAPSE;
        }
    }

    pwindow->hpalette = CreatePalette(plp);
    vCleanSystemPalette(pwindow->hdc);
    SelectPalette(pwindow->hdc, pwindow->hpalette, FALSE);
    RealizePalette(pwindow->hdc);

    pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth         = XSIZE;
    pbmi->bmiHeader.biHeight        = -YSIZE;
    pbmi->bmiHeader.biPlanes        = 1;
    pbmi->bmiHeader.biBitCount      = 8;
    pbmi->bmiHeader.biCompression   = BI_RGB;
    pbmi->bmiHeader.biSizeImage     = 0;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed       = 0;
    pbmi->bmiHeader.biClrImportant  = 0;

    pw = (PUSHORT)(pbmi->bmiColors);
    for (iTemp=0; iTemp<256; iTemp++) {
        pw[iTemp] = iTemp;
    }

    pwindow->hbitmap = CreateDIBSection(
        pwindow->hdc, pbmi, DIB_PAL_COLORS,
        (PVOID*)&(pwindow->pdata), 0, 0);
    pwindow->hdcBitmap = CreateCompatibleDC(pwindow->hdc);
    SelectObject(pwindow->hdcBitmap, pwindow->hbitmap);

    lf.lfHeight = 30;
    lf.lfWidth = 0;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfWeight = 400;
    lf.lfItalic = FALSE;
    lf.lfUnderline = FALSE;
    lf.lfStrikeOut = FALSE;
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE;
    lstrcpy(lf.lfFaceName, TEXT("Arial"));

    hfont = CreateFontIndirect(&lf);

    pwindow->hbitmapText = CreateDIBSection(
        pwindow->hdc, pbmi, DIB_PAL_COLORS,
        (PVOID*)&(pwindow->pdataText), 0, 0);
    pwindow->hdcText = CreateCompatibleDC(pwindow->hdcText);
    SelectObject(pwindow->hdcText, pwindow->hbitmapText);
    SelectObject(pwindow->hdcText, hfont);

    return TRUE;
}

/****************************************************************************/

BOOL Init(
    HWND hwnd)
{
    int i;
    RGBQUAD apal[256];
    DWORD tid;

    srand(GetTickCount());

    adot = (PDOT) LocalAlloc(LPTR, sizeof(DOT) * NUMDOTS);
    isin = (int *) LocalAlloc(LPTR, sizeof(int) * MAXANGLE);
    icos = (int *) LocalAlloc(LPTR, sizeof(int) * MAXANGLE);

    gpwindow = (PWINDOW) LocalAlloc(LPTR, sizeof(WINDOW));

    if(adot == NULL || isin == NULL || icos == NULL || gpwindow == NULL)
        return FALSE;

    gpwindow->hwnd = hwnd;
    gpwindow->xsize = gcxScreen;
    gpwindow->ysize = gcyScreen;

    gpwindow->hdc = ghdc;
    SetBkColor(gpwindow->hdc, 0);
    SetTextColor(gpwindow->hdc, RGB(0xff, 0xff, 0xff));

    gpwindow->hWait = CreateEvent(NULL, FALSE, FALSE, NULL);
    SetTimer(gpwindow->hwnd, 1, 1000 / 20, NULL);

    for (i = 0; i < 236; i++) {
        apal[i + 10].rgbRed   = (i * 255) / 235;
        apal[i + 10].rgbGreen = (i * 255) / 235;
        apal[i + 10].rgbBlue  = (i * 255) / 235;
    }

    if(!InitDibSection(gpwindow, apal, FALSE))
        return FALSE;

    CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)BltThread,
        gpwindow,
        0,
        &tid);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\common\comstrin.h ===
#define idsIniFile              1001
#define idsScreenSaver          1002
#define idsAppName              1007
#define idsNoHelpMemory         1008
#define idsHelpFile             1009

#define DLG_SCRNSAVECONFIGURE   2003

#include "cphelp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\common\scrnsave.c ===
//----------------------------------------------------------------------------
//
// SCRNSAVE.C      --    skeleton for screen saver application
//
//    4/5/94 francish   merged NT and Win4 saver code, folded in SCRNSAVE.SCR
//
//----------------------------------------------------------------------------

#define WIN31
#include <windows.h>
#include <windowsx.h>
#include "scrnsave.h"
#include <regstr.h>
#include <commctrl.h>
#include <imm.h>

#define DBG_MSGS    0

const TCHAR szScreenSaverKey[] = REGSTR_PATH_SCREENSAVE;
TCHAR szPasswordActiveValue[] = REGSTR_VALUE_USESCRPASSWORD;
const TCHAR szPasswordValue[] = REGSTR_VALUE_SCRPASSWORD;
TCHAR szPwdDLL[] = TEXT("PASSWORD.CPL");
CHAR szFnName[] = "VerifyScreenSavePwd";        // Proc name, must be ANSI
TCHAR szImmDLL[] = TEXT("IMM32.DLL");
CHAR szImmFnc[] = "ImmAssociateContext";        // Proc name, must be ANSI
#if 0
TCHAR szCoolSaverHacks[] = REGSTR_PATH_SETUP TEXT("\\Screen Savers");
TCHAR szMouseThreshold[] = TEXT("Mouse Threshold");
TCHAR szPasswordDelay[] = TEXT("Password Delay");
#endif

typedef BOOL (FAR PASCAL * VERIFYPWDPROC) (HWND);
typedef HIMC (FAR PASCAL * IMMASSOCPROC) (HWND,HIMC);


//----------------------------------------------------------------------------
// variables declared in SCRNSAVE.H
HINSTANCE hMainInstance = 0;
HWND hMainWindow = 0;
BOOL fChildPreview = FALSE;



//----------------------------------------------------------------------------
// other globals
POINT ptMouse;
BOOL fClosing = FALSE;
BOOL fCheckingPassword = FALSE;
HINSTANCE hInstPwdDLL = NULL;
VERIFYPWDPROC VerifyPassword = NULL;
static BOOL preview_like_fullscreen = FALSE;
static UINT uShellAutoPlayQueryMessage = 0;
HINSTANCE hInstImm = NULL;
IMMASSOCPROC ImmFnc = NULL;
HIMC hPrevImc = (HIMC)0L;


static BOOL fOnWin95 = FALSE;  //TRUE if on Chicago, FALSE if on Cairo

//----------------------------------------------------------------------------
// random junk
DWORD dwWakeThreshold = 4;  //default to slight movement
DWORD dwPasswordDelay = 0;
DWORD dwBlankTime = 0;
#define MAX_PASSWORD_DELAY_IN_SECONDS (60)

BYTE  bACLineStatus = AC_LINE_UNKNOWN;    // Last state of AC line 

//----------------------------------------------------------------------------
// forward declarations of internal fns
static INT_PTR DoScreenSave( HWND hParent );
static INT_PTR DoSaverPreview( LPCTSTR szUINTHandle );
static INT_PTR DoConfigBox( HWND hParent );
static INT_PTR DoChangePw( LPCTSTR szUINTHandle );
static BOOL DoPasswordCheck( HWND hParent );
VOID LoadPwdDLL(VOID);
VOID UnloadPwdDLL(VOID);


//----------------------------------------------------------------------------
// helper for time
static DWORD
GetElapsedTime(DWORD from, DWORD to)
{
    return (to >= from)? (to - from) : (1 + to + (((DWORD)-1) - from));
}

//----------------------------------------------------------------------------
// helper to convert text to unsigned int
static UINT_PTR
atoui( LPCTSTR szUINT )
{
   UINT_PTR uValue = 0;

   while( ( *szUINT >= TEXT('0') ) && ( *szUINT <= TEXT('9') ) )
      uValue = ( ( uValue * 10 ) + ( *szUINT++ - TEXT('0') ) );

   return uValue;
}


//----------------------------------------------------------------------------
// Local reboot and hotkey control (on Win95)
static void
HogMachine( BOOL value )
{
    BOOL dummy;

    //
    // NT is always secure, therefore we don't need to call this on Cairo/NT
    //
    if (fOnWin95) {
        SystemParametersInfo( SPI_SCREENSAVERRUNNING, value, &dummy, 0 );
    }
}


//----------------------------------------------------------------------------
// entry point (duh)
INT_PTR PASCAL
WinMainN( HINSTANCE hInst, HINSTANCE hPrev, LPTSTR szCmdLine, int nCmdShow )
{
    LPCTSTR pch = szCmdLine;
    HWND hParent = 0;
    OSVERSIONINFO osvi;
    INITCOMMONCONTROLSEX icce = {0};

    ZeroMemory(&icce, sizeof(icce));
    icce.dwSize = sizeof(icce);
    icce.dwICC = ICC_TAB_CLASSES;
    InitCommonControlsEx(&icce);

    hMainInstance = hInst;

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    fOnWin95 = (GetVersionEx(&osvi) &&
                osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

    _try
    {
      for(;;) switch( *pch )
      {
          case TEXT('S'):
          case TEXT('s'):
              return DoScreenSave( NULL );

          case TEXT('L'):
          case TEXT('l'):
              // special switch for tests such as WinBench
              // this is NOT a hack to make bechmarks look good
              // it's a hack to allow you to benchmark a screen saver
              // many bechmarking apps require the whole screen in foreground
              // which makes it hard to measure how a screensaver adds CPU load
              // you must provide a parent window (just like preview mode)
              preview_like_fullscreen = TRUE;
          case TEXT('P'):
          case TEXT('p'):
              do pch++; while( *pch == TEXT(' ') );  // skip to the good stuff
              return DoSaverPreview( pch );

          case TEXT('A'):
          case TEXT('a'):
              if (!fOnWin95)
                  return -1;
              do pch++; while( *pch == TEXT(' ') );  // skip to the good stuff
              return DoChangePw( pch );

          case TEXT('C'):
          case TEXT('c'): {
              HWND hwndParent = NULL
              ;
              // Look for optional parent window after the "C",
              // syntax is "C:hwnd_value"
              if (*(++pch) == TEXT(':')) {
                   hwndParent = (HWND)atoui( ++pch );
              }

              if (hwndParent == NULL || !IsWindow(hwndParent))
                   hwndParent = GetForegroundWindow();

              return DoConfigBox( hwndParent );
          }

          case TEXT('\0'):
              return DoConfigBox( NULL );

          case TEXT(' '):
          case TEXT('-'):
          case TEXT('/'):
              pch++;   // skip spaces and common switch prefixes
              break;

          default:
              return -1;
      }
    }
    _except(UnhandledExceptionFilter(GetExceptionInformation()))
    {
      // don't leave local reboot and hotkeys disabled on Win95
      HogMachine( FALSE );
    }

    return -1;
}


//----------------------------------------------------------------------------
// default screen-saver proc, declared in SCRNSAVE.H
// intended to be called by the consumer's ScreenSaverProc where
// DefWindowProc would normally be called
LRESULT WINAPI
DefScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
#if DBG_MSGS
    TCHAR szBuff[1025];

    //  safe to call wsprintf with > 1024 buffer
    wsprintf( szBuff, TEXT("*** DefSSP received:\t0x%04lx 0x%08lx 0x%08lx\n"), uMsg, wParam, lParam );
    OutputDebugString(szBuff);
#endif
    SYSTEM_POWER_STATUS sps;
    BYTE bCurrentLineStatus;

   if( !fChildPreview && !fClosing )
   {
      switch( uMsg )
      {
         case WM_CLOSE:
            //
            // Only do password check if on Windows 95.  WinNT (Cairo) has
            // the password check built into the security desktop for
            // C2 compliance.
            //
            if (fOnWin95) {
                if( !DoPasswordCheck( hWnd ) )
                {
                    GetCursorPos( &ptMouse );  // re-establish
                    return FALSE;
                }
            }
            break;

         case SCRM_VERIFYPW:
            if (fOnWin95)
                return ( VerifyPassword? (LRESULT)VerifyPassword( hWnd ) : 1L );
            break;

         default:
         {
            POINT ptMove, ptCheck;

            if( fCheckingPassword )
                break;

            switch( uMsg )
            {
                case WM_SHOWWINDOW:
                    if( (BOOL)wParam )
                    SetCursor( NULL );
                    break;

                case WM_SETCURSOR:
                    SetCursor( NULL );
                    return TRUE;

                case WM_MOUSEMOVE:
                    GetCursorPos( &ptCheck );
                    if( ( ptMove.x = ptCheck.x - ptMouse.x ) && ( ptMove.x < 0 ) )
                        ptMove.x *= -1;
                    if( ( ptMove.y = ptCheck.y - ptMouse.y ) && ( ptMove.y < 0 ) )
                        ptMove.y *= -1;
                    if( ((DWORD)ptMove.x + (DWORD)ptMove.y) > dwWakeThreshold )
                    {
                        PostMessage( hWnd, WM_CLOSE, 0, 0l );
                        ptMouse = ptCheck;
                    }
                    break;


                //
                // Handle Power Management event
                //
                case WM_POWERBROADCAST:
                    switch (wParam)
                    {
                        case PBT_APMPOWERSTATUSCHANGE:
                        if (GetSystemPowerStatus(&sps)) {
                            bCurrentLineStatus = sps.ACLineStatus;
                        }
                        else {
                            // we can't determine the power status, use default
                            bCurrentLineStatus = AC_LINE_UNKNOWN;
                        }

                        // If the current line status differs from the previous
                        // exit the screen saver, otherwise just keep running
                        if (bCurrentLineStatus != bACLineStatus) {
                            bACLineStatus = bCurrentLineStatus;
                            goto PostClose;
                        }
                        else {
                            bACLineStatus = bCurrentLineStatus;
                        }

                        break;

                        case PBT_APMRESUMECRITICAL:
                        case PBT_APMRESUMESUSPEND:
                        case PBT_APMRESUMESTANDBY:
                        case PBT_APMRESUMEAUTOMATIC:

                        // If the system is resuming from a real suspend
                        // (as opposed to a failed suspend) deactivate
                        // the screensaver.
                        if ((lParam & PBTF_APMRESUMEFROMFAILURE) == 0)
                        {
                            goto PostClose;
                        }
                        break;

                        default:
                        {
                            goto PostClose;
                        }
                    }
                    break;

                case WM_POWER:
                    //
                    // a critical resume does not generate a WM_POWERBROADCAST
                    // to windows for some reason, but it does generate an old
                    // WM_POWER message.
                    //
                    if (wParam == PWR_CRITICALRESUME)
                        goto PostClose;
                    break;

                case WM_ACTIVATEAPP:
                    if( wParam ) break;
                case WM_LBUTTONDOWN:
                case WM_MBUTTONDOWN:
                case WM_RBUTTONDOWN:
                case WM_KEYDOWN:
                case WM_SYSKEYDOWN:
PostClose:
                    PostMessage( hWnd, WM_CLOSE, 0, 0l );
                    break;
            }
         }
      }
   }

   //
   // the shell sends this message to the foreground window before running an
   // AutoPlay app. On Win95, we return 1 to cancel autoplay if we are password protected
   //
   // On WinNT, secure screen savers run on a secure separate desktop, and will never see
   // this message, therefore, this code will never get executed.
   //
   //
   // APPCOMPAT -
   // On NT we don't want to take down the screen saver unless it is running
   // on the same desktop as the autoplay shell.  There is code in the
   // NT autoplay shell that looks for this and does not run the app if
   // that is the case; however, I not positive that the uShellAutoPlayQueryMessage
   // will not go between desktops.  (BradG assures me that it will not, but you
   // never know.)  If secure screensavers on NT randomly close when you put
   // an autoplay cd in the drive, then this code should be examined closely.
   //
   if ((uMsg == uShellAutoPlayQueryMessage) && uMsg)
   {
      PostMessage(hWnd, WM_CLOSE, 0, 0L);
      return (VerifyPassword != NULL);
   }

   return DefWindowProc( hWnd, uMsg, wParam, lParam );
}

//----------------------------------------------------------------------------
// This window procedure takes care of important stuff before calling the
// consumer's ScreenSaverProc.  This helps to prevent us from getting hosed
// by wacky consumer code.
LRESULT WINAPI
RealScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
   switch( uMsg )
   {
      case WM_CREATE:
         // screen saver does not need the IME
         if ((hInstImm = GetModuleHandle(szImmDLL)) &&
             (ImmFnc = (IMMASSOCPROC)GetProcAddress(hInstImm,szImmFnc)))
             hPrevImc = ImmFnc(hWnd, (HIMC)0);

         // establish the mouse position
         GetCursorPos( &ptMouse );

         if( !fChildPreview )
            SetCursor( NULL );

         break;

      case WM_DESTROY:
         // screen saver does not need the IME
         if( hInstImm && ImmFnc && hPrevImc )
            ImmFnc(hWnd, hPrevImc);

         PostQuitMessage( 0 );
         break;

      case WM_SETTEXT:
         // don't let some fool change our title
         // we need to be able to use FindWindow() to find running instances
         // of full-screen windows screen savers
         // NOTE: USER slams our title in during WM_NCCREATE by calling the
         // defproc for WM_SETTEXT directly, so the initial title will get
         // there.  If this ever changes, we can simply set a bypass flag
         // during WM_NCCREATE processing.
         return FALSE;

      case WM_SYSCOMMAND:
         if (!fChildPreview)
         {
            switch (wParam)
            {
               case SC_NEXTWINDOW:       // no Alt-tabs
               case SC_PREVWINDOW:       // no shift-alt-tabs
               case SC_SCREENSAVE:       // no more screensavers
                  return FALSE;
                  break;
                case SC_MONITORPOWER:
                  //
                  // The monitor is shutting down.  Tell our client that he needs to
                  // cleanup and exit.
                  //
                  PostMessage( hWnd, WM_CLOSE, 0, 0l );
                  break;
            }
         }
         break;

      case WM_HELP:
      case WM_CONTEXTMENU:
         if( fChildPreview )
         {
            // if we're in preview mode, pump the help stuff to our owner
            HWND hParent = GetParent( hWnd );

            if( hParent && IsWindow( hParent ) )
               PostMessage( hParent, uMsg, (WPARAM)hParent, lParam );
               return TRUE;
         }
         break;

      case WM_TIMER:
         if( fClosing )
            return FALSE;
         Sleep( 0 );
         break;

      case WM_MOUSEMOVE:
      case WM_LBUTTONDOWN:
      case WM_MBUTTONDOWN:
      case WM_RBUTTONDOWN:
      case WM_KEYDOWN:
      case WM_SYSKEYDOWN:
         if( fClosing )
            return DefWindowProc( hWnd, uMsg, wParam, lParam );
         break;

      case WM_PAINT:
         if( fClosing )
            return DefWindowProc( hWnd, uMsg, wParam, lParam );
         if( !fChildPreview )
            SetCursor( NULL );
         break;
   }

   return ScreenSaverProc( hWnd, uMsg, wParam, lParam );
}

static void
InitRealScreenSave()
{
   LoadPwdDLL();
}

//----------------------------------------------------------------------------

static INT_PTR
DoScreenSave( HWND hParent )
{
   LPCTSTR pszWindowClass = TEXT("WindowsScreenSaverClass");
   LPCTSTR pszWindowTitle;

   WNDCLASS cls;
   MSG      msg;
   UINT     uStyle;
   UINT     uExStyle;
   int      ncx, ncy;
   int      nx, ny;

   SYSTEM_POWER_STATUS sps;

   cls.hCursor        = NULL;
   cls.hIcon          = LoadIcon( hMainInstance, MAKEINTATOM( ID_APP ) );
   cls.lpszMenuName   = NULL;
   cls.lpszClassName  = pszWindowClass;
   cls.hbrBackground  = GetStockObject( BLACK_BRUSH );
   cls.hInstance      = hMainInstance;
   cls.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_OWNDC;
   cls.lpfnWndProc    = RealScreenSaverProc;
   cls.cbWndExtra     = 0;
   cls.cbClsExtra     = 0;

   if( hParent )
   {
      RECT rcParent;
      GetClientRect( hParent, &rcParent );
      ncx = rcParent.right;
      ncy = rcParent.bottom;
      nx  = 0;
      ny  = 0;
      uStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN;
      uExStyle = 0;

      fChildPreview = TRUE;
      pszWindowTitle = TEXT("Preview");      // MUST differ from full screen
   }
   else
   {
      HWND hOther;

#ifdef SM_CXVIRTUALSCREEN
      nx  = GetSystemMetrics( SM_XVIRTUALSCREEN );
      ny  = GetSystemMetrics( SM_YVIRTUALSCREEN );
      ncx = GetSystemMetrics( SM_CXVIRTUALSCREEN );
      ncy = GetSystemMetrics( SM_CYVIRTUALSCREEN );

      if (ncx == 0 || ncy == 0)
#endif
      {
        RECT rc;
        HDC hdc = GetDC(NULL);
        GetClipBox(hdc, &rc);
        ReleaseDC(NULL, hdc);
        nx = rc.left;
        ny = rc.top;
        ncx = rc.right  - rc.left;
        ncy = rc.bottom - rc.top;
      }

      uStyle = WS_POPUP | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
      uExStyle = WS_EX_TOPMOST;

      pszWindowTitle = TEXT("Screen Saver"); // MUST differ from preview

      // if there is another NORMAL screen save instance, switch to it
      hOther = FindWindow( pszWindowClass, pszWindowTitle );

      if( hOther && IsWindow( hOther ) )
      {
         SetForegroundWindow( hOther );
         return 0;
      }

      // Get current system power status and store it
      if (GetSystemPowerStatus(&sps)) {
        bACLineStatus = sps.ACLineStatus;
      }
      else {
        // we can't determine the power status, use default
        bACLineStatus = AC_LINE_UNKNOWN;
      }


      InitRealScreenSave();
   }

   //
   // the shell sends this message to the foreground window before running an
   // AutoPlay app. we return 1 to cancel autoplay if we are password protected
   //
   if (fOnWin95) {
        uShellAutoPlayQueryMessage = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
   } else {
        uShellAutoPlayQueryMessage = 0;
   }

   if( RegisterClass( &cls ) )
   {
      hMainWindow = CreateWindowEx( uExStyle, pszWindowClass, pszWindowTitle,
                        uStyle, nx, ny, ncx, ncy, hParent, (HMENU)NULL,
                        hMainInstance, (LPVOID)NULL );
   }

   msg.wParam = 0;
   if( hMainWindow )
   {
      if( !fChildPreview )
         SetForegroundWindow( hMainWindow );

      while( GetMessage( &msg, NULL, 0, 0 ) )
      {
         TranslateMessage( &msg );
         DispatchMessage( &msg );
      }
   }

   // free password-handling DLL if loaded
   UnloadPwdDLL();

   return msg.wParam;
}


//----------------------------------------------------------------------------

static INT_PTR
DoSaverPreview( LPCTSTR szUINTHandle )
{
   // get parent handle from string
   HWND hParent = (HWND)atoui( szUINTHandle );

   // only preview on a valid parent window (NOT full screen)
   return ( (hParent && IsWindow( hParent ))? DoScreenSave( hParent ) : -1 );
}


//----------------------------------------------------------------------------

static INT_PTR
DoConfigBox( HWND hParent )
{
   // let the consumer register any special controls for the dialog
   if( !RegisterDialogClasses( hMainInstance ) )
      return FALSE;

   return DialogBox( hMainInstance, MAKEINTRESOURCE( DLG_SCRNSAVECONFIGURE ),
                     hParent, (WNDPROC)ScreenSaverConfigureDialog );

}


//----------------------------------------------------------------------------

static INT_PTR
DoChangePw( LPCTSTR szUINTHandle )
{
   // get parent handle from string
   HWND hParent = (HWND)atoui( szUINTHandle );

   if( !hParent || !IsWindow( hParent ) )
      hParent = GetForegroundWindow();

   // allow the library to be hooked
   ScreenSaverChangePassword( hParent );
   return 0;
}

static const TCHAR szMprDll[] = TEXT("MPR.DLL");       // not to be localized
static const TCHAR szProviderName[] = TEXT("SCRSAVE"); // not to be localized

#ifdef UNICODE
static const CHAR szPwdChangePW[] = "PwdChangePasswordW"; // not to be localized
#else
static const CHAR szPwdChangePW[] = "PwdChangePasswordA"; // not to be localized
#endif

// bogus prototype
typedef DWORD (FAR PASCAL *PWCHGPROC)( LPCTSTR, HWND, DWORD, LPVOID );

void WINAPI
ScreenSaverChangePassword( HWND hParent )
{
   HINSTANCE mpr = LoadLibrary( szMprDll );

   if( mpr )
   {
      // netland hasn't cracked MNRENTRY yet
      PWCHGPROC pwd = (PWCHGPROC)GetProcAddress( mpr, szPwdChangePW );

      if( pwd )
         pwd( szProviderName, hParent, 0, NULL );

      FreeLibrary( mpr );
   }
}


//----------------------------------------------------------------------------

static BOOL
DoPasswordCheck( HWND hParent )
{
   // don't reenter and don't check when we've already decided
   if( fCheckingPassword || fClosing )
      return FALSE;

   if( VerifyPassword )
   {
      static DWORD lastcheck = (DWORD)-1;
      DWORD curtime = GetTickCount();
      MSG msg;

      if (dwPasswordDelay &&
         (GetElapsedTime(dwBlankTime, curtime) < dwPasswordDelay))
      {
         fClosing = TRUE;
         goto _didcheck;
      }

      // no rapid checking...
      if ((lastcheck != (DWORD)-1) &&
         (GetElapsedTime(lastcheck, curtime) < 200))
      {
         goto _didcheck;
      }

      // do the check
      fCheckingPassword = TRUE;

      // flush WM_TIMER messages before putting up the dialog
      PeekMessage( &msg, hParent, WM_TIMER, WM_TIMER, PM_REMOVE | PM_NOYIELD );
      PeekMessage( &msg, hParent, WM_TIMER, WM_TIMER, PM_REMOVE | PM_NOYIELD );

      // call the password verify proc
      fClosing = (BOOL)SendMessage( hParent, SCRM_VERIFYPW, 0, 0L );

      fCheckingPassword = FALSE;

      if (!fClosing)
         SetCursor(NULL);

      // curtime may be outdated by now
      lastcheck = GetTickCount();
   }
   else
   {
      // passwords disabled or unable to load handler DLL, always allow exit
      fClosing = TRUE;
   }

_didcheck:
   return fClosing;
}

//----------------------------------------------------------------------------
// stolen from the CRT, used to shirink our code

int _stdcall
DummyEntry( void )
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"')) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while (*(pszCmdLine = CharNext(pszCmdLine)) &&
              (*pszCmdLine != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while ((UINT)*pszCmdLine > (UINT)TEXT(' '))
            pszCmdLine = CharNext(pszCmdLine);
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && ((UINT)*pszCmdLine <= (UINT)TEXT(' '))) {
        pszCmdLine = CharNext(pszCmdLine);
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    i = (int)WinMainN(GetModuleHandle(NULL), NULL, pszCmdLine,
        si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);
    return i;   // We never comes here.
}

//----------------------------------------------------------------------------
// main() entry point to satisfy old NT screen savers
void _cdecl main( int argc, char *argv[] ) {
    DummyEntry();
}

//----------------------------------------------------------------------------
// WinMain() entry point to satisfy old NT screen savers
int PASCAL WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int nCmdShow ) {
    DummyEntry();
    return 0;

    // reference unreferenced parameters
    (void)hInst;
    (void)hPrev;
    (void)szCmdLine;
    (void)nCmdShow;
}


VOID LoadPwdDLL(VOID)
{
    HKEY hKey;

    if (!fOnWin95)
        return;

    if (hInstPwdDLL)
        UnloadPwdDLL();

    // look in registry to see if password turned on, otherwise don't
    // bother to load password handler DLL
    if (RegOpenKeyEx(HKEY_CURRENT_USER,szScreenSaverKey,0, KEY_QUERY_VALUE, &hKey) ==
        ERROR_SUCCESS)
    {
        DWORD dwVal,dwSize=sizeof(dwVal);

        if ((RegQueryValueEx(hKey,szPasswordActiveValue,
            NULL,NULL,(BYTE *) &dwVal,&dwSize) == ERROR_SUCCESS)
            && dwVal)
        {

            // try to load the DLL that contains password proc.
            hInstPwdDLL = LoadLibrary(szPwdDLL);
            if (hInstPwdDLL)
            {
                VerifyPassword = (VERIFYPWDPROC) GetProcAddress(hInstPwdDLL,
                    szFnName);

                if( VerifyPassword )
                    HogMachine( TRUE );
                else
                    UnloadPwdDLL();
            }
        }

        RegCloseKey(hKey);
    }

}

VOID UnloadPwdDLL(VOID)
{
    if (!fOnWin95)
        return;

    if (hInstPwdDLL)
    {
        FreeLibrary(hInstPwdDLL);
        hInstPwdDLL = NULL;

        if( VerifyPassword )
        {
            VerifyPassword = NULL;
            HogMachine( FALSE );
        }
    }
}

//----------------------------------------------------------------------------
// compatbility stuff  (to make porting easier)
TCHAR szAppName[ APPNAMEBUFFERLEN ];
TCHAR szName[ TITLEBARNAMELEN ];
TCHAR szIniFile[ MAXFILELEN ];
TCHAR szScreenSaver[ 22 ];
TCHAR szHelpFile[ MAXFILELEN ];
TCHAR szNoHelpMemory[ BUFFLEN ];

// Quick fix for old screen savers that don't know about context
// sensitive help
UINT  MyHelpMessage = WM_HELP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\d3dsaver\d3dsaver.cpp ===
//-----------------------------------------------------------------------------
// File: D3DSaver.cpp
//
// Desc: Framework for screensavers that use Direct3D 8.0.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <Windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <stdio.h>
#include <tchar.h>
#include <regstr.h>
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>
#include <mmsystem.h>
#include <D3DX8.h>
#include "D3DSaver.h"
#include "dxutil.h"

// Resource IDs.  D3DSaver assumes that you will create resources with
// these IDs that it can use.  The easiest way to do this is to copy
// the resources from the rc file of an existing D3DSaver-based program.
#define IDI_MAIN_ICON                   101
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201

#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016

#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112

#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212


// Use the following structure rather than DISPLAY_DEVICE, since some old 
// versions of DISPLAY_DEVICE are missing the last two fields and this can
// cause problems with EnumDisplayDevices on Windows 2000.
struct DISPLAY_DEVICE_FULL
{
    DWORD  cb;
    TCHAR  DeviceName[32];
    TCHAR  DeviceString[128];
    DWORD  StateFlags;
    TCHAR  DeviceID[128];
    TCHAR  DeviceKey[128];
};


static CD3DScreensaver* s_pD3DScreensaver = NULL;


//-----------------------------------------------------------------------------
// Name: CD3DScreensaver()
// Desc: Constructor
//-----------------------------------------------------------------------------
CD3DScreensaver::CD3DScreensaver()
{
    s_pD3DScreensaver = this;

    m_bCheckingSaverPassword = FALSE;
    m_bIs9x = FALSE;
    m_dwSaverMouseMoveCount = 0;
    m_hWndParent = NULL;
    m_hPasswordDLL = NULL;
    m_hWnd = NULL;
    m_VerifySaverPassword = NULL;
    
    m_bAllScreensSame = FALSE;
    m_pD3D = NULL;
    m_pd3dDevice = NULL;
    m_bWindowed = FALSE;
    m_bWaitForInputIdle = FALSE;

    m_bErrorMode = FALSE;
    m_hrError = S_OK;
    m_szError[0] = TEXT('\0');

    m_fFPS              = 0.0f;
    m_strDeviceStats[0] = TEXT('\0');
    m_strFrameStats[0]  = TEXT('\0');

    // Note: clients should load a resource into m_strWindowTitle to localize this string
    lstrcpy( m_strWindowTitle, TEXT("Screen Saver") );
    m_bAllowRef = FALSE;
    m_bUseDepthBuffer = FALSE;
    m_bMultithreaded = FALSE;
    m_bOneScreenOnly = FALSE;
    m_strRegPath[0] = TEXT('\0');
    m_dwMinDepthBits = 16;
    m_dwMinStencilBits = 0;
    m_SwapEffectFullscreen = D3DSWAPEFFECT_DISCARD;
    m_SwapEffectWindowed = D3DSWAPEFFECT_COPY_VSYNC;

    SetRectEmpty( &m_rcRenderTotal );
    SetRectEmpty( &m_rcRenderCurDevice );

    ZeroMemory( m_Monitors, sizeof(m_Monitors) );
    m_dwNumMonitors = 0;

    ZeroMemory( m_Adapters, sizeof(m_Adapters) );
    m_dwNumAdapters = 0;

    ZeroMemory( m_RenderUnits, sizeof(m_RenderUnits) );
    m_dwNumRenderUnits = 0;

    m_fTime = 0.0f;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Have the client program call this function before calling Run().
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::Create( HINSTANCE hInstance )
{
    HRESULT hr;

    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_IDLE );

    m_hInstance = hInstance;

    // Parse the command line and do the appropriate thing
    TCHAR* pstrCmdLine = GetCommandLine();
    m_SaverMode = ParseCommandLine( pstrCmdLine );

    EnumMonitors();

    // Create the screen saver window(s)
    if( m_SaverMode == sm_preview || 
        m_SaverMode == sm_test    || 
        m_SaverMode == sm_full )
    {
        if( FAILED( hr = CreateSaverWindow() ) )
        {
            m_bErrorMode = TRUE;
            m_hrError = hr;
        }
    }

    if( m_SaverMode == sm_preview )
    {
        // In preview mode, "pause" (enter a limited message loop) briefly 
        // before proceeding, so the display control panel knows to update itself.
        m_bWaitForInputIdle = TRUE;

        // Post a message to mark the end of the initial group of window messages
        PostMessage( m_hWnd, WM_USER, 0, 0 );

        MSG msg;
        while( m_bWaitForInputIdle )
        {
            // If GetMessage returns FALSE, it's quitting time.
            if( !GetMessage( &msg, m_hWnd, 0, 0 ) )
            {
                // Post the quit message to handle it later
                PostQuitMessage(0);
                break;
            }

            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
    }

    // Create Direct3D object
    if( (m_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) == NULL )
    {
        m_bErrorMode = TRUE;
        m_hrError = D3DAPPERR_NODIRECT3D;
        return S_OK;
    }

    // Give the app the opportunity to register a pluggable SW D3D Device.
    if( FAILED( hr = RegisterSoftwareDevice() ) )
    {
        m_bErrorMode = TRUE;
        m_hrError = hr;
        return S_OK;
    }

    // Build a list of Direct3D adapters, modes and devices. The
    // ConfirmDevice() callback is used to confirm that only devices that
    // meet the app's requirements are considered.
    if( FAILED( hr = BuildDeviceList() ) )
    {
        m_bErrorMode = TRUE;
        m_hrError = hr;
        return S_OK;
    }

    // Make sure that at least one valid usable D3D device was found
    BOOL bCompatibleDeviceFound = FALSE;
    for( DWORD iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
    {
        if( m_Adapters[iAdapter]->bHasAppCompatHAL || 
            m_Adapters[iAdapter]->bHasAppCompatSW )
        {
            bCompatibleDeviceFound = TRUE;
            break;
        }
    }
    if( !bCompatibleDeviceFound )
    {
        m_bErrorMode = TRUE;
        m_hrError = D3DAPPERR_NOCOMPATIBLEDEVICES;
        return S_OK;
    }

    // Read any settings we need
    ReadSettings();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: EnumMonitors()
// Desc: Determine HMONITOR, desktop rect, and other info for each monitor.  
//       Note that EnumDisplayDevices enumerates monitors in the order 
//       indicated on the Settings page of the Display control panel, which 
//       is the order we want to list monitors in, as opposed to the order 
//       used by D3D's GetAdapterInfo.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::EnumMonitors( VOID )
{
    DWORD iDevice = 0;
    DISPLAY_DEVICE_FULL dispdev;
    DISPLAY_DEVICE_FULL dispdev2;
    DEVMODE devmode;
    dispdev.cb = sizeof(dispdev);
    dispdev2.cb = sizeof(dispdev2);
    devmode.dmSize = sizeof(devmode);
    devmode.dmDriverExtra = 0;
    MonitorInfo* pMonitorInfoNew;
    while( EnumDisplayDevices(NULL, iDevice, (DISPLAY_DEVICE*)&dispdev, 0) )
    {
        // Ignore NetMeeting's mirrored displays
        if( (dispdev.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER) == 0 )
        {
            // To get monitor info for a display device, call EnumDisplayDevices
            // a second time, passing dispdev.DeviceName (from the first call) as
            // the first parameter.
            EnumDisplayDevices(dispdev.DeviceName, 0, (DISPLAY_DEVICE*)&dispdev2, 0);

            pMonitorInfoNew = &m_Monitors[m_dwNumMonitors];
            ZeroMemory( pMonitorInfoNew, sizeof(MonitorInfo) );
            lstrcpy( pMonitorInfoNew->strDeviceName, dispdev.DeviceString );
            lstrcpy( pMonitorInfoNew->strMonitorName, dispdev2.DeviceString );
            pMonitorInfoNew->iAdapter = NO_ADAPTER;
            
            if( dispdev.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP )
            {
                EnumDisplaySettings( dispdev.DeviceName, ENUM_CURRENT_SETTINGS, &devmode );
                if( dispdev.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE )
                {
                    // For some reason devmode.dmPosition is not always (0, 0)
                    // for the primary display, so force it.
                    pMonitorInfoNew->rcScreen.left = 0;
                    pMonitorInfoNew->rcScreen.top = 0;
                }
                else
                {
                    pMonitorInfoNew->rcScreen.left = devmode.dmPosition.x;
                    pMonitorInfoNew->rcScreen.top = devmode.dmPosition.y;
                }
                pMonitorInfoNew->rcScreen.right = pMonitorInfoNew->rcScreen.left + devmode.dmPelsWidth;
                pMonitorInfoNew->rcScreen.bottom = pMonitorInfoNew->rcScreen.top + devmode.dmPelsHeight;
                pMonitorInfoNew->hMonitor = MonitorFromRect( &pMonitorInfoNew->rcScreen, MONITOR_DEFAULTTONULL );
            }
            m_dwNumMonitors++;
            if( m_dwNumMonitors == MAX_DISPLAYS )
                break;
        }
        iDevice++;
    }
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: Starts main execution of the screen saver.
//-----------------------------------------------------------------------------
INT CD3DScreensaver::Run()
{
    HRESULT hr;

    // Parse the command line and do the appropriate thing
    switch ( m_SaverMode )
    {
        case sm_config:
        {
            if( m_bErrorMode )
            {
                DisplayErrorMsg( m_hrError, 0 );
            }
            else
            {
                DoConfig();
            }
            break;
        }
        
        case sm_preview:
        case sm_test:
        case sm_full:
        {
            if( FAILED( hr = DoSaver() ) )
                DisplayErrorMsg( hr, 0 );
            break;
        }
        
        case sm_passwordchange:
        {
            ChangePassword();
            break;
        }
    }

    for( DWORD iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
        SAFE_DELETE( m_Adapters[iAdapter] );
    SAFE_RELEASE( m_pD3D );
    return 0;
}




//-----------------------------------------------------------------------------
// Name: ParseCommandLine()
// Desc: Interpret command-line parameters passed to this app.
//-----------------------------------------------------------------------------
SaverMode CD3DScreensaver::ParseCommandLine( TCHAR* pstrCommandLine )
{
    m_hWndParent = NULL;

    // Skip the first part of the command line, which is the full path 
    // to the exe.  If it contains spaces, it will be contained in quotes.
    if (*pstrCommandLine == TEXT('\"'))
    {
        pstrCommandLine++;
        while (*pstrCommandLine != TEXT('\0') && *pstrCommandLine != TEXT('\"'))
            pstrCommandLine++;
        if( *pstrCommandLine == TEXT('\"') )
            pstrCommandLine++;
    }
    else
    {
        while (*pstrCommandLine != TEXT('\0') && *pstrCommandLine != TEXT(' '))
            pstrCommandLine++;
        if( *pstrCommandLine == TEXT(' ') )
            pstrCommandLine++;
    }

    // Skip along to the first option delimiter "/" or "-"
    while ( *pstrCommandLine != TEXT('\0') && *pstrCommandLine != TEXT('/') && *pstrCommandLine != TEXT('-') )
        pstrCommandLine++;

    // If there wasn't one, then must be config mode
    if ( *pstrCommandLine == TEXT('\0') )
        return sm_config;

    // Otherwise see what the option was
    switch ( *(++pstrCommandLine) )
    {
        case 'c':
        case 'C':
            pstrCommandLine++;
            while ( *pstrCommandLine && !isdigit(*pstrCommandLine) )
                pstrCommandLine++;
            if ( isdigit(*pstrCommandLine) )
            {
#ifdef _WIN64
                CHAR strCommandLine[2048];
                DXUtil_ConvertGenericStringToAnsi(strCommandLine, pstrCommandLine, 2048);
                m_hWndParent = HWND(_atoi64(strCommandLine));
#else
                m_hWndParent = HWND(_ttol(pstrCommandLine));
#endif
            }
            else
            {
                m_hWndParent = NULL;
            }
            return sm_config;

        case 't':
        case 'T':
            return sm_test;

        case 'p':
        case 'P':
            // Preview-mode, so option is followed by the parent HWND in decimal
            pstrCommandLine++;
            while ( *pstrCommandLine && !isdigit(*pstrCommandLine) )
                pstrCommandLine++;
            if ( isdigit(*pstrCommandLine) )
            {
#ifdef _WIN64
                CHAR strCommandLine[2048];
                DXUtil_ConvertGenericStringToAnsi(strCommandLine, pstrCommandLine, 2048);
                m_hWndParent = HWND(_atoi64(strCommandLine));
#else
                m_hWndParent = HWND(_ttol(pstrCommandLine));
#endif
            }
            return sm_preview;

        case 'a':
        case 'A':
            // Password change mode, so option is followed by parent HWND in decimal
            pstrCommandLine++;
            while ( *pstrCommandLine && !isdigit(*pstrCommandLine) )
                pstrCommandLine++;
            if ( isdigit(*pstrCommandLine) )
            {
#ifdef _WIN64
                CHAR strCommandLine[2048];
                DXUtil_ConvertGenericStringToAnsi(strCommandLine, pstrCommandLine, 2048);
                m_hWndParent = HWND(_atoi64(strCommandLine));
#else
                m_hWndParent = HWND(_ttol(pstrCommandLine));
#endif
            }
            return sm_passwordchange;

        default:
            // All other options => run the screensaver (typically this is "/s")
            return sm_full;
    }
}




//-----------------------------------------------------------------------------
// Name: CreateSaverWindow
// Desc: Register and create the appropriate window(s)
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::CreateSaverWindow()
{
/*
    // Uncomment this code to allow stepping thru code in the preview case
    if( m_SaverMode == sm_preview )
    {
        WNDCLASS cls;
        cls.hCursor        = NULL; 
        cls.hIcon          = NULL; 
        cls.lpszMenuName   = NULL;
        cls.lpszClassName  = TEXT("Parent"); 
        cls.hbrBackground  = (HBRUSH) GetStockObject(WHITE_BRUSH);
        cls.hInstance      = m_hInstance; 
        cls.style          = CS_VREDRAW|CS_HREDRAW|CS_SAVEBITS|CS_DBLCLKS;
        cls.lpfnWndProc    = DefWindowProc;
        cls.cbWndExtra     = 0; 
        cls.cbClsExtra     = 0; 
        RegisterClass( &cls );

        // Create the window
        RECT rect;
        HWND hwnd;
        rect.left = rect.top = 40;
        rect.right = rect.left+200;
        rect.bottom = rect.top+200;
        AdjustWindowRect( &rect, WS_VISIBLE|WS_OVERLAPPED|WS_CAPTION|WS_POPUP, FALSE );
        hwnd = CreateWindow( TEXT("Parent"), TEXT("FakeShell"),
            WS_VISIBLE|WS_OVERLAPPED|WS_CAPTION|WS_POPUP, rect.left, rect.top,
            rect.right-rect.left, rect.bottom-rect.top, NULL,
            NULL, m_hInstance, NULL );
        m_hWndParent = hwnd;
    }
*/
    
    // Register an appropriate window class
    WNDCLASS    cls;
    cls.hCursor        = LoadCursor( NULL, IDC_ARROW );
    cls.hIcon          = LoadIcon( m_hInstance, MAKEINTRESOURCE(IDI_MAIN_ICON) ); 
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = TEXT("D3DSaverWndClass");
    cls.hbrBackground  = (HBRUSH) GetStockObject(BLACK_BRUSH);
    cls.hInstance      = m_hInstance; 
    cls.style          = CS_VREDRAW|CS_HREDRAW;
    cls.lpfnWndProc    = SaverProcStub;
    cls.cbWndExtra     = 0; 
    cls.cbClsExtra     = 0; 
    RegisterClass( &cls );

    // Create the window
    RECT rc;
    DWORD dwStyle;
    switch ( m_SaverMode )
    {
        case sm_preview:
            GetClientRect( m_hWndParent, &rc );
            dwStyle = WS_VISIBLE | WS_CHILD;
            AdjustWindowRect( &rc, dwStyle, FALSE );
            m_hWnd = CreateWindow( TEXT("D3DSaverWndClass"), m_strWindowTitle, dwStyle, 
                                    rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, 
                                    m_hWndParent, NULL, m_hInstance, this );
            m_Monitors[0].hWnd = m_hWnd;
            GetClientRect( m_hWnd, &m_rcRenderTotal );
            GetClientRect( m_hWnd, &m_rcRenderCurDevice );
            break;

        case sm_test:
            rc.left = rc.top = 50;
            rc.right = rc.left+600;
            rc.bottom = rc.top+400;
            dwStyle = WS_VISIBLE | WS_OVERLAPPED | WS_CAPTION | WS_MINIMIZEBOX | WS_SYSMENU;
            AdjustWindowRect( &rc, dwStyle, FALSE );
            m_hWnd = CreateWindow( TEXT("D3DSaverWndClass"), m_strWindowTitle, dwStyle, 
                                   rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, 
                                   NULL, NULL, m_hInstance, this );
            m_Monitors[0].hWnd = m_hWnd;
            GetClientRect( m_hWnd, &m_rcRenderTotal );
            GetClientRect( m_hWnd, &m_rcRenderCurDevice );
            break;

        case sm_full:
            // Create windows for each monitor.  Note that m_hWnd is NULL when CreateWindowEx
            // is called for the first monitor, so that window has no parent.  Windows for
            // additional monitors are created as children of the window for the first monitor.
            dwStyle = WS_VISIBLE | WS_POPUP;
            m_hWnd = NULL;
            for( DWORD iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
            {
                MonitorInfo* pMonitorInfo;
                pMonitorInfo = &m_Monitors[iMonitor];
                if( pMonitorInfo->hMonitor == NULL )
                    continue;
                rc = pMonitorInfo->rcScreen;
                pMonitorInfo->hWnd = CreateWindowEx( WS_EX_TOPMOST, TEXT("D3DSaverWndClass"), 
                    m_strWindowTitle, dwStyle, rc.left, rc.top, rc.right - rc.left, 
                    rc.bottom - rc.top, m_hWnd, NULL, m_hInstance, this );
                if( pMonitorInfo->hWnd == NULL )
                    return E_FAIL;
                if( m_hWnd == NULL )
                    m_hWnd = pMonitorInfo->hWnd;
            }
    }
    if ( m_hWnd == NULL )
        return E_FAIL;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: DoSaver()
// Desc: Run the screensaver graphics - may be preview, test or full-on mode
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::DoSaver()
{
    HRESULT hr;

    // Figure out if we're on Win9x
    OSVERSIONINFO osvi; 
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx( &osvi );
    m_bIs9x = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);

    // If we're in full on mode, and on 9x, then need to load the password DLL
    if ( m_SaverMode == sm_full && m_bIs9x )
    {
        // Only do this if the password is set - check registry:
        HKEY hKey; 
        if ( RegOpenKey( HKEY_CURRENT_USER , REGSTR_PATH_SCREENSAVE , &hKey ) == ERROR_SUCCESS ) 
        { 
            DWORD dwVal;
            DWORD dwSize = sizeof(dwVal); 
 
            if ( (RegQueryValueEx( hKey, REGSTR_VALUE_USESCRPASSWORD, NULL, NULL,
                                   (BYTE *)&dwVal, &dwSize ) == ERROR_SUCCESS) && dwVal ) 
            { 
                m_hPasswordDLL = LoadLibrary( TEXT("PASSWORD.CPL") );
                if ( m_hPasswordDLL )
                    m_VerifySaverPassword = (VERIFYPWDPROC)GetProcAddress( m_hPasswordDLL, "VerifyScreenSavePwd" );
                RegCloseKey( hKey );
            }
        }
    }

    // Initialize the application timer
    DXUtil_Timer( TIMER_START );

    if( !m_bErrorMode )
    {
        // Initialize the app's custom scene stuff
        if( FAILED( hr = OneTimeSceneInit() ) )
            return DisplayErrorMsg( hr, MSGERR_APPMUSTEXIT );

        // Do graphical init stuff
        if ( FAILED(hr = Initialize3DEnvironment()) )
            return hr;
    }

    // Flag as screensaver running if in full on mode
    if ( m_SaverMode == sm_full )
    {
        BOOL bUnused;
        SystemParametersInfo( SPI_SCREENSAVERRUNNING, TRUE, &bUnused, 0 );
    }

    // Message pump
    BOOL bGotMsg;
    MSG msg;
    msg.message = WM_NULL;
    while ( msg.message != WM_QUIT )
    {
        bGotMsg = PeekMessage( &msg, NULL, 0, 0, PM_REMOVE );
        if( bGotMsg )
        {
            TranslateMessage( &msg );
            DispatchMessage( &msg );
        }
        else
        {
            Sleep(10);
            if( m_bErrorMode )
            {
                UpdateErrorBox();
            }
            else
            {
                Render3DEnvironment();
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ShutdownSaver()
// Desc: 
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::ShutdownSaver()
{
    // Unflag screensaver running if in full on mode
    if ( m_SaverMode == sm_full )
    {
        BOOL bUnused;
        SystemParametersInfo( SPI_SCREENSAVERRUNNING, FALSE, &bUnused, 0 );
    }

    // Kill graphical stuff
    Cleanup3DEnvironment();

    // Let client app clean up its resources
    FinalCleanup();

    // Unload the password DLL (if we loaded it)
    if ( m_hPasswordDLL != NULL )
    {
        FreeLibrary( m_hPasswordDLL );
        m_hPasswordDLL = NULL;
    }

    // Post message to drop out of message loop
    PostQuitMessage( 0 );
}




//-----------------------------------------------------------------------------
// Name: SaverProcStub()
// Desc: This function forwards all window messages to SaverProc, which has
//       access to the "this" pointer.
//-----------------------------------------------------------------------------
LRESULT CALLBACK CD3DScreensaver::SaverProcStub( HWND hWnd, UINT uMsg,
                                                 WPARAM wParam, LPARAM lParam )
{
    return s_pD3DScreensaver->SaverProc( hWnd, uMsg, wParam, lParam );
}




//-----------------------------------------------------------------------------
// Name: SaverProc()
// Desc: Handle window messages for main screensaver windows (one per screen).
//-----------------------------------------------------------------------------
LRESULT CD3DScreensaver::SaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch ( uMsg )
        {
        case WM_USER:
            // All initialization messages have gone through.  Allow
            // 500ms of idle time, then proceed with initialization.
            SetTimer( hWnd, 1, 500, NULL );
            break;

        case WM_TIMER:
            // Initial idle time is done, proceed with initialization.
            m_bWaitForInputIdle = FALSE;
            KillTimer( hWnd, 1 );
            break;

        case WM_DESTROY:
            if( m_SaverMode == sm_preview || m_SaverMode == sm_test )
                ShutdownSaver();
            break;

        case WM_SETCURSOR:
            if ( m_SaverMode == sm_full && !m_bCheckingSaverPassword )
            {
                // Hide cursor
                SetCursor( NULL );
                return TRUE;
            }
            break;

        case WM_PAINT:
        {
            // Show error message, if there is one
            PAINTSTRUCT ps;
            BeginPaint( hWnd, &ps );

            // In preview mode, just fill 
            // the preview window with black. 
            if( !m_bErrorMode && m_SaverMode == sm_preview )
            {
                RECT rc;
                GetClientRect(hWnd,&rc);
                HBRUSH hbrBlack = (HBRUSH)GetStockObject(BLACK_BRUSH);
                if( hbrBlack != NULL )
                    FillRect(ps.hdc, &rc, hbrBlack );
            }
            else
            {
                DoPaint( hWnd, ps.hdc );
            }

            EndPaint( hWnd, &ps );
            return 0;
        }

        case WM_ERASEBKGND:
            // Erase background if checking password or if window is not
            // assigned to a render unit
            if( !m_bCheckingSaverPassword )
            {
                RenderUnit* pRenderUnit;
                D3DAdapterInfo* pD3DAdapterInfo;
                for( DWORD iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
                {
                    pRenderUnit = &m_RenderUnits[iRenderUnit];
                    pD3DAdapterInfo = m_Adapters[pRenderUnit->iAdapter];
                    if( pD3DAdapterInfo->hWndDevice == hWnd )
                        return TRUE; // don't erase this window
                }
            }
            break;

        case WM_MOUSEMOVE:
            if( m_SaverMode != sm_test )
            {
                static INT xPrev = -1;
                static INT yPrev = -1;
                INT xCur = GET_X_LPARAM(lParam);
                INT yCur = GET_Y_LPARAM(lParam);
                if( xCur != xPrev || yCur != yPrev )
                {
                    xPrev = xCur;
                    yPrev = yCur;
                    m_dwSaverMouseMoveCount++;
                    if ( m_dwSaverMouseMoveCount > 5 )
                        InterruptSaver();
                }
            }
            break;

        case WM_KEYDOWN:
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_MBUTTONDOWN:
            if( m_SaverMode != sm_test )
                InterruptSaver();
            break;

        case WM_ACTIVATEAPP:
            if( wParam == FALSE && m_SaverMode != sm_test )
                InterruptSaver();
            break;

        case WM_POWERBROADCAST:
            if( wParam == PBT_APMSUSPEND && m_VerifySaverPassword == NULL )
                InterruptSaver();
            break;

        case WM_SYSCOMMAND: 
            if ( m_SaverMode == sm_full )
            {
                switch ( wParam )
                {
                    case SC_NEXTWINDOW:
                    case SC_PREVWINDOW:
                    case SC_SCREENSAVE:
                    case SC_CLOSE:
                        return FALSE;
                        break;
                    case SC_MONITORPOWER:
                        //
                        // The monitor is shutting down.  Tell our client that he needs to
                        // cleanup and exit.
                        //
                        InterruptSaver();
                        break;
                };
            }
            break;
    }

    return DefWindowProc( hWnd, uMsg, wParam, lParam );
}




//-----------------------------------------------------------------------------
// Name: InterruptSaver()
// Desc: A message was received (mouse move, keydown, etc.) that may mean
//       the screen saver should show the password dialog and/or shut down.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::InterruptSaver()
{
    HRESULT hr;
    DWORD iRenderUnit;
    RenderUnit* pRenderUnit;
    BOOL bPasswordOkay = FALSE;

    if( m_SaverMode == sm_test ||
        m_SaverMode == sm_full && !m_bCheckingSaverPassword )
    {
        if( m_bIs9x && m_SaverMode == sm_full )
        {
            // If no VerifyPassword function, then no password is set 
            // or we're not on 9x. 
            if ( m_VerifySaverPassword != NULL )
            {
                // Shut down all D3D devices so we can show a Windows dialog
                for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
                {
                    pRenderUnit = &m_RenderUnits[iRenderUnit];
                    SwitchToRenderUnit(iRenderUnit);
                    if( pRenderUnit->bDeviceObjectsRestored )
                    {
                        InvalidateDeviceObjects();
                        pRenderUnit->bDeviceObjectsRestored = FALSE;
                    }
                    if( pRenderUnit->bDeviceObjectsInited )
                    {
                        DeleteDeviceObjects();
                        pRenderUnit->bDeviceObjectsInited = FALSE;
                    }
                    SAFE_RELEASE(pRenderUnit->pd3dDevice);
                }

                // Make sure all adapter windows cover the whole screen,
                // even after deleting D3D devices (which may have caused
                // mode changes)
                D3DAdapterInfo* pD3DAdapterInfo;
                for( DWORD iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
                {
                    pD3DAdapterInfo = m_Adapters[iAdapter];
                    ShowWindow( pD3DAdapterInfo->hWndDevice, SW_RESTORE );
                    ShowWindow( pD3DAdapterInfo->hWndDevice, SW_MAXIMIZE );
                }

                m_bCheckingSaverPassword = TRUE;

                bPasswordOkay = m_VerifySaverPassword( m_hWnd );

                m_bCheckingSaverPassword = FALSE;

                if ( bPasswordOkay )
                {
                    // D3D devices are all torn down, so it's safe
                    // to discard all render units now (so we don't
                    // try to clean them up again later).
                    m_dwNumRenderUnits = 0;
                }
                else
                {
                    // Back to screen saving...
                    SetCursor( NULL );
                    m_dwSaverMouseMoveCount = 0;

                    // Recreate all D3D devices
                    for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
                    {
                        pRenderUnit = &m_RenderUnits[iRenderUnit];
                        hr = m_pD3D->CreateDevice(pRenderUnit->iAdapter, 
                            pRenderUnit->DeviceType, m_hWnd, 
                            pRenderUnit->dwBehavior, &pRenderUnit->d3dpp, 
                            &pRenderUnit->pd3dDevice );
                        if( FAILED( hr ) )
                        {
                            m_bErrorMode = TRUE;
                            m_hrError = D3DAPPERR_CREATEDEVICEFAILED;
                        }
                        else
                        {
                            SwitchToRenderUnit(iRenderUnit);
                            if( FAILED(hr = InitDeviceObjects() ) )
                            {
                                m_bErrorMode = TRUE;
                                m_hrError = D3DAPPERR_INITDEVICEOBJECTSFAILED;
                            }
                            else 
                            {
                                pRenderUnit->bDeviceObjectsInited = TRUE;
                                if( FAILED(hr = RestoreDeviceObjects() ) )
                                {
                                    m_bErrorMode = TRUE;
                                    m_hrError = D3DAPPERR_INITDEVICEOBJECTSFAILED;
                                }
                                else
                                {
                                    pRenderUnit->bDeviceObjectsRestored = TRUE;
                                }
                            }
                        }
                    }

                    return;
                }
            }
        }
        ShutdownSaver();
    }
}




//-----------------------------------------------------------------------------
// Name: Initialize3DEnvironment()
// Desc: Set up D3D device(s)
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::Initialize3DEnvironment()
{
    HRESULT hr;
    DWORD iAdapter;
    DWORD iMonitor;
    D3DAdapterInfo* pD3DAdapterInfo;
    MonitorInfo* pMonitorInfo;
    DWORD iRenderUnit;
    RenderUnit* pRenderUnit;
    MONITORINFO monitorInfo;

    if ( m_SaverMode == sm_full )
    {
        // Fullscreen mode.  Create a RenderUnit for each monitor (unless 
        // the user wants it black)
        m_bWindowed = FALSE;

        if( m_bOneScreenOnly )
        {
            // Set things up to only create a RenderUnit on the best device
            for( iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
            {
                pD3DAdapterInfo = m_Adapters[iAdapter];
                pD3DAdapterInfo->bLeaveBlack = TRUE;
            }
            GetBestAdapter( &iAdapter );
            if( iAdapter == NO_ADAPTER )
            {
                m_bErrorMode = TRUE;
                m_hrError = D3DAPPERR_NOCOMPATIBLEDEVICES;
            }
            else
            {
                pD3DAdapterInfo = m_Adapters[iAdapter];
                pD3DAdapterInfo->bLeaveBlack = FALSE;
            }
        }

        for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
        {
            pMonitorInfo = &m_Monitors[iMonitor];
            iAdapter = pMonitorInfo->iAdapter;
            if( iAdapter == NO_ADAPTER )
                continue; 
            pD3DAdapterInfo = m_Adapters[iAdapter];
            if( !pD3DAdapterInfo->bLeaveBlack && pD3DAdapterInfo->dwNumDevices > 0 )
            {
                pD3DAdapterInfo->hWndDevice = pMonitorInfo->hWnd;
                pRenderUnit = &m_RenderUnits[m_dwNumRenderUnits++];
                ZeroMemory( pRenderUnit, sizeof(RenderUnit) );
                pRenderUnit->iAdapter = iAdapter;
                if( FAILED( hr = CreateFullscreenRenderUnit( pRenderUnit ) ) )
                {
                    // skip this render unit and leave screen blank
                    m_dwNumRenderUnits--;
                    m_bErrorMode = TRUE;
                    m_hrError = D3DAPPERR_CREATEDEVICEFAILED;
                }
            }
        }
    }
    else 
    {
        // Windowed mode, for test mode or preview window.  Just need one RenderUnit.
        m_bWindowed = TRUE;

        GetClientRect( m_hWnd, &m_rcRenderTotal );
        GetClientRect( m_hWnd, &m_rcRenderCurDevice );

        GetBestAdapter( &iAdapter );
        if( iAdapter == NO_ADAPTER )
        {
            m_bErrorMode = TRUE;
            m_hrError = D3DAPPERR_CREATEDEVICEFAILED;
        }
        else
        {
            pD3DAdapterInfo = m_Adapters[iAdapter];
            pD3DAdapterInfo->hWndDevice = m_hWnd;
        }
        if( !m_bErrorMode )
        {
            pRenderUnit = &m_RenderUnits[m_dwNumRenderUnits++];
            ZeroMemory( pRenderUnit, sizeof(RenderUnit) );
            pRenderUnit->iAdapter = iAdapter;
            if( FAILED( hr = CreateWindowedRenderUnit( pRenderUnit ) ) )
            {
                m_dwNumRenderUnits--;
                m_bErrorMode = TRUE;
                if( m_SaverMode == sm_preview )
                    m_hrError = D3DAPPERR_NOPREVIEW;
                else
                    m_hrError = D3DAPPERR_CREATEDEVICEFAILED;
            }
        }
    }

    // Once all mode changes are done, (re-)determine coordinates of all 
    // screens, and make sure windows still cover each screen
    for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        monitorInfo.cbSize = sizeof(MONITORINFO);
        GetMonitorInfo( pMonitorInfo->hMonitor, &monitorInfo );
        pMonitorInfo->rcScreen = monitorInfo.rcMonitor;
        if( !m_bWindowed )
        {
            SetWindowPos( pMonitorInfo->hWnd, HWND_TOPMOST, monitorInfo.rcMonitor.left, 
                monitorInfo.rcMonitor.top, monitorInfo.rcMonitor.right - monitorInfo.rcMonitor.left, 
                monitorInfo.rcMonitor.bottom - monitorInfo.rcMonitor.top, SWP_NOACTIVATE );
        }
    }

    // For fullscreen, determine bounds of the virtual screen containing all 
    // screens that are rendering.  Don't just use SM_XVIRTUALSCREEN, because 
    // we don't want to count screens that are just black
    if( !m_bWindowed )
    {
        for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
        {
            pRenderUnit = &m_RenderUnits[iRenderUnit];
            pMonitorInfo = &m_Monitors[pRenderUnit->iMonitor];
            UnionRect( &m_rcRenderTotal, &m_rcRenderTotal, &pMonitorInfo->rcScreen );
        }
    }

    if( !m_bErrorMode )
    {
        // Initialize D3D devices for all render units
        for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
        {
            pRenderUnit = &m_RenderUnits[iRenderUnit];
            SwitchToRenderUnit( iRenderUnit );
            if ( FAILED(hr = InitDeviceObjects() ) )
            {
                m_bErrorMode = TRUE;
                m_hrError = D3DAPPERR_INITDEVICEOBJECTSFAILED;
            }
            else 
            {
                pRenderUnit->bDeviceObjectsInited = TRUE;
                if ( FAILED(hr = RestoreDeviceObjects() ) )
                {
                    m_bErrorMode = TRUE;
                    m_hrError = D3DAPPERR_INITDEVICEOBJECTSFAILED;
                }
                else
                {
                    pRenderUnit->bDeviceObjectsRestored = TRUE;
                }
            }
        }
        UpdateDeviceStats(); 
    }

    // Make sure all those display changes don't count as user mouse moves
    m_dwSaverMouseMoveCount = 0;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetBestAdapter()
// Desc: To decide which adapter to use, loop through monitors until you find
//       one whose adapter has a compatible HAL.  If none, use the first 
//       monitor that has an compatible SW device.
//-----------------------------------------------------------------------------
BOOL CD3DScreensaver::GetBestAdapter( DWORD* piAdapter )
{
    DWORD iAdapterBest = NO_ADAPTER;
    DWORD iAdapter;
    DWORD iMonitor;
    MonitorInfo* pMonitorInfo;
    D3DAdapterInfo* pD3DAdapterInfo;

    for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        iAdapter = pMonitorInfo->iAdapter;
        if( iAdapter == NO_ADAPTER )
            continue; 
        pD3DAdapterInfo = m_Adapters[iAdapter];
        if( pD3DAdapterInfo->bHasAppCompatHAL )
        {
            iAdapterBest = iAdapter;
            break;
        }
        if( pD3DAdapterInfo->bHasAppCompatSW )
        {
            iAdapterBest = iAdapter;
            // but keep looking...
        }
    }
    *piAdapter = iAdapterBest;

    return (iAdapterBest != NO_ADAPTER);
}




//-----------------------------------------------------------------------------
// Name: CreateFullscreenRenderUnit()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::CreateFullscreenRenderUnit( RenderUnit* pRenderUnit )
{
    HRESULT hr;
    UINT iAdapter = pRenderUnit->iAdapter;
    D3DAdapterInfo* pD3DAdapterInfo = m_Adapters[iAdapter];
    DWORD iMonitor = pD3DAdapterInfo->iMonitor;
    D3DDeviceInfo* pD3DDeviceInfo;
    D3DModeInfo* pD3DModeInfo;
    DWORD dwCurrentDevice;
    D3DDEVTYPE curType;

    if( iAdapter >= m_dwNumAdapters )
        return E_FAIL;

    if( pD3DAdapterInfo->dwNumDevices == 0 )
        return E_FAIL;

    // Find the best device for the adapter.  Use HAL
    // if it's there, otherwise SW, otherwise REF.
    dwCurrentDevice = 0xffff;
    curType = D3DDEVTYPE_FORCE_DWORD;
    for( DWORD iDevice = 0; iDevice < pD3DAdapterInfo->dwNumDevices; iDevice++)
    {
        pD3DDeviceInfo = &pD3DAdapterInfo->devices[iDevice];
        if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_HAL && !pD3DAdapterInfo->bDisableHW )
        {
            dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_HAL;
            break; // stop looking
        }
        else if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_SW )
        {
            dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_SW;
            // but keep looking
        }
        else if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_REF && m_bAllowRef && curType != D3DDEVTYPE_SW )
        {
            dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_REF;
            // but keep looking
        }
    }
    if( dwCurrentDevice == 0xffff )
        return D3DAPPERR_NOHARDWAREDEVICE;
    pD3DDeviceInfo = &pD3DAdapterInfo->devices[dwCurrentDevice];

    pD3DDeviceInfo->dwCurrentMode = 0xffff;
    if( pD3DAdapterInfo->dwUserPrefWidth != 0 )
    {
        // Try to find mode that matches user preference
        for( DWORD iMode = 0; iMode < pD3DDeviceInfo->dwNumModes; iMode++)
        {
            pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];
            if( pD3DModeInfo->Width == pD3DAdapterInfo->dwUserPrefWidth &&
                pD3DModeInfo->Height == pD3DAdapterInfo->dwUserPrefHeight &&
                pD3DModeInfo->Format == pD3DAdapterInfo->d3dfmtUserPrefFormat )
            {
                pD3DDeviceInfo->dwCurrentMode = iMode;
                break;
            }
        }
    }

    // If user-preferred mode is not specified or not found,
    // use "Automatic" technique: 
    if( pD3DDeviceInfo->dwCurrentMode == 0xffff )
    {
        if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_SW )
        {
            // If using a SW rast then try to find a low resolution and 16-bpp.
            BOOL bFound16BitMode = FALSE;            
            DWORD dwSmallestHeight = -1;
            pD3DDeviceInfo->dwCurrentMode = 0; // unless we find something better

            for( DWORD iMode = 0; iMode < pD3DDeviceInfo->dwNumModes; iMode++)
            {
                pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];

                // Skip 640x400 because 640x480 is better
                if( pD3DModeInfo->Height == 400 )
                    continue; 

                if( pD3DModeInfo->Height < dwSmallestHeight || 
                    (pD3DModeInfo->Height == dwSmallestHeight && !bFound16BitMode) )
                {
                    dwSmallestHeight = pD3DModeInfo->Height;
                    pD3DDeviceInfo->dwCurrentMode = iMode;
                    bFound16BitMode = FALSE;

                    if( ( pD3DModeInfo->Format == D3DFMT_R5G6B5 ||
                          pD3DModeInfo->Format == D3DFMT_X1R5G5B5 || 
                          pD3DModeInfo->Format == D3DFMT_A1R5G5B5 || 
                          pD3DModeInfo->Format == D3DFMT_A4R4G4B4 || 
                          pD3DModeInfo->Format == D3DFMT_X4R4G4B4 ) )
                    {
                        bFound16BitMode = TRUE;
                    }
                }
            }
        }
        else
        {
            // Try to find mode matching desktop resolution and 32-bpp.
            BOOL bMatchedSize = FALSE;
            BOOL bGot32Bit = FALSE;
            pD3DDeviceInfo->dwCurrentMode = 0; // unless we find something better
            for( DWORD iMode = 0; iMode < pD3DDeviceInfo->dwNumModes; iMode++)
            {
                pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];
                if( pD3DModeInfo->Width == pD3DAdapterInfo->d3ddmDesktop.Width &&
                    pD3DModeInfo->Height == pD3DAdapterInfo->d3ddmDesktop.Height )
                {
                    if( !bMatchedSize )
                        pD3DDeviceInfo->dwCurrentMode = iMode;
                    bMatchedSize = TRUE;
                    if( !bGot32Bit &&
                        ( pD3DModeInfo->Format == D3DFMT_X8R8G8B8 ||
                          pD3DModeInfo->Format == D3DFMT_A8R8G8B8 ) )
                    {
                        pD3DDeviceInfo->dwCurrentMode = iMode;
                        bGot32Bit = TRUE;
                        break;
                    }
                }
            }
        }
    }

    // If desktop mode not found, pick highest mode available
    if( pD3DDeviceInfo->dwCurrentMode == 0xffff )
    {
        DWORD dwWidthMax = 0;
        DWORD dwHeightMax = 0;
        DWORD dwBppMax = 0;
        DWORD dwWidthCur = 0;
        DWORD dwHeightCur = 0;
        DWORD dwBppCur = 0;
        for( DWORD iMode = 0; iMode < pD3DDeviceInfo->dwNumModes; iMode++)
        {
            pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];
            dwWidthCur = pD3DModeInfo->Width;
            dwHeightCur = pD3DModeInfo->Height;
            if( pD3DModeInfo->Format == D3DFMT_X8R8G8B8 ||
                pD3DModeInfo->Format == D3DFMT_A8R8G8B8 )
            {
                dwBppCur = 32;
            }
            else
            {
                dwBppCur = 16;
            }
            if( dwWidthCur > dwWidthMax ||
                dwHeightCur > dwHeightMax ||
                dwWidthCur == dwWidthMax && dwHeightCur == dwHeightMax && dwBppCur > dwBppMax )
            {
                dwWidthMax = dwWidthCur;
                dwHeightMax = dwHeightCur;
                dwBppMax = dwBppCur;
                pD3DDeviceInfo->dwCurrentMode = iMode;
            }
        }
    }

    // Try to create the D3D device, falling back to lower-res modes if it fails
    BOOL bAtLeastOneFailure = FALSE;
    while( TRUE )
    {
        pD3DModeInfo = &pD3DDeviceInfo->modes[pD3DDeviceInfo->dwCurrentMode];
        pRenderUnit->DeviceType = pD3DDeviceInfo->DeviceType;
        pRenderUnit->dwBehavior = pD3DModeInfo->dwBehavior;
        pRenderUnit->iMonitor = iMonitor;
        pRenderUnit->d3dpp.BackBufferFormat = pD3DModeInfo->Format;
        pRenderUnit->d3dpp.BackBufferWidth = pD3DModeInfo->Width;
        pRenderUnit->d3dpp.BackBufferHeight = pD3DModeInfo->Height;
        pRenderUnit->d3dpp.Windowed = FALSE;
        pRenderUnit->d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
        pRenderUnit->d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
        pRenderUnit->d3dpp.AutoDepthStencilFormat = pD3DModeInfo->DepthStencilFormat;
        pRenderUnit->d3dpp.BackBufferCount = 1;
        pRenderUnit->d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
        pRenderUnit->d3dpp.SwapEffect = m_SwapEffectFullscreen;
        pRenderUnit->d3dpp.hDeviceWindow = pD3DAdapterInfo->hWndDevice;
        pRenderUnit->d3dpp.EnableAutoDepthStencil = m_bUseDepthBuffer;
        pRenderUnit->d3dpp.Flags = 0;

        // Create device
        hr = m_pD3D->CreateDevice( iAdapter, pRenderUnit->DeviceType, 
                                   m_hWnd, // (this is the focus window)
                                   pRenderUnit->dwBehavior, &pRenderUnit->d3dpp, 
                                   &pRenderUnit->pd3dDevice );
        if( SUCCEEDED( hr ) )
        {
            // Give the client app an opportunity to reject this mode
            // due to not enough video memory, or any other reason
            if( SUCCEEDED( hr = ConfirmMode( pRenderUnit->pd3dDevice ) ) )
                break;
            else
                SAFE_RELEASE( pRenderUnit->pd3dDevice );
        }

        // If we get here, remember that CreateDevice or ConfirmMode failed, so
        // we can change the default mode next time
        bAtLeastOneFailure = TRUE;

        if( !FindNextLowerMode( pD3DDeviceInfo ) )
            break;
    }

    if( SUCCEEDED( hr ) && bAtLeastOneFailure && m_strRegPath[0] != TEXT('\0') )
    {
        // Record the mode that succeeded in the registry so we can 
        // default to it next time
        TCHAR strKey[100];
        HKEY hkeyParent;
        HKEY hkey;

        pD3DAdapterInfo->dwUserPrefWidth = pRenderUnit->d3dpp.BackBufferWidth;
        pD3DAdapterInfo->dwUserPrefHeight = pRenderUnit->d3dpp.BackBufferHeight;
        pD3DAdapterInfo->d3dfmtUserPrefFormat = pRenderUnit->d3dpp.BackBufferFormat;

        if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
            0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyParent, NULL ) )
        {
            wsprintf( strKey, TEXT("Screen %d"), iMonitor + 1 );
            if( ERROR_SUCCESS == RegCreateKeyEx( hkeyParent, strKey, 
                0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
            {
                RegSetValueEx( hkey, TEXT("Width"), NULL, REG_DWORD, 
                    (BYTE*)&pD3DAdapterInfo->dwUserPrefWidth, sizeof(DWORD) );
                RegSetValueEx( hkey, TEXT("Height"), NULL, REG_DWORD, 
                    (BYTE*)&pD3DAdapterInfo->dwUserPrefHeight, sizeof(DWORD) );
                RegSetValueEx( hkey, TEXT("Format"), NULL, REG_DWORD, 
                    (BYTE*)&pD3DAdapterInfo->d3dfmtUserPrefFormat, sizeof(DWORD) );
                RegSetValueEx( hkey, TEXT("Adapter ID"), NULL, REG_BINARY, 
                    (BYTE*)&pD3DAdapterInfo->d3dAdapterIdentifier.DeviceIdentifier, sizeof(GUID) );
                RegCloseKey( hkey );
            }
            RegCloseKey( hkeyParent );
        }
    }

    return hr;
}




//-----------------------------------------------------------------------------
// Name: FindNextLowerMode()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CD3DScreensaver::FindNextLowerMode( D3DDeviceInfo* pD3DDeviceInfo )
{
    DWORD iModeCur = pD3DDeviceInfo->dwCurrentMode;
    D3DModeInfo* pD3DModeInfoCur = &pD3DDeviceInfo->modes[iModeCur];
    DWORD dwWidthCur = pD3DModeInfoCur->Width;
    DWORD dwHeightCur = pD3DModeInfoCur->Height;
    DWORD dwNumPixelsCur = dwWidthCur * dwHeightCur;
    D3DFORMAT d3dfmtCur = pD3DModeInfoCur->Format;
    BOOL b32BitCur = (d3dfmtCur == D3DFMT_A8R8G8B8 ||
                      d3dfmtCur == D3DFMT_X8R8G8B8);
    DWORD iModeNew;
    D3DModeInfo* pD3DModeInfoNew;
    DWORD dwWidthNew;
    DWORD dwHeightNew;
    DWORD dwNumPixelsNew;
    D3DFORMAT d3dfmtNew = D3DFMT_UNKNOWN;
    BOOL b32BitNew;

    DWORD dwWidthBest = 0;
    DWORD dwHeightBest = 0;
    DWORD dwNumPixelsBest = 0;
    BOOL b32BitBest = FALSE;
    DWORD iModeBest = 0xffff;

    for( iModeNew = 0; iModeNew < pD3DDeviceInfo->dwNumModes; iModeNew++ )
    {
        // Don't pick the same mode we currently have
        if( iModeNew == iModeCur )
            continue;

        // Get info about new mode
        pD3DModeInfoNew = &pD3DDeviceInfo->modes[iModeNew];
        dwWidthNew = pD3DModeInfoNew->Width;
        dwHeightNew = pD3DModeInfoNew->Height;
        dwNumPixelsNew = dwWidthNew * dwHeightNew;
        d3dfmtNew = pD3DModeInfoNew->Format;
        b32BitNew = (d3dfmtNew == D3DFMT_A8R8G8B8 ||
                     d3dfmtNew == D3DFMT_X8R8G8B8);

        // If we're currently 32-bit and new mode is same width/height and 16-bit, take it
        if( b32BitCur && 
            !b32BitNew &&
            pD3DModeInfoNew->Width == dwWidthCur &&
            pD3DModeInfoNew->Height == dwHeightCur)
        {
            pD3DDeviceInfo->dwCurrentMode = iModeNew;
            return TRUE;
        }

        // If new mode is smaller than current mode, see if it's our best so far
        if( dwNumPixelsNew < dwNumPixelsCur )
        {
            // If current best is 32-bit, new mode needs to be bigger to be best
            if( b32BitBest && (dwNumPixelsNew < dwNumPixelsBest ) )
                continue;

            // If new mode is bigger or equal to best, make it the best
            if( (dwNumPixelsNew > dwNumPixelsBest) || 
                (!b32BitBest && b32BitNew) )
            {
                dwWidthBest = dwWidthNew;
                dwHeightBest = dwHeightNew;
                dwNumPixelsBest = dwNumPixelsNew;
                iModeBest = iModeNew;
                b32BitBest = b32BitNew;
            }
        }
    }
    if( iModeBest == 0xffff )
        return FALSE; // no smaller mode found
    pD3DDeviceInfo->dwCurrentMode = iModeBest;
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: CreateWindowedRenderUnit()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::CreateWindowedRenderUnit( RenderUnit* pRenderUnit )
{
    HRESULT hr;
    UINT iAdapter = pRenderUnit->iAdapter;
    D3DAdapterInfo* pD3DAdapterInfo = m_Adapters[iAdapter];
    DWORD iMonitor = pD3DAdapterInfo->iMonitor;
    D3DDeviceInfo* pD3DDeviceInfo;
    D3DDEVTYPE curType;

    // Find the best device for the primary adapter.  Use HAL
    // if it's there, otherwise SW, otherwise REF.
    pD3DAdapterInfo->dwCurrentDevice = 0xffff; // unless we find something better
    curType = D3DDEVTYPE_FORCE_DWORD;
    for( DWORD iDevice = 0; iDevice < pD3DAdapterInfo->dwNumDevices; iDevice++)
    {
        pD3DDeviceInfo = &pD3DAdapterInfo->devices[iDevice];
        if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_HAL && !pD3DAdapterInfo->bDisableHW &&
            pD3DDeviceInfo->bCanDoWindowed )
        {
            pD3DAdapterInfo->dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_HAL;
            break;
        }
        else if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_SW &&
            pD3DDeviceInfo->bCanDoWindowed )
        {
            pD3DAdapterInfo->dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_SW;
            // but keep looking
        }
        else if( pD3DDeviceInfo->DeviceType == D3DDEVTYPE_REF && m_bAllowRef && curType != D3DDEVTYPE_SW )
        {
            pD3DAdapterInfo->dwCurrentDevice = iDevice;
            curType = D3DDEVTYPE_REF;
            // but keep looking
        }
    }
    if( pD3DAdapterInfo->dwCurrentDevice == 0xffff )
        return D3DAPPERR_NOHARDWAREDEVICE;
    pD3DDeviceInfo = &pD3DAdapterInfo->devices[pD3DAdapterInfo->dwCurrentDevice];

    D3DWindowedModeInfo D3DWindowedModeInfo;

    D3DWindowedModeInfo.DisplayFormat = pD3DAdapterInfo->d3ddmDesktop.Format;
    D3DWindowedModeInfo.BackBufferFormat = pD3DAdapterInfo->d3ddmDesktop.Format;
    if( FAILED( CheckWindowedFormat( iAdapter, &D3DWindowedModeInfo ) ) )
    {
        D3DWindowedModeInfo.BackBufferFormat = D3DFMT_A8R8G8B8;
        if( FAILED( CheckWindowedFormat( iAdapter, &D3DWindowedModeInfo ) ) )
        {
            D3DWindowedModeInfo.BackBufferFormat = D3DFMT_X8R8G8B8;
            if( FAILED( CheckWindowedFormat( iAdapter, &D3DWindowedModeInfo ) ) )
            {
                D3DWindowedModeInfo.BackBufferFormat = D3DFMT_A1R5G5B5;
                if( FAILED( CheckWindowedFormat( iAdapter, &D3DWindowedModeInfo ) ) )
                {
                    D3DWindowedModeInfo.BackBufferFormat = D3DFMT_R5G6B5;
                    if( FAILED( CheckWindowedFormat( iAdapter, &D3DWindowedModeInfo ) ) )
                    {
                        return E_FAIL;
                    }
                }
            }
        }
    }

    pRenderUnit->DeviceType = pD3DDeviceInfo->DeviceType;
    pRenderUnit->dwBehavior = D3DWindowedModeInfo.dwBehavior;
    pRenderUnit->iMonitor = iMonitor;
    pRenderUnit->d3dpp.BackBufferWidth = 0;
    pRenderUnit->d3dpp.BackBufferHeight = 0;
    pRenderUnit->d3dpp.Windowed = TRUE;
    pRenderUnit->d3dpp.FullScreen_RefreshRateInHz = 0;
    pRenderUnit->d3dpp.FullScreen_PresentationInterval = 0;
    pRenderUnit->d3dpp.BackBufferFormat = D3DWindowedModeInfo.BackBufferFormat;
    pRenderUnit->d3dpp.AutoDepthStencilFormat = D3DWindowedModeInfo.DepthStencilFormat;
    pRenderUnit->d3dpp.BackBufferCount = 1;
    pRenderUnit->d3dpp.MultiSampleType = D3DMULTISAMPLE_NONE;
    pRenderUnit->d3dpp.SwapEffect = m_SwapEffectWindowed;
    pRenderUnit->d3dpp.hDeviceWindow = pD3DAdapterInfo->hWndDevice;
    pRenderUnit->d3dpp.EnableAutoDepthStencil = m_bUseDepthBuffer;
    pRenderUnit->d3dpp.Flags = 0;
    // Create device
    hr = m_pD3D->CreateDevice( iAdapter, pRenderUnit->DeviceType, m_hWnd,
                               pRenderUnit->dwBehavior, &pRenderUnit->d3dpp, &pRenderUnit->pd3dDevice );
    if ( FAILED(hr) )
    {
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: UpdateDeviceStats()
// Desc: Store device description
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::UpdateDeviceStats()
{
    DWORD iRenderUnit;
    RenderUnit* pRenderUnit; 
    for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
    {
        pRenderUnit = &m_RenderUnits[iRenderUnit];
        if( pRenderUnit->DeviceType == D3DDEVTYPE_REF )
            lstrcpy( pRenderUnit->strDeviceStats, TEXT("REF") );
        else if( pRenderUnit->DeviceType == D3DDEVTYPE_HAL )
            lstrcpy( pRenderUnit->strDeviceStats, TEXT("HAL") );
        else if( pRenderUnit->DeviceType == D3DDEVTYPE_SW )
            lstrcpy( pRenderUnit->strDeviceStats, TEXT("SW") );

        if( pRenderUnit->dwBehavior & D3DCREATE_HARDWARE_VERTEXPROCESSING &&
            pRenderUnit->dwBehavior & D3DCREATE_PUREDEVICE )
        {
            if( pRenderUnit->DeviceType == D3DDEVTYPE_HAL )
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (pure hw vp)") );
            else
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (simulated pure hw vp)") );
        }
        else if( pRenderUnit->dwBehavior & D3DCREATE_HARDWARE_VERTEXPROCESSING )
        {
            if( pRenderUnit->DeviceType == D3DDEVTYPE_HAL )
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (hw vp)") );
            else
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (simulated hw vp)") );
        }
        else if( pRenderUnit->dwBehavior & D3DCREATE_MIXED_VERTEXPROCESSING )
        {
            if( pRenderUnit->DeviceType == D3DDEVTYPE_HAL )
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (mixed vp)") );
            else
                lstrcat( pRenderUnit->strDeviceStats, TEXT(" (simulated mixed vp)") );
        }
        else if( pRenderUnit->dwBehavior & D3DCREATE_SOFTWARE_VERTEXPROCESSING )
        {
            lstrcat( pRenderUnit->strDeviceStats, TEXT(" (sw vp)") );
        }

        if( pRenderUnit->DeviceType == D3DDEVTYPE_HAL )
        {
            lstrcat( pRenderUnit->strDeviceStats, TEXT(": ") );
            TCHAR szDescription[300];
            DXUtil_ConvertAnsiStringToGeneric( szDescription, 
                m_Adapters[pRenderUnit->iAdapter]->d3dAdapterIdentifier.Description, 300 );
            lstrcat( pRenderUnit->strDeviceStats, szDescription );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: SwitchToRenderUnit()
// Desc: Updates internal variables and notifies client that we are switching
//       to a new RenderUnit / D3D device.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::SwitchToRenderUnit( UINT iRenderUnit )
{
    RenderUnit* pRenderUnit = &m_RenderUnits[iRenderUnit];
    MonitorInfo* pMonitorInfo = &m_Monitors[pRenderUnit->iMonitor];

    m_pd3dDevice = pRenderUnit->pd3dDevice;
    if( !m_bWindowed )
        m_rcRenderCurDevice = pMonitorInfo->rcScreen;

    if( m_pd3dDevice != NULL )
    {
        // Store render target surface desc
        LPDIRECT3DSURFACE8 pBackBuffer;
        m_pd3dDevice->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &pBackBuffer );
        pBackBuffer->GetDesc( &m_d3dsdBackBuffer );
        pBackBuffer->Release();
    }

    lstrcpy( m_strDeviceStats, pRenderUnit->strDeviceStats );
    lstrcpy( m_strFrameStats, pRenderUnit->strFrameStats );

    // Notify the client to switch to this device
    SetDevice(iRenderUnit);
}




//-----------------------------------------------------------------------------
// Name: SetProjectionMatrix()
// Desc: This function sets up an appropriate projection matrix to support 
//       rendering the appropriate parts of the scene to each screen.
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::SetProjectionMatrix( FLOAT fNear, FLOAT fFar )
{
    D3DXMATRIX mat;
    INT cx, cy;
    INT dx, dy;
    INT dd;
    FLOAT l,r,t,b;

    if( m_bAllScreensSame )
    {
        cx = (m_rcRenderCurDevice.right + m_rcRenderCurDevice.left) / 2;
        cy = (m_rcRenderCurDevice.bottom + m_rcRenderCurDevice.top) / 2;
        dx = m_rcRenderCurDevice.right - m_rcRenderCurDevice.left;
        dy = m_rcRenderCurDevice.bottom - m_rcRenderCurDevice.top;
    }
    else
    {
        cx = (m_rcRenderTotal.right + m_rcRenderTotal.left) / 2;
        cy = (m_rcRenderTotal.bottom + m_rcRenderTotal.top) / 2;
        dx = m_rcRenderTotal.right - m_rcRenderTotal.left;
        dy = m_rcRenderTotal.bottom - m_rcRenderTotal.top;
    }

    dd = (dx > dy ? dy : dx);

    l = FLOAT(m_rcRenderCurDevice.left - cx) / (FLOAT)(dd);
    r = FLOAT(m_rcRenderCurDevice.right - cx) / (FLOAT)(dd);
    t = FLOAT(m_rcRenderCurDevice.top - cy) / (FLOAT)(dd);
    b = FLOAT(m_rcRenderCurDevice.bottom - cy) / (FLOAT)(dd);

    l = fNear * l;
    r = fNear * r;
    t = fNear * t;
    b = fNear * b;

    D3DXMatrixPerspectiveOffCenterLH( &mat, l, r, t, b, fNear, fFar );
    return m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &mat );
}




//-----------------------------------------------------------------------------
// Name: SortModesCallback()
// Desc: Callback function for sorting display modes (used by BuildDeviceList).
//-----------------------------------------------------------------------------
static int SortModesCallback( const VOID* arg1, const VOID* arg2 )
{
    D3DDISPLAYMODE* p1 = (D3DDISPLAYMODE*)arg1;
    D3DDISPLAYMODE* p2 = (D3DDISPLAYMODE*)arg2;

    if( p1->Width  < p2->Width )    return -1;
    if( p1->Width  > p2->Width )    return +1;
    if( p1->Height < p2->Height )   return -1;
    if( p1->Height > p2->Height )   return +1;
    if( p1->Format > p2->Format )   return -1;
    if( p1->Format < p2->Format )   return +1;

    return 0;
}




//-----------------------------------------------------------------------------
// Name: BuildDeviceList()
// Desc: Builds a list of all available adapters, devices, and modes.
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::BuildDeviceList()
{
    DWORD dwNumDeviceTypes;
    const TCHAR* strDeviceDescs[] = { TEXT("HAL"), TEXT("SW"), TEXT("REF") };
    const D3DDEVTYPE DeviceTypes[] = { D3DDEVTYPE_HAL, D3DDEVTYPE_SW, D3DDEVTYPE_REF };
    if( m_bAllowRef )
        dwNumDeviceTypes = 3;
    else
        dwNumDeviceTypes = 2;

    HMONITOR hMonitor = NULL;
    BOOL bHALExists = FALSE;
    BOOL bHALIsWindowedCompatible = FALSE;
    BOOL bHALIsDesktopCompatible = FALSE;
    BOOL bHALIsSampleCompatible = FALSE;

    // Loop through all the adapters on the system (usually, there's just one
    // unless more than one graphics card is present).
    for( UINT iAdapter = 0; iAdapter < m_pD3D->GetAdapterCount(); iAdapter++ )
    {
        // Fill in adapter info
        if( m_Adapters[m_dwNumAdapters] == NULL )
        {
            m_Adapters[m_dwNumAdapters] = new D3DAdapterInfo;
            if( m_Adapters[m_dwNumAdapters] == NULL )
                return E_OUTOFMEMORY;
            ZeroMemory( m_Adapters[m_dwNumAdapters], sizeof(D3DAdapterInfo) );
        }

        D3DAdapterInfo* pAdapter  = m_Adapters[m_dwNumAdapters];
        m_pD3D->GetAdapterIdentifier( iAdapter, D3DENUM_NO_WHQL_LEVEL, &pAdapter->d3dAdapterIdentifier );
        m_pD3D->GetAdapterDisplayMode( iAdapter, &pAdapter->d3ddmDesktop );
        pAdapter->dwNumDevices    = 0;
        pAdapter->dwCurrentDevice = 0;
        pAdapter->bLeaveBlack = FALSE;
        pAdapter->iMonitor = NO_MONITOR;

        // Find the MonitorInfo that corresponds to this adapter.  If the monitor
        // is disabled, the adapter has a NULL HMONITOR and we cannot find the 
        // corresponding MonitorInfo.  (Well, if one monitor was disabled, we
        // could link the one MonitorInfo with a NULL HMONITOR to the one
        // D3DAdapterInfo with a NULL HMONITOR, but if there are more than one,
        // we can't link them, so it's safer not to ever try.)
        hMonitor = m_pD3D->GetAdapterMonitor( iAdapter );
        if( hMonitor != NULL )
        {
            for( DWORD iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
            {
                MonitorInfo* pMonitorInfo;
                pMonitorInfo = &m_Monitors[iMonitor];
                if( pMonitorInfo->hMonitor == hMonitor )
                {
                    pAdapter->iMonitor = iMonitor;
                    pMonitorInfo->iAdapter = iAdapter;
                    break;
                }
            }
        }

        // Enumerate all display modes on this adapter
        D3DDISPLAYMODE modes[100];
        D3DFORMAT      formats[20];
        DWORD dwNumFormats      = 0;
        DWORD dwNumModes        = 0;
        DWORD dwNumAdapterModes = m_pD3D->GetAdapterModeCount( iAdapter );

        // Add the adapter's current desktop format to the list of formats
        formats[dwNumFormats++] = pAdapter->d3ddmDesktop.Format;

        for( UINT iMode = 0; iMode < dwNumAdapterModes; iMode++ )
        {
            // Get the display mode attributes
            D3DDISPLAYMODE DisplayMode;
            m_pD3D->EnumAdapterModes( iAdapter, iMode, &DisplayMode );

            // Filter out low-resolution modes
            if( DisplayMode.Width  < 640 || DisplayMode.Height < 400 )
                continue;

            // Check if the mode already exists (to filter out refresh rates)
            for( DWORD m=0L; m<dwNumModes; m++ )
            {
                if( ( modes[m].Width  == DisplayMode.Width  ) &&
                    ( modes[m].Height == DisplayMode.Height ) &&
                    ( modes[m].Format == DisplayMode.Format ) )
                    break;
            }

            // If we found a new mode, add it to the list of modes
            if( m == dwNumModes )
            {
                modes[dwNumModes].Width       = DisplayMode.Width;
                modes[dwNumModes].Height      = DisplayMode.Height;
                modes[dwNumModes].Format      = DisplayMode.Format;
                modes[dwNumModes].RefreshRate = 0;
                dwNumModes++;

                // Check if the mode's format already exists
                for( DWORD f=0; f<dwNumFormats; f++ )
                {
                    if( DisplayMode.Format == formats[f] )
                        break;
                }

                // If the format is new, add it to the list
                if( f== dwNumFormats )
                    formats[dwNumFormats++] = DisplayMode.Format;
            }
        }

        // Sort the list of display modes (by format, then width, then height)
        qsort( modes, dwNumModes, sizeof(D3DDISPLAYMODE), SortModesCallback );

        // Add devices to adapter
        for( UINT iDevice = 0; iDevice < dwNumDeviceTypes; iDevice++ )
        {
            // Fill in device info
            D3DDeviceInfo* pDevice;
            pDevice                 = &pAdapter->devices[pAdapter->dwNumDevices];
            pDevice->DeviceType     = DeviceTypes[iDevice];
            m_pD3D->GetDeviceCaps( iAdapter, DeviceTypes[iDevice], &pDevice->d3dCaps );
            pDevice->strDesc        = strDeviceDescs[iDevice];
            pDevice->dwNumModes     = 0;
            pDevice->dwCurrentMode  = 0;
            pDevice->bCanDoWindowed = FALSE;
            pDevice->bWindowed      = FALSE;
            pDevice->MultiSampleType = D3DMULTISAMPLE_NONE;

            // Examine each format supported by the adapter to see if it will
            // work with this device and meets the needs of the application.
            BOOL  bFormatConfirmed[20];
            DWORD dwBehavior[20];
            D3DFORMAT fmtDepthStencil[20];

            for( DWORD f=0; f<dwNumFormats; f++ )
            {
                bFormatConfirmed[f] = FALSE;
                fmtDepthStencil[f] = D3DFMT_UNKNOWN;

                // Skip formats that cannot be used as render targets on this device
                if( FAILED( m_pD3D->CheckDeviceType( iAdapter, pDevice->DeviceType,
                                                     formats[f], formats[f], FALSE ) ) )
                    continue;

                if( pDevice->DeviceType == D3DDEVTYPE_SW )
                {
                    // This system has a SW device
                    pAdapter->bHasSW = TRUE;
                }

                if( pDevice->DeviceType == D3DDEVTYPE_HAL )
                {
                    // This system has a HAL device
                    bHALExists = TRUE;
                    pAdapter->bHasHAL = TRUE;

                    if( pDevice->d3dCaps.Caps2 & D3DCAPS2_CANRENDERWINDOWED )
                    {
                        // HAL can run in a window for some mode
                        bHALIsWindowedCompatible = TRUE;

                        if( f == 0 )
                        {
                            // HAL can run in a window for the current desktop mode
                            bHALIsDesktopCompatible = TRUE;
                        }
                    }
                }

                // Confirm the device/format for HW vertex processing
                if( pDevice->d3dCaps.DevCaps&D3DDEVCAPS_HWTRANSFORMANDLIGHT )
                {
                    if( pDevice->d3dCaps.DevCaps&D3DDEVCAPS_PUREDEVICE )
                    {
                        dwBehavior[f] = D3DCREATE_HARDWARE_VERTEXPROCESSING |
                                        D3DCREATE_PUREDEVICE;

                        if( SUCCEEDED( ConfirmDevice( &pDevice->d3dCaps, dwBehavior[f],
                                                      formats[f] ) ) )
                            bFormatConfirmed[f] = TRUE;
                    }

                    if ( FALSE == bFormatConfirmed[f] )
                    {
                        dwBehavior[f] = D3DCREATE_HARDWARE_VERTEXPROCESSING;

                        if( SUCCEEDED( ConfirmDevice( &pDevice->d3dCaps, dwBehavior[f],
                                                      formats[f] ) ) )
                            bFormatConfirmed[f] = TRUE;
                    }

                    if ( FALSE == bFormatConfirmed[f] )
                    {
                        dwBehavior[f] = D3DCREATE_MIXED_VERTEXPROCESSING;

                        if( SUCCEEDED( ConfirmDevice( &pDevice->d3dCaps, dwBehavior[f],
                                                      formats[f] ) ) )
                            bFormatConfirmed[f] = TRUE;
                    }
                }

                // Confirm the device/format for SW vertex processing
                if( FALSE == bFormatConfirmed[f] )
                {
                    dwBehavior[f] = D3DCREATE_SOFTWARE_VERTEXPROCESSING;

                    if( SUCCEEDED( ConfirmDevice( &pDevice->d3dCaps, dwBehavior[f],
                                                  formats[f] ) ) )
                        bFormatConfirmed[f] = TRUE;
                }

                if( bFormatConfirmed[f] && m_bMultithreaded )
                {
                    dwBehavior[f] |= D3DCREATE_MULTITHREADED;
                }

                // Find a suitable depth/stencil buffer format for this device/format
                if( bFormatConfirmed[f] && m_bUseDepthBuffer )
                {
                    if( !FindDepthStencilFormat( iAdapter, pDevice->DeviceType,
                        formats[f], &fmtDepthStencil[f] ) )
                    {
                        bFormatConfirmed[f] = FALSE;
                    }
                }
            }

            // Add all enumerated display modes with confirmed formats to the
            // device's list of valid modes
            for( DWORD m=0L; m<dwNumModes; m++ )
            {
                for( DWORD f=0; f<dwNumFormats; f++ )
                {
                    if( modes[m].Format == formats[f] )
                    {
                        if( bFormatConfirmed[f] == TRUE )
                        {
                            // Add this mode to the device's list of valid modes
                            pDevice->modes[pDevice->dwNumModes].Width      = modes[m].Width;
                            pDevice->modes[pDevice->dwNumModes].Height     = modes[m].Height;
                            pDevice->modes[pDevice->dwNumModes].Format     = modes[m].Format;
                            pDevice->modes[pDevice->dwNumModes].dwBehavior = dwBehavior[f];
                            pDevice->modes[pDevice->dwNumModes].DepthStencilFormat = fmtDepthStencil[f];
                            pDevice->dwNumModes++;

                            if( pDevice->DeviceType == D3DDEVTYPE_HAL )
                                bHALIsSampleCompatible = TRUE;
                        }
                    }
                }
            }

            // Select any 640x480 mode for default (but prefer a 16-bit mode)
            for( m=0; m<pDevice->dwNumModes; m++ )
            {
                if( pDevice->modes[m].Width==640 && pDevice->modes[m].Height==480 )
                {
                    pDevice->dwCurrentMode = m;
                    if( pDevice->modes[m].Format == D3DFMT_R5G6B5 ||
                        pDevice->modes[m].Format == D3DFMT_X1R5G5B5 ||
                        pDevice->modes[m].Format == D3DFMT_A1R5G5B5 )
                    {
                        break;
                    }
                }
            }

            // Check if the device is compatible with the desktop display mode
            // (which was added initially as formats[0])
            if( bFormatConfirmed[0] && (pDevice->d3dCaps.Caps2 & D3DCAPS2_CANRENDERWINDOWED) )
            {
                pDevice->bCanDoWindowed = TRUE;
                pDevice->bWindowed      = TRUE;
            }

            // If valid modes were found, keep this device
            if( pDevice->dwNumModes > 0 )
            {
                pAdapter->dwNumDevices++;
                if( pDevice->DeviceType == D3DDEVTYPE_SW )
                    pAdapter->bHasAppCompatSW = TRUE;
                else if( pDevice->DeviceType == D3DDEVTYPE_HAL )
                    pAdapter->bHasAppCompatHAL = TRUE;
            }
        }

        // If valid devices were found, keep this adapter
// Count adapters even if no devices, so we can throw up blank windows on them
//        if( pAdapter->dwNumDevices > 0 )
            m_dwNumAdapters++;
    }
/*
    // Return an error if no compatible devices were found
    if( 0L == m_dwNumAdapters )
        return D3DAPPERR_NOCOMPATIBLEDEVICES;

    // Pick a default device that can render into a window
    // (This code assumes that the HAL device comes before the REF
    // device in the device array).
    for( DWORD a=0; a<m_dwNumAdapters; a++ )
    {
        for( DWORD d=0; d < m_Adapters[a]->dwNumDevices; d++ )
        {
            if( m_Adapters[a]->devices[d].bWindowed )
            {
                m_Adapters[a]->dwCurrentDevice = d;
                m_dwAdapter = a;
                m_bWindowed = TRUE;

                // Display a warning message
                if( m_Adapters[a]->devices[d].DeviceType == D3DDEVTYPE_REF )
                {
                    if( !bHALExists )
                        DisplayErrorMsg( D3DAPPERR_NOHARDWAREDEVICE, MSGWARN_SWITCHEDTOREF );
                    else if( !bHALIsSampleCompatible )
                        DisplayErrorMsg( D3DAPPERR_HALNOTCOMPATIBLE, MSGWARN_SWITCHEDTOREF );
                    else if( !bHALIsWindowedCompatible )
                        DisplayErrorMsg( D3DAPPERR_NOWINDOWEDHAL, MSGWARN_SWITCHEDTOREF );
                    else if( !bHALIsDesktopCompatible )
                        DisplayErrorMsg( D3DAPPERR_NODESKTOPHAL, MSGWARN_SWITCHEDTOREF );
                    else // HAL is desktop compatible, but not sample compatible
                        DisplayErrorMsg( D3DAPPERR_NOHALTHISMODE, MSGWARN_SWITCHEDTOREF );
                }

                return S_OK;
            }
        }
    }
    return D3DAPPERR_NOWINDOWABLEDEVICES;
*/

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CheckWindowedFormat()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::CheckWindowedFormat( UINT iAdapter, D3DWindowedModeInfo* pD3DWindowedModeInfo )
{
    HRESULT hr;
    D3DAdapterInfo* pD3DAdapterInfo = m_Adapters[iAdapter];
    D3DDeviceInfo* pD3DDeviceInfo = &pD3DAdapterInfo->devices[pD3DAdapterInfo->dwCurrentDevice];
    BOOL bFormatConfirmed = FALSE;

    if( FAILED( hr = m_pD3D->CheckDeviceType( iAdapter, pD3DDeviceInfo->DeviceType,
        pD3DAdapterInfo->d3ddmDesktop.Format, pD3DWindowedModeInfo->BackBufferFormat, TRUE ) ) )
    {
        return hr;
    }

    // Confirm the device/format for HW vertex processing
    if( pD3DDeviceInfo->d3dCaps.DevCaps&D3DDEVCAPS_HWTRANSFORMANDLIGHT )
    {
        if( pD3DDeviceInfo->d3dCaps.DevCaps&D3DDEVCAPS_PUREDEVICE )
        {
            pD3DWindowedModeInfo->dwBehavior = D3DCREATE_HARDWARE_VERTEXPROCESSING |
                            D3DCREATE_PUREDEVICE;

            if( SUCCEEDED( ConfirmDevice( &pD3DDeviceInfo->d3dCaps, pD3DWindowedModeInfo->dwBehavior,
                                          pD3DWindowedModeInfo->BackBufferFormat ) ) )
                bFormatConfirmed = TRUE;
        }

        if ( !bFormatConfirmed )
        {
            pD3DWindowedModeInfo->dwBehavior = D3DCREATE_HARDWARE_VERTEXPROCESSING;

            if( SUCCEEDED( ConfirmDevice( &pD3DDeviceInfo->d3dCaps, pD3DWindowedModeInfo->dwBehavior,
                                          pD3DWindowedModeInfo->BackBufferFormat ) ) )
                bFormatConfirmed = TRUE;
        }

        if ( !bFormatConfirmed )
        {
            pD3DWindowedModeInfo->dwBehavior = D3DCREATE_MIXED_VERTEXPROCESSING;

            if( SUCCEEDED( ConfirmDevice( &pD3DDeviceInfo->d3dCaps, pD3DWindowedModeInfo->dwBehavior,
                                          pD3DWindowedModeInfo->BackBufferFormat ) ) )
                bFormatConfirmed = TRUE;
        }
    }

    // Confirm the device/format for SW vertex processing
    if( !bFormatConfirmed )
    {
        pD3DWindowedModeInfo->dwBehavior = D3DCREATE_SOFTWARE_VERTEXPROCESSING;

        if( SUCCEEDED( ConfirmDevice( &pD3DDeviceInfo->d3dCaps, pD3DWindowedModeInfo->dwBehavior,
                                      pD3DWindowedModeInfo->BackBufferFormat ) ) )
            bFormatConfirmed = TRUE;
    }

    if( bFormatConfirmed && m_bMultithreaded )
    {
        pD3DWindowedModeInfo->dwBehavior |= D3DCREATE_MULTITHREADED;
    }

    // Find a suitable depth/stencil buffer format for this device/format
    if( bFormatConfirmed && m_bUseDepthBuffer )
    {
        if( !FindDepthStencilFormat( iAdapter, pD3DDeviceInfo->DeviceType,
            pD3DWindowedModeInfo->BackBufferFormat, &pD3DWindowedModeInfo->DepthStencilFormat ) )
        {
            bFormatConfirmed = FALSE;
        }
    }

    if( !bFormatConfirmed )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FindDepthStencilFormat()
// Desc: Finds a depth/stencil format for the given device that is compatible
//       with the render target format and meets the needs of the app.
//-----------------------------------------------------------------------------
BOOL CD3DScreensaver::FindDepthStencilFormat( UINT iAdapter, D3DDEVTYPE DeviceType,
    D3DFORMAT TargetFormat, D3DFORMAT* pDepthStencilFormat )
{
    if( m_dwMinDepthBits <= 16 && m_dwMinStencilBits == 0 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D16 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D16 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D16;
                return TRUE;
            }
        }
    }

    if( m_dwMinDepthBits <= 15 && m_dwMinStencilBits <= 1 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D15S1 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D15S1 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D15S1;
                return TRUE;
            }
        }
    }

    if( m_dwMinDepthBits <= 24 && m_dwMinStencilBits == 0 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D24X8 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D24X8 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D24X8;
                return TRUE;
            }
        }
    }

    if( m_dwMinDepthBits <= 24 && m_dwMinStencilBits <= 8 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D24S8 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D24S8 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D24S8;
                return TRUE;
            }
        }
    }

    if( m_dwMinDepthBits <= 24 && m_dwMinStencilBits <= 4 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D24X4S4 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D24X4S4 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D24X4S4;
                return TRUE;
            }
        }
    }

    if( m_dwMinDepthBits <= 32 && m_dwMinStencilBits == 0 )
    {
        if( SUCCEEDED( m_pD3D->CheckDeviceFormat( iAdapter, DeviceType,
            TargetFormat, D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, D3DFMT_D32 ) ) )
        {
            if( SUCCEEDED( m_pD3D->CheckDepthStencilMatch( iAdapter, DeviceType,
                TargetFormat, TargetFormat, D3DFMT_D32 ) ) )
            {
                *pDepthStencilFormat = D3DFMT_D32;
                return TRUE;
            }
        }
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: Cleanup3DEnvironment()
// Desc: 
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::Cleanup3DEnvironment()
{
    RenderUnit* pRenderUnit;

    for( DWORD iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
    {
        pRenderUnit = &m_RenderUnits[iRenderUnit];
        SwitchToRenderUnit( iRenderUnit );
        if( pRenderUnit->bDeviceObjectsRestored )
        {
            InvalidateDeviceObjects();
            pRenderUnit->bDeviceObjectsRestored = FALSE;
        }
        if( pRenderUnit->bDeviceObjectsInited )
        {
            DeleteDeviceObjects();
            pRenderUnit->bDeviceObjectsInited = FALSE;
        }
        SAFE_RELEASE(m_pd3dDevice);
    }
    m_dwNumRenderUnits = 0;
    SAFE_RELEASE(m_pD3D);
}




//-----------------------------------------------------------------------------
// Name: Render3DEnvironment()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::Render3DEnvironment()
{
    HRESULT hr;
    RenderUnit* pRenderUnit;
    D3DAdapterInfo* pAdapterInfo;

    m_fTime        = DXUtil_Timer( TIMER_GETAPPTIME );
    m_fElapsedTime = DXUtil_Timer( TIMER_GETELAPSEDTIME );


    // Tell client to update the world
    FrameMove();
    UpdateFrameStats();

    for( DWORD iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
    {
        pRenderUnit = &m_RenderUnits[iRenderUnit];
        pAdapterInfo = m_Adapters[pRenderUnit->iAdapter];

        SwitchToRenderUnit( iRenderUnit );

        if( m_pd3dDevice == NULL )
            continue;

        // Test the cooperative level to see if it's okay to render
        if( FAILED( hr = m_pd3dDevice->TestCooperativeLevel() ) )
        {
            // If the device was lost, do not render until we get it back
            if( D3DERR_DEVICELOST == hr )
                return S_OK;

            // Check if the device needs to be reset.
            if( D3DERR_DEVICENOTRESET == hr )
            {
                // If we are windowed, read the desktop mode and use the same format for
                // the back buffer
                if( m_bWindowed )
                {
                    m_pD3D->GetAdapterDisplayMode( pRenderUnit->iAdapter, &pAdapterInfo->d3ddmDesktop );
//                    m_d3dpp.BackBufferFormat = pAdapterInfo->d3ddmDesktop.Format;
                }

                if( pRenderUnit->bDeviceObjectsRestored )
                {
                    InvalidateDeviceObjects();
                    pRenderUnit->bDeviceObjectsRestored = FALSE;
                }
                if( FAILED( hr = m_pd3dDevice->Reset( &pRenderUnit->d3dpp ) ) )
                {
                    m_bErrorMode = TRUE;
                }
                else
                {
                    if( FAILED( hr = RestoreDeviceObjects() ) )
                    {
                        m_bErrorMode = TRUE;
                    }
                    else
                    {
                        pRenderUnit->bDeviceObjectsRestored = TRUE;
                    }
                }
            }
        }

        // Tell client to render using the current device
        Render();
    }

    // Call Present() in a separate loop once all rendering is done
    // so multiple monitors are as closely synced visually as possible
    for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
    {
        pRenderUnit = &m_RenderUnits[iRenderUnit];
        SwitchToRenderUnit( iRenderUnit );
        // Present the results of the rendering to the screen
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: UpdateErrorBox()
// Desc: Update the box that shows the error message
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::UpdateErrorBox()
{
    MonitorInfo* pMonitorInfo;
    HWND hwnd;
    RECT rcBounds;
    static DWORD dwTimeLast = 0;
    DWORD dwTimeNow;
    FLOAT fTimeDelta;

    // Make sure all the RenderUnits / D3D devices have been torn down
    // so the error box is visible
    if( m_bErrorMode && m_dwNumRenderUnits > 0 )
    {
        Cleanup3DEnvironment();
    }

    // Update timing to determine how much to move error box
    if( dwTimeLast == 0 )
        dwTimeLast = timeGetTime();
    dwTimeNow = timeGetTime();
    fTimeDelta = (FLOAT)(dwTimeNow - dwTimeLast) / 1000.0f;
    dwTimeLast = dwTimeNow;

    // Load error string if necessary
    if( m_szError[0] == TEXT('\0') )
    {
        GetTextForError( m_hrError, m_szError, sizeof(m_szError) / sizeof(TCHAR) );
    }

    for( DWORD iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        hwnd = pMonitorInfo->hWnd;
        if( hwnd == NULL )
            continue;
        if( m_SaverMode == sm_full )
        {
            rcBounds = pMonitorInfo->rcScreen;
            ScreenToClient( hwnd, (POINT*)&rcBounds.left );
            ScreenToClient( hwnd, (POINT*)&rcBounds.right );
        }
        else
        {
            rcBounds = m_rcRenderTotal;
        }

        if( pMonitorInfo->widthError == 0 )
        {
            if( m_SaverMode == sm_preview )                
            {
                pMonitorInfo->widthError = (float) (rcBounds.right - rcBounds.left);
                pMonitorInfo->heightError = (float) (rcBounds.bottom - rcBounds.top);
                pMonitorInfo->xError = 0.0f;
                pMonitorInfo->yError = 0.0f;
                pMonitorInfo->xVelError = 0.0f;
                pMonitorInfo->yVelError = 0.0f;
                InvalidateRect( hwnd, NULL, FALSE );    // Invalidate the hwnd so it gets drawn
                UpdateWindow( hwnd );
            }
            else
            {
                pMonitorInfo->widthError = 300;
                pMonitorInfo->heightError = 150;
                pMonitorInfo->xError = (rcBounds.right + rcBounds.left - pMonitorInfo->widthError) / 2.0f;
                pMonitorInfo->yError = (rcBounds.bottom + rcBounds.top - pMonitorInfo->heightError) / 2.0f;
                pMonitorInfo->xVelError = (rcBounds.right - rcBounds.left) / 10.0f;
                pMonitorInfo->yVelError = (rcBounds.bottom - rcBounds.top) / 20.0f;
            }
        }
        else
        {
            if( m_SaverMode != sm_preview )
            {
                RECT rcOld;
                RECT rcNew;

                SetRect( &rcOld, (INT)pMonitorInfo->xError, (INT)pMonitorInfo->yError,
                    (INT)(pMonitorInfo->xError + pMonitorInfo->widthError),
                    (INT)(pMonitorInfo->yError + pMonitorInfo->heightError) );

                // Update rect velocity
                if( (pMonitorInfo->xError + pMonitorInfo->xVelError * fTimeDelta + 
                    pMonitorInfo->widthError > rcBounds.right && pMonitorInfo->xVelError > 0.0f) ||
                    (pMonitorInfo->xError + pMonitorInfo->xVelError * fTimeDelta < 
                    rcBounds.left && pMonitorInfo->xVelError < 0.0f) )
                {
                    pMonitorInfo->xVelError = -pMonitorInfo->xVelError;
                }
                if( (pMonitorInfo->yError + pMonitorInfo->yVelError * fTimeDelta + 
                    pMonitorInfo->heightError > rcBounds.bottom && pMonitorInfo->yVelError > 0.0f) ||
                    (pMonitorInfo->yError + pMonitorInfo->yVelError * fTimeDelta < 
                    rcBounds.top && pMonitorInfo->yVelError < 0.0f) )
                {
                    pMonitorInfo->yVelError = -pMonitorInfo->yVelError;
                }
                // Update rect position
                pMonitorInfo->xError += pMonitorInfo->xVelError * fTimeDelta;
                pMonitorInfo->yError += pMonitorInfo->yVelError * fTimeDelta;
            
                SetRect( &rcNew, (INT)pMonitorInfo->xError, (INT)pMonitorInfo->yError,
                    (INT)(pMonitorInfo->xError + pMonitorInfo->widthError),
                    (INT)(pMonitorInfo->yError + pMonitorInfo->heightError) );

                if( rcOld.left != rcNew.left || rcOld.top != rcNew.top )
                {
                    InvalidateRect( hwnd, &rcOld, FALSE );    // Invalidate old rect so it gets erased
                    InvalidateRect( hwnd, &rcNew, FALSE );    // Invalidate new rect so it gets drawn
                    UpdateWindow( hwnd );
                }
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: GetTextForError()
// Desc: Translate an HRESULT error code into a string that can be displayed
//       to explain the error.  A class derived from CD3DScreensaver can 
//       provide its own version of this function that provides app-specific
//       error translation instead of or in addition to calling this function.
//       This function returns TRUE if a specific error was translated, or
//       FALSE if no specific translation for the HRESULT was found (though
//       it still puts a generic string into pszError).
//-----------------------------------------------------------------------------
BOOL CD3DScreensaver::GetTextForError( HRESULT hr, TCHAR* pszError, 
                                       DWORD dwNumChars )
{
    const DWORD dwErrorMap[][2] = 
    {
    //  HRESULT, stringID
        E_FAIL, IDS_ERR_GENERIC,
        D3DAPPERR_NODIRECT3D, IDS_ERR_NODIRECT3D,
        D3DAPPERR_NOWINDOWEDHAL, IDS_ERR_NOWINDOWEDHAL,
        D3DAPPERR_CREATEDEVICEFAILED, IDS_ERR_CREATEDEVICEFAILED,
        D3DAPPERR_NOCOMPATIBLEDEVICES, IDS_ERR_NOCOMPATIBLEDEVICES,
        D3DAPPERR_NOHARDWAREDEVICE, IDS_ERR_NOHARDWAREDEVICE,
        D3DAPPERR_HALNOTCOMPATIBLE, IDS_ERR_HALNOTCOMPATIBLE,
        D3DAPPERR_NOHALTHISMODE, IDS_ERR_NOHALTHISMODE,   
        D3DAPPERR_MEDIANOTFOUND, IDS_ERR_MEDIANOTFOUND,   
        D3DAPPERR_RESIZEFAILED, IDS_ERR_RESIZEFAILED,    
        E_OUTOFMEMORY, IDS_ERR_OUTOFMEMORY,     
        D3DERR_OUTOFVIDEOMEMORY, IDS_ERR_OUTOFVIDEOMEMORY,
        D3DAPPERR_NOPREVIEW, IDS_ERR_NOPREVIEW
    };
    const DWORD dwErrorMapSize = sizeof(dwErrorMap) / sizeof(DWORD[2]);

    DWORD iError;
    DWORD resid = 0;

    for( iError = 0; iError < dwErrorMapSize; iError++ )
    {
        if( hr == (HRESULT)dwErrorMap[iError][0] )
        {
            resid = dwErrorMap[iError][1];
        }
    }
    if( resid == 0 )
    {
        resid = IDS_ERR_GENERIC;
    }

    LoadString( NULL, resid, pszError, dwNumChars );

    if( resid == IDS_ERR_GENERIC )
        return FALSE;
    else
        return TRUE;
}




//-----------------------------------------------------------------------------
// Name: UpdateFrameStats()
// Desc: Keep track of the frame count
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::UpdateFrameStats()
{
    UINT iRenderUnit;
    RenderUnit* pRenderUnit;
    UINT iAdapter;
    static FLOAT fLastTime = 0.0f;
    static DWORD dwFrames  = 0L;
    FLOAT fTime = DXUtil_Timer( TIMER_GETABSOLUTETIME );

    ++dwFrames;

    // Update the scene stats once per second
    if( fTime - fLastTime > 1.0f )
    {
        m_fFPS    = dwFrames / (fTime - fLastTime);
        fLastTime = fTime;
        dwFrames  = 0L;

        for( iRenderUnit = 0; iRenderUnit < m_dwNumRenderUnits; iRenderUnit++ )
        {
            pRenderUnit = &m_RenderUnits[iRenderUnit];
            iAdapter = pRenderUnit->iAdapter;

            // Get adapter's current mode so we can report
            // bit depth (back buffer depth may be unknown)
            D3DDISPLAYMODE mode;
            m_pD3D->GetAdapterDisplayMode( iAdapter, &mode );

            _stprintf( pRenderUnit->strFrameStats, TEXT("%.02f fps (%dx%dx%d)"), m_fFPS,
                       mode.Width, mode.Height,
                       mode.Format==D3DFMT_X8R8G8B8?32:16 );
            if( m_bUseDepthBuffer )
            {
                D3DAdapterInfo* pAdapterInfo = m_Adapters[iAdapter];
                D3DDeviceInfo*  pDeviceInfo  = &pAdapterInfo->devices[pAdapterInfo->dwCurrentDevice];
                D3DModeInfo*    pModeInfo    = &pDeviceInfo->modes[pDeviceInfo->dwCurrentMode];

                switch( pModeInfo->DepthStencilFormat )
                {
                case D3DFMT_D16:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D16)") );
                    break;
                case D3DFMT_D15S1:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D15S1)") );
                    break;
                case D3DFMT_D24X8:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D24X8)") );
                    break;
                case D3DFMT_D24S8:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D24S8)") );
                    break;
                case D3DFMT_D24X4S4:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D24X4S4)") );
                    break;
                case D3DFMT_D32:
                    lstrcat( pRenderUnit->strFrameStats, TEXT(" (D32)") );
                    break;
                }
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: DoPaint()
// Desc: 
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::DoPaint(HWND hwnd, HDC hdc)
{
    HMONITOR hMonitor = MonitorFromWindow( hwnd, MONITOR_DEFAULTTONEAREST );
    MonitorInfo* pMonitorInfo = NULL;

    for( DWORD iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++)
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        if( pMonitorInfo->hMonitor == hMonitor )
            break;
    }

    if( pMonitorInfo == NULL || iMonitor == m_dwNumMonitors )
        return;

    // Draw the error message box
    HBRUSH hbrBlack = (HBRUSH)GetStockObject(BLACK_BRUSH);
    RECT rc;
    SetRect( &rc, (INT)pMonitorInfo->xError, (INT)pMonitorInfo->yError,
        (INT)(pMonitorInfo->xError + pMonitorInfo->widthError),
        (INT)(pMonitorInfo->yError + pMonitorInfo->heightError) );
    FillRect(hdc, &rc, (HBRUSH)(COLOR_WINDOW+1));
    if( hbrBlack != NULL )
        FrameRect(hdc, &rc, hbrBlack);
    RECT rc2;
    int height;
    rc2 = rc;
    height = DrawText(hdc, m_szError, -1, &rc, DT_WORDBREAK | DT_CENTER | DT_CALCRECT );
    rc = rc2;

    rc2.top = (rc.bottom + rc.top - height) / 2;

    DrawText(hdc, m_szError, -1, &rc2, DT_WORDBREAK | DT_CENTER );

    // Erase everywhere except the error message box
    ExcludeClipRect( hdc, rc.left, rc.top, rc.right, rc.bottom );
    rc = pMonitorInfo->rcScreen;
    ScreenToClient( hwnd, (POINT*)&rc.left );
    ScreenToClient( hwnd, (POINT*)&rc.right );
    if( hbrBlack != NULL )
        FillRect(hdc, &rc, hbrBlack );
}




//-----------------------------------------------------------------------------
// Name: ChangePassword()
// Desc:
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::ChangePassword()
{
    // Load the password change DLL
    HINSTANCE mpr = LoadLibrary( TEXT("MPR.DLL") );

    if ( mpr != NULL )
    {
        // Grab the password change function from it
        typedef DWORD (PASCAL *PWCHGPROC)( LPCSTR, HWND, DWORD, LPVOID );
        PWCHGPROC pwd = (PWCHGPROC)GetProcAddress( mpr, "PwdChangePasswordA" );

        // Do the password change
        if ( pwd != NULL )
            pwd( "SCRSAVE", m_hWndParent, 0, NULL );

        // Free the library
        FreeLibrary( mpr );
    }
}




//-----------------------------------------------------------------------------
// Name: DisplayErrorMsg()
// Desc: Displays error messages in a message box
//-----------------------------------------------------------------------------
HRESULT CD3DScreensaver::DisplayErrorMsg( HRESULT hr, DWORD dwType )
{
    TCHAR strMsg[512];

    GetTextForError( hr, strMsg, 512 );

    MessageBox( m_hWnd, strMsg, m_strWindowTitle, MB_ICONERROR | MB_OK );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: ReadScreenSettings()
// Desc: Read the registry settings that affect how the screens are set up and
//       used.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::ReadScreenSettings( HKEY hkeyParent )
{
    TCHAR strKey[100];
    DWORD iMonitor;
    MonitorInfo* pMonitorInfo;
    DWORD iAdapter;
    D3DAdapterInfo* pD3DAdapterInfo;
    HKEY hkey;
    DWORD dwType = REG_DWORD;
    DWORD dwLength = sizeof(DWORD);
    DWORD dwLength2 = sizeof(GUID);
    GUID guidAdapterID;
    GUID guidZero;
    ZeroMemory( &guidAdapterID, sizeof(GUID) );
    ZeroMemory( &guidZero, sizeof(GUID) );

    RegQueryValueEx( hkeyParent, TEXT("AllScreensSame"), NULL, &dwType, 
        (BYTE*)&m_bAllScreensSame, &dwLength);
    for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        iAdapter = pMonitorInfo->iAdapter;
        if( iAdapter == NO_ADAPTER )
            continue; 
        pD3DAdapterInfo = m_Adapters[iAdapter];
        wsprintf( strKey, TEXT("Screen %d"), iMonitor + 1 );
        if( ERROR_SUCCESS == RegCreateKeyEx( hkeyParent, strKey, 
            0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
        {
            RegQueryValueEx( hkey, TEXT("Adapter ID"), NULL, &dwType, 
                (BYTE*)&guidAdapterID, &dwLength2);

            RegQueryValueEx( hkey, TEXT("Leave Black"), NULL, &dwType, 
                (BYTE*)&pD3DAdapterInfo->bLeaveBlack, &dwLength);

            if( guidAdapterID == pD3DAdapterInfo->d3dAdapterIdentifier.DeviceIdentifier ||
                guidAdapterID == guidZero )
            {
                RegQueryValueEx( hkey, TEXT("Disable Hardware"), NULL, &dwType, 
                    (BYTE*)&pD3DAdapterInfo->bDisableHW, &dwLength);
                RegQueryValueEx( hkey, TEXT("Width"), NULL, &dwType, 
                    (BYTE*)&pD3DAdapterInfo->dwUserPrefWidth, &dwLength);
                RegQueryValueEx( hkey, TEXT("Height"), NULL, &dwType, 
                    (BYTE*)&pD3DAdapterInfo->dwUserPrefHeight, &dwLength);
                RegQueryValueEx( hkey, TEXT("Format"), NULL, &dwType, 
                    (BYTE*)&pD3DAdapterInfo->d3dfmtUserPrefFormat, &dwLength);
            }
            RegCloseKey( hkey);
        }
    }
}




//-----------------------------------------------------------------------------
// Name: WriteScreenSettings()
// Desc: Write the registry settings that affect how the screens are set up and
//       used.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::WriteScreenSettings( HKEY hkeyParent )
{
    TCHAR strKey[100];
    DWORD iMonitor;
    MonitorInfo* pMonitorInfo;
    DWORD iAdapter;
    D3DAdapterInfo* pD3DAdapterInfo;
    HKEY hkey;

    RegSetValueEx( hkeyParent, TEXT("AllScreensSame"), NULL, REG_DWORD, 
        (BYTE*)&m_bAllScreensSame, sizeof(DWORD) );
    for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
    {
        pMonitorInfo = &m_Monitors[iMonitor];
        iAdapter = pMonitorInfo->iAdapter;
        if( iAdapter == NO_ADAPTER )
            continue; 
        pD3DAdapterInfo = m_Adapters[iAdapter];
        wsprintf( strKey, TEXT("Screen %d"), iMonitor + 1 );
        if( ERROR_SUCCESS == RegCreateKeyEx( hkeyParent, strKey, 
            0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
        {
            RegSetValueEx( hkey, TEXT("Leave Black"), NULL, REG_DWORD, 
                (BYTE*)&pD3DAdapterInfo->bLeaveBlack, sizeof(DWORD) );
            RegSetValueEx( hkey, TEXT("Disable Hardware"), NULL, REG_DWORD, 
                (BYTE*)&pD3DAdapterInfo->bDisableHW, sizeof(DWORD) );
            RegSetValueEx( hkey, TEXT("Width"), NULL, REG_DWORD, 
                (BYTE*)&pD3DAdapterInfo->dwUserPrefWidth, sizeof(DWORD) );
            RegSetValueEx( hkey, TEXT("Height"), NULL, REG_DWORD, 
                (BYTE*)&pD3DAdapterInfo->dwUserPrefHeight, sizeof(DWORD) );
            RegSetValueEx( hkey, TEXT("Format"), NULL, REG_DWORD, 
                (BYTE*)&pD3DAdapterInfo->d3dfmtUserPrefFormat, sizeof(DWORD) );
            RegSetValueEx( hkey, TEXT("Adapter ID"), NULL, REG_BINARY, 
                (BYTE*)&pD3DAdapterInfo->d3dAdapterIdentifier.DeviceIdentifier, sizeof(GUID) );
            RegCloseKey( hkey);
        }
    }
}




//-----------------------------------------------------------------------------
// Name: DoScreenSettingsDialog()
// Desc: 
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::DoScreenSettingsDialog( HWND hwndParent )
{
    LPCTSTR pstrTemplate;

    if( m_dwNumAdapters > 1 && !m_bOneScreenOnly )
        pstrTemplate = MAKEINTRESOURCE( IDD_MULTIMONITORSETTINGS );
    else
        pstrTemplate = MAKEINTRESOURCE( IDD_SINGLEMONITORSETTINGS );

    DialogBox(m_hInstance, pstrTemplate, hwndParent, ScreenSettingsDlgProcStub );
}




//-----------------------------------------------------------------------------
// Name: ScreenSettingsDlgProcStub()
// Desc:
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CD3DScreensaver::ScreenSettingsDlgProcStub( HWND hWnd, UINT uMsg,
                                                 WPARAM wParam, LPARAM lParam )
{
    return s_pD3DScreensaver->ScreenSettingsDlgProc( hWnd, uMsg, wParam, lParam );
}




// We need to store a copy of the original screen settings so that the user
// can modify those settings in the dialog, then hit Cancel and have the
// original settings restored.
static D3DAdapterInfo* s_AdaptersSave[9];
static BOOL s_bAllScreensSameSave;

//-----------------------------------------------------------------------------
// Name: ScreenSettingsDlgProc()
// Desc:
//-----------------------------------------------------------------------------
INT_PTR CD3DScreensaver::ScreenSettingsDlgProc( HWND hWnd, UINT uMsg, 
                                                WPARAM wParam, LPARAM lParam )
{
    HWND hwndTabs = GetDlgItem(hWnd, IDC_MONITORSTAB);
    HWND hwndModeList = GetDlgItem(hWnd, IDC_MODESCOMBO);
    DWORD iMonitor;
    MonitorInfo* pMonitorInfo;
    DWORD iAdapter;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            INT i = 0;
            TC_ITEM tie; 
            TCHAR szFmt[100];
            TCHAR sz[100];

            GetWindowText(GetDlgItem(hWnd, IDC_TABNAMEFMT), szFmt, 100);

            tie.mask = TCIF_TEXT | TCIF_IMAGE; 
            tie.iImage = -1; 
            for( iMonitor = 0; iMonitor < m_dwNumMonitors; iMonitor++ )
            {
                wsprintf(sz, szFmt, iMonitor + 1);
                tie.pszText = sz; 
                TabCtrl_InsertItem(hwndTabs, i++, &tie);
            }
            for( iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
            {
                s_AdaptersSave[iAdapter] = new D3DAdapterInfo;
                if( s_AdaptersSave[iAdapter] != NULL )
                    *s_AdaptersSave[iAdapter] = *m_Adapters[iAdapter];
            }
            s_bAllScreensSameSave = m_bAllScreensSame;
            SetupAdapterPage(hWnd);
            CheckDlgButton(hWnd, IDC_SAME, (m_bAllScreensSame ? BST_CHECKED : BST_UNCHECKED));
        }
        return TRUE;
 
    case WM_NOTIFY:
        {
            NMHDR* pnmh = (LPNMHDR)lParam;
            UINT code = pnmh->code;
            if (code == TCN_SELCHANGE)
            {
                SetupAdapterPage(hWnd);
            }
        }
        return TRUE;

    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {
        case IDC_SAME:
            m_bAllScreensSame = (IsDlgButtonChecked(hWnd, IDC_SAME) == BST_CHECKED);
            break;

        case IDC_LEAVEBLACK:
        case IDC_RENDER:
            if( m_bOneScreenOnly )
            {
                GetBestAdapter( &iAdapter );
                iMonitor = m_Adapters[iAdapter]->iMonitor;
            }
            else
            {
                iMonitor = TabCtrl_GetCurSel(hwndTabs);
            }
            pMonitorInfo = &m_Monitors[iMonitor];
            iAdapter = pMonitorInfo->iAdapter;
            if( IsDlgButtonChecked(hWnd, IDC_LEAVEBLACK) == BST_CHECKED )
            {
                m_Adapters[iAdapter]->bLeaveBlack = TRUE;
                EnableWindow(GetDlgItem(hWnd, IDC_MODESCOMBO), FALSE);
                EnableWindow(GetDlgItem(hWnd, IDC_MODESSTATIC), FALSE);
                EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODEBOX), FALSE);
                EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODENOTE), FALSE);
            }
            else
            {
                m_Adapters[iAdapter]->bLeaveBlack = FALSE;
                EnableWindow(GetDlgItem(hWnd, IDC_MODESCOMBO), TRUE);
                EnableWindow(GetDlgItem(hWnd, IDC_MODESSTATIC), TRUE);
                EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODEBOX), TRUE);
                EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODENOTE), TRUE);
            }
            break;

        case IDC_MODESCOMBO:
            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                DWORD iSel;
                DWORD iMode;

                if( m_bOneScreenOnly )
                {
                    GetBestAdapter( &iAdapter );
                    iMonitor = m_Adapters[iAdapter]->iMonitor;
                }
                else
                {
                    iMonitor = TabCtrl_GetCurSel(hwndTabs);
                }
                pMonitorInfo = &m_Monitors[iMonitor];
                iAdapter = pMonitorInfo->iAdapter;
                iSel = ComboBox_GetCurSel( hwndModeList );
                if( iSel == 0 )
                {
                    // "Automatic"
                    m_Adapters[iAdapter]->dwUserPrefWidth = 0;
                    m_Adapters[iAdapter]->dwUserPrefHeight = 0;
                    m_Adapters[iAdapter]->d3dfmtUserPrefFormat = D3DFMT_UNKNOWN;
                }
                else
                {
                    D3DAdapterInfo* pD3DAdapterInfo = m_Adapters[iAdapter];
                    D3DDeviceInfo* pD3DDeviceInfo;
                    D3DModeInfo* pD3DModeInfo;
                    pD3DDeviceInfo = &pD3DAdapterInfo->devices[pD3DAdapterInfo->dwCurrentDevice];
                    iMode = (DWORD)ComboBox_GetItemData( hwndModeList, iSel );
                    pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];
                    m_Adapters[iAdapter]->dwUserPrefWidth = pD3DModeInfo->Width;
                    m_Adapters[iAdapter]->dwUserPrefHeight = pD3DModeInfo->Height;
                    m_Adapters[iAdapter]->d3dfmtUserPrefFormat = pD3DModeInfo->Format;
                }
            }
            break;

        case IDC_DISABLEHW:
            if( m_bOneScreenOnly )
            {
                GetBestAdapter( &iAdapter );
                iMonitor = m_Adapters[iAdapter]->iMonitor;
            }
            else
            {
                iMonitor = TabCtrl_GetCurSel(hwndTabs);
            }
            pMonitorInfo = &m_Monitors[iMonitor];
            iAdapter = pMonitorInfo->iAdapter;
            if( IsDlgButtonChecked( hWnd, IDC_DISABLEHW ) == BST_CHECKED )
                m_Adapters[iAdapter]->bDisableHW = TRUE;
            else
                m_Adapters[iAdapter]->bDisableHW = FALSE;
            SetupAdapterPage( hWnd );
            break;

        case IDC_MOREINFO:
            {
                if( m_bOneScreenOnly )
                {
                    GetBestAdapter( &iAdapter );
                    iMonitor = m_Adapters[iAdapter]->iMonitor;
                }
                else
                {
                    iMonitor = TabCtrl_GetCurSel(hwndTabs);
                }
                pMonitorInfo = &m_Monitors[iMonitor];
                iAdapter = pMonitorInfo->iAdapter;
                D3DAdapterInfo* pD3DAdapterInfo;
                TCHAR szText[500];

                if( pMonitorInfo->hMonitor == NULL )
                    pD3DAdapterInfo = NULL;
                else
                    pD3DAdapterInfo = m_Adapters[pMonitorInfo->iAdapter];

                // Accelerated / Unaccelerated settings
                BOOL bHasHAL = FALSE;
                BOOL bHasAppCompatHAL = FALSE;
                BOOL bDisabledHAL = FALSE;
                BOOL bHasSW = FALSE;
                BOOL bHasAppCompatSW = FALSE;
    
                if( pD3DAdapterInfo != NULL )
                {
                    bHasHAL = pD3DAdapterInfo->bHasHAL;
                    bHasAppCompatHAL = pD3DAdapterInfo->bHasAppCompatHAL;
                    bDisabledHAL = pD3DAdapterInfo->bDisableHW;
                    bHasSW = pD3DAdapterInfo->bHasSW;
                    bHasAppCompatSW = pD3DAdapterInfo->bHasAppCompatSW;
                }
                if( bHasHAL && !bDisabledHAL && bHasAppCompatHAL )
                {
                    // Good HAL
                    LoadString( NULL, IDS_INFO_GOODHAL, szText, 500 );
                }
                else if( bHasHAL && bDisabledHAL )
                {
                    // Disabled HAL
                    if( bHasSW && bHasAppCompatSW )
                        LoadString( NULL, IDS_INFO_DISABLEDHAL_GOODSW, szText, 500 );
                    else if( bHasSW )
                        LoadString( NULL, IDS_INFO_DISABLEDHAL_BADSW, szText, 500 );
                    else 
                        LoadString( NULL, IDS_INFO_DISABLEDHAL_NOSW, szText, 500 );
                }
                else if( bHasHAL && !bHasAppCompatHAL )
                {
                    // Bad HAL
                    if( bHasSW && bHasAppCompatSW )
                        LoadString( NULL, IDS_INFO_BADHAL_GOODSW, szText, 500 );
                    else if( bHasSW )
                        LoadString( NULL, IDS_INFO_BADHAL_BADSW, szText, 500 );
                    else 
                        LoadString( NULL, IDS_INFO_BADHAL_NOSW, szText, 500 );
                }
                else 
                {
                    // No HAL
                    if( bHasSW && bHasAppCompatSW )
                        LoadString( NULL, IDS_INFO_NOHAL_GOODSW, szText, 500 );
                    else if( bHasSW  )
                        LoadString( NULL, IDS_INFO_NOHAL_BADSW, szText, 500 );
                    else 
                        LoadString( NULL, IDS_INFO_NOHAL_NOSW, szText, 500 );
                }

                MessageBox( hWnd, szText, pMonitorInfo->strDeviceName, MB_OK | MB_ICONINFORMATION );
                break;
            }

        case IDOK:
            for( iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
            {
                SAFE_DELETE( s_AdaptersSave[iAdapter] );
            }
            EndDialog(hWnd, IDOK);
            break;

        case IDCANCEL:
            // Restore member values to original state
            for( iAdapter = 0; iAdapter < m_dwNumAdapters; iAdapter++ )
            {
                if( s_AdaptersSave[iAdapter] != NULL )
                    *m_Adapters[iAdapter] = *s_AdaptersSave[iAdapter];
                SAFE_DELETE( s_AdaptersSave[iAdapter] );
            }
            m_bAllScreensSame = s_bAllScreensSameSave;
            EndDialog(hWnd, IDCANCEL);
            break;
        }
        return TRUE;

    default:
        return FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: SetupAdapterPage()
// Desc: Set up the controls for a given page in the Screen Settings dialog.
//-----------------------------------------------------------------------------
VOID CD3DScreensaver::SetupAdapterPage( HWND hWnd )
{
    HWND hwndTabs = GetDlgItem(hWnd, IDC_MONITORSTAB);
    HWND hwndModeList = GetDlgItem(hWnd, IDC_MODESCOMBO);
    UINT iPage = TabCtrl_GetCurFocus(hwndTabs);
    HWND hwndDesc = GetDlgItem(hWnd, IDC_ADAPTERNAME);
    MonitorInfo* pMonitorInfo;
    D3DAdapterInfo* pD3DAdapterInfo;
    D3DDeviceInfo* pD3DDeviceInfo;
    D3DModeInfo* pD3DModeInfo;

    if( m_bOneScreenOnly )
    {
        DWORD iAdapter;
        GetBestAdapter( &iAdapter );
        if( iAdapter != NO_ADAPTER )
        {
            pD3DAdapterInfo = m_Adapters[iAdapter];
            iPage = pD3DAdapterInfo->iMonitor;
        }
    }

    pMonitorInfo = &m_Monitors[iPage];

    SetWindowText( hwndDesc, pMonitorInfo->strDeviceName );

    if( pMonitorInfo->iAdapter == NO_ADAPTER )
        pD3DAdapterInfo = NULL;
    else
        pD3DAdapterInfo = m_Adapters[pMonitorInfo->iAdapter];

    // Accelerated / Unaccelerated settings
    BOOL bHasHAL = FALSE;
    BOOL bHasAppCompatHAL = FALSE;
    BOOL bDisabledHAL = FALSE;
    BOOL bHasSW = FALSE;
    BOOL bHasAppCompatSW = FALSE;
    
    if( pD3DAdapterInfo != NULL )
    {
        bHasHAL = pD3DAdapterInfo->bHasHAL;
        bHasAppCompatHAL = pD3DAdapterInfo->bHasAppCompatHAL;
        bDisabledHAL = pD3DAdapterInfo->bDisableHW;
        bHasSW = pD3DAdapterInfo->bHasSW;
        bHasAppCompatSW = pD3DAdapterInfo->bHasAppCompatSW;
    }

    TCHAR szStatus[200];
    if( bHasHAL && !bDisabledHAL && bHasAppCompatHAL )
    {
        LoadString( NULL, IDS_RENDERING_HAL, szStatus, 200 );
    }
    else if( bHasSW && bHasAppCompatSW )
    {
        LoadString( NULL, IDS_RENDERING_SW, szStatus, 200 );
    }
    else
    {
        LoadString( NULL, IDS_RENDERING_NONE, szStatus, 200 );
    }
    SetWindowText( GetDlgItem( hWnd, IDC_RENDERING ), szStatus );

    if( bHasHAL && bHasAppCompatHAL )
    {
        EnableWindow( GetDlgItem( hWnd, IDC_DISABLEHW ), TRUE );
        CheckDlgButton( hWnd, IDC_DISABLEHW, 
            pD3DAdapterInfo->bDisableHW ? BST_CHECKED : BST_UNCHECKED );
    }
    else
    {
        EnableWindow( GetDlgItem( hWnd, IDC_DISABLEHW ), FALSE );
        CheckDlgButton( hWnd, IDC_DISABLEHW, BST_UNCHECKED );
    }

    if( bHasAppCompatHAL || bHasAppCompatSW )
    {
        if( pD3DAdapterInfo->bLeaveBlack )
            CheckRadioButton(hWnd, IDC_RENDER, IDC_LEAVEBLACK, IDC_LEAVEBLACK);
        else
            CheckRadioButton(hWnd, IDC_RENDER, IDC_LEAVEBLACK, IDC_RENDER);
        EnableWindow(GetDlgItem(hWnd, IDC_LEAVEBLACK), TRUE);
        EnableWindow(GetDlgItem(hWnd, IDC_RENDER), TRUE);
        EnableWindow(GetDlgItem(hWnd, IDC_SCREENUSAGEBOX), TRUE);

    }
    else
    {
        CheckRadioButton(hWnd, IDC_RENDER, IDC_LEAVEBLACK, IDC_LEAVEBLACK);
        EnableWindow(GetDlgItem(hWnd, IDC_LEAVEBLACK), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_RENDER), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_SCREENUSAGEBOX), FALSE);
    }

    if( IsDlgButtonChecked(hWnd, IDC_LEAVEBLACK) == BST_CHECKED )
    {
        EnableWindow(GetDlgItem(hWnd, IDC_MODESCOMBO), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_MODESSTATIC), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODEBOX), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODENOTE), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(hWnd, IDC_MODESCOMBO), TRUE);
        EnableWindow(GetDlgItem(hWnd, IDC_MODESSTATIC), TRUE);
        EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODEBOX), TRUE);
        EnableWindow(GetDlgItem(hWnd, IDC_DISPLAYMODENOTE), TRUE);
    }

    // Mode list
    ComboBox_ResetContent( hwndModeList );
    if( pD3DAdapterInfo == NULL )
        return;
    TCHAR strAutomatic[100];
    GetWindowText(GetDlgItem(hWnd, IDC_AUTOMATIC), strAutomatic, 100);
    ComboBox_AddString( hwndModeList, strAutomatic );
    ComboBox_SetItemData( hwndModeList, 0, -1 );
    pD3DDeviceInfo = &pD3DAdapterInfo->devices[pD3DAdapterInfo->dwCurrentDevice];
    DWORD iSelInitial = 0;
    TCHAR strModeFmt[100];

    GetWindowText(GetDlgItem(hWnd, IDC_MODEFMT), strModeFmt, 100);
    for( DWORD iMode = 0; iMode < pD3DDeviceInfo->dwNumModes; iMode++ )
    {
        DWORD dwBitDepth;
        TCHAR strMode[80];
        DWORD dwItem;

        pD3DModeInfo = &pD3DDeviceInfo->modes[iMode];
        dwBitDepth = 16;
        if( pD3DModeInfo->Format == D3DFMT_X8R8G8B8 ||
            pD3DModeInfo->Format == D3DFMT_A8R8G8B8 ||
            pD3DModeInfo->Format == D3DFMT_R8G8B8 )
        {
            dwBitDepth = 32;
        }

        wsprintf( strMode, strModeFmt, pD3DModeInfo->Width,
                  pD3DModeInfo->Height, dwBitDepth );
        dwItem = ComboBox_AddString( hwndModeList, strMode );
        ComboBox_SetItemData( hwndModeList, dwItem, iMode );

        if( pD3DModeInfo->Width == pD3DAdapterInfo->dwUserPrefWidth &&
            pD3DModeInfo->Height == pD3DAdapterInfo->dwUserPrefHeight &&
            pD3DModeInfo->Format == pD3DAdapterInfo->d3dfmtUserPrefFormat )
        {
            iSelInitial = dwItem;
        }
    }
    ComboBox_SetCurSel( hwndModeList, iSelInitial );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\d3dsaver\d3dsaver.h ===
//-----------------------------------------------------------------------------
// File: D3DSaver.h
//
// Desc: Framework for screensavers that use Direct3D 8.0.
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _D3DSAVER_H
#define _D3DSAVER_H


//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
enum APPMSGTYPE { MSG_NONE, MSGERR_APPMUSTEXIT, MSGWARN_SWITCHEDTOREF };

#define D3DAPPERR_NODIRECT3D          0x82000001
#define D3DAPPERR_NOWINDOW            0x82000002
#define D3DAPPERR_NOCOMPATIBLEDEVICES 0x82000003
#define D3DAPPERR_NOWINDOWABLEDEVICES 0x82000004
#define D3DAPPERR_NOHARDWAREDEVICE    0x82000005
#define D3DAPPERR_HALNOTCOMPATIBLE    0x82000006
#define D3DAPPERR_NOWINDOWEDHAL       0x82000007
#define D3DAPPERR_NODESKTOPHAL        0x82000008
#define D3DAPPERR_NOHALTHISMODE       0x82000009
#define D3DAPPERR_NONZEROREFCOUNT     0x8200000a
#define D3DAPPERR_MEDIANOTFOUND       0x8200000b
#define D3DAPPERR_RESIZEFAILED        0x8200000c
#define D3DAPPERR_INITDEVICEOBJECTSFAILED 0x8200000d
#define D3DAPPERR_CREATEDEVICEFAILED  0x8200000e
#define D3DAPPERR_NOPREVIEW           0x8200000f


//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------
#define MAX_DISPLAYS 9
#define NO_ADAPTER 0xffffffff
#define NO_MONITOR 0xffffffff


//***************************************************************************************
// Modes of operation for screensaver
enum SaverMode
{
    sm_config,         // Config dialog box
    sm_preview,        // Mini preview window in Display Properties dialog
    sm_full,           // Full-on screensaver mode
    sm_test,           // Test mode
    sm_passwordchange  // Change password
};


// Prototype for VerifyScreenSavePwd() in password.cpl, used on Win9x
typedef BOOL (PASCAL * VERIFYPWDPROC) (HWND);


//-----------------------------------------------------------------------------
// Name: struct D3DModeInfo
// Desc: Structure for holding information about a display mode
//-----------------------------------------------------------------------------
struct D3DModeInfo
{
    DWORD      Width;      // Screen width in this mode
    DWORD      Height;     // Screen height in this mode
    D3DFORMAT  Format;     // Pixel format in this mode
    DWORD      dwBehavior; // Hardware / Software / Mixed vertex processing
    D3DFORMAT  DepthStencilFormat; // Which depth/stencil format to use with this mode
};




//-----------------------------------------------------------------------------
// Name: struct D3DWindowedModeInfo
// Desc: Structure for holding information about a display mode
//-----------------------------------------------------------------------------
struct D3DWindowedModeInfo
{
    D3DFORMAT  DisplayFormat;
    D3DFORMAT  BackBufferFormat;
    DWORD      dwBehavior; // Hardware / Software / Mixed vertex processing
    D3DFORMAT  DepthStencilFormat; // Which depth/stencil format to use with this mode
};




//-----------------------------------------------------------------------------
// Name: struct D3DDeviceInfo
// Desc: Structure for holding information about a Direct3D device, including
//       a list of modes compatible with this device
//-----------------------------------------------------------------------------
struct D3DDeviceInfo
{
    // Device data
    D3DDEVTYPE   DeviceType;      // Reference, HAL, etc.
    D3DCAPS8     d3dCaps;         // Capabilities of this device
    const TCHAR* strDesc;         // Name of this device
    BOOL         bCanDoWindowed;  // Whether this device can work in windowed mode

    // Modes for this device
    DWORD        dwNumModes;
    D3DModeInfo  modes[150];

    // Current state
    DWORD        dwCurrentMode;
    BOOL         bWindowed;
    D3DMULTISAMPLE_TYPE MultiSampleType;
};




//-----------------------------------------------------------------------------
// Name: struct D3DAdapterInfo
// Desc: Structure for holding information about an adapter, including a list
//       of devices available on this adapter
//-----------------------------------------------------------------------------
struct D3DAdapterInfo
{
    // Adapter data
    DWORD          iMonitor; // Which MonitorInfo corresponds to this adapter
    D3DADAPTER_IDENTIFIER8 d3dAdapterIdentifier;
    D3DDISPLAYMODE d3ddmDesktop;      // Desktop display mode for this adapter

    // Devices for this adapter
    DWORD          dwNumDevices;
    D3DDeviceInfo  devices[3];
    BOOL           bHasHAL;
    BOOL           bHasAppCompatHAL;
    BOOL           bHasSW;
    BOOL           bHasAppCompatSW;

    // User's preferred mode settings for this adapter
    DWORD          dwUserPrefWidth;
    DWORD          dwUserPrefHeight;
    D3DFORMAT      d3dfmtUserPrefFormat;
    BOOL           bLeaveBlack;  // If TRUE, don't render to this display
    BOOL           bDisableHW;   // If TRUE, don't use HAL on this display

    // Current state
    DWORD          dwCurrentDevice;
    HWND           hWndDevice;
};




//-----------------------------------------------------------------------------
// Name: struct MonitorInfo
// Desc: Structure for holding information about a monitor
//-----------------------------------------------------------------------------
struct MonitorInfo
{
    TCHAR          strDeviceName[128];
    TCHAR          strMonitorName[128];
    HMONITOR       hMonitor;
    RECT           rcScreen;
    DWORD          iAdapter; // Which D3DAdapterInfo corresponds to this monitor
    HWND           hWnd;

    // Error message state
    FLOAT          xError;
    FLOAT          yError;
    FLOAT          widthError;
    FLOAT          heightError;
    FLOAT          xVelError;
    FLOAT          yVelError;
};




//-----------------------------------------------------------------------------
// Name: struct RenderUnit
// Desc: 
//-----------------------------------------------------------------------------
struct RenderUnit
{
    UINT                  iAdapter;
    UINT                  iMonitor;
    D3DDEVTYPE            DeviceType;      // Reference, HAL, etc.
    DWORD                 dwBehavior;
    IDirect3DDevice8*     pd3dDevice;
    D3DPRESENT_PARAMETERS d3dpp;
    BOOL                  bDeviceObjectsInited; // InitDeviceObjects was called
    BOOL                  bDeviceObjectsRestored; // RestoreDeviceObjects was called
    TCHAR                 strDeviceStats[90];// String to hold D3D device stats
    TCHAR                 strFrameStats[40]; // String to hold frame stats
};




//-----------------------------------------------------------------------------
// Name: class CD3DScreensaver
// Desc: D3D screensaver class
//-----------------------------------------------------------------------------
class CD3DScreensaver
{
public:
                    CD3DScreensaver();

    virtual HRESULT Create( HINSTANCE hInstance );
    virtual INT     Run();
    HRESULT         DisplayErrorMsg( HRESULT hr, DWORD dwType = 0 );

protected:
    SaverMode       ParseCommandLine( TCHAR* pstrCommandLine );
    VOID            ChangePassword();
    HRESULT         DoSaver();

    virtual VOID    DoConfig() { }
    virtual VOID    ReadSettings() {};
    VOID            ReadScreenSettings( HKEY hkeyParent );
    VOID            WriteScreenSettings( HKEY hkeyParent );

    virtual VOID    DoPaint( HWND hwnd, HDC hdc );
    HRESULT         Initialize3DEnvironment();
    VOID            Cleanup3DEnvironment();
    HRESULT         Render3DEnvironment();
    static LRESULT CALLBACK SaverProcStub( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    virtual LRESULT SaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    VOID            InterruptSaver();
    VOID            ShutdownSaver();
    VOID            DoScreenSettingsDialog( HWND hwndParent );
    static INT_PTR CALLBACK ScreenSettingsDlgProcStub( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    INT_PTR         ScreenSettingsDlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
    VOID            SetupAdapterPage(HWND hWnd);

    HRESULT         CreateSaverWindow();
    HRESULT         BuildDeviceList();
    BOOL            FindDepthStencilFormat( UINT iAdapter, D3DDEVTYPE DeviceType,
                        D3DFORMAT TargetFormat, D3DFORMAT* pDepthStencilFormat );
    HRESULT         CheckWindowedFormat( UINT iAdapter, D3DWindowedModeInfo* pD3DWindowedModeInfo );
    HRESULT         CreateFullscreenRenderUnit( RenderUnit* pRenderUnit );
    HRESULT         CreateWindowedRenderUnit( RenderUnit* pRenderUnit );
    BOOL            FindNextLowerMode( D3DDeviceInfo* pD3DDeviceInfo );
    VOID            SwitchToRenderUnit( UINT iRenderUnit );
    HRESULT         SetProjectionMatrix( FLOAT fNear, FLOAT fFar );
    virtual VOID    UpdateDeviceStats();
    virtual VOID    UpdateFrameStats();
    virtual BOOL    GetTextForError( HRESULT hr, TCHAR* pszError, DWORD dwNumChars );
    VOID            UpdateErrorBox();
    VOID            EnumMonitors( VOID );
    BOOL            GetBestAdapter( DWORD* piAdapter );

    virtual VOID    SetDevice( UINT iDevice )                  { }
    virtual HRESULT RegisterSoftwareDevice()                   { return S_OK; }
    virtual HRESULT ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, 
                                  D3DFORMAT fmtBackBuffer)     { return S_OK; }
    virtual HRESULT ConfirmMode( LPDIRECT3DDEVICE8 pd3dDev )   { return S_OK; }
    virtual HRESULT OneTimeSceneInit()                         { return S_OK; }
    virtual HRESULT InitDeviceObjects()                        { return S_OK; }
    virtual HRESULT RestoreDeviceObjects()                     { return S_OK; }
    virtual HRESULT FrameMove()                                { return S_OK; }
    virtual HRESULT Render()                                   { return S_OK; }
    virtual HRESULT InvalidateDeviceObjects()                  { return S_OK; }
    virtual HRESULT DeleteDeviceObjects()                      { return S_OK; }
    virtual HRESULT FinalCleanup()                             { return S_OK; }

protected:
    SaverMode       m_SaverMode;         // sm_config, sm_full, sm_preview, etc.
    BOOL            m_bAllScreensSame;   // If TRUE, show same image on all screens
    HWND            m_hWnd;              // Focus window and device window on primary
    HWND            m_hWndParent;
    HINSTANCE       m_hInstance;
    BOOL            m_bWaitForInputIdle;  // Used to pause when preview starts
    DWORD           m_dwSaverMouseMoveCount;
    BOOL            m_bIs9x;
    HINSTANCE       m_hPasswordDLL;
    VERIFYPWDPROC   m_VerifySaverPassword;
    BOOL            m_bCheckingSaverPassword;
    BOOL            m_bWindowed;

    // Variables for non-fatal error management
    BOOL            m_bErrorMode;        // Whether to display an error
    HRESULT         m_hrError;           // Error code to display
    TCHAR           m_szError[400];      // Error message text

    MonitorInfo     m_Monitors[MAX_DISPLAYS];
    DWORD           m_dwNumMonitors;
    RenderUnit      m_RenderUnits[MAX_DISPLAYS];
    DWORD           m_dwNumRenderUnits;
    D3DAdapterInfo* m_Adapters[MAX_DISPLAYS];
    DWORD           m_dwNumAdapters;
    IDirect3D8*     m_pD3D;
    IDirect3DDevice8* m_pd3dDevice;      // Current D3D device
    RECT            m_rcRenderTotal;     // Rect of entire area to be rendered
    RECT            m_rcRenderCurDevice; // Rect of render area of current device
    D3DSURFACE_DESC m_d3dsdBackBuffer;   // Info on back buffer for current device

    TCHAR           m_strWindowTitle[200]; // Title for the app's window
    BOOL            m_bAllowRef;         // Whether to allow REF D3D device
    BOOL            m_bUseDepthBuffer;   // Whether to autocreate depthbuffer
    BOOL            m_bMultithreaded;    // Whether to make D3D thread-safe
    BOOL            m_bOneScreenOnly;    // Only ever show screensaver on one screen
    TCHAR           m_strRegPath[200];   // Where to store registry info
    DWORD           m_dwMinDepthBits;    // Minimum number of bits needed in depth buffer
    DWORD           m_dwMinStencilBits;  // Minimum number of bits needed in stencil buffer
    D3DSWAPEFFECT   m_SwapEffectFullscreen; // SwapEffect to use in fullscreen Present()
    D3DSWAPEFFECT   m_SwapEffectWindowed; // SwapEffect to use in windowed Present()

    // Variables for timing
    FLOAT           m_fTime;             // Current time in seconds
    FLOAT           m_fElapsedTime;      // Time elapsed since last frame
    FLOAT           m_fFPS;              // Instanteous frame rate
    TCHAR           m_strDeviceStats[90];// D3D device stats for current device
    TCHAR           m_strFrameStats[40]; // Frame stats for current device
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\d3dsaver\dxutil.cpp ===
//-----------------------------------------------------------------------------
// File: DXUtil.cpp
//
// Desc: Shortcut macros and functions for using DX objects
//
//@@BEGIN_MSINTERNAL
//
// Hist: 11.16.98 - mwetzel - New for DirectX 7
//       12.10.98 - mwetzel - Changes to InitLight and axed InitViewport
//       04.12.99 - mwetzelf - Changed some helper funcs
//       07.06.99 - mwetzel - Mods for UNICODE support
//       03.20.00 - mwetzel - Added timer support
//
//@@END_MSINTERNAL
//
// Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#define STRICT
#include <windows.h>
#include <mmsystem.h>
#include <tchar.h>
#include <stdio.h> 
#include <stdarg.h>
#include "DXUtil.h"




//-----------------------------------------------------------------------------
// Name: DXUtil_GetDXSDKMediaPath()
// Desc: Returns the DirectX SDK media path
//-----------------------------------------------------------------------------
const TCHAR* DXUtil_GetDXSDKMediaPath()
{
    static TCHAR strNull[2] = _T("");
    static TCHAR strPath[MAX_PATH];
    DWORD dwType;
    DWORD dwSize = MAX_PATH;
    HKEY  hKey;

    // Open the appropriate registry key
    LONG lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                _T("Software\\Microsoft\\DirectX"),
                                0, KEY_READ, &hKey );
    if( ERROR_SUCCESS != lResult )
        return strNull;

    lResult = RegQueryValueEx( hKey, _T("DX8SDK Samples Path"), NULL,
                              &dwType, (BYTE*)strPath, &dwSize );
    RegCloseKey( hKey );

    if( ERROR_SUCCESS != lResult )
        return strNull;

    _tcscat( strPath, _T("\\Media\\") );

    return strPath;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_FindMediaFile()
// Desc: Returns a valid path to a DXSDK media file
//-----------------------------------------------------------------------------
HRESULT DXUtil_FindMediaFile( TCHAR* strPath, TCHAR* strFilename )
{
    HANDLE file;

    if( NULL==strFilename || NULL==strPath )
        return E_INVALIDARG;

    // Check if the file exists in the current directory
    _tcscpy( strPath, strFilename );

    file = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE != file )
    {
        CloseHandle( file );
        return S_OK;
    }
    
    // Check if the file exists in the current directory
    _stprintf( strPath, _T("%s%s"), DXUtil_GetDXSDKMediaPath(), strFilename );

    file = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE != file )
    {
        CloseHandle( file );
        return S_OK;
    }

    // On failure, just return the file as the path
    _tcscpy( strPath, strFilename );
    return E_FAIL;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadStringRegKey()
// Desc: Helper function to read a registry key string
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadStringRegKey( HKEY hKey, TCHAR* strRegName, TCHAR* strValue, 
                                 DWORD dwLength, TCHAR* strDefault )
{
    DWORD dwType;

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (BYTE*)strValue, &dwLength ) )
    {
        _tcscpy( strValue, strDefault );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteStringRegKey()
// Desc: Helper function to write a registry key string
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteStringRegKey( HKEY hKey, TCHAR* strRegName,
                                  TCHAR* strValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_SZ, 
                                        (BYTE*)strValue, 
                                        (_tcslen(strValue)+1)*sizeof(TCHAR) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadIntRegKey()
// Desc: Helper function to read a registry key int
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD* pdwValue, 
                              DWORD dwDefault )
{
    DWORD dwType;
    DWORD dwLength = sizeof(DWORD);

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (BYTE*)pdwValue, &dwLength ) )
    {
        *pdwValue = dwDefault;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteIntRegKey()
// Desc: Helper function to write a registry key int
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD dwValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
                                        (BYTE*)&dwValue, sizeof(DWORD) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadBoolRegKey()
// Desc: Helper function to read a registry key BOOL
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL* pbValue, 
                              BOOL bDefault )
{
    DWORD dwType;
    DWORD dwLength = sizeof(BOOL);

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (BYTE*)pbValue, &dwLength ) )
    {
        *pbValue = bDefault;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteBoolRegKey()
// Desc: Helper function to write a registry key BOOL
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL bValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
                                        (BYTE*)&bValue, sizeof(BOOL) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadGuidRegKey()
// Desc: Helper function to read a registry key guid
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID* pGuidValue, 
                               GUID& guidDefault )
{
    DWORD dwType;
    DWORD dwLength = sizeof(GUID);

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (LPBYTE) pGuidValue, &dwLength ) )
    {
        *pGuidValue = guidDefault;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteGuidRegKey()
// Desc: Helper function to write a registry key guid
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID guidValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_BINARY, 
                                        (BYTE*)&guidValue, sizeof(GUID) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//          TIMER_GETELAPSEDTIME  - to get the time that elapsed between 
//                                  TIMER_GETELAPSEDTIME calls
//-----------------------------------------------------------------------------
FLOAT __stdcall DXUtil_Timer( TIMER_COMMAND command )
{
    static BOOL     m_bTimerInitialized = FALSE;
    static BOOL     m_bUsingQPF         = FALSE;
    static BOOL     m_bTimerStopped     = TRUE;
    static LONGLONG m_llQPFTicksPerSec  = 0;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.  If QPF is
        // not supported, we will timeGetTime() which returns milliseconds.
        LARGE_INTEGER qwTicksPerSec;
        m_bUsingQPF = QueryPerformanceFrequency( &qwTicksPerSec );
        if( m_bUsingQPF )
            m_llQPFTicksPerSec = qwTicksPerSec.QuadPart;
    }

    if( m_bUsingQPF )
    {
        static LONGLONG m_llStopTime        = 0;
        static LONGLONG m_llLastElapsedTime = 0;
        static LONGLONG m_llBaseTime        = 0;
        double fTime;
        double fElapsedTime;
        LARGE_INTEGER qwTime;
        
        // Get either the current time or the stop time, depending
        // on whether we're stopped and what command was sent
        if( m_llStopTime != 0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)
            qwTime.QuadPart = m_llStopTime;
        else
            QueryPerformanceCounter( &qwTime );

        // Return the elapsed time
        if( command == TIMER_GETELAPSEDTIME )
        {
            fElapsedTime = (double) ( qwTime.QuadPart - m_llLastElapsedTime ) / (double) m_llQPFTicksPerSec;
            m_llLastElapsedTime = qwTime.QuadPart;
            return (FLOAT) fElapsedTime;
        }
    
        // Return the current time
        if( command == TIMER_GETAPPTIME )
        {
            double fAppTime = (double) ( qwTime.QuadPart - m_llBaseTime ) / (double) m_llQPFTicksPerSec;
            return (FLOAT) fAppTime;
        }
    
        // Reset the timer
        if( command == TIMER_RESET )
        {
            m_llBaseTime        = qwTime.QuadPart;
            m_llLastElapsedTime = qwTime.QuadPart;
            m_llStopTime        = 0;
            m_bTimerStopped     = FALSE;
            return 0.0f;
        }
    
        // Start the timer
        if( command == TIMER_START )
        {
            if( m_bTimerStopped )
                m_llBaseTime += qwTime.QuadPart - m_llStopTime;
            m_llStopTime = 0;
            m_llLastElapsedTime = qwTime.QuadPart;
            m_bTimerStopped = FALSE;
            return 0.0f;
        }
    
        // Stop the timer
        if( command == TIMER_STOP )
        {
            m_llStopTime = qwTime.QuadPart;
            m_llLastElapsedTime = qwTime.QuadPart;
            m_bTimerStopped = TRUE;
            return 0.0f;
        }
    
        // Advance the timer by 1/10th second
        if( command == TIMER_ADVANCE )
        {
            m_llStopTime += m_llQPFTicksPerSec/10;
            return 0.0f;
        }

        if( command == TIMER_GETABSOLUTETIME )
        {
            fTime = qwTime.QuadPart / (double) m_llQPFTicksPerSec;
            return (FLOAT) fTime;
        }

        return -1.0f; // Invalid command specified
    }
    else
    {
        // Get the time using timeGetTime()
        static double m_fLastElapsedTime  = 0.0;
        static double m_fBaseTime         = 0.0;
        static double m_fStopTime         = 0.0;
        double fTime;
        double fElapsedTime;
        
        // Get either the current time or the stop time, depending
        // on whether we're stopped and what command was sent
        if( m_fStopTime != 0.0 && command != TIMER_START && command != TIMER_GETABSOLUTETIME)
            fTime = m_fStopTime;
        else
            fTime = timeGetTime() * 0.001;
    
        // Return the elapsed time
        if( command == TIMER_GETELAPSEDTIME )
        {   
            fElapsedTime = (double) (fTime - m_fLastElapsedTime);
            m_fLastElapsedTime = fTime;
            return (FLOAT) fElapsedTime;
        }
    
        // Return the current time
        if( command == TIMER_GETAPPTIME )
        {
            return (FLOAT) (fTime - m_fBaseTime);
        }
    
        // Reset the timer
        if( command == TIMER_RESET )
        {
            m_fBaseTime         = fTime;
            m_fLastElapsedTime  = fTime;
            m_fStopTime         = 0;
            m_bTimerStopped     = FALSE;
            return 0.0f;
        }
    
        // Start the timer
        if( command == TIMER_START )
        {
            if( m_bTimerStopped )
                m_fBaseTime += fTime - m_fStopTime;
            m_fStopTime = 0.0f;
            m_fLastElapsedTime  = fTime;
            m_bTimerStopped = FALSE;
            return 0.0f;
        }
    
        // Stop the timer
        if( command == TIMER_STOP )
        {
            m_fStopTime = fTime;
            m_bTimerStopped = TRUE;
            return 0.0f;
        }
    
        // Advance the timer by 1/10th second
        if( command == TIMER_ADVANCE )
        {
            m_fStopTime += 0.1f;
            return 0.0f;
        }

        if( command == TIMER_GETABSOLUTETIME )
        {
            return (FLOAT) fTime;
        }

        return -1.0f; // Invalid command specified
    }
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertAnsiStringToWide()
// Desc: This is a UNICODE conversion utility to convert a CHAR string into a
//       WCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertAnsiStringToWide( WCHAR* wstrDestination, const CHAR* strSource, 
                                     int cchDestChar )
{
    if( wstrDestination==NULL || strSource==NULL )
        return;

    if( cchDestChar == -1 )
        cchDestChar = strlen(strSource)+1;

    MultiByteToWideChar( CP_ACP, 0, strSource, -1, 
                         wstrDestination, cchDestChar-1 );

    wstrDestination[cchDestChar-1] = 0;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertWideStringToAnsi()
// Desc: This is a UNICODE conversion utility to convert a WCHAR string into a
//       CHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertWideStringToAnsi( CHAR* strDestination, const WCHAR* wstrSource, 
                                     int cchDestChar )
{
    if( strDestination==NULL || wstrSource==NULL )
        return;

    if( cchDestChar == -1 )
        cchDestChar = wcslen(wstrSource)+1;

    WideCharToMultiByte( CP_ACP, 0, wstrSource, -1, strDestination, 
                         cchDestChar-1, NULL, NULL );

    strDestination[cchDestChar-1] = 0;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertGenericStringToAnsi()
// Desc: This is a UNICODE conversion utility to convert a TCHAR string into a
//       CHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertGenericStringToAnsi( CHAR* strDestination, const TCHAR* tstrSource, 
                                        int cchDestChar )
{
    if( strDestination==NULL || tstrSource==NULL )
        return;

#ifdef _UNICODE
    DXUtil_ConvertWideStringToAnsi( strDestination, tstrSource, cchDestChar );
#else
    if( cchDestChar == -1 )
    	strcpy( strDestination, tstrSource );
    else
    	strncpy( strDestination, tstrSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertGenericStringToWide()
// Desc: This is a UNICODE conversion utility to convert a TCHAR string into a
//       WCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, 
                                        int cchDestChar )
{
    if( wstrDestination==NULL || tstrSource==NULL )
        return;

#ifdef _UNICODE
    if( cchDestChar == -1 )
	    wcscpy( wstrDestination, tstrSource );
    else
	    wcsncpy( wstrDestination, tstrSource, cchDestChar );
#else
    DXUtil_ConvertAnsiStringToWide( wstrDestination, tstrSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertAnsiStringToGeneric()
// Desc: This is a UNICODE conversion utility to convert a CHAR string into a
//       TCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertAnsiStringToGeneric( TCHAR* tstrDestination, const CHAR* strSource, 
                                        int cchDestChar )
{
    if( tstrDestination==NULL || strSource==NULL )
        return;
        
#ifdef _UNICODE
    DXUtil_ConvertAnsiStringToWide( tstrDestination, strSource, cchDestChar );
#else
    if( cchDestChar == -1 )
    	strcpy( tstrDestination, strSource );
    else
    	strncpy( tstrDestination, strSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertAnsiStringToGeneric()
// Desc: This is a UNICODE conversion utility to convert a WCHAR string into a
//       TCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertWideStringToGeneric( TCHAR* tstrDestination, const WCHAR* wstrSource, 
                                        int cchDestChar )
{
    if( tstrDestination==NULL || wstrSource==NULL )
        return;

#ifdef _UNICODE
    if( cchDestChar == -1 )
	    wcscpy( tstrDestination, wstrSource );
    else
	    wcsncpy( tstrDestination, wstrSource, cchDestChar );
#else
    DXUtil_ConvertWideStringToAnsi( tstrDestination, wstrSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: _DbgOut()
// Desc: Outputs a message to the debug stream
//-----------------------------------------------------------------------------
HRESULT _DbgOut( TCHAR* strFile, DWORD dwLine, HRESULT hr, TCHAR* strMsg )
{
    TCHAR buffer[256];
    wsprintf( buffer, _T("%s(%ld): "), strFile, dwLine );
    OutputDebugString( buffer );
    OutputDebugString( strMsg );

    if( hr != S_OK )
    {
        wsprintf( buffer, _T("(hr=%08lx)\n"), hr );
        OutputDebugString( buffer );
    }

    OutputDebugString( _T("\n") );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_Trace()
// Desc: Outputs to the debug stream a formatted string with a variable-
//       argument list.
//-----------------------------------------------------------------------------
VOID DXUtil_Trace( TCHAR* strMsg, ... )
{
#if defined(DEBUG) | defined(_DEBUG)
    TCHAR strBuffer[512];
    
    va_list args;
    va_start(args, strMsg);
    _vsntprintf( strBuffer, 512, strMsg, args );
    va_end(args);

    OutputDebugString( strBuffer );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\default\strings.h ===
#define idsAppName      100
#define idsNoConfigure  101
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\default\scrnsave.c ===
/*
 *  SCRNSAVE.C - default screen saver.
 *
 *  this app makes a IdleWild screen saver compatible with the windows 3.1
 *  screen saver interface.
 *
 *  Usage:      SCRNSAVE.EXE saver.iw [/s] [/c]
 *
 *      the IdleWild screen saver 'saver.iw' will be loaded and told to
 *      screen save.  if '/c' is specifed the savers configure dialog will
 *      be shown.
 *
 *      when the screen saver terminates SCRNSAVE.EXE will terminate too.
 *
 *      if the saver.iw is not specifed or refuses to load then a
 *      builtin 'blackness' screen saver will be used.
 *
 *  Restrictions:
 *
 *      because only one screen saver is loaded, (not all the screen savers
 *      like IdleWild.exe does) the random screen saver will not work correctly
 *
 *  History:
 *      10/15/90        ToddLa      stolen from SOS.C by BradCh
 *       6/17/91        stevecat    ported to NT Windows
 *
 */
#include <string.h>

#define WIN31 /* For topmost windows */
#include <windows.h>
#include "strings.h"
#include <stdlib.h>

#define BUFFER_LEN  255

CHAR szAppName[BUFFER_LEN];
CHAR szNoConfigure[BUFFER_LEN];

#define     THRESHOLD   3

#define abs(x)      ( (x)<0 ? -(x) : (x) )

//
// private stuff in IWLIB.DLL
//
HANDLE  hIdleWildDll;
CHAR    szIdleWildDll[] = "IWLIB.DLL";

SHORT (*FInitScrSave) (HANDLE, HWND);
VOID  (*TermScrSave) (VOID);
VOID  (*ScrBlank) (SHORT);
VOID  (*ScrSetIgnore) (SHORT);
SHORT (*ScrLoadServer) (CHAR *);
SHORT (*ScrSetServer) (CHAR *);
VOID  (*ScrInvokeDlg) (HANDLE, HWND);

HANDLE  hMainInstance   = NULL;
HWND    hwndApp         = NULL;
HWND    hwndActive      = NULL;
HWND    hwndPreview     = NULL;
BOOL    fBlankNow       = FALSE;
BOOL    fIdleWild       = FALSE;
//SHORT   wmScrSave       = -1;
// changed to what I believe it should be
UINT wmScrSave  = 0xffffffff;

typedef LONG (*LPWNDPROC)(); // pointer to a window procedure

BOOL FInitIdleWild (LPSTR szCmdLine);
BOOL FTermIdleWild (VOID);
BOOL FInitApp      (HANDLE hInstance, LPSTR szCmdLine, WORD sw);
BOOL FTermApp      (VOID);
BOOL FInitDefault  (VOID);
LRESULT DefaultProc   (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

int __cdecl main (USHORT argc, CHAR **argv)
{
        HANDLE   hInstance;
        HANDLE   hPrev     = NULL;
        LPSTR    szCmdLine = GetCommandLine();
        WORD     sw        = SW_SHOWNORMAL;
        MSG      msg;

    hInstance = GetModuleHandle (NULL);

        hMainInstance = hInstance;

        // If we're already running another instance, get out
        if (hPrev != NULL)
                return FALSE;

        if (!FInitApp (hInstance, szCmdLine, sw))
        {
                //MessageBox (NULL, "Cannot initialize!", szAppName, MB_OK);
                return FALSE;
        }

        while (GetMessage (&msg, NULL, 0, 0))
        {
                //
        // IWLIB.DLL will brodcast a message when the screen saving
                // is done.
        //
                if (msg.message == wmScrSave && msg.wParam == FALSE)
                        break;

                TranslateMessage (&msg);
                DispatchMessage (&msg);
        }

        return FTermApp ();
}


BOOL FTermApp (VOID)
{
        ////FTermDefault ();

        FTermIdleWild ();
        return TRUE;
}


BOOL FInitApp (HANDLE hInstance, LPSTR szCmdLine, WORD sw)
{
        LPSTR lpch, lpT;

    LoadString(hMainInstance, idsAppName, szAppName, BUFFER_LEN);
    LoadString(hMainInstance, idsNoConfigure, szNoConfigure, BUFFER_LEN);

//=================================================================

    // on NT, szCmdLine's first string includes its own name, remove this
    // to make it exactly like the windows command line.

    if (*szCmdLine)
        {
        lpT = strchr(szCmdLine, ' ');   // skip self name
        if (lpT)
                {
            szCmdLine = lpT;
            while (*szCmdLine == ' ')
                szCmdLine++;            // skip spaces to end or first cmd
        }
                else
                {
            szCmdLine += strlen(szCmdLine);   // point to NULL
        }
    }
//=====================================================================
        //
    //  parse command line looking for switches
        //

        for (lpch = szCmdLine; *lpch != '\0'; lpch += 1)
        {
                if (*lpch == '/' || *lpch == '-')
                {
                        if (lpch[1] == 's' || lpch[1] == 'S')
                                fBlankNow = TRUE;
                        if (lpch[1] == 'c' || lpch[1] == 'C')
                                hwndActive = GetActiveWindow ();
                        if (lpch[1] == 'p' || lpch[1] == 'P')
                        {
                                fBlankNow = TRUE;
                                hwndPreview = (HWND)IntToPtr(atoi(lpch+2));
                                break;
                        }
                        lpch[0] = ' ';
                        lpch[1] = ' ';
                }
        }

        //
    //  try to load the IdleWild screen saver, if none specifed or
        //  we are unable to load it then use the default one.
    //
        if (FInitIdleWild (szCmdLine))
        {
                if (fBlankNow)
                {
                        ScrSetIgnore (1);
                        ScrBlank (TRUE);
                }
                else
                {
                        ScrInvokeDlg (hMainInstance, hwndActive);
                        PostQuitMessage (0);
                }
        }
        else if (!fBlankNow || !FInitDefault ())
        {
                MessageBox (hwndActive, szNoConfigure, szAppName, MB_OK | MB_ICONEXCLAMATION);
                PostQuitMessage (0);
        }

        return TRUE;
}


//
//  run-time link to IWLIB.DLL
//
BOOL FInitIdleWild (LPSTR szCmdLine)
{
        OFSTRUCT of;

        while (*szCmdLine == ' ')
                szCmdLine++;

        if (*szCmdLine == 0)
                return FALSE;

        if (-1 == OpenFile(szIdleWildDll, &of, OF_EXIST | OF_SHARE_DENY_NONE) ||
            -1 == OpenFile(szCmdLine, &of, OF_EXIST | OF_SHARE_DENY_NONE))
                return FALSE;

        if ((hIdleWildDll = LoadLibrary (szIdleWildDll)) == NULL)
                return FALSE;

        FInitScrSave  = (SHORT (*) (HANDLE, HWND))GetProcAddress (hIdleWildDll, "FInitScrSave" );
        TermScrSave   = (VOID (*) (VOID))         GetProcAddress (hIdleWildDll, "TermScrSave"  );
        ScrBlank      = (VOID (*) (SHORT))        GetProcAddress (hIdleWildDll, "ScrBlank"     );
        ScrSetIgnore  = (VOID (*) (SHORT))        GetProcAddress (hIdleWildDll, "ScrSetIgnore" );
        ScrLoadServer = (SHORT (*) (CHAR *))      GetProcAddress (hIdleWildDll, "ScrLoadServer");
        ScrSetServer  = (SHORT (*) (CHAR *))      GetProcAddress (hIdleWildDll, "ScrSetServer" );
        ScrInvokeDlg  = (VOID (*) (HANDLE, HWND)) GetProcAddress (hIdleWildDll, "ScrInvokeDlg" );

        //
    // must be a invalid dll?
        //
    if (!FInitScrSave || !TermScrSave)
        {
                FreeLibrary (hIdleWildDll);
                return FALSE;
        }

        //
    // init iwlib.dll
        //
    if (!FInitScrSave (hMainInstance, NULL))     // NULL hwnd???
        {
                FreeLibrary (hIdleWildDll);
                return FALSE;
        }

        //
    //  load the screen saver on the command line.
        //  if the load fails, abort
    //
        if (!ScrLoadServer (szCmdLine))
        {
                TermScrSave ();
                FreeLibrary (hIdleWildDll);
                return FALSE;
        }

        wmScrSave = RegisterWindowMessage ("SCRSAVE"); // REVIEW: for win 3.1

        fIdleWild = TRUE;

        return TRUE;
}


BOOL FTermIdleWild (VOID)
{
        if (fIdleWild)
        {
                TermScrSave ();
                FreeLibrary (hIdleWildDll);
        }
        return TRUE;
}


//
//  init the default screen saver
//
BOOL FInitDefault (VOID)
{
        WNDCLASS    cls;
        HWND        hwnd;
        HDC         hdc;
        RECT rc;
        OSVERSIONINFO osvi;
        BOOL bWin2000 =  FALSE;

        cls.style           = 0;
        cls.lpfnWndProc     = DefaultProc;
        cls.cbClsExtra      = 0;
        cls.cbWndExtra      = 0;
        cls.hInstance       = hMainInstance;
        cls.hIcon           = NULL;
        if (hwndPreview == NULL)
        {
            cls.hCursor     = NULL;
        }
        else
        {
            cls.hCursor     = LoadCursor(NULL,IDC_ARROW);
        }

        cls.hbrBackground   = GetStockObject (BLACK_BRUSH);
        cls.lpszMenuName    = NULL;
        cls.lpszClassName   = szAppName;

        if (!RegisterClass (&cls))
                return FALSE;

        //
        // Make sure we use the entire virtual desktop size for multiple
        // displays
        //
        hdc = GetDC(NULL);
        GetClipBox(hdc, &rc);
        ReleaseDC(NULL, hdc);

        // On Win2000 Terminal Services we must detect the case where a remotte session
        // is on the disconnected desktop, because in this case GetClipBox() returns
        // an empty rect.

        if (IsRectEmpty(&rc)) {
            osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            if (GetVersionEx (&osvi)){
                if ((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osvi.dwMajorVersion >= 5)) {
                    bWin2000 = TRUE;
                }
            }
            if (bWin2000 && GetSystemMetrics(SM_REMOTESESSION)) {
                rc.left = 0;
                rc.top = 0;
                rc.right = GetSystemMetrics(SM_CXVIRTUALSCREEN);
                rc.bottom = GetSystemMetrics(SM_CYVIRTUALSCREEN);

            }

        }


        hwnd = CreateWindowEx (WS_EX_TOPMOST, szAppName, szAppName,
                                                        WS_VISIBLE | ((hwndPreview == NULL) ? WS_POPUP : WS_CHILD),
                                                        rc.left,
                                                        rc.top,
                                                        rc.right  - rc.left,
                                                        rc.bottom - rc.top,
                                                        hwndPreview, NULL,
                                                        hMainInstance, NULL);

        return hwnd != NULL;
}


LRESULT DefaultProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
        static POINT  ptLast;
        POINT  ptMouse;

        switch (msg)
        {
        case WM_CREATE:
                GetCursorPos (&ptLast);
                break;

        case WM_DESTROY:
                PostQuitMessage (0);
                break;

        case WM_ACTIVATE:
        case WM_ACTIVATEAPP:
                if (wParam)
                        break;

        case WM_LBUTTONDOWN:
        case WM_MBUTTONDOWN:
        case WM_RBUTTONDOWN:
        case WM_KEYDOWN:
        case WM_CHAR:
                if (hwndPreview == NULL)
                {
                    PostMessage (hwnd, WM_CLOSE, 0, 0L);
                }
                break;

        case WM_MOUSEMOVE:
                if (hwndPreview == NULL)
                {
                    GetCursorPos (&ptMouse);
                    if (abs (ptMouse.x - ptLast.x) + abs (ptMouse.y - ptLast.y) > THRESHOLD)
                            PostMessage (hwnd, WM_CLOSE, 0, 0L);
                }
                break;

        case WM_SETCURSOR:
                if (hwndPreview == NULL)
                {
                    SetCursor (NULL);
                    return 0L;
                }
                break;
        }

        return DefWindowProc (hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\d3dsaver\dxutil.h ===
//-----------------------------------------------------------------------------
// File: DXUtil.h
//
// Desc: Helper functions and typing shortcuts for DirectX programming.
//
//@@BEGIN_MSINTERNAL
//
// Hist: See the source files for detailed histories
//       03.21.00 - mwetzel - Last Modified
//
//@@END_MSINTERNAL
// Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#ifndef DXUTIL_H
#define DXUTIL_H


//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------
#define SAFE_DELETE(p)       { if(p) { delete (p);     (p)=NULL; } }
#define SAFE_DELETE_ARRAY(p) { if(p) { delete[] (p);   (p)=NULL; } }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }




//-----------------------------------------------------------------------------
// Name: DXUtil_GetDXSDKMediaPath() and DXUtil_FindMediaFile() 
// Desc: Returns the DirectX SDK path, as stored in the system registry
//       during the SDK install.
//-----------------------------------------------------------------------------
const TCHAR* DXUtil_GetDXSDKMediaPath();
HRESULT      DXUtil_FindMediaFile( TCHAR* strPath, TCHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: DXUtil_Read*RegKey() and DXUtil_Write*RegKey()
// Desc: Helper functions to read/write a string registry key 
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteStringRegKey( HKEY hKey, TCHAR* strRegName, TCHAR* strValue );
HRESULT DXUtil_WriteIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD dwValue );
HRESULT DXUtil_WriteGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID guidValue );
HRESULT DXUtil_WriteBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL bValue );

HRESULT DXUtil_ReadStringRegKey( HKEY hKey, TCHAR* strRegName, TCHAR* strValue, DWORD dwLength, TCHAR* strDefault );
HRESULT DXUtil_ReadIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD* pdwValue, DWORD dwDefault );
HRESULT DXUtil_ReadGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID* pGuidValue, GUID& guidDefault );
HRESULT DXUtil_ReadBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL* pbValue, BOOL bDefault );




//-----------------------------------------------------------------------------
// Name: DXUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//          TIMER_GETELAPSEDTIME  - to get the time that elapsed between 
//                                  TIMER_GETELAPSEDTIME calls
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, TIMER_ADVANCE,
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME, TIMER_GETELAPSEDTIME };
FLOAT __stdcall DXUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// UNICODE support for converting between CHAR, TCHAR, and WCHAR strings
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertAnsiStringToWide( WCHAR* wstrDestination, const CHAR* strSource, int cchDestChar = -1 );
VOID DXUtil_ConvertWideStringToAnsi( CHAR* strDestination, const WCHAR* wstrSource, int cchDestChar = -1 );
VOID DXUtil_ConvertGenericStringToAnsi( CHAR* strDestination, const TCHAR* tstrSource, int cchDestChar = -1 );
VOID DXUtil_ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, int cchDestChar = -1 );
VOID DXUtil_ConvertAnsiStringToGeneric( TCHAR* tstrDestination, const CHAR* strSource, int cchDestChar = -1 );
VOID DXUtil_ConvertWideStringToGeneric( TCHAR* tstrDestination, const WCHAR* wstrSource, int cchDestChar = -1 );




//-----------------------------------------------------------------------------
// Debug printing support
//-----------------------------------------------------------------------------
VOID    DXUtil_Trace( TCHAR* strMsg, ... );
HRESULT _DbgOut( TCHAR*, DWORD, HRESULT, TCHAR* );

#if defined(DEBUG) | defined(_DEBUG)
    #define DXTRACE           DXUtil_Trace
#else
    #define DXTRACE           sizeof
#endif

#if defined(DEBUG) | defined(_DEBUG)
    #define DEBUG_MSG(str)    _DbgOut( __FILE__, (DWORD)__LINE__, 0, str )
#else
    #define DEBUG_MSG(str)    (0L)
#endif




#endif // DXUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flowerbox\flowerbox.h ===
//-----------------------------------------------------------------------------
// File: FlowerBox.h
//
// Desc: 
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _FLOWERBOX_H
#define _FLOWERBOX_H

//-----------------------------------------------------------------------------
// Name: struct MYVERTEX
// Desc: D3D vertex type for this app
//-----------------------------------------------------------------------------
struct MYVERTEX
{
    D3DXVECTOR3 p;     // Position
    D3DXVECTOR3 n;     // Normal
};

#define D3DFVF_MYVERTEX ( D3DFVF_XYZ | D3DFVF_NORMAL )


//-----------------------------------------------------------------------------
// Name: struct FLOATRECT
// Desc: Floating viewport rect
//-----------------------------------------------------------------------------
struct FLOATRECT
{
    FLOAT xMin;           
    FLOAT yMin;
    FLOAT xSize;
    FLOAT ySize;
    FLOAT xVel;
    FLOAT yVel;
};



// Minimum and maximum number of side subdivisions
#define MINSUBDIV 3
#define MAXSUBDIV 10

// Maximum values allowed
#define MAXSIDES 8
#define MAXSPTS ((MAXSUBDIV+1)*(MAXSUBDIV+1))
#define MAXPTS (MAXSIDES*MAXSPTS)
#define MAXSFACES (MAXSUBDIV*MAXSUBDIV)
#define MAXFACES (MAXSIDES*MAXSFACES)
#define MAXFPTS 4

// Number of colors used in checkerboarding
#define NCCOLS 2

// Configurable options
struct CONFIG
{
    BOOL smooth_colors;
    BOOL triangle_colors;
    BOOL cycle_colors;
    BOOL spin;
    BOOL bloom;
    INT subdiv;
    INT color_pick;
    INT image_size;
    INT geom;
    INT two_sided;
};

extern CONFIG config;

extern FLOAT checker_cols[MAXSIDES][NCCOLS][4];
extern FLOAT side_cols[MAXSIDES][4];
extern FLOAT solid_cols[4];



// A side of a shape
struct SIDE
{
    INT nstrips; // Number of triangle strips in this side
    INT *strip_size; // Number of vertices per strip
    unsigned short *strip_index; // Indices for each point in the triangle strips
};

// Geometry of a shape
struct GEOMETRY
{
    VOID (*init)(GEOMETRY *geom);
    INT nsides; // Number of sides
    SIDE sides[MAXSIDES]; // Sides

    // Data for each vertex in the shape
    D3DXVECTOR3 *pts, *npts;
    D3DXVECTOR3 *normals;
    MYVERTEX* pVertices;
    INT total_pts; // Total number of vertices

    // Scaling control
    FLOAT min_sf, max_sf, sf_inc;
    FLOAT init_sf; // Initial scale factor setup control
};

#define GEOM_CUBE       0
#define GEOM_TETRA      1
#define GEOM_PYRAMIDS   2


class   CFlowerBoxScreensaver : public CD3DScreensaver
{
protected:
    FLOATRECT m_floatrect;
    // Spin rotations
    FLOAT m_xr;
    FLOAT m_yr;
    FLOAT m_zr;

    // Scale factor and increment
    FLOAT m_sf;
    FLOAT m_sfi;

    // Color cycling hue phase
    FLOAT m_phase;
    GEOMETRY *m_pGeomCur;

protected:
    virtual HRESULT RegisterSoftwareDevice();
    virtual VOID    DoConfig();
    virtual VOID    ReadSettings();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();

    VOID ss_ReadSettings();
    BOOL ss_RegistrySetup( int section, int file );
    int  ss_GetRegistryInt( int name, int iDefault );
    VOID ss_GetRegistryString( int name, LPTSTR lpDefault, LPTSTR lpDest, int bufSize );
    
    VOID NewConfig(CONFIG *cnf);
    VOID UpdatePts(GEOMETRY *geom, FLOAT sf);
    VOID InitVlen(GEOMETRY *geom, INT npts, D3DXVECTOR3 *pts);
    VOID DrawGeom(GEOMETRY *geom);
    VOID ComputeHsvColors(VOID);
    HRESULT SetMaterialColor(FLOAT* pfColors);
    static INT_PTR CALLBACK ScreenSaverConfigureDialog(HWND hdlg, UINT msg,
                                                    WPARAM wpm, LPARAM lpm);

public:
    CFlowerBoxScreensaver();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flowerbox\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FlowerBox.rc
//
#define IDI_MAIN_ICON                   101
#define IDR_MAIN_ACCEL                  113
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201

#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016

#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112

#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212


#define ID_COMPLEXITY              401
#define ID_IMAGE_SIZE              402

#define ID_COL_PICK_FIRST          ID_COL_CHECKER
#define ID_COL_CHECKER             500
#define ID_COL_PER_SIDE            501
#define ID_COL_SINGLE              502
#define ID_COL_PICK_LAST           ID_COL_SINGLE
#define ID_COL_PICK_COUNT          (ID_COL_PICK_LAST-ID_COL_PICK_FIRST+1)

#define ID_COL_SMOOTH              550
#define ID_COL_TRIANGLE            551
#define ID_COL_CYCLE               552

#define ID_SPIN                    600
#define ID_BLOOM                   601
#define ID_TWO_SIDED               602

#define ID_GEOM                    650

#define IDC_SCREENSETTINGS         651

#define IDS_GEOM_FIRST                  IDS_GEOM_CUBE
#define IDS_GEOM_CUBE                   1025
#define IDS_GEOM_TETRA                  1026
#define IDS_GEOM_PYRAMIDS               1027
#define IDS_GEOM_CYLINDER               1028
#define IDS_GEOM_SPRING                 1029
#define IDS_GEOM_LAST                   IDS_GEOM_SPRING
#define IDS_GEOM_COUNT                  (IDS_GEOM_LAST-IDS_GEOM_FIRST+1)

#define IDS_INIFILE                     1113
#define IDS_INI_SECTION                 1114
#define IDS_CONFIG_TRIANGLE_COLORS      1115
#define IDS_CONFIG_CYCLE_COLORS         1116
#define IDS_CONFIG_SPIN                 1117
#define IDS_CONFIG_BLOOM                1118
#define IDS_CONFIG_SUBDIV               1119
#define IDS_CONFIG_COLOR_PICK           1120
#define IDS_CONFIG_IMAGE_SIZE           1121
#define IDS_CONFIG_GEOM                 1122
#define IDS_CONFIG_TWO_SIDED            1123
#define IDS_CONFIG_SMOOTH_COLORS        1124

#define IDS_GENNAME             9003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        154
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1055
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flowerbox\flowerbox.cpp ===
//-----------------------------------------------------------------------------
// File: FlowerBox.cpp
//
// Desc: Fun screen saver
//       Original OpenGL version by Drew Bliss
//       Ported to Direct3D 8.0 by Mike Anderson
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <windows.h>
#include <tchar.h>
#include <d3d8.h>
#include <d3dx8.h>
#include <d3d8rgbrast.h>
#include <stdio.h>
#include <commctrl.h>
#include <scrnsave.h>
#include "d3dsaver.h"
#include "FlowerBox.h"
#include "Resource.h"
#include "dxutil.h"

#ifndef GL_FRONT
#define GL_FRONT                          0x0404
#endif

#ifndef GL_FRONT_AND_BACK
#define GL_FRONT_AND_BACK                 0x0408
#endif


// Minimum and maximum image sizes
#define MINIMAGESIZE 10
#define MAXIMAGESIZE 100

// Color tables for checkboard, per-side and single color modes
FLOAT base_checker_cols[MAXSIDES][NCCOLS][4] =
{
    1.0f, 0.0f, 0.0f, 1.0f,
    0.0f, 1.0f, 0.0f, 1.0f,
    0.0f, 1.0f, 0.0f, 1.0f,
    0.0f, 0.0f, 1.0f, 1.0f,
    0.0f, 0.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 1.0f, 1.0f,
    0.0f, 1.0f, 1.0f, 1.0f,
    0.0f, 1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 0.0f, 1.0f,
    1.0f, 1.0f, 0.0f, 1.0f,
    0.5f, 0.5f, 1.0f, 1.0f,
    0.5f, 0.5f, 1.0f, 1.0f,
    1.0f, 0.5f, 0.5f, 1.0f,
    1.0f, 0.5f, 0.5f, 1.0f,
    1.0f, 0.0f, 0.0f, 1.0f
};
FLOAT checker_cols[MAXSIDES][NCCOLS][4];

FLOAT base_side_cols[MAXSIDES][4] =
{
    1.0f, 0.0f, 0.0f, 1.0f,
    0.0f, 1.0f, 0.0f, 1.0f,
    0.0f, 0.0f, 1.0f, 1.0f,
    1.0f, 0.0f, 1.0f, 1.0f,
    0.0f, 1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 0.0f, 1.0f,
    0.5f, 0.5f, 1.0f, 1.0f,
    1.0f, 0.5f, 0.5f, 1.0f
};
FLOAT side_cols[MAXSIDES][4];

FLOAT base_solid_cols[4] =
{
    1.0f, 1.0f, 1.0f, 1.0f
};
FLOAT solid_cols[4];


// Default configuration
CONFIG config =
{
    TRUE, FALSE, FALSE, TRUE, TRUE, MAXSUBDIV, ID_COL_PER_SIDE,
    (MAXIMAGESIZE+MINIMAGESIZE)/2, GEOM_CUBE, GL_FRONT
};

// A slider range
typedef struct _RANGE
{
    INT min_val;
    INT max_val;
    INT step;
    INT page_step;
} RANGE;

RANGE complexity_range = {MINSUBDIV, MAXSUBDIV, 1, 2};
RANGE image_size_range = {MINIMAGESIZE, MAXIMAGESIZE, 1, 10};

// Values to map a 2D point onto a 3D plane
// Base point and axes to map X and Y coordinates onto
struct PLANE_MAP
{
    D3DXVECTOR3 base, x_axis, y_axis;
    PLANE_MAP(D3DXVECTOR3 tbase, D3DXVECTOR3 tx_axis, D3DXVECTOR3 ty_axis)
        { base = tbase; x_axis = tx_axis; y_axis = ty_axis; }
    PLANE_MAP(VOID) {};
};

// Data area used by the current geometry
// Base points and generated points
D3DXVECTOR3 pts[MAXPTS], npts[MAXPTS];
MYVERTEX vertices[MAXPTS];

// Scaling factor for spherical projection
FLOAT vlen[MAXPTS];
// Normals
D3DXVECTOR3 normals[MAXPTS];
// Vertex data indices
WORD index[MAXPTS*2];
// Triangle strip sizes
INT strip_size[MAXSIDES*MAXSUBDIV];

VOID InitCube(GEOMETRY *geom);
VOID InitTetra(GEOMETRY *geom);
VOID InitPyramids(GEOMETRY *geom);
VOID InitCylinder(GEOMETRY *geom);
VOID InitSpring(GEOMETRY *geom);

GEOMETRY cube_geom = {InitCube};
GEOMETRY tetra_geom = {InitTetra};
GEOMETRY pyramids_geom = {InitPyramids};
GEOMETRY cylinder_geom = {InitCylinder};
GEOMETRY spring_geom = {InitSpring};

GEOMETRY *geom_table[] =
{
    &cube_geom,
    &tetra_geom,
    &pyramids_geom,
    &cylinder_geom,
    &spring_geom
};


#define BUF_SIZE 255
TCHAR g_szSectName[BUF_SIZE];
TCHAR g_szFname[BUF_SIZE];

CFlowerBoxScreensaver* g_pMyFlowerBoxScreensaver = NULL;




//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
{
    HRESULT hr;
    CFlowerBoxScreensaver flowerboxSS;

    if( FAILED( hr = flowerboxSS.Create( hInst ) ) )
    {
        flowerboxSS.DisplayErrorMsg( hr );
        return 0;
    }

    return flowerboxSS.Run();
}




//-----------------------------------------------------------------------------
// Name: CFlowerBoxScreensaver()
// Desc: Constructor
//-----------------------------------------------------------------------------
CFlowerBoxScreensaver::CFlowerBoxScreensaver( )
{
    g_pMyFlowerBoxScreensaver = this;

    LoadString( NULL, IDS_DESCRIPTION, m_strWindowTitle, 200 );
    m_bUseDepthBuffer = TRUE;

    lstrcpy( m_strRegPath, TEXT("Software\\Microsoft\\Screensavers\\Flowerbox") );

    m_xr = 0;
    m_yr = 0;
    m_zr = 0;

    m_sf = 0;
    m_sfi = 0;

    m_phase = 0.0f;

    m_pGeomCur = NULL;

    m_floatrect.xSize = 0.0f;
    InitCommonControls();
}


//-----------------------------------------------------------------------------
// Name: RegisterSoftwareDevice()
// Desc: This can register the D3D8RGBRasterizer or any other
//       pluggable software rasterizer.
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::RegisterSoftwareDevice()
{ 
    m_pD3D->RegisterSoftwareDevice( D3D8RGBRasterizer );

    return S_OK; 
}


//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::FrameMove()
{
    // update floatrect
    RECT rcBounceBounds;

    if( m_floatrect.xSize == 0.0f )
    {
        // Initialize floatrect
        RECT rcBounds;
        DWORD dwParentWidth;
        DWORD dwParentHeight;

        rcBounds = m_rcRenderTotal;

        dwParentWidth = rcBounds.right - rcBounds.left;
        dwParentHeight = rcBounds.bottom - rcBounds.top;

        FLOAT sizeFact;
        FLOAT sizeScale;
        DWORD size;

        sizeScale = (FLOAT)config.image_size / 150.0f;

    //    sizeFact = 0.25f + (0.5f * sizeScale);     // range 25-75%
    //    size = (DWORD) (sizeFact * ( ((FLOAT)(dwParentWidth + dwParentHeight)) / 2.0f ));

        sizeFact = 0.25f + (0.75f * sizeScale);     // range 25-100%
        size = (DWORD) (sizeFact * ( dwParentWidth > dwParentHeight ? dwParentHeight : dwParentWidth ) );

        if( size > dwParentWidth )
            size = dwParentWidth;
        if( size > dwParentHeight )
            size = dwParentHeight;

        // Start floatrect centered on primary
        m_floatrect.xMin = rcBounds.left + (dwParentWidth - size) / 2.0f;
        m_floatrect.yMin = rcBounds.top + (dwParentHeight - size) / 2.0f;
        m_floatrect.xSize = (FLOAT)size;
        m_floatrect.ySize = (FLOAT)size;

        m_floatrect.xVel = 0.01f * (FLOAT) size;
        m_floatrect.yVel = 0.01f * (FLOAT) size;
    }

    rcBounceBounds = m_rcRenderTotal;

    FLOAT xMinOld = m_floatrect.xMin;
    FLOAT yMinOld = m_floatrect.yMin;

    m_floatrect.xMin += m_floatrect.xVel * 20.0f * m_fElapsedTime;
    m_floatrect.yMin += m_floatrect.yVel * 20.0f * m_fElapsedTime;
    if( m_floatrect.xVel < 0 && m_floatrect.xMin < rcBounceBounds.left || 
        m_floatrect.xVel > 0 && (m_floatrect.xMin + m_floatrect.xSize) > rcBounceBounds.right )
    {
        m_floatrect.xMin = xMinOld; // undo last move
        m_floatrect.xVel = -m_floatrect.xVel; // change direction
    }
    if( m_floatrect.yVel < 0 && m_floatrect.yMin < rcBounceBounds.top || 
        m_floatrect.yVel > 0 && (m_floatrect.yMin + m_floatrect.ySize) > rcBounceBounds.bottom )
    {
        m_floatrect.yMin = yMinOld; // undo last move
        m_floatrect.yVel = -m_floatrect.yVel; // change direction
    }

    if (config.spin)
    {
        m_xr += 3 * 20.0f * m_fElapsedTime;
        m_yr += 2 * 20.0f * m_fElapsedTime;
    }

    if (config.bloom)
    {
        m_sf += m_sfi * 20.0f * m_fElapsedTime;
        if (m_sfi > 0.0f && m_sf > m_pGeomCur->max_sf ||
            m_sfi < 0.0f && m_sf < m_pGeomCur->min_sf )
        {
            m_sfi = -m_sfi;
        }
        UpdatePts(m_pGeomCur, m_sf);
    }

    if (config.cycle_colors)
    {
        ComputeHsvColors();
        m_phase += (FLOAT)(2.5 * 20.0f * m_fElapsedTime * D3DX_PI/180.);
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::Render()
{
    D3DVIEWPORT8 vp;

    // First, clear the entire back buffer to the background color
    vp.X = 0;
    vp.Y = 0;
    vp.Width = m_rcRenderCurDevice.right - m_rcRenderCurDevice.left;
    vp.Height = m_rcRenderCurDevice.bottom - m_rcRenderCurDevice.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff000000, 1.0f, 0L );

    // Now determine what part of the floatrect, if any, intersects the current screen
    RECT rcFloatThisScreen;
    RECT rcFloatThisScreenClipped;

    rcFloatThisScreen.left = (INT)m_floatrect.xMin;
    rcFloatThisScreen.top = (INT)m_floatrect.yMin;
    rcFloatThisScreen.right = rcFloatThisScreen.left + (INT)m_floatrect.xSize;
    rcFloatThisScreen.bottom = rcFloatThisScreen.top + (INT)m_floatrect.ySize;

    if( !IntersectRect(&rcFloatThisScreenClipped, &rcFloatThisScreen, &m_rcRenderCurDevice) )
    {
        return S_OK; // no intersection, so nothing further to render on this screen
    }

    // Convert rcFloatThisScreen from screen to window coordinates
    OffsetRect(&rcFloatThisScreen, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);
    OffsetRect(&rcFloatThisScreenClipped, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);

    // Now set up the viewport to render to the clipped rect
    vp.X = rcFloatThisScreenClipped.left;
    vp.Y = rcFloatThisScreenClipped.top;
    vp.Width = rcFloatThisScreenClipped.right - rcFloatThisScreenClipped.left;
    vp.Height = rcFloatThisScreenClipped.bottom - rcFloatThisScreenClipped.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );

    // Now set up the projection matrix to only render the onscreen part of the
    // rect to the viewport
    D3DXMATRIX matProj;
    FLOAT l,r,b,t;
    l = -0.8f;
    r =  0.8f;
    b =  0.8f;
    t = -0.8f;
    FLOAT cxUnclipped = (rcFloatThisScreen.right + rcFloatThisScreen.left) / 2.0f;
    FLOAT cyUnclipped = (rcFloatThisScreen.bottom + rcFloatThisScreen.top) / 2.0f;
    l *= (rcFloatThisScreenClipped.left - cxUnclipped) / (rcFloatThisScreen.left - cxUnclipped);
    r *= (rcFloatThisScreenClipped.right - cxUnclipped) / (rcFloatThisScreen.right - cxUnclipped);
    t *= (rcFloatThisScreenClipped.top - cyUnclipped) / (rcFloatThisScreen.top - cyUnclipped);
    b *= (rcFloatThisScreenClipped.bottom - cyUnclipped) / (rcFloatThisScreen.bottom - cyUnclipped);
    D3DXMatrixPerspectiveOffCenterLH( &matProj, l, r, b, t, 2.0f, 5.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION , &matProj );

    // Begin the scene 
    if( SUCCEEDED( m_pd3dDevice->BeginScene() ) )
    {
        D3DXMATRIX mat, matx, maty, matz;
        D3DXMatrixRotationX( &matx, D3DXToRadian( (FLOAT)m_xr ) );
        D3DXMatrixRotationY( &maty, D3DXToRadian( (FLOAT)m_yr ) );
        D3DXMatrixRotationZ( &matz, D3DXToRadian( (FLOAT)m_zr ) );
        mat = matx * maty * matz;
        m_pd3dDevice->SetTransform( D3DTS_WORLD, &mat );

        DrawGeom(m_pGeomCur);

        // End the scene.
        m_pd3dDevice->EndScene();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::RestoreDeviceObjects()
{
    if( m_pd3dDevice == NULL )
        return S_OK;
    
    D3DXMATRIX matView;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 3.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW , &matView );

    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type       = D3DLIGHT_POINT;
    light.Diffuse.r  = 1.0f;
    light.Diffuse.g  = 1.0f;
    light.Diffuse.b  = 1.0f;
    light.Diffuse.a  = 1.0f;
    light.Specular.r = 1.0f;
    light.Specular.g = 1.0f;
    light.Specular.b = 1.0f;
    light.Specular.a = 1.0f;
    light.Position.x = 2.0;
    light.Position.y = 2.0;
    light.Position.z = 10.0;
    light.Range      = 1000.0f;
    light.Attenuation0 = 1.0f;
    m_pd3dDevice->SetLight(0, &light);
    m_pd3dDevice->LightEnable(0, TRUE);
    
    // Set some basic renderstates
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, D3DCOLOR(0x40404040 ) );
    if( config.two_sided == GL_FRONT_AND_BACK )
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    else
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );
    
    NewConfig(&config);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::InvalidateDeviceObjects()
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitVlen()
// Desc: Precomputes scaling factor for spherical projection
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::InitVlen(GEOMETRY *geom, INT npts, D3DXVECTOR3 *pts)
{
    const FLOAT RADIUS = 1;
    FLOAT d;
    FLOAT *vl;

    vl = vlen;
    while (npts-- > 0)
    {
        d = D3DXVec3Length(pts);

        // Don't allow really close points because this leads to
        // numeric instability and really large objects
//        assert(d > 0.01f);

        // Geometries are created with size one, filling the area
        // from -.5 to .5.  This leads to distances generally less
        // than one, which leaves off half of the interesting morphing
        // effects due to the projection
        // Scaling up the scaling factor allows the values to
        // be both above and below one
        d *= geom->init_sf;
        
//        assert(d > 0.0001f);
        
        *vl++ = (RADIUS-d)/d;

        pts++;
    }
}




//-----------------------------------------------------------------------------
// Name: MapToSide()
// Desc: Takes x,y coordinates in the range 0-1 and maps them onto the given
//       side plane for the current geometry
//-----------------------------------------------------------------------------
VOID MapToSide(PLANE_MAP *map, FLOAT x, FLOAT y, D3DXVECTOR3 *pt)
{
    pt->x = x*map->x_axis.x+y*map->y_axis.x+map->base.x;
    pt->y = x*map->x_axis.y+y*map->y_axis.y+map->base.y;
    pt->z = x*map->x_axis.z+y*map->y_axis.z+map->base.z;
}





//-----------------------------------------------------------------------------
// Name: InitCube()
// Desc: Initializes the cube's geometry
//-----------------------------------------------------------------------------
VOID InitCube(GEOMETRY *geom)
{
    const INT CUBE_SIDES = 6;
    PLANE_MAP cube_planes[CUBE_SIDES] =
    {
        PLANE_MAP(D3DXVECTOR3(-0.5f, -0.5f,  0.5f),  D3DXVECTOR3( 1.0f,  0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, -0.5f, -0.5f),  D3DXVECTOR3(-1.0f,  0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f,  0.5f, -0.5f),  D3DXVECTOR3(-1.0f,  0.0f, 0.0f), D3DXVECTOR3(0.0f, 0.0f, 1.0f)),
        PLANE_MAP(D3DXVECTOR3(-0.5f, -0.5f, -0.5f),  D3DXVECTOR3( 1.0f,  0.0f, 0.0f), D3DXVECTOR3(0.0f, 0.0f, 1.0f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, -0.5f, -0.5f),  D3DXVECTOR3( 0.0f,  1.0f, 0.0f), D3DXVECTOR3(0.0f, 0.0f, 1.0f)),
        PLANE_MAP(D3DXVECTOR3(-0.5f,  0.5f, -0.5f),  D3DXVECTOR3( 0.0f, -1.0f, 0.0f), D3DXVECTOR3(0.0f, 0.0f, 1.0f))
    };
    INT side, x, y;
    D3DXVECTOR3 *pt;
    unsigned short/*INT*/ *idx;
    INT *sz;
    INT side_pts;

    side_pts = (config.subdiv+1)*(config.subdiv+1);
    
    geom->nsides = CUBE_SIDES;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];
    geom->pVertices = &vertices[0];

    geom->min_sf = -1.1f;
    geom->max_sf = 5.1f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 2.0f;
    
    // Generate triangle strip data
    sz = &strip_size[0];
    idx = &index[0];
    for (side = 0; side < geom->nsides; side++)
    {
        geom->sides[side].nstrips = config.subdiv;
        geom->sides[side].strip_size = sz;
        geom->sides[side].strip_index = idx;
        
        for (x = 0; x < config.subdiv; x++)
        {
            *sz++ = (config.subdiv+1)*2;

            for (y = 0; y < config.subdiv+1; y++)
            {
                *idx++ = side * side_pts + x * (config.subdiv + 1) + y;
                *idx++ = side * side_pts + (x + 1) * (config.subdiv + 1) + y;
            }
        }
    }

    // Generate base vertices
    pt = geom->pts;
    for (side = 0; side < geom->nsides; side++)
    {
        for (x = 0; x < config.subdiv+1; x++)
        {
            for (y = 0; y < config.subdiv+1; y++)
            {
                MapToSide(&cube_planes[side],
                          (FLOAT)x/config.subdiv, (FLOAT)y/config.subdiv,
                          pt);
                pt++;
            }
        }
    }

    geom->total_pts = geom->nsides*side_pts;
}





//-----------------------------------------------------------------------------
// Name: InitTetra()
// Desc: Initializes the tetrahedron's geometry
//-----------------------------------------------------------------------------
VOID InitTetra(GEOMETRY *geom)
{
    const INT TETRA_SIDES = 4;
    const FLOAT SQRT3 = 1.73205f;
    const FLOAT SQRT3_2 = (SQRT3/2.0f);
    const FLOAT SQRT3_3 = (SQRT3/3.0f);
    const FLOAT SQRT3_6 = (SQRT3/6.0f);
    const FLOAT SQRT3_12 = (SQRT3/12.0f);
    const FLOAT TETRA_BASE = (-SQRT3/8.0f);
    PLANE_MAP tetra_planes[TETRA_SIDES] =
    {
        PLANE_MAP(D3DXVECTOR3(-0.5f, TETRA_BASE, SQRT3_6), D3DXVECTOR3(1.0f, 0.0f, 0.0f),      D3DXVECTOR3(0.0f, SQRT3_2, -SQRT3_6)),
        PLANE_MAP(D3DXVECTOR3(0.0f, TETRA_BASE, -SQRT3_3), D3DXVECTOR3(-0.5f, 0.0f, SQRT3_2),  D3DXVECTOR3(0.25f, SQRT3_2, SQRT3_12)),
        PLANE_MAP(D3DXVECTOR3(0.5f, TETRA_BASE, SQRT3_6),  D3DXVECTOR3(-0.5f, 0.0f, -SQRT3_2), D3DXVECTOR3(-0.25f, SQRT3_2, SQRT3_12)),
        PLANE_MAP(D3DXVECTOR3(0.5f, TETRA_BASE, SQRT3_6),  D3DXVECTOR3(-1.0f, 0.0f, 0.0f),     D3DXVECTOR3(0.0f, 0.0f, -SQRT3_2)),
    };

    INT side, x, y;
    D3DXVECTOR3 *pt;
    unsigned short/*INT*/ *idx;
    INT *sz;
    unsigned short side_pts;
    unsigned short base_pt;
    unsigned short row_pts;
    FLOAT fx;

    side_pts = (config.subdiv+2)*(config.subdiv+1)/2;
    
    geom->nsides = TETRA_SIDES;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];
    geom->pVertices = &vertices[0];

    geom->min_sf = -1.1f;
    geom->max_sf = 5.2f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 3.75f;

    // Generate triangle strip data
    sz = &strip_size[0];
    idx = &index[0];
    base_pt = 0;
    for (side = 0; side < geom->nsides; side++)
    {
        geom->sides[side].nstrips = config.subdiv;
        geom->sides[side].strip_size = sz;
        geom->sides[side].strip_index = idx;

        for (x = 0; x < config.subdiv; x++)
        {
            row_pts = config.subdiv-x+1;
            *sz++ = row_pts*2-1;

            *idx++ = base_pt;
            for (y = 0; y < row_pts-1; y++)
            {
                *idx++ = base_pt+row_pts+y;
                *idx++ = base_pt+1+y;
            }

            base_pt += row_pts;
        }

        base_pt++;
    }

    // Generate base vertices
    pt = geom->pts;
    for (side = 0; side < geom->nsides; side++)
    {
        for (x = 0; x < config.subdiv+1; x++)
        {
            fx = (FLOAT)x/config.subdiv;
            for (y = 0; y < config.subdiv-x+1; y++)
            {
                MapToSide(&tetra_planes[side],
                          fx+(FLOAT)y/(config.subdiv*2),
                          (FLOAT)y/config.subdiv,
                          pt);
                pt++;
            }
        }
    }

    geom->total_pts = geom->nsides*side_pts;
}




//-----------------------------------------------------------------------------
// Name: InitPyramids()
// Desc: Initializes double pyramid geometry
//-----------------------------------------------------------------------------
VOID InitPyramids(GEOMETRY *geom)
{
    const INT PYRAMIDS_SIDES = 8;
    PLANE_MAP pyramids_planes[PYRAMIDS_SIDES] =
    {
        PLANE_MAP(D3DXVECTOR3(-0.5f, 0.0f,  0.5f), D3DXVECTOR3( 1.0f, 0.0f,  0.0f), D3DXVECTOR3( 0.0f,  0.5f, -0.5f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, 0.0f,  0.5f), D3DXVECTOR3(-1.0f, 0.0f,  0.0f), D3DXVECTOR3( 0.0f, -0.5f, -0.5f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, 0.0f,  0.5f), D3DXVECTOR3( 0.0f, 0.0f, -1.0f), D3DXVECTOR3(-0.5f,  0.5f,  0.0f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, 0.0f, -0.5f), D3DXVECTOR3( 0.0f, 0.0f,  1.0f), D3DXVECTOR3(-0.5f, -0.5f,  0.0f)),
        PLANE_MAP(D3DXVECTOR3( 0.5f, 0.0f, -0.5f), D3DXVECTOR3(-1.0f, 0.0f,  0.0f), D3DXVECTOR3( 0.0f,  0.5f,  0.5f)),
        PLANE_MAP(D3DXVECTOR3(-0.5f, 0.0f, -0.5f), D3DXVECTOR3( 1.0f, 0.0f,  0.0f), D3DXVECTOR3( 0.0f, -0.5f,  0.5f)),
        PLANE_MAP(D3DXVECTOR3(-0.5f, 0.0f, -0.5f), D3DXVECTOR3( 0.0f, 0.0f,  1.0f), D3DXVECTOR3( 0.5f,  0.5f,  0.0f)),
        PLANE_MAP(D3DXVECTOR3(-0.5f, 0.0f,  0.5f), D3DXVECTOR3( 0.0f, 0.0f, -1.0f), D3DXVECTOR3( 0.5f, -0.5f,  0.0f))
    };

    INT side, x, y;
    D3DXVECTOR3 *pt;
    unsigned short/*INT*/ *idx;
    INT *sz;
    unsigned short side_pts;
    unsigned short base_pt;
    unsigned short row_pts;
    FLOAT fx;

    side_pts = (config.subdiv+2)*(config.subdiv+1)/2;
    
    geom->nsides = PYRAMIDS_SIDES;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];
    geom->pVertices = &vertices[0];

    geom->min_sf = -1.1f;
    geom->max_sf = 5.2f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 3.0f;

    // Generate triangle strip data
    sz = &strip_size[0];
    idx = &index[0];
    base_pt = 0;

    for (side = 0; side < geom->nsides; side++) {
        geom->sides[side].nstrips = config.subdiv;
        geom->sides[side].strip_size = sz;
        geom->sides[side].strip_index = idx;
            
        for (x = 0; x < config.subdiv; x++) {
            row_pts = config.subdiv-x+1;
            *sz++ = row_pts*2-1;

            *idx++ = base_pt;
            for (y = 0; y < row_pts-1; y++) {
                *idx++ = base_pt+row_pts+y;
                *idx++ = base_pt+1+y;
            }

            base_pt += row_pts;
        }
            
        base_pt++;
    }

    // Generate base vertices
    pt = geom->pts;
    for (side = 0; side < geom->nsides; side++)
    {
        
        for (x = 0; x < config.subdiv+1; x++)
        {
            fx = (FLOAT)x/config.subdiv;
            for (y = 0; y < config.subdiv-x+1; y++)
            {
                MapToSide(&pyramids_planes[side],
                          fx+(FLOAT)y/(config.subdiv*2),
                          (FLOAT)y/config.subdiv,
                          pt);
                pt++;
            }
        }
    }

    geom->total_pts = geom->nsides*side_pts;
}




//-----------------------------------------------------------------------------
// Name: InitCylinder()
// Desc: Initializes the cylinder geometry
//-----------------------------------------------------------------------------
VOID InitCylinder(GEOMETRY *geom)
{
    unsigned short side, x, y;
    D3DXVECTOR3 *pt;
    unsigned short/*INT*/ *idx;
    INT *sz;
    unsigned short base_pt;
    unsigned short row_pts;
    FLOAT fx, fz;
    double ang;

    geom->nsides = 1;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];
    geom->pVertices = &vertices[0];

    geom->min_sf = -2.5f;
    geom->max_sf = 8.5f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 2.1f;

    // Generate triangle strip data
    // If version 1.1 then allocate the index buffer for glDrawElements
    sz = &strip_size[0];
    idx = &index[0];
    side = 0;
    geom->sides[side].nstrips = config.subdiv;
    geom->sides[side].strip_size = sz;
    geom->sides[side].strip_index = idx;
    
    row_pts = config.subdiv+1;
    base_pt = 0;
    for (x = 0; x < config.subdiv; x++) {
        *sz++ = row_pts*2;
        
        for (y = 0; y < row_pts; y++) {
            // Wrap around at the edge so the cylinder normals
            // are properly averaged
            if (x == config.subdiv-1) {
                *idx++ = y;
            }
            else {
                *idx++ = base_pt+row_pts+y;
            }
            *idx++ = base_pt+y;
        }

        base_pt += row_pts;
    }
    
    // Generate base vertices
    pt = geom->pts;
    ang = 0;
    for (x = 0; x < config.subdiv; x++)
    {
        fx = (FLOAT)cos(ang)*0.5f;
        fz = (FLOAT)sin(ang)*0.5f;
        for (y = 0; y < config.subdiv+1; y++)
        {
            pt->x = fx;
            pt->y = (FLOAT)y/config.subdiv-0.5f;
            pt->z = fz;
            pt++;
        }
        ang += (2*D3DX_PI)/config.subdiv;
    }

    geom->total_pts = geom->nsides*(config.subdiv+1)*config.subdiv;
}




//-----------------------------------------------------------------------------
// Name: InitSpring()
// Desc: Initializes the spring geometry
//-----------------------------------------------------------------------------
VOID InitSpring(GEOMETRY *geom)
{
    const FLOAT SPRING_RADIUS = 0.1f;
    const FLOAT SPRING_CENTER = (0.5f-SPRING_RADIUS);
    INT side, x, y;
    D3DXVECTOR3 *pt;
    unsigned short/*INT*/ *idx;
    INT *sz;
    double ang_center, ang_surf;
    FLOAT cs, sn;
    FLOAT rad;
    PLANE_MAP plane;
    INT spin_pts;
    INT row_pts;

    geom->nsides = 1;
    geom->pts = &pts[0];
    geom->npts = &npts[0];
    geom->normals = &normals[0];
    geom->pVertices = &vertices[0];

    geom->min_sf = -2.2f;
    geom->max_sf = 0.2f;
    geom->sf_inc = 0.05f;
    geom->init_sf = 1.0f;

    // Generate triangle strip data
    // If version 1.1 then allocate the index buffer for glDrawElements
    sz = &strip_size[0];
    idx = &index[0];
    side = 0;
    geom->sides[side].nstrips = config.subdiv;
    geom->sides[side].strip_size = sz;
    geom->sides[side].strip_index = idx;
    
    row_pts = config.subdiv;
    spin_pts = 4*config.subdiv+1;
    for (x = 0; x < config.subdiv; x++) {
        *sz++ = spin_pts*2;

        for (y = 0; y < spin_pts; y++) {
            *idx++ = x+row_pts*y;
            // Wrap around at the edge so the cylindrical surface
            // of the tube is seamless.  Without this the normal
            // averaging would be incorrect and a seam would be visible
            if (x == config.subdiv-1) {
                *idx++ = row_pts*y;
            }
            else {
                *idx++ = x+row_pts*y+1;
            }
        }
    }
    
    // Generate base vertices
    pt = geom->pts;
    ang_center = 0;
    plane.y_axis.x = 0.0f;
    plane.y_axis.y = SPRING_RADIUS;
    plane.y_axis.z = 0.0f;
    plane.x_axis.y = 0.0f;
    for (x = 0; x < spin_pts; x++)
    {
        cs = (FLOAT)cos(ang_center);
        sn = (FLOAT)sin(ang_center);
        rad = 0.5f-(FLOAT)x/(spin_pts-1)*(SPRING_CENTER/2);
        plane.base.x = cs*rad;
        plane.base.y = -0.5f+(FLOAT)x/(spin_pts-1);
        plane.base.z = sn*rad;
        plane.x_axis.x = cs*SPRING_RADIUS;
        plane.x_axis.z = sn*SPRING_RADIUS;

        ang_surf = 0;
        for (y = 0; y < config.subdiv; y++)
        {
            MapToSide(&plane,
                      (FLOAT)cos(ang_surf), (FLOAT)sin(ang_surf),
                      pt);
            pt++;
            ang_surf += (2*D3DX_PI)/config.subdiv;
        }
        
        ang_center += (4*D3DX_PI)/(spin_pts-1);
    }

    geom->total_pts = geom->nsides*spin_pts*config.subdiv;
}




//-----------------------------------------------------------------------------
// Name: DrawGeom()
// Desc: Draw the current geometry
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::DrawGeom(GEOMETRY *geom)
{
    if (config.smooth_colors)
        m_pd3dDevice->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_GOURAUD );
    else
        m_pd3dDevice->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT );

    if (config.color_pick == ID_COL_SINGLE)
        SetMaterialColor(solid_cols);

    for( INT i = 0; i < geom->total_pts; i++ )
    {
        geom->pVertices[i].p = *(D3DXVECTOR3*)&geom->npts[i];
        D3DXVec3Normalize( &geom->pVertices[i].n, (D3DXVECTOR3*)&geom->normals[i] );
    }

    m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );

    WORD* col0Indices = NULL;
    INT numCol0Indices;
    WORD* col1Indices = NULL;
    INT numCol1Indices;

    col0Indices = new WORD[5000];
    if( col0Indices == NULL )
        return;
    col1Indices = new WORD[5000];
    if( col1Indices == NULL )
    {
        delete[] col0Indices;
        return;
    }

    INT side;
    INT strip;
    INT triangle;
    unsigned short *idx;
    BOOL bBackwards; // triangle backwards for original strip implementation
    BOOL bCol0; // col0 or col1 for this triangle?
    INT numThisColor; // num tris done in this color; helps determine bCol0
    for (side = 0; side < geom->nsides; side++) 
    {
        numCol0Indices = 0;
        numCol1Indices = 0;
        bCol0 = TRUE;

        idx = geom->sides[side].strip_index;
        for (strip = 0; strip < geom->sides[side].nstrips; strip++, idx += 2) 
        {
            numThisColor = 0;
            if( !config.triangle_colors )
                numThisColor++;
            bBackwards = FALSE;
            if( config.color_pick == ID_COL_CHECKER )
                bCol0 = ( strip & 1 );

            for( triangle = 0; triangle < geom->sides[side].strip_size[strip] - 2; triangle++ )
            {
                if( config.color_pick == ID_COL_CHECKER )
                {
                    numThisColor++;
                    if( numThisColor == 2 )
                    {
                        bCol0 = !bCol0;
                        numThisColor = 0;
                    }
                }

                if( bCol0 )
                {
                    if( bBackwards )
                    {
                        col0Indices[numCol0Indices++] = *(idx+1);
                        col0Indices[numCol0Indices++] = *(idx+0);
                        col0Indices[numCol0Indices++] = *(idx+2);
                    }
                    else
                    {
                        col0Indices[numCol0Indices++] = *(idx+0);
                        col0Indices[numCol0Indices++] = *(idx+1);
                        col0Indices[numCol0Indices++] = *(idx+2);
                    }
                }
                else
                {
                    if( bBackwards )
                    {
                        col1Indices[numCol1Indices++] = *(idx+1);
                        col1Indices[numCol1Indices++] = *(idx+0);
                        col1Indices[numCol1Indices++] = *(idx+2);
                    }
                    else
                    {
                        col1Indices[numCol1Indices++] = *(idx+0);
                        col1Indices[numCol1Indices++] = *(idx+1);
                        col1Indices[numCol1Indices++] = *(idx+2);
                   }
                }
                idx ++;
                bBackwards = !bBackwards;
            }
        }

        // Draw this side's col0 primitives
        if (config.color_pick == ID_COL_PER_SIDE) 
            SetMaterialColor(side_cols[side]);
        else if (config.color_pick == ID_COL_CHECKER) 
            SetMaterialColor(checker_cols[side][0]);
        m_pd3dDevice->DrawIndexedPrimitiveUP( D3DPT_TRIANGLELIST, 0,
            geom->total_pts, numCol0Indices / 3, 
            col0Indices, D3DFMT_INDEX16, &geom->pVertices[0], sizeof(MYVERTEX) );

        // Draw this side's col1 primitives, if any
        if (config.color_pick == ID_COL_CHECKER) 
        {
            SetMaterialColor(checker_cols[side][1]);
            m_pd3dDevice->DrawIndexedPrimitiveUP( D3DPT_TRIANGLELIST, 0,
                geom->total_pts, numCol1Indices / 3, 
                col1Indices, D3DFMT_INDEX16, &geom->pVertices[0], sizeof(MYVERTEX) );
        }
    }
    if( col0Indices != NULL )
        delete[] col0Indices;
    if( col1Indices != NULL )
        delete[] col1Indices;
}




//-----------------------------------------------------------------------------
// Name: ComputeAveragedNormals()
// Desc: Compute face-averaged normals for each vertex
//-----------------------------------------------------------------------------
VOID ComputeAveragedNormals(GEOMETRY *geom)
{
    INT side, strip;
    INT *sz;
    unsigned short/*INT*/ *idx;
    INT idx1, idx2, idx3;
    INT tc, idc;
    D3DXVECTOR3 v1, v2, n1;
    
    memset(geom->normals, 0, sizeof(D3DXVECTOR3)*geom->total_pts);
    
    for (side = 0; side < geom->nsides; side++)
    {
        idx = geom->sides[side].strip_index;
        sz = geom->sides[side].strip_size;
        for (strip = 0; strip < geom->sides[side].nstrips; strip++)
        {
            idx1 = *idx++;
            idx2 = *idx++;

//            assert(idx1 >= 0 && idx1 < geom->total_pts &&
//                   idx2 >= 0 && idx2 < geom->total_pts);
            
            tc = (*sz++)-2;
            for (idc = 0; idc < tc; idc++)
            {
                idx3 = *idx++;

//                assert(idx3 >= 0 && idx3 < geom->total_pts);

                v1 = geom->npts[idx3] - geom->npts[idx1];
                v2 = geom->npts[idx2] - geom->npts[idx1];
                D3DXVec3Cross( &n1, &v1, &v2 );

                // Triangle strip ordering causes half of the triangles
                // to be oriented oppositely from the others
                // Those triangles need to have their normals flipped
                // so the whole triangle strip has consistent normals
                if ((idc & 1) == 0)
                {
                    n1.x = -n1.x;
                    n1.y = -n1.y;
                    n1.z = -n1.z;
                }

                geom->normals[idx1] += n1;
                geom->normals[idx2] += n1;
                geom->normals[idx3] += n1;

                idx1 = idx2;
                idx2 = idx3;
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: UpdatePts()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::UpdatePts(GEOMETRY *geom, FLOAT sf)
{
    INT pt;
    FLOAT f, *vl;
    D3DXVECTOR3 *v;
    D3DXVECTOR3 *p;

    vl = vlen;
    p = &geom->pts[0];
    v = &geom->npts[0];
    for (pt = 0; pt < geom->total_pts; pt++)
    {
        f = (*vl++)*sf+1;
        v->x = p->x*f;
        v->y = p->y*f;
        v->z = p->z*f;
        p++;
        v++;
    }

    ComputeAveragedNormals(geom);
}




//-----------------------------------------------------------------------------
// Name: ComputeHsvColors()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::ComputeHsvColors(VOID)
{
    FLOAT *cols;
    INT ncols;
    FLOAT ang, da;
    INT hex;
    FLOAT fhex, frac;
    FLOAT p, q, t;
    FLOAT sat, val;

    switch(config.color_pick)
    {
    case ID_COL_CHECKER:
        ncols = MAXSIDES*NCCOLS;
        cols = &checker_cols[0][0][0];
        break;
    case ID_COL_PER_SIDE:
        ncols = MAXSIDES;
        cols = &side_cols[0][0];
        break;
    case ID_COL_SINGLE:
        ncols = 1;
        cols = &solid_cols[0];
        break;
    }

    ang = m_phase;
    da = (FLOAT)((2*D3DX_PI)/ncols);
    val = sat = 1.0f;

    while (ncols > 0)
    {
        fhex = (FLOAT)(6*ang/(2*D3DX_PI));
        hex = (INT)fhex;
        frac = fhex-hex;
        hex = hex % 6;
        
	p = val*(1-sat);
	q = val*(1-sat*frac);
	t = val*(1-sat*(1-frac));
        
	switch(hex)
	{
	case 0:
            cols[0] = val;
            cols[1] = t;
            cols[2] = p;
	    break;
	case 1:
            cols[0] = q;
            cols[1] = val;
            cols[2] = p;
	    break;
	case 2:
            cols[0] = p;
            cols[1] = val;
            cols[2] = t;
	    break;
	case 3:
            cols[0] = p;
            cols[1] = q;
            cols[2] = val;
	    break;
	case 4:
            cols[0] = t;
            cols[1] = p;
            cols[2] = val;
            break;
	case 5:
            cols[0] = val;
            cols[1] = p;
            cols[2] = q;
	    break;
	}

        ang += da;
        cols += 4;
        ncols--;
    }
}




//-----------------------------------------------------------------------------
// Name: NewConfig()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::NewConfig(CONFIG *cnf)
{
    // Set new config
    config = *cnf;

    HKEY hkey;

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        DXUtil_WriteBoolRegKey( hkey, TEXT("Smooth"), config.smooth_colors );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Slanted"), config.triangle_colors );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Cycle"), config.cycle_colors );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Spin"), config.spin );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Bloom"), config.bloom );
        DXUtil_WriteIntRegKey( hkey, TEXT("Subdiv"), config.subdiv );
        DXUtil_WriteIntRegKey( hkey, TEXT("ColorPick"), config.color_pick );
        DXUtil_WriteIntRegKey( hkey, TEXT("ImageSize"), config.image_size );
        DXUtil_WriteIntRegKey( hkey, TEXT("Geom"), config.geom );
        DXUtil_WriteIntRegKey( hkey, TEXT("TwoSided"), config.two_sided );

        WriteScreenSettings( hkey );

        RegCloseKey( hkey );
    }

    // Reset colors
    memcpy(checker_cols, base_checker_cols, sizeof(checker_cols));
    memcpy(side_cols, base_side_cols, sizeof(side_cols));
    memcpy(solid_cols, base_solid_cols, sizeof(solid_cols));

    // Reset geometry
    m_pGeomCur = geom_table[config.geom];
    m_pGeomCur->init(m_pGeomCur);
    
//    assert(m_pGeomCur->total_pts <= MAXPTS);
           
    InitVlen(m_pGeomCur, m_pGeomCur->total_pts, m_pGeomCur->pts);
    m_sf = 0.0f;
    m_sfi = m_pGeomCur->sf_inc;
    UpdatePts(m_pGeomCur, m_sf);
}




//-----------------------------------------------------------------------------
// Name: SetupTrackbar()
// Desc: Setup a common control trackbar
//-----------------------------------------------------------------------------
VOID SetupTrackbar( HWND hDlg, INT item, INT lo, INT hi, INT lineSize, 
                  INT pageSize, INT pos )
{
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETRANGE, 
        (WPARAM) TRUE, 
        (LPARAM) MAKELONG( lo, hi )
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETPOS, 
        (WPARAM) TRUE, 
        (LPARAM) pos
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETPAGESIZE, 
        (WPARAM) 0,
        (LPARAM) pageSize 
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETLINESIZE, 
        (WPARAM) 0,
        (LPARAM) lineSize
    );
}




//-----------------------------------------------------------------------------
// Name: GetTrackbarPos()
// Desc: Get the current position of a common control trackbar
//-----------------------------------------------------------------------------
INT GetTrackbarPos( HWND hDlg, INT item )
{
    return 
       (INT)SendDlgItemMessage( 
            hDlg, 
            item,
            TBM_GETPOS, 
            0,
            0
        );
}

// Temporary configuration for when the configuration dialog is active
// If the dialog is ok'ed then this becomes the current configuration,
// otherwise it is discarded
CONFIG temp_config;

//-----------------------------------------------------------------------------
// Name: ScreenSaverConfigureDialog()
// Desc: 
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CFlowerBoxScreensaver::ScreenSaverConfigureDialog(HWND hdlg, UINT msg,
                                         WPARAM wpm, LPARAM lpm)
{
    HWND hCtrl;
    INT i;
    
    switch(msg)
    {
    case WM_INITDIALOG:

        InitCommonControls();

        g_pMyFlowerBoxScreensaver->ReadSettings();
    
        temp_config = config;
        
        CheckRadioButton(hdlg, ID_COL_PICK_FIRST, ID_COL_PICK_LAST,
                         config.color_pick);
        CheckDlgButton(hdlg, ID_COL_SMOOTH, config.smooth_colors);
        CheckDlgButton(hdlg, ID_COL_TRIANGLE, config.triangle_colors);
        CheckDlgButton(hdlg, ID_COL_CYCLE, config.cycle_colors);
        CheckDlgButton(hdlg, ID_SPIN, config.spin);
        CheckDlgButton(hdlg, ID_BLOOM, config.bloom);
        CheckDlgButton(hdlg, ID_TWO_SIDED,
                       config.two_sided == GL_FRONT_AND_BACK);
        
        SetupTrackbar( hdlg, ID_COMPLEXITY, MINSUBDIV, MAXSUBDIV, 
                          complexity_range.step,
                          complexity_range.page_step,
                          config.subdiv);

        SetupTrackbar( hdlg, ID_IMAGE_SIZE, MINIMAGESIZE, MAXIMAGESIZE, 
                          image_size_range.step,
                          image_size_range.page_step,
                          config.image_size);

        hCtrl = GetDlgItem(hdlg, ID_GEOM);
        SendMessage(hCtrl, CB_RESETCONTENT, 0, 0);

        // String storage
        TCHAR geom_names[IDS_GEOM_COUNT][20];
        
        for (i = 0; i < IDS_GEOM_COUNT; i++)
        {
            LoadString( NULL, i+IDS_GEOM_FIRST, geom_names[i],
                        sizeof(geom_names)/IDS_GEOM_COUNT );
            SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)geom_names[i]);
        }
        SendMessage(hCtrl, CB_SETCURSEL, config.geom, 0);
        
        SetFocus(GetDlgItem(hdlg, ID_COMPLEXITY));
        return FALSE;

    case WM_COMMAND:
        switch(LOWORD(wpm))
        {
        case ID_COL_CHECKER:
        case ID_COL_PER_SIDE:
        case ID_COL_SINGLE:
            temp_config.color_pick = LOWORD(wpm);
            break;

        case ID_COL_SMOOTH:
            temp_config.smooth_colors = !temp_config.smooth_colors;
            break;
        case ID_COL_TRIANGLE:
            temp_config.triangle_colors = !temp_config.triangle_colors;
            break;
        case ID_COL_CYCLE:
            temp_config.cycle_colors = !temp_config.cycle_colors;
            break;
            
        case ID_SPIN:
            temp_config.spin = !temp_config.spin;
            break;
        case ID_BLOOM:
            temp_config.bloom = !temp_config.bloom;
            break;
        case ID_TWO_SIDED:
            temp_config.two_sided =
                temp_config.two_sided == GL_FRONT_AND_BACK ? GL_FRONT :
                GL_FRONT_AND_BACK;
            break;

        case IDC_SCREENSETTINGS:
            g_pMyFlowerBoxScreensaver->DoScreenSettingsDialog(hdlg);
            break;

        case IDOK:
            temp_config.subdiv =
                GetTrackbarPos(hdlg, ID_COMPLEXITY);
            temp_config.image_size =
                GetTrackbarPos(hdlg, ID_IMAGE_SIZE);
            temp_config.geom =
                (INT)SendMessage(GetDlgItem(hdlg, ID_GEOM), CB_GETCURSEL, 0, 0);
//            NewConfig(&temp_config);
            // Fall through
        case IDCANCEL:
            EndDialog(hdlg, LOWORD(wpm));
            break;
        }
        return TRUE;
        
    }

    return FALSE;
}





//-----------------------------------------------------------------------------
// Name: SetMaterialColor()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlowerBoxScreensaver::SetMaterialColor(FLOAT* pfColors)
{
    D3DMATERIAL8 mtrl;

    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = pfColors[0];
    mtrl.Diffuse.g = mtrl.Ambient.g = pfColors[1];
    mtrl.Diffuse.b = mtrl.Ambient.b = pfColors[2];
    mtrl.Diffuse.a = mtrl.Ambient.a = pfColors[3];
    mtrl.Specular.r = 0.8f;
    mtrl.Specular.g = 0.8f;
    mtrl.Specular.b = 0.8f;
    mtrl.Specular.a = 1.0f;
    mtrl.Power = 30.0f;

    return m_pd3dDevice->SetMaterial(&mtrl);
}




//-----------------------------------------------------------------------------
// Name: ReadSettings()
// Desc: Read user preferences from registry
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::ReadSettings()
{
    HKEY hkey;

    // Read OpenGL settings first, so OS upgrade cases work
    ss_ReadSettings();

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        DXUtil_ReadBoolRegKey( hkey, TEXT("Smooth"), &config.smooth_colors, config.smooth_colors );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Slanted"), &config.triangle_colors, config.triangle_colors );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Cycle"), &config.cycle_colors, config.cycle_colors );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Spin"), &config.spin, config.spin );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Bloom"), &config.bloom, config.bloom );
        DXUtil_ReadIntRegKey( hkey, TEXT("Subdiv"), (DWORD*)&config.subdiv, config.subdiv );
        if( config.subdiv < MINSUBDIV )
            config.subdiv = MINSUBDIV;
        if( config.subdiv > MAXSUBDIV )
            config.subdiv = MAXSUBDIV;
        DXUtil_ReadIntRegKey( hkey, TEXT("ColorPick"), (DWORD*)&config.color_pick, config.color_pick );
        DXUtil_ReadIntRegKey( hkey, TEXT("ImageSize"), (DWORD*)&config.image_size, config.image_size );
        DXUtil_ReadIntRegKey( hkey, TEXT("Geom"), (DWORD*)&config.geom, config.geom );
        DXUtil_ReadIntRegKey( hkey, TEXT("TwoSided"), (DWORD*)&config.two_sided, config.two_sided );

        ReadScreenSettings( hkey );

        RegCloseKey( hkey );
    }
}




//-----------------------------------------------------------------------------
// Name: ss_ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::ss_ReadSettings()
{
    if( !ss_RegistrySetup( IDS_INI_SECTION, IDS_INIFILE ) )
        return;
    
    config.smooth_colors =
        ss_GetRegistryInt( IDS_CONFIG_SMOOTH_COLORS, config.smooth_colors );
    config.triangle_colors =
        ss_GetRegistryInt( IDS_CONFIG_TRIANGLE_COLORS, config.triangle_colors );
    config.cycle_colors =
        ss_GetRegistryInt( IDS_CONFIG_CYCLE_COLORS, config.cycle_colors );
    config.spin =
        ss_GetRegistryInt( IDS_CONFIG_SPIN, config.spin );
    config.bloom =
        ss_GetRegistryInt( IDS_CONFIG_BLOOM, config.bloom );
    config.subdiv =
        ss_GetRegistryInt( IDS_CONFIG_SUBDIV, config.subdiv );
    config.color_pick =
        ss_GetRegistryInt( IDS_CONFIG_COLOR_PICK, config.color_pick );
    config.image_size =
        ss_GetRegistryInt( IDS_CONFIG_IMAGE_SIZE, config.image_size );
    config.geom =
        ss_GetRegistryInt( IDS_CONFIG_GEOM, config.geom );
    config.two_sided =
        ss_GetRegistryInt( IDS_CONFIG_TWO_SIDED, config.two_sided );
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CFlowerBoxScreensaver::ss_RegistrySetup( int section, int file )
{
    if( LoadString(m_hInstance, section, g_szSectName, BUF_SIZE) &&
        LoadString(m_hInstance, file, g_szFname, BUF_SIZE) ) 
    {
        TCHAR pBuffer[100];
        DWORD dwRealSize = GetPrivateProfileSection( g_szSectName, pBuffer, 100, g_szFname );
        if( dwRealSize > 0 )
            return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
int CFlowerBoxScreensaver::ss_GetRegistryInt( int name, int iDefault )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        return GetPrivateProfileInt(g_szSectName, szItemName, iDefault, g_szFname);

    return 0;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::ss_GetRegistryString( int name, LPTSTR lpDefault, 
                                                         LPTSTR lpDest, int bufSize )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        GetPrivateProfileString(g_szSectName, szItemName, lpDefault, lpDest,
                                bufSize, g_szFname);

    return;
}




//-----------------------------------------------------------------------------
// Name: DoConfig()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlowerBoxScreensaver::DoConfig()
{
    if( IDOK == DialogBox( NULL, MAKEINTRESOURCE( DLG_SCRNSAVECONFIGURE ),
        m_hWndParent, ScreenSaverConfigureDialog ) )
    {
        NewConfig(&temp_config);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\flyingobjects.cpp ===
//-----------------------------------------------------------------------------
// File: FlyingObjects.cpp
//
// Desc: Fun screen saver
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <windows.h>
#include <tchar.h>
#include <d3d8.h>
#include <d3dx8.h>
#include <d3d8rgbrast.h>
#include <time.h>
#include <stdio.h>
#include <commctrl.h>
#include <scrnsave.h>
#include "d3dsaver.h"
#include "FlyingObjects.h"
#include "mesh.h"
#include "Resource.h"
#include "dxutil.h"


extern void updateStripScene(int flags, FLOAT fElapsedTime);
extern void updateDropScene(int flags, FLOAT fElapsedTime);
extern void updateLemScene(int flags, FLOAT fElapsedTime);
extern void updateExplodeScene(int flags, FLOAT fElapsedTime);
extern void updateWinScene(int flags, FLOAT fElapsedTime);
extern void updateWin2Scene(int flags, FLOAT fElapsedTime);
extern void updateTexScene(int flags, FLOAT fElapsedTime);
extern BOOL initStripScene(void);
extern BOOL initDropScene(void);
extern BOOL initLemScene(void);
extern BOOL initExplodeScene(void);
extern BOOL initWinScene(void);
extern BOOL initWin2Scene(void);
extern BOOL initTexScene(void);
extern void delStripScene(void);
extern void delDropScene(void);
extern void delLemScene(void);
extern void delExplodeScene(void);
extern void delWinScene(void);
extern void delWin2Scene(void);
extern void delTexScene(void);

typedef void (*PTRUPDATE)(int flags, FLOAT fElapsedTime);
typedef void (*ptrdel)();
typedef BOOL (*ptrinit)();

// Each screen saver style puts its hook functions into the function
// arrays below.  A consistent ordering of the functions is required.

static PTRUPDATE updateFuncs[] =
    {/*updateWinScene,*/ updateWin2Scene, updateExplodeScene,updateStripScene, updateStripScene,
     updateDropScene, updateLemScene, updateTexScene};

static ptrdel delFuncs[] =
    {/*delWinScene,*/ delWin2Scene, delExplodeScene, delStripScene, delStripScene,
     delDropScene, delLemScene, delTexScene};

static ptrinit initFuncs[] =
    {/*initWinScene,*/ initWin2Scene, initExplodeScene, initStripScene, initStripScene,
     initDropScene, initLemScene, initTexScene};

static int idsStyles[] =
    {IDS_LOGO, IDS_EXPLODE, IDS_RIBBON, IDS_2RIBBON,
     IDS_SPLASH, IDS_TWIST, IDS_FLAG};

#define MAX_TYPE    ( sizeof(initFuncs) / sizeof(ptrinit) - 1 )

// Each screen saver style can choose which dialog box controls it wants
// to use.  These flags enable each of the controls.  Controls not choosen
// will be disabled.

#define OPT_COLOR_CYCLE     0x00000001
#define OPT_SMOOTH_SHADE    0x00000002
#define OPT_TESSEL          0x00000008
#define OPT_SIZE            0x00000010
#define OPT_TEXTURE         0x00000020
#define OPT_STD             ( OPT_COLOR_CYCLE | OPT_SMOOTH_SHADE | OPT_TESSEL | OPT_SIZE )

static ULONG gflConfigOpt[] = {
//     OPT_STD,               // Windows logo
     0,                     // New Windows logo
     OPT_STD,               // Explode
     OPT_STD,               // Strip
     OPT_STD,               // Strip
     OPT_STD,               // Drop
     OPT_STD,               // Twist (lemniscate)
     OPT_SMOOTH_SHADE | OPT_TESSEL | OPT_SIZE | OPT_TEXTURE  // Texture mapped flag
};

static void updateDialogControls(HWND hDlg);

CFlyingObjectsScreensaver* g_pMyFlyingObjectsScreensaver = NULL;

INT g_xScreenOrigin = 0;
INT g_yScreenOrigin = 0;
INT g_iDevice = -1;
FLOATRECT* g_pFloatRect = NULL;
BOOL gbBounce = FALSE; // floating window bounce off side


// Global message loop variables.
D3DMATERIAL8 Material[16];
#ifdef MEMDEBUG
ULONG totalMem = 0;
#endif

void (*updateSceneFunc)(int flags, FLOAT fElapsedTime); // current screen saver update function
void (*delSceneFunc)(void);         // current screen saver deletion function
BOOL bColorCycle = FALSE;           // color cycling flag
DeviceObjects* g_pDeviceObjects = NULL;
BOOL g_bMoveToOrigin = FALSE;
BOOL g_bAtOrigin = FALSE;
BOOL bSmoothShading = TRUE;         // smooth shading flag
UINT uSize = 100;                   // object size
float fTesselFact = 2.0f;           // object tessalation
int UpdateFlags = 0;                // extra data sent to update function
int Type = 0;                       // screen saver index (into function arrays)

LPDIRECT3DDEVICE8 m_pd3dDevice = NULL;
LPDIRECT3DINDEXBUFFER8 m_pIB = NULL;
LPDIRECT3DVERTEXBUFFER8 m_pVB = NULL;
LPDIRECT3DVERTEXBUFFER8 m_pVB2 = NULL;

// Texture file information
TEXFILE gTexFile = {0};

// Lighting properties.

static const RGBA lightAmbient   = {0.21f, 0.21f, 0.21f, 1.0f};
static const RGBA light0Ambient  = {0.0f, 0.0f, 0.0f, 1.0f};
static const RGBA light0Diffuse  = {0.7f, 0.7f, 0.7f, 1.0f};
static const RGBA light0Specular = {1.0f, 1.0f, 1.0f, 1.0f};
static const FLOAT light0Pos[]      = {100.0f, 100.0f, 100.0f, 0.0f};

// Material properties.

static RGBA matlColors[7] = {{1.0f, 0.0f, 0.0f, 1.0f},
                             {0.0f, 1.0f, 0.0f, 1.0f},
                             {0.0f, 0.0f, 1.0f, 1.0f},
                             {1.0f, 1.0f, 0.0f, 1.0f},
                             {0.0f, 1.0f, 1.0f, 1.0f},
                             {1.0f, 0.0f, 1.0f, 1.0f},
                             {0.235f, 0.0f, 0.78f, 1.0f},
                            };




static D3DMATERIAL8 s_mtrl = 
{ 
    1.0f, 1.0f, 1.0f, 1.0f,  // Diffuse
    1.0f, 1.0f, 1.0f, 1.0f,  // Ambient
    1.0f, 1.0f, 1.0f, 1.0f,  // Specular
    0.0f, 0.0f, 0.0f, 0.0f,  // Emissive
    30.0f                    // Power
};


#define BUF_SIZE 255
TCHAR g_szSectName[BUF_SIZE];
TCHAR g_szFname[BUF_SIZE];


//-----------------------------------------------------------------------------
// Name: myglMaterialfv()
// Desc: 
//-----------------------------------------------------------------------------
VOID myglMaterialfv(INT face, INT pname, FLOAT* params)
{
    if( pname == GL_AMBIENT_AND_DIFFUSE)
    {
        s_mtrl.Ambient.r = s_mtrl.Diffuse.r = params[0];
        s_mtrl.Ambient.g = s_mtrl.Diffuse.g = params[1];
        s_mtrl.Ambient.b = s_mtrl.Diffuse.b = params[2];
        s_mtrl.Ambient.a = s_mtrl.Diffuse.a = params[3];
    }
    else if( pname == GL_SPECULAR )
    {
        s_mtrl.Specular.r = params[0];
        s_mtrl.Specular.g = params[1];
        s_mtrl.Specular.b = params[2];
        s_mtrl.Specular.a = params[3];
    }
    else if( pname == GL_SHININESS )
    {
        s_mtrl.Power = params[0];
    }

    m_pd3dDevice->SetMaterial(&s_mtrl);
}




//-----------------------------------------------------------------------------
// Name: myglMaterialf()
// Desc: 
//-----------------------------------------------------------------------------
VOID myglMaterialf(INT face, INT pname, FLOAT param)
{
    if( pname == GL_SHININESS )
    {
        s_mtrl.Power = param;
    }

    m_pd3dDevice->SetMaterial(&s_mtrl);
}




/******************************Public*Routine******************************\
* HsvToRgb
*
* HSV to RGB color space conversion.  From pg. 593 of Foley & van Dam.
*
\**************************************************************************/
void ss_HsvToRgb(float h, float s, float v, RGBA *color )
{
    float i, f, p, q, t;

    // set alpha value, so caller doesn't have to worry about undefined value
    color->a = 1.0f;

    if (s == 0.0f)     // assume h is undefined
        color->r = color->g = color->b = v;
    else {
        if (h >= 360.0f)
            h = 0.0f;
        h = h / 60.0f;
        i = (float) floor(h);
        f = h - i;
        p = v * (1.0f - s);
        q = v * (1.0f - (s * f));
        t = v * (1.0f - (s * (1.0f - f)));
        switch ((int)i) {
        case 0:
            color->r = v;
            color->g = t;
            color->b = p;
            break;
        case 1:
            color->r = q;
            color->g = v;
            color->b = p;
            break;
        case 2:
            color->r = p;
            color->g = v;
            color->b = t;
            break;
        case 3:
            color->r = p;
            color->g = q;
            color->b = v;
            break;
        case 4:
            color->r = t;
            color->g = p;
            color->b = v;
            break;
        case 5:
            color->r = v;
            color->g = p;
            color->b = q;
            break;
        default:
            break;
        }
    }
}





void *SaverAlloc(ULONG size)
{
    void *mPtr;

    mPtr = malloc(size);
#ifdef MEMDEBUG
    totalMem += size;
    xprintf("malloc'd %x, size %d\n", mPtr, size);
#endif
    return mPtr;
}




void SaverFree(void *pMem)
{
#ifdef MEMDEBUG
    totalMem -= _msize(pMem);
    xprintf("free %x, size = %d, total = %d\n", pMem, _msize(pMem), totalMem);
#endif
    free(pMem);
}




// Minimum and maximum image sizes
#define MINIMAGESIZE 10
#define MAXIMAGESIZE 100


// A slider range
typedef struct _RANGE
{
    int min_val;
    int max_val;
    int step;
    int page_step;
} RANGE;

RANGE complexity_range = {MINSUBDIV, MAXSUBDIV, 1, 2};
RANGE image_size_range = {MINIMAGESIZE, MAXIMAGESIZE, 1, 10};



/******************************Public*Routine******************************\
* initMaterial
*
* Initialize the material properties.
*
\**************************************************************************/

void initMaterial(int id, float r, float g, float b, float a)
{
    Material[id].Ambient.r = r;
    Material[id].Ambient.g = g;
    Material[id].Ambient.b = b;
    Material[id].Ambient.a = a;

    Material[id].Diffuse.r = r;
    Material[id].Diffuse.g = g;
    Material[id].Diffuse.b = b;
    Material[id].Diffuse.a = a;

    Material[id].Specular.r = 1.0f;
    Material[id].Specular.g = 1.0f;
    Material[id].Specular.b = 1.0f;
    Material[id].Specular.a = 1.0f;

    Material[id].Power = 128.0f;
}

/******************************Public*Routine******************************\
* _3dfo_Init
*
\**************************************************************************/

BOOL CFlyingObjectsScreensaver::_3dfo_Init(void *data)
{

    int i;

    for (i = 0; i < 7; i++)
        initMaterial(i, matlColors[i].r, matlColors[i].g,
                     matlColors[i].b, matlColors[i].a);

/*
    // Set the OpenGL clear color to black.

    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
#ifdef SS_DEBUG
    glClearColor(0.2f, 0.2f, 0.2f, 0.0f);
#endif

    // Enable the z-buffer.

    glEnable(GL_DEPTH_TEST);
*/
    // Select the shading model.

    if (bSmoothShading)
    {
        m_pd3dDevice->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_GOURAUD );
    }
    else
    {
        m_pd3dDevice->SetRenderState( D3DRS_SHADEMODE, D3DSHADE_FLAT );
    }

/*    // Setup the OpenGL matrices.

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // Setup the lighting.

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (FLOAT *) &lightAmbient);
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE);
    glLightfv(GL_LIGHT0, GL_AMBIENT, (FLOAT *) &light0Ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, (FLOAT *) &light0Diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, (FLOAT *) &light0Specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
*/

//    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, D3DCOLOR_COLORVALUE(lightAmbient.r,
//        lightAmbient.g, lightAmbient.b, lightAmbient.a ) );

    D3DLIGHT8 light;
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type = D3DLIGHT_POINT;
    light.Range = 1000.0f;
    light.Position.x = light0Pos[0];
    light.Position.y = light0Pos[1];
    light.Position.z = light0Pos[2];
    light.Ambient.r = lightAmbient.r;
    light.Ambient.g = lightAmbient.g;
    light.Ambient.b = lightAmbient.b;
    light.Ambient.a = light0Ambient.a;
    light.Diffuse.r = light0Diffuse.r;
    light.Diffuse.g = light0Diffuse.g;
    light.Diffuse.b = light0Diffuse.b;
    light.Diffuse.a = light0Diffuse.a;
    light.Specular.r = light0Specular.r;
    light.Specular.g = light0Specular.g;
    light.Specular.b = light0Specular.b;
    light.Specular.a = light0Specular.a;
    light.Attenuation0 = 1.0f;
    light.Attenuation1 = 0.0f;
    light.Attenuation2 = 0.0f;
    m_pd3dDevice->SetLight(0, &light);
    m_pd3dDevice->LightEnable(0, TRUE);

//    m_pd3dDevice->SetRenderState( D3DRS_NORMALIZENORMALS, TRUE);

    // Setup the material properties.
    m_pd3dDevice->SetMaterial( &Material[0] );

/*    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, (FLOAT *) &Material[0].ks);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, (FLOAT *) &Material[0].specExp);
*/
    // call specific objects init func
    if (! (*initFuncs[Type])() )
        return FALSE;
    updateSceneFunc = updateFuncs[Type];

    return TRUE;
}




/******************************Public*Routine******************************\
* WriteSettings
*
* Save the screen saver configuration option to the .INI file/registry.
*
* History:
*  10-May-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/
VOID CFlyingObjectsScreensaver::WriteSettings(HWND hDlg)
{
    HKEY hkey;

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        int pos, options;
        int optMask = 1;

        bSmoothShading = IsDlgButtonChecked(hDlg, DLG_SETUP_SMOOTH);
        bColorCycle = IsDlgButtonChecked(hDlg, DLG_SETUP_CYCLE);
        options = bColorCycle;
        options <<= 1;
        options |= bSmoothShading;
        DXUtil_WriteIntRegKey( hkey, TEXT("Options"), options );

        Type = (int)SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_GETCURSEL,
                                       0, 0);
        DXUtil_WriteIntRegKey( hkey, TEXT("Type"), Type );

        pos = ss_GetTrackbarPos( hDlg, DLG_SETUP_TESSEL );
        DXUtil_WriteIntRegKey( hkey, TEXT("Tesselation"), pos );

        pos = ss_GetTrackbarPos( hDlg, DLG_SETUP_SIZE );
        DXUtil_WriteIntRegKey( hkey, TEXT("Size"), pos );

        DXUtil_WriteStringRegKey( hkey, TEXT("Texture"), gTexFile.szPathName );
        DXUtil_WriteIntRegKey( hkey, TEXT("TextureFileOffset"), gTexFile.nOffset );

        WriteScreenSettings( hkey );
        
        RegCloseKey( hkey );
    }
}




/******************************Public*Routine******************************\
* SetupTrackbar
*
* Setup a common control trackbar
\**************************************************************************/
void
ss_SetupTrackbar( HWND hDlg, int item, int lo, int hi, int lineSize, 
                  int pageSize, int pos )
{
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETRANGE, 
        (WPARAM) TRUE, 
        (LPARAM) MAKELONG( lo, hi )
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETPOS, 
        (WPARAM) TRUE, 
        (LPARAM) pos
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETPAGESIZE, 
        (WPARAM) 0,
        (LPARAM) pageSize 
    );
    SendDlgItemMessage( 
        hDlg, 
        item,
        TBM_SETLINESIZE, 
        (WPARAM) 0,
        (LPARAM) lineSize
    );
}




/******************************Public*Routine******************************\
* GetTrackbarPos
*
* Get the current position of a common control trackbar
\**************************************************************************/
int
ss_GetTrackbarPos( HWND hDlg, int item )
{
    return 
       (int)SendDlgItemMessage( 
            hDlg, 
            item,
            TBM_GETPOS, 
            0,
            0
        );
}

/******************************Public*Routine******************************\
* setupDialogControls
*
* Setup the dialog controls initially.
*
\**************************************************************************/

static void
setupDialogControls(HWND hDlg)
{
    int pos;

    InitCommonControls();

    if (fTesselFact <= 1.0f)
        pos = (int)(fTesselFact * 100.0f);
    else
        pos = 100 + (int) ((fTesselFact - 1.0f) * 100.0f);

    ss_SetupTrackbar( hDlg, DLG_SETUP_TESSEL, 0, 200, 1, 10, pos );

    ss_SetupTrackbar( hDlg, DLG_SETUP_SIZE, 0, 100, 1, 10, uSize );

    updateDialogControls( hDlg );
}

/******************************Public*Routine******************************\
* updateDialogControls
*
* Update the dialog controls based on the current global state.
*
\**************************************************************************/

static void
updateDialogControls(HWND hDlg)
{
    CheckDlgButton(hDlg, DLG_SETUP_SMOOTH, bSmoothShading);
    CheckDlgButton(hDlg, DLG_SETUP_CYCLE, bColorCycle);

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_SMOOTH),
                 gflConfigOpt[Type] & OPT_SMOOTH_SHADE );
    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_CYCLE),
                 gflConfigOpt[Type] & OPT_COLOR_CYCLE );

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_TESSEL),
                 gflConfigOpt[Type] & OPT_TESSEL);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS),
                 gflConfigOpt[Type] & OPT_TESSEL);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS_MIN),
                 gflConfigOpt[Type] & OPT_TESSEL);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS_MAX),
                 gflConfigOpt[Type] & OPT_TESSEL);

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_SIZE),
                 gflConfigOpt[Type] & OPT_SIZE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE),
                 gflConfigOpt[Type] & OPT_SIZE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE_MIN),
                 gflConfigOpt[Type] & OPT_SIZE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE_MAX),
                 gflConfigOpt[Type] & OPT_SIZE);

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_TEXTURE),
                 gflConfigOpt[Type] & OPT_TEXTURE);
}

/******************************Public*Routine******************************\
*
* ScreenSaverConfigureDialog
*
* Standard screensaver hook
*
* History:
*  Wed Jul 19 14:56:41 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/
INT_PTR CALLBACK CFlyingObjectsScreensaver::ScreenSaverConfigureDialog(HWND hDlg, UINT message,
                                                                       WPARAM wParam, LPARAM lParam)
{
    int wTmp;
    TCHAR szString[GEN_STRING_SIZE];

    switch (message) {
        case WM_INITDIALOG:
            g_pMyFlyingObjectsScreensaver->ReadSettings();

            setupDialogControls(hDlg);

            for (wTmp = 0; wTmp <= MAX_TYPE; wTmp++) {
                LoadString(NULL, idsStyles[wTmp], szString, GEN_STRING_SIZE);
                SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_ADDSTRING, 0,
                                   (LPARAM) szString);
            }
            SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_SETCURSEL, Type, 0);

            return TRUE;


        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case DLG_SETUP_TYPES:
                    switch (HIWORD(wParam))
                    {
                        case CBN_EDITCHANGE:
                        case CBN_SELCHANGE:
                            Type = (int)SendDlgItemMessage(hDlg, DLG_SETUP_TYPES,
                                                           CB_GETCURSEL, 0, 0);
                            updateDialogControls(hDlg);
                            break;
                        default:
                            break;
                    }
                    return FALSE;

                case DLG_SETUP_TEXTURE:
                    ss_SelectTextureFile( hDlg, &gTexFile );
                    break;

                case DLG_SETUP_MONITORSETTINGS:
                    g_pMyFlyingObjectsScreensaver->DoScreenSettingsDialog( hDlg );
                    break;

                case IDOK:
                    g_pMyFlyingObjectsScreensaver->WriteSettings( hDlg );
                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case DLG_SETUP_SMOOTH:
                case DLG_SETUP_CYCLE:
                default:
                    break;
            }
            return TRUE;
            break;

        default:
            return 0;
    }
    return 0;
}





//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
{
    HRESULT hr;
    CFlyingObjectsScreensaver flyingobjectsSS;

    if( FAILED( hr = flyingobjectsSS.Create( hInst ) ) )
    {
        flyingobjectsSS.DisplayErrorMsg( hr );
        return 0;
    }

    return flyingobjectsSS.Run();
}




//-----------------------------------------------------------------------------
// Name: CFlyingObjectsScreensaver()
// Desc: Constructor
//-----------------------------------------------------------------------------
CFlyingObjectsScreensaver::CFlyingObjectsScreensaver( )
{
    g_pMyFlyingObjectsScreensaver = this;
    g_pFloatRect = &m_floatrect;

    ZeroMemory( m_DeviceObjectsArray, sizeof(m_DeviceObjectsArray) );
    m_pDeviceObjects = NULL;

    LoadString( NULL, IDS_DESCRIPTION, m_strWindowTitle, 200 );
    m_bUseDepthBuffer = TRUE;

    lstrcpy( m_strRegPath, TEXT("Software\\Microsoft\\Screensavers\\Flying Objects") );

    m_floatrect.xSize = 0.0f;
    InitCommonControls();

    bSmoothShading = FALSE;
    bColorCycle = FALSE;
    UpdateFlags = (bColorCycle << 1);
    Type = 0;
    fTesselFact = 2.0f;
    uSize = 50;
    ss_GetDefaultBmpFile( gTexFile.szPathName );
    gTexFile.nOffset = 0;

    ss_LoadTextureResourceStrings();

    srand((UINT)time(NULL)); // seed random number generator
}




//-----------------------------------------------------------------------------
// Name: RegisterSoftwareDevice()
// Desc: This can register the D3D8RGBRasterizer or any other
//       pluggable software rasterizer.
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::RegisterSoftwareDevice()
{ 
    m_pD3D->RegisterSoftwareDevice( D3D8RGBRasterizer );

    return S_OK; 
}


//-----------------------------------------------------------------------------
// Name: SetMaterialColor()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::SetMaterialColor(FLOAT* pfColors)
{
    D3DMATERIAL8 mtrl;
    ZeroMemory( &mtrl, sizeof(mtrl) );
    mtrl.Diffuse.r = mtrl.Ambient.r = pfColors[0];
    mtrl.Diffuse.g = mtrl.Ambient.g = pfColors[1];
    mtrl.Diffuse.b = mtrl.Ambient.b = pfColors[2];
    mtrl.Diffuse.a = mtrl.Ambient.a = pfColors[3];
    mtrl.Specular.r = 1.0f;
    mtrl.Specular.g = 1.0f;
    mtrl.Specular.b = 1.0f;
    mtrl.Specular.a = 1.0f;
    mtrl.Power = 30.0f;

    return m_pd3dDevice->SetMaterial(&mtrl);
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::FrameMove()
{
    // update floatrect
    RECT rcBounceBounds;

    if( m_floatrect.xSize == 0.0f )
    {
        // Initialize floatrect
        RECT rcBounds;
        DWORD dwParentWidth;
        DWORD dwParentHeight;

        rcBounds = m_rcRenderTotal;

        dwParentWidth = rcBounds.right - rcBounds.left;
        dwParentHeight = rcBounds.bottom - rcBounds.top;

        FLOAT sizeFact;
        FLOAT sizeScale;
        DWORD size;

        sizeScale = (FLOAT)uSize / 150.0f;

    //    sizeFact = 0.25f + (0.5f * sizeScale);     // range 25-75%
    //    size = (DWORD) (sizeFact * ( ((FLOAT)(dwParentWidth + dwParentHeight)) / 2.0f ));

//        sizeFact = 0.25f + (0.75f * sizeScale);     // range 25-100%
        // Note: there are bouncing problems when size is 100% (gbBounce is always 
        // true) -- things "jitter" too much.  So limit size to 95% for this screensaver.
        sizeFact = 0.25f + (0.70f * sizeScale);     // range 25-95%
        size = (DWORD) (sizeFact * ( dwParentWidth > dwParentHeight ? dwParentHeight : dwParentWidth ) );

        if( size > dwParentWidth )
            size = dwParentWidth;
        if( size > dwParentHeight )
            size = dwParentHeight;

        // Start floatrect centered on first RenderUnit's screen
        if( !m_bWindowed )
        {
            INT iMonitor = m_RenderUnits[0].iMonitor;
            rcBounds = m_Monitors[iMonitor].rcScreen;
        }
        m_floatrect.xMin = rcBounds.left + ((rcBounds.right - rcBounds.left) - size) / 2.0f;
        m_floatrect.yMin = rcBounds.top + ((rcBounds.bottom - rcBounds.top) - size) / 2.0f;
        m_floatrect.xOrigin = m_floatrect.xMin;
        m_floatrect.yOrigin = m_floatrect.yMin;
        m_floatrect.xSize = (FLOAT)size;
        m_floatrect.ySize = (FLOAT)size;

        m_floatrect.xVel = 0.01f * (FLOAT) size;
        if( rand() % 2 == 0 )
            m_floatrect.xVel = -m_floatrect.xVel;

        m_floatrect.yVel = 0.01f * (FLOAT) size;
        if( rand() % 2 == 0 )
            m_floatrect.yVel = -m_floatrect.yVel;

        m_floatrect.xVelMax = m_floatrect.xVel;
        m_floatrect.yVelMax = m_floatrect.yVel;
    }

    rcBounceBounds = m_rcRenderTotal;

    FLOAT xMinOld = m_floatrect.xMin;
    FLOAT yMinOld = m_floatrect.yMin;

    if( g_bMoveToOrigin )
    {
        if( m_floatrect.xVel < 0  && m_floatrect.xMin < m_floatrect.xOrigin ||
            m_floatrect.xVel > 0 && m_floatrect.xMin > m_floatrect.xOrigin )
        {
            m_floatrect.xVel = -m_floatrect.xVel;
        }
        if( m_floatrect.yVel < 0  && m_floatrect.yMin < m_floatrect.yOrigin ||
            m_floatrect.yVel > 0 && m_floatrect.yMin > m_floatrect.yOrigin )
        {
            m_floatrect.yVel = -m_floatrect.yVel;
        }
        m_floatrect.xMin += m_floatrect.xVel * 20.0f * m_fElapsedTime;
        m_floatrect.yMin += m_floatrect.yVel * 20.0f * m_fElapsedTime;

        if( m_floatrect.xVel < 0  && m_floatrect.xMin < m_floatrect.xOrigin ||
            m_floatrect.xVel > 0 && m_floatrect.xMin > m_floatrect.xOrigin )
        {
            m_floatrect.xMin = m_floatrect.xOrigin;
            m_floatrect.xVel = 0.0f;
        }
        if( m_floatrect.yVel < 0  && m_floatrect.yMin < m_floatrect.yOrigin ||
            m_floatrect.yVel > 0 && m_floatrect.yMin > m_floatrect.yOrigin )
        {
            m_floatrect.yMin = m_floatrect.yOrigin;
            m_floatrect.yVel = 0.0f;
        }
        if( m_floatrect.xMin == m_floatrect.xOrigin &&
            m_floatrect.yMin == m_floatrect.yOrigin )
        {
            g_bAtOrigin = TRUE;
        }
    }
    else
    {
        g_bAtOrigin = FALSE;
        if( m_floatrect.xVel == 0.0f )
        {
            m_floatrect.xVel = m_floatrect.xVelMax;
            if( rand() % 2 == 0 )
                m_floatrect.xVel = -m_floatrect.xVel;
        }
        if( m_floatrect.yVel == 0.0f )
        {
            m_floatrect.yVel = m_floatrect.yVelMax;
            if( rand() % 2 == 0 )
                m_floatrect.yVel = -m_floatrect.yVel;
        }

        m_floatrect.xMin += m_floatrect.xVel * 20.0f * m_fElapsedTime;
        m_floatrect.yMin += m_floatrect.yVel * 20.0f * m_fElapsedTime;
        if( m_floatrect.xVel < 0 && m_floatrect.xMin < rcBounceBounds.left || 
            m_floatrect.xVel > 0 && (m_floatrect.xMin + m_floatrect.xSize) > rcBounceBounds.right )
        {
            gbBounce = TRUE;
            m_floatrect.xMin = xMinOld; // undo last move
            m_floatrect.xVel = -m_floatrect.xVel; // change direction
        }
        if( m_floatrect.yVel < 0 && m_floatrect.yMin < rcBounceBounds.top || 
            m_floatrect.yVel > 0 && (m_floatrect.yMin + m_floatrect.ySize) > rcBounceBounds.bottom )
        {
            gbBounce = TRUE;
            m_floatrect.yMin = yMinOld; // undo last move
            m_floatrect.yVel = -m_floatrect.yVel; // change direction
        }
    }

    return S_OK;
}


VOID SetProjectionMatrixInfo( BOOL bOrtho, FLOAT fWidth, 
                              FLOAT fHeight, FLOAT fNear, FLOAT fFar )
{
    g_pMyFlyingObjectsScreensaver->m_bOrtho = bOrtho;
    g_pMyFlyingObjectsScreensaver->m_fWidth = fWidth;
    g_pMyFlyingObjectsScreensaver->m_fHeight = fHeight;
    g_pMyFlyingObjectsScreensaver->m_fNear = fNear;
    g_pMyFlyingObjectsScreensaver->m_fFar = fFar;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::Render()
{
    D3DVIEWPORT8 vp;

    // First, clear the entire back buffer to the background color
    vp.X = 0;
    vp.Y = 0;
    vp.Width = m_rcRenderCurDevice.right - m_rcRenderCurDevice.left;
    vp.Height = m_rcRenderCurDevice.bottom - m_rcRenderCurDevice.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff000000, 1.0f, 0L );

    // Now determine what part of the floatrect, if any, intersects the current screen
    RECT rcFloatThisScreen;
    RECT rcFloatThisScreenClipped;

    rcFloatThisScreen.left = (INT)m_floatrect.xMin;
    rcFloatThisScreen.top = (INT)m_floatrect.yMin;
    rcFloatThisScreen.right = rcFloatThisScreen.left + (INT)m_floatrect.xSize;
    rcFloatThisScreen.bottom = rcFloatThisScreen.top + (INT)m_floatrect.ySize;

    if( !IntersectRect(&rcFloatThisScreenClipped, &rcFloatThisScreen, &m_rcRenderCurDevice) )
    {
        return S_OK; // no intersection, so nothing further to render on this screen
    }

    // Convert rcFloatThisScreen from screen to window coordinates
    OffsetRect(&rcFloatThisScreen, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);
    OffsetRect(&rcFloatThisScreenClipped, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);

    // Now set up the viewport to render to the clipped rect
    vp.X = rcFloatThisScreenClipped.left;
    vp.Y = rcFloatThisScreenClipped.top;
    vp.Width = rcFloatThisScreenClipped.right - rcFloatThisScreenClipped.left;
    vp.Height = rcFloatThisScreenClipped.bottom - rcFloatThisScreenClipped.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );
//    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff000080, 1.0f, 0L );

    // Now set up the projection matrix to only render the onscreen part of the
    // rect to the viewport
    D3DXMATRIX matProj;
    FLOAT l,r,b,t;
    l = -m_fWidth / 2;
    r =  m_fWidth / 2;
    b = -m_fHeight / 2;
    t =  m_fHeight / 2;
    FLOAT cxUnclipped = (rcFloatThisScreen.right + rcFloatThisScreen.left) / 2.0f;
    FLOAT cyUnclipped = (rcFloatThisScreen.bottom + rcFloatThisScreen.top) / 2.0f;
    l *= (rcFloatThisScreenClipped.left - cxUnclipped) / (rcFloatThisScreen.left - cxUnclipped);
    r *= (rcFloatThisScreenClipped.right - cxUnclipped) / (rcFloatThisScreen.right - cxUnclipped);
    t *= (rcFloatThisScreenClipped.top - cyUnclipped) / (rcFloatThisScreen.top - cyUnclipped);
    b *= (rcFloatThisScreenClipped.bottom - cyUnclipped) / (rcFloatThisScreen.bottom - cyUnclipped);
    if( m_bOrtho )
    {
        D3DXMatrixOrthoOffCenterLH( &matProj, l, r, b, t, m_fNear, m_fFar );
    }
    else
    {
        D3DXMatrixPerspectiveOffCenterLH( &matProj, l, r, b, t, m_fNear, m_fFar );
    }
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION , &matProj );

    // Make elapsed time be zero unless time has really advanced since
    // the last call, so things don't move faster in multimon situations.
    // The right way to do this would be to separate the animation code from
    // the rendering code.
    FLOAT fElapsedTime;
    static FLOAT s_fTimeLast = 0.0f;
    if( m_fTime == s_fTimeLast )
        fElapsedTime = 0.0f;
    else
        fElapsedTime = m_fElapsedTime;
    s_fTimeLast = m_fTime;

    // Begin the scene 
    if( SUCCEEDED( m_pd3dDevice->BeginScene() ) )
    {
        ::m_pd3dDevice = m_pd3dDevice;
        ::m_pIB = m_pDeviceObjects->m_pIB;
        ::m_pVB = m_pDeviceObjects->m_pVB;
        ::m_pVB2 = m_pDeviceObjects->m_pVB2;
    
        updateSceneFunc( UpdateFlags, fElapsedTime );

        // End the scene.
        m_pd3dDevice->EndScene();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetDevice()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlyingObjectsScreensaver::SetDevice( UINT iDevice )
{
    m_pDeviceObjects = &m_DeviceObjectsArray[iDevice];
    g_pDeviceObjects = m_pDeviceObjects;

    INT iMonitor = m_RenderUnits[iDevice].iMonitor;
    g_xScreenOrigin = m_Monitors[iMonitor].rcScreen.left;
    g_yScreenOrigin = m_Monitors[iMonitor].rcScreen.top;
    g_iDevice = iDevice;
}




//-----------------------------------------------------------------------------
// Name: LoadTextureFromResource()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT LoadTextureFromResource( LPDIRECT3DDEVICE8 pd3dDevice, 
    TCHAR* strRes, TCHAR* strResType, LPDIRECT3DTEXTURE8* ppTex )
{
    HRESULT hr;
    HMODULE hModule = NULL;
    HRSRC rsrc;
    HGLOBAL hgData;
    LPVOID pvData;
    DWORD cbData;

    rsrc = FindResource( hModule, strRes, strResType );
    if( rsrc != NULL )
    {
        cbData = SizeofResource( hModule, rsrc );
        if( cbData > 0 )
        {
            hgData = LoadResource( hModule, rsrc );
            if( hgData != NULL )
            {
                pvData = LockResource( hgData );
                if( pvData != NULL )
                {
                    if( FAILED( hr = D3DXCreateTextureFromFileInMemory( pd3dDevice, 
                        pvData, cbData, ppTex ) ) )
                    {
                        return hr;
                    }
                }
            }
        }
    }
    
    if( *ppTex == NULL)
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::RestoreDeviceObjects()
{
    if( m_pd3dDevice == NULL )
        return S_OK;

    ::m_pd3dDevice = m_pd3dDevice;
    

/*
    D3DLIGHT8 light;
    D3DUtil_InitLight( light, D3DLIGHT_POINT, 2.0, 2.0, 10.0 );
    light.Specular.r = 1.0f;
    light.Specular.g = 1.0f;
    light.Specular.b = 1.0f;
    light.Specular.a = 1.0f;
    light.Attenuation0 = 1.0f;
    m_pd3dDevice->SetLight(0, &light);
    m_pd3dDevice->LightEnable(0, TRUE);
*/    
    
    // Set some basic renderstates
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, D3DCOLOR(0x20202020) );
/*    if( config.two_sided == GL_FRONT_AND_BACK )
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    else
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CCW );
*/    
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLOROP , D3DTOP_SELECTARG1 );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG1 , D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG2 , D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ALPHAOP , D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_COLOROP , D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_ALPHAOP , D3DTOP_DISABLE );


    D3DMATERIAL8 mtrl;
    ZeroMemory( &mtrl, sizeof(mtrl) );
    mtrl.Diffuse.r = mtrl.Ambient.r = 1.0f;
    mtrl.Diffuse.g = mtrl.Ambient.g = 1.0f;
    mtrl.Diffuse.b = mtrl.Ambient.b = 1.0f;
    mtrl.Diffuse.a = mtrl.Ambient.a = 1.0f;

    m_pd3dDevice->SetMaterial(&mtrl);
    
    if( !_3dfo_Init(NULL) )
        return E_FAIL;

    if( Type == 6 )
    {
        if( FAILED( D3DXCreateTextureFromFile( m_pd3dDevice, gTexFile.szPathName, 
            &m_pDeviceObjects->m_pTexture ) ) )
        {
            LoadTextureFromResource( m_pd3dDevice, MAKEINTRESOURCE(IDB_DEFTEX), TEXT("JPG"),
                &m_pDeviceObjects->m_pTexture );
        }
    }
    else if( Type == 0 )
    {
        LoadTextureFromResource( m_pd3dDevice, MAKEINTRESOURCE(IDR_FLATFLAG), TEXT("DDS"),
            &m_pDeviceObjects->m_pTexture );
        LoadTextureFromResource( m_pd3dDevice, MAKEINTRESOURCE(IDR_WINLOGO), TEXT("PNG"),
            &m_pDeviceObjects->m_pTexture2 );
    }

    m_pd3dDevice->SetTexture( 0, m_pDeviceObjects->m_pTexture );
    
    if( FAILED( m_pd3dDevice->CreateIndexBuffer( MAX_INDICES * sizeof(WORD),
        D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, &m_pDeviceObjects->m_pIB ) ) )
    {
        return E_FAIL;
    }

    if( FAILED( m_pd3dDevice->CreateVertexBuffer( MAX_VERTICES * sizeof(MYVERTEX),
        D3DUSAGE_WRITEONLY, D3DFVF_MYVERTEX, D3DPOOL_MANAGED, &m_pDeviceObjects->m_pVB ) ) )
    {
        return E_FAIL;
    }

    if( FAILED( m_pd3dDevice->CreateVertexBuffer( MAX_VERTICES * sizeof(MYVERTEX2),
        D3DUSAGE_WRITEONLY, D3DFVF_MYVERTEX2, D3DPOOL_MANAGED, &m_pDeviceObjects->m_pVB2 ) ) )
    {
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::InvalidateDeviceObjects()
{
    SAFE_RELEASE( m_pDeviceObjects->m_pTexture );
    SAFE_RELEASE( m_pDeviceObjects->m_pTexture2 );
    SAFE_RELEASE( m_pDeviceObjects->m_pIB );
    SAFE_RELEASE( m_pDeviceObjects->m_pVB );
    SAFE_RELEASE( m_pDeviceObjects->m_pVB2 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlyingObjectsScreensaver::ReadSettings()
{
    int    options;
    int    optMask = 1;
    int    tessel=0;

    // Read OpenGL settings first, so OS upgrade cases work
    ss_ReadSettings();

    HKEY hkey;

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        options = bSmoothShading | bColorCycle<<1;
        DXUtil_ReadIntRegKey( hkey, TEXT("Options"), (DWORD*)&options, options );
        if (options >= 0)
        {
            bSmoothShading = ((options & optMask) != 0);
            optMask <<= 1;
            bColorCycle = ((options & optMask) != 0);
            UpdateFlags = (bColorCycle << 1);
        }

        DXUtil_ReadIntRegKey( hkey, TEXT("Type"), (DWORD*)&Type, Type );

        // Sanity check Type.  Don't want to index into function arrays
        // with a bad index!
        Type = (int)min(Type, MAX_TYPE);

        // Set flag so that updateStripScene will do two strips instead
        // of one.

        if (Type == 3)
            UpdateFlags |= 0x4;

        tessel = (int) (fTesselFact * 100);
        DXUtil_ReadIntRegKey( hkey, TEXT("Tesselation"), (DWORD*)&tessel, tessel );
        SS_CLAMP_TO_RANGE2( tessel, 0, 200 );

        if (tessel <= 100)
            fTesselFact  = (float)tessel / 100.0f;
        else
            fTesselFact = 1.0f + (((float)tessel - 100.0f) / 100.0f);

        DXUtil_ReadIntRegKey( hkey, TEXT("Size"), (DWORD*)&uSize, uSize );
        if (uSize > 100)
            uSize = 100;
        
        // Static size for new winlogo
        if (Type == 0)
        {
            uSize = 75;
            bSmoothShading = TRUE;
        }

        // SS_CLAMP_TO_RANGE2( uSize, 0, 100 );  /* can't be less than zero since it is a UINT */

        // Is there a texture specified in the registry that overrides the
        // default?

        DXUtil_ReadStringRegKey( hkey, TEXT("Texture"), (TCHAR*)&gTexFile.szPathName, 
            MAX_PATH, gTexFile.szPathName );

        DXUtil_ReadIntRegKey( hkey, TEXT("TextureFileOffset"), (DWORD*)&gTexFile.nOffset, gTexFile.nOffset );

        ReadScreenSettings( hkey );

        RegCloseKey( hkey );
    }
}




//-----------------------------------------------------------------------------
// Name: ss_ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlyingObjectsScreensaver::ss_ReadSettings()
{
    int    options;
    int    optMask = 1;
    TCHAR  szDefaultBitmap[MAX_PATH];
    int    tessel=0;

    if( ss_RegistrySetup( IDS_SAVERNAME, IDS_INIFILE ) )
    {
        options = ss_GetRegistryInt( IDS_OPTIONS, -1 );
        if (options >= 0)
        {
            bSmoothShading = ((options & optMask) != 0);
            optMask <<= 1;
            bColorCycle = ((options & optMask) != 0);
            UpdateFlags = (bColorCycle << 1);
        }

        Type = ss_GetRegistryInt( IDS_OBJTYPE, 0 );

        // Sanity check Type.  Don't want to index into function arrays
        // with a bad index!
        Type = (int)min(Type, MAX_TYPE);

        // Set flag so that updateStripScene will do two strips instead
        // of one.

        if (Type == 3)
            UpdateFlags |= 0x4;

        tessel = ss_GetRegistryInt( IDS_TESSELATION, 100 );
        SS_CLAMP_TO_RANGE2( tessel, 0, 200 );

        if (tessel <= 100)
            fTesselFact  = (float)tessel / 100.0f;
        else
            fTesselFact = 1.0f + (((float)tessel - 100.0f) / 100.0f);

        uSize = ss_GetRegistryInt( IDS_SIZE, 50 );
        if (uSize > 100)
            uSize = 100;
        // SS_CLAMP_TO_RANGE2( uSize, 0, 100 );  /* can't be less than zero since it is a UINT */

        // Determine the default .bmp file

        ss_GetDefaultBmpFile( szDefaultBitmap );

        // Is there a texture specified in the registry that overrides the
        // default?


        ss_GetRegistryString( IDS_TEXTURE, szDefaultBitmap, gTexFile.szPathName,
                              MAX_PATH);

        gTexFile.nOffset = ss_GetRegistryInt( IDS_TEXTURE_FILE_OFFSET, 0 );
    }
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CFlyingObjectsScreensaver::ss_RegistrySetup( int section, int file )
{
    if( LoadString(m_hInstance, section, g_szSectName, BUF_SIZE) &&
        LoadString(m_hInstance, file, g_szFname, BUF_SIZE) ) 
    {
        TCHAR pBuffer[100];
        DWORD dwRealSize = GetPrivateProfileSection( g_szSectName, pBuffer, 100, g_szFname );
        if( dwRealSize > 0 )
            return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
int CFlyingObjectsScreensaver::ss_GetRegistryInt( int name, int iDefault )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        return GetPrivateProfileInt(g_szSectName, szItemName, iDefault, g_szFname);

    return 0;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlyingObjectsScreensaver::ss_GetRegistryString( int name, LPTSTR lpDefault, 
                                                         LPTSTR lpDest, int bufSize )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        GetPrivateProfileString(g_szSectName, szItemName, lpDefault, lpDest,
                                bufSize, g_szFname);

    return;
}




//-----------------------------------------------------------------------------
// Name: DoConfig()
// Desc: 
//-----------------------------------------------------------------------------
VOID CFlyingObjectsScreensaver::DoConfig()
{
    if( IDOK == DialogBox( NULL, MAKEINTRESOURCE( DLG_SCRNSAVECONFIGURE ),
        m_hWndParent, ScreenSaverConfigureDialog ) )
    {
    }
}




//-----------------------------------------------------------------------------
// Name: ConfirmDevice()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CFlyingObjectsScreensaver::ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, 
                                  D3DFORMAT fmtBackBuffer)
{
    if( dwBehavior & D3DCREATE_PUREDEVICE )
        return E_FAIL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\gendrop.cpp ===
/******************************Module*Header*******************************\
* Module Name: gendrop.c
*
* The Splash style of the 3D Flying Objects screen saver.
*
* Simulation of a drop of water falling into a pool of water.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

#define FLOAT_SMALL (1e-6)

#define DROPPREC   10

// Remember from pre-calc:
//      x = r cos th
//      y = r sin th
// to convert from polar to rect, and that
//      x = x' cos th - y' sin th
//      y = x' sin th + y' cos th
// to rotate axes.
//
// Also, note that the equation for a lemniscate is:
//      r = sqrt(sin 2*th)
//

static POINT3D *circle;
static POINT3D *drop;
static POINT3D *curves;
static MESH waterMesh;
static MESH waterInmesh;
static MESH waterOutmesh;
static MESH waterBorderMesh;
static MESH *drops;
static int iPrec;
static float fRadiusFact = 0.35f;

static FLOAT light0Pos[] = {100.0f, 100.0f, 100.0f, 0.0f};

void genCurves()
{
    // iPrec is already protected from getting too low in InitDropScene,
    // but this will make "prefix" happy:
    if( iPrec <= 1 )
        return;

    int i;
    double angle;
    double step = -PI / (float)(iPrec - 1);
    double start = PI / 2.0;
    double rotSin = sin(PI / 4.0);
    double rotCos = cos(PI / 4.0);
    double aFract = 0.0;
    double bFract = 1.0;
    double fractInc = 1.0 / (double)(iPrec - 1);
    POINT3D *pt = curves;

    for (i = 0, angle = start; i < iPrec; i++, angle += step) {
        circle[i].x = (float) (0.5 * cos(angle));
        circle[i].y = (float) (0.5 * sin(angle));
    }

    step = (-PI / 4.0) / (float)(iPrec - 1);
    start = PI / 4.0;

    for (i = 0, angle = start; i < iPrec; i++, angle += step) {
        double x, y, r;
        double xrot, yrot;
        double sinVal;

        sinVal = sin(2.0 * angle);
        if (sinVal < 0.0)
            sinVal = -sinVal;

        r = 1.5 * sqrt(sinVal);
        x = r * cos(angle);
        y = r * sin(angle);

        xrot = x * rotCos - y * rotSin;
        yrot = x * rotSin + y * rotCos - 1.0;

        drop[i].x = (float) xrot;
        drop[i].y = (float) yrot;
    }


    for (i = 0; i < DROPPREC; i++) {
        int j;

        for (j = 0; j < iPrec; j++, pt++) {
            pt->x = (float) (aFract * circle[j].x +
                             bFract * drop[j].x);

            pt->y = (float) (aFract * circle[j].y +
                             bFract * drop[j].y);

            pt->z = 0.0f;
        }
        aFract += fractInc;
        bFract -= fractInc;
    }
}

#define NORMS(x, y) waterMesh.norms[((x) * iPrec) + y]
#define BNORMS(x, y) waterBorderMesh.norms[((x) * iPrec) + y]
#define INGRID(x, y)  waterInmesh.pts[((x) * iPrec) + y]
#define OUTGRID(x, y)  waterOutmesh.pts[((x) * iPrec) + y]
#define GRID(x, y)  waterMesh.pts[((x) * iPrec) + y]
#define BGRID(x, y)  waterBorderMesh.pts[((x) * iPrec) + y]

void genWater(double freq, double damp, double mag, double w, double minr)
{
    int i;
    int j;
    double r;
    double theta;
    double thetaInc = (2.0 * PI) / (float)iPrec;
    double posInc = 1.0 / (float)iPrec;
    int facecount;
    double xCenter = 0.0;
    double zCenter = 0.0;
    POINT3D norm;
    static BOOL first = TRUE;

    if (first) {
        for (i = 0, r = 0.0; i < iPrec; i++, r += posInc) {
            for (j = 0, theta = 0.0; j < iPrec; j++, theta += thetaInc) {
                float x, z;
                float dx, dz;
                float rr;

                x = (float) cos(theta);
                z = (float) sin(theta);

                dx = x - (float) xCenter;
                dz = z - (float) zCenter;

                rr = (float) sqrt((dx * dx) + (dz * dz));
                dx /= rr;
                dz /= rr;
                dx *= i / (float)(iPrec - 1);
                dz *= i / (float)(iPrec - 1);
                GRID(i, j).x = dx + (float) xCenter;
                GRID(i, j).z = dz + (float) zCenter;

                INGRID(i, j).y = 0.0f;
                OUTGRID(i, j).y = 0.0f;
            }
        }
    }


    for (i = (iPrec - 1), r = 1.0; i >= 0; i--, r -= posInc) {
        float val;

        if (i == 0) {
            if (minr != 0.0)
                val = (float) (-mag * cos(w + (r * freq)) * exp((-damp * r)/2.0));
            else
                val =  INGRID(0, 0).y * 0.95f;
        } else
            val = OUTGRID(i - 1, 0).y * 0.95f;

        for (j = 0; j < iPrec; j++)
            OUTGRID(i, j).y = val;
    }


    for (i = 0, r = 0.0; i < iPrec; i++, r += posInc) {
        for (j = 0; j < iPrec; j++) {
            if (i == iPrec-1)
                INGRID(i, j).y = -OUTGRID(i, j).y;
            else
                INGRID(i, j).y = INGRID(i + 1, j).y * 0.95f;
        }
    }


    waterMesh.numFaces = 0;
    waterBorderMesh.numFaces = 0;

    for (i = 0; i < iPrec; i++) {
        for (j = 0; j < iPrec; j++) {
            NORMS(i, j).x = 0.0f;
            NORMS(i, j).y = 0.0f;
            NORMS(i, j).z = 0.0f;
        }
    }

    for (i = 0, r = 0.0; i < iPrec; i++, r += posInc) {
        for (j = 0, theta = 0.0; j < iPrec; j++, theta += thetaInc) {
            GRID(i, j).y = OUTGRID(i, j).y + INGRID(i, j).y;


            if (i == (iPrec - 1)) {
                GRID(i, j).y = 0.0f;

                BGRID(0, j).x = GRID(i, j).x;
                BGRID(0, j).z = GRID(i, j).z;
                BGRID(0, j).y = GRID(i, j).y;

                BGRID(1, j).x = GRID(i, j).x;
                BGRID(1, j).z = GRID(i, j).z;
                BGRID(1, j).y = -0.5f;
            }
        }
    }

    for (i = 0; i < 2; i++) {
        for (j = 0; j < iPrec; j++) {
            BNORMS(i, j).x = 0.0f;
            BNORMS(i, j).y = 0.0f;
            BNORMS(i, j).z = 0.0f;
        }
    }

    for (facecount = 0, i = 0; i < (iPrec - 1); i++) {
        for (j = 0; j < iPrec; j++) {
            int k, l;

            k = i + 1;

            if (j == (iPrec - 1))
                l = 0;
            else
                l = j + 1;

            ss_calcNorm(&norm, &GRID(k, j), &GRID(i, j), &GRID(i, l));

            if (norm.x > -FLOAT_SMALL && norm.x < FLOAT_SMALL &&
                norm.y > -FLOAT_SMALL && norm.y < FLOAT_SMALL &&
                norm.z > -FLOAT_SMALL && norm.z < FLOAT_SMALL)
                ss_calcNorm(&norm, &GRID(i, l), &GRID(k, l), &GRID(k, j));


            waterMesh.faces[facecount].material = 0;
            waterMesh.faces[facecount].norm = norm;

            NORMS(i, j).x += norm.x;
            NORMS(i, j).y += norm.y;
            NORMS(i, j).z += norm.z;

            NORMS(k, j).x += norm.x;
            NORMS(k, j).y += norm.y;
            NORMS(k, j).z += norm.z;

            NORMS(i, l).x += norm.x;
            NORMS(i, l).y += norm.y;
            NORMS(i, l).z += norm.z;

            NORMS(k, l).x += norm.x;
            NORMS(k, l).y += norm.y;
            NORMS(k, l).z += norm.z;

            waterMesh.faces[facecount].p[0] = (k * iPrec) + j;
            waterMesh.faces[facecount].p[1] = (i * iPrec) + j;
            waterMesh.faces[facecount].p[2] = (k * iPrec) + l;
            waterMesh.faces[facecount].p[3] = (i * iPrec) + l;
            waterMesh.numFaces++;
            facecount++;
        }
    }

    waterMesh.numPoints = iPrec * iPrec;

    for (facecount = 0, i = 0; i < 1; i++) {
        for (j = 0; j < iPrec; j++) {
            int k, l;

            k = i + 1;

            if (j == (iPrec - 1))
                l = 0;
            else
                l = j + 1;

            ss_calcNorm(&norm, &BGRID(k, j), &BGRID(i, j), &BGRID(i, l));

            waterBorderMesh.faces[facecount].material = 0;
            waterBorderMesh.faces[facecount].norm = norm;

// Setting SMOOTH_BORDER will render the border (the sides of the "pool")
// with smooth shading.  This effect is good at higher tesselations, but
// doesn't really look that good for low tesselations.
//
// A possible enhancement for later: use smooth shading if tesselation
// exceeds some threshold.  Should we just pick some arbitrary threshold?
// Make it a setup option?  Things look pretty good now, so don't bother?

#if SMOOTH_BORDER
            BNORMS(i, j).x += norm.x;
            BNORMS(i, j).y += norm.y;
            BNORMS(i, j).z += norm.z;

            if (i) {
                BNORMS(i-1, j).x += norm.x;
                BNORMS(i-1, j).y += norm.y;
                BNORMS(i-1, j).z += norm.z;
            }
            if (j) {
                BNORMS(i, j-1).x += norm.x;
                BNORMS(i, j-1).y += norm.y;
                BNORMS(i, j-1).z += norm.z;
            }

            BNORMS(k, j).x += norm.x;
            BNORMS(k, j).y += norm.y;
            BNORMS(k, j).z += norm.z;

            BNORMS(i, l).x += norm.x;
            BNORMS(i, l).y += norm.y;
            BNORMS(i, l).z += norm.z;
#else
            BNORMS(i, j) = norm;

            if (i)
                BNORMS(i-1, j) = norm;
            if (j)
                BNORMS(i, j-1) = norm;

            BNORMS(k, j) = norm;
            BNORMS(i, l) = norm;
#endif

            waterBorderMesh.faces[facecount].p[0] = (k * iPrec) + j;
            waterBorderMesh.faces[facecount].p[1] = (i * iPrec) + j;
            waterBorderMesh.faces[facecount].p[2] = (k * iPrec) + l;
            waterBorderMesh.faces[facecount].p[3] = (i * iPrec) + l;
            waterBorderMesh.numFaces++;
            facecount++;
        }
    }
    waterBorderMesh.numPoints = 2 * iPrec;

    ss_normalizeNorms(waterBorderMesh.norms, waterBorderMesh.numPoints);
    ss_normalizeNorms(waterMesh.norms, waterMesh.numPoints);

    first = FALSE;
}


BOOL initDropScene()
{
    int i;

    iPrec = (int)(fTesselFact * 10.5);
    if (iPrec < 4)
        iPrec = 4;

    if (fTesselFact > fRadiusFact)
        fRadiusFact = fTesselFact;

    circle = (POINT3D *)SaverAlloc(iPrec * sizeof(POINT3D));
    if( circle == NULL )
        return FALSE;

    drop = (POINT3D *)SaverAlloc(iPrec * sizeof(POINT3D));
    if( drop == NULL )
        return FALSE;

    curves = (POINT3D *)SaverAlloc(DROPPREC * iPrec * sizeof(POINT3D));
    if( curves == NULL )
        return FALSE;

    drops = (MESH *)SaverAlloc(DROPPREC * sizeof(MESH));
    if( drops == NULL )
        return FALSE;

/*
    D3DXMATRIX matProj;
    D3DXMatrixOrthoLH( &matProj, 3.0, 3.0, 0.0f, 3.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
*/
    SetProjectionMatrixInfo( TRUE, 3.0, 3.0, 0.0, 3.0 );

    D3DXMATRIX matView;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 1.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    if (!newMesh(&waterInmesh, iPrec * iPrec, iPrec * iPrec + iPrec) )
        return FALSE;
    if (!newMesh(&waterOutmesh, iPrec * iPrec, iPrec * iPrec + iPrec) )
        return FALSE;
    if (!newMesh(&waterMesh, iPrec * iPrec, iPrec * iPrec + iPrec) )
        return FALSE;
    if (!newMesh(&waterBorderMesh, iPrec, 2 * iPrec) )
        return FALSE;
    genCurves();

    for (i = 0; i < DROPPREC; i++)
        revolveSurface(&drops[i], &curves[i * iPrec], iPrec);
    return TRUE;
}

void delDropScene()
{
    int i;

    for (i = 0; i < DROPPREC; i++) {
        delMesh(&drops[i]);
    }

    SaverFree(circle);
    SaverFree(drop);
    SaverFree(curves);
    SaverFree(drops);
    
    delMesh(&waterMesh);
    delMesh(&waterInmesh);
    delMesh(&waterOutmesh);
    delMesh(&waterBorderMesh);
}


void updateDropScene(int flags, FLOAT fElapsedTime)
{
    static double zrot = 0.0;
    static double yrot = 0.0;
    static double myrot = 0.0;
    static double myrotInc = 0.1;
    static double zrotInc = 3.0;
    static double yrotInc = 1.5;
    static double ypos = 1.0;
    static int dropnum = 0;
    static double radius = 0.3;
    static double damp = 1.0;
    static double mag = 0.0;
    static double w = 1.0;
    static double freq = 1.0;
    static double dist;
    static double minr = 0.0;
    static FLOAT fH = 0.0f;
    static FLOAT fTimer = 0.0f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    if( fTimeFactor > 0.25f )
        fTimeFactor = 0.25f;
    RGBA color;
    D3DXMATRIX mat1, mat2, mat3, mat4, mat5, matFinal;

    zrot += zrotInc * fTimeFactor;
    if (zrot >= 45.0) {
        zrot = 45.0;
        zrotInc = -(2.0 + ((float)rand() / (float)RAND_MAX) * 3.0);
    } else if (zrot <= -45.0) {
        zrot = -45.0;
        zrotInc = 2.0 + ((float)rand() / (float)RAND_MAX) * 3.0;
    }

    yrot += yrotInc * fTimeFactor;
    if (yrot >= 10.0) {
        yrot = 10.0;
        yrotInc = -(1.0 + ((float)rand() / (float)RAND_MAX) * 2.0);
    } else if (zrot <= -10.0) {
        yrot = -10.0;
        yrotInc = 1.0 + ((float)rand() / (float)RAND_MAX) * 2.0;
    }

    if ((ypos + 0.5 < -radius) && (mag < 0.05)) {
        radius = (float)rand() / (6.0 * (float)RAND_MAX) + 0.1;
        ypos = 1.0;
        dropnum = 0;
    }

    dist = (ypos + 0.5);
    if ((dist > -radius / 2.0) && (dist < radius / 2.0)) {
        if (dist <= 0.0)
            dist = radius / 2.0;
        else
            dist = (radius / 2.0) - dist;
        freq = (0.25 * PI) / dist;
        if (freq < 0.2)
            freq = 0.2;

        minr = radius;

        damp = 20.0;
        mag = (0.35 / fRadiusFact) + 0.2 * dist;

        w = 0;
    } else {
        minr -= 0.05 * fTimeFactor;
        if (minr < 0.0)
            minr = 0.0;

        mag = mag * 0.95 * fTimeFactor;
        if (minr == 0.0) {
            w -= (PI / 6.0) * fTimeFactor;
            mag *= 0.75 * fTimeFactor;
        }
        if (damp > 0.0)
            damp -= 1.0 * fTimeFactor;
    }

    // Only call genWater about 10x per second
    fTimer += fElapsedTime;
    if( fTimer > 0.07f)
    {
        genWater(freq, damp, mag, w, minr);
        fTimer = 0.0f;
    }

    D3DXMatrixRotationZ(&mat1, D3DXToRadian((FLOAT)zrot));
    D3DXMatrixRotationX(&mat2, D3DXToRadian(30.0f));
    D3DXMatrixTranslation(&mat3, 0.0f, -0.5f, 0.0f);
    D3DXMatrixRotationY(&mat4, D3DXToRadian((FLOAT) (myrot * (180.0 / PI))));
    matFinal = mat4 * mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD , &matFinal );

    if (bColorCycle) {
        ss_HsvToRgb(fH, 1.0f, 1.0f, &color );

        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (FLOAT *) &color);
        fH += fTimeFactor;
        if( fH >= 360.0f )
            fH -= 360.0f;
    } else {
        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (FLOAT *) &Material[6].Diffuse);
    }

    RenderMesh3(&waterMesh, bSmoothShading);

    if (!bColorCycle)
    {
        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (FLOAT *) &Material[2].Diffuse);

    }
    RenderMesh3(&waterBorderMesh, FALSE);

    if (dist > -radius) {

        if (!bColorCycle)
        {
            myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                         (FLOAT *) &Material[6].Diffuse);
        }
        D3DXMatrixRotationZ(&mat1, D3DXToRadian((FLOAT)zrot));
        D3DXMatrixRotationX(&mat2, D3DXToRadian(30.0f));
        D3DXMatrixTranslation(&mat3, 0.0f, (FLOAT) ypos, 0.0f);
        D3DXMatrixScaling(&mat4, (FLOAT) radius, (FLOAT) radius, (FLOAT) radius);
        D3DXMatrixRotationX(&mat5, D3DXToRadian(180.0f));
        matFinal = mat5 * mat4 * mat3 * mat2 * mat1;
        m_pd3dDevice->SetTransform( D3DTS_WORLD , &matFinal );
        
        RenderMesh3( &drops[dropnum], bSmoothShading );
    }

    myrot += myrotInc * fTimeFactor;

    ypos -= 0.08 * fTimeFactor;
    dropnum = (int) ((DROPPREC - 1) - (ypos * (DROPPREC - 1)));
    if (dropnum > (DROPPREC - 1))
        dropnum = DROPPREC - 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\flyingobjects.h ===
//-----------------------------------------------------------------------------
// File: FlyingObjects.h
//
// Desc: 
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _FLYINGOBJECTS_H
#define _FLYINGOBJECTS_H

#include "resource.h"

#define PI 3.14159265358979323846f
// double version of PI
#define PI_D 3.14159265358979323846264338327950288419716939937510
#define ONE_OVER_PI (1.0f / PI)
#define ROOT_TWO 1.414213562373f

#define GEN_STRING_SIZE 64

typedef struct _point2d {
    FLOAT x;
    FLOAT y;
} POINT2D;

typedef struct _ipoint2d {
    int x;
    int y;
} IPOINT2D;

typedef D3DXVECTOR3 POINT3D;

typedef struct _ipoint3d {
    int x;
    int y;
    int z;
} IPOINT3D;

typedef struct _texpoint2d {
    FLOAT s;
    FLOAT t;
} TEX_POINT2D;

typedef struct _isize {
    int width;
    int height;
} ISIZE;

typedef struct _fsize {
    FLOAT width;
    FLOAT height;
} FSIZE;

typedef struct _glrect {
    int x, y;
    int width, height;
} GLRECT;

// texture data
typedef struct {
    int     width;
    int     height;
    DWORD  format;
    INT components;
    float   origAspectRatio; // original width/height aspect ratio
    unsigned char *data;
    DWORD  texObj;          // texture object
    int     pal_size;
    int     iPalRot;         // current palette rotation (not used yet)
    RGBQUAD *pal;
} TEXTURE, *HTEXTURE;


// texture resource

#define RT_RGB          99
#define RT_MYBMP        100
#define RT_A8           101

// texture resource types
enum {
    TEX_UNKNOWN = 0,
    TEX_RGB,
    TEX_BMP,
    TEX_A8
};

typedef struct {
    int     type;
    int     name;
} TEX_RES;


typedef struct _MATRIX {
    FLOAT M[4][4];
} MATRIX;
//typedef D3DXMATRIX MATRIX;

typedef struct strRGBA {
    FLOAT r;
    FLOAT g;
    FLOAT b;
    FLOAT a;
} RGBA;

typedef struct {
    BYTE r;
    BYTE g;
    BYTE b;
} RGB8;

typedef struct {
    BYTE r;
    BYTE g;
    BYTE b;
    BYTE a;
} RGBA8;


typedef struct _MATERIAL {
    RGBA ka;
    RGBA kd;
    RGBA ks;
    FLOAT specExp;
} MATERIAL;

// texture file info

typedef struct {
    int     nOffset;  // filename offset into pathname
    TCHAR   szPathName[MAX_PATH];  // texture pathname
} TEXFILE;

// texture file processing messages

typedef struct {
    TCHAR   szWarningMsg[MAX_PATH];
    TCHAR   szBitmapSizeMsg[MAX_PATH];
    TCHAR   szBitmapInvalidMsg[MAX_PATH];
    TCHAR   szSelectAnotherBitmapMsg[MAX_PATH];
    TCHAR   szTextureDialogTitle[GEN_STRING_SIZE];
    TCHAR   szTextureFilter[2*GEN_STRING_SIZE];
    TCHAR   szBmp[GEN_STRING_SIZE];
    TCHAR   szDotBmp[GEN_STRING_SIZE];
} TEX_STRINGS;

// Useful macros

#define SS_MAX( a, b ) \
    ( a > b ? a : b )

#define SS_MIN( a, b ) \
    ( a < b ? a : b )

// macro to round up floating values
#define SS_ROUND_UP( fval ) \
    ( (((fval) - (FLOAT)(int)(fval)) > 0.0f) ? (int) ((fval)+1.0f) : (int) (fval) )

// macros to clamp a value within a range
#define SS_CLAMP_TO_RANGE( a, lo, hi ) ( (a < lo) ? lo : ((a > hi) ? hi : a) )
#define SS_CLAMP_TO_RANGE2( a, lo, hi ) \
    ( a = (a < lo) ? lo : ((a > hi) ? hi : a) )

// degree<->radian macros
#define ONE_OVER_180 (1.0f / 180.0f)
#define SS_DEG_TO_RAD( a ) ( (a*PI) * ONE_OVER_180 )
#define SS_RAD_TO_DEG( a ) ( (a*180.0f) * ONE_OVER_PI )

extern MATERIAL TeaMaterial[], TexMaterial[], ss_BlackMat;


// color

extern void ss_HsvToRgb(float h, float s, float v, RGBA *color );


// texture file processing

extern void ss_DisableTextureErrorMsgs();
extern void ss_SetTexture( TEXTURE *pTex );
extern void ss_SetTexturePalette( TEXTURE *pTex, int index );
extern void ss_DeleteTexture( TEXTURE *pTex );
extern BOOL ss_LoadTextureResourceStrings();
extern BOOL ss_VerifyTextureFile( TEXFILE *ptf );
extern BOOL ss_SelectTextureFile( HWND hDlg, TEXFILE *ptf );
extern void ss_GetDefaultBmpFile( LPTSTR pszBmpFile );
extern void ss_InitAutoTexture( TEX_POINT2D *pTexRep );

// math functions

extern POINT3D ss_ptZero;
extern void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *);
extern void ss_matrixIdent(MATRIX *);
extern void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta);
extern void ss_matrixTranslate(MATRIX *, double xTrans, double yTrans, double zTrans);
extern void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 );
extern void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3);
extern void ss_normalizeNorm(POINT3D *);
extern void ss_normalizeNorms(POINT3D *, ULONG);

// dialog helper functions

extern int ss_GetTrackbarPos( HWND hDlg, int item );
extern void ss_SetupTrackbar( HWND hDlg, int item, int lo, int hi, int lineSize, int pageSize, int pos );

extern BOOL gbTextureObjects; // from texture.c

//-----------------------------------------------------------------------------
// Name: struct MYVERTEX
// Desc: D3D vertex type for this app
//-----------------------------------------------------------------------------
struct MYVERTEX
{
    D3DXVECTOR3 p;     // Position
    D3DXVECTOR3 n;     // Normal
};

#define D3DFVF_MYVERTEX ( D3DFVF_XYZ | D3DFVF_NORMAL )


//-----------------------------------------------------------------------------
// Name: struct MYVERTEX2
// Desc: D3D vertex type for this app
//-----------------------------------------------------------------------------
struct MYVERTEX2
{
    D3DXVECTOR3 p;      // Position
    D3DXVECTOR3 n;      // Normal
    FLOAT       tu, tv; // Vertex texture coordinates

};

#define D3DFVF_MYVERTEX2 ( D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1 )

//-----------------------------------------------------------------------------
// Name: struct MYVERTEX3
// Desc: D3D vertex type for this app
//-----------------------------------------------------------------------------
struct MYVERTEX3
{
    D3DXVECTOR3 p;      // Position
    FLOAT       rhw;
    DWORD       dwDiffuse;
    FLOAT       tu, tv; // Vertex texture coordinates

};

#define D3DFVF_MYVERTEX3 ( D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_TEX1 )

#define MAX_VERTICES 5000
#define MAX_INDICES 5000


//-----------------------------------------------------------------------------
// Name: struct FLOATRECT
// Desc: Floating viewport rect
//-----------------------------------------------------------------------------
struct FLOATRECT
{
    FLOAT xMin;           
    FLOAT yMin;
    FLOAT xSize;
    FLOAT ySize;

    FLOAT xVel;
    FLOAT yVel;

    FLOAT xOrigin;
    FLOAT yOrigin;
    FLOAT xVelMax;
    FLOAT yVelMax;
};



#ifndef PI
#define PI 3.14159265358979323846
#endif



// Minimum and maximum number of side subdivisions
#define MINSUBDIV 2
#define MAXSUBDIV 10

// Maximum values allowed
#define MAXSIDES 8
#define MAXSPTS ((MAXSUBDIV+1)*(MAXSUBDIV+1))
#define MAXPTS (MAXSIDES*MAXSPTS)
#define MAXSFACES (MAXSUBDIV*MAXSUBDIV)
#define MAXFACES (MAXSIDES*MAXSFACES)
#define MAXFPTS 4

// Allow floating point type configurability
typedef FLOAT FLT;
typedef struct
{
    FLT x, y, z;
} PT3;

extern LPDIRECT3DDEVICE8 m_pd3dDevice;
extern LPDIRECT3DINDEXBUFFER8 m_pIB;
extern LPDIRECT3DVERTEXBUFFER8 m_pVB;
extern LPDIRECT3DVERTEXBUFFER8 m_pVB2;

#define DIMA(a) (sizeof(a)/sizeof(a[0]))


#define PALETTE_PER_MATL    32
#define PALETTE_PER_DIFF    26
#define PALETTE_PER_SPEC    6
#define MATL_MAX            7

typedef struct strFACE {
    POINT3D p[4];
    POINT3D n[4];
    POINT3D fn;
    int idMatl;
} FACE;

typedef struct strMFACE {
    int p[4];
    int material;
    POINT3D norm;
} MFACE;

typedef struct strMESH {
    int numFaces;
    int numPoints;
    POINT3D *pts;
    POINT3D *norms;
    MFACE *faces;
    INT listID;
} MESH;


/******************************Public*Routine******************************\
*
* Basic vector math macros
*
* History:
*  Wed Jul 19 14:49:49 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define V3Sub(a, b, r) \
    ((r)->x = (a)->x-(b)->x, (r)->y = (a)->y-(b)->y, (r)->z = (a)->z-(b)->z)
#define V3Add(a, b, r) \
    ((r)->x = (a)->x+(b)->x, (r)->y = (a)->y+(b)->y, (r)->z = (a)->z+(b)->z)
#define V3Cross(a, b, r) \
    ((r)->x = (a)->y*(b)->z-(b)->y*(a)->z,\
     (r)->y = (a)->z*(b)->x-(b)->z*(a)->x,\
     (r)->z = (a)->x*(b)->y-(b)->x*(a)->y)
extern FLT V3Len(PT3 *v);


#define MAX_DEVICE_OBJECTS 10

struct DeviceObjects
{
    LPDIRECT3DTEXTURE8 m_pTexture;
    LPDIRECT3DTEXTURE8 m_pTexture2;
    LPDIRECT3DINDEXBUFFER8 m_pIB;
    LPDIRECT3DVERTEXBUFFER8 m_pVB;  // D3DFVF_MYVERTEX (no tex coords)
    LPDIRECT3DVERTEXBUFFER8 m_pVB2; // D3DFVF_MYVERTEX2 (tex coords)
};



extern DeviceObjects* g_pDeviceObjects;
extern FLOATRECT* g_pFloatRect;
extern INT g_xScreenOrigin;
extern INT g_yScreenOrigin;
extern INT g_iDevice;
extern BOOL g_bMoveToOrigin;
extern BOOL g_bAtOrigin;
extern BOOL bSmoothShading;
extern BOOL bFalseColor;
extern BOOL bColorCycle;
extern float fTesselFact;
extern TEXFILE gTexFile;
extern BOOL gbBounce;

extern D3DMATERIAL8 Material[];
extern int NumLights;

extern BOOL newMesh(MESH *, int numFaces, int numPts);
extern void delMesh(MESH *);
extern void revolveSurface(MESH *, POINT3D *curve, int steps);

extern void *SaverAlloc(ULONG);
extern void SaverFree(void *);

#ifndef GL_FRONT
#define GL_FRONT                          0x0404
#endif

#ifndef GL_FRONT_AND_BACK
#define GL_FRONT_AND_BACK                 0x0408
#endif

#ifndef GL_AMBIENT_AND_DIFFUSE
#define GL_AMBIENT_AND_DIFFUSE            0x1602
#endif

#ifndef GL_SHININESS
#define GL_SHININESS                      0x1601
#endif

#ifndef GL_SPECULAR
#define GL_SPECULAR                       0x1202
#endif



extern VOID myglMaterialfv(INT face, INT pname, FLOAT* params);
extern VOID myglMaterialf(INT face, INT pname, FLOAT param);

VOID SetProjectionMatrixInfo( BOOL bOrtho, FLOAT fWidth, 
                              FLOAT fHeight, FLOAT fNear, FLOAT fFar );

class   CFlyingObjectsScreensaver : public CD3DScreensaver
{
protected:
    FLOATRECT m_floatrect;
    DeviceObjects  m_DeviceObjectsArray[MAX_DEVICE_OBJECTS];
    DeviceObjects* m_pDeviceObjects;

public:
    // Projection matrix settings
    BOOL m_bOrtho;
    FLOAT m_fWidth;
    FLOAT m_fHeight;
    FLOAT m_fNear;
    FLOAT m_fFar;

protected:
    virtual HRESULT RegisterSoftwareDevice();
    virtual VOID    SetDevice( UINT iDevice );
    virtual VOID    DoConfig();
    virtual VOID    ReadSettings();
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();
    virtual HRESULT ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, 
                                  D3DFORMAT fmtBackBuffer);
    VOID            WriteSettings( HWND hdlg );

    VOID ss_ReadSettings();
    BOOL ss_RegistrySetup( int section, int file );
    int  ss_GetRegistryInt( int name, int iDefault );
    VOID ss_GetRegistryString( int name, LPTSTR lpDefault, LPTSTR lpDest, int bufSize );
    
    static INT_PTR CALLBACK ScreenSaverConfigureDialog(HWND hDlg, UINT message,
                                                       WPARAM wParam, LPARAM lParam);
    HRESULT SetMaterialColor(FLOAT* pfColors);
    BOOL _3dfo_Init(void *data);
    void _3dfo_Draw(void *data);


public:
    CFlyingObjectsScreensaver();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\genexpld.cpp ===
/******************************Module*Header*******************************\
* Module Name: genexpld.c
*
* The Explode style of the 3D Flying Objects screen saver.
*
* Simulation of a sphere that occasionally explodes.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

#define RADIUS         	0.3
#define STEPS    	30
#define MAXPREC		20

static MATRIX *faceMat;
static float *xstep;
static float *ystep;
static float *zstep;
static float *xrot;
static float *yrot;
static float *zrot;
static MESH explodeMesh;
static int iPrec = 10;

// Data type accepted by glInterleavedArrays
typedef struct _POINT_N3F_V3F {
    POINT3D normal;
    POINT3D vertex;
} POINT_N3F_V3F;

static POINT_N3F_V3F *pN3V3;

static FLOAT matl1Diffuse[] = {1.0f, 0.8f, 0.0f, 1.0f};
static FLOAT matl2Diffuse[] = {0.8f, 0.8f, 0.8f, 1.0f};
static FLOAT matlSpecular[] = {1.0f, 1.0f, 1.0f, 1.0f};
static FLOAT light0Pos[] = {100.0f, 100.0f, 100.0f, 0.0f};

void genExplode()
{
    int i;
    POINT3D circle[MAXPREC+1];
    double angle;
    double step = -PI / (float)(iPrec - 1);
    double start = PI / 2.0;
    
    for (i = 0, angle = start; i < iPrec; i++, angle += step) {
        circle[i].x = (float) (RADIUS * cos(angle));
        circle[i].y = (float) (RADIUS * sin(angle));
        circle[i].z = 0.0f;
    }

    revolveSurface(&explodeMesh, circle, iPrec);

    for (i = 0; i < explodeMesh.numFaces; i++) {
        ss_matrixIdent(&faceMat[i]);
        xstep[i] = (float)(((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
        ystep[i] = (float)(((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
        zstep[i] = (float)(((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
        xrot[i] = 0.0f;
        yrot[i] = 0.0f;
        zrot[i] = 0.0f;
    }
}

BOOL initExplodeScene()
{
    iPrec = (int)(fTesselFact * 10.5);
    if (iPrec < 5)
        iPrec = 5;
    if (iPrec > MAXPREC)
        iPrec = MAXPREC;

    faceMat = (MATRIX *)SaverAlloc((iPrec * iPrec) * 
    				 (4 * 4 * sizeof(float)));
    if( faceMat == NULL )
        return FALSE;

    xstep = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( xstep == NULL )
        return FALSE;

    ystep = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( ystep == NULL )
        return FALSE;

    zstep = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( zstep == NULL )
        return FALSE;

    xrot = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( xrot == NULL )
        return FALSE;

    yrot = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( yrot == NULL )
        return FALSE;

    zrot = (float*)SaverAlloc(iPrec * iPrec * sizeof(float));
    if( zrot == NULL )
        return FALSE;

    
    genExplode();

/*
    // Find out the OpenGL version that we are running on.
    bOpenGL11 = ss_fOnGL11();
*/

    // Setup the data arrays.
    pN3V3 = (POINT_N3F_V3F*)SaverAlloc(explodeMesh.numFaces * 4 * sizeof(POINT_N3F_V3F));
/*
    // If we are running on OpenGL 1.1, use the new vertex array functions.
    if (bOpenGL11) {
        glInterleavedArrays(GL_N3F_V3F, 0, pN3V3);
    }
*/

    myglMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, matl1Diffuse);
    myglMaterialfv(GL_FRONT, GL_SPECULAR, matlSpecular);
    myglMaterialf(GL_FRONT, GL_SHININESS, 100.0f);
/*
    glMaterialfv(GL_BACK, GL_AMBIENT_AND_DIFFUSE, matl2Diffuse);
    glMaterialfv(GL_BACK, GL_SPECULAR, matlSpecular);
    glMaterialf(GL_BACK, GL_SHININESS, 60.0f);
*/

/*
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveLH( &matProj, 0.66f, 0.66f, 0.3f, 3.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
*/
    SetProjectionMatrixInfo( FALSE, 0.66f, 0.66f, 0.3f, 3.0f );

    D3DXMATRIX matView;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 1.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    return TRUE;
}


void delExplodeScene()
{
    delMesh(&explodeMesh);
    
    SaverFree(faceMat);
    SaverFree(xstep);
    SaverFree(ystep);
    SaverFree(zstep);
    SaverFree(xrot);
    SaverFree(yrot);
    SaverFree(zrot);
    SaverFree(pN3V3);
}

void updateExplodeScene(int flags, FLOAT fElapsedTime)
{
    static float maxR;
    static float r = 0.0f;
    static float rChange = 0.0f;
    static float rChangePrev = 1.0f;
    static float rotZ = 0.0f;
    static int count = 0;
    static float fCount = 0.0f;
    static int direction = 1;
    static FLOAT fRestCount = 0.0f;
    static float lightSpin = 0.0f;
    static float spinDelta = 5.0f;
    static FLOAT fH = 0.0f;
    static RGBA color;
    if( fElapsedTime > 0.25f )
        fElapsedTime = 0.25f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    int i;
    MFACE *faces;
    POINT_N3F_V3F *pn3v3;
    D3DXMATRIX mat1, mat2, mat3, mat4, mat5, matFinal;
    static FLOAT fTimer = 0.0f;
/*
    // Only update 50x per second
    fTimer += fElapsedTime;
    if( fTimer < 1.0f/50.0f )
        return;
    fTimer = 0.0f;
*/
    if (bColorCycle || fH == 0.0f) 
    {
        ss_HsvToRgb(fH, 1.0f, 1.0f, &color);

        myglMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, (FLOAT *) &color);
        fH += fTimeFactor;
        if( fH >= 360.0f )
            fH -= 360.0f;
    }
/*
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glRotatef(-lightSpin, 0.0f, 1.0f, 0.0f);
    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos);

    lightSpin += spinDelta * fTimeFactor;
    if ((lightSpin > 90.0) || (lightSpin < 0.0))
        spinDelta = -spinDelta;
*/
/*
    glPopMatrix();

    if (!bOpenGL11) {
        glBegin(GL_QUADS);
    }
*/
    for(
        i = 0, faces = explodeMesh.faces, pn3v3 = pN3V3;
        i < explodeMesh.numFaces;
        i++, faces++, pn3v3 += 4
       ) 
        {
        int a, b, c, d;
        int j;
        POINT3D vector;
        
        ss_matrixIdent(&faceMat[i]);
        ss_matrixRotate(&faceMat[i], xrot[i], yrot[i], zrot[i]);

        if (fRestCount > 0.0f)
            ;
        else {
            xrot[i] += (xstep[i]) * fTimeFactor;
            yrot[i] += (ystep[i]) * fTimeFactor;
            zrot[i] += (zstep[i]) * fTimeFactor;
        } 

        a = faces->p[0];
        b = faces->p[1];
        c = faces->p[3];
        d = faces->p[2];
        
        memcpy(&pn3v3[0].vertex, (explodeMesh.pts + a), sizeof(POINT3D));
        memcpy(&pn3v3[1].vertex, (explodeMesh.pts + b), sizeof(POINT3D));
        memcpy(&pn3v3[2].vertex, (explodeMesh.pts + c), sizeof(POINT3D));
        memcpy(&pn3v3[3].vertex, (explodeMesh.pts + d), sizeof(POINT3D));

        vector.x = pn3v3[0].vertex.x;
        vector.y = pn3v3[0].vertex.y;
        vector.z = pn3v3[0].vertex.z;

        for (j = 0; j < 4; j++) {
            pn3v3[j].vertex.x -= vector.x;
            pn3v3[j].vertex.y -= vector.y;
            pn3v3[j].vertex.z -= vector.z;
            ss_xformPoint((POINT3D *)&pn3v3[j].vertex, (POINT3D *)&pn3v3[j].vertex, &faceMat[i]);
            pn3v3[j].vertex.x += vector.x + (vector.x * r);
            pn3v3[j].vertex.y += vector.y + (vector.y * r);
            pn3v3[j].vertex.z += vector.z + (vector.z * r);
        }
        if (bSmoothShading) {
            memcpy(&pn3v3[0].normal, (explodeMesh.norms + a), sizeof(POINT3D));
            memcpy(&pn3v3[1].normal, (explodeMesh.norms + b), sizeof(POINT3D));
            memcpy(&pn3v3[2].normal, (explodeMesh.norms + c), sizeof(POINT3D));
            memcpy(&pn3v3[3].normal, (explodeMesh.norms + d), sizeof(POINT3D));
           
            for (j = 0; j < 4; j++)
                ss_xformNorm((POINT3D *)&pn3v3[j].normal, (POINT3D *)&pn3v3[j].normal, &faceMat[i]);
        } else {            
            memcpy(&pn3v3[0].normal, &faces->norm, sizeof(POINT3D));
            ss_xformNorm((POINT3D *)&pn3v3[0].normal, (POINT3D *)&pn3v3[0].normal, &faceMat[i]);
            memcpy(&pn3v3[1].normal, &pn3v3[0].normal, sizeof(POINT3D));
            memcpy(&pn3v3[2].normal, &pn3v3[0].normal, sizeof(POINT3D));
            memcpy(&pn3v3[3].normal, &pn3v3[0].normal, sizeof(POINT3D));
        }
    }
    {
        m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );
        static WORD s_indexArray[5000];
        static MYVERTEX s_vertexArray[5000];
        INT numPrims = 0;
        INT numIndices = 0;
        INT numVertices = 0;
        WORD iVertexA, iVertexB, iVertexC, iVertexD;
        INT a,b,c,d;
        HRESULT hr;

        for( int iFace = 0; iFace < explodeMesh.numFaces; iFace++ )
        {
            a = iFace * 4 + 0;
            b = iFace * 4 + 1;
            c = iFace * 4 + 2;
            d = iFace * 4 + 3;

            s_vertexArray[numVertices].p = pN3V3[a].vertex;
            s_vertexArray[numVertices].n = pN3V3[a].normal;
            iVertexA = numVertices++;
            s_vertexArray[numVertices].p = pN3V3[b].vertex;
            s_vertexArray[numVertices].n = pN3V3[b].normal;
            iVertexB = numVertices++;
            s_vertexArray[numVertices].p = pN3V3[c].vertex;
            s_vertexArray[numVertices].n = pN3V3[c].normal;
            iVertexC = numVertices++;
            s_vertexArray[numVertices].p = pN3V3[d].vertex;
            s_vertexArray[numVertices].n = pN3V3[d].normal;
            iVertexD = numVertices++;

            s_indexArray[numIndices++] = iVertexA;
            s_indexArray[numIndices++] = iVertexB;
            s_indexArray[numIndices++] = iVertexC;
            numPrims++;
            s_indexArray[numIndices++] = iVertexA;
            s_indexArray[numIndices++] = iVertexC;
            s_indexArray[numIndices++] = iVertexD;
            numPrims++;
        }
        hr = m_pd3dDevice->DrawIndexedPrimitiveUP( D3DPT_TRIANGLELIST, 0, numVertices, 
            numPrims, s_indexArray, D3DFMT_INDEX16, s_vertexArray, sizeof(MYVERTEX) );
    }
/*
    if (bOpenGL11) {
        glDrawArrays(GL_QUADS, 0, explodeMesh.numFaces * 4);
    } else {
        glEnd();
    }
*/
    if (fRestCount > 0.0f) {
        fRestCount -= fTimeFactor;
        goto resting;
    }

    rChange += fTimeFactor;
    while( (INT)rChangePrev < (INT)rChange )
    {
        rChangePrev += 1.0;
        if (direction) {
            maxR = r;
            r += (float) (0.3 * pow((double)(STEPS - count) / (double)STEPS, 4.0));
        } else {
            r -= (float) (maxR / (double)(STEPS));
        }
    }

    fCount += fTimeFactor;
    count = (INT)fCount;
    if (count > STEPS) {
        direction ^= 1;
        count = 0;
        fCount = 0.0f;

        if (direction == 1) {
            fRestCount = 10.0f;
            r = 0.0f;
            rChange = 0.0f;
            rChangePrev = 1.0f;

            for (i = 0; i < explodeMesh.numFaces; i++) {
                ss_matrixIdent(&faceMat[i]);
                xstep[i] = (float) (((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
                ystep[i] = (float) (((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
                zstep[i] = (float) (((float)(rand() & 0x3) * PI) / ((float)STEPS + 1.0));
                
                xrot[i] = 0.0f;
                yrot[i] = 0.0f;
                zrot[i] = 0.0f;
            }
        }
    }

resting:
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\genlem.cpp ===
/******************************Module*Header*******************************\
* Module Name: genlem.c
*
* The Twist style of the 3D Flying Objects screen saver.
*
* Solid model of a 3D lemniscate.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
//#include <GL\gl.h>
#include <string.h>
#include <math.h>
//#include "ss3dfo.h"
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

#define ROT_PREC    10
#define NORMS(x, y) lemMesh.norms[((x) * iPrec) + y]
#define GRID(x, y)  lemMesh.pts[((x) * iPrec) + y]

static MESH lemMesh;
static POINT3D basis[ROT_PREC];
static double zrot = 0.2;
static int iPrec = 32;
static double *lemX;
static double *lemY;
static double *lemXT;
static double *lemYT;


static void getLem(double index, double max, double *angle, double *r)
{    
    double a, sina;

    a = (index * PI) / (max - 1.0);
    if (a >= PI)
        a -= PI;
    if (a > PI / 2.0) {
        *angle = (2.0 * PI) - a;
        sina = sin( 2.0 * *angle );
        if( sina < 0.0 )
            sina = 0.0; // protect against sqrt fpe
        *r = 0.5 * sqrt(sina);
    } else {
        *angle = a;
        sina = sin( 2.0 * *angle );
        if( sina < 0.0 )
            sina = 0.0;
        *r = 0.5 * sqrt(sina);
    }
}            


static void initLemCoords(int iMax)
{
    int i;
    double max = (double)iMax;
    double angle;
    double r;

    for (i = 0; i < iMax; i++) {
        getLem((double)i, (double)iPrec, &angle, &r);        
        lemX[i] = r * cos(angle);
        lemY[i] = r * sin(angle);
        
        getLem((double)i + 0.00001, (double)iPrec, &angle, &r);        
        lemXT[i] = r * cos(angle);
        lemYT[i] = r * sin(angle);

    }
}


void genLemniscate(void)
{
    int i;
    int j;
    double posInc = 2.0 / (float)iPrec;
    int facecount = 0;
    int ptcount = 0;
    POINT3D norm;
    static float twistFact = 0.0f;
    static float twistFactAdd = 0.05f;
    POINT3D a[ROT_PREC];
    POINT3D b[ROT_PREC];
    MATRIX matrix;
    MESH *mesh = &lemMesh;

    mesh->numPoints = 0;   
    mesh->numFaces = 0;   
    for (i = 0; i < (iPrec - 1) * (ROT_PREC - 1); i++)
        mesh->norms[i] = ss_ptZero;

    for (i = 0; i < (iPrec - 1); i++) {
        double x1, y1, x2, y2;
        double len;
        double sinAngle;
        double rotZ;
        int id[4];

        x1 = lemX[i];
        y1 = lemY[i];
        x2 = lemXT[i];
        y2 = lemYT[i];

        x2 -= x1;
        y2 -= y1;

        len = sqrt(x2 * x2 + y2 * y2);
        if (len > 0.0)
            sinAngle = y2 / len;
        else
            sinAngle = 0.0;
        if (y2 < 0.0)
            sinAngle = -sinAngle;
        rotZ = asin(sinAngle);
        if (x2 < 0.0)
            rotZ = PI - rotZ;
        if (y2 < 0.0)
            rotZ = -rotZ;
        if (rotZ < 0.0)
            rotZ = 2.0 * PI + rotZ;

        ss_matrixIdent(&matrix);
        ss_matrixRotate(&matrix, 0.0, 0.0, -rotZ);
        ss_matrixTranslate(&matrix, x1, y1, 
                         twistFact * cos((2.0 * PI * (float)i) / ((float)iPrec - 1)));
        
        for (j = 0; j < ROT_PREC; j++)
            ss_xformPoint(&a[j], &basis[j], &matrix);

        x1 = lemX[i+1];
        y1 = lemY[i+1];

        x2 = lemXT[i+1];
        y2 = lemYT[i+1];

        x2 -= x1;
        y2 -= y1;

        len = sqrt(x2 * x2 + y2 * y2);

        if (len > 0.0)
            sinAngle = y2 / len;
        else
            sinAngle = 0.0;
        if (y2 < 0.0)
            sinAngle = -sinAngle;
        rotZ = asin(sinAngle);
        if (x2 < 0.0)
            rotZ = PI - rotZ;
        if (y2 < 0.0)
            rotZ = -rotZ;
        if (rotZ < 0.0)
            rotZ = 2.0 * PI + rotZ;

        ss_matrixIdent(&matrix);
        ss_matrixRotate(&matrix, 0.0, 0.0, -rotZ);        
        ss_matrixTranslate(&matrix, x1, y1, 
                         twistFact * cos((2.0 * PI * ((float)i + 1.0)) / ((float)iPrec - 1)));

        for (j = 0; j < ROT_PREC; j++)
            ss_xformPoint(&b[j], &basis[j], &matrix);
            
        memcpy(&mesh->pts[ptcount], a, sizeof(POINT3D) * (ROT_PREC - 1));
        ptcount += (ROT_PREC - 1);
        mesh->numPoints += (ROT_PREC - 1);
        
            
        for (j = 0; j < (ROT_PREC - 1); j++) {
            int k;
            int jj;
            
            if (j == (ROT_PREC - 2))
                jj = 0;
            else
                jj = j + 1;

            ss_calcNorm(&norm, &b[j + 1], &b[j], &a[j]);
            
            mesh->faces[facecount].material = 3;
            mesh->faces[facecount].norm = norm;
            if (i == iPrec - 2) {
                id[0] = mesh->faces[facecount].p[0] = j;
                id[1] = mesh->faces[facecount].p[1] = jj;
            } else {
                id[0] = mesh->faces[facecount].p[0] = ptcount + j;
                id[1] = mesh->faces[facecount].p[1] = ptcount + jj;
            }
            id[2] = mesh->faces[facecount].p[2] = ptcount - (ROT_PREC - 1) + j;
            id[3] = mesh->faces[facecount].p[3] = ptcount - (ROT_PREC - 1) + jj;
            
            for (k = 0; k < 4; k++) {
                POINT3D *pn = &mesh->norms[id[k]];
                
                pn->x += norm.x;
                pn->y += norm.y;
                pn->z += norm.z;
            }
            mesh->numFaces++;
            facecount++;
        }
    }

    ss_normalizeNorms(lemMesh.norms, lemMesh.numPoints);
        
    if (twistFact >= 1.0f)
        twistFactAdd = -0.01f;
    else if (twistFact <= -1.0f)
        twistFactAdd = 0.01f;
    twistFact += twistFactAdd;
        
}

BOOL initLemScene()
{
    int i;
    RGBA lightAmbient = {0.0f, 0.0f, 0.0f, 1.0f};

    iPrec = (int)(fTesselFact * 32.5);
    if (iPrec < 5)
        iPrec = 5;

    lemX = (double*)SaverAlloc(sizeof(double) * iPrec);
    if( lemX == NULL )
        return FALSE;

    lemY = (double*)SaverAlloc(sizeof(double) * iPrec);
    if( lemY == NULL )
        return FALSE;

    lemXT = (double*)SaverAlloc(sizeof(double) * iPrec);
    if( lemXT == NULL )
        return FALSE;

    lemYT = (double*)SaverAlloc(sizeof(double) * iPrec);
    if( lemYT == NULL )
        return FALSE;

/*
    D3DXMATRIX matProj;
    D3DXMatrixOrthoLH( &matProj, 3.0, 3.0, 0.0f, 3.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
*/
    SetProjectionMatrixInfo( TRUE, 3.0f, 3.0f, 0.0f, 3.0f );

    D3DXMATRIX matView;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 1.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    if (!newMesh(&lemMesh, (ROT_PREC - 1) * (iPrec - 1) , 
            (ROT_PREC - 1) * (iPrec - 1)) )
    {
        return FALSE;
    }

    for (i = 0; i < ROT_PREC; i++) {
        basis[i].x = 0.0f;
        basis[i].y = (float) (0.15 * cos((i * 2.0 * PI) / (ROT_PREC - 1.0)));
        basis[i].z = (float) (0.15 * sin((i * 2.0 * PI) / (ROT_PREC - 1.0)));
    }

    initLemCoords(iPrec);
/*
    glFrontFace(GL_CW);
    glEnable(GL_CULL_FACE);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (FLOAT *) &lightAmbient);
*/
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_CW );
    myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                 (FLOAT *) &Material[3].Diffuse);

    return TRUE;
}

void delLemScene()
{
    delMesh(&lemMesh);

    SaverFree(lemX);
    SaverFree(lemY);
    SaverFree(lemXT);
    SaverFree(lemYT);
}

void updateLemScene(int flags, FLOAT fElapsedTime)
{
    static double mxrot = 0.0;
    static double myrot = 0.0;
    static double mzrot = 0.0;
    static double mxrotInc = 0.0;
    static double myrotInc = 0.1;
    static double zrotInc = 0.1;
    static double mzrotInc = 0.0;
    RGBA color;
    MATRIX model;
    D3DXMATRIX mat1, mat2, mat3, mat4, mat5, matFinal;
    static FLOAT fH = 0.0f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    if( fTimeFactor > 0.25f )
        fTimeFactor = 0.25f;
    
    mxrot += mxrotInc * fTimeFactor;
    myrot += myrotInc * fTimeFactor;
    mzrot += mzrotInc * fTimeFactor;

    if( gbBounce ) {
        // floating window bounced off an edge
        if (mxrotInc) {
            mxrotInc = 0.0;
            myrotInc = 0.1;
        } else if (myrotInc) {
            myrotInc = 0.0;
            mzrotInc = 0.1;
        } else if (mzrotInc) {
            mzrotInc = 0.0;
            mxrotInc = 0.1;
        }
        gbBounce = FALSE;
    }

    zrot += zrotInc * fTimeFactor;
    if (zrot >= PI / 4.0) {
        zrot = PI / 4.0;
        zrotInc = -0.03;
    } else if (zrot <= -PI / 4.0) {
        zrot = -PI / 4.0;
        zrotInc = 0.03;
    }

    genLemniscate();

    if (bColorCycle) {
        ss_HsvToRgb(fH, 1.0f, 1.0f, &color );

        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, (FLOAT *) &color);

        fH += fTimeFactor;
        if( fH >= 360.0f )
            fH -= 360.0f;
    }
/*
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.5, 1.5, -1.5, 1.5, 0.0, 3.0);
    glTranslatef(0.0f, 0.0f, -1.5f);
*/
/*
    glRotatef((FLOAT) (zrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f);
    glRotatef(50.0f, 1.0f, 0.0f, 0.0f);
    glRotatef(50.0f, 0.0f, 0.0f, 1.0f);
*/

    D3DXMATRIX matView;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 1.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookatPt, &vUpVec );
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );
/*
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0f, -0.5f, 0.0f);
    glRotatef((FLOAT) (mxrot * (180.0 / PI)), 1.0f, 0.0f, 0.0f);
    glRotatef((FLOAT) (myrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f);
    glRotatef((FLOAT) (mzrot * (180.0 / PI)), 0.0f, 0.0f, 1.0f);
*/
    D3DXMatrixTranslation(&mat1, 0.0f, -0.5f, 0.0f);
    D3DXMatrixRotationX(&mat2, D3DXToRadian((FLOAT)(mxrot * (180.0 / PI))));
    D3DXMatrixRotationY(&mat3, D3DXToRadian((FLOAT)(myrot * (180.0 / PI))));
    D3DXMatrixRotationZ(&mat4, D3DXToRadian((FLOAT)(mzrot * (180.0 / PI))));
    matFinal = mat4 * mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD , &matFinal );

    ss_matrixIdent(&model);
    ss_matrixRotate(&model, mxrot, myrot, mzrot);
    ss_matrixTranslate(&model, 0.0, -0.5, 0.0);

//    updateObject(&lemMesh, bSmoothShading);    
    RenderMesh3(&lemMesh, bSmoothShading);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\genstrip.cpp ===
/******************************Module*Header*******************************\
* Module Name: genstrip.c
*
* The Ribbon and 2 Ribbon styles of the 3D Flying Objects screen saver.
*
* Animation of 1 or 2 quad strips floating about.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

static MESH stripMesh;
static int iPrec = 40;

void genStrip(FLOAT fTimeFactor)
{
    static int counter = 0;
    int i;
    int facecount;
    // Use Hermite basis, pg 488, FVD
    static float M[4][4] = {{2.0f, -2.0f, 1.0f, 1.0f},
                            {-3.0f, 3.0f, -2.0f, -1.0f},
                            {0.0f, 0.0f, 1.0f, 0.0f},
                            {1.0f, 0.0f, 0.0f, 0.0f}};
    float xx[4], yy[4], zz[4];
    float cx[4], cy[4], cz[4];
    float d = 1.0f / (float) iPrec;
    float t = 0.0f;
    float t2, t3;
    POINT3D p1(-0.5f, 0.0f, 0.0f);
    POINT3D p2(0.5f, 0.0f, 0.0f);
    POINT3D v1(1.5f, 1.5f, 0.0f);
    POINT3D v2(0.0f, 3.0f, 0.0f);
    POINT3D norm;
    float sinVal;
    float angle;
    float angleStep = (float) (PI / iPrec);
    static float rotA = 0.0f;
    static float rotB = (float) (PI / 2.0);
    static float sideSin = 0.0f;
    float rotStepA = (float) (PI / (2.0 * iPrec)) * fTimeFactor;
    float rotStepB = (float) (PI / (4.0 * iPrec)) * fTimeFactor;
    MESH *mesh = &stripMesh;

#define NORMS(x, y) stripMesh.norms[((x) * iPrec) + y]
#define GRID(x, y)  stripMesh.pts[((x) * iPrec) + y]
    
    v1.x = (float) (4.0 * cos(rotA));
    v1.y = (float) (4.0 * sin(rotA));

    p2.x = (float) (0.5 * sin(rotB));
//    p2.y = (float) (0.5 * sin(rotB));
    
    rotA += rotStepA;
    rotB += rotStepB;
    counter++;
    if (counter >= (2 * iPrec)) {
        rotStepA = -rotStepA;
        counter = 0;
    }

    angle = sideSin;
    sideSin += (float) (PI / 80.0);
    
    xx[0] = p1.x;
    xx[1] = p2.x;
    xx[2] = v1.x;
    xx[3] = v2.x;

    yy[0] = p1.y;
    yy[1] = p2.y;
    yy[2] = v1.y;
    yy[3] = v2.y;

    zz[0] = p1.z;
    zz[1] = p2.z;
    zz[2] = v1.z;
    zz[3] = v2.z;
    
    for (i = 0; i < 4; i++) {
        cx[i] = xx[0] * M[i][0] + xx[1] * M[i][1] +
                xx[2] * M[i][2] + xx[3] * M[i][3];
        cy[i] = yy[0] * M[i][0] + yy[1] * M[i][1] +
                yy[2] * M[i][2] + yy[3] * M[i][3];
        cz[i] = zz[0] * M[i][0] + zz[1] * M[i][1] +
                zz[2] * M[i][2] + zz[3] * M[i][3];
    }

    for (i = 0; i < iPrec; i++) {
        float x, y;
            
        t += d;
        t2 = t * t;
        t3 = t2 * t;
        
        x = cx[0] * t3 + cx[1] * t2 + cx[2] * t + cx[3];
        y = cy[0] * t3 + cy[1] * t2 + cy[2] * t + cy[3];
        
        sinVal = (float) (sin(angle) / 5.0);
        if (sinVal < 0.0)
            sinVal = -sinVal;
        angle += angleStep;
       
        GRID(0, i).x = x;
        GRID(0, i).z = y;
        GRID(0, i).y = 0.25f;    // extrusion // + sinVal;
        GRID(1, i).x = x;
        GRID(1, i).z = y;
        GRID(1, i).y = -0.25f;   // - sinVal;
    }

    stripMesh.numFaces = 0;
    
    for (i = 0; i < 2 * iPrec; i++)
        mesh->norms[i] = ss_ptZero;

    for (facecount = 0, i = 0; i < (iPrec - 1); i++) {
        
        ss_calcNorm(&norm, &GRID(0, i + 1), &GRID(0, i), &GRID(1, i));
        stripMesh.faces[facecount].material = 0;
        stripMesh.faces[facecount].norm = norm;
            
        NORMS(0, i).x += norm.x;
        NORMS(0, i).y += norm.y;
        NORMS(0, i).z += norm.z;
        NORMS(1, i).x += norm.x;
        NORMS(1, i).y += norm.y;
        NORMS(1, i).z += norm.z;

        if (i != (iPrec - 1)) {
            NORMS(0, i+1).x += norm.x;
            NORMS(0, i+1).y += norm.y;
            NORMS(0, i+1).z += norm.z;
            NORMS(1, i+1).x += norm.x;
            NORMS(1, i+1).y += norm.y;
            NORMS(1, i+1).z += norm.z;
        }

        stripMesh.faces[facecount].p[0] = i;
        stripMesh.faces[facecount].p[1] = iPrec + i;
        stripMesh.faces[facecount].p[2] = i + 1;
        stripMesh.faces[facecount].p[3] = iPrec + i + 1;
        stripMesh.numFaces++;
        facecount++;
    }

    stripMesh.numPoints = 2 * iPrec;

    ss_normalizeNorms(stripMesh.norms, stripMesh.numPoints);
}




BOOL initStripScene()
{
    iPrec = (int)(fTesselFact * 40.5);
    if (iPrec < 4)
        iPrec = 4;

    if( !newMesh(&stripMesh, iPrec, 2 * iPrec) )
        return FALSE;

/*
    D3DXMATRIX matProj;
    D3DXMatrixOrthoLH( &matProj, 2.2f, 2.2f, 0.0f, 3.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
*/
    SetProjectionMatrixInfo( TRUE, 2.2f, 2.2f, 0.0f, 3.0f );

    D3DXMATRIX mat1, mat2, mat3, mat4, matFinal;
    D3DXMatrixTranslation(&mat1, 0.0f, 0.0f, 1.5f);
    D3DXMatrixRotationX(&mat2, D3DXToRadian(50.0f));
    D3DXMatrixRotationY(&mat3, D3DXToRadian(50.0f));
    D3DXMatrixRotationZ(&mat4, D3DXToRadian(12.0f));
    matFinal = mat4 * mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matFinal );

//    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    return TRUE;
}

void delStripScene()
{
    delMesh(&stripMesh);
}

void updateStripScene(int flags, FLOAT fElapsedTime)
{
    static double mxrot = 0.0;
    static double myrot = 0.0;
    static double mzrot = 0.0;
    static double mxrotInc = 0.0;
    static double myrotInc = 0.1;
    static double mzrotInc = 0.0;
    static FLOAT fH = 0.0f;
    if( fElapsedTime > 0.25f )
        fElapsedTime = 0.25f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    RGBA color;
    D3DXMATRIX mat1, mat2, mat3, mat4, mat5, matFinal;

    // This is to deal with when you set maximum size and
    // gbBounce is TRUE every frame.  If that's happening,
    // don't toggle the rotInc's or the scene will jiggle.
    static BOOL bBounceLast = FALSE;

    if( gbBounce ) {
        if( bBounceLast )
        {
        }
        else
        {
            // floating window bounced off an edge
            if (mxrotInc) {
                mxrotInc = 0.0;
                myrotInc = 0.1;
            } else if (myrotInc) {
                myrotInc = 0.0;
                mzrotInc = 0.1;
            } else if (mzrotInc) {
                mzrotInc = 0.0;
                mxrotInc = 0.1;
            }
        }
        gbBounce = FALSE;
        bBounceLast = TRUE;
    }
    else
    {
        bBounceLast = FALSE;
    }

    D3DXMatrixRotationX(&mat1, D3DXToRadian((FLOAT)(mxrot * (180.0 / PI))));
    D3DXMatrixRotationY(&mat2, D3DXToRadian((FLOAT)(myrot * (180.0 / PI))));
    D3DXMatrixRotationZ(&mat3, D3DXToRadian((FLOAT)(mzrot * (180.0 / PI))));
    matFinal = mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matFinal );

    genStrip(fTimeFactor);

    if (bColorCycle) {
        ss_HsvToRgb(fH, 1.0f, 1.0f, &color );

        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                     (FLOAT *) &color);
        fH += fTimeFactor;
        if( fH >= 360.0f )
            fH -= 360.0f;
    } else {
        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, 
                     (FLOAT *) &Material[1].Diffuse);
    }

    RenderMesh3(&stripMesh, bSmoothShading);
    RenderMesh3Backsides(&stripMesh, bSmoothShading);

    if (flags & 0x4) 
    {
        D3DXMatrixTranslation(&mat1, 0.05f, 0.0f, 0.0f);
        D3DXMatrixRotationX(&mat2, D3DXToRadian((FLOAT)(myrot * (180.0 / PI))));
        D3DXMatrixRotationY(&mat3, D3DXToRadian((FLOAT)(mxrot * (180.0 / PI))));
        D3DXMatrixRotationZ(&mat4, D3DXToRadian((FLOAT)(mzrot * (180.0 / PI))));
        matFinal = mat4 * mat3 * mat2 * mat1 ;
        m_pd3dDevice->SetTransform( D3DTS_WORLD , &matFinal );

        if (bColorCycle) {
            color.r = 1.0f - color.r;
            color.g = 1.0f - color.g;
            color.b = 1.0f - color.b;

            myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,
                         (FLOAT *) &color);
        } else {
            myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, 
                         (FLOAT *) &Material[2].Diffuse);
        }

        RenderMesh3(&stripMesh, bSmoothShading);
        RenderMesh3Backsides(&stripMesh, bSmoothShading);
    }

    mxrot += mxrotInc * fTimeFactor;
    myrot += myrotInc * fTimeFactor;
    mzrot += mzrotInc * fTimeFactor;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\gentex.cpp ===
/******************************Module*Header*******************************\
* Module Name: gentex.c
*
* The Textured Flag style of the 3D Flying Objects screen saver.
*
* Texture maps .BMP files onto a simulation of a flag waving in the breeze.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "resource.h"
#include "mesh.h"

static FLOAT winTotalwidth = (FLOAT)0.75;
static FLOAT winTotalheight = (FLOAT)0.75 * (FLOAT)0.75;

#define MAX_FRAMES 20

// IPREC is the number of faces in the mesh that models the flag.

#define IPREC   15

static int Frames = 10;
static MESH winMesh[MAX_FRAMES];
static FLOAT sinAngle = (FLOAT)0.0;
static FLOAT xTrans = (FLOAT)0.0;
static int curMatl = 0;

// Material properties.

static RGBA matlBrightSpecular = {1.0f, 1.0f, 1.0f, 1.0f};
static RGBA matlDimSpecular    = {0.5f, 0.5f, 0.5f, 1.0f};
static RGBA matlNoSpecular     = {0.0f, 0.0f, 0.0f, 0.0f};

// Lighting properties.

static FLOAT light0Pos[] = {20.0f, 5.0f, 20.0f, 0.0f};
static FLOAT light1Pos[] = {-20.0f, 5.0f, 0.0f, 0.0f};
static RGBA light1Ambient  = {0.0f, 0.0f, 0.0f, 0.0f};
static RGBA light1Diffuse  = {0.4f, 0.4f, 0.4f, 1.0f};
static RGBA light1Specular = {0.0f, 0.0f, 0.0f, 0.0f};

static RGBA flagColors[] = {{1.0f, 1.0f, 1.0f, 1.0f},
                            {0.94f, 0.37f, 0.13f, 1.0f},    // red
                           };

// Default texture resource

static TEX_RES gTexRes = { TEX_BMP, IDB_DEFTEX };

static TEXTURE gTex = {0}; // One global texture


                           
                           
/******************************Public*Routine******************************\
* iPtInList
*
* Add a vertex and its normal to the mesh.  If the vertex already exists,
* add in the normal to the existing normal (we to accumulate the average
* normal at each vertex).  Normalization of the normals is the
* responsibility of the caller.
*
\**************************************************************************/
static int iPtInList(MESH *mesh, int start, 
                     POINT3D *p, POINT3D *norm, BOOL blend)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    if (blend) {
        for (i = start; i < mesh->numPoints; i++, pts++) {
            if ((pts->x == p->x) && (pts->y == p->y) && (pts->z == p->z)) {
                mesh->norms[i].x += norm->x;
                mesh->norms[i].y += norm->y;
                mesh->norms[i].z += norm->z;
                return i;
            }
        }
    } else {
        i = mesh->numPoints;
    }

    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}




/******************************Public*Routine******************************\
* getZpos
*
* Get the z-position (depth) of the "wavy" flag component at the given x.
*
* The function used to model the wave is:
*
*        1/2
*   z = x    * sin((2*PI*x + sinAngle) / 4)
*
* The shape of the wave varies from frame to frame by changing the
* phase, sinAngle.
*
\**************************************************************************/
FLOAT getZpos(FLOAT x)
{
    FLOAT xAbs = x - xTrans;
    FLOAT angle = sinAngle + ((FLOAT) (2.0 * PI) * (xAbs / winTotalwidth));

    xAbs = winTotalwidth - xAbs;
//    xAbs += (winTotalwidth / 2.0);

    return (FLOAT)((sin((double)angle) / 4.0) *
                   sqrt((double)(xAbs / winTotalwidth )));
}




/******************************Public*Routine******************************\
* genTex
*
* Generate a mesh representing a frame of the flag.  The phase, sinAngle,
* is a global variable.
*
\**************************************************************************/
BOOL genTex(MESH *winMesh)
{
    POINT3D pos;
    POINT3D pts[4];
    FLOAT w, h;
    int i;

    if( !newMesh(winMesh, IPREC * IPREC, IPREC * IPREC) )
        return FALSE;

// Width and height of each face

    w = (winTotalwidth) / (FLOAT)(IPREC + 1);
    h = winTotalheight;

// Generate the mesh data.  At equally spaced intervals along the x-axis,
// we compute the z-position of the flag surface.

    pos.y = (FLOAT) 0.0;
    pos.z = (FLOAT) 0.0;

    for (i = 0, pos.x = xTrans; i < IPREC; i++, pos.x += w) {
        int faceCount = winMesh->numFaces;

        pts[0].x = (FLOAT)pos.x; 
        pts[0].y = (FLOAT)(pos.y);   
        pts[0].z = getZpos(pos.x);

        pts[1].x = (FLOAT)pos.x;
        pts[1].y = (FLOAT)(pos.y + h);  
        pts[1].z = getZpos(pos.x);

        pts[2].x = (FLOAT)(pos.x + w);  
        pts[2].y = (FLOAT)(pos.y);  
        pts[2].z = getZpos(pos.x + w);

        pts[3].x = (FLOAT)(pos.x + w);
        pts[3].y = (FLOAT)(pos.y + h);
        pts[3].z = getZpos(pos.x + w);

    // Compute the face normal.

        ss_calcNorm(&winMesh->faces[faceCount].norm, pts + 2, pts + 1, pts);

    // Add the face to the mesh.

        winMesh->faces[faceCount].material = 0;
        winMesh->faces[faceCount].p[0] = iPtInList(winMesh, 0, pts,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[1] = iPtInList(winMesh, 0, pts + 1,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[2] = iPtInList(winMesh, 0, pts + 2,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[3] = iPtInList(winMesh, 0, pts + 3,
            &winMesh->faces[faceCount].norm, TRUE);

        winMesh->numFaces++;
    }

// Normalize the vertex normals in the mesh.

    ss_normalizeNorms(winMesh->norms, winMesh->numPoints);

    return TRUE;
}




/******************************Public*Routine******************************\
* initTexScene
*
* Initialize the screen saver.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
BOOL initTexScene()
{
    int i;
    FLOAT angleDelta;
//    FLOAT aspectRatio;

    // Initialize the transform.
/*
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-0.25, 1.0, -0.25, 1.0, 0.0, 3.0);
    glTranslatef(0.0f, 0.0f, -1.5f);
*/
    SetProjectionMatrixInfo( TRUE, 2.0f, 2.0f, 0.0f, 3.0f );

    D3DXMATRIX matView;
    D3DXMatrixTranslation(&matView, 0.0f, 0.0f, 1.5f);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Initialize and turn on lighting.
/*
    glDisable(GL_DEPTH_TEST);
*/
    // Light 0
    D3DLIGHT8 light;
    m_pd3dDevice->GetLight(0, &light);
    light.Position.x = light0Pos[0];
    light.Position.y = light0Pos[1];
    light.Position.z = light0Pos[2];
    m_pd3dDevice->SetLight(0, &light);

    // Light 1
    light.Type = D3DLIGHT_POINT;
    light.Ambient.r = light1Ambient.r;
    light.Ambient.g = light1Ambient.g;
    light.Ambient.b = light1Ambient.b;
    light.Ambient.a = light1Ambient.a;
    light.Diffuse.r = light1Diffuse.r;
    light.Diffuse.g = light1Diffuse.g;
    light.Diffuse.b = light1Diffuse.b;
    light.Diffuse.a = light1Diffuse.a;
    light.Specular.r = light1Specular.r;
    light.Specular.g = light1Specular.g;
    light.Specular.b = light1Specular.b;
    light.Specular.a = light1Specular.a;
    light.Position.x = light1Pos[0];
    light.Position.y = light1Pos[1];
    light.Position.z = light1Pos[2];
    m_pd3dDevice->SetLight(1, &light);
    m_pd3dDevice->LightEnable(1, TRUE);

    // Leave OpenGL in a state ready to accept the model view transform (we
    // are going to have the flag vary its orientation from frame to frame).
/*
    glMatrixMode(GL_MODELVIEW);
*/
    // Define orientation of polygon faces.

//    glFrontFace(GL_CW);
    //    glEnable(GL_CULL_FACE);
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG1 , D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );

    Frames = (int)((FLOAT)(MAX_FRAMES / 2) * fTesselFact);

    // Load user texture - if that fails load default texture resource
#if 0
//    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    if( ss_LoadTextureFile( &gTexFile, &gTex ) ||
        ss_LoadTextureResource( &gTexRes, &gTex) )
    {
/*        glEnable(GL_TEXTURE_2D);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
*/
        ss_SetTexture( &gTex );

    // Correct aspect ratio of flag to match image.
    //
    // The 1.4 is a correction factor to account for the length of the
    // curve that models the surface ripple of the waving flag.  This
    // factor is the length of the curve at zero phase.  It would be
    // more accurate to determine the length of the curve at each phase,
    // but this is a sufficient approximation for our purposes.

        aspectRatio = ((FLOAT) gTex.height / (FLOAT) gTex.width)
                      * (FLOAT) 1.4;

        if (aspectRatio < (FLOAT) 1.0) {
            winTotalwidth  = (FLOAT)0.75;
            winTotalheight = winTotalwidth * aspectRatio;
        } else {
            winTotalheight = (FLOAT) 0.75;
            winTotalwidth  = winTotalheight / aspectRatio;
        };
    }
#endif

    if (Frames < 5)
        Frames = 5;
    if (Frames > MAX_FRAMES)
        Frames = MAX_FRAMES;

    // Generate the geometry data (stored in the array of mesh structures),
    // for each frame of the animation.  The shape of the flag is varied by
    // changing the global variable sinAngle.

    angleDelta = (FLOAT)(2.0 * PI) / (FLOAT)Frames;
    sinAngle = (FLOAT) 0.0;

    for (i = 0; i < Frames; i++) {
        if( !genTex(&winMesh[i]) )
            return FALSE;
        sinAngle += angleDelta;
    }
    return TRUE;
}




/******************************Public*Routine******************************\
* delTexScene
*
* Cleanup the data associated with this screen saver.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
void delTexScene()
{
    int i;

    for (i = 0; i < Frames; i++)
        delMesh(&winMesh[i]);

    // Delete the texture
    ss_DeleteTexture( &gTex );
}




/******************************Public*Routine******************************\
* updateTexScene
*
* Generate a scene by taking one of the meshes and rendering it with
* OpenGL.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
void updateTexScene(int flags, FLOAT fElapsedTime)
{
    MESH *mesh;
    static double mxrot = 23.0;
    static double myrot = 23.0;
    static double mzrot = 5.7;
    static double mxrotInc = 0.0;
    static double myrotInc = 3.0;
    static double mzrotInc = 0.0;
    static int frameNum = 0;
    static FLOAT fFrameNum = 0.0f;
    if( fElapsedTime > 0.25f )
        fElapsedTime = 0.25f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
/*
    MFACE *faces;
    int i;
    POINT3D *pp;
    POINT3D *pn;
    int lastC, lastD;
    int aOffs, bOffs, cOffs, dOffs;
    int a, b;
*/
    FLOAT s = (FLOAT) 0.0;
    FLOAT ds;

// In addition to having the flag wave (an effect acheived by switching
// meshes from frame to frame), the flag changes its orientation from
// frame to frame.  This is done by applying a model view transform.
    D3DXMATRIX mat1, mat2, mat3, matFinal;
    D3DXMatrixRotationX(&mat1, D3DXToRadian((FLOAT)mxrot));
    D3DXMatrixRotationY(&mat2, D3DXToRadian((FLOAT)myrot));
    D3DXMatrixRotationZ(&mat3, D3DXToRadian((FLOAT)mzrot));
    matFinal = mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matFinal );
    
// Divide the texture into IPREC slices.  ds is the texture coordinate
// delta we apply as we move along the x-axis.

    ds = (FLOAT)1.0 / (FLOAT)IPREC;

// Setup the material property of the flag.  The material property, light
// properties, and polygon orientation will interact with the texture.

    curMatl = 0;

    myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, (FLOAT *) &flagColors[0]);
    myglMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, (FLOAT *) &matlBrightSpecular);
    myglMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, (FLOAT) 60.0);

// Pick the mesh for the current frame.

    mesh = &winMesh[frameNum];

// Take the geometry data is the mesh and convert it to a single OpenGL
// quad strip.  If smooth shading is required, use the vertex normals stored
// in the mesh.  Otherwise, use the face normals.
//
// As we define each vertex, we also define a corresponding vertex and
// texture coordinate.

//    glBegin(GL_QUAD_STRIP);
#if 0
    pp = mesh->pts;
    pn = mesh->norms;

    for (i = 0, faces = mesh->faces, lastC = faces->p[0], lastD = faces->p[1];
         i < mesh->numFaces; i++, faces++) {

        a = faces->p[0];
        b = faces->p[1];

        if (!bSmoothShading) {
            // Since flag is a single quad strip, this isn't needed.
            // But lets keep it in case we ever change to a more
            // complex model (ie., one that uses more than one quad
            // strip).
            #if 0
            if ((a != lastC) || (b != lastD)) {
/*
                glNormal3fv((FLOAT *)&(faces - 1)->norm);

                glTexCoord2f(s, (FLOAT) 0.0);
                glVertex3fv((FLOAT *)((char *)pp + 
                            (lastC << 3) + (lastC << 2)));
                glTexCoord2f(s, (FLOAT) 1.0);
                glVertex3fv((FLOAT *)((char *)pp + 
                            (lastD << 3) + (lastD << 2)));
*/
                s += ds;
/*
                glEnd();
                glBegin(GL_QUAD_STRIP);
*/
            }
            #endif

            if (faces->material != curMatl) {
                curMatl = faces->material;
/*
                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,
                             (FLOAT *) &matlNoSpecular);
                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (FLOAT *) &flagColors[curMatl]);
*/
            }
/*
            glNormal3fv((FLOAT *)&faces->norm);
            glTexCoord2f(s, (FLOAT) 0.0);
            glVertex3fv((FLOAT *)((char *)pp + (a << 3) + (a << 2)));
            glTexCoord2f(s, (FLOAT) 1.0);
            glVertex3fv((FLOAT *)((char *)pp + (b << 3) + (b << 2)));
*/
            s += ds;
        } else {

            aOffs = (a << 3) + (a << 2);
            bOffs = (b << 3) + (b << 2);

            if (faces->material != curMatl) {
                curMatl = faces->material;
/*
                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,
                             (FLOAT *) &matlNoSpecular);
                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (FLOAT *) &flagColors[curMatl]);
*/
            }
/*
            glTexCoord2f(s, (FLOAT) 0.0);
            glNormal3fv((FLOAT *)((char *)pn + aOffs));
            glVertex3fv((FLOAT *)((char *)pp + aOffs));
            glTexCoord2f(s, (FLOAT) 1.0);
            glNormal3fv((FLOAT *)((char *)pn + bOffs));
            glVertex3fv((FLOAT *)((char *)pp + bOffs));
*/
            s += ds;
        }

        lastC = faces->p[2];
        lastD = faces->p[3];
    }

    if (!bSmoothShading) {
/*
        glNormal3fv((FLOAT *)&(faces - 1)->norm);
        glTexCoord2f(s, (FLOAT) 0.0);
        glVertex3fv((FLOAT *)((char *)pp + (lastC << 3) + (lastC << 2)));
        glTexCoord2f(s, (FLOAT) 1.0);
        glVertex3fv((FLOAT *)((char *)pp + (lastD << 3) + (lastD << 2)));
*/
    } else {
        cOffs = (lastC << 3) + (lastC << 2);
        dOffs = (lastD << 3) + (lastD << 2);
/*
        glTexCoord2f(s, (FLOAT) 0.0);
        glNormal3fv((FLOAT *)((char *)pn + cOffs));
        glVertex3fv((FLOAT *)((char *)pp + cOffs));
        glTexCoord2f(s, (FLOAT) 1.0);
        glNormal3fv((FLOAT *)((char *)pn + dOffs));
        glVertex3fv((FLOAT *)((char *)pp + dOffs));
*/
    }

//    glEnd();
#endif
    {
        HRESULT hr;
        WORD indexArray[4];
        MYVERTEX2 vertexArray[4];

        m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX2 );

        indexArray[0] = 0;
        indexArray[1] = 1;
        indexArray[2] = 2;
        indexArray[3] = 3;

        for( int iFace = 0; iFace < mesh->numFaces; iFace++ )
        {
            vertexArray[0].p = mesh->pts[ mesh->faces[iFace].p[0] ];
            vertexArray[1].p = mesh->pts[ mesh->faces[iFace].p[1] ];
            vertexArray[2].p = mesh->pts[ mesh->faces[iFace].p[2] ];
            vertexArray[3].p = mesh->pts[ mesh->faces[iFace].p[3] ];

            vertexArray[0].tu = s; vertexArray[0].tv = 1.0f;
            vertexArray[1].tu = s; vertexArray[1].tv = 0.0f;
            vertexArray[2].tu = s+ds; vertexArray[2].tv = 1.0f;
            vertexArray[3].tu = s+ds; vertexArray[3].tv = 0.0f;
            s += ds;

            if( bSmoothShading )
            {
                vertexArray[0].n = mesh->norms[ mesh->faces[iFace].p[0] ];
                vertexArray[1].n = mesh->norms[ mesh->faces[iFace].p[1] ];
                vertexArray[2].n = mesh->norms[ mesh->faces[iFace].p[2] ];
                vertexArray[3].n = mesh->norms[ mesh->faces[iFace].p[3] ];
            }
            else
            {
                vertexArray[0].n = mesh->faces[iFace].norm;
                vertexArray[1].n = mesh->faces[iFace].norm;
                vertexArray[2].n = mesh->faces[iFace].norm;
                vertexArray[3].n = mesh->faces[iFace].norm;
            }

            hr = m_pd3dDevice->DrawIndexedPrimitiveUP( D3DPT_TRIANGLESTRIP, 0,
                4, 2, indexArray, D3DFMT_INDEX16, vertexArray, sizeof(MYVERTEX2) );
        }
    }

// Transfer the image to the floating OpenGL window.

// Determine the flag orientation for the next frame.
// What we are doing is an oscillating rotation about the y-axis
// (mxrotInc and mzrotInc are currently 0).


    mxrot += mxrotInc * fTimeFactor;
    myrot += myrotInc * fTimeFactor;
    mzrot += mzrotInc * fTimeFactor;

    if ((myrot < -65.0 && myrotInc < 0) || (myrot > 25.0 && myrotInc > 0))
        myrotInc = -myrotInc;

//    frameNum++;
    fFrameNum += fTimeFactor;
    frameNum = (INT)fFrameNum;
    if (frameNum >= Frames)
    {
        fFrameNum = 0.0f;
        frameNum = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\genwin2.cpp ===
/******************************Module*Header*******************************\
* Module Name: genwin2.c
*
* The new Windows style of the 3D Flying Objects screen saver.
*
* Texture maps .BMP files onto a simulation of a flag waving in the breeze.
*
* Copyright (c) 2001 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "resource.h"
#include "mesh.h"


enum STATE
{
    S_FREE,
    S_MOVETOORIGIN,
    S_FADETOCOLOR,
    S_PAUSE,
    S_FADEFROMCOLOR
};

#define TIME_FREE 10.0f
#define TIME_FADETOCOLOR 1.0f
#define TIME_PAUSE 5.0f
#define TIME_FADEFROMCOLOR 1.0f
// Note: There's no TIME_MOVETOORIGIN since that takes a variable amt of time.

const FLOAT winTotalwidth = (FLOAT)0.75;
const FLOAT winTotalheight = (FLOAT)0.75;

#define MAX_FRAMES 20

// IPREC is the number of faces in the mesh that models the flag.
#define IPREC   35

static int Frames = 10;
static MESH winMesh[MAX_FRAMES];
static FLOAT sinAngle = (FLOAT)0.0;
static FLOAT xTrans = (FLOAT)0.0;

// Material properties
static RGBA matlBrightSpecular = {1.0f, 1.0f, 1.0f, 1.0f};

// Lighting properties
static FLOAT light0Pos[] = {-15.0f, 0.0f, -10.0f};

                           
                           
/******************************Public*Routine******************************\
* iPtInList
*
* Add a vertex and its normal to the mesh.  If the vertex already exists,
* add in the normal to the existing normal (we to accumulate the average
* normal at each vertex).  Normalization of the normals is the
* responsibility of the caller.
*
\**************************************************************************/
static int iPtInList(MESH *mesh, int start, 
                     POINT3D *p, POINT3D *norm, BOOL blend)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    if (blend) {
        for (i = start; i < mesh->numPoints; i++, pts++) {
            if ((pts->x == p->x) && (pts->y == p->y) && (pts->z == p->z)) {
                mesh->norms[i].x += norm->x;
                mesh->norms[i].y += norm->y;
                mesh->norms[i].z += norm->z;
                return i;
            }
        }
    } else {
        i = mesh->numPoints;
    }

    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}




/******************************Public*Routine******************************\
* getZpos
*
* Get the z-position (depth) of the "wavy" flag component at the given x.
*
* The function used to model the wave is:
*
*        1/2
*   z = x    * sin((2*PI*x + sinAngle) / 8)
*
* The shape of the wave varies from frame to frame by changing the
* phase, sinAngle.
*
\**************************************************************************/
static FLOAT getZpos(FLOAT x)
{
    FLOAT xAbs = x - xTrans;
    FLOAT angle = sinAngle + ((FLOAT) (2.0 * PI) * (xAbs / winTotalwidth));

    xAbs = winTotalwidth - xAbs;

    return (FLOAT)(-(sin((double)angle) / 8.0) *
                   sqrt((double)(xAbs / winTotalwidth )));
}




/******************************Public*Routine******************************\
* genTex
*
* Generate a mesh representing a frame of the flag.  The phase, sinAngle,
* is a global variable.
*
\**************************************************************************/
static BOOL genTex(MESH *winMesh)
{
    POINT3D pos;
    POINT3D pts[4];
    FLOAT w, h;
    int i;

    if( !newMesh(winMesh, IPREC * IPREC, IPREC * IPREC) )
        return FALSE;

    // Width and height of each face
    w = (winTotalwidth) / (FLOAT)(IPREC + 1);
    h = winTotalheight;

    // Generate the mesh data.  At equally spaced intervals along the x-axis,
    // we compute the z-position of the flag surface.

    pos.y = (FLOAT) 0.0;
    pos.z = (FLOAT) 0.0;

    for (i = 0, pos.x = xTrans; i < IPREC; i++, pos.x += w) {
        int faceCount = winMesh->numFaces;

        pts[0].x = (FLOAT)pos.x; 
        pts[0].y = (FLOAT)(pos.y);   
        pts[0].z = getZpos(pos.x);

        pts[1].x = (FLOAT)pos.x;
        pts[1].y = (FLOAT)(pos.y + h);  
        pts[1].z = getZpos(pos.x);

        pts[2].x = (FLOAT)(pos.x + w);  
        pts[2].y = (FLOAT)(pos.y);  
        pts[2].z = getZpos(pos.x + w);

        pts[3].x = (FLOAT)(pos.x + w);
        pts[3].y = (FLOAT)(pos.y + h);
        pts[3].z = getZpos(pos.x + w);

        // Compute the face normal.
        ss_calcNorm(&winMesh->faces[faceCount].norm, pts + 2, pts + 1, pts);

        // Add the face to the mesh.
        winMesh->faces[faceCount].material = 0;
        winMesh->faces[faceCount].p[0] = iPtInList(winMesh, 0, pts,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[1] = iPtInList(winMesh, 0, pts + 1,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[2] = iPtInList(winMesh, 0, pts + 2,
            &winMesh->faces[faceCount].norm, TRUE);
        winMesh->faces[faceCount].p[3] = iPtInList(winMesh, 0, pts + 3,
            &winMesh->faces[faceCount].norm, TRUE);

        winMesh->numFaces++;
    }

    // Normalize the vertex normals in the mesh.
    ss_normalizeNorms(winMesh->norms, winMesh->numPoints);

    return TRUE;
}




/******************************Public*Routine******************************\
* initWin2Scene
*
* Initialize the screen saver.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
BOOL initWin2Scene()
{
    int i;
    FLOAT angleDelta;

    SetProjectionMatrixInfo( TRUE, 2.0f, 2.0f, 0.0f, 3.0f );

    D3DXMATRIX matView;
    D3DXMatrixTranslation(&matView, -0.17f, -0.04f, 1.5f);
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Adjust position of light 0
    D3DLIGHT8 light;
    m_pd3dDevice->GetLight(0, &light);
    light.Position.x = light0Pos[0];
    light.Position.y = light0Pos[1];
    light.Position.z = light0Pos[2];
    m_pd3dDevice->SetLight(0, &light);

    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE);
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP, D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    
    Frames = MAX_FRAMES;

    // Generate the geometry data (stored in the array of mesh structures),
    // for each frame of the animation.  The shape of the flag is varied by
    // changing the global variable sinAngle.
    angleDelta = (FLOAT)(2.0 * PI) / (FLOAT)Frames;
    sinAngle = (FLOAT) 0.0;
    for (i = 0; i < Frames; i++) {
        if( !genTex(&winMesh[i]) )
            return FALSE;
        sinAngle += angleDelta;
    }

    return TRUE;
}




/******************************Public*Routine******************************\
* delWin2Scene
*
* Cleanup the data associated with this screen saver.
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
void delWin2Scene()
{
    int i;
    for (i = 0; i < Frames; i++)
        delMesh(&winMesh[i]);
}




/******************************Public*Routine******************************\
* updateWin2Scene
*
* Generate a scene by taking one of the meshes and rendering it
*
* This function is exported to the main module in ss3dfo.c.
*
\**************************************************************************/
void updateWin2Scene(int flags, FLOAT fElapsedTime)
{
    MESH *pMesh;
    static double mxrot = 40.0;
    static double myrot = 0;
    static double mzrot = -12.0;
    static int frameNum = 0;
    static FLOAT fFrameNum = (FLOAT)Frames;
    FLOAT s = 0.0f;
    FLOAT ds;
    static FLOAT s_fTime = 0.0f;
    static FLOAT s_fTimeLastChange = 0.0f;
    static FLOAT s_fTimeNextChange = TIME_FREE;
    static STATE s_state = S_FREE;
    FLOAT fBeta;
    if( fElapsedTime > 0.25f )
        fElapsedTime = 0.25f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    HRESULT hr;

    s_fTime += fElapsedTime;
    if( s_fTimeNextChange != -1.0f && s_fTime > s_fTimeNextChange )
    {
        // Handle state transitions
        s_fTimeLastChange = s_fTime;
        switch( s_state )
        {
        case S_FREE:
            s_state = S_MOVETOORIGIN;
            g_bMoveToOrigin = TRUE;
            s_fTimeNextChange = -1.0f;
            break;
        case S_MOVETOORIGIN:
            s_state = S_FADETOCOLOR;
            s_fTimeNextChange = s_fTime + TIME_FADETOCOLOR;
            break;
        case S_FADETOCOLOR:
            s_state = S_PAUSE;
            s_fTimeNextChange = s_fTime + TIME_PAUSE;
            break;
        case S_PAUSE:
            s_state = S_FADEFROMCOLOR;
            s_fTimeNextChange = s_fTime + TIME_FADEFROMCOLOR;
            break;
        case S_FADEFROMCOLOR:
            s_state = S_FREE;
            s_fTimeNextChange = s_fTime + TIME_FREE;
            g_bMoveToOrigin = FALSE;
            break;
        }
    }

    fBeta = 0.0f;

    // Handle state processing
    switch( s_state )
    {
    case S_MOVETOORIGIN:
        if( g_bAtOrigin && frameNum == 0)
            s_fTimeNextChange = s_fTime; // provoke state change next time
        break;
    case S_FADETOCOLOR:
        fBeta = (s_fTime - s_fTimeLastChange) / TIME_FADETOCOLOR;
        break;
    case S_PAUSE:
        fBeta = 1.0f;
        break;
    case S_FADEFROMCOLOR:
        fBeta = 1.0f - ( (s_fTime - s_fTimeLastChange) / TIME_FADEFROMCOLOR );
        break;
    }

    if( fBeta != 0.0f )
    {
        // Render background logo
        MYVERTEX3 v[4];
        FLOAT fLeft = g_pFloatRect->xMin - g_xScreenOrigin;
        FLOAT fRight = fLeft + g_pFloatRect->xSize;
        FLOAT fBottom = g_pFloatRect->yMin - g_yScreenOrigin;
        FLOAT fTop = g_pFloatRect->yMin + g_pFloatRect->ySize;
        DWORD dwColor = D3DXCOLOR( 1.0f, 1.0f, 1.0f, fBeta );
        v[0].p = D3DXVECTOR3(fLeft, fBottom, 0.9f); v[0].rhw = 0.1f; v[0].dwDiffuse = dwColor; v[0].tu = 0.0f; v[0].tv = 0.0f;
        v[1].p = D3DXVECTOR3(fRight, fBottom, 0.9f); v[1].rhw = 0.1f; v[1].dwDiffuse = dwColor; v[1].tu = 1.0f; v[1].tv = 0.0f;
        v[2].p = D3DXVECTOR3(fLeft, fTop, 0.9f); v[2].rhw = 0.1f; v[2].dwDiffuse = dwColor; v[2].tu = 0.0f; v[2].tv = 1.0f;
        v[3].p = D3DXVECTOR3(fRight, fTop, 0.9f); v[3].rhw = 0.1f; v[3].dwDiffuse = dwColor; v[3].tu = 1.0f; v[3].tv = 1.0f;

        hr = m_pd3dDevice->SetTexture( 0, g_pDeviceObjects->m_pTexture2 );
        hr = m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX3 );
        hr = m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(MYVERTEX3) );
    }
    m_pd3dDevice->SetTexture( 0, g_pDeviceObjects->m_pTexture );


    D3DXMATRIX mat1, mat2, mat3, mat4, matFinal;
    D3DXMatrixRotationX(&mat1, D3DXToRadian((FLOAT)mxrot));
    D3DXMatrixRotationY(&mat2, D3DXToRadian((FLOAT)myrot));
    D3DXMatrixRotationZ(&mat3, D3DXToRadian((FLOAT)mzrot));
    D3DXMatrixScaling( &mat4, 0.82f, 0.92f, 0.82f );
    matFinal = mat4 * mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD, &matFinal );
    
    // Divide the texture into IPREC slices.  ds is the texture coordinate
    // delta we apply as we move along the x-axis.
    ds = (FLOAT)1.0 / (FLOAT)IPREC;

    // Setup the material property of the flag.  The material property, light
    // properties, and polygon orientation will interact with the texture.
    myglMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, (FLOAT *) &matlBrightSpecular);
    myglMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, (FLOAT) 40.0);

    FLOAT fColor[4];
    fColor[0] = 1.0f;
    fColor[1] = 1.0f;
    fColor[2] = 1.0f;
    fColor[3] = 1.0f - fBeta; // Adjust flag alpha so it fades when showing logo
    if( fColor[3] != 0.0f )
    {
        // Render flag
        myglMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, fColor);
        pMesh = &winMesh[frameNum];

        INT numPrims = 0;
        INT numIndices = 0;
        INT numVertices = 0;
        WORD iVertexA, iVertexB, iVertexC, iVertexD;
        INT a,b,c,d;
        MFACE *faces;

        WORD* i;
        MYVERTEX2* v;
        hr = m_pVB2->Lock( 0, 0, (BYTE**)&v, 0 );
        hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

        faces = pMesh->faces;
        for( int iFace = 0; iFace < pMesh->numFaces; iFace++ )
        {
            a = faces[iFace].p[0];
            b = faces[iFace].p[1];
            c = faces[iFace].p[2];
            d = faces[iFace].p[3];

            v[numVertices].p = pMesh->pts[a];
            v[numVertices].n = bSmoothShading ? -pMesh->norms[a] : -faces[iFace].norm;
            v[numVertices].tu = s; v[numVertices].tv = 1.0f;
            iVertexA = numVertices++;
            v[numVertices].p = pMesh->pts[b];
            v[numVertices].n = bSmoothShading ? -pMesh->norms[b] : -faces[iFace].norm;
            v[numVertices].tu = s; v[numVertices].tv = 0.0f;
            iVertexB = numVertices++;
            v[numVertices].p = pMesh->pts[c];
            v[numVertices].n = bSmoothShading ? -pMesh->norms[c] : -faces[iFace].norm;
            v[numVertices].tu = s+ds; v[numVertices].tv = 1.0f;
            iVertexC = numVertices++;
            v[numVertices].p = pMesh->pts[d];
            v[numVertices].n = bSmoothShading ? -pMesh->norms[d] : -faces[iFace].norm;
            v[numVertices].tu = s+ds; v[numVertices].tv = 0.0f;
            iVertexD = numVertices++;

            s += ds;

            i[numIndices++] = iVertexA;
            i[numIndices++] = iVertexB;
            i[numIndices++] = iVertexC;
            numPrims++;
            i[numIndices++] = iVertexC;
            i[numIndices++] = iVertexB;
            i[numIndices++] = iVertexD;
            numPrims++;
        }        

        hr = m_pVB2->Unlock();
        hr = m_pIB->Unlock();

        hr = m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX2 );
        hr = m_pd3dDevice->SetStreamSource( 0, m_pVB2, sizeof(MYVERTEX2) );
        hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

        hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
            0, numPrims );
    }

    // Don't change frame number if we're in S_FADETOCOLOR, S_PAUSE, 
    // or S_FADEFROMCOLOR, unless by some chance we're in those states
    // but framenum is not at zero (yet).
    if( frameNum != 0 ||
        s_state != S_FADETOCOLOR &&
        s_state != S_PAUSE && 
        s_state != S_FADEFROMCOLOR )
    {
        fFrameNum -= fTimeFactor;
        frameNum = (INT)fFrameNum;
        if (frameNum < 0)
        {
            fFrameNum = (FLOAT)(Frames - 1);
            frameNum = Frames - 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\math.cpp ===
/******************************Module*Header*******************************\
* Module Name: math.c
*
* Misc. useful math utility functions.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <math.h>
#include <d3dx8.h>
#include "d3dsaver.h"
#include "FlyingObjects.h"

#define ZERO_EPS    0.00000001

POINT3D ss_ptZero(0.0f, 0.0f, 0.0f);


void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]) + mat->M[0][3];

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]) + mat->M[1][3];

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]) + mat->M[2][3];

    ptOut->x = (float) x;
    ptOut->y = (float) y;
    ptOut->z = (float) z;
}

void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat)
{
    double x, y, z;
    double len;

    x = (ptIn->x * mat->M[0][0]) + (ptIn->y * mat->M[0][1]) +
        (ptIn->z * mat->M[0][2]);

    y = (ptIn->x * mat->M[1][0]) + (ptIn->y * mat->M[1][1]) +
        (ptIn->z * mat->M[1][2]);

    z = (ptIn->x * mat->M[2][0]) + (ptIn->y * mat->M[2][1]) +
        (ptIn->z * mat->M[2][2]);

    len = (x * x) + (y * y) + (z * z);
    if (len >= ZERO_EPS)
        len = 1.0 / sqrt(len);
    else
        len = 1.0;

    ptOut->x = (float) (x * len);
    ptOut->y = (float) (y * len);
    ptOut->z = (float) (z * len);
    return;
}

void ss_matrixIdent(MATRIX *mat)
{
    mat->M[0][0] = 1.0f; mat->M[0][1] = 0.0f;
    mat->M[0][2] = 0.0f; mat->M[0][3] = 0.0f;

    mat->M[1][0] = 0.0f; mat->M[1][1] = 1.0f;
    mat->M[1][2] = 0.0f; mat->M[1][3] = 0.0f;

    mat->M[2][0] = 0.0f; mat->M[2][1] = 0.0f;
    mat->M[2][2] = 1.0f; mat->M[2][3] = 0.0f;

    mat->M[3][0] = 0.0f; mat->M[3][1] = 0.0f;
    mat->M[3][2] = 0.0f; mat->M[3][3] = 1.0f;
}

void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta)
{
    float xScale, yScale, zScale;
    float sinX, cosX;
    float sinY, cosY;
    float sinZ, cosZ;

    xScale = m->M[0][0];
    yScale = m->M[1][1];
    zScale = m->M[2][2];
    sinX = (float) sin(xTheta);
    cosX = (float) cos(xTheta);
    sinY = (float) sin(yTheta);
    cosY = (float) cos(yTheta);
    sinZ = (float) sin(zTheta);
    cosZ = (float) cos(zTheta);

    m->M[0][0] = (float) ((cosZ * cosY) * xScale);
    m->M[0][1] = (float) ((cosZ * -sinY * -sinX + sinZ * cosX) * yScale);
    m->M[0][2] = (float) ((cosZ * -sinY * cosX + sinZ * sinX) * zScale);

    m->M[1][0] = (float) (-sinZ * cosY * xScale);
    m->M[1][1] = (float) ((-sinZ * -sinY * -sinX + cosZ * cosX) * yScale);
    m->M[1][2] = (float) ((-sinZ * -sinY * cosX + cosZ * sinX) * zScale);

    m->M[2][0] = (float) (sinY * xScale);
    m->M[2][1] = (float) (cosY * -sinX * yScale);
    m->M[2][2] = (float) (cosY * cosX * zScale);
}

void ss_matrixTranslate(MATRIX *m, double xTrans, double yTrans,
                     double zTrans)
{
    m->M[0][3] = (float) xTrans;
    m->M[1][3] = (float) yTrans;
    m->M[2][3] = (float) zTrans;
}


void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 )
{
    int i, j;

    for( j = 0; j < 4; j ++ ) {
    	for( i = 0; i < 4; i ++ ) {
	    m1->M[j][i] = m2->M[j][0] * m3->M[0][i] +
			  m2->M[j][1] * m3->M[1][i] +
			  m2->M[j][2] * m3->M[2][i] +
			  m2->M[j][3] * m3->M[3][i];
	}
    }
}

void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3)
{
    float crossX, crossY, crossZ;
    float abX, abY, abZ;
    float acX, acY, acZ;
    float sqrLength;
    float invLength;

    abX = p2->x - p1->x;       // calculate p2 - p1
    abY = p2->y - p1->y;
    abZ = p2->z - p1->z;

    acX = p3->x - p1->x;       // calculate p3 - p1
    acY = p3->y - p1->y;
    acZ = p3->z - p1->z;

    crossX = (abY * acZ) - (abZ * acY);    // get cross product
    crossY = (abZ * acX) - (abX * acZ);    // (p2 - p1) X (p3 - p1)
    crossZ = (abX * acY) - (abY * acX);

    sqrLength = (crossX * crossX) + (crossY * crossY) +
                 (crossZ * crossZ);

    if (sqrLength > ZERO_EPS)
        invLength = (float) (1.0 / sqrt(sqrLength));
    else
        invLength = 1.0f;

    norm->x = crossX * invLength;
    norm->y = crossY * invLength;
    norm->z = crossZ * invLength;
}


void ss_normalizeNorm( POINT3D *n ) 
{
    float len;

    len = (n->x * n->x) + (n->y * n->y) + (n->z * n->z);
    if (len > ZERO_EPS)
        len = (float) (1.0 / sqrt(len));
    else
        len = 1.0f;

    n->x *= len;
    n->y *= len;
    n->z *= len;
}

void ss_normalizeNorms(POINT3D *p, ULONG cPts)
{
    float len;
    ULONG i;

    for (i = 0; i < cPts; i++, p++) {
        len = (p->x * p->x) + (p->y * p->y) + (p->z * p->z);
        if (len > ZERO_EPS)
            len = (float) (1.0 / sqrt(len));
        else
            len = 1.0f;

        p->x *= len;
        p->y *= len;
        p->z *= len;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\genwin.cpp ===
/******************************Module*Header*******************************\
* Module Name: genwin.c
*
* The Windows Logo style of the 3D Flying Objects screen saver.
*
* Animated 3D model of the Microsoft (R) Windows NT (TM) flag logo.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

#define WIN_TOP_BORDER      (float)0.1
#define WIN_RIGHT_BORDER    WIN_TOP_BORDER
#define WIN_CROSSBAR        (0.6522f * WIN_TOP_BORDER)
#define WIN_NUMPIECES       7
#define WIN_NUMCOLUMNS      6
#define WIN_GAP             (WIN_TOP_BORDER / 8.0f)
#define WIN_GAP_X           (2.0f * WIN_GAP)
#define WIN_HEIGHT          ((WIN_GAP * 6.0f) + \
                                (WIN_NUMPIECES * WIN_TOP_BORDER))
#define WIN_WIDTH           (0.7024f * WIN_HEIGHT)
#define WIN_THICKNESS       WIN_CROSSBAR

#define WIN_TOTALWIDTH      (WIN_TOP_BORDER * 1.1f * (float)WIN_NUMCOLUMNS + \
                             WIN_WIDTH)

#define BLOCK_TOP            0x0001
#define BLOCK_BOTTOM         0x0002
#define BLOCK_LEFT           0x0004
#define BLOCK_RIGHT          0x0008
#define BLOCK_FRONT          0x0010
#define BLOCK_BACK           0x0020
#define BLOCK_ALL            0x003f
#define DELTA_BLEND          0x2000
#define NO_BLEND             0x1000

#define CUBE_FACES          6
#define CUBE_POINTS         8

#define MAX_FRAMES 20

#define MAXPREC 15
#define S_IPREC 3

static int Frames = 10;
static MESH winMesh[MAX_FRAMES];
static MESH winStreamer[MAX_FRAMES];
static float sinAngle = 0.0f;
static float xTrans = 0.2f;
static int curMatl = 0;
static int iPrec = 10;

static RGBA matlBrightSpecular = {1.0f, 1.0f, 1.0f, 1.0f};
static RGBA matlDimSpecular = {0.3f, 0.3f, 0.3f, 1.0f};
static RGBA matlNoSpecular = {0.0f, 0.0f, 0.0f, 0.0f};
static FLOAT light0Pos[] = {20.0f, -10.0f, 20.0f, 0.0f};

static RGBA light1Ambient  = {0.0f, 0.0f, 0.0f, 0.0f};
static RGBA light1Diffuse  = {0.4f, 0.4f, 0.4f, 1.0f};
static RGBA light1Specular = {0.0f, 0.0f, 0.0f, 0.0f};
static FLOAT light1Pos[] = {-20.0f, 5.0f, 0.0f, 0.0f};

static RGBA winColors[] = {{0.3f, 0.3f, 0.3f, 1.0f},
                           {0.94f, 0.37f, 0.13f, 1.0f},    // red
                           {0.22f, 0.42f, 0.78f, 1.0f},    // blue
                           {0.35f, 0.71f, 0.35f, 1.0f},    // green
                           {0.95f, 0.82f, 0.12f, 1.0f}};   // yellow




static int iPtInList(MESH *mesh, int start, 
                     POINT3D *p, POINT3D *norm, BOOL blend)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    if (blend) {
        for (i = start; i < mesh->numPoints; i++, pts++) {
            if ((pts->x == p->x) && (pts->y == p->y) && (pts->z == p->z)) {
                mesh->norms[i].x += norm->x;
                mesh->norms[i].y += norm->y;
                mesh->norms[i].z += norm->z;
                return i;
            }
        }
    } else {
        i = mesh->numPoints;
    }
    
    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}




float getZPos(float x)
{
    float xAbs = x - xTrans;
    float angle = (float) (sinAngle + ((2.0 * PI) * (xAbs / WIN_TOTALWIDTH)));

    xAbs += (WIN_TOTALWIDTH / 2.0f);
    xAbs = WIN_TOTALWIDTH - xAbs;

    return (float)((sin((double)angle) / 4.0) * 
                   sqrt((double)(xAbs / WIN_TOTALWIDTH )));
}




void AddFace(MESH *mesh, int startBlend, POINT3D *pos, float w, float h)
{
#define FACE_VERTEX(i) \
    iPtInList(mesh, startBlend, pts + i, &mesh->faces[faceCount].norm, TRUE)

    int faceCount = mesh->numFaces;     
    int numPts = mesh->numPoints;
    POINT3D *pts = mesh->pts + numPts;
    float zLeft = getZPos(pos->x);
    float zRight = getZPos(pos->x + w);

    pts->x = (float)pos->x; 
    pts->y = (float)pos->y;   
    pts->z = zLeft; 
    pts++;

    pts->x = (float)pos->x;
    pts->y = (float)(pos->y + h);  
    pts->z = zLeft;  
    pts++;

    pts->x = (float)(pos->x + w);  
    pts->y = (float)(pos->y + h);  
    pts->z = zRight;  
    pts++;

    pts->x = (float)(pos->x + w);
    pts->y = (float)pos->y;  
    pts->z = zRight;

    pts -= 3;

    mesh->faces[faceCount].material = curMatl;
    ss_calcNorm(&mesh->faces[faceCount].norm, pts + 2, pts + 1, pts);
    mesh->faces[faceCount].p[3] = FACE_VERTEX(0);
    mesh->faces[faceCount].p[2] = FACE_VERTEX(1);
    mesh->faces[faceCount].p[1] = FACE_VERTEX(2);
    mesh->faces[faceCount].p[0] = FACE_VERTEX(3);
    mesh->numFaces++;
}




#define BLOCK_VERTEX(face, i)\
{\
    if (flags & DELTA_BLEND) {\
        mesh->faces[faceCount].p[face] = \
            iPtInList(mesh, blendStart, &pts[i], &norms[((i & 0x2) >> 1)],\
                      bBlend);\
    } else\
        mesh->faces[faceCount].p[face] = \
            iPtInList(mesh, blendStart, &pts[i],\
                      &mesh->faces[faceCount].norm, bBlend);\
}


#define DELTA_FACT  (float)10.0



void AddBlock(MESH *mesh, int blendStart, POINT3D *pos, 
              float w, float h, float d, ULONG flags)
{

    POINT3D pts[8];
    POINT3D ptsL[8];
    POINT3D ptsR[8];
    POINT3D norms[2];
    POINT3D posPrev;
    float zLeft = getZPos(pos->x);
    float zRight = getZPos(pos->x + w);
    int faceCount = mesh->numFaces;     
    BOOL bBlend = ((flags & NO_BLEND) == 0);

    flags |= DELTA_BLEND;

    pts[0].x = (float)pos->x; 
    pts[0].y = (float)(pos->y + h);   
    pts[0].z = zLeft;

    pts[1].x = (float)pos->x;
    pts[1].y = (float)(pos->y + h);  
    pts[1].z = zLeft + d;  

    pts[2].x = (float)(pos->x + w);  
    pts[2].y = (float)(pos->y + h);  
    pts[2].z = zRight + d;  

    pts[3].x = (float)(pos->x + w);
    pts[3].y = (float)(pos->y + h);
    pts[3].z = zRight;

    pts[4].x = (float)pos->x;
    pts[4].y = (float)pos->y;
    pts[4].z = zLeft;

    pts[5].x = (float)pos->x;
    pts[5].y = (float)pos->y;
    pts[5].z = zLeft + d;  

    pts[6].x = (float)(pos->x + w);  
    pts[6].y = (float)pos->y;
    pts[6].z = zRight + d;  

    pts[7].x = (float)(pos->x + w);  
    pts[7].y = (float)pos->y;
    pts[7].z = zRight;

    if (flags & DELTA_BLEND) 
    {
    	float prevW = w;
        posPrev = *pos;

        w /= DELTA_FACT;
        zRight = getZPos(pos->x + w);

        ptsL[0].x = (float)pos->x; 
        ptsL[0].y = (float)(pos->y + h);   
        ptsL[0].z = zLeft;

        ptsL[1].x = (float)pos->x;
        ptsL[1].y = (float)(pos->y + h);  
        ptsL[1].z = zLeft + d;  

        ptsL[2].x = (float)(pos->x + w);  
        ptsL[2].y = (float)(pos->y + h);  
        ptsL[2].z = zRight + d;  

        ptsL[3].x = (float)(pos->x + w);
        ptsL[3].y = (float)(pos->y + h);
        ptsL[3].z = zRight;

        ptsL[4].x = (float)pos->x;
        ptsL[4].y = (float)pos->y;
        ptsL[4].z = zLeft;

        ptsL[5].x = (float)pos->x;
        ptsL[5].y = (float)pos->y;
        ptsL[5].z = zLeft + d;  

        ptsL[6].x = (float)(pos->x + w);  
        ptsL[6].y = (float)pos->y;
        ptsL[6].z = zRight + d;  

        ptsL[7].x = (float)(pos->x + w);  
        ptsL[7].y = (float)pos->y;
        ptsL[7].z = zRight;

        pos->x += (prevW - w);
        zLeft = getZPos(pos->x);
        zRight = getZPos(pos->x + w);

        ptsR[0].x = (float)pos->x; 
        ptsR[0].y = (float)(pos->y + h);   
        ptsR[0].z = zLeft;

        ptsR[1].x = (float)pos->x;
        ptsR[1].y = (float)(pos->y + h);  
        ptsR[1].z = zLeft + d;  

        ptsR[2].x = (float)(pos->x + w);  
        ptsR[2].y = (float)(pos->y + h);  
        ptsR[2].z = zRight + d;  

        ptsR[3].x = (float)(pos->x + w);
        ptsR[3].y = (float)(pos->y + h);
        ptsR[3].z = zRight;

        ptsR[4].x = (float)pos->x;
        ptsR[4].y = (float)pos->y;
        ptsR[4].z = zLeft;

        ptsR[5].x = (float)pos->x;
        ptsR[5].y = (float)pos->y;
        ptsR[5].z = zLeft + d;  

        ptsR[6].x = (float)(pos->x + w);  
        ptsR[6].y = (float)pos->y;
        ptsR[6].z = zRight + d;  

        ptsR[7].x = (float)(pos->x + w);  
        ptsR[7].y = (float)pos->y;
        ptsR[7].z = zRight;

        *pos = posPrev;

    }

    if (flags & BLOCK_TOP) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[0], &pts[1], &pts[2]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[0], &ptsL[1], &ptsL[2]);
            ss_calcNorm(&norms[1], &ptsR[0], &ptsR[1], &ptsR[2]);
        }
        BLOCK_VERTEX(0, 0);
        BLOCK_VERTEX(1, 1);
        BLOCK_VERTEX(2, 2);
        BLOCK_VERTEX(3, 3);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_BOTTOM) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[4], &pts[7], &pts[6]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[4], &ptsL[7], &ptsL[6]);
            ss_calcNorm(&norms[1], &ptsR[4], &ptsR[7], &ptsR[6]);
        }
        BLOCK_VERTEX(0, 4);
        BLOCK_VERTEX(1, 7);
        BLOCK_VERTEX(2, 6);
        BLOCK_VERTEX(3, 5);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_LEFT) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[1], &pts[0], &pts[4]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[1], &ptsL[0], &ptsL[4]);
            ss_calcNorm(&norms[1], &ptsR[1], &ptsR[0], &ptsR[4]);
        }
        BLOCK_VERTEX(0, 1);
        BLOCK_VERTEX(1, 0);
        BLOCK_VERTEX(2, 4);
        BLOCK_VERTEX(3, 5);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_RIGHT) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[3], &pts[2], &pts[6]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[3], &ptsL[2], &ptsL[6]);
            ss_calcNorm(&norms[1], &ptsR[3], &ptsR[2], &ptsR[6]);
        }
        BLOCK_VERTEX(0, 3);
        BLOCK_VERTEX(1, 2);
        BLOCK_VERTEX(2, 6);
        BLOCK_VERTEX(3, 7);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_FRONT) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[0], &pts[3], &pts[7]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[0], &ptsL[3], &ptsL[7]);
            ss_calcNorm(&norms[1], &ptsR[0], &ptsR[3], &ptsR[7]);
        }
        BLOCK_VERTEX(0, 0);
        BLOCK_VERTEX(1, 3);
        BLOCK_VERTEX(2, 7);
        BLOCK_VERTEX(3, 4);
        faceCount++;
        mesh->numFaces++;
    }

    if (flags & BLOCK_BACK) {
        mesh->faces[faceCount].material = curMatl;
        ss_calcNorm(&mesh->faces[faceCount].norm, &pts[1], &pts[5], &pts[6]);
        if (flags & DELTA_BLEND) {
            ss_calcNorm(&norms[0], &ptsL[1], &ptsL[5], &ptsL[6]);
            ss_calcNorm(&norms[1], &ptsR[1], &ptsR[5], &ptsR[6]);
        }
        BLOCK_VERTEX(0, 1);
        BLOCK_VERTEX(1, 5);
        BLOCK_VERTEX(2, 6);
        BLOCK_VERTEX(3, 2);
        mesh->numFaces++;
    }

}




BOOL genWin(MESH *winMesh, MESH *winStreamer)
{
    POINT3D pos, posCenter;
    float w, h, d;
    float wMax, hMax;
    float xpos;
    int i, j, prec;
    int startBlend;

    if( !newMesh(winMesh, CUBE_FACES * iPrec * 20, CUBE_POINTS * iPrec * 20) )
        return FALSE;

    //
    // create window frame
    //

    w = (WIN_WIDTH - WIN_TOP_BORDER) / (float)iPrec;
    h = (float)WIN_TOP_BORDER;
    d = (float)WIN_THICKNESS;

    // draw top and bottom portions

    pos.y = 0.0f;
    pos.z = 0.0f;

    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints; 
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);
    pos.x = xTrans;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_LEFT | NO_BLEND);

    pos.y = WIN_HEIGHT - WIN_TOP_BORDER;
    pos.z = 0.0f;

    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < iPrec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);
    pos.x = xTrans;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_LEFT | NO_BLEND);
    
    // draw middle horizontal portions

    prec = (iPrec / 2);
    w = (WIN_WIDTH - WIN_TOP_BORDER - WIN_CROSSBAR) / 2.0f;
    w /= (float)prec;
    h = WIN_CROSSBAR;
    pos.y = (WIN_HEIGHT - WIN_CROSSBAR) / 2.0f;
    pos.z = 0.0f;

    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xTrans, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);

    xpos = pos.x + WIN_CROSSBAR;

    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < prec; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);

    pos.x = xTrans;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_LEFT | NO_BLEND);


    // Draw thick right-hand edge of frame

    pos.x = xpos = xTrans + WIN_WIDTH - WIN_RIGHT_BORDER;
    pos.y = 0.0f;
    pos.z = 0.0f;
    w = WIN_RIGHT_BORDER / (float)S_IPREC;
    h = WIN_HEIGHT;

    AddBlock(winMesh, winMesh->numPoints, &pos, w, h, d, BLOCK_LEFT);

    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_FRONT);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BACK);
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_TOP);
    pos.y = WIN_HEIGHT;
    for (i = 0, pos.x = xpos, startBlend = winMesh->numPoints;
         i < S_IPREC; i++, pos.x += w)
        AddBlock(winMesh, startBlend, &pos, w, h, d, BLOCK_BOTTOM);

    pos.y = 0.0f;
    pos.x = xTrans + WIN_WIDTH - w;
    AddBlock(winMesh, winMesh->numPoints, &pos, w, h, d, BLOCK_RIGHT);

    // draw middle-vertical portion of frame

    pos.x = xTrans + (WIN_WIDTH - WIN_RIGHT_BORDER) / 2.0f - (WIN_CROSSBAR / 2.0f);
    pos.y = WIN_TOP_BORDER;
    pos.z = 0.0f;
    w = WIN_CROSSBAR;
    h = WIN_HEIGHT - 2.0f * WIN_TOP_BORDER;
    AddBlock(winMesh, 0, &pos, w, h, d, BLOCK_ALL | NO_BLEND);

    //
    // add the panels
    //

    w = (WIN_WIDTH - WIN_RIGHT_BORDER - WIN_CROSSBAR) / 2.0f;
    h = (WIN_HEIGHT - 2.0f * WIN_TOP_BORDER - WIN_CROSSBAR) / 2.0f;

    w /= (float)(iPrec / 2);

    curMatl = 2;
    pos.x = xTrans;
    pos.y = WIN_TOP_BORDER;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }
    curMatl = 4;
    pos.x += WIN_CROSSBAR;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }

    curMatl = 1;
    pos.x = xTrans;
    pos.y = WIN_TOP_BORDER + h + WIN_CROSSBAR;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }
    curMatl = 3;
    pos.x += WIN_CROSSBAR;
    for (i = 0, startBlend = winMesh->numPoints; i < iPrec / 2; i++) {
        AddFace(winMesh, startBlend, &pos, w, h);
        pos.x += w;
    }

    ss_normalizeNorms(winMesh->norms, winMesh->numPoints);

    if( !newMesh(winStreamer, CUBE_FACES * WIN_NUMPIECES * WIN_NUMCOLUMNS,
            CUBE_POINTS * WIN_NUMPIECES * WIN_NUMCOLUMNS) )
    {
        return FALSE;
    }

    h = hMax = WIN_TOP_BORDER;
    w = wMax = WIN_TOP_BORDER * 1.1f;

    posCenter.x = pos.x = xTrans - wMax - WIN_GAP_X;
    posCenter.y = pos.y = 0.0f;

    for (i = 0; i < WIN_NUMCOLUMNS; i++) {
        for (j = 0; j < WIN_NUMPIECES; j++) {
            if (((j % 3) == 0) || (i == 0))
                curMatl = 0;
            else if (j < 3)
                curMatl = 2;
            else
                curMatl = 1;
            AddBlock(winStreamer, 0, &pos, w, h, d, BLOCK_ALL);
            pos.y += (hMax + WIN_GAP);
        }

        posCenter.x -= (wMax + WIN_GAP_X);
        posCenter.y = 0.0f;

        h = h * 0.8f;
        w = w * 0.8f;

        pos.x = posCenter.x;
        pos.y = posCenter.y;

        pos.x += (wMax - w) / 2.0f;
        pos.y += (hMax - h) / 2.0f;
    }    
    ss_normalizeNorms(winStreamer->norms, winStreamer->numPoints);

    return TRUE;
}




BOOL initWinScene()
{
    int i;
    float angleDelta;

    iPrec = (int)(fTesselFact * 10.5);
    if (iPrec < 5)
        iPrec = 5;
    if (iPrec > MAXPREC)
        iPrec = MAXPREC;
/*
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.0, 1.0, -0.75, 1.25, 0.0, 3.0);
*/
    SetProjectionMatrixInfo( TRUE, 2.0f, 2.0f, 0.0f, 3.0f );

/*
    glTranslatef(0.0f, 0.0f, -1.5f);
*/
    D3DXMATRIX matView1, matReverseX, matView2;
    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );
    D3DXVECTOR3 vEyePt(0, 0, 1.5f);
    D3DXVECTOR3 vLookatPt(0, 0, 0);
    D3DXMatrixLookAtLH( &matView1, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixScaling( &matReverseX, -1.0f, 1.0f, 1.0f );
    matView2 = matView1 * matReverseX;
    m_pd3dDevice->SetTransform( D3DTS_VIEW, &matView2 );

    // Light 0
    D3DLIGHT8 light;
    m_pd3dDevice->GetLight(0, &light);
    light.Position.x = light0Pos[0];
    light.Position.y = light0Pos[1];
    light.Position.z = light0Pos[2];
    m_pd3dDevice->SetLight(0, &light);

    // Light 1
    light.Type = D3DLIGHT_POINT;
    light.Ambient.r = light1Ambient.r;
    light.Ambient.g = light1Ambient.g;
    light.Ambient.b = light1Ambient.b;
    light.Ambient.a = light1Ambient.a;
    light.Diffuse.r = light1Diffuse.r;
    light.Diffuse.g = light1Diffuse.g;
    light.Diffuse.b = light1Diffuse.b;
    light.Diffuse.a = light1Diffuse.a;
    light.Specular.r = light1Specular.r;
    light.Specular.g = light1Specular.g;
    light.Specular.b = light1Specular.b;
    light.Specular.a = light1Specular.a;
    light.Position.x = light1Pos[0];
    light.Position.y = light1Pos[1];
    light.Position.z = light1Pos[2];
    m_pd3dDevice->SetLight(1, &light);
    m_pd3dDevice->LightEnable(1, TRUE);
    
/*
    glMatrixMode(GL_MODELVIEW);

    glFrontFace(GL_CCW);
    glEnable(GL_CULL_FACE);
*/
    
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    Frames = (int)((float)(MAX_FRAMES / 2) * fTesselFact);

    if (Frames < 5)
        Frames = 5;
    if (Frames > MAX_FRAMES)
        Frames = MAX_FRAMES;

    angleDelta = (float) ((2.0 * PI) / Frames);
    sinAngle = 0.0f;

    for (i = 0; i < Frames; i++) {
        if( !genWin(&winMesh[i], &winStreamer[i]) )
            return FALSE;
        sinAngle += angleDelta;
    }
    return TRUE;
}




void delWinScene()
{
    int i;

    for (i = 0; i < Frames; i++) {
        delMesh(&winMesh[i]);
        delMesh(&winStreamer[i]);
    }
}




void updateWinScene(int flags, FLOAT fElapsedTime)
{
    MESH *mesh;
    static double mxrot = 23.0;
    static double myrot = 23.0;
    static double mzrot = 5.7;
    static double mxrotInc = 0.0;
    static double myrotInc = 3.0;
    static double mzrotInc = 0.0;
    static FLOAT fH = 0.0f;
    static int frameNum = 0;
    static FLOAT fFrameNum = 0.0f;
    if( fElapsedTime > 0.25f )
        fElapsedTime = 0.25f;
    FLOAT fTimeFactor = fElapsedTime * 20.0f;
    D3DXMATRIX mat1, mat2, mat3, matFinal;

    if (bColorCycle) {
        ss_HsvToRgb(fH, 1.0f, 1.0f, &winColors[0] );

        fH += fTimeFactor;
        if( fH >= 360.0f )
            fH -= 360.0f;
    }

    D3DXMatrixRotationX(&mat1, D3DXToRadian((FLOAT)mxrot));
    D3DXMatrixRotationY(&mat2, D3DXToRadian((FLOAT)myrot));
    D3DXMatrixRotationZ(&mat3, D3DXToRadian((FLOAT)mzrot));
    matFinal = mat3 * mat2 * mat1 ;
    m_pd3dDevice->SetTransform( D3DTS_WORLD , &matFinal );

    curMatl = 0;

    myglMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, (FLOAT *) &winColors[0]);
    myglMaterialfv(GL_FRONT, GL_SPECULAR, (FLOAT *) &matlBrightSpecular);
    myglMaterialf(GL_FRONT, GL_SHININESS, 60.0f);

    mesh = &winMesh[frameNum];

    {
        HRESULT hr;
        MESH* pMesh = mesh;
        INT numPrims = 0;
        INT numIndices = 0;
        INT numVertices = 0;
        WORD* i;
        MYVERTEX* v;
        hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
        hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

        m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );

        for( int iFace = 0; iFace < pMesh->numFaces; iFace++ )
        {
            if (pMesh->faces[iFace].material != curMatl) 
            {
                hr = m_pVB->Unlock();
                hr = m_pIB->Unlock();

                hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
                hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

                hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
                    0, numPrims );
                numVertices = 0;
                numIndices = 0;
                numPrims = 0;
                hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
                hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

                curMatl = pMesh->faces[iFace].material;
                myglMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR,
                             (FLOAT *) &matlNoSpecular);
                myglMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (FLOAT *) &winColors[curMatl]);
    
            }
            v[numVertices+0].p = pMesh->pts[ pMesh->faces[iFace].p[0] ];
            v[numVertices+1].p = pMesh->pts[ pMesh->faces[iFace].p[1] ];
            v[numVertices+2].p = pMesh->pts[ pMesh->faces[iFace].p[2] ];
            v[numVertices+3].p = pMesh->pts[ pMesh->faces[iFace].p[3] ];

            if( bSmoothShading )
            {
                v[numVertices+0].n = pMesh->norms[ pMesh->faces[iFace].p[0] ];
                v[numVertices+1].n = pMesh->norms[ pMesh->faces[iFace].p[1] ];
                v[numVertices+2].n = pMesh->norms[ pMesh->faces[iFace].p[2] ];
                v[numVertices+3].n = pMesh->norms[ pMesh->faces[iFace].p[3] ];
            }
            else
            {
                v[numVertices+0].n = pMesh->faces[iFace].norm;
                v[numVertices+1].n = pMesh->faces[iFace].norm;
                v[numVertices+2].n = pMesh->faces[iFace].norm;
                v[numVertices+3].n = pMesh->faces[iFace].norm;
            }

            i[numIndices++] = numVertices + 0;
            i[numIndices++] = numVertices + 1;
            i[numIndices++] = numVertices + 2;
            i[numIndices++] = numVertices + 2;
            i[numIndices++] = numVertices + 0;
            i[numIndices++] = numVertices + 3;
            numVertices += 4;
            numPrims += 2;
        }
        hr = m_pVB->Unlock();
        hr = m_pIB->Unlock();

        hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
        hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

        hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
            0, numPrims );
    }

    myglMaterialfv(GL_FRONT, GL_SPECULAR, (FLOAT *) &matlDimSpecular);

    mesh = &winStreamer[frameNum];

    {
        HRESULT hr;
        MESH* pMesh = mesh;
        INT numPrims = 0;
        INT numIndices = 0;
        INT numVertices = 0;
        WORD* i;
        MYVERTEX* v;
        hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
        hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

        m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );

        for( int iFace = 0; iFace < pMesh->numFaces; iFace++ )
        {
            if (pMesh->faces[iFace].material != curMatl) 
            {
                hr = m_pVB->Unlock();
                hr = m_pIB->Unlock();

                hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
                hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

                hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
                    0, numPrims );

                numVertices = 0;
                numIndices = 0;
                numPrims = 0;
                hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
                hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

                curMatl = pMesh->faces[iFace].material;
                myglMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, 
                             (FLOAT *) &winColors[curMatl]);
    
            }
            v[numVertices+0].p = pMesh->pts[ pMesh->faces[iFace].p[0] ];
            v[numVertices+1].p = pMesh->pts[ pMesh->faces[iFace].p[1] ];
            v[numVertices+2].p = pMesh->pts[ pMesh->faces[iFace].p[2] ];
            v[numVertices+3].p = pMesh->pts[ pMesh->faces[iFace].p[3] ];

            v[numVertices+0].n = pMesh->faces[iFace].norm;
            v[numVertices+1].n = pMesh->faces[iFace].norm;
            v[numVertices+2].n = pMesh->faces[iFace].norm;
            v[numVertices+3].n = pMesh->faces[iFace].norm;

            i[numIndices++] = numVertices + 0;
            i[numIndices++] = numVertices + 1;
            i[numIndices++] = numVertices + 2;
            i[numIndices++] = numVertices + 2;
            i[numIndices++] = numVertices + 0;
            i[numIndices++] = numVertices + 3;
            numVertices += 4;
            numPrims += 2;
        }
        hr = m_pVB->Unlock();
        hr = m_pIB->Unlock();

        hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
        hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

        hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
            0, numPrims );
    }

    mxrot += mxrotInc * fTimeFactor;
    myrot += myrotInc * fTimeFactor;
    mzrot += mzrotInc * fTimeFactor;

    if ((myrot < -45.0 && myrotInc < 0) || (myrot > 45.0 && myrotInc > 0))
        myrotInc = -myrotInc;

    fFrameNum += fTimeFactor;
    frameNum = (INT)fFrameNum;
    if (frameNum >= Frames)
    {
        frameNum = 0;
        fFrameNum -= Frames; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\mesh.h ===
/******************************Module*Header*******************************\
* Module Name: mesh.h
*
* Declaration of the mesh routines.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

extern BOOL newMesh(MESH *mesh, int numFaces, int numPts);
extern void delMesh(MESH *mesh);
extern void revolveSurface(MESH *mesh, POINT3D *curve, int steps);
extern void updateObject(MESH *mesh, BOOL bSmooth);
extern void updateObject2(MESH *mesh, BOOL bSmooth);
extern void MakeList(DWORD listID, MESH *mesh);

extern VOID SetD3DDevice( LPDIRECT3DDEVICE8 pd3dDevice );
extern HRESULT RenderMesh( MESH* pMesh, BOOL bSmooth );
extern HRESULT RenderMesh2( MESH* pMesh, BOOL bSmooth );
extern HRESULT RenderMesh3( MESH* pMesh, BOOL bSmooth );
extern HRESULT RenderMesh3Backsides( MESH* pMesh, BOOL bSmooth );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\mesh.cpp ===
/******************************Module*Header*******************************\
* Module Name: mesh.c
*
* Routines to create a mesh representation of a 3D object and to turn it
* into an OpenGL description.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/
#include <stdlib.h>
#include <windows.h>
#include <D3DX8.h>
#include <string.h>
#include <math.h>
#include <d3dx8.h>
#include "D3DSaver.h"
#include "FlyingObjects.h"
#include "mesh.h"

#define ZERO_EPS    0.00000001




/******************************Public*Routine******************************\
* newMesh
*
* Allocate memory for the mesh structure to accomodate the specified number
* of points and faces.
*
\**************************************************************************/
BOOL newMesh(MESH *mesh, int numFaces, int numPts)
{
    mesh->numFaces = 0;
    mesh->numPoints = 0;

    if (numPts) {
        mesh->pts = (POINT3D*)SaverAlloc((LONG)numPts * (LONG)sizeof(POINT3D));
        if( mesh->pts == NULL ) 
            return FALSE;

        mesh->norms = (POINT3D*)SaverAlloc((LONG)numPts * (LONG)sizeof(POINT3D));
        if( mesh->norms == NULL )
            return FALSE;
    }
    mesh->faces = (MFACE*)SaverAlloc((LONG)numFaces * (LONG)sizeof(MFACE));
    if (mesh->faces == NULL )
        return FALSE;

    return TRUE;
}




/******************************Public*Routine******************************\
* delMesh
*
* Delete the allocated portions of the MESH structure.
*
\**************************************************************************/
void delMesh(MESH *mesh)
{    
    SaverFree(mesh->pts);
    SaverFree(mesh->norms);
    SaverFree(mesh->faces);
}




/******************************Public*Routine******************************\
* iPtInList
*
* Add a vertex and its normal to the mesh.  If the vertex already exists,
* add in the normal to the existing normal (we to accumulate the average
* normal at each vertex).  Normalization of the normals is the
* responsibility of the caller.
*
\**************************************************************************/
static int iPtInList(MESH *mesh, POINT3D *p, POINT3D *norm, int start)
{
    int i;
    POINT3D *pts = mesh->pts + start;

    for (i = start; i < mesh->numPoints; i++, pts++)
    {
    // If the vertices are within ZERO_EPS of each other, then its the same
    // vertex.

        if ( fabs(pts->x - p->x) < ZERO_EPS &&
             fabs(pts->y - p->y) < ZERO_EPS &&
             fabs(pts->z - p->z) < ZERO_EPS )
        {
            mesh->norms[i].x += norm->x;
            mesh->norms[i].y += norm->y;
            mesh->norms[i].z += norm->z;
            return i;
        }
    }
    
    mesh->pts[i] = *p;
    mesh->norms[i] = *norm;
    mesh->numPoints++;
    return i;
}




/******************************Public*Routine******************************\
* revolveSurface
*
* Takes the set of points in curve and fills the mesh structure with a
* surface of revolution.  The surface consists of quads made up of the
* points in curve rotated about the y-axis.  The number of increments
* in the revolution is determined by the steps parameter.
*
\**************************************************************************/
#define MAXPREC 40
void revolveSurface(MESH *mesh, POINT3D *curve, int steps)
{
    int i;
    int j;
    int facecount = 0;
    double rotation = 0.0;
    double rotInc;
    double cosVal;
    double sinVal;
    int stepsSqr;
    POINT3D norm;
    POINT3D a[MAXPREC + 1];
    POINT3D b[MAXPREC + 1];
    
    if (steps > MAXPREC)
        steps = MAXPREC;
    rotInc = (2.0 * PI) / (double)(steps - 1);
    stepsSqr = steps * steps;
    newMesh(mesh, stepsSqr, 4 * stepsSqr);

    for (j = 0; j < steps; j++, rotation += rotInc) {
        cosVal = cos(rotation);
        sinVal = sin(rotation);
        for (i = 0; i < steps; i++) {
            a[i].x = (float) (curve[i].x * cosVal + curve[i].z * sinVal);
            a[i].y = (float) (curve[i].y);
            a[i].z = (float) (curve[i].z * cosVal - curve[i].x * sinVal);
        }

        cosVal = cos(rotation + rotInc);
        sinVal = sin(rotation + rotInc);
        for (i = 0; i < steps; i++) {
            b[i].x = (float) (curve[i].x * cosVal + curve[i].z * sinVal);
            b[i].y = (float) (curve[i].y);
            b[i].z = (float) (curve[i].z * cosVal - curve[i].x * sinVal);
        }

        for (i = 0; i < (steps - 1); i++) {
            ss_calcNorm(&norm, &b[i + 1], &b[i], &a[i]);
            if ((norm.x * norm.x) + (norm.y * norm.y) + (norm.z * norm.z) < 0.9)
                ss_calcNorm(&norm, &a[i], &a[i+1], &b[i + 1]);
            mesh->faces[facecount].material = j & 7;
            mesh->faces[facecount].norm = norm;
            mesh->faces[facecount].p[0] = iPtInList(mesh, &b[i], &norm, 0);
            mesh->faces[facecount].p[1] = iPtInList(mesh, &a[i], &norm, 0);
            mesh->faces[facecount].p[2] = iPtInList(mesh, &b[i + 1], &norm, 0);
            mesh->faces[facecount].p[3] = iPtInList(mesh, &a[i + 1], &norm, 0); 
            mesh->numFaces++;
            facecount++;
        }
    }

    ss_normalizeNorms(mesh->norms, mesh->numPoints);
}




HRESULT RenderMesh3( MESH* pMesh, BOOL bSmooth )
{
    HRESULT hr;
    INT numPrims = 0;
    INT numIndices = 0;
    INT numVertices = 0;
    WORD iVertexA, iVertexB, iVertexC, iVertexD;
    INT a,b,c,d;
    MFACE *faces;

    m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );

    WORD* i;
    MYVERTEX* v;
    hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
    hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

    faces = pMesh->faces;
    for( int iFace = 0; iFace < pMesh->numFaces; iFace++ )
    {
        a = faces[iFace].p[0];
        b = faces[iFace].p[1];
        c = faces[iFace].p[2];
        d = faces[iFace].p[3];

        v[numVertices].p = pMesh->pts[a];
        v[numVertices].n = bSmooth ? pMesh->norms[a] : faces[iFace].norm;
        iVertexA = numVertices++;
        v[numVertices].p = pMesh->pts[b];
        v[numVertices].n = bSmooth ? pMesh->norms[b] : faces[iFace].norm;
        iVertexB = numVertices++;
        v[numVertices].p = pMesh->pts[c];
        v[numVertices].n = bSmooth ? pMesh->norms[c] : faces[iFace].norm;
        iVertexC = numVertices++;
        v[numVertices].p = pMesh->pts[d];
        v[numVertices].n = bSmooth ? pMesh->norms[d] : faces[iFace].norm;
        iVertexD = numVertices++;

        i[numIndices++] = iVertexA;
        i[numIndices++] = iVertexB;
        i[numIndices++] = iVertexC;
        numPrims++;
        i[numIndices++] = iVertexC;
        i[numIndices++] = iVertexB;
        i[numIndices++] = iVertexD;
        numPrims++;
    }        

    hr = m_pVB->Unlock();
    hr = m_pIB->Unlock();

    hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
    hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

    hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
        0, numPrims );
    return hr;
}




HRESULT RenderMesh3Backsides( MESH* pMesh, BOOL bSmooth )
{
    HRESULT hr;
    INT numPrims = 0;
    INT numIndices = 0;
    INT numVertices = 0;
    WORD iVertexA, iVertexB, iVertexC, iVertexD;
    INT a,b,c,d;
    MFACE *faces;

    m_pd3dDevice->SetVertexShader( D3DFVF_MYVERTEX );

    WORD* i;
    MYVERTEX* v;
    hr = m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );
    hr = m_pIB->Lock( 0, MAX_INDICES, (BYTE**)&i, 0 );

    faces = pMesh->faces;
    for( int iFace = 0; iFace < pMesh->numFaces; iFace++ )
    {
        a = faces[iFace].p[0];
        b = faces[iFace].p[1];
        c = faces[iFace].p[2];
        d = faces[iFace].p[3];

        v[numVertices].p = pMesh->pts[a];
        v[numVertices].n = bSmooth ? -pMesh->norms[a] : -faces[iFace].norm;
        iVertexA = numVertices++;
        v[numVertices].p = pMesh->pts[b];
        v[numVertices].n = bSmooth ? -pMesh->norms[b] : -faces[iFace].norm;
        iVertexB = numVertices++;
        v[numVertices].p = pMesh->pts[c];
        v[numVertices].n = bSmooth ? -pMesh->norms[c] : -faces[iFace].norm;
        iVertexC = numVertices++;
        v[numVertices].p = pMesh->pts[d];
        v[numVertices].n = bSmooth ? -pMesh->norms[d] : -faces[iFace].norm;
        iVertexD = numVertices++;

        i[numIndices++] = iVertexB;
        i[numIndices++] = iVertexA;
        i[numIndices++] = iVertexC;
        numPrims++;
        i[numIndices++] = iVertexB;
        i[numIndices++] = iVertexC;
        i[numIndices++] = iVertexD;
        numPrims++;
    }        

    hr = m_pVB->Unlock();
    hr = m_pIB->Unlock();

    hr = m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(MYVERTEX) );
    hr = m_pd3dDevice->SetIndices( m_pIB, 0 );

    hr = m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, numVertices, 
        0, numPrims );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FlyingObjects.rc
//
#define IDI_MAIN_ICON                   101
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201

#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016

#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112

#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212

#define ID_COMPLEXITY              401
#define ID_IMAGE_SIZE              402

#define ID_COL_PICK_FIRST          ID_COL_CHECKER
#define ID_COL_CHECKER             500
#define ID_COL_PER_SIDE            501
#define ID_COL_SINGLE              502
#define ID_COL_PICK_LAST           ID_COL_SINGLE
#define ID_COL_PICK_COUNT          (ID_COL_PICK_LAST-ID_COL_PICK_FIRST+1)

#define ID_COL_SMOOTH              550
#define ID_COL_TRIANGLE            551
#define ID_COL_CYCLE               552

#define ID_SPIN                    600
#define ID_BLOOM                   601
#define ID_TWO_SIDED               602

#define ID_GEOM                    650

#define IDS_CONFIG_SMOOTH_COLORS        1000
#define IDS_CONFIG_TRIANGLE_COLORS      1001
#define IDS_CONFIG_CYCLE_COLORS         1002
#define IDS_CONFIG_SPIN                 1003
#define IDS_CONFIG_BLOOM                1004
#define IDS_CONFIG_SUBDIV               1005
#define IDS_CONFIG_COLOR_PICK           1006
#define IDS_CONFIG_IMAGE_SIZE           1007
#define IDS_CONFIG_GEOM                 1008
#define IDS_CONFIG_TWO_SIDED            1009

#define IDS_GEOM_FIRST                  IDS_GEOM_CUBE
#define IDS_GEOM_CUBE                   1025
#define IDS_GEOM_TETRA                  1026
#define IDS_GEOM_PYRAMIDS               1027
#define IDS_GEOM_CYLINDER               1028
#define IDS_GEOM_SPRING                 1029
#define IDS_GEOM_LAST                   IDS_GEOM_SPRING
#define IDS_GEOM_COUNT                  (IDS_GEOM_LAST-IDS_GEOM_FIRST+1)

#define IDS_INI_SECTION                 1051

#define IDS_WARNING             9014
#define IDS_ERROR               9015
#define IDS_BITMAP_SIZE         9016
#define IDS_BITMAP_INVALID      9017
#define IDS_SELECT_ANOTHER_BITMAP 9018
#define IDS_START_FAILED        9019
#define IDS_TEXTUREFILTER       9021
#define IDS_TEXTUREDIALOGTITLE  9022
#define IDS_BMP                 9023
#define IDS_DOTBMP              9024
#define IDS_STARDOTBMP          9025
#define IDS_RGB                 9030
#define IDS_DOTRGB              9031
#define IDS_STARDOTRGB          9032

// 3dfo

#define IDS_LOGO                1100
#define IDS_EXPLODE             1101
#define IDS_RIBBON              1102
#define IDS_2RIBBON             1103
#define IDS_SPLASH              1104
#define IDS_TWIST               1105
#define IDS_FLAG                1106

#define IDS_SAVERNAME           1107
#define IDS_OPTIONS             1108
#define IDS_OBJTYPE             1109
#define IDS_TEXTURE             1110
#define IDS_TEXTURE_FILE_OFFSET 1111
#define IDS_SIZE                1112
#define IDS_TESSELATION         1113
#define IDS_INIFILE             1114

#define DLG_SETUP_HELP          2001
#define DLG_SETUP_TYPES         2002
#define DLG_SETUP_BITMAP        2003
#define DLG_SETUP_FCOLOR        2004
#define DLG_SETUP_SMOOTH        2005
#define DLG_SETUP_CYCLE         2006
#define DLG_SETUP_ABOUT         2007
#define DLG_SETUP_TESSEL        2008
#define DLG_SETUP_SIZE          2009
#define DLG_SETUP_TEXTURE       2010
#define IDC_STATIC_TESS         2011
#define IDC_STATIC_TESS_MIN     2012
#define IDC_STATIC_TESS_MAX     2013
#define IDC_STATIC_SIZE         2014
#define IDC_STATIC_SIZE_MIN     2015
#define IDC_STATIC_SIZE_MAX     2016
#define DLG_SETUP_MONITORSETTINGS 2017

#define IDB_DEFTEX              3000
#define IDR_FLATFLAG            3001
#define IDR_WINLOGO             3002


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        154
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1055
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\texture.h ===
/******************************Module*Header*******************************\
* Module Name: texture.h
*
* Local texture processing functions
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __texture_h__
#define __texture_h__


#ifdef __cplusplus
extern "C" {
#endif

extern BOOL bVerifyDIB(LPTSTR pszFileName, ISIZE *pSize );
extern BOOL bVerifyRGB(LPTSTR pszFileName, ISIZE *pSize );

#ifdef __cplusplus
}
#endif

#endif // __texture_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\flyingobjects\texture.cpp ===
/******************************Module*Header*******************************\
* Module Name: texture.c
*
* Texture handling functions
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <time.h>
#include <windows.h>
#include <scrnsave.h>
#include <commdlg.h>
//#include <GL/gl.h>
//#include "tk.h"

//#include "scrnsave.h"  // for hMainInstance
//#include "sscommon.h"
#include <d3dx8.h>
#include "d3dsaver.h"
#include "FlyingObjects.h"
#include "texture.h"

static int VerifyTextureFile( TEXFILE *pTexFile );
static int GetTexFileType( TEXFILE *pTexFile );

static TEX_STRINGS gts = {0};
BOOL gbTextureObjects = FALSE;

static BOOL gbEnableErrorMsgs = FALSE;

/******************************Public*Routine******************************\
* ss_fOnWin95
*
* True if running on Windows 95
*
\**************************************************************************/

BOOL
ss_fOnWin95( void )
{
    // Figure out if we're on 9x
    OSVERSIONINFO osvi; 
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx( &osvi );
    return (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
}

/******************************Public*Routine******************************\
*
* ss_LoadTextureResourceStrings
*
* Load various messages and strings that are used in processing textures,
* into global TEX_STRINGS structure
*
\**************************************************************************/

BOOL
ss_LoadTextureResourceStrings()
{
    LPTSTR pszStr;

    // title for choose texture File dialog
    LoadString(NULL, IDS_TEXTUREDIALOGTITLE, gts.szTextureDialogTitle, 
                GEN_STRING_SIZE);
    LoadString(NULL, IDS_BMP, gts.szBmp, GEN_STRING_SIZE);
    LoadString(NULL, IDS_DOTBMP, gts.szDotBmp, GEN_STRING_SIZE);

    // szTextureFilter requires a little more work.  Need to assemble the file
    // name filter string, which is composed of two strings separated by a NULL
    // and terminated with a double NULL.

    LoadString(NULL, IDS_TEXTUREFILTER, gts.szTextureFilter, 
                GEN_STRING_SIZE);
    pszStr = &gts.szTextureFilter[lstrlen(gts.szTextureFilter)+1];
    LoadString(NULL, IDS_STARDOTBMP, pszStr, GEN_STRING_SIZE);
    pszStr += lstrlen(pszStr);
/*
    *pszStr++ = TEXT(';');
    LoadString(NULL, IDS_STARDOTRGB, pszStr, GEN_STRING_SIZE);
    pszStr += lstrlen(pszStr);
*/
    pszStr++;
    *pszStr = TEXT('\0');

    LoadString(NULL, IDS_WARNING, gts.szWarningMsg, MAX_PATH);
    LoadString(NULL, IDS_SELECT_ANOTHER_BITMAP, 
                gts.szSelectAnotherBitmapMsg, MAX_PATH );

    LoadString(NULL, IDS_BITMAP_INVALID, 
                gts.szBitmapInvalidMsg, MAX_PATH );
    LoadString(NULL, IDS_BITMAP_SIZE, 
                gts.szBitmapSizeMsg, MAX_PATH );

    // assumed here that all above calls loaded properly (mf: fix later)
    return TRUE;
}

/******************************Public*Routine******************************\
*
*
\**************************************************************************/

void
ss_DisableTextureErrorMsgs()
{
    gbEnableErrorMsgs = FALSE;
}

/******************************Public*Routine******************************\
*
* ss_DeleteTexture
*
\**************************************************************************/

void
ss_DeleteTexture( TEXTURE *pTex )
{
    if( pTex == NULL )
        return;

    if( gbTextureObjects && pTex->texObj ) {
//        glDeleteTextures( 1, &pTex->texObj );
        pTex->texObj = 0;
    }
    if (pTex->pal != NULL)
    {
        free(pTex->pal);
    }
    if( pTex->data )
        free( pTex->data );
}



/******************************Public*Routine******************************\
*
* ss_VerifyTextureFile
*
* Validates texture bmp or rgb file, by checking for valid pathname and
* correct format.
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Wrote it
*
*  Jul. 25, 95 : [marcfo]
*    - Suppress warning dialog box in child preview mode, as it will
*      be continuously brought up.
*
*  Dec. 12, 95 : [marcfo]
*     - Support .rgb files as well
*
*  Dec. 14, 95 : [marcfo]
*     - Change to have it only check the file path
*
\**************************************************************************/

BOOL
ss_VerifyTextureFile( TEXFILE *ptf )
{
    // Make sure the selected texture file is OK.

    TCHAR szFileName[MAX_PATH];
    PTSTR pszString;
    TCHAR szString[MAX_PATH];

    lstrcpy(szFileName, ptf->szPathName);

    if ( SearchPath(NULL, szFileName, NULL, MAX_PATH,
                     ptf->szPathName, &pszString)
       )
    {
        ptf->nOffset = (int)((ULONG_PTR)(pszString - ptf->szPathName));
        return TRUE;
    }
    else
    {
        lstrcpy(ptf->szPathName, szFileName);    // restore

        if( !ss_fOnWin95() && gbEnableErrorMsgs )
        {
            wsprintf(szString, gts.szSelectAnotherBitmapMsg, ptf->szPathName);
            MessageBox(NULL, szString, gts.szWarningMsg, MB_OK);
        }
        return FALSE;
    }
}


/******************************Public*Routine******************************\
*
* ss_SelectTextureFile
*
* Use the common dialog GetOpenFileName to get the name of a bitmap file
* for use as a texture.  This function will not return until the user
* either selects a valid bitmap or cancels.  If a valid bitmap is selected
* by the user, the global array szPathName will have the full path
* to the bitmap file and the global value nOffset will have the
* offset from the beginning of szPathName to the pathless file name.
*
* If the user cancels, szPathName and nOffset will remain
* unchanged.
*
* History:
*  10-May-1994 -by- Gilman Wong [gilmanw]
*    - Wrote it.
*  Apr. 28, 95 : [marcfo]
*    - Modified for common use
*  Dec. 12, 95 : [marcfo]
*    - Support .rgb files as well
*
\**************************************************************************/

BOOL
ss_SelectTextureFile( HWND hDlg, TEXFILE *ptf )
{
    OPENFILENAME ofn;
    TCHAR dirName[MAX_PATH];
    TEXFILE newTexFile;
    LPTSTR pszFileName = newTexFile.szPathName;
    TCHAR origPathName[MAX_PATH];
    PTSTR pszString;
    BOOL bTryAgain, bFileSelected;

//mf: 
    gbEnableErrorMsgs = TRUE;

    // Make a copy of the original file path name, so we can tell if
    // it changed or not
    lstrcpy( origPathName, ptf->szPathName );

    // Make dialog look nice by parsing out the initial path and
    // file name from the full pathname.  If this isn't done, then
    // dialog has a long ugly name in the file combo box and
    // directory will end up with the default current directory.

    if (ptf->nOffset) {
    // Separate the directory and file names.

        lstrcpy(dirName, ptf->szPathName);
        dirName[ptf->nOffset-1] = L'\0';
        lstrcpy(pszFileName, &ptf->szPathName[ptf->nOffset]);
    }
    else {
    // If nOffset is zero, then szPathName is not a full path.
    // Attempt to make it a full path by calling SearchPath.

        if ( SearchPath(NULL, ptf->szPathName, NULL, MAX_PATH,
                         dirName, &pszString) )
        {
        // Successful.  Go ahead a change szPathName to the full path
        // and compute the filename offset.

            lstrcpy(ptf->szPathName, dirName);
            ptf->nOffset = (int)((ULONG_PTR)(pszString - dirName));

        // Break the filename and directory paths apart.

            dirName[ptf->nOffset-1] = TEXT('\0');
            lstrcpy(pszFileName, pszString);
        }

    // Give up and use the Windows system directory.

        else
        {
            if( !GetWindowsDirectory(dirName, MAX_PATH) )
                dirName[0] = TEXT('\0');
            lstrcpy(pszFileName, ptf->szPathName);
        }
    }

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = gts.szTextureFilter;
    ofn.lpstrCustomFilter = (LPTSTR) NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = pszFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = (LPTSTR) NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = dirName;
    ofn.lpstrTitle = gts.szTextureDialogTitle;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = gts.szBmp;
    ofn.lCustData = 0;
    ofn.lpfnHook = (LPOFNHOOKPROC) NULL;
    ofn.lpTemplateName = (LPTSTR) NULL;

    do {
    // Invoke the common file dialog.  If it succeeds, then validate
    // the bitmap file.  If not valid, make user try again until either
    // they pick a good one or cancel the dialog.

        bTryAgain = FALSE;

        if ( bFileSelected = GetOpenFileName(&ofn) ) {
            newTexFile.nOffset = ofn.nFileOffset;
            if( VerifyTextureFile( &newTexFile ) ) {
                // copy in new file and offset
                *ptf = newTexFile;
            }
            else {
                bTryAgain = TRUE;
            }
        }

    // If need to try again, recompute dir and file name so dialog
    // still looks nice.

        if (bTryAgain && ofn.nFileOffset) {
            lstrcpy(dirName, pszFileName);
            dirName[ofn.nFileOffset-1] = L'\0';
            lstrcpy(pszFileName, &pszFileName[ofn.nFileOffset]);
        }

    } while (bTryAgain);

    gbEnableErrorMsgs = FALSE;

    if( bFileSelected ) {
        if( lstrcmpi( origPathName, ptf->szPathName ) )
            // a different file was selected
            return TRUE;
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
// Name: DXUtil_strcmpi()
// Desc: compares 2 strings
//-----------------------------------------------------------------------------
int DXUtil_strcmpi( TCHAR* str1, TCHAR* str2 )
{
    int nResult = CompareString( LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, str1, -1, str2, -1 );
    
    if( nResult == CSTR_EQUAL )
        return 0;
    if( nResult == CSTR_LESS_THAN )
        return -1;
    else 
        return 1;
}

/******************************Public*Routine******************************\
*
* ss_GetDefaultBmpFile
*
* Determine a default bitmap file to use for texturing, if none
* exists yet in the registry.  
*
* Put default in BmpFile parameter.   DotBmp parameter is the bitmap
* extension (usually .bmp).
*
* We have to synthesise the name from the ProductType registry entry.
* Currently, this can be WinNT, LanmanNT, or Server.  If it is
* WinNT, the bitmap is winnt.bmp.  If it is LanmanNT or Server,
* the bitmap is lanmannt.bmp.
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Wrote it
*
*  Jul. 27, 95 : [marcfo]
*    - Added support for win95
*
*  Apr. 23, 96 : [marcfo]
*    - Return NULL string for win95
*
\**************************************************************************/

void
ss_GetDefaultBmpFile( LPTSTR pszBmpFile )
{
    HKEY   hkey;
    LONG   cjDefaultBitmap = MAX_PATH;

    if( ss_fOnWin95() )
        // There is no 'nice' bmp file on standard win95 installations
        lstrcpy( pszBmpFile, TEXT("") );
    else {
        if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 (LPCTSTR) TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
                 0,
                 KEY_QUERY_VALUE,
                 &hkey) == ERROR_SUCCESS )
        {

            if ( RegQueryValueEx(hkey,
                                  TEXT("ProductType"),
                                  (LPDWORD) NULL,
                                  (LPDWORD) NULL,
                                  (LPBYTE) pszBmpFile,
                                  (LPDWORD) &cjDefaultBitmap) == ERROR_SUCCESS
                 && (cjDefaultBitmap / sizeof(TCHAR) + 4) <= MAX_PATH )
                lstrcat( pszBmpFile, gts.szDotBmp );
            else
                lstrcpy( pszBmpFile, TEXT("winnt.bmp") );

            RegCloseKey(hkey);
        }
        else
            lstrcpy( pszBmpFile, TEXT("winnt.bmp") );

    // If its not winnt.bmp, then its lanmannt.bmp.  (This would be a lot
    // cleaner both in the screen savers and for usersrv desktop bitmap
    // initialization if the desktop bitmap name were stored in the
    // registry).

        if ( DXUtil_strcmpi( pszBmpFile, TEXT("winnt.bmp") ) != 0 )
            lstrcpy( pszBmpFile, TEXT("lanmannt.bmp") );
    }
}

/******************************Public*Routine******************************\
*
* VerifyTextureFile
*
* Verify that a bitmap or rgb file is valid
*
* Returns:
*   File type (RGB or BMP) if valid file; otherwise, 0.
*
* History
*  Dec. 12, 95 : [marcfo]
*    - Creation
*
\**************************************************************************/

static int
VerifyTextureFile( TEXFILE *pTexFile )
{
    int type;
//    ISIZE size;
    BOOL bValid = TRUE;
    TCHAR szString[2 * MAX_PATH]; // May contain a pathname

    // check for 0 offset and null strings
    if( (pTexFile->nOffset == 0) || (*pTexFile->szPathName == 0) )
        return 0;

    type = GetTexFileType( pTexFile );

    switch( type ) {
        case TEX_BMP:
//            bValid = bVerifyDIB( pTexFile->szPathName, &size );
            break;
/*
        case TEX_RGB:
//            bValid = bVerifyRGB( pTexFile->szPathName, &size );
            break;
*/
        case TEX_UNKNOWN:
        default:
            bValid = FALSE;
    }

    if( !bValid ) {
        if( gbEnableErrorMsgs ) {
            wsprintf(szString, gts.szSelectAnotherBitmapMsg, pTexFile->szPathName);
            MessageBox(NULL, szString, gts.szWarningMsg, MB_OK);
        }
        return 0;
    }

    return type;
}

/******************************Public*Routine******************************\
*
* GetTexFileType
*
* Determine if a texture file is rgb or bmp, based on extension.  This is
* good enough, as the open texture dialog only shows files with these
* extensions.
*
\**************************************************************************/

static int
GetTexFileType( TEXFILE *pTexFile )
{
    LPTSTR pszStr;

#ifdef UNICODE
    pszStr = wcsrchr( pTexFile->szPathName + pTexFile->nOffset, 
             (USHORT) L'.' );
#else
    pszStr = strrchr( pTexFile->szPathName + pTexFile->nOffset, 
             (USHORT) L'.' );
#endif
    if( !pszStr || (lstrlen(++pszStr) == 0) )
        return TEX_UNKNOWN;

    if( !DXUtil_strcmpi( pszStr, TEXT("bmp") ) )
        return TEX_BMP;
/*
    else if( !lstrcmpi( pszStr, TEXT("rgb") ) )
        return TEX_RGB;
*/
    else
        return TEX_UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\logon\logon.h ===
#define IDB_SERVER              200
#define IDB_WORKSTA             201
#define IDB_ADVANCED            202
#define IDB_DATACENTER          203
#define IDB_PERSONAL            204
#define IDB_EMBEDDED            205
#define IDB_SBS                 206
#define IDB_BLADE               207
#define IDB_TABLET              208
#define IDI_CLIENT              209
#define IDI_SERVER              210
#define IDS_OPTIONS             211
#define IDB_APPLIANCE           212
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\marquee\marquee.h ===
#define         ID_MARQUEETEXT          102
#define         ID_BGROUNDCOLOR         104
#define         ID_CENTERED             105
#define         ID_RANDOM               106
#define         ID_SPEED                107
#define         ID_TEXTWINDOW           108
#define         ID_FORMATTEXT           109
                                        
#define         ID_PASSWORDPROTECT      110
#define         ID_SETPASSWORD          111
#define         ID_BGROUNDCOLOR_LABEL   113
#define         ID_SPEED_SLOW           114
#define         ID_SPEED_FAST           115
#define         ID_MARQUEETEXT_LABEL    116

//
// Help IDs
//
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_POSITION_CENTERED  4200
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_POSITION_RANDOM 4201
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_SPEED           4202
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_BACKGROUND_COLOR 4203
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_TEXT            4204
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_TEXT_EXAMPLE    4205
#define IDH_DISPLAY_SCREENSAVER_MARQUEE_FORMAT_TEXT     4206
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\logon\logon.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>

#include <windows.h>
#include <scrnsave.h>
#include <logon.h>

// For IsOS()
#include <shlwapi.h>
#include <shlwapip.h>


#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a)/sizeof(*a))
#endif


HANDLE hInst;

int cxhwndLogon;
int cyhwndLogon;
int xScreen;        // the top-left corner of the screen, might be different than (0,0)
int yScreen;
int cxScreen;
int cyScreen;
HBRUSH hbrBlack;
HDC hdcLogon;
HWND hwndLogon;
HBITMAP hbmLogon = NULL;
HICON ghiconLogon = NULL;
HICON   hMovingIcon = NULL;
HPALETTE ghpal = NULL;

#define APPCLASS "LOGON"

#define MAX_CAPTION_LENGTH  128

DWORD FAR lRandom(VOID)
{
    static DWORD glSeed = (DWORD)-365387184;

    glSeed *= 69069;
    return(++glSeed);
}

HPALETTE GetPalette(HBITMAP hbm)
{
    DIBSECTION ds;
    int i;
    HANDLE hmem;
    HDC hdc, hdcMem;
    LOGPALETTE *ppal;
    HPALETTE hpal;
    RGBQUAD rgbquad[256];
    USHORT nColors;

    GetObject(hbm, sizeof(DIBSECTION), &ds);
    if (ds.dsBmih.biBitCount > 8)
        return NULL;

    nColors = (ds.dsBmih.biBitCount < 16) ? (1 << ds.dsBmih.biBitCount) : 0xffff;

    hmem = GlobalAlloc(GHND, sizeof (LOGPALETTE) + sizeof (PALETTEENTRY) * nColors);
    if (hmem == NULL)
        return NULL;

    ppal = (LPLOGPALETTE) GlobalLock(hmem);

    hdc = GetDC(NULL);
    hdcMem = CreateCompatibleDC(hdc);
    SelectObject(hdcMem, hbm);

    ppal->palVersion = 0x300;
    ppal->palNumEntries = nColors;
    GetDIBColorTable(hdcMem, 0, nColors, rgbquad);

    for (i = 0; i < nColors; i++) {
        ppal->palPalEntry[i].peRed = rgbquad[i].rgbRed;
        ppal->palPalEntry[i].peGreen = rgbquad[i].rgbGreen;
        ppal->palPalEntry[i].peBlue = rgbquad[i].rgbBlue;
    }

    hpal = CreatePalette(ppal);

    GlobalUnlock(hmem);
    GlobalFree(hmem);

    DeleteObject(hdcMem);
    ReleaseDC(NULL, hdc);

    return hpal;
}

LRESULT APIENTRY
WndProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    int x, y;
    int nColorsChanged;

    switch (message) {
    PAINTSTRUCT ps;

    case WM_PALETTECHANGED:
        if ((HWND)wParam == hwnd)
            break;

    case WM_QUERYNEWPALETTE:
    {
        HDC hdc = GetDC(hwnd);
        SelectPalette(hdc, ghpal, FALSE);
        nColorsChanged = RealizePalette(hdc);
        ReleaseDC(hwnd, hdc);

        if (nColorsChanged != 0) {
            InvalidateRect(hwnd, NULL, TRUE);
        }
    }
    break;

    case WM_PAINT:
        BeginPaint(hwnd, &ps);
        SelectPalette(ps.hdc, ghpal, FALSE);
        BitBlt(ps.hdc, 0, 0, cxhwndLogon, cyhwndLogon, hdcLogon, 0, 0, SRCCOPY);
        EndPaint(hwnd, &ps);
        break;

    case WM_TIMER:
        /*
         * Pick a new place on the screen to put the dialog.
         */
        x = lRandom() % (cxScreen - cxhwndLogon) + xScreen;
        y = lRandom() % (cyScreen - cyhwndLogon) + yScreen;

        SetWindowPos(hwndLogon, NULL, x, y, 0, 0,
                SWP_NOSIZE | SWP_NOZORDER);
        break;

    case WM_CLOSE:
        ExitProcess(0);
        break;

    case WM_SETFOCUS:
        /*
         * Don't allow DefDlgProc() to do default processing on this
         * message because it'll set the focus to the first control and
         * we want it set to the main dialog so that DefScreenSaverProc()
         * will see the key input and cancel the screen saver.
         */
        return TRUE;
        break;

    /*
     * Call DefScreenSaverProc() so we get its default processing (so it
     * can detect key and mouse input).
     */
    default:
        return DefScreenSaverProc(hwnd, message, wParam, lParam) ? TRUE : FALSE;
    }

    return 0;
}


int sx;
int sy;

LRESULT OnCreateSS(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{

    // Background window is black
    // Make sure we use the entire virtual desktop size for multiple
    // displays:
    cxScreen =  ((LPCREATESTRUCT)lParam)->cx;
    cyScreen =  ((LPCREATESTRUCT)lParam)->cy;
    xScreen =  ((LPCREATESTRUCT)lParam)->x;
    yScreen =  ((LPCREATESTRUCT)lParam)->y;

    hbrBlack = GetStockObject(BLACK_BRUSH);
    if (!fChildPreview)
    {
        WNDCLASS wndClass;
        BITMAP bm = {0};

        if (hbmLogon == NULL)
        {
            LPTSTR res;

            // Embedded OS has it's own logo
            if (IsOS(OS_EMBEDDED))
            {
                res = MAKEINTRESOURCE(IDB_EMBEDDED);
            }
            else if (IsOS(OS_TABLETPC))
            {
                res = MAKEINTRESOURCE(IDB_TABLET);
            }
            else if (IsOS(OS_DATACENTER))
            {
                res = MAKEINTRESOURCE(IDB_DATACENTER);
            }
            else if (IsOS(OS_ADVSERVER))
            {
                res = MAKEINTRESOURCE(IDB_ADVANCED);
            }
            else if (IsOS(OS_BLADE))
            {
                res = MAKEINTRESOURCE(IDB_BLADE);
            }
            else if (IsOS(OS_SMALLBUSINESSSERVER))
            {
                res = MAKEINTRESOURCE(IDB_SBS);
            }
            else if (IsOS(OS_APPLIANCE))
            {
                res = MAKEINTRESOURCE(IDB_APPLIANCE);
            }
            else if (IsOS(OS_SERVER))
            {
                res = MAKEINTRESOURCE(IDB_SERVER);
            }
            else if (IsOS(OS_PERSONAL))
            {
                res = MAKEINTRESOURCE(IDB_PERSONAL);
            }
            else
            {
                res = MAKEINTRESOURCE(IDB_WORKSTA);
            }

            hbmLogon = LoadImage(hMainInstance, res, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

            if (hbmLogon)
            {
                ghpal = GetPalette(hbmLogon);
            }
        }

        if (hbmLogon)
        {
            GetObject(hbmLogon, sizeof(bm), &bm);
        }

        cxhwndLogon = bm.bmWidth;
        cyhwndLogon = bm.bmHeight;

        hdcLogon = CreateCompatibleDC(NULL);
        if (hdcLogon && hbmLogon)
        {
            SelectObject(hdcLogon, hbmLogon);
        }

        wndClass.style         = CS_HREDRAW | CS_VREDRAW;
        wndClass.lpfnWndProc   = WndProc;
        wndClass.cbClsExtra    = 0;
        wndClass.cbWndExtra    = sizeof(LONG);
        wndClass.hInstance     = hInst;
        wndClass.hIcon         = NULL;
        wndClass.hCursor       = NULL;
        wndClass.hbrBackground = NULL;
        wndClass.lpszMenuName  = NULL;
        wndClass.lpszClassName = TEXT("LOGON");

        RegisterClass(&wndClass);

        // Create the window we'll move around every 10 seconds.
        hwndLogon = CreateWindowEx(WS_EX_TOPMOST, TEXT("LOGON"), NULL, WS_VISIBLE | WS_POPUP,
                50, 50, cxhwndLogon, cyhwndLogon, hMainWindow, NULL, hInst, NULL);

        if (hwndLogon)
        {
            SetTimer(hwndLogon, 1, 10 * 1000, 0);
        }

        // Post this message so we activate after this window is created.
        PostMessage(hwnd, WM_USER, 0, 0);
    }
    else
    {
        SetTimer(hwnd, 1, 10 * 1000, 0);

        cxhwndLogon = GetSystemMetrics(SM_CXICON);
        cyhwndLogon = GetSystemMetrics(SM_CYICON);

        ghiconLogon = LoadIcon(hMainInstance, 
                               IsOS(OS_ANYSERVER)               ? 
                                    MAKEINTRESOURCE(IDI_SERVER) : 
                                    MAKEINTRESOURCE(IDI_CLIENT));

        sx = lRandom() % (cxScreen - cxhwndLogon) + xScreen;
        sy = lRandom() % (cyScreen - cyhwndLogon) + yScreen;
    }

    return 0;
}

LRESULT APIENTRY ScreenSaverProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;

    switch (message)
    {
    case WM_CREATE:
        OnCreateSS(hwnd, message, wParam, lParam);
        break;

    case WM_SIZE:
        cxScreen = LOWORD(lParam);
        cyScreen = HIWORD(lParam);
        break;

    case WM_WINDOWPOSCHANGING:
        /*
         * Take down hwndLogon if this window is going invisible.
         */
        if (hwndLogon == NULL)
            break;

        if (((LPWINDOWPOS)lParam)->flags & SWP_HIDEWINDOW) {
            ShowWindow(hwndLogon, SW_HIDE);
        }
        break;

    case WM_USER:
        /*
         * Now show and activate this window.
         */
        if (hwndLogon == NULL)
            break;

        SetWindowPos(hwndLogon, NULL, 0, 0, 0, 0, SWP_SHOWWINDOW |
                SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER);
        break;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        SetRect(&rc, xScreen, yScreen, cxScreen, cyScreen);
        FillRect(hdc, &rc, hbrBlack);

        if (fChildPreview) {
            DrawIcon(hdc, sx, sy, ghiconLogon);
        }

        EndPaint(hwnd, &ps);
        break;

    case WM_NCACTIVATE:
        /*
         * Case out WM_NCACTIVATE so the dialog activates: DefScreenSaverProc
         * returns FALSE for this message, not allowing activation.
         */
        if (!fChildPreview)
            return DefWindowProc(hwnd, message, wParam, lParam);
        break;

    case WM_TIMER:
        /*
         * Pick a new place on the screen to put the dialog.
         */
        sx = lRandom() % (cxScreen - cxhwndLogon) + xScreen;
        sy = lRandom() % (cyScreen - cyhwndLogon) + yScreen;
        InvalidateRect(hwnd, NULL, TRUE);
        break;
    }

    return DefScreenSaverProc(hwnd, message, wParam, lParam);
}

BOOL APIENTRY
ScreenSaverConfigureDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR ach1[256];
    TCHAR ach2[256];
    int cchLoaded, cchActual;

    switch (message) {
    case WM_INITDIALOG:
        /*
         * This is hack-o-rama, but fast and cheap.
         */
        cchLoaded = LoadString(hMainInstance, IDS_DESCRIPTION, ach1, ARRAYSIZE(ach1));

        if (!IsOS(OS_ANYSERVER))
        {
            // HACK!!!: The display CPL looks for screen saver descriptions with string resource id=IDS_DESCRIPTION.  
            // As we need the certain screen saver descriptions to be different for client of server builds (32 and 64bit), 
            // the description string may be in the form of "Server\0Client".  If this is true, LoadString will return a 
            // count greater than the lstrlen of the string.
            cchActual = lstrlen(ach1);

            if (cchLoaded != cchActual)
            {
                // Extract the client portion of the description string
                lstrcpyn(ach1, &ach1[cchActual + 1], cchLoaded - cchActual);
            }
        }

        LoadString(hMainInstance, IDS_OPTIONS, ach2, ARRAYSIZE(ach2));

        MessageBox(hDlg, ach2, ach1, MB_OK | MB_ICONEXCLAMATION);

        EndDialog(hDlg, TRUE);
        break;
    }
    return FALSE;
}

BOOL WINAPI RegisterDialogClasses(HANDLE hInst)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\marquee\strings.h ===
#define idsDescription    1
#define idsName         100
#define idsDefaultText  101
#define idsFormatText   102
#define idsDefFontName  103


#include "..\common\comstrin.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\cameramove.cpp ===
/*****************************************************************************\
    FILE: CameraMove.cpp

    DESCRIPTION:
        The caller can create this object to tell it to move from point a to 
    point b from time t1 to time t2.

    BryanSt 12/24/2000

    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include <d3d8.h>
#include <d3dx8.h>
#include <d3dsaver.h>
#include <d3d8rgbrast.h>
#include <dxutil.h>

#include <shlobj.h>
#include "CameraMove.h"


enum eCameraMoveType
{
    cameraMoveLocation = 0,
    cameraRotate,
    cameraWait,
};

typedef struct
{
    eCameraMoveType type;
    D3DXVECTOR3 vSourceLoc;           // For cameraMoveLocation and cameraRotate
    D3DXVECTOR3 vSourceTangent;       // For cameraMoveLocation and cameraRotate
    D3DXVECTOR3 vDestLoc;             // For cameraMoveLocation
    D3DXVECTOR3 vDestTangent;         // For cameraMoveLocation and cameraRotate
    float fTime;                    // For cameraMoveLocation cameraRotate, and cameraWait
    int nMinFrames;
    int nMaxFrames;
    int nBatch;
    int nPreFetch;
} CAMERA_MOVEMENT;


CCameraMove::CCameraMove()
{
    m_hdpaMovements = DPA_Create(4);
    m_fTimeInPreviousMovements = NULL;
    m_vLookAtLast = m_vUpVec = m_vLocLast = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
    m_nCurrent = 0;
    m_fTimeInPreviousMovements = 0.0f;
    m_nFramesFromCurrent = 1;

    m_fTimeToLookAtPainting = 1.0f;
    DWORD dwSpeedSlider = DEFAULT_SPEEDSLIDER;
    if (g_pConfig)
    {
        m_fTimeToLookAtPainting = (float) g_pConfig->GetDWORDSetting(CONFIG_DWORD_VIEWPAINTINGTIME);
        dwSpeedSlider = g_pConfig->GetDWORDSetting(CONFIG_DWORD_SPEED_SLIDER);
    }

    m_fTimeToRotate = s_SpeedSettings[dwSpeedSlider].fTimeToRotate;
    m_nMinTurnFrames = s_SpeedSettings[dwSpeedSlider].nMinTurnFrames;
    m_nMaxTurnFrames = s_SpeedSettings[dwSpeedSlider].nMaxTurnFrames;

    m_fTimeToWalk = s_SpeedSettings[dwSpeedSlider].fTimeToWalk;
    m_nMinWalkFrames = s_SpeedSettings[dwSpeedSlider].nMinWalkFrames;
    m_nMaxWalkFrames = s_SpeedSettings[dwSpeedSlider].nMaxWalkFrames;
}


CCameraMove::~CCameraMove()
{
    DeleteAllMovements(0.0f);
}




HRESULT CCameraMove::Init(D3DXVECTOR3 vStartLoc, D3DXVECTOR3 vStartTangent, D3DXVECTOR3 vUpVec)
{
    HRESULT hr = S_OK;

    // Initialize member variables
    m_vUpVec = vUpVec;
    m_vLocLast = vStartLoc;
    m_vLookAtLast = vStartTangent;

    m_nFramesFromCurrent = 0;

    return hr;
}


HRESULT CCameraMove::CreateNextMove(D3DXVECTOR3 vSourceLoc, D3DXVECTOR3 vSourceTangent, D3DXVECTOR3 vDestLoc, D3DXVECTOR3 vDestTangent)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (m_hdpaMovements)
    {
        CAMERA_MOVEMENT * pNew = (CAMERA_MOVEMENT *) LocalAlloc(LPTR, sizeof(*pNew));

        if (pNew)
        {
            D3DXVECTOR3 vDelta = (vSourceLoc - vDestLoc);
            float fLen = D3DXVec3Length(&vDelta);        // How far are we traveling
            float fRatio = (fLen / 50.0f);              // The speed values are stored per 50.0f distance

            pNew->type = cameraMoveLocation;
            pNew->vSourceLoc = vSourceLoc;
            pNew->vSourceTangent = vSourceTangent;
            pNew->vDestLoc = vDestLoc;
            pNew->vDestTangent = vDestTangent;
            pNew->fTime = (m_fTimeToWalk * fRatio);
            pNew->nMinFrames = (int) max((m_nMinWalkFrames * fRatio), 1);
            pNew->nMaxFrames = (int) max((m_nMaxWalkFrames * fRatio), 1);
            pNew->nBatch = 0;
            pNew->nPreFetch = 0;

            if (-1 != DPA_AppendPtr(m_hdpaMovements, pNew))
            {
                hr = S_OK;
            }
            else
            {
                LocalFree(pNew);
            }
        }
    }

    return hr;
}


HRESULT CCameraMove::CreateNextRotate(D3DXVECTOR3 vSourceLoc, D3DXVECTOR3 vSourceTangent, D3DXVECTOR3 vDestTangent)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (m_hdpaMovements)
    {
        CAMERA_MOVEMENT * pNew = (CAMERA_MOVEMENT *) LocalAlloc(LPTR, sizeof(*pNew));

        if (pNew)
        {
            float fDotProduct = D3DXVec3Dot(&vSourceTangent, &vDestTangent);
            float fRatio;

            if (fDotProduct)
            {
                float fRads = (float)acos(fDotProduct / max(1, (D3DXVec3Length(&vSourceTangent) * D3DXVec3Length(&vDestTangent))));        // How far are we traveling
                fRatio = (D3DXToDegree(fRads) / 90.0f);              // The speed values are stored per 90.0f distance
            }
            else
            {
                // Assume a dot product of 0 means 90 degrees.
                fRatio = 1.0f;              // The speed values are stored per 90.0f distance
            }

            pNew->type = cameraRotate;
            pNew->vSourceLoc = vSourceLoc;
            pNew->vSourceTangent = vSourceTangent;
            pNew->vDestLoc = vSourceLoc;
            pNew->vDestTangent = vDestTangent;
            pNew->fTime = (m_fTimeToRotate * fRatio);
            pNew->nMinFrames = (int) max((m_nMinTurnFrames * fRatio), 1);
            pNew->nMaxFrames = (int) max((m_nMaxTurnFrames * fRatio), 1);
            pNew->nBatch = 0;
            pNew->nPreFetch = 0;

            if (-1 != DPA_AppendPtr(m_hdpaMovements, pNew))
            {
                hr = S_OK;
            }
            else
            {
                LocalFree(pNew);
            }
        }
    }

    return hr;
}


HRESULT CCameraMove::CreateNextWait(int nBatch, int nPreFetch, float fTime)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (-1.0f == fTime)
    {
        fTime = m_fTimeToLookAtPainting;
    }

    if (m_hdpaMovements)
    {
        CAMERA_MOVEMENT * pNew = (CAMERA_MOVEMENT *) LocalAlloc(LPTR, sizeof(*pNew));

        if (pNew)
        {
            pNew->type = cameraWait;
            pNew->vSourceLoc = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
            pNew->vSourceTangent = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
            pNew->vDestLoc = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
            pNew->vDestTangent = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
            pNew->fTime = fTime;
            pNew->nMinFrames = 1;
            pNew->nMaxFrames = 1000000;
            pNew->nBatch = nBatch;
            pNew->nPreFetch = nPreFetch;

            if (-1 != DPA_AppendPtr(m_hdpaMovements, pNew))
            {
                hr = S_OK;
            }
            else
            {
                LocalFree(pNew);
            }
        }
    }

    return hr;
}


HRESULT CCameraMove::SetCamera(IDirect3DDevice8 * pD3DDevice, FLOAT fTimeKeyIn)
{
    HRESULT hr = E_INVALIDARG;

    if (pD3DDevice && m_hdpaMovements)
    {
        float fTimeInSegment = 0.0f;
        CAMERA_MOVEMENT * pCurrent = NULL;

        if (0 > m_nCurrent)
        {
            m_nCurrent = 0;
        }

        if (m_nCurrent >= DPA_GetPtrCount(m_hdpaMovements))
        {
            hr = S_FALSE;   // This means we left the room.
        }
        else
        {
            do
            {
                pCurrent = (CAMERA_MOVEMENT *) DPA_GetPtr(m_hdpaMovements, m_nCurrent);

                if (!pCurrent)
                {
    //                ASSERT(FAILED(hr));
                    break;
                }
                else
                {
                    float fTimePerFrameMin = (pCurrent->fTime / pCurrent->nMinFrames);

                    fTimeInSegment = (fTimeKeyIn - m_fTimeInPreviousMovements);

                    if (fTimeInSegment < 0)
                    {
                        fTimeInSegment = 0;
                    }

                    // Do we need to warp time in order to have enough frames for the motion so we don't
                    // jump?
                    if ((fTimeInSegment > (fTimePerFrameMin * m_nFramesFromCurrent)) &&
                        (m_nFramesFromCurrent <= pCurrent->nMinFrames))
                    {
                        // Yes.
                        float fTimeWarp = (fTimeInSegment - (fTimePerFrameMin * m_nFramesFromCurrent));

                        m_fTimeInPreviousMovements += fTimeWarp;
                        fTimeInSegment = (fTimeKeyIn - m_fTimeInPreviousMovements);
                    }

                    if (fTimeInSegment > pCurrent->fTime)
                    {
                        m_fTimeInPreviousMovements += pCurrent->fTime;

                        if (cameraRotate == pCurrent->type)
                        {
                            m_vLocLast = pCurrent->vSourceLoc;
                            m_vLookAtLast = pCurrent->vDestTangent;
                        }
                        else if (cameraMoveLocation == pCurrent->type)
                        {
                            m_vLocLast = pCurrent->vDestLoc;
                            m_vLookAtLast = pCurrent->vDestTangent;
                        }

                        m_nFramesFromCurrent = 0;
                        m_nCurrent++;
                    }
                    else
                    {
                        m_nFramesFromCurrent++;
                        hr = S_OK;
                        break;
                    }
                }
            }
            while (1);
        }

        if (S_OK == hr) // S_FALSE means we left the room, so do nothing.
        {
            D3DXVECTOR3 vEye = m_vLocLast;
            D3DXVECTOR3 vLookAt = (m_vLocLast + m_vLookAtLast);
            float fTimeRatio = (fTimeInSegment / pCurrent->fTime);
            float fTimeRemainingInSeg = 0.0f;

            switch (pCurrent->type)
            {
            case cameraMoveLocation:
                D3DXVec3Lerp(&vEye, &pCurrent->vSourceLoc, &pCurrent->vDestLoc, fTimeRatio);
                D3DXVec3Lerp(&vLookAt, &pCurrent->vSourceTangent, &pCurrent->vDestTangent, fTimeRatio);

                vLookAt += vEye;
                break;
            case cameraRotate:
                // TODO: Use D3DXVec3Lerp() instead.
                D3DXVec3Lerp(&vLookAt, &pCurrent->vSourceTangent, &pCurrent->vDestTangent, fTimeRatio);
                vLookAt += vEye;
//                vLookAt = (vEye + (pCurrent->vSourceTangent + (fTimeRatio * (pCurrent->vDestTangent - pCurrent->vSourceTangent))));
                // How do we rotate?  Quaternion.
                break;
            case cameraWait:
                if (m_nFramesFromCurrent > 1)
                {
                    if ((2 == m_nFramesFromCurrent) && g_pPictureMgr)
                    {
                        DWORD dwMaxPixelSize = ((3 * g_dwHeight) / 4);

                        // Let's take the hit now of converting an image into a texture object since we don't have
                        // any work to do while looking at this painting.  This can normally take 1.5 seconds, so
                        // it's big perf hit to do it any other time.
                        hr = g_pPictureMgr->PreFetch(pCurrent->nBatch, pCurrent->nPreFetch);
                    }
                    else
                    {
                        // We don't have any work remaining to do, so sleep so the computer can get some work
                        // done.  (Like in background services or let it do any paging that we may have caused)
                        fTimeRemainingInSeg = (pCurrent->fTime - fTimeInSegment);
                        int nSleepTime = 1000 * (int) fTimeRemainingInSeg;

                        Sleep(nSleepTime);
                    }
                }
                break;
            default:
                // Do nothing.
                break;
            };


            D3DXMATRIX matView;
            D3DXMATRIX matIdentity;

            D3DXMatrixIdentity(&matIdentity);
            if (g_fOverheadViewTest)
            {
                static float s_fHeight = 600.0f;
                D3DXVECTOR3 vDelta = (vEye - vLookAt);

                vEye += D3DXVECTOR3(0.0f, s_fHeight, 0.0f);
                vEye += (4 * vDelta);
                D3DXMatrixLookAtLH(&matView, &vEye, &vLookAt, &m_vUpVec);
            }
            else
            {
                D3DXMatrixLookAtLH(&matView, &vEye, &vLookAt, &m_vUpVec);
            }

//            PrintLocation(TEXT("Camera angle at: %s and looking at: %s"), vEye, vLookAt);
            hr = pD3DDevice->SetTransform(D3DTS_VIEW, &matView);

            m_vEyePrev = vEye;
            m_vLookAtPrev = vLookAt;
        }
        else
        {
            D3DXMATRIX matView;

            D3DXMatrixLookAtLH(&matView, &m_vEyePrev, &m_vLookAtPrev, &m_vUpVec);
//            PrintLocation(TEXT("xxxxxx Camera angle at: %s and looking at: %s"), m_vEyePrev, m_vLookAtPrev);
            pD3DDevice->SetTransform(D3DTS_VIEW, &matView);
        }
    }
    else
    {
        DXUtil_Trace(TEXT("ERROR: pD3DDevice or m_hdpaMovements is NULL"));
    }

    return hr;
}




HRESULT CCameraMove::DeleteAllMovements(float fCurrentTime)
{
    HRESULT hr = S_OK;

    if (m_hdpaMovements)
    {
        DPA_DestroyCallback(m_hdpaMovements, DPALocalFree_Callback, NULL);
        m_hdpaMovements = DPA_Create(4);
    }

    m_fTimeInPreviousMovements = fCurrentTime;
    m_nCurrent = 0;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\marquee\ssmarque.c ===
/*
marquee.c
This is a screen saver that can easily be added onto...

  History:
       6/17/91        stevecat    ported to NT Windows
       2/10/92        stevecat    snapped to latest Win3.1 sources
*/

#include <windows.h>
#include <commdlg.h>
#include <dlgs.h>
#include <scrnsave.h>
#include "marquee.h"
#include "strings.h"
#include "uniconv.h"


#define MulDiv(a, b, c)  ((int)(a) * (int)(b) / (int)(c))

typedef struct
{
    HWND        hDlg;
    WORD        wID;
    HDC         hDC;
} INFOSTRUCT;
typedef INFOSTRUCT far * LPINFOSTRUCT;

UINT PWM_NEWSPEED;
UINT PWM_NEWPOSITION;
#define BUFFER_LEN        1025  //  make it safe to use these buffers for wsprintf
#define COUNT             2
#define MAX_SPEED         10
#define DEF_SPEED         10
#define DIV_SPEED         3

#define NATTRIBUTES       5
#define UNDERLINE         0
#define STRIKEOUT         1
#define ITALIC            2
#define MODE              3
#define BOLD              4

#define DEFAULT_TEXT_COLOR      RGB(255,0,255)
#define DEFAULT_SCREEN_COLOR    RGB(0,0,0)

TCHAR szDefaultText[BUFFER_LEN];         // Buffer for default Marquee text
TCHAR szFormatText[TITLEBARNAMELEN];     // Name in font formatting dlg.

TCHAR szFontName[]=TEXT("Font");               // CONTROL.INI key values
TCHAR szSizeName[]=TEXT("Size");
TCHAR szTextName[]=TEXT("Text");
TCHAR szTColorName[]=TEXT("TextColor");
TCHAR szBColorName[]=TEXT("BackgroundColor");
TCHAR szAttributes[]=TEXT("Attributes");
TCHAR szSpeedName[]=TEXT("Speed");
TCHAR szCharSetName[]=TEXT("CharSet");
TCHAR szShowTextName[]=TEXT("showtext");

TCHAR szBuffer[BUFFER_LEN];              // Text to display in Marquee
TCHAR szFaceName[LF_FACESIZE];           // Font face name to use...
TCHAR szDefFontName[LF_FACESIZE];
BOOL fMode=FALSE;                       // Mode of ScreenSaver
TCHAR fUnderline=TEXT('0');
TCHAR fStrikeOut=TEXT('0');
TCHAR fItalic=TEXT('0');
TCHAR fBold=TEXT('0');
HFONT hfontMessage = NULL;
DWORD dwTColor;                         // Global text color
DWORD dwBColor;                         // Global background color
BYTE bCharSet;
DWORD dwRand = 1L;

#define RAND(x)   ((rand() % ((x == 0) ? 1 : x)) + 1)
#define ZRAND(x)  (rand() % ((x == 0) ? 1 : x))

// Function prototypes...

void  srand (DWORD);
WORD  rand (void);
LRESULT APIENTRY ShowTextProc (HWND, UINT, WPARAM, LPARAM);
int   GetHeightFromPointSize (int);
void  FillR (HDC, LPRECT, DWORD);
void  FrameR (HDC, LPRECT, DWORD, int);
void  PatB (HDC, int, int, int, int, DWORD);
void  GetAttributes (void);
DWORD GetProfileRgb (LPTSTR, LPTSTR, DWORD);
WORD  AtoI (LPTSTR);
BOOL  APIENTRY ChooseFontHookProc (HWND, UINT, DWORD, LONG);

//
// Help IDs
//
DWORD aMarqueeDlgHelpIds[] = {
    ((DWORD) -1), ((DWORD) -1),
    ID_FORMATTEXT,          IDH_DISPLAY_SCREENSAVER_MARQUEE_FORMAT_TEXT,
    ID_CENTERED,            IDH_DISPLAY_SCREENSAVER_MARQUEE_POSITION_CENTERED,
    ID_RANDOM,              IDH_DISPLAY_SCREENSAVER_MARQUEE_POSITION_RANDOM,
    ID_BGROUNDCOLOR_LABEL,  IDH_DISPLAY_SCREENSAVER_MARQUEE_BACKGROUND_COLOR,
    ID_BGROUNDCOLOR,        IDH_DISPLAY_SCREENSAVER_MARQUEE_BACKGROUND_COLOR,
    ID_SPEED_SLOW,          IDH_DISPLAY_SCREENSAVER_MARQUEE_SPEED,
    ID_SPEED_FAST,          IDH_DISPLAY_SCREENSAVER_MARQUEE_SPEED,
    ID_SPEED,               IDH_DISPLAY_SCREENSAVER_MARQUEE_SPEED,
    ID_MARQUEETEXT_LABEL,   IDH_DISPLAY_SCREENSAVER_MARQUEE_TEXT,
    ID_MARQUEETEXT,         IDH_DISPLAY_SCREENSAVER_MARQUEE_TEXT,
    ID_TEXTWINDOW,          IDH_DISPLAY_SCREENSAVER_MARQUEE_TEXT_EXAMPLE,
    0,0
};

//***************************************************************************

//
// This function returns TRUE, if szBuffer includes DBCS, otherwise FALSE.
// #425:12/21/92:fixing DBCS dispatch automatically
//
// ToddB: all DBCS and CodePage issues are handled by first calling this function.
// To do the FE single binary merge I'm simply calling this function always (instead
// of only in Far East builds).  If this function returns FALSE then the remaining
// code path is identical to the old US version.
BOOL FAR PASCAL IsTextIncludeDBCSChar(void)
{
    static BOOL bDBCS = -1;
    int   i, len = lstrlen(szBuffer) ;
    CHAR  c;
    CHAR  szb[BUFFER_LEN*sizeof(TCHAR)];

    // Use lazy initialization since I have multiple the entry points which vary
    // depending on what message handlers are processed in the WndProc
    if ( -1 == bDBCS )
        bDBCS = GetSystemMetrics( SM_DBCSENABLED );

    // if we are not using a DBCS version of user.exe then nothing should
    // be treated as a DBCS character.
    if (!bDBCS)
        return FALSE;

    if (sizeof(TCHAR) == sizeof(CHAR))
    {
        // same size, just copy.  The cast is valid due to the above check and
        // it keeps the compiler happy
        lstrcpyn( (TCHAR *)szb, szBuffer, CharSizeOf(szb) );
    }
    else
    {
        // szBuffer is UNICODE, we convert it to DBCS before checking for lead bytes.
        WideCharToMultiByte( CP_ACP, WC_COMPOSITECHECK,
        szBuffer, len+1,
        szb, CharSizeOf(szb),
        NULL, NULL );
    }

    for (i = 0;i < len;i++) {
        c = szb[i] ;

        if (IsDBCSLeadByte(c)) {
            return TRUE ;
        }
/* hankaku katakana JAPAN only */
        else if (GetACP() == 932 && c >= 0xa0 && c <  0xe0) {
            return TRUE ;
        }
    }
    return FALSE ;
}

static CHARSETINFO csi;

void LoadStrings(void)
{
    TCHAR szTmp[BUFFER_LEN];
    OSVERSIONINFO osi;

    // This simply fills a CHARSETINFO structure with data about the code page
    DWORD dw = GetACP();
    if (!TranslateCharsetInfo((DWORD*)IntToPtr(dw), &csi, TCI_SRCCODEPAGE))
        csi.ciCharset = ANSI_CHARSET;

    LoadString (hMainInstance, idsName, szName, CharSizeOf(szName));
    LoadString (hMainInstance, idsAppName, szAppName, CharSizeOf(szAppName));

    // Get OS Version
    LoadString (hMainInstance, idsDefaultText, szTmp, CharSizeOf(szTmp));
    osi.dwOSVersionInfoSize = sizeof(osi);
    if (!GetVersionEx(&osi)) {
        osi.dwMajorVersion = 4;
        osi.dwMinorVersion = 0;
    }

    wsprintf( szDefaultText, szTmp, osi.dwMajorVersion, osi.dwMinorVersion );

    LoadString (hMainInstance, idsIniFile, szIniFile, CharSizeOf(szIniFile));
    LoadString (hMainInstance, idsScreenSaver, szScreenSaver, CharSizeOf(szScreenSaver));
    LoadString (hMainInstance, idsHelpFile, szHelpFile, CharSizeOf(szHelpFile));
    LoadString (hMainInstance, idsNoHelpMemory, szNoHelpMemory, CharSizeOf(szNoHelpMemory));
    LoadString (hMainInstance, idsFormatText, szFormatText, CharSizeOf(szFormatText));
    LoadString (hMainInstance, idsDefFontName, szDefFontName, CharSizeOf(szDefFontName));
}

//***************************************************************************

/* This is the main window procedure to be used when the screen saver is
    activated in a screen saver mode ( as opposed to configure mode ).  This
    function must be declared as an EXPORT in the EXPORTS section of the
    DEFinition file... */

LRESULT APIENTRY ScreenSaverProc(hWnd, message, wParam, lParam)
HWND   hWnd;
UINT   message;
WPARAM wParam;
LPARAM lParam;
{
RECT                rRect;
static int          wSize;
static WORD         wHeight;
static UINT_PTR     wTimer;
static WORD         wX;
static WORD         wY;
static WORD         wCount;
static SIZE         sizeExtent;
static int          wLength;
static WORD         wSpeed;
static WORD         wVelocity;
static HBRUSH       hbrTemp;
static TEXTMETRIC   tm;
static BOOL         bMELocale;
HBRUSH              hbrOld;
HFONT               hfontOld;
HDC                 hDC;
DWORD               dwLocale;
UINT                uiETOFlags;

    switch(message)
    {
        case WM_CREATE:
            LoadStrings ();
            GetAttributes();
            /* Get the info necessary to create the font... */
            GetPrivateProfileString (szAppName, szFontName, szDefFontName, szFaceName,
                                     CharSizeOf(szFaceName), szIniFile);
            bCharSet = (BYTE)GetPrivateProfileInt (szAppName,szCharSetName,
                                                    (WORD)ANSI_CHARSET, szIniFile);
        if( IsTextIncludeDBCSChar() )
            {
                bCharSet = (BYTE)csi.ciCharset;
            }

            hDC = GetDC (NULL);

            //  See if the user locale id is Arabic or Hebrew.
            dwLocale    = GetUserDefaultLCID();
            bMELocale = ((PRIMARYLANGID(LANGIDFROMLCID(dwLocale)) == LANG_ARABIC) ||
                (PRIMARYLANGID(LANGIDFROMLCID(dwLocale)) == LANG_HEBREW));

            /* Get the dimensions of the entire virtual screen... */
            wX = (WORD)((LPCREATESTRUCT)lParam)->cx;
            wY = (WORD)((LPCREATESTRUCT)lParam)->cy;

            wSize = GetPrivateProfileInt (szAppName, szSizeName, 0, szIniFile);
            // wSize is in POINTS, we need to convert it to LogicalUnits...
            wSize = GetHeightFromPointSize (wSize);

            if (fChildPreview) {
                // Scale font down to fit in preview window
                wSize = (wSize * wY) / GetDeviceCaps(hDC, VERTRES);
            }

            hfontMessage = CreateFont (wSize, 0, 0, 0,
                                       (fBold == TEXT('0')) ? FW_NORMAL : FW_BOLD,
                                       (fItalic == TEXT('0')) ? 0 : 1,
                                       (fUnderline == TEXT('0')) ? 0 : 1,
                                       (fStrikeOut == TEXT('0')) ? 0 : 1,
                                       bCharSet,
                                       OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                       DEFAULT_PITCH|FF_DONTCARE, szFaceName);

            /* Get the text to display and figure out how long it is... */
            GetPrivateProfileString (szAppName, szTextName, szDefaultText, szBuffer,
                                     CharSizeOf(szBuffer), szIniFile);

            #define SOME_SPACING TEXT("     ")

            //  Check to see if there is room before we append.  Note that CharSizeOf(SOME_SPACING) 
            //  will include the terminating NULL.
            if ((lstrlen(szDefaultText) + CharSizeOf(SOME_SPACING)) < CharSizeOf(szDefaultText))
            {
                lstrcat(szDefaultText, SOME_SPACING);
            }
            
            wLength = lstrlen (szBuffer);
            hfontOld = SelectObject (hDC,hfontMessage);
            GetTextExtentPoint32 (hDC, szBuffer, wLength, &sizeExtent);

            if (fChildPreview)
                sizeExtent.cx *= 2;

            GetTextMetrics (hDC,&tm);
            if (hfontOld)
                SelectObject (hDC,hfontOld);

            ReleaseDC (NULL,hDC);
            if (bMELocale) {
                wCount = (WORD)(0 - sizeExtent.cy + 1);
            } else {
                wCount = wX;
            }
            srand(GetCurrentTime());

            /* set everything up... */
            if(fMode)
                wHeight = (WORD) ZRAND(wY - sizeExtent.cy);
            else
                wHeight = (WORD) (wY - sizeExtent.cy)/2;

            if ((int)(wSpeed = (WORD) GetPrivateProfileInt (szAppName, szSpeedName, DEF_SPEED, szIniFile))
                < 1)
                wSpeed = 1;
            if (wSpeed > (MAX_SPEED * DIV_SPEED))
                wSpeed = MAX_SPEED * DIV_SPEED;

            dwTColor = GetProfileRgb(szAppName,szTColorName,DEFAULT_TEXT_COLOR);
            dwBColor = GetProfileRgb(szAppName,szBColorName,DEFAULT_SCREEN_COLOR);
            hbrTemp = CreateSolidBrush(dwBColor);

            /* Set the timer... */
            wTimer = SetTimer(hWnd,9,1,NULL);
            break;

        case WM_SIZE:
            wX = LOWORD(lParam);
            wY = HIWORD(lParam);
            break;

        case WM_ERASEBKGND:
            /* If you want something put on the background, do it right here
                using wParam as a handle to a device context.  Remember to
                unrealize a brush if it is not a solid color.  If you do
                something here, you want to use the line:
                    return 0l;
                So the program knows not to take the default action. Otherwise
                just use:
                    break;
                */
            GetClientRect (hWnd, &rRect);
            FillRect ((HDC)wParam, &rRect, hbrTemp);
            return 0l;

        case WM_TIMER:
        {
            RECT rc;

            // NOTE:  For Win32 the casting of these quantities is extremely
            //        important.  The original code was very sloppy and just
            //        made everything WORD (even for signed quantities).  We
            //        must use proper casting here to get around these coding
            //        ERRORS!!
            //           [stevecat]

            rc.top    = (int)(short) wHeight;
            rc.left   = (int)(short) wCount - tm.tmMaxCharWidth;
            rc.bottom = (int)(short) wHeight + sizeExtent.cy + (sizeExtent.cy >> 3); //Some fonts leave a trail
            rc.right  = (int)(short) wCount + sizeExtent.cx + (wVelocity / DIV_SPEED) +
                                  1 + tm.tmMaxCharWidth * 2;

            /* Add the new increment to the timer count, if we have not reached
                the integral part of the count, wait until we do... */
            wVelocity += wSpeed;
            if(wVelocity < DIV_SPEED)
                break;
            hDC = GetDC(hWnd);
            hfontOld = SelectObject(hDC,hfontMessage);
            SetTextColor(hDC,dwTColor);
            SetBkColor(hDC,dwBColor);

            uiETOFlags = ETO_OPAQUE;
            
            if (bMELocale) {
              uiETOFlags |= ETO_RTLREADING;
            }

            ExtTextOut(hDC, (int)(short)wCount, wHeight, uiETOFlags,
                                            &rc, szBuffer, wLength, NULL);
                                            
            if (hfontOld)
                SelectObject(hDC,hfontOld);

            if (bMELocale) { // Arabic/Hebrew Locale
                if((short)wCount < (short) wX)
                   wCount += (wVelocity/DIV_SPEED)+1;
                else
                {
                    wCount = (WORD)(0 - sizeExtent.cx + 1);
                    if(fMode)
                       wHeight = (WORD) ZRAND(wY - sizeExtent.cy);
                 }

            } else {

                /* Increment so it is ready for the next pass... */
                if((short)wCount >= (short)(0-sizeExtent.cx))
                   wCount -= (wVelocity/DIV_SPEED)+1;
                else
                {
                    hbrOld = SelectObject(hDC,hbrTemp);
                    //  The wSize variable is some bogus value left over during WM_CREATE and
                    //  doesn't seem to have any connection to where the PatBlt should start
                    //  in the X direction.  Replacing this value with 0 fixes bug #5415
                    //                PatBlt(hDC,(int)(short)wSize, (int)(short)wHeight,
                    PatBlt(hDC, 0, (int)(short)wHeight,
                             ((wVelocity/DIV_SPEED)+1)*1+tm.tmMaxCharWidth*2,
                               sizeExtent.cy, PATCOPY);
                    if (hbrOld)
                       SelectObject(hDC,hbrOld);
                    wCount = wX;
                    if(fMode)
                       wHeight = (WORD) ZRAND(wY - sizeExtent.cy);
                 }
            }
            ReleaseDC(hWnd,hDC);

            wVelocity = wVelocity % DIV_SPEED;
            break;
        }
        case WM_DESTROY:
            /* Anything that needs to be deleted when the window is closed
                goes here... */
            if(wTimer)
                KillTimer(hWnd,wTimer);
            if(hfontMessage)
                DeleteObject(hfontMessage);
            DeleteObject(hbrTemp);
            break;
    }
    /* Unless it is told otherwise, the program will take default actions... */
    return (DefScreenSaverProc(hWnd,message,wParam,lParam));
}

//***************************************************************************

/*  This is where the code for the configure dialog box goes. It is a typical
    dialog box. The corresponding resource that is loaded is called
    'ScreenSaverConfigure' and is located in the ResourceCompiler file.
    Minimally (as in this case), this functions as an about box.  In this
    case, we also get the applications icon which must be defined as
    ID_APP... */

BOOL APIENTRY ScreenSaverConfigureDialog(hDlg, message, wParam, lParam)
HWND   hDlg;
UINT   message;
WPARAM wParam;
LPARAM lParam;
{
UINT            wTemp,wPal =0;
static int      wSize;              // current font size selected.
HPALETTE        hPal;
RECT            rc;
static HWND     hIDOK, hSetPassword;
HDC             hDC;
static LOGFONT  lfFont;
CHOOSEFONT      chfChooseFont;
FARPROC         lpfp;

static HFONT hfontPrev, hFontSave;
static LOGFONT lfFontPrev;

    switch(message)
    {
        case WM_INITDIALOG:
            PWM_NEWSPEED = RegisterWindowMessage(TEXT("PWM_NEWSPEED"));
            PWM_NEWPOSITION = RegisterWindowMessage(TEXT("PWM_NEWPOSITION"));

            LoadStrings ();
            GetAttributes ();
            hIDOK = GetDlgItem (hDlg, IDOK);

            /* Fill up both of the color combo boxes and select the right
                entries... */
            hPal = GetStockObject (DEFAULT_PALETTE);
            GetObject (hPal, sizeof(int), (LPTSTR)&wPal);
            for (wTemp = 0; wTemp < wPal; wTemp++)
                SendDlgItemMessage (hDlg, ID_BGROUNDCOLOR, CB_ADDSTRING, 0,
                                    (LPARAM)TEXT("a"));

            dwBColor = GetProfileRgb (szAppName, szBColorName, DEFAULT_SCREEN_COLOR);
            wTemp = GetNearestPaletteIndex (hPal,dwBColor);
            SendDlgItemMessage (hDlg, ID_BGROUNDCOLOR, CB_SETCURSEL, wTemp, 0l);
            GetPaletteEntries (hPal, wTemp, 1, (LPPALETTEENTRY)(LPDWORD)&dwBColor);

            /* Get the mode of the marquee... */
            CheckRadioButton (hDlg,ID_CENTERED,ID_RANDOM,
                              fMode ? ID_RANDOM : ID_CENTERED);
            SendDlgItemMessage (hDlg, ID_TEXTWINDOW, PWM_NEWPOSITION, fMode, 0l);

            /* Set up the scroll bar to take care of speed... */
            SetScrollRange (GetDlgItem (hDlg,ID_SPEED), SB_CTL, 1, MAX_SPEED * DIV_SPEED,
                            FALSE);
            if ((wTemp = GetPrivateProfileInt (szAppName, szSpeedName, DEF_SPEED, szIniFile))
                < 1)
                wTemp = 1;
            if (wTemp > (MAX_SPEED * DIV_SPEED))
                wTemp = MAX_SPEED * DIV_SPEED;
            SetScrollPos (GetDlgItem (hDlg,ID_SPEED), SB_CTL, wTemp, TRUE);
            SendDlgItemMessage (hDlg, ID_TEXTWINDOW, PWM_NEWSPEED, wTemp, 0l);

            /* Get the text from the .INI file entry and set up the edit box
                where the user enters the text to display... */
            SendDlgItemMessage (hDlg, ID_MARQUEETEXT, EM_LIMITTEXT, CharSizeOf(szBuffer) - 1, 0l);
            GetPrivateProfileString (szAppName, szTextName, szDefaultText, szBuffer,
                                     CharSizeOf(szBuffer), szIniFile);
            SetWindowText (GetDlgItem (hDlg, ID_MARQUEETEXT), szBuffer);

            /* Get the info necessary to create the font... */
            GetPrivateProfileString (szAppName, szFontName, szDefFontName, szFaceName,
                                     CharSizeOf(szFaceName), szIniFile);
            bCharSet = (BYTE)GetPrivateProfileInt (szAppName, szCharSetName,
                                                 (WORD)ANSI_CHARSET, szIniFile);

            if( IsTextIncludeDBCSChar() )
            {
                bCharSet = (BYTE) csi.ciCharset;
            }

            wSize = GetPrivateProfileInt (szAppName, szSizeName, 10, szIniFile);
            // wSize is in POINTS, we need to convert it to LogicalUnits...
            wSize = GetHeightFromPointSize (wSize);

            hfontMessage = CreateFont(wSize,0,0,0,
                (fBold     ==TEXT('0'))?FW_NORMAL:FW_BOLD,
                (TCHAR)((fItalic   ==TEXT('0'))?0:1),
                (TCHAR)((fUnderline==TEXT('0'))?0:1),
                (TCHAR)((fStrikeOut==TEXT('0'))?0:1),
                bCharSet,
                OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,
                DEFAULT_PITCH|FF_DONTCARE,szFaceName);
            dwTColor = GetProfileRgb(szAppName,szTColorName,DEFAULT_TEXT_COLOR);

            lfFont.lfWeight   =(fBold     ==TEXT('0'))?FW_NORMAL:FW_BOLD,
            lfFont.lfItalic   =(fItalic   ==TEXT('0'))?(TCHAR)0:(TCHAR)1,
            lfFont.lfUnderline=(fUnderline==TEXT('0'))?(TCHAR)0:(TCHAR)1,
            lfFont.lfStrikeOut=(fStrikeOut==TEXT('0'))?(TCHAR)0:(TCHAR)1,
            lfFont.lfHeight=(LONG)wSize;
            lfFont.lfCharSet = bCharSet;
            lstrcpyn(lfFont.lfFaceName, szFaceName, CharSizeOf(lfFont.lfFaceName));

            return TRUE;

        case WM_HSCROLL:
            wTemp = GetScrollPos(GetDlgItem(hDlg,ID_SPEED),SB_CTL);
            switch(LOWORD(wParam))
            {
                case SB_PAGEDOWN:
                    wTemp += (DIV_SPEED-1);
                case SB_LINEDOWN:
                    wTemp += 1;
                    wTemp = min(MAX_SPEED*DIV_SPEED,wTemp);
                    break;
                case SB_PAGEUP:
                    wTemp -= (DIV_SPEED-1);
                case SB_LINEUP:
                    wTemp -= 1;
                    wTemp = max(1,(int)wTemp);
                    break;
                case SB_THUMBPOSITION:
                    wTemp = HIWORD(wParam);
                    break;
                case SB_TOP:
                    wTemp = 1;
                    break;
                case SB_BOTTOM:
                    wTemp = MAX_SPEED*DIV_SPEED;
                    break;
            }
            SetScrollPos(GetDlgItem(hDlg,ID_SPEED),SB_CTL,wTemp,TRUE);
            SendDlgItemMessage(hDlg,ID_TEXTWINDOW,PWM_NEWSPEED,wTemp,0l);
            break;

        case WM_MEASUREITEM:
            ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = 12;
            return TRUE;

        case WM_DRAWITEM:
            rc    = ((LPDRAWITEMSTRUCT)lParam)->rcItem;

            if (((LPDRAWITEMSTRUCT)lParam)->itemState & ODS_SELECTED)
            {
                FrameR(((LPDRAWITEMSTRUCT)lParam)->hDC,&rc,RGB(0,0,0),2);
                InflateRect(&rc,-1,-1);
                FrameR(((LPDRAWITEMSTRUCT)lParam)->hDC,&rc,RGB(255,255,255),2);
                InflateRect(&rc,-1,-1);
            }
            FillR(((LPDRAWITEMSTRUCT)lParam)->hDC,&rc,PALETTEINDEX
                (((LPDRAWITEMSTRUCT)lParam)->itemID));
            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case ID_MARQUEETEXT:
                    if(HIWORD(wParam) == EN_UPDATE)
                    {
                        GetDlgItemText (hDlg, ID_MARQUEETEXT, szBuffer, CharSizeOf(szBuffer));

                        if (IsTextIncludeDBCSChar()) {
                            if (lfFont.lfCharSet != csi.ciCharset) {
                                if (hfontPrev) {
                                    if (hfontMessage)
                                        DeleteObject(hfontMessage);
                                    // Restore old font imformation
                                    hfontMessage = hfontPrev;
                                    lfFont = lfFontPrev;
                                    hfontPrev = NULL;
                                }
                                else {
                                    // Save old font imformation
                                    hfontPrev = hfontMessage;
                                    lfFontPrev = lfFont;
                                    lfFont.lfCharSet = (BYTE) csi.ciCharset;
                                    hfontMessage = CreateFontIndirect((LPLOGFONT)&lfFont);
                                }
                                SendDlgItemMessage(hDlg, ID_TEXTWINDOW, PWM_NEWPOSITION, fMode, 0l);
                                InvalidateRect(GetDlgItem(hDlg, ID_TEXTWINDOW), NULL, TRUE);
                            }
                        }
                        else {
                            if (lfFont.lfCharSet == csi.ciCharset) {
                                if (hfontPrev) {
                                    if (hfontMessage)
                                        DeleteObject(hfontMessage);
                                    // Restore old font imformation
                                    hfontMessage = hfontPrev;
                                    lfFont = lfFontPrev;
                                    hfontPrev = NULL;
                                    SendDlgItemMessage(hDlg, ID_TEXTWINDOW, PWM_NEWPOSITION, fMode, 0l);
                                    InvalidateRect(GetDlgItem(hDlg, ID_TEXTWINDOW), NULL, TRUE);
                                }
                            }
                        }
                        bCharSet = lfFont.lfCharSet;
                        SetDlgItemText (hDlg, ID_TEXTWINDOW, szBuffer);
                    }
                    break;

                case ID_CENTERED:
                case ID_RANDOM:
                    fMode=(wParam!=ID_CENTERED);
                    SendDlgItemMessage(hDlg,ID_TEXTWINDOW,PWM_NEWPOSITION,fMode,0l);
                    CheckRadioButton(hDlg,ID_CENTERED,ID_RANDOM,LOWORD(wParam));
                    break;

                case ID_FORMATTEXT:
                    hDC = GetDC(hDlg);

                    hFontSave = SelectObject( hDC, hfontMessage );
                    GetTextFace( hDC, LF_FACESIZE, lfFont.lfFaceName );
                    SelectObject( hDC, hFontSave );

                    chfChooseFont.lStructSize = sizeof (CHOOSEFONT);
                    chfChooseFont.hwndOwner = hDlg;
                    chfChooseFont.hDC = hDC;
                    chfChooseFont.lpLogFont = &lfFont;
                    chfChooseFont.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT |
                                          CF_LIMITSIZE | CF_EFFECTS | CF_ENABLEHOOK;
                    chfChooseFont.rgbColors = dwTColor;
                    chfChooseFont.lCustData = 0L;
                    chfChooseFont.lpfnHook = (LPCFHOOKPROC)ChooseFontHookProc;
                    chfChooseFont.lpTemplateName = (LPTSTR)NULL;
                    chfChooseFont.hInstance = (HANDLE) NULL;
                    chfChooseFont.lpszStyle = (LPTSTR) NULL;
                    chfChooseFont.nFontType = SCREEN_FONTTYPE;
                    chfChooseFont.nSizeMin = 8;
                    chfChooseFont.nSizeMax = 200;
                    if (ChooseFont(&chfChooseFont))
                    {
                        lstrcpyn(szFaceName, lfFont.lfFaceName, CharSizeOf(szFaceName));
                        wSize     =lfFont.lfHeight;
                        dwTColor  =chfChooseFont.rgbColors;
                        fStrikeOut=(lfFont.lfStrikeOut)?(TCHAR)TEXT('1'):(TCHAR)TEXT('0');
                        fUnderline=(lfFont.lfUnderline)?(TCHAR)TEXT('1'):(TCHAR)TEXT('0');
                        fItalic   =(lfFont.lfItalic)   ?(TCHAR)TEXT('1'):(TCHAR)TEXT('0');
                        fBold     =(lfFont.lfWeight==FW_NORMAL)?(TCHAR)TEXT('0'):(TCHAR)TEXT('1');
                        bCharSet  =lfFont.lfCharSet;

                        if (hfontPrev)
                        {
                            DeleteObject(hfontPrev);
                            hfontPrev = NULL;
                        }

                        if (hfontMessage)
                           DeleteObject(hfontMessage);

                        hfontMessage = CreateFontIndirect((LPLOGFONT)&lfFont);

                        if (IsTextIncludeDBCSChar()) {
                            if (lfFont.lfCharSet != csi.ciCharset) {
                                hfontPrev = hfontMessage ;
                                lfFontPrev = lfFont ;
                                lfFont.lfCharSet = (BYTE) csi.ciCharset ;
                                hfontMessage = CreateFontIndirect( &lfFont );
                            }
                        }

                        SendDlgItemMessage(hDlg,ID_TEXTWINDOW,PWM_NEWPOSITION,fMode,0l);
                        InvalidateRect(GetDlgItem(hDlg,ID_TEXTWINDOW),NULL,TRUE);
                    }
                    ReleaseDC(hDlg, hDC);
                    break;

                case ID_BGROUNDCOLOR:
                    if(HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        wTemp = (WORD)SendDlgItemMessage(hDlg,LOWORD(wParam),
                            CB_GETCURSEL,0,0l);
                        hPal = GetStockObject(DEFAULT_PALETTE);
                        GetPaletteEntries(hPal,wTemp,1,
                            (LPPALETTEENTRY)(LPDWORD)&dwBColor);
                        InvalidateRect(GetDlgItem(hDlg,ID_TEXTWINDOW),NULL,TRUE);
                    }
                    break;

                case IDOK:
                    GetWindowText(GetDlgItem(hDlg,ID_MARQUEETEXT),szBuffer,CharSizeOf(szBuffer));
                    WritePrivateProfileString(szAppName,szTextName,szBuffer, szIniFile);

                    WritePrivateProfileString(szAppName,szFontName,szFaceName, szIniFile);

                    // wSize is in logical units... we want to save as point size.
                    hDC = GetDC(hDlg);
                    wSize = MulDiv(-wSize, 72, GetDeviceCaps(hDC, LOGPIXELSY));
                    wsprintf(szBuffer, TEXT("%d"), wSize);
                    WritePrivateProfileString(szAppName,szSizeName, szBuffer, szIniFile);
                    ReleaseDC(hDlg, hDC);

                    hPal = GetStockObject(DEFAULT_PALETTE);
                    wTemp = (WORD)SendDlgItemMessage(hDlg,ID_BGROUNDCOLOR,CB_GETCURSEL,
                        0,0l);
                    GetPaletteEntries(hPal,wTemp,1,
                        (LPPALETTEENTRY)(LPDWORD)&dwBColor);
                    wsprintf(szBuffer,TEXT("%d %d %d"),GetRValue(dwBColor),
                        GetGValue(dwBColor),GetBValue(dwBColor));
                    WritePrivateProfileString(szAppName,szBColorName,szBuffer, szIniFile);

                    wsprintf(szBuffer,TEXT("%d %d %d"),GetRValue(dwTColor),
                        GetGValue(dwTColor),GetBValue(dwTColor));
                    WritePrivateProfileString(szAppName,szTColorName,szBuffer, szIniFile);

                    wTemp = GetScrollPos(GetDlgItem(hDlg,ID_SPEED),SB_CTL);
                    wsprintf(szBuffer,TEXT("%d"),wTemp);
                    WritePrivateProfileString(szAppName,szSpeedName,szBuffer, szIniFile);

                    szBuffer[UNDERLINE]=fUnderline;
                    szBuffer[STRIKEOUT]=fStrikeOut;
                    szBuffer[ITALIC]=fItalic;
                    szBuffer[MODE]=(fMode?(TCHAR)TEXT('1'):(TCHAR)TEXT('0'));
                    szBuffer[BOLD]=fBold;
                    szBuffer[NATTRIBUTES]=TEXT('\0');
                    WritePrivateProfileString(szAppName,szAttributes,szBuffer,szIniFile);

                    wsprintf(szBuffer, TEXT("%i"), (int)bCharSet);
                    WritePrivateProfileString(szAppName,szCharSetName,szBuffer,szIniFile);

                case IDCANCEL:
                    if (hfontMessage)
                        DeleteObject(hfontMessage);
                    EndDialog(hDlg,LOWORD(wParam) == IDOK);
                    return TRUE;

            }
            break;

    case WM_HELP: // F1
        WinHelp(
            (HWND) ((LPHELPINFO) lParam)->hItemHandle,
            szHelpFile,
            HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aMarqueeDlgHelpIds
        );
        break;

    case WM_CONTEXTMENU:  // right mouse click
        WinHelp(
            (HWND) wParam,
            szHelpFile,
            HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aMarqueeDlgHelpIds
        );
        break;

        default:
            break;
    }
    return FALSE;
}

//***************************************************************************

BOOL APIENTRY ChooseFontHookProc(hDlg, msg, wParam, lParam)
HWND  hDlg;
UINT  msg;
DWORD wParam;
LONG  lParam;
{
    switch(msg)
    {
        case WM_INITDIALOG:
            ShowWindow(hDlg, SW_SHOWNORMAL);    // bug #12820
            SetWindowText(hDlg, szFormatText);
            break;
    }
    return (FALSE);
}

//***************************************************************************

/* This procedure is called right before the dialog box above is created in
    order to register any child windows that are custom controls.  If no
    custom controls need to be registered, then simply return TRUE as in this
    case.  Otherwise, register the child controls however is convenient... */

BOOL     RegisterDialogClasses ( hInst )
HANDLE   hInst;
{
    WNDCLASS wc;

    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = ShowTextProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInst;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szShowTextName;

    return RegisterClass(&wc);
}

//***************************************************************************

int GetHeightFromPointSize(int szPoints)
{
    HDC hdc;
    int height;

    hdc = GetDC(NULL);
    height = MulDiv(-szPoints, GetDeviceCaps(hdc, LOGPIXELSY), 72);
    ReleaseDC(NULL, hdc);

    return height;
}

void PatB(HDC hdc,int x,int y,int dx,int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

void FillR(HDC hdc, LPRECT prc, DWORD rgb)
{
    SetBkColor(hdc,rgb);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL);
}

void FrameR(HDC hdc, LPRECT prc, DWORD rgb, int iFrame)
{
    int     dx,dy;

    dx = prc->right  - prc->left;
    dy = prc->bottom - prc->top - 2*iFrame;

    PatB(hdc, prc->left, prc->top,          dx,iFrame,   rgb);
    PatB(hdc, prc->left, prc->bottom-iFrame,dx,iFrame,   rgb);

    PatB(hdc, prc->left,          prc->top+iFrame, iFrame,dy, rgb);
    PatB(hdc, prc->right-iFrame,  prc->top+iFrame, iFrame,dy, rgb);
}

void srand ( dwSeed )
DWORD dwSeed;
{
    dwRand = dwSeed;
}

WORD rand ( void )
{
    dwRand = dwRand * 214013L + 2531011L;
    return (WORD)((dwRand >> 16) & 0xffff);
}

LRESULT APIENTRY ShowTextProc ( hWnd, message, wParam, lParam )
HWND  hWnd;
UINT  message;
WPARAM wParam;
LPARAM lParam;
{
    PAINTSTRUCT     ps;
    RECT            rc;
    TCHAR           ach[180];
    int             len;
    static SIZE     sizeExt;
    HFONT           hfontT;
    HBRUSH          hbrTemp;
    static UINT_PTR wTimer;
    static WORD     wCount;
    static WORD     wInc;
    static WORD     wStep;
    static WORD     wHeight;
    static BOOL     bMELocale;
    static BOOL     fNeedToInitHeight;
    HDC             hDC;
    DWORD           dwLocale;
    UINT            uiETOFlags;

    switch (message)
    {
    case WM_CREATE:
        //  See if the user locale id is Arabic or Hebrew.
        dwLocale    = GetUserDefaultLCID();
        bMELocale = ((PRIMARYLANGID(LANGIDFROMLCID(dwLocale)) == LANG_ARABIC) ||
                (PRIMARYLANGID(LANGIDFROMLCID(dwLocale)) == LANG_HEBREW));

        GetClientRect(hWnd,&rc);
        if(wTimer = SetTimer(hWnd,1,1,NULL))
            wCount = (WORD) rc.right;
        else
            wCount = 0;

        wStep = DEF_SPEED;
        hDC = GetDC(NULL);
        GetTextExtentPoint32 (hDC, TEXT("T"), 1, &sizeExt);
        wHeight = (WORD)(((rc.bottom-rc.top)-sizeExt.cy)/2);
        fNeedToInitHeight = TRUE;
        ReleaseDC(NULL, hDC);
        break;

    case WM_TIMER:
        InvalidateRect(hWnd,NULL,FALSE);
        break;

    case WM_DESTROY:
        KillTimer(hWnd,wTimer);
        break;

    case WM_SETTEXT:
        DefWindowProc(hWnd, message, wParam, lParam);
        InvalidateRect(hWnd,NULL,FALSE);
    case WM_PAINT:
        BeginPaint(hWnd, &ps);
        wInc += wStep;
        if (wInc >= DIV_SPEED)
        {
           WORD          wVelocity;
           TEXTMETRIC    tm;

            wVelocity = (wInc / DIV_SPEED) + 1;

            if (bMELocale) {
                wCount += wVelocity;
            } else {
                wCount -= wVelocity;
            }

            wInc = wInc % DIV_SPEED;
            len = GetWindowText (hWnd,ach,180);
            if (hfontMessage)
                hfontT = SelectObject(ps.hdc,hfontMessage);
            else
                hfontT = NULL;
            GetTextExtentPoint32 (ps.hdc, ach, len, &sizeExt);
            GetTextMetrics (ps.hdc, &tm);
            GetClientRect(hWnd,&rc);

            if (bMELocale) {
                 if (((short)wCount >= rc.right) || fNeedToInitHeight)
                 {
                   wCount = (WORD)(0 - sizeExt.cx + 1);
                   if(fMode)
                       wHeight = (WORD)(ZRAND(((rc.bottom-rc.top)-(sizeExt.cy/4))));
                   else
                       wHeight = (WORD)((int)((rc.bottom-rc.top)-(int)sizeExt.cy)/2);
                 }
            } else {
                 if ((((short)wCount + (short)sizeExt.cx) < 0) || fNeedToInitHeight)
                 {
                   wCount = (WORD) rc.right;
                   if(fMode)
                       wHeight = (WORD)(ZRAND(((rc.bottom-rc.top)-(sizeExt.cy/4))));
                   else
                       wHeight = (WORD)((int)((rc.bottom-rc.top)-(int)sizeExt.cy)/2);
                 }
            }

            if(fNeedToInitHeight)
                fNeedToInitHeight = FALSE;
                
            SetBkColor (ps.hdc,dwBColor);
            SetTextColor (ps.hdc,dwTColor);

#ifdef NOT_USED
//////////////////////////////////////////////////////////////////////////////
// This should have never been put in since this winproc only handles the
// "Sample Text Window"  control for the configuration dialog.  It is OK to
// use the whole client area as the opaqueing rect.
//////////////////////////////////////////////////////////////////////////////
            // Compute the opaque rectangle.
            rc.top    = (int)(short) wHeight;
            rc.left   = (int)(short) wCount;
            rc.bottom = (int)(short) wHeight + sizeExt.cy;
            rc.right  = (int)(short) wCount + sizeExt.cx + wVelocity
                                     + tm.tmMaxCharWidth * 2;
#endif  //  NOT_USED

            uiETOFlags = ETO_OPAQUE;
            if (bMELocale) {
              uiETOFlags |= ETO_RTLREADING;
            }

            ExtTextOut (ps.hdc,(int)(short) wCount, (int)(short)wHeight, uiETOFlags, (LPRECT)&rc,
                        ach, len, NULL);
            if (hfontT)
                SelectObject(ps.hdc, hfontT);
        }
        EndPaint (hWnd, &ps);
        return 0L;

    case WM_ERASEBKGND:
        hbrTemp = CreateSolidBrush (dwBColor);
        if (hbrTemp)
        {
            GetClientRect (hWnd, &rc);
            FillRect ((HDC)wParam, &rc, hbrTemp);
            DeleteObject (hbrTemp);
        }
        return 0l;

    default:
        if (message == PWM_NEWSPEED)
        {
            wStep = (WORD) wParam;
            break;
        }
        if (message == PWM_NEWPOSITION)
        {
            GetClientRect (hWnd,&rc);
            if (fMode)
                wHeight = (WORD)(ZRAND(((rc.bottom-rc.top)-(sizeExt.cy/4))));
            else
                wHeight = (WORD)((int)((rc.bottom-rc.top)-(int)sizeExt.cy)/2);
            fNeedToInitHeight = TRUE;
            InvalidateRect(hWnd,NULL,TRUE);
            break;
        }
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}

DWORD GetProfileRgb (LPTSTR szApp, LPTSTR szItem, DWORD rgb)
{
  TCHAR    buf[80];
  LPTSTR   pch;
  WORD     r,g,b;

    GetPrivateProfileString (szApp, szItem, TEXT(""), buf, CharSizeOf(buf), szIniFile);

    if (*buf)
    {
        pch = buf;
        r = AtoI (pch);
        while (*pch && *pch != TEXT(' '))
            pch++;
        while (*pch && *pch == TEXT(' '))
            pch++;
        g = AtoI(pch);
        while (*pch && *pch != TEXT(' '))
            pch++;
        while (*pch && *pch == TEXT(' '))
            pch++;
        b = AtoI(pch);

        return RGB(r,g,b);
    }
    else
        return rgb;
}

WORD  AtoI (LPTSTR  lpszConvert)
{
  WORD  wReturn = 0;

    while(*lpszConvert >= TEXT('0') && *lpszConvert <= TEXT('9'))
    {
        wReturn = wReturn*10 + (WORD)(*lpszConvert - TEXT('0'));
        lpszConvert++;
    }
    return wReturn;
}

void GetAttributes(void)
{
    TCHAR szBuffer[NATTRIBUTES+1];

    GetPrivateProfileString (szAppName, szAttributes, TEXT("00000"), szBuffer,
                             CharSizeOf(szBuffer), szIniFile);

    fUnderline = szBuffer[UNDERLINE];
    fStrikeOut = szBuffer[STRIKEOUT];
    fItalic = szBuffer[ITALIC];
    fMode = (szBuffer[MODE] == TEXT('1'));
    fBold = szBuffer[BOLD];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\cameramove.h ===
/*****************************************************************************\
    FILE: CameraMove.h

    DESCRIPTION:
        The caller can create this object to tell it to move from point a to 
    point b from time t1 to time t2.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef CAMERAMOVE_H
#define CAMERAMOVE_H

class CCameraMove;

#include "util.h"
#include "main.h"


class CCameraMove
{
public:
    // Member Functions
    virtual HRESULT Init(D3DXVECTOR3 vStartLoc, D3DXVECTOR3 vStartTangent, D3DXVECTOR3 vUpVec);
    virtual HRESULT CreateNextMove(D3DXVECTOR3 vSourceLoc, D3DXVECTOR3 vSourceTangent, D3DXVECTOR3 vDestLoc, D3DXVECTOR3 vDestTangent);
    virtual HRESULT CreateNextRotate(D3DXVECTOR3 vSourceLoc, D3DXVECTOR3 vSourceTangent, D3DXVECTOR3 vDestTangent);
    virtual HRESULT CreateNextWait(int nBatch, int nPreFetch, float fTime = -1.0f);

    virtual HRESULT SetCamera(IDirect3DDevice8 * pD3DDevice, FLOAT fTimeKeyIn);

    virtual HRESULT DeleteAllMovements(float fCurrentTime);

    CCameraMove();
    ~CCameraMove();

private:
    // Helper Functions


    // Member Variables
    D3DXVECTOR3 m_vUpVec;
    D3DXVECTOR3 m_vLocLast;           // This is the last location we were in.
    D3DXVECTOR3 m_vLookAtLast;        // This is the last location we were looking at.

    D3DXVECTOR3 m_vEyePrev;
    D3DXVECTOR3 m_vLookAtPrev;

    HDPA m_hdpaMovements;           // This contains CAMERA_MOVEMENT items.
    int m_nCurrent;
    int m_nFramesFromCurrent;

    float m_fTimeInPreviousMovements;
    float m_fTimeWarp;

    float m_fTimeToRotate;
    float m_fTimeToWalk;
    float m_fTimeToLookAtPainting;
    int m_nMinTurnFrames;
    int m_nMinWalkFrames;
    int m_nMaxTurnFrames;
    int m_nMaxWalkFrames;
};



#endif // CAMERAMOVE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\config.cpp ===
/*****************************************************************************\
    FILE: config.cpp

    DESCRIPTION:
        The class will handle the user's configuration state.  It will also
    display the Screen Saver's configuration dialog to allow the user to change
    these settings.

    BryanSt 12/18/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include <shlobj.h>
#include "config.h"
#include "resource.h"


#define SZ_REGKEY_THISSCREENSAVER       TEXT("Software\\Microsoft\\Screensavers\\Museum")
#define SZ_REGKEY_THISSS_CONFIG         SZ_REGKEY_THISSCREENSAVER TEXT("\\Config")

#define SZ_REGVALUE_QUALITYSLIDER       TEXT("Quality Slider")
#define SZ_REGVALUE_SPEEDSLIDER         TEXT("Speed Slider")
#define SZ_REGVALUE_TEMPMB              TEXT("Temp Disk Space")
#define SZ_REGVALUE_WALKSPEED           TEXT("Walk Speed")
#define SZ_REGVALUE_OTHERPICTURES       TEXT("Other Pictures Directory")
#define SZ_REGVALUE_VIEWTIME            TEXT("View Painting Time")

SPEED_SETTING s_SpeedSettings[MAX_SPEED] =
{
    {15.0f, 15.0f, 60.0f, 15, 15, 50, 50},
    {11.0f, 11.0f, 25.0f, 12, 12, 35, 35},
    {10.0f, 10.0f, 15.0f, 10, 10, 35, 35},
    {7.0f, 7.0f, 12.0f, 9, 9, 25, 25},
    {4.0f, 4.0f, 10.0f, 8, 8, 25, 25},
    {4.0f, 4.0f, 7.0f, 7, 7, 25, 25},
    {2.5f, 2.5f, 5.0f, 6, 6, 21, 21},
    {2.0f, 2.0f, 2.50f, 5, 5, 17, 17},
    {2.00f, 2.0f, 1.5f, 10, 10, 15, 15},
    {0.50f, 0.5f, 0.5f, 7, 7, 15, 15},
    {0.50f, 0.5f, 0.5f, 5, 5, 15, 15},
//    {5.00f, 10.0f, 0.50f, 5, 5, 15, 15},
};


static QUALITY_SETTING s_QualitySettings[NUM_BOOL_SETTINGS] = 
{
    {TEXT("Show Stats")},                 // IDC_CHECK_SHOWSTATS
};


// Values we can add: Lighing, Vectors on floor, etc.
static BOOL s_fQualityValues[MAX_QUALITY][NUM_BOOL_SETTINGS] =
{   // ORDER: AntiAlias, Texture Perspective, Texture Dithering, Depth Buffering (Z), Specular Highlights, Anti-Alias Edges, Render Quality (Flat, Gouraud, Phong)
    {0},
    {0},
    {0},
    {0},
    {0},
    {0},
    {0},
    {0}
};

#define MINUTE          60

static int s_nViewTimeSettings[MAX_VIEWTIME] =
{ 1, 2, 3, 4, 5, 7, 10, 12, 15, 17,
  20, 25, 30, 35, 40, 45, 50, 55, MINUTE, MINUTE + 15, 
  MINUTE + 30, MINUTE + 45, 2 * MINUTE, 2 * MINUTE + 30, 3 * MINUTE, 4 * MINUTE, 5 * MINUTE, 7 * MINUTE, 10 * MINUTE, 20 * MINUTE};

static DWORD s_RenderQualitySliderValues[MAX_QUALITY] = 
{
    0, 1, 1, 1, 2, 2, 2, 2
};


static LPCTSTR s_pszDWORDSettingsArray[NUM_DWORD_SETTINGS] = 
{
    TEXT("RenderQuality"),              // IDC_RENDERQUALITY1
    TEXT("RealTimeMode"),               // Walking Speed                 
    TEXT("Quality Slider"),                      
    TEXT("Speed Slider"),                      
    TEXT("View Time Slider"),                      
};

static FOLDER_SETTING s_FolderSettings[NUM_BOOL_FOLDERS] = 
{
    {TEXT("My Pictures"), TRUE},                 // IDC_CHECK_MYPICTS
    {TEXT("Common Pictures"), FALSE},            // IDC_CHECK_COMMONPICTS
    {TEXT("Windows Pictures"), TRUE},            // IDC_CHECK_WINPICTS
    {TEXT("Other Pictures"), FALSE},             // IDC_CHECK_OTHERPICTS
};

static DWORD s_dwSettingsDefaults[NUM_DWORD_SETTINGS] = 
{
    DEFAULT_RENDERQUALITY,              // CONFIG_DWORD_RENDERQUALITY
    2,                                  // CONFIG_DWORD_REALTIMEMODE
    DEFAULT_QUALITYSLIDER,              // CONFIG_DWORD_QUALITY_SLIDER
    DEFAULT_SPEEDSLIDER,                // CONFIG_DWORD_SPEED_SLIDER
    DEFAULT_VIEWTIMESLIDER,             // CONFIG_DWORD_VIEWPAINTINGTIME
};

CConfig * g_pConfig = NULL;                         // The configuration settings the user wants to use.



CConfig::CConfig(CMSLogoDXScreenSaver * pMain)
{
    m_hkeyCurrentUser = NULL;
    m_fLoaded = FALSE;
    m_hDlg = NULL;
    m_szOther[0] = 0;

    m_pMain = pMain;

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
    {
        m_pszCustomPaths[nIndex] = NULL;
        m_dwCustomScale[nIndex] = 100;          // Default to 100%
    }
}


CConfig::~CConfig()
{
    if (m_hkeyCurrentUser)
    {
        RegCloseKey(m_hkeyCurrentUser);
        m_hkeyCurrentUser = NULL;
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
    {
        Str_SetPtr(&(m_pszCustomPaths[nIndex]), NULL);
    }
}


HRESULT CConfig::_GetStateFromUI(void)
{
    int nIndex;

    // Get Directory Checkboxes
    for (nIndex = 0; nIndex < ARRAYSIZE(m_fFolders); nIndex++)
    {
        m_fFolders[nIndex] = GetCheckBox(m_hDlg, IDC_CHECK_MYPICTS + nIndex);
    }

    // Set Other Path
    GetWindowText(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_szOther, ARRAYSIZE(m_szOther));

    // Get Sliders
    m_dwSettings[CONFIG_DWORD_SPEED_SLIDER] = (DWORD) TaskBar_GetPos(GetDlgItem(m_hDlg, IDC_SLIDER_SPEED));
    m_dwSettings[CONFIG_DWORD_QUALITY_SLIDER] = (DWORD) TaskBar_GetPos(GetDlgItem(m_hDlg, IDC_SLIDER_QUALITY));
    m_dwSettings[CONFIG_DWORD_VIEWPAINTINGTIME] = s_nViewTimeSettings[(DWORD) TaskBar_GetPos(GetDlgItem(m_hDlg, IDC_SLIDER_VIEWTIME))];
  
    // Get Walk Speed ComboBox
    m_dwSettings[CONFIG_DWORD_REALTIMEMODE] = 0;

    return S_OK;
}


HRESULT CConfig::_LoadQualitySliderValues(void)
{
    int nNewPos = TaskBar_GetPos(GetDlgItem(m_hDlg, IDC_SLIDER_QUALITY));

    if ((nNewPos < 0) || (nNewPos >= MAX_QUALITY))
    {
        nNewPos = DEFAULT_QUALITYSLIDER;    // The value was invalid so revert to a valid value.
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_fSettings); nIndex++)
    {
        m_fSettings[nIndex] = s_fQualityValues[nNewPos][nIndex];
    }

    m_dwSettings[CONFIG_DWORD_RENDERQUALITY] = s_RenderQualitySliderValues[nNewPos];

    return S_OK;
}


HRESULT CConfig::_UpdateViewTimeSelection(void)
{
    int nNewPos = TaskBar_GetPos(GetDlgItem(m_hDlg, IDC_SLIDER_VIEWTIME));
    TCHAR szDesc[MAX_PATH];

    if ((nNewPos < 0) || (nNewPos >= MAX_VIEWTIME))
    {
        nNewPos = DEFAULT_VIEWTIMESLIDER;    // The value was invalid so revert to a valid value.
    }

    LoadString(HINST_THISDLL, IDS_VIEW_TIME_DESC + nNewPos, szDesc, ARRAYSIZE(szDesc));
    SetWindowText(GetDlgItem(m_hDlg, IDC_STATIC_VIEWTIME), szDesc);

    return S_OK;
}


int CALLBACK BrowseCallback(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
{
    int nResult = 0;

    switch (msg)
    {
    case BFFM_INITIALIZED:
        if (lpData)   // Documentation says it will be NULL but other code does this.
        {
            // we passed ppidl as lpData so pass on just pidl
            // Notice I pass BFFM_SETSELECTIONA which would normally indicate ANSI.
            // I do this because Win95 requires it, but it doesn't matter because I'm
            // only passing a pidl
            SendMessage(hwnd, BFFM_SETSELECTIONA, FALSE, (LPARAM)((LPITEMIDLIST)lpData));
        }
        break;
    }

    return nResult;
}


HRESULT CConfig::_OnBrowseForFolder(void)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlCurrent = NULL;
    BROWSEINFO bi = {0};
    TCHAR szTitle[MAX_PATH];

    GetWindowText(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_szOther, ARRAYSIZE(m_szOther));
    LoadString(HINST_THISDLL, IDS_OTHERBROWSE_TITLE, szTitle, ARRAYSIZE(szTitle));

    hr = ShellFolderParsePath(m_szOther, &pidlCurrent);
    bi.hwndOwner = m_hDlg;
    bi.lpszTitle = szTitle;
    bi.lpfn = BrowseCallback;
    bi.lParam = (LPARAM) pidlCurrent;
    bi.ulFlags = (BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS | BIF_EDITBOX | BIF_USENEWUI | BIF_VALIDATE);

    LPITEMIDLIST pidlNew = SHBrowseForFolder(&bi);
    if (pidlNew)
    {
        hr = ShellFolderGetPath(pidlNew, m_szOther, ARRAYSIZE(m_szOther));
        if (SUCCEEDED(hr))
        {
            SetWindowText(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_szOther);
        }

        ILFree(pidlNew);
    }

    ILFree(pidlCurrent);

    return hr;
}


HRESULT CConfig::_OnInitDlg(HWND hDlg)
{
    m_hDlg = hDlg;
    int nIndex;

    // Set Directory Checkboxes
    for (nIndex = 0; nIndex < ARRAYSIZE(m_fFolders); nIndex++)
    {
        SetCheckBox(m_hDlg, IDC_CHECK_MYPICTS + nIndex, m_fFolders[nIndex]);
    }

    // Set Other Path
    SetWindowText(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_szOther);
    EnableWindow(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_fFolders[3]);
    EnableWindow(GetDlgItem(m_hDlg, IDC_BUTTON_BROWSEPICTS), m_fFolders[3]);

    // If we want to run on IE4, we need to delay load this.
    SHAutoComplete(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), SHACF_FILESYSTEM);

    // Set Sliders
    TaskBar_SetRange(GetDlgItem(m_hDlg, IDC_SLIDER_SPEED), TRUE, 0, MAX_SPEED-1);
    TaskBar_SetPos(GetDlgItem(m_hDlg, IDC_SLIDER_SPEED), TRUE, m_dwSettings[CONFIG_DWORD_SPEED_SLIDER]);

    TaskBar_SetRange(GetDlgItem(m_hDlg, IDC_SLIDER_QUALITY), TRUE, 0, MAX_QUALITY-1);
    TaskBar_SetPos(GetDlgItem(m_hDlg, IDC_SLIDER_QUALITY), TRUE, m_dwSettings[CONFIG_DWORD_QUALITY_SLIDER]);

    TaskBar_SetRange(GetDlgItem(m_hDlg, IDC_SLIDER_VIEWTIME), TRUE, 0, MAX_VIEWTIME-1);
    TaskBar_SetPos(GetDlgItem(m_hDlg, IDC_SLIDER_VIEWTIME), TRUE, m_dwSettings[CONFIG_DWORD_VIEWPAINTINGTIME]);

    _UpdateViewTimeSelection();

    return S_OK;
}


HRESULT CConfig::_OnDestroy(HWND hDlg)
{
    return S_OK;
}


BOOL CConfig::_IsDialogDataValid(void)
{
    BOOL fValid = TRUE;

    GetWindowText(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_szOther, ARRAYSIZE(m_szOther));
    if (m_fFolders[CONFIG_FOLDER_OTHER])
    {
        if (!PathFileExists(m_szOther))
        {
            TCHAR szMessage[MAX_PATH];
            TCHAR szTitle[MAX_PATH];

            LoadString(HINST_THISDLL, IDS_ERROR_INVALIDOTHERPATH, szMessage, ARRAYSIZE(szMessage));
            LoadString(HINST_THISDLL, IDS_ERROR_TITLE_OTHERPATH, szTitle, ARRAYSIZE(szTitle));
            MessageBox(m_hDlg, szMessage, szTitle, MB_OK);
            fValid = FALSE;
        }
        else if (!PathIsDirectory(m_szOther))
        {
            TCHAR szMessage[MAX_PATH];
            TCHAR szTitle[MAX_PATH];

            LoadString(HINST_THISDLL, IDS_ERROR_OTHERPATH_NOTDIR, szMessage, ARRAYSIZE(szMessage));
            LoadString(HINST_THISDLL, IDS_ERROR_TITLE_OTHERPATH, szTitle, ARRAYSIZE(szTitle));
            MessageBox(m_hDlg, szMessage, szTitle, MB_OK);
            fValid = FALSE;
        }
    }

    return fValid;
}


HRESULT CConfig::_OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    WORD wEvent = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (idCtrl)
    {
    case IDOK:
        if (_IsDialogDataValid())
        {
            _GetStateFromUI();
            EndDialog(hDlg, IDOK);
        }
        break;

    case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;

    case IDC_CHECK_OTHERPICTS:
        if ((BN_CLICKED == wEvent) && (IDC_CHECK_OTHERPICTS == idCtrl))
        {
            m_fFolders[3] = GetCheckBox(m_hDlg, IDC_CHECK_OTHERPICTS);

            EnableWindow(GetDlgItem(m_hDlg, IDC_EDIT_OTHERPICTS), m_fFolders[3]);
            EnableWindow(GetDlgItem(m_hDlg, IDC_BUTTON_BROWSEPICTS), m_fFolders[3]);
        }
        break;


    case IDC_BUTTON_ADVANCEDQUALITY:
        DisplayAdvancedDialog(m_hDlg);
        break;

    case IDC_BUTTON_BROWSEPICTS:
        _OnBrowseForFolder();
        break;

    case IDC_BUTTON_MONITORSETTINGS:
        if (m_pMain)
        {
            m_pMain->DisplayMonitorSettings(hDlg);
        }
        break;

    default:
        break;
    }

    return S_OK;
}


INT_PTR CALLBACK CConfig::ConfigDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CConfig * pThis = (CConfig *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CConfig *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
    {
        return pThis->_ConfigDlgProc(hDlg, wMsg, wParam, lParam);
    }

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR CConfig::_ConfigDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_NOTIFY:
        break;

    case WM_INITDIALOG:
        _OnInitDlg(hDlg);
        break;

    case WM_DESTROY:
        _OnDestroy(hDlg);
        break;

    case WM_HELP:
        // TODO: Get help strings
//        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_ADVAPPEARANCE, HELP_WM_HELP, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
//        WinHelp((HWND) wParam, SZ_HELPFILE_ADVAPPEARANCE, HELP_CONTEXTMENU, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_COMMAND:
        _OnCommand(hDlg, message, wParam, lParam);
        break;

    case WM_HSCROLL:
    case WM_VSCROLL:
        if (GetDlgItem(m_hDlg, IDC_SLIDER_VIEWTIME) == (HWND) lParam)
        {
            _UpdateViewTimeSelection();
        }
        else if (GetDlgItem(m_hDlg, IDC_SLIDER_QUALITY) == (HWND) lParam)
        {
            _LoadQualitySliderValues();
        }
        break;
    }

    return FALSE;
}


HRESULT CConfig::_LoadState(void)
{
    HRESULT hr = S_OK;

    if (!m_fLoaded)
    {
        if (!m_hkeyCurrentUser)
        {
            hr = HrRegCreateKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_THISSS_CONFIG, 0, NULL, REG_OPTION_NON_VOLATILE, (KEY_WRITE | KEY_READ), NULL, &m_hkeyCurrentUser, NULL);
        }

        if (m_hkeyCurrentUser)
        {
            int nIndex;

            for (nIndex = 0; nIndex < ARRAYSIZE(m_fSettings); nIndex++)
            {
                HrRegGetDWORD(m_hkeyCurrentUser, NULL, s_QualitySettings[nIndex].pszRegValue, (DWORD *)&m_fSettings[nIndex], s_fQualityValues[DEFAULT_QUALITYSLIDER][nIndex]);
            }

            for (nIndex = 0; nIndex < ARRAYSIZE(m_dwSettings); nIndex++)
            {
                HrRegGetDWORD(m_hkeyCurrentUser, NULL, s_pszDWORDSettingsArray[nIndex], &m_dwSettings[nIndex], s_dwSettingsDefaults[nIndex]);
            }

            // For the view time, we persist the number of seconds, not the slot number.
            // Let's find the slot number from the view time in seconds..
            for (nIndex = 0; nIndex < ARRAYSIZE(s_nViewTimeSettings); nIndex++)
            {
                if ((DWORD)s_nViewTimeSettings[nIndex] == m_dwSettings[CONFIG_DWORD_VIEWPAINTINGTIME])
                {
                    m_dwSettings[CONFIG_DWORD_VIEWPAINTINGTIME] = nIndex;
                    break;
                }
            }

            for (nIndex = 0; nIndex < ARRAYSIZE(m_fFolders); nIndex++)
            {
                HrRegGetDWORD(m_hkeyCurrentUser, NULL, s_FolderSettings[nIndex].pszRegValue, (DWORD *)&m_fFolders[nIndex], s_FolderSettings[nIndex].fDefaultToOn);    // Only default to on for IDC_CHECK_WINPICTS
            }

            if (FAILED(HrRegGetValueString(m_hkeyCurrentUser, NULL, SZ_REGVALUE_OTHERPICTURES, m_szOther, ARRAYSIZE(m_szOther))))
            {
                StrCpyN(m_szOther, TEXT("C:\\"), ARRAYSIZE(m_szOther));
            }

            // Load any customized textures
            for (nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
            {
                TCHAR szRegValue[MAX_PATH];
                TCHAR szRegString[MAX_PATH];

                wnsprintf(szRegValue, ARRAYSIZE(szRegValue), TEXT("Texture #%d"), nIndex);
                szRegString[0] = 0; // in case the regkey doesn't exist yet.

                HrRegGetValueString(m_hkeyCurrentUser, NULL, szRegValue, szRegString, ARRAYSIZE(szRegString));
                if (szRegString[0])
                {
                    Str_SetPtr(&(m_pszCustomPaths[nIndex]), szRegString);
                }
                else
                {
                    Str_SetPtr(&(m_pszCustomPaths[nIndex]), NULL);
                }

                wnsprintf(szRegValue, ARRAYSIZE(szRegValue), TEXT("Texture #%d Scale"), nIndex);
                HrRegGetDWORD(m_hkeyCurrentUser, NULL, szRegValue, (DWORD *)&m_dwCustomScale[nIndex], 100);
            }

            m_pMain->ReadScreenSettingsPublic( m_hkeyCurrentUser );
        }
        m_fLoaded = TRUE;
    }

    return hr;
}


HRESULT CConfig::_SaveState(void)
{
    HRESULT hr = E_FAIL;

    if (m_hkeyCurrentUser)
    {
        int nIndex;

        for (nIndex = 0; nIndex < ARRAYSIZE(m_fSettings); nIndex++)
        {
            HrRegSetDWORD(m_hkeyCurrentUser, NULL, s_QualitySettings[nIndex].pszRegValue, m_fSettings[nIndex]);
        }

        for (nIndex = 0; nIndex < ARRAYSIZE(m_dwSettings); nIndex++)
        {
            HrRegSetDWORD(m_hkeyCurrentUser, NULL, s_pszDWORDSettingsArray[nIndex], m_dwSettings[nIndex]);
        }

        for (nIndex = 0; nIndex < ARRAYSIZE(m_fFolders); nIndex++)
        {
            HrRegSetDWORD(m_hkeyCurrentUser, NULL, s_FolderSettings[nIndex].pszRegValue, m_fFolders[nIndex]);    // Only default to on for IDC_CHECK_WINPICTS
        }

        hr = HrRegSetValueString(m_hkeyCurrentUser, NULL, SZ_REGVALUE_OTHERPICTURES, m_szOther);

        // Load any customized textures
        for (nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
        {
            TCHAR szRegValue[MAX_PATH];

            wnsprintf(szRegValue, ARRAYSIZE(szRegValue), TEXT("Texture #%d"), nIndex);
            HrRegSetValueString(m_hkeyCurrentUser, NULL, szRegValue, (m_pszCustomPaths[nIndex] ? m_pszCustomPaths[nIndex] : TEXT("")));

            wnsprintf(szRegValue, ARRAYSIZE(szRegValue), TEXT("Texture #%d Scale"), nIndex);
            HrRegSetDWORD(m_hkeyCurrentUser, NULL, szRegValue, m_dwCustomScale[nIndex]);
        }

        m_pMain->WriteScreenSettingsPublic( m_hkeyCurrentUser );
    }

    return hr;
}


HRESULT CConfig::GetOtherDir(LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = _LoadState();

    if (SUCCEEDED(hr))
    {
        StrCpyN(pszPath, m_szOther, cchSize);
    }

    return hr;
}


HRESULT CConfig::GetTexturePath(int nTextureIndex, DWORD * pdwScale, LPTSTR pszPath, DWORD cchSize)
{
    HRESULT hr = _LoadState();

    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;

        if ((nTextureIndex >= 0) && (nTextureIndex < ARRAYSIZE(m_pszCustomPaths)) &&
            m_pszCustomPaths[nTextureIndex] && m_pszCustomPaths[nTextureIndex][0])
        {
            // We have a custom texture to use.
            StrCpyN(pszPath, m_pszCustomPaths[nTextureIndex], cchSize);
            *pdwScale = m_dwCustomScale[nTextureIndex];
            hr = S_OK;
        }
    }

    return hr;
}


BOOL CConfig::GetFolderOn(UINT nSetting)
{
    HRESULT hr = _LoadState();
    BOOL fReturn = FALSE;

    if (SUCCEEDED(hr) && (nSetting < ARRAYSIZE(m_fFolders)))
    {
        fReturn = m_fFolders[nSetting];
    }

    return fReturn;
}


BOOL CConfig::GetBoolSetting(UINT nSetting)
{
    HRESULT hr = _LoadState();
    BOOL fReturn = FALSE;

    if (SUCCEEDED(hr) && (IDC_CHECK_SHOWSTATS <= nSetting))
    {
        nSetting -= IDC_CHECK_SHOWSTATS;
        if (nSetting < ARRAYSIZE(m_fSettings))
        {
            fReturn = m_fSettings[nSetting];
        }
    }

    return fReturn;
}


DWORD CConfig::GetDWORDSetting(UINT nSetting)
{
    HRESULT hr = _LoadState();
    DWORD dwReturn = 0;

    if (SUCCEEDED(hr) && (nSetting < ARRAYSIZE(m_dwSettings)))
    {
        dwReturn = m_dwSettings[nSetting];
    }

    return dwReturn;
}


HRESULT CConfig::DisplayConfigDialog(HWND hwndParent)
{
    HRESULT hr = _LoadState();

    if (SUCCEEDED(hr))
    {
        // Display Advanced Dialog
        if (IDOK == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_DIALOG_CONFIG), hwndParent, CConfig::ConfigDlgProc, (LPARAM)this))
        {
            hr = _SaveState();
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
    }

    return hr;
}




HRESULT CConfig::DisplayAdvancedDialog(HWND hwndParent)
{
    HRESULT hr = S_OK;
    int nIndex;

    for (nIndex = 0; nIndex < ARRAYSIZE(m_fSettings); nIndex++)
    {
        m_fAdvSettings[nIndex] = m_fSettings[nIndex];
    }

    for (nIndex = 0; nIndex < ARRAYSIZE(m_dwSettings); nIndex++)
    {
        m_dwAdvSettings[nIndex] = m_dwSettings[nIndex];
    }

    // Display Advanced Dialog
    if (IDOK == DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(IDD_DIALOG_ADVANCED), hwndParent, CConfig::AdvDlgProc, (LPARAM)this))
    {
        for (nIndex = 0; nIndex < ARRAYSIZE(m_fSettings); nIndex++)
        {
            m_fSettings[nIndex] = m_fAdvSettings[nIndex];
        }

        for (nIndex = 0; nIndex < ARRAYSIZE(m_dwSettings); nIndex++)
        {
            m_dwSettings[nIndex] = m_dwAdvSettings[nIndex];
        }

        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }

    return hr;
}


HRESULT CConfig::_OnEnableCustomTexture(int nIndex, BOOL fEnable)
{
    EnableWindow(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOOR + nIndex)), fEnable);
    EnableWindow(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOORSIZE + nIndex)), fEnable);
    EnableWindow(GetDlgItem(m_hDlgAdvanced, (IDC_STATIC1_TEXTR_FLOOR + nIndex)), fEnable);
    EnableWindow(GetDlgItem(m_hDlgAdvanced, (IDC_STATIC2_TEXTR_FLOOR + nIndex)), fEnable);
    EnableWindow(GetDlgItem(m_hDlgAdvanced, (IDC_STATIC3_TEXTR_FLOOR + nIndex)), fEnable);

    return S_OK;
}


HRESULT CConfig::_OnAdvInitDlg(HWND hDlg)
{
    m_hDlgAdvanced = hDlg;
    int nIndex;

    // Set Directory Checkboxes
    for (nIndex = 0; nIndex < ARRAYSIZE(m_fAdvSettings); nIndex++)
    {
        SetCheckBox(m_hDlgAdvanced, IDC_CHECK_SHOWSTATS+nIndex, m_fAdvSettings[nIndex]);
    }

    // Copy the customized textures.
    for (nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
    {
        TCHAR szPath[MAX_PATH];

        SHAutoComplete(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOOR + nIndex)), SHACF_FILESYSTEM);

        wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("%d"), m_dwCustomScale[nIndex]);
        SetWindowText(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOORSIZE + nIndex)), szPath);

        if (m_pszCustomPaths[nIndex] && m_pszCustomPaths[nIndex][0])
        {
            CheckDlgButton(m_hDlgAdvanced, (IDC_CHECK_TEXTR_FLOOR + nIndex), BST_CHECKED);
            SetWindowText(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOOR + nIndex)), m_pszCustomPaths[nIndex]);
        }
        else
        {
            _OnEnableCustomTexture(nIndex, FALSE);
        }
    }

    CheckDlgButton(m_hDlgAdvanced, IDC_RENDERQUALITY1+m_dwAdvSettings[CONFIG_DWORD_RENDERQUALITY], BST_CHECKED);
    return S_OK;
}


HRESULT CConfig::_GetAdvState(void)
{
    int nIndex;

    // Set Directory Checkboxes
    for (nIndex = 0; nIndex < ARRAYSIZE(m_fAdvSettings); nIndex++)
    {
        m_fAdvSettings[nIndex] = GetCheckBox(m_hDlgAdvanced, IDC_CHECK_SHOWSTATS+nIndex);
    }

    // Copy the customized textures.
    for (nIndex = 0; nIndex < ARRAYSIZE(m_pszCustomPaths); nIndex++)
    {
        if (IsDlgButtonChecked(m_hDlgAdvanced, (IDC_CHECK_TEXTR_FLOOR + nIndex)))
        {
            TCHAR szPath[MAX_PATH];

            GetWindowText(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOOR + nIndex)), szPath, ARRAYSIZE(szPath));
            Str_SetPtr(&(m_pszCustomPaths[nIndex]), szPath);

            GetWindowText(GetDlgItem(m_hDlgAdvanced, (IDC_EDIT_TEXTR_FLOORSIZE + nIndex)), szPath, ARRAYSIZE(szPath));
            m_dwCustomScale[nIndex] = (DWORD) StrToInt(szPath);
        }
        else
        {
            Str_SetPtr(&(m_pszCustomPaths[nIndex]), NULL);
        }
    }

    if (BST_CHECKED == IsDlgButtonChecked(m_hDlgAdvanced, IDC_RENDERQUALITY1))
    {
        m_dwAdvSettings[CONFIG_DWORD_RENDERQUALITY] = 0;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlgAdvanced, IDC_RENDERQUALITY2))
    {
        m_dwAdvSettings[CONFIG_DWORD_RENDERQUALITY] = 1;
    }
    else if (BST_CHECKED == IsDlgButtonChecked(m_hDlgAdvanced, IDC_RENDERQUALITY3))
    {
        m_dwAdvSettings[CONFIG_DWORD_RENDERQUALITY] = 2;
    }

    return S_OK;
}


HRESULT CConfig::_OnAdvDestroy(HWND hDlg)
{
    return S_OK;
}


HRESULT CConfig::_OnAdvCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);
    WORD wEvent = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (idCtrl)
    {
    case IDOK:
        _GetAdvState();
        EndDialog(hDlg, IDOK);
        break;

    case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;

    case IDC_CHECK_TEXTR_FLOOR:
        _OnEnableCustomTexture(0, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_FLOOR));
        break;

    case IDC_CHECK_TEXTR_WALLPAPER:
        _OnEnableCustomTexture(1, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_WALLPAPER));
        break;

    case IDC_CHECK_TEXTR_CEILING:
        _OnEnableCustomTexture(2, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_CEILING));
        break;

    case IDC_CHECK_TEXTR_TOEGUARD:
        _OnEnableCustomTexture(3, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_TOEGUARD));
        break;

    case IDC_CHECK_TEXTR_RUG:
        _OnEnableCustomTexture(4, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_RUG));
        break;

    case IDC_CHECK_TEXTR_FRAME:
        _OnEnableCustomTexture(5, IsDlgButtonChecked(m_hDlgAdvanced, IDC_CHECK_TEXTR_FRAME));
        break;

    default:
        break;
    }

    return S_OK;
}


INT_PTR CALLBACK CConfig::AdvDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CConfig * pThis = (CConfig *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        pThis = (CConfig *) lParam;

        if (pThis)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        }
    }

    if (pThis)
    {
        return pThis->_AdvDlgProc(hDlg, wMsg, wParam, lParam);
    }

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR CConfig::_AdvDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_NOTIFY:
        break;

    case WM_INITDIALOG:
        _OnAdvInitDlg(hDlg);
        break;

    case WM_DESTROY:
        _OnAdvDestroy(hDlg);
        break;

    case WM_HELP:
        // TODO: Get help strings
//        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_ADVAPPEARANCE, HELP_WM_HELP, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
//        WinHelp((HWND) wParam, SZ_HELPFILE_ADVAPPEARANCE, HELP_CONTEXTMENU, (DWORD_PTR)  aAdvAppearanceHelpIds);
        break;

    case WM_COMMAND:
        _OnAdvCommand(hDlg, message, wParam, lParam);
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\config.h ===
/*****************************************************************************\
    FILE: config.h

    DESCRIPTION:
        The class will handle the user's configuration state.  It will also
    display the Screen Saver's configuration dialog to allow the user to change
    these settings.

    BryanSt 12/18/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef CONFIG_H
#define CONFIG_H

class CConfig;

#include "util.h"
#include "main.h"
#include "resource.h"

#define NUM_BOOL_SETTINGS           1
#define NUM_DWORD_SETTINGS          5
#define NUM_BOOL_FOLDERS            4

#define MAX_QUALITY                 8
#define MAX_WALK                    6
#define MAX_VIEWTIME                30

// Args for CConfig::GetFolderOn()
#define CONFIG_FOLDER_MYPICTS       0
#define CONFIG_FOLDER_COMMONPICTS   1
#define CONFIG_FOLDER_WINPICTS      2
#define CONFIG_FOLDER_OTHER         3

// Args for CConfig::GetDWORDSetting()
#define CONFIG_DWORD_RENDERQUALITY  0
#define CONFIG_DWORD_REALTIMEMODE   1
#define CONFIG_DWORD_QUALITY_SLIDER 2
#define CONFIG_DWORD_SPEED_SLIDER   3
#define CONFIG_DWORD_VIEWPAINTINGTIME 4

#define DEFAULT_QUALITYSLIDER           2
#define DEFAULT_VIEWTIMESLIDER          7
#define DEFAULT_SPEEDSLIDER             2
#define DEFAULT_WALKSPEED               2
#define DEFAULT_RENDERQUALITY           1


typedef struct
{
    LPCTSTR pszRegValue;
} QUALITY_SETTING;

typedef struct
{
    LPCTSTR pszRegValue;
    BOOL fDefaultToOn;
} FOLDER_SETTING;


extern CConfig * g_pConfig;                         // The configuration settings the user wants to use.
extern QUALITY_SETTING s_QualitySettings[NUM_BOOL_SETTINGS];




class CConfig
{
public:
    // Member Functions
    virtual BOOL GetBoolSetting(UINT nSetting);
    virtual DWORD GetDWORDSetting(UINT nSetting);
    virtual BOOL GetFolderOn(UINT nSetting);
    virtual HRESULT GetOtherDir(LPTSTR pszPath, DWORD cchSize);
    virtual HRESULT GetTexturePath(int nTextureIndex, DWORD * pdwScale, LPTSTR pszPath, DWORD cchSize);

    virtual HRESULT DisplayConfigDialog(HWND hwndParent);

    HRESULT LoadStatePublic(void) { return _LoadState(); }

    CConfig(CMSLogoDXScreenSaver * pMain);
    ~CConfig();

private:
    // Helper Functions
    HRESULT _LoadState(void);
    HRESULT _SaveState(void);
    HRESULT _GetState(void);

    HRESULT _UpdateViewTimeSelection(void);
    HRESULT _OnBrowseForFolder(void);
    HRESULT _GetStateFromUI(void);
    HRESULT _LoadQualitySliderValues(void);
    BOOL _IsDialogDataValid(void);

    HRESULT _OnInitDlg(HWND hDlg);
    HRESULT _OnDestroy(HWND hDlg);
    HRESULT _OnCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    INT_PTR _ConfigDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    // Advanced Dialog
    HRESULT DisplayAdvancedDialog(HWND hwndParent);
    INT_PTR _AdvDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _OnAdvInitDlg(HWND hDlg);
    HRESULT _OnAdvDestroy(HWND hDlg);
    HRESULT _OnAdvCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    HRESULT _GetAdvState(void);

    HRESULT _OnEnableCustomTexture(int nIndex, BOOL fEnable);


    static INT_PTR CALLBACK AdvDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK ConfigDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);

    // Member Variables
    HKEY m_hkeyCurrentUser;         // Cached Key
    BOOL m_fSettings[NUM_BOOL_SETTINGS];
    DWORD m_dwSettings[NUM_DWORD_SETTINGS];
    BOOL m_fFolders[NUM_BOOL_FOLDERS];
    TCHAR m_szOther[MAX_PATH];
    BOOL m_fLoaded;
    HWND m_hDlg;
    HWND m_hDlgAdvanced;
    LPWSTR m_pszCustomPaths[MAX_CUSTOMTEXTURES];
    DWORD m_dwCustomScale[MAX_CUSTOMTEXTURES];

    CMSLogoDXScreenSaver * m_pMain;         // Weak reference

    // Advanced Dialog
    BOOL m_fAdvSettings[NUM_BOOL_SETTINGS];
    DWORD m_dwAdvSettings[NUM_DWORD_SETTINGS];
};



#endif // CONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\d3dfont.cpp ===
//-----------------------------------------------------------------------------
// File: D3DFont.cpp
//
// Desc: Texture-based font class
//
//@@BEGIN_MSINTERNAL
//
// Hist: 02.28.98 - mwetzel - Replacing the history
//       05.15.00 - mwetzel - Cleaning up the code
//       06.01.00 - mwetzel - Converted to use state blocks
//
//@@END_MSINTERNAL
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include <stdio.h>
#include <tchar.h>
#include <D3DX8.h>
#include "D3DFont.h"
#include "DXUtil.h"




//-----------------------------------------------------------------------------
// Custom vertex types for rendering text
//-----------------------------------------------------------------------------
#define MAX_NUM_VERTICES 50*6

struct FONT2DVERTEX { D3DXVECTOR4 p;   DWORD color;     FLOAT tu, tv; };
struct FONT3DVERTEX { D3DXVECTOR3 p;   D3DXVECTOR3 n;   FLOAT tu, tv; };

#define D3DFVF_FONT2DVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)
#define D3DFVF_FONT3DVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

inline FONT2DVERTEX InitFont2DVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                      FLOAT tu, FLOAT tv )
{
    FONT2DVERTEX v;   v.p = p;   v.color = color;   v.tu = tu;   v.tv = tv;
    return v;
}

inline FONT3DVERTEX InitFont3DVertex( const D3DXVECTOR3& p, const D3DXVECTOR3& n,
                                      FLOAT tu, FLOAT tv )
{
    FONT3DVERTEX v;   v.p = p;   v.n = n;   v.tu = tu;   v.tv = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CD3DFont()
// Desc: Font class constructor
//-----------------------------------------------------------------------------
CD3DFont::CD3DFont( TCHAR* strFontName, DWORD dwHeight, DWORD dwFlags )
{
    _tcscpy( m_strFontName, strFontName );
    m_dwFontHeight         = dwHeight;
    m_dwFontFlags          = dwFlags;

    m_pd3dDevice           = NULL;
    m_pTexture             = NULL;
    m_pVB                  = NULL;

    m_dwSavedStateBlock    = 0L;
    m_dwDrawTextStateBlock = 0L;
}




//-----------------------------------------------------------------------------
// Name: ~CD3DFont()
// Desc: Font class destructor
//-----------------------------------------------------------------------------
CD3DFont::~CD3DFont()
{
    InvalidateDeviceObjects();
    DeleteDeviceObjects();
}




//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc: Initializes device-dependent objects, including the vertex buffer used
//       for rendering text and the texture map which stores the font image.
//-----------------------------------------------------------------------------
HRESULT CD3DFont::InitDeviceObjects( LPDIRECT3DDEVICE8 pd3dDevice )
{
    HRESULT hr;

    // Keep a local copy of the device
    m_pd3dDevice = pd3dDevice;

    // Establish the font and texture size
    m_fTextScale  = 1.0f; // Draw fonts into texture without scaling

    // Large fonts need larger textures
    if( m_dwFontHeight > 40 )
        m_dwTexWidth = m_dwTexHeight = 1024;
    else if( m_dwFontHeight > 20 )
        m_dwTexWidth = m_dwTexHeight = 512;
    else
        m_dwTexWidth  = m_dwTexHeight = 256;

    // If requested texture is too big, use a smaller texture and smaller font,
    // and scale up when rendering.
    D3DCAPS8 d3dCaps;
    m_pd3dDevice->GetDeviceCaps( &d3dCaps );

    if( m_dwTexWidth > d3dCaps.MaxTextureWidth )
    {
        m_fTextScale = (FLOAT)d3dCaps.MaxTextureWidth / (FLOAT)m_dwTexWidth;
        m_dwTexWidth = m_dwTexHeight = d3dCaps.MaxTextureWidth;
    }

    // Create a new texture for the font
    hr = m_pd3dDevice->CreateTexture( m_dwTexWidth, m_dwTexHeight, 1,
                                      0, D3DFMT_A4R4G4B4,
                                      D3DPOOL_MANAGED, &m_pTexture );
    if( FAILED(hr) )
        return hr;

    // Prepare to create a bitmap
    DWORD*      pBitmapBits;
    BITMAPINFO bmi;
    ZeroMemory( &bmi.bmiHeader,  sizeof(BITMAPINFOHEADER) );
    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       =  (int)m_dwTexWidth;
    bmi.bmiHeader.biHeight      = -(int)m_dwTexHeight;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biBitCount    = 32;

    // Create a DC and a bitmap for the font
    HDC     hDC       = CreateCompatibleDC( NULL );
    HBITMAP hbmBitmap = CreateDIBSection( hDC, &bmi, DIB_RGB_COLORS,
                                          (VOID**)&pBitmapBits, NULL, 0 );
    SetMapMode( hDC, MM_TEXT );

    // Create a font.  By specifying ANTIALIASED_QUALITY, we might get an
    // antialiased font, but this is not guaranteed.
    INT nHeight    = -MulDiv( m_dwFontHeight, 
        (INT)(GetDeviceCaps(hDC, LOGPIXELSY) * m_fTextScale), 72 );
    DWORD dwBold   = (m_dwFontFlags&D3DFONT_BOLD)   ? FW_BOLD : FW_NORMAL;
    DWORD dwItalic = (m_dwFontFlags&D3DFONT_ITALIC) ? TRUE    : FALSE;
    HFONT hFont    = CreateFont( nHeight, 0, 0, 0, dwBold, dwItalic,
                          FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                          CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
                          VARIABLE_PITCH, m_strFontName );
    if( NULL==hFont )
        return E_FAIL;

    SelectObject( hDC, hbmBitmap );
    SelectObject( hDC, hFont );

    // Set text properties
    SetTextColor( hDC, RGB(255,255,255) );
    SetBkColor(   hDC, 0x00000000 );
    SetTextAlign( hDC, TA_TOP );

    // Loop through all printable character and output them to the bitmap..
    // Meanwhile, keep track of the corresponding tex coords for each character.
    DWORD x = 0;
    DWORD y = 0;
    TCHAR str[2] = _T("x");
    SIZE size;

    for( TCHAR c=32; c<127; c++ )
    {
        str[0] = c;
        GetTextExtentPoint32( hDC, str, 1, &size );

        if( (DWORD)(x+size.cx+1) > m_dwTexWidth )
        {
            x  = 0;
            y += size.cy+1;
        }

        ExtTextOut( hDC, x+0, y+0, ETO_OPAQUE, NULL, str, 1, NULL );

        m_fTexCoords[c-32][0] = ((FLOAT)(x+0))/m_dwTexWidth;
        m_fTexCoords[c-32][1] = ((FLOAT)(y+0))/m_dwTexHeight;
        m_fTexCoords[c-32][2] = ((FLOAT)(x+0+size.cx))/m_dwTexWidth;
        m_fTexCoords[c-32][3] = ((FLOAT)(y+0+size.cy))/m_dwTexHeight;

        x += size.cx+1;
    }

    // Lock the surface and write the alpha values for the set pixels
    D3DLOCKED_RECT d3dlr;
    m_pTexture->LockRect( 0, &d3dlr, 0, 0 );
    WORD* pDst16 = (WORD*)d3dlr.pBits;
    BYTE bAlpha; // 4-bit measure of pixel intensity

    for( y=0; y < m_dwTexHeight; y++ )
    {
        for( x=0; x < m_dwTexWidth; x++ )
        {
            bAlpha = (BYTE)((pBitmapBits[m_dwTexWidth*y + x] & 0xff) >> 4);
            if (bAlpha > 0)
            {
                *pDst16++ = (bAlpha << 12) | 0x0fff;
            }
            else
            {
                *pDst16++ = 0x0000;
            }
        }
    }

    // Done updating texture, so clean up used objects
    m_pTexture->UnlockRect(0);
    DeleteObject( hbmBitmap );
    DeleteDC( hDC );
    DeleteObject( hFont );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CD3DFont::RestoreDeviceObjects()
{
    HRESULT hr;

    // Create vertex buffer for the letters
    if( FAILED( hr = m_pd3dDevice->CreateVertexBuffer( MAX_NUM_VERTICES*sizeof(FONT2DVERTEX),
                                                       D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC, 0,
                                                       D3DPOOL_DEFAULT, &m_pVB ) ) )
    {
        return hr;
    }

    // Create the state blocks for rendering text
    for( UINT which=0; which<2; which++ )
    {
        m_pd3dDevice->BeginStateBlock();
        m_pd3dDevice->SetTexture( 0, m_pTexture );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,   D3DBLEND_SRCALPHA );
        m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,  D3DBLEND_INVSRCALPHA );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,  D3DCMP_GREATEREQUAL );
        m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,   D3DFILL_SOLID );
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,   D3DCULL_CCW );
        m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_CLIPPING,         TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_CLIPPLANEENABLE,  FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_VERTEXBLEND,      FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_INDEXEDVERTEXBLENDENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

        if( which==0 )
            m_pd3dDevice->EndStateBlock( &m_dwSavedStateBlock );
        else
            m_pd3dDevice->EndStateBlock( &m_dwDrawTextStateBlock );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: Destroys all device-dependent objects
//-----------------------------------------------------------------------------
HRESULT CD3DFont::InvalidateDeviceObjects()
{
    SAFE_RELEASE( m_pVB );

    // Delete the state blocks
    if( m_pd3dDevice )
    {
        if( m_dwSavedStateBlock )
            m_pd3dDevice->DeleteStateBlock( m_dwSavedStateBlock );
        if( m_dwDrawTextStateBlock )
            m_pd3dDevice->DeleteStateBlock( m_dwDrawTextStateBlock );
    }

    m_dwSavedStateBlock    = 0L;
    m_dwDrawTextStateBlock = 0L;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Destroys all device-dependent objects
//-----------------------------------------------------------------------------
HRESULT CD3DFont::DeleteDeviceObjects()
{
    SAFE_RELEASE( m_pTexture );
    m_pd3dDevice = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CD3DFont::GetTextExtent( TCHAR* strText, SIZE* pSize )
{
    if( NULL==strText || NULL==pSize )
        return E_FAIL;

    FLOAT fRowWidth  = 0.0f;
    FLOAT fRowHeight = (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight;
    FLOAT fWidth     = 0.0f;
    FLOAT fHeight    = fRowHeight;

    while( *strText )
    {
        TCHAR c = *strText++;

        if( c == _T('\n') )
        {
            fRowWidth = 0.0f;
            fHeight  += fRowHeight;
        }
        if( c < _T(' ') )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT tx2 = m_fTexCoords[c-32][2];

        fRowWidth += (tx2-tx1)*m_dwTexWidth;

        if( fRowWidth > fWidth )
            fWidth = fRowWidth;
    }

    pSize->cx = (int)fWidth;
    pSize->cy = (int)fHeight;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawTextScaled()
// Desc: Draws scaled 2D text.  Note that x and y are in viewport coordinates
//       (ranging from -1 to +1).  fXScale and fYScale are the size fraction 
//       relative to the entire viewport.  For example, a fXScale of 0.25 is
//       1/8th of the screen width.  This allows you to output text at a fixed
//       fraction of the viewport, even if the screen or window size changes.
//-----------------------------------------------------------------------------
HRESULT CD3DFont::DrawTextScaled( FLOAT x, FLOAT y, FLOAT z,
                                  FLOAT fXScale, FLOAT fYScale, DWORD dwColor,
                                  TCHAR* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;

    // Set up renderstate
    m_pd3dDevice->CaptureStateBlock( m_dwSavedStateBlock );
    m_pd3dDevice->ApplyStateBlock( m_dwDrawTextStateBlock );
    m_pd3dDevice->SetVertexShader( D3DFVF_FONT2DVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(FONT2DVERTEX) );

    // Set filter states
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    }

    D3DVIEWPORT8 vp;
    m_pd3dDevice->GetViewport( &vp );
    FLOAT sx  = (x+1.0f)*vp.Width/2;
    FLOAT sy  = (y-1.0f)*vp.Height/2;
    FLOAT sz  = z;
    FLOAT rhw = 1.0f;
    FLOAT fStartX = sx;

    FLOAT fLineHeight = ( m_fTexCoords[0][3] - m_fTexCoords[0][1] ) * m_dwTexHeight;

    // Fill vertex buffer
    FONT2DVERTEX* pVertices;
    DWORD         dwNumTriangles = 0L;
    m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );

    while( *strText )
    {
        TCHAR c = *strText++;

        if( c == _T('\n') )
        {
            sx  = fStartX;
            sy += fYScale*vp.Height;
        }
        if( c < _T(' ') )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];

        FLOAT w = (tx2-tx1)*m_dwTexWidth;
        FLOAT h = (ty2-ty1)*m_dwTexHeight;

        w *= (fXScale*vp.Height)/fLineHeight;
        h *= (fYScale*vp.Height)/fLineHeight;

        if( c != _T(' ') )
        {
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+h-0.5f,sz,rhw), dwColor, tx1, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,sz,rhw), dwColor, tx1, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,sz,rhw), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+0-0.5f,sz,rhw), dwColor, tx2, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,sz,rhw), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,sz,rhw), dwColor, tx1, ty1 );
            dwNumTriangles += 2;

            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                // Unlock, render, and relock the vertex buffer
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }

        sx += w;
    }

    // Unlock and render the vertex buffer
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );

    // Restore the modified renderstates
    m_pd3dDevice->ApplyStateBlock( m_dwSavedStateBlock );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws 2D text
//-----------------------------------------------------------------------------
HRESULT CD3DFont::DrawText( FLOAT sx, FLOAT sy, DWORD dwColor,
                            TCHAR* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;

    // Setup renderstate
    m_pd3dDevice->CaptureStateBlock( m_dwSavedStateBlock );
    m_pd3dDevice->ApplyStateBlock( m_dwDrawTextStateBlock );
    m_pd3dDevice->SetVertexShader( D3DFVF_FONT2DVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(FONT2DVERTEX) );

    // Set filter states
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    }

    FLOAT fStartX = sx;

    // Fill vertex buffer
    FONT2DVERTEX* pVertices = NULL;
    DWORD         dwNumTriangles = 0;
    m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );

    while( *strText )
    {
        TCHAR c = *strText++;

        if( c == _T('\n') )
        {
            sx = fStartX;
            sy += (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight;
        }
        if( c < _T(' ') )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];

        FLOAT w = (tx2-tx1) *  m_dwTexWidth / m_fTextScale;
        FLOAT h = (ty2-ty1) * m_dwTexHeight / m_fTextScale;

        if( c != _T(' ') )
        {
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx1, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx1, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx2, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx1, ty1 );
            dwNumTriangles += 2;

            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                // Unlock, render, and relock the vertex buffer
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                pVertices = NULL;
                m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }

        sx += w;
    }

    // Unlock and render the vertex buffer
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );

    // Restore the modified renderstates
    m_pd3dDevice->ApplyStateBlock( m_dwSavedStateBlock );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render3DText()
// Desc: Renders 3D text
//-----------------------------------------------------------------------------
HRESULT CD3DFont::Render3DText( TCHAR* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;

    // Setup renderstate
    m_pd3dDevice->CaptureStateBlock( m_dwSavedStateBlock );
    m_pd3dDevice->ApplyStateBlock( m_dwDrawTextStateBlock );
    m_pd3dDevice->SetVertexShader( D3DFVF_FONT3DVERTEX );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(FONT3DVERTEX) );

    // Set filter states
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    }

    // Position for each text element
    FLOAT x = 0.0f;
    FLOAT y = 0.0f;

    // Center the text block at the origin
    if( dwFlags & D3DFONT_CENTERED )
    {
        SIZE sz;
        GetTextExtent( strText, &sz );
        x = -(((FLOAT)sz.cx)/10.0f)/2.0f;
        y = -(((FLOAT)sz.cy)/10.0f)/2.0f;
    }

    // Turn off culling for two-sided text
    if( dwFlags & D3DFONT_TWOSIDED )
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    FLOAT fStartX = x;
    TCHAR c;

    // Fill vertex buffer
    FONT3DVERTEX* pVertices;
    DWORD         dwVertex       = 0L;
    DWORD         dwNumTriangles = 0L;
    m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );

    while( c = *strText++ )
    {
        if( c == '\n' )
        {
            x = fStartX;
            y -= (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight/10.0f;
        }
        if( c < 32 )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];

        FLOAT w = (tx2-tx1) * m_dwTexWidth  / ( 10.0f * m_fTextScale );
        FLOAT h = (ty2-ty1) * m_dwTexHeight / ( 10.0f * m_fTextScale );

        if( c != _T(' ') )
        {
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+0,0), D3DXVECTOR3(0,0,-1), tx1, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+h,0), D3DXVECTOR3(0,0,-1), tx1, ty1 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+0,0), D3DXVECTOR3(0,0,-1), tx2, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+h,0), D3DXVECTOR3(0,0,-1), tx2, ty1 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+0,0), D3DXVECTOR3(0,0,-1), tx2, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+h,0), D3DXVECTOR3(0,0,-1), tx1, ty1 );
            dwNumTriangles += 2;

            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                // Unlock, render, and relock the vertex buffer
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                m_pVB->Lock( 0, 0, (BYTE**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }

        x += w;
    }

    // Unlock and render the vertex buffer
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );

    // Restore the modified renderstates
    m_pd3dDevice->ApplyStateBlock( m_dwSavedStateBlock );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\d3dfont.h ===
//-----------------------------------------------------------------------------
// File: D3DFont.h
//
// Desc: Texture-based font class
//
//@@BEGIN_MSINTERNAL
//
// Hist: 06.01.00 - mwetzel - Last modified
//
//@@END_MSINTERNAL
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef D3DFONT_H
#define D3DFONT_H
#include <tchar.h>
#include <D3D8.h>


// Font creation flags
#define D3DFONT_BOLD        0x0001
#define D3DFONT_ITALIC      0x0002

// Font rendering flags
#define D3DFONT_CENTERED    0x0001
#define D3DFONT_TWOSIDED    0x0002
#define D3DFONT_FILTERED    0x0004




//-----------------------------------------------------------------------------
// Name: class CD3DFont
// Desc: Texture-based font class for doing text in a 3D scene.
//-----------------------------------------------------------------------------
class CD3DFont
{
    TCHAR   m_strFontName[80];            // Font properties
    DWORD   m_dwFontHeight;
    DWORD   m_dwFontFlags;

    LPDIRECT3DDEVICE8       m_pd3dDevice; // A D3DDevice used for rendering
    LPDIRECT3DTEXTURE8      m_pTexture;   // The d3d texture for this font
    LPDIRECT3DVERTEXBUFFER8 m_pVB;        // VertexBuffer for rendering text
    DWORD   m_dwTexWidth;                 // Texture dimensions
    DWORD   m_dwTexHeight;
    FLOAT   m_fTextScale;
    FLOAT   m_fTexCoords[128-32][4];

    // Stateblocks for setting and restoring render states
    DWORD   m_dwSavedStateBlock;
    DWORD   m_dwDrawTextStateBlock;

public:
    // 2D and 3D text drawing functions
    HRESULT DrawText( FLOAT x, FLOAT y, DWORD dwColor, 
                      TCHAR* strText, DWORD dwFlags=0L );
    HRESULT DrawTextScaled( FLOAT x, FLOAT y, FLOAT z, 
                            FLOAT fXScale, FLOAT fYScale, DWORD dwColor, 
                            TCHAR* strText, DWORD dwFlags=0L );
    HRESULT Render3DText( TCHAR* strText, DWORD dwFlags=0L );
    
    // Function to get extent of text
    HRESULT GetTextExtent( TCHAR* strText, SIZE* pSize );

    // Initializing and destroying device-dependent objects
    HRESULT InitDeviceObjects( LPDIRECT3DDEVICE8 pd3dDevice );
    HRESULT RestoreDeviceObjects();
    HRESULT InvalidateDeviceObjects();
    HRESULT DeleteDeviceObjects();

    // Constructor / destructor
    CD3DFont( TCHAR* strFontName, DWORD dwHeight, DWORD dwFlags=0L );
    ~CD3DFont();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\main.cpp ===
/*****************************************************************************\
    FILE: main.cpp

    DESCRIPTION:
        Here we can subclass CDXScreenSaver if we want to override the behavior.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include <shlobj.h>
#include "main.h"
#include "..\\D3DSaver\\D3DSaver.h"


CRITICAL_SECTION g_csDll = {{0},0, 0, NULL, NULL, 0 };

CMSLogoDXScreenSaver * g_pScreenSaver = NULL;       // Replace with CMyDXScreenSaver if you want to override.

DWORD g_dwBaseTime = 0;
HINSTANCE g_hMainInstance = NULL;
IDirect3D8 * g_pD3D = NULL;

DWORD g_dwWidth = 0;
DWORD g_dwHeight = 0;

BOOL g_fFirstFrame = TRUE;      // On our first frame, we don't want to render the images because then the screensaver will remain black for a long time while they load


//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain(HINSTANCE hInst, HINSTANCE, LPSTR, INT)
{
    HRESULT hr = E_OUTOFMEMORY;
    HRESULT hrOle = CoInitialize(0);
    g_pScreenSaver = new CMSLogoDXScreenSaver();

    g_hMainInstance = hInst;
    if (g_pScreenSaver)
    {
        hr = g_pScreenSaver->Create(hInst);
        if (SUCCEEDED(hr))
        {
            hr = g_pScreenSaver->Run();
        }

        if (FAILED(hr))
        {
            g_pScreenSaver->DisplayErrorMsg(hr);
        }

        SAFE_DELETE(g_pScreenSaver);
    }

    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }

    return hr;
}



CMSLogoDXScreenSaver::CMSLogoDXScreenSaver()
{
    InitializeCriticalSection(&g_csDll);

    time_t nTime = time(NULL);
    UINT uSeed = (UINT) nTime;

    InitCommonControls();       // To enable fusion.

    srand(uSeed);
    m_ptheCamera = NULL;
    m_pCurrentRoom = NULL;
    m_fFrontToBack = FALSE;
    m_bUseDepthBuffer = TRUE;
    m_pDeviceObjects = 0;
    m_nCurrentDevice = 0;
    m_fShowFrameInfo = FALSE;
    m_fUseSmallImages = TRUE;

    m_pDeviceObjects = NULL;
    ZeroMemory(m_DeviceObjects, sizeof(m_DeviceObjects));

#ifdef MANUAL_CAMERA
    ZeroMemory( &m_camera, sizeof(m_camera) );
    m_camera.m_vPosition = D3DXVECTOR3( 60.16f, 20.0f, 196.10f );
    m_camera.m_fYaw = -81.41f;
    ZeroMemory( m_bKey, 256 );
#endif

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pTextures); nIndex++)
    {
        m_pTextures[nIndex] = NULL;
    }

    if (!g_pConfig)
    {
        g_pConfig = new CConfig(this);
    }
}


extern int g_nLeakCheck;

CMSLogoDXScreenSaver::~CMSLogoDXScreenSaver()
{
    DWORD dwTemp = 0;
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pTextures); nIndex++)
    {
        SAFE_RELEASE(m_pTextures[nIndex]);
    }

    IUnknown_Set((IUnknown **) &g_pD3D, NULL);
    SAFE_DELETE(g_pConfig);

    if (m_pCurrentRoom)
    {
        m_pCurrentRoom->FinalCleanup();
    }
    SAFE_RELEASE(m_pCurrentRoom);
//    AssertMsg((0 == g_nLeakCheck), TEXT("We have a bug in the CTheRoom ref-counting that caused %d rooms to be leaked."), g_nLeakCheck);
    if (g_nLeakCheck)
    {
        dwTemp = g_nLeakCheck;
    }

    DeleteCriticalSection(&g_csDll);
}


IDirect3DDevice8 * CMSLogoDXScreenSaver::GetD3DDevice(void)
{
    return m_pd3dDevice;
}


void CMSLogoDXScreenSaver::SetDevice(UINT iDevice)
{
    m_nCurrentDevice = iDevice;
    m_pDeviceObjects = &m_DeviceObjects[m_nCurrentDevice];
}

void CMSLogoDXScreenSaver::ReadSettings()
{
    g_pConfig->LoadStatePublic();
}


HRESULT CMSLogoDXScreenSaver::GetCurrentScreenSize(int * pnWidth, int * pnHeight)
{
    int nAdapter = m_RenderUnits[m_nCurrentDevice].iAdapter;
    D3DAdapterInfo * pAdapterInfo = m_Adapters[nAdapter];
    D3DDeviceInfo * pDeviceInfo = &(pAdapterInfo->devices[pAdapterInfo->dwCurrentDevice]);
    D3DModeInfo * pModeInfo = &(pDeviceInfo->modes[pDeviceInfo->dwCurrentMode]);

    *pnWidth = pModeInfo->Width;
    *pnHeight = pModeInfo->Height;

    return S_OK;
}


CTexture * CMSLogoDXScreenSaver::GetGlobalTexture(DWORD dwItem, float * pfScale)
{
    CTexture * pTexture = NULL;

    if (dwItem >= ARRAYSIZE(m_pTextures))
    {
        return NULL;
    }

    *pfScale = 1.0f;
    pTexture = m_pTextures[dwItem];

    if (!pTexture && m_pd3dDevice && g_pConfig)
    {
        TCHAR szPath[MAX_PATH];
        DWORD dwScale;

        if (SUCCEEDED(g_pConfig->GetTexturePath(dwItem, &dwScale, szPath, ARRAYSIZE(szPath))) &&
            PathFileExists(szPath))
        {
            *pfScale = (1.0f / (((float) dwScale) / 100.0f));
        }
        else
        {
            StrCpyN(szPath, c_pszGlobalTextures[dwItem], ARRAYSIZE(szPath));
        }

        // This will give people a chance to customize the images.
        pTexture = new CTexture(this, szPath, c_pszGlobalTextures[dwItem], *pfScale);
        m_pTextures[dwItem] = pTexture;
    }

    *pfScale = (pTexture ? pTexture->GetScale() : 1.0f);
    return pTexture;
}

HRESULT CMSLogoDXScreenSaver::RegisterSoftwareDevice(void)
{ 
    if (m_pD3D)
    {
        m_pD3D->RegisterSoftwareDevice(D3D8RGBRasterizer);
    }

    return S_OK; 
}


void _stdcall ModuleEntry(void)
{
    int nReturn = WinMain(GetModuleHandle(NULL), NULL, NULL, 0);
    ExitProcess(nReturn);
}


HRESULT CMSLogoDXScreenSaver::_SetTestCameraPosition(void)
{
    D3DXVECTOR3 vSourceLoc(1.0f, 20.f, 199.0f);
    D3DXVECTOR3 vSourceTangent(5.0f, 0.0f, 0.0f);

    HRESULT hr = m_ptheCamera->Init(vSourceLoc, vSourceTangent, D3DXVECTOR3(0.0f, 1.0f, 0.0f));
    if (SUCCEEDED(hr))
    {
        D3DXVECTOR3 vDestLoc(1.0f, 20.f, 10.0f);
        D3DXVECTOR3 vDestTangent(5.0, 0.0f, 0.0f);
        hr = m_ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        hr = m_ptheCamera->CreateNextWait(0, 0, 300.0f);
    }

    return hr;
}


HRESULT CMSLogoDXScreenSaver::_CheckMachinePerf(void)
{
    // Initialize member variables
    int nWidth;
    int nHeight;

    // We will only consider using large images if the screen is larger
    // than 1248x1024
    if (SUCCEEDED(GetCurrentScreenSize(&nWidth, &nHeight)) && g_pConfig &&
        (nWidth > 1200) && (nHeight >= 1024))
    {
        // Now, the user can force this on by using a high "Quality" setting
        if ((MAX_QUALITY - 2) <= g_pConfig->GetDWORDSetting(CONFIG_DWORD_QUALITY_SLIDER))
        {
            m_fUseSmallImages = FALSE;
        }
        else
        {
            // Otherwise, we need to check the machines capabilities.
            MEMORYSTATUS ms;

            GlobalMemoryStatus(&ms);
            SIZE_T nMegabytes = (ms.dwTotalPhys / (1024 * 1024));

            // Only use large images if there is more than 170MB of RAM or we can
            // thrash.
            if ((nMegabytes > 170) && (2 < g_pConfig->GetDWORDSetting(CONFIG_DWORD_QUALITY_SLIDER)))
            {
                // We should only use 60% of the video memory.  So at this resolution, find
                // out how many images that will most likely be.
                // TODO: nNumberOfImages = floor((VideoMemory * 0.60) / AveBytesPerImage);
                m_fUseSmallImages = FALSE;
            }
        }
    }

    return S_OK;
}


extern float g_fRoomWidthX;
extern float g_fRoomDepthZ;
extern float g_fRoomHeightY;

HRESULT CMSLogoDXScreenSaver::_Init(void)
{
    // Initialize member variables
    HRESULT hr = S_OK;

    if (g_pConfig)
    {
        m_fShowFrameInfo = g_pConfig->GetBoolSetting(IDC_CHECK_SHOWSTATS);
    }

    _CheckMachinePerf();
    if (!g_pPictureMgr)
    {
        g_pPictureMgr = new CPictureManager(this);
        if (!g_pPictureMgr)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    IUnknown_Set((IUnknown **) &g_pD3D, (IUnknown *)m_pD3D);
    return hr;
}


void CMSLogoDXScreenSaver::DoConfig(void)
{
    HRESULT hr = E_UNEXPECTED;

    if (g_pConfig)
    {
        hr = g_pConfig->DisplayConfigDialog(NULL);
    }
}


HRESULT CMSLogoDXScreenSaver::SetViewParams(IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 * pvecEyePt, D3DXVECTOR3 * pvecLookatPt, D3DXVECTOR3 * pvecUpVec, float nNumber)
{
    HRESULT hr = E_UNEXPECTED;

    if (pD3DDevice)
    {
        D3DXMATRIX matView;

        D3DXMatrixLookAtLH(&matView, pvecEyePt, pvecLookatPt, pvecUpVec);
        hr = pD3DDevice->SetTransform(D3DTS_VIEW, &matView);
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: OneTimeSceneInit()
// Desc: Called during initial app startup, this function performs all the
//       permanent initialization.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::_OneTimeSceneInit(void)
{
    HRESULT hr = _Init();

    if (SUCCEEDED(hr))
    {
        m_pCurrentRoom = new CTheRoom(FALSE, this, NULL, 0);
        if (m_pCurrentRoom)
        {
            m_pCurrentRoom->SetCurrent(TRUE);
            hr = m_pCurrentRoom->OneTimeSceneInit(2, FALSE);

            if (SUCCEEDED(hr) && !m_ptheCamera)
            {
                m_ptheCamera = new CCameraMove();
                if (m_ptheCamera && g_pPictureMgr)
                {
//            return _SetTestCameraPosition();
                    hr = m_pCurrentRoom->LoadCameraMoves(m_ptheCamera);
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::FinalCleanup(void)
{
    HRESULT hr = S_OK;
    
    if (m_pCurrentRoom)
    {
        m_pCurrentRoom->FinalCleanup();
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::InitDeviceObjects(void)
{
    HRESULT hr = E_FAIL;

    if (m_pd3dDevice && g_pConfig)
    {
        DWORD dwAmbient = 0xD0D0D0D0;       // 0x33333333, 0x0a0a0a0a, 0x11111111

        // Set up the lights
        hr = m_pd3dDevice->SetRenderState(D3DRS_AMBIENT, dwAmbient);

        // TODO: GetViewport() is not compatible with pure-devices, which we want because it gives us
        // Big perf win.
        D3DMATERIAL8 mtrl = {0};
        mtrl.Ambient.r = mtrl.Specular.r = mtrl.Diffuse.r = 1.0f;
        mtrl.Ambient.g = mtrl.Specular.g = mtrl.Diffuse.g = 1.0f;
        mtrl.Ambient.b = mtrl.Specular.b = mtrl.Diffuse.b = 1.0f;
        mtrl.Ambient.a = mtrl.Specular.a = mtrl.Diffuse.a = 1.0f;

        m_pd3dDevice->SetMaterial(&mtrl);


        // Setup texture states
        hr = m_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
        hr = m_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
        m_pd3dDevice->SetTextureStageState(0, D3DTSS_MIPFILTER, D3DTEXF_LINEAR);

        // Set default render states
        hr = m_pd3dDevice->SetRenderState(D3DRS_DITHERENABLE, TRUE);
        hr = m_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
        hr = m_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, D3DZB_TRUE);
        hr = m_pd3dDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
        hr = m_pd3dDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);

        switch (g_pConfig->GetDWORDSetting(CONFIG_DWORD_RENDERQUALITY))
        {
        case 0:
            hr = m_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_FLAT);
            break;
        case 1:
            hr = m_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
            break;
        case 2:
            hr = m_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_PHONG);
            break;
        }

        if (SUCCEEDED(hr))
        {
            hr = _OneTimeSceneInit();
        }
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: Initialize scene objects.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::RestoreDeviceObjects(void)
{
    m_pDeviceObjects->m_pStatsFont = new CD3DFont( _T("Arial"), 12, D3DFONT_BOLD );
    m_pDeviceObjects->m_pStatsFont->InitDeviceObjects( m_pd3dDevice );
    m_pDeviceObjects->m_pStatsFont->RestoreDeviceObjects();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::InvalidateDeviceObjects()
{
    m_pDeviceObjects->m_pStatsFont->InvalidateDeviceObjects();
    m_pDeviceObjects->m_pStatsFont->DeleteDeviceObjects();
    SAFE_DELETE( m_pDeviceObjects->m_pStatsFont );

    return S_OK;
}



/*****************************************************************************\
    DESCRIPTION:
        This function is used to check the computers capabilities.  By default
    we try to use the user's current resolution to render.  If we are happy with
    the computer's capabilities, we return FALSE, and the current resolution is used.

    Otherwise, we return FALSE and recommend a resolution to use.  Most often
    640x480 or 800x600 is recommended.
\*****************************************************************************/
BOOL CMSLogoDXScreenSaver::UseLowResolution(int * pRecommendX, int * pRecommendY)
{
    BOOL fUseLowRes = FALSE;
    MEMORYSTATUS ms;
/*
    DDCAPS ddCaps = {0};

    ddCaps.dwSize = sizeof(ddCaps);
    HRESULT hr = pDDraw7->GetCaps(&ddCaps, NULL);
*/
    GlobalMemoryStatus(&ms);

    // Our frame rate will hurt if any of these are true...
    if ( (ms.dwTotalPhys < (125 * 1024 * 1024))           // If the computer has less than 128 MB of physical RAM, then it could trash.
/*        TODO
        ||
        FAILED(hr) ||
        (ddCaps.dwCaps & DDCAPS_3D) || )                    // Our frame rate will hurt without these abilities
        (ddCaps.dwVidMemTotal < (15 * 1024 * 1024)) || )    // We want video cards with 16 MB of RAM.  Less indicates old hardware.
        (ddCaps.dwCaps & DDCAPS_3D))                        // We want a real 3D card
        (ddCaps.dwCaps.ddsCaps  & DDSCAPS_TEXTURE))         // We want video cards with at least this support...
*/
        )
    {
        fUseLowRes = TRUE;
        *pRecommendX = 640;
        *pRecommendY = 480;
    }

    return fUseLowRes;
}


//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::DeleteDeviceObjects(void)
{
    HRESULT hr = S_OK;
    
    if (m_pCurrentRoom)
    {
        m_pCurrentRoom->DeleteDeviceObjects();
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::Render(void)
{
    HRESULT hr = E_INVALIDARG;

    g_nTexturesRenderedInThisFrame = 0;
    g_nTrianglesRenderedInThisFrame = 0;

    SetProjectionMatrix( 1.0f, 1000.0f );

    if (m_pd3dDevice)
    {
        // Clear the viewport
        hr = m_pd3dDevice->Clear(0, NULL, (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER), 0x00000000 /*WATER_COLOR*/, 1.0f, 0L);

        // Watch the number of textures we have open at one time.
//        TCHAR szOut[MAX_PATH];
//        wsprintf(szOut, TEXT("Number of open textures: %d"), D3DTextr_GetTextureCount());
//        TraceOutput(szOut);

        // Begin the scene 
        if (m_ptheCamera && SUCCEEDED(m_pd3dDevice->BeginScene()))
        {
            D3DXMATRIX matIdentity;

            D3DXMatrixIdentity(&matIdentity);

#ifdef MANUAL_CAMERA
            UpdateCamera(&m_camera);
            hr = m_pd3dDevice->SetTransform( D3DTS_VIEW, &m_camera.m_matView );
#else
            hr = m_ptheCamera->SetCamera(m_pd3dDevice, m_fTimeKeyIn);
            if (FAILED(hr))
            {
                DXUtil_Trace(TEXT("ERROR: m_ptheCamera->SetCamera failed."));
            }
#endif

            if ((S_FALSE == hr) && m_pCurrentRoom)
            {
                CTheRoom * pNextRoom = NULL;

                m_pCurrentRoom->FreePictures();
                hr = m_pCurrentRoom->GetNextRoom(&pNextRoom);
                if (SUCCEEDED(hr))
                {
                    m_pCurrentRoom->SetCurrent(FALSE);
                    pNextRoom->SetCurrent(TRUE);

                    SAFE_RELEASE(m_pCurrentRoom);
                    m_pCurrentRoom = pNextRoom;

                    hr = m_ptheCamera->DeleteAllMovements(m_fTimeKeyIn);        // Purge all the previous movements.
                    hr = m_pCurrentRoom->LoadCameraMoves(m_ptheCamera);
                    if (SUCCEEDED(hr))
                    {
                        // We need to set the camera at the start of the new room.
                        hr = m_ptheCamera->SetCamera(m_pd3dDevice, m_fTimeKeyIn);
                    }
                }
            }

            // Update cull info for this frame
            // TODO: cache these matrices ourselves rather than using GetTransform
            D3DXMATRIX matView;
            D3DXMATRIX matProj;
            m_pd3dDevice->GetTransform( D3DTS_VIEW, &matView );
            m_pd3dDevice->GetTransform( D3DTS_PROJECTION, &matProj );
            UpdateCullInfo( &m_cullInfo, &matView, &matProj );

            ////////////////////////////
            // Render the objects in the room
            ////////////////////////////
            // Room
            m_pd3dDevice->SetRenderState(D3DRS_ZBIAS, 0);
            m_pd3dDevice->SetTransform(D3DTS_WORLDMATRIX(0), &matIdentity);

            if (m_pCurrentRoom)
            {
                int nMaxPhases = m_pCurrentRoom->GetMaxRenderPhases();

                m_fFrontToBack = !m_fFrontToBack;

                // An object will break down it's rendering by the textures it uses.  It will then
                // render one phase for each texture.  We reverse the phase render order to try
                // to keep the textures in memory when transitioning between one rendering cycle and the next.

                // For now, reversing the rendering order has been removed.  DX should take care of this for us
                // and it causes us to control z-order.
                for (int nCurrentPhase = 0; nCurrentPhase < nMaxPhases; nCurrentPhase++)
                {
                    hr = m_pCurrentRoom->Render(m_pd3dDevice, nCurrentPhase, TRUE /*m_fFrontToBack*/);
                }
            }

            if( m_fShowFrameInfo )
            {
                m_pDeviceObjects->m_pStatsFont->DrawText( 3,  1, D3DCOLOR_ARGB(255,0,0,0), m_strFrameStats );
                m_pDeviceObjects->m_pStatsFont->DrawText( 2,  0, D3DCOLOR_ARGB(255,255,255,0), m_strFrameStats );

                m_pDeviceObjects->m_pStatsFont->DrawText( 3, 21, D3DCOLOR_ARGB(255,0,0,0), m_strDeviceStats );
                m_pDeviceObjects->m_pStatsFont->DrawText( 2, 20, D3DCOLOR_ARGB(255,255,255,0), m_strDeviceStats );
            }
            // End the scene.
            m_pd3dDevice->EndScene();
        }
        else
        {
            DXUtil_Trace(TEXT("ERROR: m_ptheCamera is NULL or ::BeginScene() failed."));
        }
    }

    g_nTexturesRenderedInThisFrame++;       // This is the picture frame.
    g_fFirstFrame = FALSE;

    // Display stats for this frame.
    DXUtil_Trace(TEXT("RENDER FRAME: Textures: %d (Rendered %d)   Triangles Rendered: %d  Room: %d\n"), 
                g_nTotalTexturesLoaded, g_nTexturesRenderedInThisFrame, g_nTrianglesRenderedInThisFrame, m_pCurrentRoom->m_nBatch);

    return hr;
}


#ifdef MANUAL_CAMERA
//-----------------------------------------------------------------------------
// Name: UpdateCamera()
// Desc: 
//-----------------------------------------------------------------------------
VOID CMSLogoDXScreenSaver::UpdateCamera(Camera* pCamera)
{
    FLOAT fElapsedTime;

    if( m_fElapsedTime > 0.0f )
        fElapsedTime = m_fElapsedTime;
    else
        fElapsedTime = 0.05f;

    FLOAT fSpeed        = 5.0f*fElapsedTime;
    FLOAT fAngularSpeed = 2.0f*fElapsedTime;

    // De-accelerate the camera movement (for smooth motion)
    pCamera->m_vVelocity      *= 0.75f;
    pCamera->m_fYawVelocity   *= 0.75f;
    pCamera->m_fPitchVelocity *= 0.75f;

    // Process keyboard input
    if( m_bKey[VK_RIGHT] )    pCamera->m_vVelocity.x    += fSpeed; // Slide Right
    if( m_bKey[VK_LEFT] )     pCamera->m_vVelocity.x    -= fSpeed; // Slide Left
    if( m_bKey[VK_UP] )       pCamera->m_vVelocity.y    += fSpeed; // Slide Up
    if( m_bKey[VK_DOWN] )     pCamera->m_vVelocity.y    -= fSpeed; // Slide Down
    if( m_bKey['W'] )         pCamera->m_vVelocity.z    += fSpeed; // Move Forward
    if( m_bKey['S'] )         pCamera->m_vVelocity.z    -= fSpeed; // Move Backward
    if( m_bKey['E'] )         pCamera->m_fYawVelocity   += fSpeed; // Turn Right
    if( m_bKey['Q'] )         pCamera->m_fYawVelocity   -= fSpeed; // Turn Left
    if( m_bKey['Z'] )         pCamera->m_fPitchVelocity += fSpeed; // Turn Down
    if( m_bKey['A'] )         pCamera->m_fPitchVelocity -= fSpeed; // Turn Up

    // Update the position vector
    D3DXVECTOR3 vT = pCamera->m_vVelocity * fSpeed;
    D3DXVec3TransformNormal( &vT, &vT, &pCamera->m_matOrientation );
    pCamera->m_vPosition += vT;

    // Update the yaw-pitch-rotation vector
    pCamera->m_fYaw   += fAngularSpeed * pCamera->m_fYawVelocity;
    pCamera->m_fPitch += fAngularSpeed * pCamera->m_fPitchVelocity;
    if( pCamera->m_fPitch < -D3DX_PI/2 ) 
        pCamera->m_fPitch = -D3DX_PI/2;
    if( pCamera->m_fPitch > D3DX_PI/2 ) 
        pCamera->m_fPitch = D3DX_PI/2;

    // Set the view matrix
    D3DXQUATERNION qR;
    D3DXQuaternionRotationYawPitchRoll( &qR, pCamera->m_fYaw, pCamera->m_fPitch, 0.0f );
    D3DXMatrixAffineTransformation( &pCamera->m_matOrientation, 1.25f, NULL, &qR, &pCamera->m_vPosition );
    D3DXMatrixInverse( &pCamera->m_matView, NULL, &pCamera->m_matOrientation );
}



LRESULT CMSLogoDXScreenSaver::SaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    if( WM_KEYDOWN == uMsg )
    {
        m_bKey[wParam] = 1;
    }
    // Perform commands when keys are released
    if( WM_KEYUP == uMsg )
    {
        m_bKey[wParam] = 0;
    }
    return CD3DScreensaver::SaverProc( hWnd, uMsg, wParam, lParam );
}
#endif

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CMSLogoDXScreenSaver::FrameMove(void)
{
    if (sm_preview == m_SaverMode)
    {
        Sleep(50);        // We can render plenty of frames in preview mode.
    }

    if (0 == g_dwBaseTime)
    {
        g_dwBaseTime = timeGetTime();
    }

    m_fTimeKeyIn = (timeGetTime() - g_dwBaseTime) * 0.001f;
    return S_OK;
}


HRESULT CMSLogoDXScreenSaver::ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, D3DFORMAT fmtBackBuffer)
{
    // TODO: In the future, we would like to use PURE-Devices because it's
    // a big perf win.  However, if we do, then we need to stop using GetViewport and
    // GetTransform.
    if (dwBehavior & D3DCREATE_PUREDEVICE)
        return E_FAIL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\main.h ===
/*****************************************************************************\
    FILE: main.h

    DESCRIPTION:
        Here we can subclass CDXScreenSaver if we want to override the behavior.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef SSMAIN_H
#define SSMAIN_H

extern IDirect3D8 * g_pD3D;
extern DWORD g_dwWidth;
extern DWORD g_dwHeight;
extern BOOL g_fFirstFrame;

class CMSLogoDXScreenSaver;
extern CMSLogoDXScreenSaver * g_pScreenSaver;

#include "texture.h"
#include "d3dfont.h"
#include "object.h"
#include "util.h"
#include "CameraMove.h"
#include "room.h"
#include "painting.h"
#include "pictures.h"
#include "config.h"
#include "resource.h"

class CCameraMove;

#define ITEM_FLOOR                  0
#define ITEM_WALLPAPER              1
#define ITEM_CEILING                2
#define ITEM_TOEGUARD               3
#define ITEM_RUG                    4
#define ITEM_FRAME                  5
#define ITEM_POWEROUTLET            6

#define MAX_DEVICE_OBJECTS 10

const LPCWSTR c_pszGlobalTextures[] =
{
    L"Floor.bmp",
    L"Walls.bmp",
    L"Ceiling.bmp",
    L"ToeGuard.bmp",
    L"Rug.bmp",
    L"Frame.bmp",
    L"PowerSocket.bmp"
};


#ifdef MANUAL_CAMERA
//-----------------------------------------------------------------------------
// Name: struct Camera
// Desc: 
//-----------------------------------------------------------------------------
struct Camera
{
    D3DXVECTOR3        m_vPosition;
    D3DXVECTOR3        m_vVelocity;
    FLOAT              m_fYaw;
    FLOAT              m_fYawVelocity;
    FLOAT              m_fPitch;
    FLOAT              m_fPitchVelocity;
    D3DXMATRIX         m_matView;
    D3DXMATRIX         m_matOrientation;
};
#endif

struct DeviceObjects
{
    CD3DFont* m_pStatsFont;
};


class CMSLogoDXScreenSaver : public CD3DScreensaver
{
public:
    virtual void DoConfig(void);
    CTexture * GetGlobalTexture(DWORD dwItem, float * pfScale);
    IDirect3DDevice8 * GetD3DDevice(void);
    virtual void SetDevice(UINT iDevice);
    virtual HRESULT ConfirmDevice(D3DCAPS8 * pCaps, DWORD dwBehavior, D3DFORMAT fmtBackBuffer);
    void DisplayMonitorSettings(HWND hwndParent) {DoScreenSettingsDialog(hwndParent);}
    virtual VOID ReadSettings();
    HRESULT GetCurrentScreenSize(int * pnWidth, int * pnHeight);
    int GetNumberOfMonitors(void) {return m_dwNumAdapters;}
    int GetCurrMonitorIndex(void) {return m_nCurrentDevice;}
    VOID ReadScreenSettingsPublic( HKEY hkey ) { ReadScreenSettings( hkey ); }
    VOID WriteScreenSettingsPublic( HKEY hkey ) { WriteScreenSettings( hkey ); }
    CULLINFO* PCullInfo(void) { return &m_cullInfo; }
    BOOL UseSmallImages(void) {return m_fUseSmallImages;}

    CMSLogoDXScreenSaver();
    virtual ~CMSLogoDXScreenSaver();

protected:
    // Member Functions
    virtual HRESULT RegisterSoftwareDevice(void);

    virtual HRESULT OneTimeSceneInit(void) {return S_OK;}
    virtual HRESULT FrameMove(void);
    virtual HRESULT Render(void);
    virtual HRESULT DeleteDeviceObjects(void);
    virtual HRESULT FinalCleanup(void);
    virtual HRESULT InitDeviceObjects(void);
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();
    virtual BOOL UseLowResolution(int * pRecommendX, int * pRecommendY);
#ifdef MANUAL_CAMERA
    VOID    UpdateCamera(Camera* pCamera);
    virtual LRESULT SaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
#endif


private:
    // Helper Functions
    HRESULT SetViewParams(IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 * pvecEyePt, D3DXVECTOR3 * pvecLookatPt, D3DXVECTOR3 * pvecUpVec, float nNumber);
    HRESULT _Init(void);
    HRESULT _SetTestCameraPosition(void);
    HRESULT _OneTimeSceneInit(void);
    HRESULT _CheckMachinePerf(void);

    // Member Variables
    CTheRoom * m_pCurrentRoom;
    BOOL m_fFrontToBack;
    int m_nCurrentDevice;
    BOOL m_fShowFrameInfo;
    CULLINFO m_cullInfo;
    BOOL m_fUseSmallImages;         // If TRUE, Cap images at 512x512, otherwise 1024x1024

#ifdef MANUAL_CAMERA
    BYTE m_bKey[256];
    Camera m_camera;
#endif

    CCameraMove * m_ptheCamera;

    DeviceObjects  m_DeviceObjects[MAX_DEVICE_OBJECTS];
    DeviceObjects * m_pDeviceObjects;

    CTexture * m_pTextures[ARRAYSIZE(c_pszGlobalTextures)];

    FLOAT m_fTimeKeyIn;
};






#endif // SSMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\object.cpp ===
/*****************************************************************************\
    FILE: object.cpp

    DESCRIPTION:
        The caller will tell us what shape they want.  Normally a rectangle on a
    plane or a sphere.  We will then create the number vertexs the caller wants
    for that objectand create texture coordinates.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include "util.h"
#include "room.h"
#include "object.h"


int g_nTrianglesRenderedInThisFrame = 0;



C3DObject::C3DObject(CMSLogoDXScreenSaver * pMain)
{
    // Initialize member variables
    m_pTexture = NULL;
    m_pdwIndices = NULL;

    m_dwNumVer = 0;
    m_dwNumIndeces = 0;

    m_pvVertexs = NULL;

    m_pMain = pMain;

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pIndexBuff); nIndex++)
    {
        m_pVB[nIndex] = NULL;
        m_pIndexBuff[nIndex] = NULL;
    }

    m_pNextObject = NULL;
}


C3DObject::~C3DObject()
{
    SAFE_RELEASE(m_pTexture);

    SAFE_DELETE(m_pdwIndices);
    SAFE_DELETE(m_pvVertexs);
    SAFE_DELETE(m_pNextObject);
    _PurgeDeviceObjects();
}


HRESULT C3DObject::InitPlaneStretch(CTexture * pTexture, IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal, 
                                int nNumVertexX, int nNumVertexY, DWORD dwMaxPixelSize)
{
    D3DXVECTOR3 vWidth;
    D3DXVECTOR3 vHeight;

    if (vNormal.x)
    {
        vWidth = D3DXVECTOR3(0, 0, 1);
        vHeight = D3DXVECTOR3(0, 1, 0);
    }
    else if (vNormal.y)
    {
        vWidth = D3DXVECTOR3(0, 0, 1);
        vHeight = D3DXVECTOR3(1, 0, 0);
    }
    else
    {
        vWidth = D3DXVECTOR3(1, 0, 0);
        vHeight = D3DXVECTOR3(0, 1, 0);
    }
    
    float fTextureX = (1.0f / AddVectorComponents(D3DXVec3Multiply(vSize, vWidth)));
    float fTextureY = (1.0f / AddVectorComponents(D3DXVec3Multiply(vSize, vHeight)));
    
    return InitPlane(pTexture, pD3DDevice, vLocation, vSize, vNormal, nNumVertexX, nNumVertexY,
            fTextureX, fTextureY, dwMaxPixelSize, 0.0f);
}


/*****************************************************************************\
    DESCRIPTION:
        This function needs to force pvSize to be positive, but ajusting pvLocation.
    This is necessary in order to get the normal vectors for the verticies correct
    or the triangle will be culled from the user's view.
\*****************************************************************************/
HRESULT C3DObject::_ForPositiveSize(D3DXVECTOR3 * pvLocation, D3DXVECTOR3 * pvSize)
{
    if (0 > pvSize->x)
    {
        pvLocation->x += pvSize->x;
        pvSize->x = -pvSize->x;
    }

    if (0 > pvSize->y)
    {
        pvLocation->y += pvSize->y;
        pvSize->y = -pvSize->y;
    }

    if (0 > pvSize->z)
    {
        pvLocation->z += pvSize->z;
        pvSize->z = -pvSize->z;
    }

    return S_OK;
}


/*****************************************************************************\
    DESCRIPTION:
        This function will create an object which is a plane with pTexture on the
    surface.  It will be a grid of nNumVertexX by nNumVertexY.

    PARAMETERS:
        fTextureScaleX: This is the number patterns to repeat in a 1.0f of space.
\*****************************************************************************/
HRESULT C3DObject::InitPlane(CTexture * pTexture, IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal, 
                                int nNumVertexX, int nNumVertexY, float fTextureScaleX, float fTextureScaleY,
                                DWORD dwMaxPixelSize, float fVisibleRadius)
{
    HRESULT hr = E_INVALIDARG;

    _ForPositiveSize(&vLocation, &vSize);
    _PurgeDeviceObjects();

    m_vMin = vLocation;
    m_vMax = vLocation + vSize;
    
    SAFE_DELETE(m_pdwIndices);
    SAFE_DELETE(m_pvVertexs);
    if (pD3DDevice && (nNumVertexX > 1) && (nNumVertexY > 1))
    {
        D3DXVECTOR3 vWidth;
        D3DXVECTOR3 vHeight;
        BOOL fFlipOrder = FALSE;
        BOOL fFlipTexture = FALSE;

        IUnknown_Set((IUnknown **) &m_pTexture, (IUnknown *) pTexture);

        //AssertMsg(((nNumVertexX > 1) && (nNumVertexY > 1)), TEXT("Grid needs to be larger."));
        if (vNormal.x)
        {
            // Flip the order of the triangle vectors.
            vWidth = D3DXVECTOR3(0, 0, 1);
            vHeight = D3DXVECTOR3(0, 1, 0);
        }
        else if (vNormal.y)
        {
            fFlipOrder = TRUE;
            vWidth = D3DXVECTOR3(0, 0, 1);
            vHeight = D3DXVECTOR3(1, 0, 0);
        }
        else
        {
            // Flip the order of the triangle vectors.
            fFlipOrder = TRUE;
            vWidth = D3DXVECTOR3(1, 0, 0);
            vHeight = D3DXVECTOR3(0, 1, 0);
        }

        if ((0 > vNormal.x) || (0 < vNormal.z))
        {
            fFlipTexture = TRUE;
        }

        if (0 < AddVectorComponents(vNormal))
        {
            fFlipOrder = !fFlipOrder;
        }

        D3DXMatrixIdentity(&m_matIdentity);

        m_dwNumVer = (nNumVertexX * nNumVertexY);

        m_dwNumIndeces = (6 * ((nNumVertexX - 1) * (nNumVertexY - 1)));
        m_pdwIndices = new WORD[m_dwNumIndeces];
        if (m_pdwIndices)
        {
            m_pvVertexs = new MYVERTEX[m_dwNumVer];
            if (m_pvVertexs)
            {
                int nVerticies = 0;

                hr = S_OK;
                for (int nCurrentY = 0; nCurrentY < nNumVertexY; nCurrentY++)
                {
                    for (int nCurrentX = 0; nCurrentX < nNumVertexX; nCurrentX++)
                    {
                        D3DXVECTOR3 vThisSize = ( D3DXVec3Multiply( (((float)nCurrentY)*vHeight), (vSize / ((float)(nNumVertexY - 1))) ) + 
                                                D3DXVec3Multiply( (((float)nCurrentX) *vWidth), (vSize / ((float)(nNumVertexX - 1))) ));
                        D3DXVECTOR3 vThisLocation = (vLocation + vThisSize);
                        float fTextureX = ((fTextureScaleX*AddVectorComponents(D3DXVec3Multiply(vThisSize, vWidth))) * (fFlipTexture ? -1 : 1));
                        float fTextureY = (-fTextureScaleY*AddVectorComponents(D3DXVec3Multiply(vThisSize, vHeight)));

                        m_pvVertexs[(nCurrentY * nNumVertexX) + nCurrentX] = MYVERTEX(vThisLocation, vNormal, fTextureX, fTextureY);

                        if (( (int)m_dwNumIndeces > (nVerticies * 6)) &&
                            (nCurrentY < (nNumVertexY - 1)) &&
                            (nCurrentX < (nNumVertexX - 1)))
                        {
                            // The number of indexs will not have the last row.
                            m_pdwIndices[(nVerticies * 6) + 0] = (((nCurrentY + 1) * nNumVertexY) + nCurrentX);
                            m_pdwIndices[(nVerticies * 6) + 1] = ((nCurrentY * nNumVertexY) + nCurrentX);
                            m_pdwIndices[(nVerticies * 6) + 2] = (((nCurrentY + 0) * nNumVertexY) + nCurrentX + 1);

                            m_pdwIndices[(nVerticies * 6) + 3] = (((nCurrentY + 1) * nNumVertexY) + nCurrentX);
                            m_pdwIndices[(nVerticies * 6) + 4] = (((nCurrentY + 0) * nNumVertexY) + nCurrentX + 1);
                            m_pdwIndices[(nVerticies * 6) + 5] = (((nCurrentY + 1) * nNumVertexY) + nCurrentX + 1);

                            if (fFlipOrder)
                            {
                                WORD wTemp = m_pdwIndices[(nVerticies * 6) + 0];

                                m_pdwIndices[(nVerticies * 6) + 0] = m_pdwIndices[(nVerticies * 6) + 2];
                                m_pdwIndices[(nVerticies * 6) + 2] = wTemp;

                                wTemp = m_pdwIndices[(nVerticies * 6) + 3];
                                m_pdwIndices[(nVerticies * 6) + 3] = m_pdwIndices[(nVerticies * 6) + 5];
                                m_pdwIndices[(nVerticies * 6) + 5] = wTemp;
                            }

                            nVerticies++;
                        }
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT C3DObject::_PurgeDeviceObjects(void)
{
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pIndexBuff); nIndex++)
    {
        SAFE_RELEASE(m_pVB[nIndex]);
        SAFE_RELEASE(m_pIndexBuff[nIndex]);
    }

    return S_OK;
}


HRESULT C3DObject::_GenerateDeviceObjects(void)
{
    HRESULT hr = E_INVALIDARG;

    if (m_pMain)
    {
        int nCurrMonitor = m_pMain->GetCurrMonitorIndex();
        IDirect3DDevice8 * pD3DDevice = m_pMain->GetD3DDevice();

        hr = S_OK;
        if (pD3DDevice && (!m_pVB[nCurrMonitor] || !m_pIndexBuff[nCurrMonitor]))
        {
            SAFE_RELEASE(m_pVB[nCurrMonitor]);              // Make sure both are set or both clear.
            SAFE_RELEASE(m_pIndexBuff[nCurrMonitor]);

            hr = pD3DDevice->CreateVertexBuffer((m_dwNumVer*sizeof(MYVERTEX)), D3DUSAGE_WRITEONLY, D3DFVF_MYVERTEX, D3DPOOL_MANAGED, &m_pVB[nCurrMonitor]);
            if (SUCCEEDED(hr))
            {
                MYVERTEX * pVertexArray;

                hr = m_pVB[nCurrMonitor]->Lock(0, 0, (BYTE **)&pVertexArray, 0);
                if (SUCCEEDED(hr))
                {
                    hr = pD3DDevice->CreateIndexBuffer((m_dwNumIndeces*sizeof(WORD)), D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, &m_pIndexBuff[nCurrMonitor]);
                    if (SUCCEEDED(hr))
                    {
                        WORD * pwIndexes;

                        hr = m_pIndexBuff[nCurrMonitor]->Lock(0, (m_dwNumIndeces*sizeof(WORD)), (BYTE **)&pwIndexes, 0);
                        if (SUCCEEDED(hr))
                        {
                            // 1. Copy m_pvVertexs to pVertexArray
                            DWORD cbSize = (m_dwNumVer*sizeof(MYVERTEX));
                            CopyMemory(pVertexArray, m_pvVertexs, cbSize);

                            // 2. Copy m_pdwIndices[(nVerticies * 6) + 0] to y
                            cbSize = (m_dwNumIndeces*sizeof(WORD));
                            CopyMemory(pwIndexes, m_pdwIndices, cbSize);

                            m_pIndexBuff[nCurrMonitor]->Unlock();
                        }
                    }

                    m_pVB[nCurrMonitor]->Unlock();
                }

                if (FAILED(hr))
                {
                    SAFE_RELEASE(m_pVB[nCurrMonitor]);              // Make sure both are set or both clear.
                    SAFE_RELEASE(m_pIndexBuff[nCurrMonitor]);
                }
            }
        }
    }

    return hr;
}


HRESULT C3DObject::CombineObject(IDirect3DDevice8 * pD3DDevice, C3DObject * pObjToMerge)
{
    HRESULT hr = E_INVALIDARG;

    if (pObjToMerge && m_pdwIndices && m_dwNumIndeces && pObjToMerge->m_pdwIndices && pObjToMerge->m_dwNumIndeces)
    {
        hr = _PurgeDeviceObjects();

        if (pObjToMerge->m_vMin.x < m_vMin.x)
            m_vMin.x = pObjToMerge->m_vMin.x;
        if (pObjToMerge->m_vMin.y < m_vMin.y)
            m_vMin.y = pObjToMerge->m_vMin.y;
        if (pObjToMerge->m_vMin.z < m_vMin.z)
            m_vMin.z = pObjToMerge->m_vMin.z;

        if (pObjToMerge->m_vMax.x > m_vMax.x)
            m_vMax.x = pObjToMerge->m_vMax.x;
        if (pObjToMerge->m_vMax.y > m_vMax.y)
            m_vMax.y = pObjToMerge->m_vMax.y;
        if (pObjToMerge->m_vMax.z > m_vMax.z)
            m_vMax.z = pObjToMerge->m_vMax.z;

        if (SUCCEEDED(hr))
        {
            LPWORD pdwIndicesOld = m_pdwIndices;
            DWORD dwNumIndecesOld = m_dwNumIndeces;
            MYVERTEX * pvVertexsOld = m_pvVertexs;
            DWORD dwNumVerOld = m_dwNumVer;

            m_dwNumIndeces += pObjToMerge->m_dwNumIndeces;
            m_pdwIndices = new WORD[m_dwNumIndeces];

            m_dwNumVer += pObjToMerge->m_dwNumVer;
            m_pvVertexs = new MYVERTEX[m_dwNumIndeces];

            if (m_pvVertexs && m_pdwIndices)
            {
                DWORD dwCurrent;

                // Copy the original Index values.
                for (dwCurrent = 0; dwCurrent < dwNumIndecesOld; dwCurrent++)
                {
                    m_pdwIndices[dwCurrent] = pdwIndicesOld[dwCurrent];
                }

                // Append the new Index values.
                for (dwCurrent = 0; dwCurrent < pObjToMerge->m_dwNumIndeces; dwCurrent++)
                {
                    m_pdwIndices[dwCurrent + dwNumIndecesOld] = (pObjToMerge->m_pdwIndices[dwCurrent] + (WORD) dwNumVerOld);
                }

                // Copy the original vertex values.
                for (dwCurrent = 0; dwCurrent < dwNumVerOld; dwCurrent++)
                {
                    m_pvVertexs[dwCurrent] = pvVertexsOld[dwCurrent];
                }

                // Append the new vertex values.
                for (dwCurrent = 0; dwCurrent < pObjToMerge->m_dwNumVer; dwCurrent++)
                {
                    m_pvVertexs[dwCurrent + dwNumVerOld] = pObjToMerge->m_pvVertexs[dwCurrent];
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            SAFE_DELETE(pdwIndicesOld);
            SAFE_DELETE(pvVertexsOld);
        }
    }
    else
    {
        SAFE_DELETE(m_pvVertexs);
        SAFE_DELETE(m_pdwIndices);
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr) && pObjToMerge && pObjToMerge->m_pNextObject)
    {
        hr = CombineObject(pD3DDevice, pObjToMerge->m_pNextObject);
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
HRESULT C3DObject::FinalCleanup(void)
{
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
HRESULT C3DObject::DeleteDeviceObjects(void)
{
    return S_OK;
}


BOOL C3DObject::IsObjectViewable(IDirect3DDevice8 * pD3DDevice)
{
    D3DXMATRIX matWorld;

    pD3DDevice->GetTransform( D3DTS_WORLD, &matWorld );
    return Is3DRectViewable( m_pMain->PCullInfo(), &matWorld, m_vMin, m_vMax );
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT C3DObject::Render(IDirect3DDevice8 * pD3DDevice)
{
    HRESULT hr = E_INVALIDARG;

    if (pD3DDevice && m_pMain && m_pdwIndices && m_pvVertexs)
    {
        int nCurrMonitor = m_pMain->GetCurrMonitorIndex();

        hr = _GenerateDeviceObjects();              // We may not have created them yet.  Especially for the current device (monitor)
        if (SUCCEEDED(hr))
        {
#ifdef RENDER_CORNERS
            D3DMATERIAL8 mtrl = {0};
            mtrl.Ambient.r = mtrl.Specular.r = mtrl.Diffuse.r = 1.0f;
            mtrl.Ambient.g = mtrl.Specular.g = mtrl.Diffuse.g = 1.0f;
            mtrl.Ambient.b = mtrl.Specular.b = mtrl.Diffuse.b = 1.0f;
            mtrl.Ambient.a = mtrl.Specular.a = mtrl.Diffuse.a = 1.0f;
            pD3DDevice->SetMaterial(&mtrl);

            LPD3DXMESH pMesh;
            if( FAILED( D3DXCreateSphere( pD3DDevice, 1.0f, 12, 12, &pMesh, NULL ) ) )
                return hr;
            D3DXComputeNormals( pMesh );
            
            D3DXMATRIX matWorldSave;
            D3DXMATRIX matWorld;
            pD3DDevice->GetTransform( D3DTS_WORLD, &matWorldSave );

            D3DXMatrixTranslation( &matWorld, m_vMax.x, m_vMax.y, m_vMax.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMin.x, m_vMax.y, m_vMax.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMax.x, m_vMax.y, m_vMin.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMin.x, m_vMax.y, m_vMin.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMax.x, m_vMin.y, m_vMax.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMin.x, m_vMin.y, m_vMax.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMax.x, m_vMin.y, m_vMin.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            D3DXMatrixTranslation( &matWorld, m_vMin.x, m_vMin.y, m_vMin.z );
            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorld );
            pMesh->DrawSubset( 0 );

            pD3DDevice->SetTransform( D3DTS_WORLD, &matWorldSave );
            SAFE_RELEASE( pMesh );
#endif

            if (IsObjectViewable(pD3DDevice))
            {
                /////////////////////
                // Draw Object
                /////////////////////
                hr = pD3DDevice->SetTexture(0, (m_pTexture ? m_pTexture->GetTexture() : NULL));

                if (m_pTexture->GetTexture())
                {
                    g_nTexturesRenderedInThisFrame++;
                }

                if (SUCCEEDED(hr) && m_pVB[nCurrMonitor] && m_pIndexBuff[nCurrMonitor])
                {
                    hr = pD3DDevice->SetStreamSource(0, m_pVB[nCurrMonitor], sizeof(MYVERTEX));
                    if (SUCCEEDED(hr))
                    {
                        hr = pD3DDevice->SetIndices(m_pIndexBuff[nCurrMonitor], 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pD3DDevice->SetVertexShader(D3DFVF_MYVERTEX);
                            if (SUCCEEDED(hr))
                            {
                                DWORD dwNumPrimitives = (m_dwNumIndeces / 3);

                                g_nTrianglesRenderedInThisFrame += dwNumPrimitives;
                                hr = pD3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_dwNumVer, 0, dwNumPrimitives);
                            }
                        }
                    }
                }

                pD3DDevice->SetTexture(0, NULL);
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    if (m_pNextObject)
    {
        m_pNextObject->Render(pD3DDevice);
    }

    return hr;
}


HRESULT C3DObject::SetNextObject(C3DObject * pNextObject)
{
    _PurgeDeviceObjects();
    SAFE_DELETE(m_pNextObject);
    m_pNextObject = pNextObject;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\painting.cpp ===
/*****************************************************************************\
    FILE: painting.cpp

    DESCRIPTION:

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include "util.h"
#include "painting.h"





//-----------------------------------------------------------------------------
// Name: C3DObject()
// Desc: Constructor
//-----------------------------------------------------------------------------
CPainting::CPainting(CMSLogoDXScreenSaver * pMain)
{
    // Initialize member variables
    m_pMain = pMain;

    m_pFrameTexture = NULL;
    m_pPaintingTexture = NULL;

    m_pObjPainting = NULL;
    m_pObjFrame = NULL;
}


CPainting::~CPainting()
{
    SAFE_RELEASE(m_pFrameTexture);
    SAFE_RELEASE(m_pPaintingTexture);

    SAFE_DELETE(m_pObjPainting);
    SAFE_DELETE(m_pObjFrame);
}


//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
HRESULT CPainting::FinalCleanup(void)
{
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
HRESULT CPainting::DeleteDeviceObjects(void)
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: OneTimeSceneInit()
// Desc: Called during initial app startup, this function performs all the
//       permanent initialization.
//-----------------------------------------------------------------------------
HRESULT CPainting::OneTimeSceneInit(void)
{
    HRESULT hr = E_OUTOFMEMORY;

    m_pObjPainting = new C3DObject(m_pMain);
    m_pObjFrame = new C3DObject(m_pMain);
    if (m_pObjFrame && m_pObjFrame)
    {
        hr = S_OK;
    }

    return hr;
}


HRESULT CPainting::SetPainting(CTexture * pFrameTexture, CTexture * pPaintingTexture, D3DXVECTOR3 vLocationCenter, float fMaxHeight,
                               float fFrameWidth, float fFrameHeight, D3DXVECTOR3 vNormal, DWORD dwMaxPixelSize)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (m_pObjPainting && m_pObjFrame && m_pMain && pFrameTexture && pPaintingTexture)
    {
        D3DXVECTOR3 vWidth;
        D3DXVECTOR3 vHeight;

        if (vNormal.x)
        {
            vWidth = D3DXVECTOR3(0, 0, 1);
            vHeight = D3DXVECTOR3(0, 1, 0);
        }
        else if (vNormal.y)
        {
            vWidth = D3DXVECTOR3(0, 0, 1);
            vHeight = D3DXVECTOR3(1, 0, 0);
        }
        else
        {
            vWidth = D3DXVECTOR3(1, 0, 0);
            vHeight = D3DXVECTOR3(0, 1, 0);
        }

        IUnknown_Set((IUnknown **) &m_pFrameTexture, (IUnknown *) pFrameTexture);
        IUnknown_Set((IUnknown **) &m_pPaintingTexture, (IUnknown *) pPaintingTexture);

        DWORD dwPaintingWidth = pPaintingTexture->GetTextureWidth();
        DWORD dwPaintingHeight = pPaintingTexture->GetTextureHeight();
        float fPaintingRatio = (((float) dwPaintingWidth) / ((float) dwPaintingHeight));

        int nWidth = 1;
        int nHeight = 1;
        
        m_pMain->GetCurrentScreenSize(&nWidth, &nHeight);
        float fMonitorRatio = (((float) nWidth) / ((float) nHeight));

        float fPaintingHeight = fMaxHeight;
        float fPaintingWidth = (fPaintingHeight * fPaintingRatio);

        if (fPaintingRatio > fMonitorRatio)
        {
            // Oh no, the picture ratio is wider than the screen radio.  This will cause
            // warpping so it will extend off the right and left.  We need to scale it down.
            float fScaleDownRatio = (fMonitorRatio / fPaintingRatio);
            fPaintingHeight *= fScaleDownRatio;
            fPaintingWidth *= fScaleDownRatio;
        }

        D3DXVECTOR3 vTranslateToCorner = ((-fPaintingWidth/2)*vWidth + (-fPaintingHeight/2)*vHeight);

        D3DXVECTOR3 vObjLocation(vLocationCenter + vTranslateToCorner);
        D3DXVECTOR3 vObjSize(fPaintingWidth*vWidth + fPaintingHeight*vHeight);
        hr = m_pObjPainting->InitPlaneStretch(pPaintingTexture, m_pMain->GetD3DDevice(), vObjLocation, vObjSize, vNormal, 3, 3, dwMaxPixelSize);

        D3DXVECTOR3 vFrameSize(D3DXVec3Multiply(vObjSize, (D3DXVECTOR3((fFrameWidth * vWidth) + D3DXVECTOR3(fFrameHeight * vHeight)))));
        vObjLocation = (vObjLocation - vFrameSize + ((g_fFudge / -2.0f)* vNormal));
        vObjSize = (vObjSize + (2 * vFrameSize));
        hr = m_pObjFrame->InitPlaneStretch(pFrameTexture, m_pMain->GetD3DDevice(), vObjLocation, vObjSize, vNormal, 3, 3, dwMaxPixelSize);
    }

    return hr;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CPainting::Render(IDirect3DDevice8 * pD3DDevice, int nPhase)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (m_pObjFrame && m_pObjPainting)
    {
        switch (nPhase)
        {
        case 0:
            hr = m_pObjFrame->Render(pD3DDevice);
        break;

        case 1:
            hr = m_pObjPainting->Render(pD3DDevice);
        break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\painting.h ===
/*****************************************************************************\
    FILE: painting.h

    DESCRIPTION:

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/


#ifndef PAINTING_H
#define PAINTING_H

#include "util.h"
#include "main.h"



//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------

#define SIZE_MAXPAINTINGSIZE_INWALLPERCENT          0.5f




class CPainting
{
public:
    HRESULT OneTimeSceneInit(void);
    HRESULT Render(IDirect3DDevice8 * lpDev, int nPhase);
    HRESULT FinalCleanup(void);
    HRESULT DeleteDeviceObjects(void);

    HRESULT SetPainting(CTexture * pFrameTexture, CTexture * pPaintingTexture, D3DXVECTOR3 vLocationCenter, float fMaxHeight,
                        float fFrameWidth, float fFrameHeight, D3DXVECTOR3 vNormal, DWORD dwMaxPixelSize);

    CPainting(CMSLogoDXScreenSaver * pMain);
    virtual ~CPainting();

    CTexture * m_pPaintingTexture;

private:
    CMSLogoDXScreenSaver * m_pMain;         // Weak reference

    C3DObject * m_pObjPainting;
    C3DObject * m_pObjFrame;

    CTexture * m_pFrameTexture;
};


#endif // PAINTING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\pictures.h ===
/*****************************************************************************\
    FILE: pictures.h

    DESCRIPTION:
        Manage the pictures in the user's directories.  Convert them when needed.
    Handle caching and making sure we don't use too much diskspace.  Also add
    picture frames when needed.

    PERF:
    The biggest perf impact on this screen saver is how we handle loading the pictures.
    1. If we load to many pictures, we will start paging and blow the texture
       memory.
    2. If we recycle too much or too little, we will either use too much memory or look too repeative.
    3. Latency is a killer.  We want the main thread being CPU and video card bound while
       we have a background thread loading and uncompressing images.  This will allow
       the background thread to be I/O bound so the forground can still render fairly well.

    We need to decide a size and scale pictures down to that size.  This will reduce the memory
    requirements.  If we determine that smallest picture we can use that will still look good,
    we should be okay.
    
    Here are some numbers:
    Images Size     Each Picture    For 18 Images
    ===========     =============   =============
    320x240         .152 MB         5.47 MB
    640x480         .6 MB           21 MB
    800x600         .96 MB          34 MB
    1024x768        1.5 MB          54 MB

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef PICTURES_H
#define PICTURES_H


#include "util.h"
#include "main.h"
#include "config.h"

class CPictureManager;

extern CPictureManager * g_pPictureMgr;

#define GNPF_NONE                       0x00000000
#define GNPF_RECYCLEPAINTINGS           0x00000001      // The picture is probably in a side room so reuse pictures to keep memory use down.

#define MAX_PICTURES_IN_BATCH           7

typedef struct
{
    LPTSTR pszPath;
    CTexture * pTexture;
    BOOL fInABatch;           // Has this painting been loaded?
} SSPICTURE_INFO;


typedef struct
{
    SSPICTURE_INFO * pInfo[MAX_PICTURES_IN_BATCH];
} SSPICTURES_BATCH;



class CPictureManager
{
public:
    // Member Functions
    HRESULT GetPainting(int nBatch, int nIndex, DWORD dwFlags, CTexture ** ppTexture);
    HRESULT PreFetch(int nBatch, int nToFetch);
    HRESULT ReleaseBatch(int nBatch);

    CPictureManager(CMSLogoDXScreenSaver * pMain);
    virtual ~CPictureManager();

private:
    // Private Functions

    // Enum and build of picture list
    HRESULT _PInfoCreate(int nIndex, LPCTSTR pszPath);
    HRESULT _EnumPaintings(void);
    HRESULT _AddPaintingsFromDir(LPCTSTR pszPath);

    // Create a batch
    HRESULT _LoadTexture(SSPICTURE_INFO * pInfo, BOOL fFaultInTexture);
    HRESULT _GetNextWithWrap(SSPICTURE_INFO ** ppInfo, BOOL fAlreadyLoaded, BOOL fFaultInTexture);
    HRESULT _TryGetNextPainting(SSPICTURE_INFO ** ppInfo, DWORD dwFlags);
    HRESULT _CreateNewBatch(int nBatch, BOOL fFaultInTexture);


    // Member Variables
    HDSA m_hdsaPictures;           // Contains SSPICTURE_INFO.  We want each painting in m_hdpaPaintings to be ref-counted.
    int m_nCurrent;

    HDSA m_hdsaBatches;             // Contains Batches (SSPICTURES_BATCH)
    int m_nCurrentBatch;            // 

    CMSLogoDXScreenSaver * m_pMain;         // Weak reference
};



#endif // PICTURES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\object.h ===
/*****************************************************************************\
    FILE: object.h

    DESCRIPTION:
        The caller will tell us what shape they want.  Normally a rectangle on a
    plane or a sphere.  We will then create the number vertexs the caller wants
    for that objectand create texture coordinates.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/


#ifndef OBJECT_H
#define OBJECT_H

#include "main.h"


struct MYVERTEX
{
    D3DXVECTOR3 pos;
    D3DXVECTOR3 norm;
    float tu;
    float tv;

    MYVERTEX() { }
    MYVERTEX(const D3DXVECTOR3& v, const D3DXVECTOR3& n, float _tu, float _tv)
        { pos = v; norm = n; 
          tu = _tu; tv = _tv;
        }
};

#define D3DFVF_MYVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------


extern int g_nTrianglesRenderedInThisFrame;


class C3DObject
{
public:
    HRESULT InitPlane(CTexture * pTexture, IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal, 
                                int nNumVertexX, int nNumVertexY, float fTextureScaleX, float fTextureScaleY,
                                DWORD dwMaxPixelSize, float fVisibleRadius);
    HRESULT InitPlaneStretch(CTexture * pTexture, IDirect3DDevice8 * pD3DDevice, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal, 
                                int nNumVertexX, int nNumVertexY, DWORD dwMaxPixelSize);

    HRESULT Render(IDirect3DDevice8 * pDev);
    HRESULT FinalCleanup(void);
    HRESULT DeleteDeviceObjects(void);
    HRESULT SetNextObject(C3DObject * pNextObject);
    HRESULT CombineObject(IDirect3DDevice8 * pD3DDevice, C3DObject * pObjToMerge);
    BOOL IsObjectViewable(IDirect3DDevice8 * pD3DDevice);

    C3DObject(CMSLogoDXScreenSaver * pMain);
    virtual ~C3DObject();

public:

    D3DXMATRIX m_matIdentity;

    CTexture * m_pTexture;

    IDirect3DVertexBuffer8 * m_pVB[10];
    IDirect3DIndexBuffer8 * m_pIndexBuff[10];
    MYVERTEX * m_pvVertexs;
    DWORD m_dwNumVer;
    LPWORD m_pdwIndices;
    DWORD m_dwNumIndeces;

    C3DObject * m_pNextObject;
    CMSLogoDXScreenSaver * m_pMain;         // Weak reference

    D3DXVECTOR3 m_vMin;
    D3DXVECTOR3 m_vMax;

private:
    // Functions:
    HRESULT _PurgeDeviceObjects(void);
    HRESULT _GenerateDeviceObjects(void);
    HRESULT _ForPositiveSize(D3DXVECTOR3 * pvLocation, D3DXVECTOR3 * pvSize);
};


#endif // OBJECT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winmain.rc
//
#define IDI_MAIN_ICON                   101
#define IDR_MAIN_ACCEL                  113
#define IDR_MENU                        141
#define IDR_POPUP                       142
#define IDC_CURSOR1                     144
#define IDC_DEVICE_COMBO                1000
#define IDC_MODE_COMBO                  1001
#define IDC_WINDOWED_CHECKBOX           1012
#define IDC_STEREO_CHECKBOX             1013
#define IDC_FULLSCREEN_TEXT             1014
#define IDM_ABOUT                       40001
#define IDM_CHANGEDEVICE                40002
#define IDM_TOGGLEFULLSCREEN            40003
#define IDM_TOGGLESTART                 40004
#define IDM_SINGLESTEP                  40005
#define IDM_EXIT                        40006

/////////////////////////
// Dialogs
/////////////////////////
#define IDD_ABOUT                       143
#define IDD_CHANGEDEVICE                144
#define IDD_DIALOG_ADVANCED             145
#define IDD_DIALOG_CONFIG               146

/////////////////////////
// Dialog Controls
/////////////////////////
// Config Dialog
#define IDC_SLIDER_VIEWTIME             2002
#define IDC_SLIDER_SPEED                2003
#define IDC_SLIDER_QUALITY              2004
#define IDC_BUTTON_ADVANCEDQUALITY      2009
#define IDC_STATIC_VIEWTIME             2010
#define IDC_CHECK_MYPICTS               2013
#define IDC_CHECK_COMMONPICTS           2014
#define IDC_CHECK_WINPICTS              2015
#define IDC_CHECK_OTHERPICTS            2016
#define IDC_EDIT_OTHERPICTS             2017
#define IDC_BUTTON_BROWSEPICTS          2018
#define IDC_BUTTON_MONITORSETTINGS      2020

// Advanced Dialog
#define IDC_CHECK_SHOWSTATS             2036

#define IDC_RENDERQUALITY1              2040
#define IDC_RENDERQUALITY2              2041
#define IDC_RENDERQUALITY3              2042

// Textures
#define IDC_CHECK_TEXTR_FLOOR           2060
#define IDC_CHECK_TEXTR_WALLPAPER       2061
#define IDC_CHECK_TEXTR_CEILING         2062
#define IDC_CHECK_TEXTR_TOEGUARD        2063
#define IDC_CHECK_TEXTR_RUG             2064
#define IDC_CHECK_TEXTR_FRAME           2065

#define IDC_EDIT_TEXTR_FLOOR            2070
#define IDC_EDIT_TEXTR_WALLPAPER        2071
#define IDC_EDIT_TEXTR_CEILING          2072
#define IDC_EDIT_TEXTR_TOEGUARD         2073
#define IDC_EDIT_TEXTR_RUG              2074
#define IDC_EDIT_TEXTR_FRAME            2075

#define IDC_EDIT_TEXTR_FLOORSIZE        2080
#define IDC_EDIT_TEXTR_WALLPAPERSIZE    2081
#define IDC_EDIT_TEXTR_CEILINGSIZE      2082
#define IDC_EDIT_TEXTR_TOEGUARDSIZE     2083

#define IDC_STATIC1_TEXTR_FLOOR         2090
#define IDC_STATIC1_TEXTR_WALLPAPER     2091
#define IDC_STATIC1_TEXTR_CEILING       2092
#define IDC_STATIC1_TEXTR_TOEGUARD      2093
#define IDC_STATIC1_TEXTR_RUG           2094
#define IDC_STATIC1_TEXTR_FRAME         2095

#define IDC_STATIC2_TEXTR_FLOOR         2100
#define IDC_STATIC2_TEXTR_WALLPAPER     2101
#define IDC_STATIC2_TEXTR_CEILING       2102
#define IDC_STATIC2_TEXTR_TOEGUARD      2103
 
#define IDC_STATIC3_TEXTR_FLOOR         2110
#define IDC_STATIC3_TEXTR_WALLPAPER     2111
#define IDC_STATIC3_TEXTR_CEILING       2112
#define IDC_STATIC3_TEXTR_TOEGUARD      2113

#define MAX_CUSTOMTEXTURES              6



/////////////////////////
// String Resources
/////////////////////////
#define IDS_SSDISPLAYNAME               1
#define IDS_WALKSPEED                   4000
#define IDS_OTHERBROWSE_TITLE           4020
#define IDS_LOBBY_TITLE                 4021
#define IDS_LOBBY_TITLE2                4022
#define IDS_VIEW_TIME_DESC              4030



/////////////////////////
// Error Strings
/////////////////////////
#define IDS_ERROR_INVALIDOTHERPATH      5000
#define IDS_ERROR_TITLE_OTHERPATH       5001
#define IDS_ERROR_OTHERPATH_NOTDIR      5002





/////////////////////////
// D3DSaver Framework Resources
/////////////////////////
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201

#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016

#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112

#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212

#define IDS_STATS_TEMPLATE              2213
#define IDS_STATS_D3DFMT_D16            2214
#define IDS_STATS_D3DFMT_D15S1          2215
#define IDS_STATS_D3DFMT_D24X8          2216
#define IDS_STATS_D3DFMT_D24S8          2217
#define IDS_STATS_D3DFMT_D24X4S4        2218
#define IDS_STATS_D3DFMT_D32            2219
#define IDS_STATS_DEVTYPE_PHW           2220
#define IDS_STATS_DEVTYPE_SPHW          2221
#define IDS_STATS_DEVTYPE_HW            2222
#define IDS_STATS_DEVTYPE_SHW           2223
#define IDS_STATS_DEVTYPE_MVP           2224
#define IDS_STATS_DEVTYPE_SMVP          2225
#define IDS_STATS_DEVTYPE_SWVP          2226
#define IDS_STATS_DEV_REF               2227
#define IDS_STATS_DEV_HAL               2228
#define IDS_STATS_DEV_SW                2229





/////////////////////////
// Bitmaps
/////////////////////////
#define IDB_FLOOR                       3500
#define IDB_CEILING                     3501
#define IDB_WALLS                       3502
#define IDB_FRAME                       3503
#define IDB_POWERPLUG                   3504
#define IDB_TOEGUARD                    3505
#define IDB_RUG                         3506




// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        145
#define _APS_NEXT_COMMAND_VALUE         40010
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  DXSvr.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\room.cpp ===
/*****************************************************************************\
    FILE: room.cpp

    DESCRIPTION:

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include "main.h"
#include "room.h"
#include "util.h"


// Ref-counting on the room tree is involved because it's a doubly linked tree with the root node constantly changing, so
// we need this mechanism to make sure we get the ref-count correct and don't leak.
int g_nLeakCheck = 0;

float g_fRoomWidthX = 100.0f;
float g_fRoomDepthZ = 200.0f;
float g_fRoomHeightY = 40.0f;

float g_fPaintingHeightY = (g_fRoomHeightY * SIZE_MAXPAINTINGSIZE_INWALLPERCENT);   // This is how much of the wall we want the painting to take up.

float g_fFudge = 0.1f;            // This will cause one object to be above another.

#define MAX_ROOMWALK_PATHS          2

#define NORMAL_NEG_Z            D3DXVECTOR3(0, 0, -1)
#define NORMAL_NEG_Y            D3DXVECTOR3(0, -1, 0)
#define NORMAL_NEG_X            D3DXVECTOR3(-1, 0, 0)

#define NORMAL_Z                D3DXVECTOR3(0, 0, 1)
#define NORMAL_Y                D3DXVECTOR3(0, 1, 0)
#define NORMAL_X                D3DXVECTOR3(1, 0, 0)

#define NORMAL_NEG_Z            D3DXVECTOR3(0, 0, -1)
#define NORMAL_NEG_Z            D3DXVECTOR3(0, 0, -1)


PAINTING_LAYOUT g_LongRoomPaintings1[6];            // Both doors exist (1 & 2)

PAINTING_LAYOUT g_LongRoomPaintings2[7];            // Doors 0 & 1 exist (Must exit 1)
PAINTING_LAYOUT g_LongRoomPaintings3[7];            // Doors 0 & 1 exist (Must exit 2)



ROOM_FLOORPLANS g_RoomFloorPlans[] =
{
    {0, 1, 0, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},
    {0, 1, 0, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},    // Duplicate to increase odds
    {0, 2, 0, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},
    {0, 2, 0, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},    // Duplicate to increase odds
    {0, 1, 0, TRUE, TRUE, FALSE, ARRAYSIZE(g_LongRoomPaintings2), g_LongRoomPaintings2},
    {0, 2, 0, TRUE, FALSE, TRUE, ARRAYSIZE(g_LongRoomPaintings3), g_LongRoomPaintings3},

// These require entering door other than 0
//    {1, 2, 1, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},
//    {2, 1, 1, TRUE, TRUE, TRUE, ARRAYSIZE(g_LongRoomPaintings1), g_LongRoomPaintings1},

// This requuires supporting leaving the first door
//    {2, 0, TRUE, TRUE, FALSE, ARRAYSIZE(g_LongRoomPaintings2), g_LongRoomPaintings2},
};

ROOM_FLOORPLANS g_RoomFloorPlansLobby[] =
{
    {0, 1, 0, FALSE, TRUE, TRUE, 0, NULL},
    {0, 2, 0, FALSE, TRUE, TRUE, 0, NULL}
};


void InitLayout(void)
{
    static BOOL fInited = FALSE;

    if (!fInited)
    {
        int nIndex;
        fInited = TRUE;

        g_LongRoomPaintings1[0].vLocation = D3DXVECTOR3(g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ / 4.0f)); g_LongRoomPaintings1[0].vNormal = NORMAL_X;                                  // Left Wall 1
        g_LongRoomPaintings1[1].vLocation = D3DXVECTOR3(g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ * (2.0f / 4.0f))); g_LongRoomPaintings1[1].vNormal = NORMAL_X;                         // Left Wall 2
        g_LongRoomPaintings1[2].vLocation = D3DXVECTOR3((g_fRoomWidthX * (1.0f / 3.0f)), g_fPaintingHeightY, g_fRoomDepthZ-g_fFudge); g_LongRoomPaintings1[2].vNormal = NORMAL_NEG_Z;       // Front Wall 1
        g_LongRoomPaintings1[3].vLocation = D3DXVECTOR3((g_fRoomWidthX * (2.0f / 3.0f)), g_fPaintingHeightY, g_fRoomDepthZ-g_fFudge); g_LongRoomPaintings1[3].vNormal = NORMAL_NEG_Z;       // Front Wall 2
        g_LongRoomPaintings1[4].vLocation = D3DXVECTOR3(g_fRoomWidthX-g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ / 4.0f)); g_LongRoomPaintings1[4].vNormal = NORMAL_NEG_X;                // Right Wall 1
        g_LongRoomPaintings1[5].vLocation = D3DXVECTOR3(g_fRoomWidthX-g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ * (2.0f / 4.0f) )); g_LongRoomPaintings1[5].vNormal = NORMAL_NEG_X;      // Right Wall 2

        // g_LongRoomPaintings2 is a copy of g_LongRoomPaintings1 plus another painting.
        for (nIndex = 0; nIndex < ARRAYSIZE(g_LongRoomPaintings1); nIndex++)
        {
            g_LongRoomPaintings2[nIndex].vLocation = g_LongRoomPaintings1[nIndex].vLocation;
            g_LongRoomPaintings2[nIndex].vNormal = g_LongRoomPaintings1[nIndex].vNormal;
        }
        g_LongRoomPaintings2[6].vLocation = D3DXVECTOR3(g_fRoomWidthX-g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ * (3.0f / 4.0f) )); g_LongRoomPaintings2[6].vNormal = NORMAL_NEG_X;      // Right Wall 3

        // g_LongRoomPaintings3 is a copy of g_LongRoomPaintings1 plus another painting.
        for (nIndex = 0; nIndex < ARRAYSIZE(g_LongRoomPaintings1); nIndex++)
        {
            g_LongRoomPaintings3[nIndex].vLocation = g_LongRoomPaintings1[nIndex].vLocation;
            g_LongRoomPaintings3[nIndex].vNormal = g_LongRoomPaintings1[nIndex].vNormal;
        }
        g_LongRoomPaintings3[6].vLocation = D3DXVECTOR3(g_fFudge, g_fPaintingHeightY, (g_fRoomDepthZ * (3.0f / 4.0f))); g_LongRoomPaintings3[6].vNormal = NORMAL_X;                         // Left Wall 3
    }
}


//-----------------------------------------------------------------------------
// Name: CTheRoom()
// Desc: Constructor
//-----------------------------------------------------------------------------
CTheRoom::CTheRoom(BOOL fLobby, CMSLogoDXScreenSaver * pMain, CTheRoom * pEnterRoom, int nBatch) 
                        : m_objWall1(pMain), m_objCeiling(pMain), m_objToeGuard1(pMain), m_objFloor(pMain),
                          m_theRug(pMain), m_thePowerSocket(pMain), m_nBatch(nBatch), m_cRef(1)
{
    InitLayout();

    // Initialize member variables
    D3DXMatrixIdentity(&m_matIdentity);
    m_pEnterRoom = NULL;
    m_pFirstRoom = NULL;
    m_pLeftRoom = NULL;
    m_pRightRoom = NULL;

    m_fRoomCreated = FALSE;
    m_fVisible = FALSE;
    m_fLowPriority = FALSE;
    m_fLobby = fLobby;
    m_pMain = pMain;
    m_fCurrentRoom = FALSE;
    IUnknown_Set((IUnknown **) &m_pEnterRoom, pEnterRoom);

    if (fLobby)
    {
        m_pFloorPlan = &g_RoomFloorPlansLobby[GetRandomInt(0, ARRAYSIZE(g_RoomFloorPlansLobby)-1)];
    }
    else
    {
        m_pFloorPlan = &g_RoomFloorPlans[GetRandomInt(0, ARRAYSIZE(g_RoomFloorPlans)-1)];   // ARRAYSIZE(g_RoomFloorPlans)-1
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pPaintings); nIndex++)
    {
        m_pPaintings[nIndex] = NULL;
    }

    g_nLeakCheck++;
}


CTheRoom::~CTheRoom()
{
    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pPaintings); nIndex++)
    {
        SAFE_DELETE(m_pPaintings[nIndex]);
    }

    FinalCleanup();     // Just in case someone forgot to call FinalCleanup() in an error condition.
    g_nLeakCheck--;
}


HRESULT CTheRoom::_InitPaintings(void)
{
    HRESULT hr = S_OK;

    if (!g_pPictureMgr || !m_pFloorPlan)
    {
        return E_FAIL;
    }

    if (m_pPaintings[0])
    {
        return S_OK;
    }

#define FRAMESIZE_X     0.062696f      // This is the frame size for frame.bmp
#define FRAMESIZE_Y     0.087336f      // This is the frame size for frame.bmp

    float fMaxPaintingWH = (g_fRoomHeightY * 0.4f);       // The picture can not be more than one half the size of the wall.
    float fScale = 1.0f;

    for (int nIndex = 0; (nIndex < ARRAYSIZE(m_pPaintings)) && (nIndex < m_pFloorPlan->nPaintings) && SUCCEEDED(hr); nIndex++)
    {
        m_pPaintings[nIndex] = new CPainting(m_pMain);

        if (m_pPaintings[nIndex])
        {
            DWORD dwMaxPixelSize = ((3 * g_dwHeight) / 4);
            CTexture * pPaintingTexture = NULL;

            hr = g_pPictureMgr->GetPainting(m_nBatch, nIndex, 0, &pPaintingTexture);
            if (SUCCEEDED(hr))
            {
                D3DXVECTOR3 vPaintingLoc = m_pFloorPlan->pPaintingsLayout[nIndex].vLocation;
                D3DXVECTOR3 vPaintingNormal = m_pFloorPlan->pPaintingsLayout[nIndex].vNormal;

                m_pPaintings[nIndex]->OneTimeSceneInit();
                hr = m_pPaintings[nIndex]->SetPainting(m_pMain->GetGlobalTexture(ITEM_FRAME, &fScale), pPaintingTexture, vPaintingLoc, fMaxPaintingWH, FRAMESIZE_X, FRAMESIZE_Y, vPaintingNormal, dwMaxPixelSize);
                pPaintingTexture->Release();
            }
            else
            {
                // This will fail if we can't load our pictures.  This will cause us to come back later when
                // the background thread may have an image.
                SAFE_DELETE(m_pPaintings[nIndex]);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT CTheRoom::_AddWall(BOOL fWithDoor, D3DXVECTOR3 vLocation, D3DXVECTOR3 vWidth, D3DXVECTOR3 vHeight, D3DXVECTOR3 vNormal,
                           float fTotalHeight, float fDoorHeight, float fTotalWidth, float fDoorWidth, float fDoorStart)
{
    HRESULT hr = S_OK;

    C3DObject * pobjNextWall = new C3DObject(m_pMain);
    C3DObject * pobjNextToeGuard = new C3DObject(m_pMain);
    if (pobjNextWall && pobjNextToeGuard && m_pMain)
    {
        if (fWithDoor)
        {
            hr = _AddWallWithDoor(pobjNextWall, pobjNextToeGuard, &m_objFloor, vLocation, vWidth, vHeight, vNormal, fTotalHeight, fDoorHeight, fTotalWidth, fDoorWidth, fDoorStart);
        }
        else
        {
            // Texture Coords
            float fScale = 1.0f;
            CTexture * pTexture = m_pMain->GetGlobalTexture(ITEM_WALLPAPER, &fScale);
            float fTSWallpaperX = (TEXTURESCALE_WALLPAPER * fScale);     // How many repeats per 1 unit.
            float fTSWallpaperY = fTSWallpaperX * pTexture->GetSurfaceRatio();

            D3DXVECTOR3 vSizeNoDoor = ((vWidth * fTotalWidth) + (vHeight * fTotalHeight));
            hr = pobjNextWall->InitPlane(pTexture, m_pMain->GetD3DDevice(), vLocation, vSizeNoDoor, vNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
            if (SUCCEEDED(hr))
            {
                CTexture * pToeGuardTexture = m_pMain->GetGlobalTexture(ITEM_TOEGUARD, &fScale);
                float fTSToeGuardX = (TEXTURESCALE_TOEGUARD * fScale);     // How many repeats per 1 unit.
                float fTSToeGuardY = fTSToeGuardX * pToeGuardTexture->GetSurfaceRatio();

                // Draw ToeGuard
                vLocation += (g_fFudge * vNormal);
                vSizeNoDoor = D3DXVECTOR3(vSizeNoDoor.x, TOEGUARD_HEIGHT, vSizeNoDoor.z);
                hr = pobjNextToeGuard->InitPlane(pToeGuardTexture, m_pMain->GetD3DDevice(), vLocation, vSizeNoDoor, vNormal, 2, 2, fTSToeGuardX, fTSToeGuardY, 0, 0);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = m_objWall1.CombineObject(m_pMain->GetD3DDevice(), pobjNextWall);
            hr = m_objToeGuard1.CombineObject(m_pMain->GetD3DDevice(), pobjNextToeGuard);
        }
    }
    SAFE_DELETE(pobjNextWall);
    SAFE_DELETE(pobjNextToeGuard);

    return hr;
}


HRESULT CTheRoom::_AddWallWithDoor(C3DObject * pobjWall, C3DObject * pobjToeGuard, C3DObject * pobjFloor, D3DXVECTOR3 vLocation, D3DXVECTOR3 vWidth, D3DXVECTOR3 vHeight, D3DXVECTOR3 vNormal,
                                   float fTotalHeight, float fDoorHeight, float fTotalWidth, float fDoorWidth, float fDoorStart)
{
    HRESULT hr = S_OK;
    float fScale = 1.0f;
    float fYToeGuard = TOEGUARD_HEIGHT;

    CTexture * pToeTexture = m_pMain->GetGlobalTexture(ITEM_TOEGUARD, &fScale);
    float fTSToeGuardX = (TEXTURESCALE_TOEGUARD * fScale);     // How many repeats per 1 unit.
    float fTSToeGuardY = fTSToeGuardX * pToeTexture->GetSurfaceRatio();

    CTexture * pTexture = m_pMain->GetGlobalTexture(ITEM_WALLPAPER, &fScale);
    float fTSWallpaperX = (TEXTURESCALE_WALLPAPER * fScale);     // How many repeats per 1 unit.
    float fTSWallpaperY = fTSWallpaperX * pTexture->GetSurfaceRatio();

    CTexture * pFloorTexture = m_pMain->GetGlobalTexture(ITEM_FLOOR, &fScale);
    float fTSFloorX = (TEXTURESCALE_FLOOR * fScale);     // How many repeats per 1 unit.
    float fTSFloorY = fTSFloorX * pFloorTexture->GetSurfaceRatio();

    // Create Main Wall
    D3DXVECTOR3 vSize = ((fDoorStart * vWidth) + (fTotalHeight * vHeight));

    hr = pobjWall->InitPlane(pTexture, m_pMain->GetD3DDevice(), vLocation, vSize, vNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
    if (SUCCEEDED(hr))
    {
        D3DXVECTOR3 vToeLocation = (vLocation + (g_fFudge * vNormal));    // Offset the toeguard so it's above the wall.
        vSize = D3DXVECTOR3(D3DXVec3Multiply(vSize, vWidth) + (vHeight * fYToeGuard));            // Replace the height component with the ToeGuard height)

        hr = pobjToeGuard->InitPlane(pToeTexture, m_pMain->GetD3DDevice(), vToeLocation, vSize, vNormal, 2, 2, fTSToeGuardX, fTSToeGuardY, 0, 0);
        if (SUCCEEDED(hr))
        {
            int nParts = 9;
            D3DXVECTOR3 vNextLocation;
            D3DXVECTOR3 vTempNormal;

            while (nParts--)    // We have 2 more wall parts and 1 more toeguards to add.
            {
                C3DObject * pNewObject = new C3DObject(m_pMain);

                if (pNewObject)
                {
                    switch (nParts)
                    {
                    case 8:             // Floor at base of door way.
                        vNextLocation = (vLocation + (fDoorStart * vWidth));
                        vSize = (((-1.0f * DOORFRAME_DEPTH) * vNormal) + (fDoorWidth * vWidth));
                        vTempNormal = D3DXVECTOR3(0.0f, 1.0f, 0.0f);        // Normal points up
                        hr = pNewObject->InitPlane(pFloorTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSFloorX, fTSFloorY, 0, 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjFloor->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 7:             // Add the wallguard in the door way #2
                        vNextLocation = (vLocation + ((fDoorStart + g_fFudge) * vWidth) + (g_fFudge * vNormal));
                        vSize = (((-1.0f * (DOORFRAME_DEPTH + (2.0f * g_fFudge)) * vNormal)) + (fYToeGuard * vHeight));
                        vTempNormal = vWidth;
                        hr = pNewObject->InitPlane(pToeTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSToeGuardX, fTSToeGuardY, 0, 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjToeGuard->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 6:             // Add the wallguard in the door way #1
                        vNextLocation = (vLocation + ((fDoorStart + fDoorWidth - g_fFudge) * vWidth) + (g_fFudge * vNormal));
                        vSize = (((-1.0f * (DOORFRAME_DEPTH + (2.0f * g_fFudge))) * vNormal) + (fYToeGuard * vHeight));
                        vTempNormal = (-1.0f * vWidth);
                        hr = pNewObject->InitPlane(pToeTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSToeGuardX, fTSToeGuardY, 0, 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjToeGuard->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 5:             // Add door frame top
                        vNextLocation = (vLocation + (fDoorStart * vWidth) + (fDoorHeight * vHeight));
                        vSize = (((-1.0f * DOORFRAME_DEPTH) * vNormal) + (fDoorWidth * vWidth));
                        vTempNormal = D3DXVECTOR3(0.0f, -1.0f, 0.0f);
                        hr = pNewObject->InitPlane(pTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjWall->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 4:             // Add door frame #2
                        vNextLocation = (vLocation + (fDoorStart * vWidth));
                        vSize = (((-1.0f * DOORFRAME_DEPTH) * vNormal) + (fTotalHeight * vHeight));
                        vTempNormal = vWidth;
                        hr = pNewObject->InitPlane(pTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjWall->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 3:             // Add door frame #1
                        vNextLocation = (vLocation + ((fDoorStart + fDoorWidth) * vWidth));
                        vSize = (((-1.0f * DOORFRAME_DEPTH) * vNormal) + (fTotalHeight * vHeight));
                        vTempNormal = (-1.0f * vWidth);
                        hr = pNewObject->InitPlane(pToeTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vTempNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjWall->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 2:             // Add the second wall part. (Wall over the door)
                        vNextLocation = (vLocation + (fDoorStart * vWidth) + (fDoorHeight * vHeight));
                        vSize = ((fDoorWidth * vWidth) + ((fTotalHeight - fDoorHeight) * vHeight));
                        hr = pNewObject->InitPlane(pTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjWall->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 1:             // Add the third wall part
                        vNextLocation = (vLocation + ((fDoorStart + fDoorWidth) * vWidth));
                        vSize = (((fTotalWidth - (fDoorStart + fDoorWidth)) * vWidth) + (fTotalHeight * vHeight));
                        hr = pNewObject->InitPlane(pTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vNormal, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjWall->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    case 0:             // Add the second Toe Guard   
                        vNextLocation = (vLocation + ((fDoorStart + fDoorWidth) * vWidth) + (g_fFudge * vNormal));
                        vSize = (((fTotalWidth - (fDoorStart + fDoorWidth)) * vWidth) + (fYToeGuard * vHeight));
                        hr = pNewObject->InitPlane(pToeTexture, m_pMain->GetD3DDevice(), vNextLocation, vSize, vNormal, 2, 2, fTSToeGuardX, fTSToeGuardY, 0, 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pobjToeGuard->CombineObject(m_pMain->GetD3DDevice(), pNewObject);
                        }
                        delete pNewObject;
                        break;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    return hr;
}


HRESULT CTheRoom::_SetRotationMatrix(void)
{
    HRESULT hr = S_OK;
    D3DXMATRIX matRotate;
    D3DXMATRIX matTrans;

    // We want to set the matricies to get us to the next room.
    // Next Room
    if (m_pFirstRoom)
    {
        D3DXMatrixRotationY(&matRotate, D3DXToRadian(180));
        D3DXMatrixTranslation(&matTrans, ((g_fRoomWidthX / 2.0f) + (DOOR_WIDTH / 2.0f) + m_pFirstRoom->GetDoorOffset()), 0.0f, -1.0f);
        D3DXMatrixMultiply(&m_matFirstRoom, &matRotate, &matTrans);
    }

    if (m_pLeftRoom)
    {
        D3DXMatrixRotationY(&matRotate, D3DXToRadian(270));
        D3DXMatrixTranslation(&matTrans, -1.0f, 0.0f, WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f) - m_pLeftRoom->GetDoorOffset());
        D3DXMatrixMultiply(&m_matLeftRoom, &matRotate, &matTrans);
    }

    // Side Room
    if (m_pRightRoom)
    {
        D3DXMatrixRotationY(&matRotate, D3DXToRadian(90));
        D3DXMatrixTranslation(&matTrans, (g_fRoomWidthX + 1.0f), 0.0f, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f) + m_pRightRoom->GetDoorOffset()));
        D3DXMatrixMultiply(&m_matRightRoom, &matRotate, &matTrans);
    }

    return hr;
}


HRESULT CTheRoom::_CreateLobbySign(void)
{
    TCHAR szLine2[MAX_PATH];
    TCHAR szUsername[MAX_PATH];
    HRESULT hr = GetCurrentUserCustomName(szUsername, ARRAYSIZE(szUsername));

    LoadString(HINST_THISDLL, IDS_LOBBY_TITLE2, szLine2, ARRAYSIZE(szLine2));
    if (SUCCEEDED(hr))
    {
        // TODO:
        // 1. Create Sign backdrop. (Marble, wood?)
        // 2. Render Text. (D3DXCreateTextW, etc.)
    }

    return hr;
}


HRESULT CTheRoom::_CreateRoom(void)
{
    // TODO: For Square room, layout differently
    HRESULT hr = S_OK;

    D3DXVECTOR3 vNormalWall1(0, 0, -1);
    D3DXVECTOR3 vNormalWall2(-1, 0, 0);
    D3DXVECTOR3 vNormalWall3(0, 0, 1);
    D3DXVECTOR3 vNormalWall4(1, 0, 0);
    D3DXVECTOR3 vNormalFloor(0, 1, 0);
    D3DXVECTOR3 vNormalCeiling(0, -1, 0);
    DWORD dwRugMaxPixelSize = ((3 * g_dwHeight) / 4);

    m_fCeiling = m_fToeGuard = m_fPaintings = m_fRug = m_fPower = m_fWalls = m_fFloor = TRUE;
    m_fCeiling = !g_fOverheadViewTest;

    // Locations
    float fYToeGuard = TOEGUARD_HEIGHT;

    // Rug
    float fScale = 1.0f;
    float fRugWidth = 40.0f;
    float fRugDepth = (fRugWidth * (m_pMain->GetGlobalTexture(ITEM_RUG, &fScale))->GetSurfaceRatio());            // This will cause one object to be above another.
    D3DXVECTOR3 vRugLoc(((g_fRoomWidthX - fRugWidth) / 2.0f), g_fFudge, ((g_fRoomDepthZ - fRugDepth) / 2.0f));
    D3DXVECTOR3 vRugSize(fRugWidth, 0, fRugDepth);

    // PowerSocket
    float fPowerWidth = 2.5f;
    float fPowerHeight = (fPowerWidth * (m_pMain->GetGlobalTexture(ITEM_POWEROUTLET, &fScale))->GetSurfaceRatio());            // This will cause one object to be above another.
    D3DXVECTOR3 vPowerLoc(((g_fRoomWidthX - fPowerWidth) / 2.0f), 5.00f, (g_fRoomDepthZ - g_fFudge));
    D3DXVECTOR3 vPowerSize(fPowerWidth, fPowerHeight, 0.0f);

    // Texture Coords
    CTexture * pTexture = m_pMain->GetGlobalTexture(ITEM_WALLPAPER, &fScale);
    float fTSWallpaperX = (TEXTURESCALE_WALLPAPER * fScale);     // How many repeats per 1 unit.
    float fTSWallpaperY = fTSWallpaperX * pTexture->GetSurfaceRatio();

    CTexture * pFloorTexture = m_pMain->GetGlobalTexture(ITEM_FLOOR, &fScale);
    float fTSFloorX = (TEXTURESCALE_FLOOR * fScale);     // How many repeats per 1 unit.
    float fTSFloorY = fTSFloorX * pFloorTexture->GetSurfaceRatio();

    CTexture * pToeGuardTexture = m_pMain->GetGlobalTexture(ITEM_TOEGUARD, &fScale);
    float fTSToeGuardX = (TEXTURESCALE_TOEGUARD * fScale);     // How many repeats per 1 unit.
    float fTSToeGuardY = fTSToeGuardX * pToeGuardTexture->GetSurfaceRatio();

    CTexture * pCeilingTexture = m_pMain->GetGlobalTexture(ITEM_CEILING, &fScale);
    float fTSCeilingX = (TEXTURESCALE_CEILING * fScale);     // How many repeats per 1 unit.
    float fTSCeilingY = fTSCeilingX * pCeilingTexture->GetSurfaceRatio();

    // Draw Floor
    D3DXVECTOR3 vLocation(0.00f, 0.00f, 0.00f);
    D3DXVECTOR3 vSize(g_fRoomWidthX, 0.00f, g_fRoomDepthZ);
    hr = m_objFloor.InitPlane(pFloorTexture, m_pMain->GetD3DDevice(), vLocation, vSize, vNormalFloor, 2, 2, fTSFloorY, fTSFloorX, 0, 10);


    // Draw Wall 1 (Facing Wall)
    vLocation = D3DXVECTOR3(0.00f, 0.00f, g_fRoomDepthZ);
    vSize = D3DXVECTOR3(g_fRoomWidthX, g_fRoomHeightY, 0.00f);
    hr = m_objWall1.InitPlane(pTexture, m_pMain->GetD3DDevice(), vLocation, vSize, vNormalWall1, 2, 2, fTSWallpaperX, fTSWallpaperY, 0, 10);

    // Draw ToeGuard 1
    vLocation = D3DXVECTOR3(0.00f, 0.00f, g_fRoomDepthZ-g_fFudge);
    vSize = D3DXVECTOR3(g_fRoomWidthX, fYToeGuard, 0.00f);
    hr = m_objToeGuard1.InitPlane(pToeGuardTexture, m_pMain->GetD3DDevice(), vLocation, vSize, vNormalWall1, 2, 2, fTSToeGuardY, fTSToeGuardX, 0, 0);


    // Draw Wall 2 (Right wall)
    vLocation = D3DXVECTOR3(g_fRoomWidthX, 0.00f, 0.00f);
    hr = _AddWall((NULL != m_pRightRoom), vLocation, D3DXVECTOR3(0.0f, 0.0f, 1.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), vNormalWall2, g_fRoomHeightY,
                            DOOR_HEIGHT, g_fRoomDepthZ, DOOR_WIDTH, WALL_WIDTHBEFOREDOOR);


    // Draw Wall 3 (Back Wall)
    vLocation = D3DXVECTOR3(0.00f, 0.00f, 0.00f);
    hr = _AddWall(FALSE, vLocation, D3DXVECTOR3(1.0f, 0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), vNormalWall3, g_fRoomHeightY,
                            DOOR_HEIGHT, g_fRoomWidthX, DOOR_WIDTH, ((g_fRoomWidthX - DOOR_WIDTH) / 2.0f));


    // Draw Wall 4 (Left Wall)
    vLocation = D3DXVECTOR3(0.00f, 0.00f, 0.00f);
    hr = _AddWall((NULL != m_pLeftRoom), vLocation, D3DXVECTOR3(0.0f, 0.0f, 1.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), vNormalWall4, g_fRoomHeightY,
                        DOOR_HEIGHT, g_fRoomDepthZ, DOOR_WIDTH, WALL_WIDTHBEFOREDOOR);

    // Draw Ceiling
    vLocation = D3DXVECTOR3(0.00f, g_fRoomHeightY, 0.00f);
    vSize = D3DXVECTOR3(g_fRoomWidthX, 0.00f, g_fRoomDepthZ);
    hr = m_objCeiling.InitPlane(pCeilingTexture, m_pMain->GetD3DDevice(), vLocation, vSize, vNormalCeiling, 2, 2, fTSCeilingY, fTSCeilingX, 0, 10);
    

    // Room Items (Rug, Power Sockets, Benches)
    hr = m_theRug.InitPlaneStretch(m_pMain->GetGlobalTexture(ITEM_RUG, &fScale), m_pMain->GetD3DDevice(), vRugLoc, vRugSize, vNormalFloor, 2, 2, dwRugMaxPixelSize);

    if (m_fLobby)
    {
        hr = _CreateLobbySign();
    }
    else
    {
        // We don't want a powerplug in the lobby.
        hr = m_thePowerSocket.InitPlaneStretch(m_pMain->GetGlobalTexture(ITEM_POWEROUTLET, &fScale), m_pMain->GetD3DDevice(), vPowerLoc, vPowerSize, vNormalWall1, 2, 2, 0);
    }

    hr = _SetRotationMatrix();

    m_fWalls = TRUE;

    return hr;
}


//-----------------------------------------------------------------------------
// Name: OneTimeSceneInit()
// Desc: Called during initial app startup, this function performs all the
//       permanent initialization.
//-----------------------------------------------------------------------------
HRESULT CTheRoom::OneTimeSceneInit(int nFutureRooms, BOOL fLowPriority)
{
    HRESULT hr = S_OK;

    m_fLowPriority = fLowPriority;
    if (!m_fRoomCreated)
    {
//        assert(!m_pFirstRoom);      // This will cause a leak
//        ASSERT(!m_pLeftRoom);       //, TEXT("This will cause a leak"));
//        ASSERT(!m_pRightRoom);      // , TEXT("This will cause a leak"));

        if (m_pFloorPlan->nEnterDoor == 0)
        {
            IUnknown_Set((IUnknown **) &m_pFirstRoom, m_pEnterRoom);
        }
        else
        {
            if (m_pFloorPlan->fDoor0)
            {
                m_pFirstRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
                if (!m_pFirstRoom)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (m_pFloorPlan->nEnterDoor == 1)
        {
            IUnknown_Set((IUnknown **) &m_pLeftRoom, m_pEnterRoom);
        }
        else
        {
            if (m_pFloorPlan->fDoor1)
            {
                m_pLeftRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
                if (!m_pLeftRoom)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (m_pFloorPlan->nEnterDoor == 2)
        {
            IUnknown_Set((IUnknown **) &m_pRightRoom, m_pEnterRoom);
        }
        else
        {
            if (m_pFloorPlan->fDoor2)
            {
                m_pRightRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
                if (!m_pRightRoom)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (SUCCEEDED(hr) &&
            (m_pFirstRoom || m_pLeftRoom || m_pRightRoom))
        {
            hr = _CreateRoom();
            if (!m_fLobby && !g_fFirstFrame)
            {
                _InitPaintings();
            }

            if (SUCCEEDED(hr))
            {
                m_fVisible = TRUE;       // We have children to render.
                m_fRoomCreated = TRUE;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr) && (nFutureRooms > 0))
    {
        if (m_pLeftRoom)
        {
            hr = m_pLeftRoom->OneTimeSceneInit(nFutureRooms-1, FALSE);
        }
        if (SUCCEEDED(hr) && m_pRightRoom)
        {
            hr = m_pRightRoom->OneTimeSceneInit(nFutureRooms-1, FALSE);
        }  // TODO: Need first room?
    }

    return hr;
}


HRESULT CTheRoom::FreePictures(int nMaxBatch)
{
    HRESULT hr = S_OK;

    if (-1 == nMaxBatch)
    {
        nMaxBatch = m_nBatch;
    }

    if (nMaxBatch >= m_nBatch)
    {
        if (g_pPictureMgr)
        {
            g_pPictureMgr->ReleaseBatch(m_nBatch);
            m_nBatch = 0;
        }

        // Free our paintings
        for (int nIndex = 0; (nIndex < ARRAYSIZE(m_pPaintings)); nIndex++)
        {
            SAFE_DELETE(m_pPaintings[nIndex]);
        }

        if (m_pFloorPlan)
        {
            if (m_pFirstRoom && (m_pFirstRoom != m_pEnterRoom) &&
                (!m_fCurrentRoom || (0 != m_pFloorPlan->nExitDoor)))
            {
                hr = m_pFirstRoom->FreePictures(nMaxBatch);
            }

            if (m_pLeftRoom && (m_pLeftRoom != m_pEnterRoom) &&
                (!m_fCurrentRoom || (1 != m_pFloorPlan->nExitDoor)))
            {
                hr = m_pLeftRoom->FreePictures(nMaxBatch);
            }

            if (m_pRightRoom && (m_pRightRoom != m_pEnterRoom) &&
                (!m_fCurrentRoom || (2 != m_pFloorPlan->nExitDoor)))
            {
                hr = m_pRightRoom->FreePictures(nMaxBatch);
            }
        }
    }

    return hr;
}


HRESULT CTheRoom::SetCurrent(BOOL fCurrent)
{
    HRESULT hr = S_OK;

    m_fCurrentRoom = fCurrent;
    if (fCurrent)
    {
        if (m_pFirstRoom)
        {
            hr = m_pFirstRoom->OneTimeSceneInit(1, TRUE);
        }

        if (m_pLeftRoom)
        {
            hr = m_pLeftRoom->OneTimeSceneInit(1, TRUE);
        }

        if (m_pRightRoom)
        {
            hr = m_pRightRoom->OneTimeSceneInit(1, TRUE);
        }

        m_fVisible = TRUE;
    }
    else
    {
    }

    return hr;
}


HRESULT CTheRoom::GetNextRoom(CTheRoom ** ppNextRoom)
{
    // This function does two things:
    // 1. Gives the caller a pointer to our next room, and
    // 2. Changes the order so we free rooms we will no longer need.
    // We want to take this opportunity to free our other rooms in case we come back into this room.
    // TODO: Regen other rooms.  Use Ref-counting with SetSite(NULL) in order to track memory correctly.

    // We would need to re-generate m_pFloorPlan that has the same enter door as our exit door
    // with the same floor plan if we want to walk into previous rooms.
    switch (m_pFloorPlan->nExitDoor)
    {
    case 0: // Enter door
        IUnknown_Set((IUnknown **) ppNextRoom, m_pFirstRoom);
        IUnknown_Set((IUnknown **) &m_pEnterRoom, m_pFirstRoom);
        break;
    case 1: // Left door
        IUnknown_Set((IUnknown **) ppNextRoom, m_pLeftRoom);
        IUnknown_Set((IUnknown **) &m_pEnterRoom, m_pLeftRoom);
        break;
    case 2: // Right door
        IUnknown_Set((IUnknown **) ppNextRoom, m_pRightRoom);
        IUnknown_Set((IUnknown **) &m_pEnterRoom, m_pRightRoom);
        break;
    };

    BOOL fReEnter = ((ppNextRoom && *ppNextRoom) ? ((*ppNextRoom)->GetEnterDoor() == (*ppNextRoom)->GetExitDoor()) : FALSE);

    if (m_pFirstRoom != m_pEnterRoom)
    {
        if (m_pFirstRoom) m_pFirstRoom->FinalCleanup();
        SAFE_RELEASE(m_pFirstRoom);

        if (fReEnter)
        {
            m_pFirstRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
        }
    }

    if (m_pLeftRoom != m_pEnterRoom)
    {
        if (m_pLeftRoom) m_pLeftRoom->FinalCleanup();
        SAFE_RELEASE(m_pLeftRoom);

        if (fReEnter)
        {
            m_pLeftRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
        }
    }

    if (m_pRightRoom != m_pEnterRoom)
    {
        if (m_pRightRoom) m_pRightRoom->FinalCleanup();
        SAFE_RELEASE(m_pRightRoom);

        if (fReEnter)
        {
            m_pRightRoom = new CTheRoom(FALSE, m_pMain, this, m_nBatch+1);
        }
    }

    return (*ppNextRoom ? S_OK : E_FAIL);
}


//-----------------------------------------------------------------------------
// Name: FinalCleanup()
// Desc: Called before the app exits, this function gives the app the chance
//       to cleanup after itself.
//-----------------------------------------------------------------------------
HRESULT CTheRoom::FinalCleanup(void)
{
    // This is where we break all the circular ref-counts
    if (m_pFirstRoom && (m_pEnterRoom != m_pFirstRoom))  m_pFirstRoom->FinalCleanup();
    if (m_pLeftRoom && (m_pEnterRoom != m_pLeftRoom))  m_pLeftRoom->FinalCleanup();
    if (m_pRightRoom && (m_pEnterRoom != m_pRightRoom))  m_pRightRoom->FinalCleanup();

    SAFE_RELEASE(m_pEnterRoom);
    SAFE_RELEASE(m_pFirstRoom);
    SAFE_RELEASE(m_pLeftRoom);
    SAFE_RELEASE(m_pRightRoom);

    m_theRug.FinalCleanup();
    m_thePowerSocket.FinalCleanup();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Called when the app is exitting, or the device is being changed,
//       this function deletes any device dependant objects.
//-----------------------------------------------------------------------------
HRESULT CTheRoom::DeleteDeviceObjects(void)
{
    m_theRug.DeleteDeviceObjects();
    m_thePowerSocket.DeleteDeviceObjects();

    return S_OK;
}


#define ABS(i)  (((i) < 0) ? -(i) : (i))


HRESULT CTheRoom::_RenderThisRoom(IDirect3DDevice8 * pD3DDevice, int nRenderPhase, BOOL fFrontToBack)
{
    HRESULT hr = S_OK;
    DWORD dwTesting = 0;

    switch (nRenderPhase)
    {
        case 0:         // Wallpaper
        if (m_fWalls)
        {
            hr = m_objWall1.Render(pD3DDevice);
        }
        break;

        case 1:
        if (m_fFloor)
        {
            hr = m_objFloor.Render(pD3DDevice);
        }
        break;


        case 2:
        if (m_fToeGuard)
        {
    //        pD3DDevice->SetRenderState(D3DRS_ZBIAS, 12);   // Force the ToeGuard to appear above the wallpaper.
            hr = m_objToeGuard1.Render(pD3DDevice);
        }
        break;

        case 3:         // Frames
        case 4:         // Pictures. (Here's where we blow the cache)
        if (m_fPaintings)
        {
            if (m_fLobby)
            {
                // TODO: Paint lobby sign. (user name)  Anything created in _CreateLobbySign().
            }
            else
            {
//        pD3DDevice->SetRenderState(D3DRS_ZBIAS, 13);
                if (!m_pPaintings[0] && m_fVisible && !g_fFirstFrame)      // Did the background thread not yet have any pictures for us?
                {
                    hr = _InitPaintings();      // If so, see if they have anything yet?
                }

                for (int nIndex = ARRAYSIZE(m_pPaintings)-1; m_fVisible && (nIndex >= 0); nIndex--)
                {
                    if (m_pPaintings[nIndex])       // May be NULL if out of memory or in lobby.
                    {
                        // We use fFrontToBack because we always want to render the frame first.  This way
                        // the painting is always painted on top.  We don't worry about blowing the texture
                        // cache on the video card because since we will render so many paintings and change
                        // the paintings we render so often, the cache will almost be certainly blown anyway.
                        // We always want 0 rendered first.
                        if (fFrontToBack)
                        {
                            m_pPaintings[nIndex]->Render(pD3DDevice, nRenderPhase-3);
                        }
                        else
                        {
                            m_pPaintings[nIndex]->Render(pD3DDevice, ((4 == nRenderPhase) ? 0 : 1));
                        }
                    }
                }
            }
        }
        break;

        case 5:
        if (m_fPower)
        {
//        pD3DDevice->SetRenderState(D3DRS_ZBIAS, 11);
            m_thePowerSocket.Render(pD3DDevice);
        }
        break;

        case 6:
        if (m_fRug)
        {
//        pD3DDevice->SetRenderState(D3DRS_ZBIAS, 10);
            m_theRug.Render(pD3DDevice);
        }
        break;

        case 7:
        if (m_fCeiling)
        {
            hr = m_objCeiling.Render(pD3DDevice);
        }
        break;
    }

    return hr;
}


//#define COLOR_DOORFRAME_GRAY        D3DXCOLOR(0.78f, 0.78f, 0.78f, 1.0f)
#define COLOR_DOORFRAME_GRAY        D3DXCOLOR(0.28f, 0.28f, 0.28f, 1.0f)

BOOL CTheRoom::_IsRoomVisible(IDirect3DDevice8 * pD3DDevice, int nRoomNumber)
{
    D3DXVECTOR3 vMin;
    D3DXVECTOR3 vMax;
    D3DXMATRIX matWorld;
    pD3DDevice->GetTransform(D3DTS_WORLD, &matWorld);

    switch (nRoomNumber)
    {
    case 0:             // First Door.
        return FALSE; // we never look back at the first door

    case 1:             // Left Door.
        vMin = D3DXVECTOR3( 0, 0, WALL_WIDTHBEFOREDOOR );
        vMax = D3DXVECTOR3( 0, DOOR_HEIGHT, WALL_WIDTHBEFOREDOOR + DOOR_WIDTH );
        return Is3DRectViewable( m_pMain->PCullInfo(), &matWorld, vMin, vMax );

    case 2:            // Right Door
        vMin = D3DXVECTOR3( g_fRoomWidthX, 0, WALL_WIDTHBEFOREDOOR );
        vMax = D3DXVECTOR3( g_fRoomWidthX, DOOR_HEIGHT, WALL_WIDTHBEFOREDOOR + DOOR_WIDTH );
        return Is3DRectViewable( m_pMain->PCullInfo(), &matWorld, vMin, vMax );

    default:
        return FALSE;
    }
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CTheRoom::Render(IDirect3DDevice8 * pD3DDevice, int nRenderPhase, BOOL fFrontToBack)
{
    HRESULT hr;
    DWORD dwTesting = 0;

    // Draw the obstacles
    D3DMATERIAL8 mtrl = {0};
    mtrl.Ambient.r = mtrl.Specular.r = mtrl.Diffuse.r = 1.0f;
    mtrl.Ambient.g = mtrl.Specular.g = mtrl.Diffuse.g = 1.0f;
    mtrl.Ambient.b = mtrl.Specular.b = mtrl.Diffuse.b = 1.0f;
    mtrl.Ambient.a = mtrl.Specular.a = mtrl.Diffuse.a = 1.0f;

    if (m_fCurrentRoom)
    {
//        DXUtil_Trace(TEXT("ROOM: m_nExitDoor=%d, m_pLeftRoom=%d, m_pRightRoom=%d\n"), m_pFloorPlan->nExitDoor, m_pLeftRoom, m_pRightRoom);
    }

    hr = pD3DDevice->SetMaterial(&mtrl);

    if (SUCCEEDED(hr) && m_fVisible && (m_pEnterRoom || m_pLeftRoom || m_pRightRoom))
    {
        // We really want to do hit testing here otherwise we are really wasting our time.
        D3DXMATRIX matPrevious;
        D3DXMATRIX matNext;

        hr = pD3DDevice->GetTransform(D3DTS_WORLD, &matPrevious);

        if (m_pEnterRoom && _IsRoomVisible(pD3DDevice, 0) &&
            (m_pEnterRoom != m_pFirstRoom))
        {
            D3DXMatrixMultiply(&matNext, &m_matFirstRoom, &matPrevious);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matNext);
            hr = m_pFirstRoom->Render(pD3DDevice, nRenderPhase, fFrontToBack);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matPrevious);
        }

        if (m_pLeftRoom && _IsRoomVisible(pD3DDevice, 1) &&
            (m_pEnterRoom != m_pLeftRoom))
        {
            D3DXMatrixMultiply(&matNext, &m_matLeftRoom, &matPrevious);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matNext);
            hr = m_pLeftRoom->Render(pD3DDevice, nRenderPhase, fFrontToBack);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matPrevious);
        }

        if (m_pRightRoom && _IsRoomVisible(pD3DDevice, 2) &&
            (m_pEnterRoom != m_pRightRoom))
        {
            D3DXMatrixMultiply(&matNext, &m_matRightRoom, &matPrevious);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matNext);
            hr = m_pRightRoom->Render(pD3DDevice, nRenderPhase, fFrontToBack);
            hr = pD3DDevice->SetTransform(D3DTS_WORLD, &matPrevious);
        }
    }

    hr = _RenderThisRoom(pD3DDevice, nRenderPhase, fFrontToBack);

    return hr;
}


#define DIST_TO_WALL_ON_ZOOM                10.0f

HRESULT CTheRoom::_AddPaintingToPaintingMovements(CCameraMove * ptheCamera, D3DXVECTOR3 vSourceLocIn, D3DXVECTOR3 vSourceTangentIn, 
                                                  D3DXVECTOR3 vPainting, D3DXVECTOR3 * pvDestDir, float fDest, D3DXVECTOR3 * pvDestTangent,
                                                  int nBatch)
{
    HRESULT hr = S_OK;
    float fDistToWall = 30.0f;
    float fZoomDistToWall = DIST_TO_WALL_ON_ZOOM;
    float fZoomDelta = (fDistToWall - fZoomDistToWall);
    BOOL fExitLeft = ((1 == m_pFloorPlan->nExitDoor) ? TRUE : FALSE);

    D3DXVECTOR3 vSourceLoc = vSourceLocIn;
    D3DXVECTOR3 vSourceTangent = vSourceTangentIn;
    D3DXVECTOR3 vDestLoc;
    D3DXVECTOR3 vDestTangent;

    // Move closer to the first painting so it's full screen
    vDestLoc = (vSourceLoc + (vPainting * fZoomDelta));
    vDestTangent = vSourceTangent;
    hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

    // Look at painting #1
    hr = ptheCamera->CreateNextWait(m_nBatch+3, nBatch);

    // Back up some and start moving to the next painting.
    vSourceLoc = vDestLoc;
    vSourceTangent = vDestTangent;
    vDestLoc = (vSourceLocIn + (*pvDestDir * (fDest * 0.5f)));
    vDestTangent = (*pvDestDir * fDest);
    hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

    // Now walk much closer to the next painting
    vSourceLoc = vDestLoc;
    vSourceTangent = vDestTangent;
    vDestLoc = (vSourceLocIn + (*pvDestDir * (fDest * 0.90f)));
    vDestTangent = vSourceTangent;
    hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

    // Now move close to the painting
    vSourceLoc = vDestLoc;
    vSourceTangent = vDestTangent;
    vDestLoc = (vSourceLocIn + (vPainting * fZoomDelta) + (*pvDestDir * fDest));
    vDestTangent = (vPainting * 5.0f) * 1000.0f;
    hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

    // Look at painting #2
    hr = ptheCamera->CreateNextWait(m_nBatch+3, nBatch);

    vSourceLoc = vDestLoc;
    vSourceTangent = vDestTangent = vPainting;
    vDestLoc = (vSourceLocIn + (*pvDestDir * fDest));
    hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

    *pvDestDir = vDestLoc;
    *pvDestTangent = vDestTangent;

    return hr;
}


HRESULT CTheRoom::_LongRoomEnterDoorMovements(CCameraMove * ptheCamera)
{
    HRESULT hr = S_OK;

    float fDistant = 5.0f;
    float fDistToWall = 30.0f;
    float fWalkHeight = 20.0f;

    D3DXVECTOR3 vSourceLoc((g_fRoomWidthX / 2.0f), fWalkHeight, 1.0f);
    D3DXVECTOR3 vSourceTangent(0.0f, 0.0f, fDistant);

    hr = ptheCamera->Init(vSourceLoc, vSourceTangent, D3DXVECTOR3(0.0f, 1.0f, 0.0f));
    if (SUCCEEDED(hr))
    {
        BOOL fExitLeft = ((1 == m_pFloorPlan->nExitDoor) ? TRUE : FALSE);

        // fExitLeft 1=Left
        D3DXVECTOR3 vDestLoc((fExitLeft ? fDistToWall : g_fRoomWidthX-fDistToWall), fWalkHeight, (g_fRoomDepthZ * (1.0f / 4.0f)));
        D3DXVECTOR3 vDestTangent((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
        hr = _AddPaintingToPaintingMovements(ptheCamera, vSourceLoc, vSourceTangent, D3DXVECTOR3((fExitLeft ? -1.0f : 1.0f), 0.0f, 0.0f),
                                &vDestLoc, (g_fRoomDepthZ * (1.0f / 4.0f)), &vDestTangent, 2);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? fDistant : -fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? g_fRoomWidthX-fDistToWall : fDistToWall), fWalkHeight, (g_fRoomDepthZ * (2.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        // If we removed this door, then let us look at the painting that took it's place.
        if (!m_pLeftRoom || !m_pRightRoom)
        {
            vSourceLoc = vDestLoc;
            vSourceTangent = vDestTangent;
            vDestLoc = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
            hr = _AddPaintingToPaintingMovements(ptheCamera, vSourceLoc, vSourceTangent, D3DXVECTOR3((fExitLeft ? 1.0f : -1.0f), 0.0f, 0.0f),
                                    &vDestLoc, (g_fRoomDepthZ * (1.0f / 4.0f)), &vDestTangent, 1);
        }
        else
        {
            vSourceLoc = vDestLoc;
            vSourceTangent = vDestTangent;
            vDestLoc = D3DXVECTOR3((fExitLeft ? g_fRoomWidthX-DIST_TO_WALL_ON_ZOOM : DIST_TO_WALL_ON_ZOOM), fWalkHeight, (g_fRoomDepthZ * (2.0f / 4.0f)));
            hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

            // Look at painting #3
            hr = ptheCamera->CreateNextWait(m_nBatch+3, 1);

            vSourceLoc = vDestLoc;
            vSourceTangent = vDestTangent;
            vDestTangent = D3DXVECTOR3((fExitLeft ? fDistant : -fDistant), 0.0f, fDistant);
            hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);
        }

        // Now, walk from this painting close up to the location of the next painting
        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? 2.0f : 1.0f) * (g_fRoomWidthX/3.0f), fWalkHeight, (g_fRoomDepthZ - fDistToWall));
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? -1.0f : 1.0f), 0.0f, 0.0f);
        hr = _AddPaintingToPaintingMovements(ptheCamera, vSourceLoc, vSourceTangent, D3DXVECTOR3(0.0f, 0.0f, 1.0f), 
                                &vDestLoc, (g_fRoomWidthX * (1.0f / 3.0f)), &vDestTangent, 1);

        // Turn toward the door while walking.
        vSourceLoc = vDestLoc;
        vSourceTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        vDestLoc = D3DXVECTOR3((fExitLeft ? 0.0f : g_fRoomWidthX), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        vDestTangent = D3DXVECTOR3((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
#define TURN_RATE           0.30f
        D3DXVECTOR3 vTemp;
        D3DXVec3Lerp(&vTemp, &vSourceLoc, &vDestLoc, TURN_RATE);        // We want to do our turn towards the door while walking.  We do it while walking 10% towards the door.
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vTemp, vDestTangent);
        vSourceLoc = vTemp;


        // Finish walking to and thru the exit door.
        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? 0.0f : g_fRoomWidthX), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);
    }

    return hr;
}


HRESULT CTheRoom::_LongRoomSideEnterLeaveMovements(CCameraMove * ptheCamera)
{
    HRESULT hr = S_OK;
    BOOL fExitLeft = ((1 == m_pFloorPlan->nExitDoor) ? TRUE : FALSE);

    float fDistant = 5.0f;
    float fDistToWall = 30.0f;
    float fWalkHeight = 20.0f;

    D3DXVECTOR3 vSourceLoc((fExitLeft ? g_fRoomWidthX : 0.0f), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
    D3DXVECTOR3 vSourceTangent((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);

    hr = ptheCamera->Init(vSourceLoc, vSourceTangent, D3DXVECTOR3(0.0f, 1.0f, 0.0f));
    if (SUCCEEDED(hr))
    {
        BOOL fExitLeft = ((1 == m_pFloorPlan->nExitDoor) ? TRUE : FALSE);

        // fExitLeft 1=Left
        D3DXVECTOR3 vDestLoc((fExitLeft ? g_fRoomWidthX-fDistToWall : fDistToWall), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        D3DXVECTOR3 vDestTangent((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, -fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? g_fRoomWidthX-fDistToWall : fDistToWall), fWalkHeight, (g_fRoomDepthZ * (3.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? fDistant : -fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        // Look at painting #1
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 2);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, -fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? g_fRoomWidthX-fDistToWall : fDistToWall), fWalkHeight, (g_fRoomDepthZ * (2.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? fDistant : -fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        // Look at painting #2
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 2);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, -fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? g_fRoomWidthX-fDistToWall : fDistToWall), fWalkHeight, (g_fRoomDepthZ * (1.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? fDistant : -fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        // Look at painting #3
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 1);

        // Now do the 180 degree turn around
        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, (GetRandomInt(0, 1) ? -fDistant : fDistant));
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? fDistToWall : g_fRoomWidthX-fDistToWall), fWalkHeight, (g_fRoomDepthZ * (1.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        // Look at painting #4 (Front Wall #1)
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 1);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? fDistToWall : g_fRoomWidthX-fDistToWall), fWalkHeight, (g_fRoomDepthZ * (2.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        // Look at painting #5 (Front Wall #2)
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 1);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? fDistToWall : g_fRoomWidthX-fDistToWall), fWalkHeight, (g_fRoomDepthZ * (3.0f / 4.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        // Look at painting #6 (Front Wall #2)
        hr = ptheCamera->CreateNextWait(m_nBatch+3, 1);

        // Walk towards the door
        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3(0.0f, 0.0f, fDistant);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? fDistToWall : g_fRoomWidthX-fDistToWall), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        // Now leave the room.
        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;
        vDestTangent = D3DXVECTOR3((fExitLeft ? -fDistant : fDistant), 0.0f, 0.0f);
        hr = ptheCamera->CreateNextRotate(vSourceLoc, vSourceTangent, vDestTangent);

        vSourceTangent = vDestTangent;
        vDestLoc = D3DXVECTOR3((fExitLeft ? 0.0f : g_fRoomWidthX), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        vDestTangent = vSourceTangent;
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);
    }

    return hr;
}


HRESULT CTheRoom::LoadCameraMoves(CCameraMove * ptheCamera)
{   // TODO: We need to change this based on the room shape and the door entered.
    HRESULT hr = S_OK;

    if (m_fLobby)
    {
        hr = _LoadLobbyPath(ptheCamera);
    }
    else
    {
        switch (m_pFloorPlan->nMovementPattern)
        {
        case 0:
            hr = _LongRoomEnterDoorMovements(ptheCamera);
            break;
        case 1:
            hr = _LongRoomSideEnterLeaveMovements(ptheCamera);
            break;
        }
    }

    return hr;
}


HRESULT CTheRoom::_LoadLobbyPath(CCameraMove * ptheCamera)
{
    HRESULT hr = S_OK;

    float fDistant = 5.0f;
    float fDistToWall = 30.0f;
    float fWalkHeight = 20.0f;

    D3DXVECTOR3 vSourceLoc((g_fRoomWidthX / 2.0f), fWalkHeight, 1.0f);
    D3DXVECTOR3 vSourceTangent(0.0f, 0.0f, fDistant);

    hr = ptheCamera->Init(vSourceLoc, vSourceTangent, D3DXVECTOR3(0.0f, 1.0f, 0.0f));
    if (SUCCEEDED(hr))
    {
        // Walk down the middle of the room.
        D3DXVECTOR3 vDestLoc((g_fRoomWidthX / 2.0f), fWalkHeight, (g_fRoomDepthZ * (2.0f / 4.0f)));
        D3DXVECTOR3 vDestTangent(0.0f, 0.0f, 1.0f);
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);

        // Now start walking toward the door.
        vSourceLoc = vDestLoc;
        vSourceTangent = vDestTangent;

        // 1=Left
        vDestTangent = D3DXVECTOR3(((1 == m_pFloorPlan->nExitDoor) ? -1.0f : 1.0f), 0.0f, 0.0f);
        vDestLoc = D3DXVECTOR3(((1 == m_pFloorPlan->nExitDoor) ? 0.0f : g_fRoomWidthX), fWalkHeight, (WALL_WIDTHBEFOREDOOR + (DOOR_WIDTH / 2.0f)));
        hr = ptheCamera->CreateNextMove(vSourceLoc, vSourceTangent, vDestLoc, vDestTangent);
    }

    return hr;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CTheRoom::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CTheRoom::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CTheRoom::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTheRoom, IUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}



int CTheRoom::GetEnterDoor(void)
{
    int nDoor = 0;

    if (m_pFloorPlan)
    {
        nDoor = m_pFloorPlan->nEnterDoor;
    }

    return nDoor;
}


int CTheRoom::GetExitDoor(void)
{
    int nDoor = 0;

    if (m_pFloorPlan)
    {
        nDoor = m_pFloorPlan->nExitDoor;
    }

    return nDoor;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\room.h ===
/*****************************************************************************\
    FILE: room.h

    DESCRIPTION:

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/


#ifndef ROOM_H
#define ROOM_H

#include "util.h"
#include "main.h"
#include "painting.h"
#include "pictures.h"


#define WATER_COLOR          0x00008899



//-----------------------------------------------------------------------------
// Defines, constants, and global variables
//-----------------------------------------------------------------------------

#define WALL_VECTORS                6
#define CEILING_VECTORS             4
#define FLOOR_VECTORS               4


#define DOORFRAME_DEPTH             1.0f
#define DOOR_HEIGHT                 30.0f
#define DOOR_WIDTH                  30.0f
#define WALL_WIDTHBEFOREDOOR        145.0f

#define TOEGUARD_HEIGHT             1.25f

// Smaller numbers make them appear larger.
#define TEXTURESCALE_WALLPAPER      0.6f        // 0.6f for 25x36 Orig, 0.3f for CDWallpaper 256x256.
#define TEXTURESCALE_TOEGUARD       0.6f        // 0.6f for 32x32.
#define TEXTURESCALE_CEILING        0.09f
#define TEXTURESCALE_FLOOR          0.05f       // 0.03f or 0.05f for Hardwoods (476x214), 0.09f for Tile (256x256)

#define DOOR_DISTANCETOFIRSTDOOR    0.6f

#define NUM_PAINTINGS               8

extern float g_fRoomWidthX;
extern float g_fRoomDepthZ;
extern float g_fRoomHeightY;
extern float g_fFudge;            // This will cause one object to be above another.



typedef struct
{
    D3DXVECTOR3 vLocation;
    D3DXVECTOR3 vNormal;
} PAINTING_LAYOUT;


typedef struct
{
    int nEnterDoor;
    int nExitDoor;
    int nMovementPattern;   // What pattern should be used in the user's movements?
    BOOL fDoor0;            // Does this door exist?
    BOOL fDoor1;            // Does this door exist?
    BOOL fDoor2;            // Does this door exist?
    int nPaintings;         // Number of PAINTING_LAYOUT in pPaintingsLayout.
    PAINTING_LAYOUT * pPaintingsLayout;
} ROOM_FLOORPLANS;




class CTheRoom          : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

public:
    HRESULT OneTimeSceneInit(int nFutureRooms, BOOL fLowPriority);
    HRESULT Render(IDirect3DDevice8 * lpDev, int nRenderPhase, BOOL fFrontToBack);
    HRESULT FinalCleanup(void);
    HRESULT DeleteDeviceObjects(void);
    HRESULT SetCurrent(BOOL fCurrent);
    HRESULT GetNextRoom(CTheRoom ** ppNextRoom);
    HRESULT LoadCameraMoves(CCameraMove * ptheCamera);
    HRESULT FreePictures(int nMaxBatch = -1);

    float GetDoorOffset(void) {return (g_fRoomWidthX / 2.0f);}       // This will return the distance between the new room's 0 coord and the middle of it's the enter door.
    int GetMaxRenderPhases(void) {return 8;};
    int GetEnterDoor(void);
    int GetExitDoor(void);

    CTheRoom(BOOL fLobby, CMSLogoDXScreenSaver * pMain, CTheRoom * pEnterRoom, int nBatch);
    virtual ~CTheRoom();

protected:
    int m_nBatch;

private:
    long m_cRef;

    D3DXMATRIX m_matIdentity;

    C3DObject m_objWall1;
    C3DObject m_objCeiling;
    C3DObject m_objToeGuard1;
    C3DObject m_objFloor;

    C3DObject m_theRug;
    C3DObject m_thePowerSocket;
    CPainting * m_pPaintings[NUM_PAINTINGS];

    BOOL m_fWalls;
    BOOL m_fToeGuard;
    BOOL m_fRug;
    BOOL m_fPower;
    BOOL m_fCeiling;
    BOOL m_fFloor;
    BOOL m_fPaintings;
    BOOL m_fLobby;

    BOOL m_fCurrentRoom;          // Current Room
    BOOL m_fVisible;
    BOOL m_fLowPriority;

    CMSLogoDXScreenSaver * m_pMain;         // Weak reference
    ROOM_FLOORPLANS * m_pFloorPlan;

    CTheRoom * m_pEnterRoom;                // Equal to m_pFirstRoom or m_pLeftRoom or m_pRightRoom
    CTheRoom * m_pFirstRoom;                // Thru Door 0
    CTheRoom * m_pLeftRoom;                 // Thru Door 1
    CTheRoom * m_pRightRoom;                // Thru Door 2
    D3DXMATRIX m_matFirstRoom;
    D3DXMATRIX m_matLeftRoom;
    D3DXMATRIX m_matRightRoom;

    BOOL m_fRoomCreated;

    // Functions:
    LPCTSTR _GetItemTexturePath(DWORD dwItem);
    HRESULT _InitPaintings(void);
    HRESULT _CreateRoom(void);
    HRESULT _AddWallWithDoor(C3DObject * pobjWall, C3DObject * pobjToeGuard, C3DObject * pobjFloor, D3DXVECTOR3 vLocation, D3DXVECTOR3 vWidth, D3DXVECTOR3 vHeight, D3DXVECTOR3 vNormal,
                                   float fTotalHeight, float fDoorHeight, float fTotalWidth, float fDoorWidth, float fDoorStart);
    HRESULT _RenderThisRoom(IDirect3DDevice8 * pD3DDevice, int nRenderPhase, BOOL fFrontToBack);
    HRESULT _SetRotationMatrix(void);
    HRESULT _LoadLobbyPath(CCameraMove * ptheCamera);
    HRESULT _CreateLobbySign(void);

    HRESULT _LongRoomEnterDoorMovements(CCameraMove * ptheCamera);
    HRESULT _LongRoomSideEnterLeaveMovements(CCameraMove * ptheCamera);

    BOOL _IsRoomVisible(IDirect3DDevice8 * pD3DDevice, int nRoomNumber);
    HRESULT _AddWall(BOOL fWithDoor, D3DXVECTOR3 vLocation, D3DXVECTOR3 vWidth, D3DXVECTOR3 vHeight, D3DXVECTOR3 vNormal,
                       float fTotalHeight, float fDoorHeight, float fTotalWidth, float fDoorWidth, float fDoorStart);
    HRESULT _AddPaintingToPaintingMovements(CCameraMove * ptheCamera, D3DXVECTOR3 vSourceLocIn, D3DXVECTOR3 vSourceTangentIn, 
                                                  D3DXVECTOR3 vPainting, D3DXVECTOR3 * pvDestDir, float fDest, D3DXVECTOR3 * pvDestTangent, int nBatch);

    friend CMSLogoDXScreenSaver;
};


#endif // ROOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\pictures.cpp ===
/*****************************************************************************\
    FILE: pictures.cpp

    DESCRIPTION:
        Manage the pictures in the user's directories.  Convert them when needed.
    Handle caching and making sure we don't use too much diskspace.  Also add
    picture frame when needed.

    BryanSt 12/24/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include <shlobj.h>
#include "pictures.h"
#include "util.h"


#undef __IShellFolder2_FWD_DEFINED__

#include <ccstock.h>




CPictureManager * g_pPictureMgr = NULL;



int CALLBACK DSACallback_FreePainting(LPVOID p, LPVOID pData)
{
    SSPICTURE_INFO * pPInfo = (SSPICTURE_INFO *) p;

    if (pPInfo)
    {
        Str_SetPtr(&pPInfo->pszPath, NULL);
    }

    return 1;
}


CPictureManager::CPictureManager(CMSLogoDXScreenSaver * pMain)
{
    m_nCurrent = 0;
    m_hdsaPictures = NULL;

    m_pMain = pMain;

    m_hdsaBatches = 0;
    m_nCurrentBatch = 0;

    _EnumPaintings();
}


CPictureManager::~CPictureManager()
{
    if (m_hdsaBatches)
    {
        DSA_Destroy(m_hdsaBatches);
        m_hdsaBatches = NULL;
    }

    if (m_hdsaPictures)
    {
        DSA_DestroyCallback(m_hdsaPictures, DSACallback_FreePainting, NULL);
        m_hdsaPictures = NULL;
    }

    m_pMain = NULL;
}




HRESULT CPictureManager::_PInfoCreate(int nIndex, LPCTSTR pszPath)
{
    HRESULT hr = S_OK;
    SSPICTURE_INFO pInfo = {0};

    pInfo.fInABatch = FALSE;
    pInfo.pszPath = NULL;
    Str_SetPtr(&pInfo.pszPath, pszPath);

    // We add them in a random order so the pattern doesn't get boring.
    if (-1 == DSA_InsertItem(m_hdsaPictures, nIndex, &pInfo))
    {
        // We failed so free the memory
        Str_SetPtr(&pInfo.pszPath, NULL);
        hr = E_OUTOFMEMORY;
    }

    return S_OK;
}


HRESULT CPictureManager::_AddPaintingsFromDir(LPCTSTR pszPath)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (!m_hdsaPictures)
    {
        m_hdsaPictures = DSA_Create(sizeof(SSPICTURE_INFO), 20);
    }

    if (m_hdsaPictures)
    {
        TCHAR szSearch[MAX_PATH];
        WIN32_FIND_DATA findFileData;

        hr = S_OK;
        StrCpyN(szSearch, pszPath, ARRAYSIZE(szSearch));
        PathAppend(szSearch, TEXT("*.*"));
        HANDLE hFindFiles = FindFirstFile(szSearch, &findFileData);
        if (INVALID_HANDLE_VALUE != hFindFiles)
        {
            while ((INVALID_HANDLE_VALUE != hFindFiles))
            {
                if (!PathIsDotOrDotDot(findFileData.cFileName))
                {
                    if (!(FILE_ATTRIBUTE_DIRECTORY & findFileData.dwFileAttributes))
                    {
                        LPCTSTR pszExt = PathFindExtension(findFileData.cFileName);

                        if (pszExt && pszExt[0] &&
                            (!StrCmpI(pszExt, TEXT(".bmp"))
                              || !StrCmpI(pszExt, TEXT(".jpg"))
                              || !StrCmpI(pszExt, TEXT(".jpeg"))
                              || !StrCmpI(pszExt, TEXT(".png"))
//                              || !StrCmpI(pszExt, TEXT(".gif"))
                              || !StrCmpI(pszExt, TEXT(".tiff"))
                            ))
                        {
                            int nInsertLoc = GetRandomInt(0, max(0, DSA_GetItemCount(m_hdsaPictures) - 1));

                            StrCpyN(szSearch, pszPath, ARRAYSIZE(szSearch));
                            PathAppend(szSearch, findFileData.cFileName);

                            hr = _PInfoCreate(nInsertLoc, szSearch);
                        }
                    }
                    else
                    {
                        StrCpyN(szSearch, pszPath, ARRAYSIZE(szSearch));
                        PathAppend(szSearch, findFileData.cFileName);
                        hr = _AddPaintingsFromDir(szSearch);
                    }
                }

                if (!FindNextFile(hFindFiles, &findFileData))
                {
                    break;
                }
            }

            FindClose(hFindFiles);
        }
    }

    return hr;
}


HRESULT CPictureManager::_EnumPaintings(void)
{
    HRESULT hr = E_FAIL;
    TCHAR szDir[MAX_PATH];

    if (g_pConfig)
    {
        hr = S_OK;
        if (g_pConfig->GetFolderOn(CONFIG_FOLDER_MYPICTS) &&
            SHGetSpecialFolderPath(NULL, szDir, CSIDL_MYPICTURES, TRUE))
        {
            hr = _AddPaintingsFromDir(szDir);
        }

        if (g_pConfig->GetFolderOn(CONFIG_FOLDER_COMMONPICTS))
        {
            // TODO: When Common Pictures are added.
        }

        if (g_pConfig->GetFolderOn(CONFIG_FOLDER_OTHER) &&
            SUCCEEDED(g_pConfig->GetOtherDir(szDir, ARRAYSIZE(szDir))))
        {
            hr = _AddPaintingsFromDir(szDir);
        }

        // If we have less than 10 paintings, then we force add the
        // Windows wallpapers.
        if ((g_pConfig->GetFolderOn(CONFIG_FOLDER_WINPICTS) ||
            (10 > DSA_GetItemCount(m_hdsaPictures))) &&
            SHGetSpecialFolderPath(NULL, szDir, CSIDL_WINDOWS, TRUE))
        {
            PathAppend(szDir, TEXT("Web\\Wallpaper"));
            hr = _AddPaintingsFromDir(szDir);
        }

        if (m_hdsaPictures)
        {
            m_nCurrent = GetRandomInt(0, max(0, DSA_GetItemCount(m_hdsaPictures) - 1));
        }
    }

    return hr;
}


HRESULT CPictureManager::_LoadTexture(SSPICTURE_INFO * pInfo, BOOL fFaultInTexture)
{
    // We keep trying until we hit the end.  We give up after that.
    HRESULT hr = E_INVALIDARG;

    if (pInfo)
    {
        if (!pInfo->pTexture)
        {
            pInfo->pTexture = new CTexture(m_pMain, pInfo->pszPath, NULL, 1.0f);
        }

        hr = (pInfo->pTexture ? S_OK : E_OUTOFMEMORY);

        if (pInfo->pTexture && fFaultInTexture)
        {
            pInfo->pTexture->GetTexture(NULL);  // Force the image to be paged in.
        }
    }

    return hr;
}


#define GNPF_NONE           0x00000000
#define GNPF_ALREADYLOADED  0x00000001
#define GNPF_FAULTINTEXTURE 0x00000002
#define GNPF_ALLOWALREADYINBATCH 0x00000004

HRESULT CPictureManager::_TryGetNextPainting(SSPICTURE_INFO ** ppInfo, DWORD dwFlags)
{
    // We keep trying until we hit the end.  We give up after that.
    HRESULT hr = E_FAIL;

    while (m_hdsaPictures &&
            FAILED(hr) && (m_nCurrent < DSA_GetItemCount(m_hdsaPictures)))
    {
        SSPICTURE_INFO * pPInfo = (SSPICTURE_INFO *) DSA_GetItemPtr(m_hdsaPictures, m_nCurrent);

        if (pPInfo && pPInfo->pszPath)
        {
            if (!pPInfo->fInABatch || (dwFlags & GNPF_ALLOWALREADYINBATCH))
            {
                if (dwFlags & GNPF_ALREADYLOADED)
                {
                    if (pPInfo->pTexture && pPInfo->pTexture->IsLoadedInAnyDevice())
                    {
                        // The caller only wants an object that's already pre-fetched, and we just found one.
                        *ppInfo = pPInfo;
                        pPInfo->fInABatch = TRUE;
                        hr = S_OK;
                    }
                }
                else
                {
                    // The caller is happen to this now.  We only get this far if we failed to load it.
                    hr = _LoadTexture(pPInfo, (dwFlags & GNPF_FAULTINTEXTURE));
                    if (SUCCEEDED(hr))
                    {
                        *ppInfo = pPInfo;
                        pPInfo->fInABatch = TRUE;
                    }
                }
            }
        }

        m_nCurrent++;
    }

    return hr;
}


HRESULT CPictureManager::_GetNextWithWrap(SSPICTURE_INFO ** ppInfo, BOOL fAlreadyLoaded, BOOL fFaultInTexture)
{
    DWORD dwFlags = ((fAlreadyLoaded ? GNPF_ALREADYLOADED : GNPF_NONE) | (fFaultInTexture ? GNPF_FAULTINTEXTURE : GNPF_NONE));

    *ppInfo = NULL;
    HRESULT hr = _TryGetNextPainting(ppInfo, dwFlags);

    if (m_nCurrent >= DSA_GetItemCount(m_hdsaPictures))
    {
        m_nCurrent = 0;
        if (FAILED(hr))
        {
            // Maybe it was necessary to wrap.  We don't loop to prevent infinite recursion in corner cases.
            hr = _TryGetNextPainting(ppInfo, dwFlags);
            if (FAILED(hr))
            {
                // Maybe we have so few paintings available that we need to reuse.
                m_nCurrent = 0;
                hr = _TryGetNextPainting(ppInfo, (dwFlags | GNPF_ALLOWALREADYINBATCH));
            }
        }
    }

    if (SUCCEEDED(hr) && (10 < DSA_GetItemCount(m_hdsaPictures)) &&
            (1 == GetRandomInt(0, 4)))
    {
        // There is a one in for chance we want to skip pictures.  This will keep the order somewhat random
        // while still not always going in the same order.  We only do this if the user has more than 10
        // pictures or it may lap and the user will have the same picture twice in the same room.
        m_nCurrent += GetRandomInt(1, 5);
        if (m_nCurrent >= DSA_GetItemCount(m_hdsaPictures))
        {
            m_nCurrent = 0;
        }
    }

    return hr;
}


HRESULT CPictureManager::_CreateNewBatch(int nBatch, BOOL fFaultInTexture)
{
    HRESULT hr = S_OK;
    SSPICTURES_BATCH batch = {0};
    int nIndex;

    for (nIndex = 0; (nIndex < ARRAYSIZE(batch.pInfo)) && SUCCEEDED(hr); nIndex++)
    {
        // First try and not get any dups
        hr = _GetNextWithWrap(&(batch.pInfo[nIndex]), FALSE, fFaultInTexture);
    }

    if (SUCCEEDED(hr))
    {
        if (-1 == DSA_AppendItem(m_hdsaBatches, &batch))
        {
            // We failed so free the memory
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}




///////////////////////////////////////////////////////////////////////
// FUNCTION: GetPainting
///////////////////////////////////////////////////////////////////////
HRESULT CPictureManager::GetPainting(int nBatch, int nIndex, DWORD dwFlags, CTexture ** ppTexture)
{
    HRESULT hr = E_FAIL;

    if (!m_hdsaBatches)
    {
        m_hdsaBatches = DSA_Create(sizeof(SSPICTURES_BATCH), 20);
    }

    m_nCurrentBatch = max(m_nCurrentBatch, nBatch);

    *ppTexture = NULL;
    if (m_hdsaPictures && m_hdsaBatches)
    {
        hr = S_OK;

        while ((nBatch >= DSA_GetItemCount(m_hdsaBatches)) && SUCCEEDED(hr))
        {
            hr = _CreateNewBatch(nBatch, TRUE);
        }

        if (SUCCEEDED(hr))
        {
            SSPICTURES_BATCH * pBatch = (SSPICTURES_BATCH *) DSA_GetItemPtr(m_hdsaBatches, nBatch);

            if (pBatch && ((void *)-1 != pBatch) && pBatch->pInfo[nIndex] && pBatch->pInfo[nIndex]->pTexture)
            {
                IUnknown_Set((IUnknown **) ppTexture, (IUnknown *) pBatch->pInfo[nIndex]->pTexture);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////
// FUNCTION: PreFetch
///////////////////////////////////////////////////////////////////////
HRESULT CPictureManager::PreFetch(int nBatch, int nToFetch)
{
    HRESULT hr = S_OK;

    while ((nBatch >= DSA_GetItemCount(m_hdsaBatches)) && SUCCEEDED(hr))
    {
        hr = _CreateNewBatch(nBatch, FALSE);
        if (FAILED(hr))
        {
            DXUtil_Trace(TEXT("ERROR: PreFetch() _CreateNewBatch failed.  nBatch=%d\n"), nBatch);
        }
    }

    SSPICTURES_BATCH * pBatch = (SSPICTURES_BATCH *) DSA_GetItemPtr(m_hdsaBatches, nBatch);

    if (pBatch && (nToFetch < ARRAYSIZE(pBatch->pInfo)))
    {
        int nIndex;

        for (nIndex = 0; (nIndex < ARRAYSIZE(pBatch->pInfo)) && nToFetch; nIndex++)
        {
            if (pBatch->pInfo[nIndex] && 
                (!pBatch->pInfo[nIndex]->pTexture ||
                 !pBatch->pInfo[nIndex]->pTexture->IsLoadedForThisDevice()))
            {
                hr = _LoadTexture(pBatch->pInfo[nIndex], TRUE);

                nToFetch--;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////
// FUNCTION: ReleaseBatch
///////////////////////////////////////////////////////////////////////
HRESULT CPictureManager::ReleaseBatch(int nBatch)
{
    HRESULT hr = E_INVALIDARG;

    for (int nIndex = 0; nIndex < nBatch; nIndex++)
    {
        SSPICTURES_BATCH * pBatch = (SSPICTURES_BATCH *) DSA_GetItemPtr(m_hdsaBatches, nIndex);

        for (int nIndex2 = 0; nIndex2 < ARRAYSIZE(pBatch->pInfo); nIndex2++)
        {
            if (pBatch && pBatch->pInfo[nIndex2] && (pBatch->pInfo[nIndex2]->fInABatch || pBatch->pInfo[nIndex2]->pTexture))
            {
                ReleaseBatch(nIndex);
                DXUtil_Trace(TEXT("ERROR: ReleaseBatch() and previous batch aren't released.  nBatch=%d, nIndex=%d\n"), nBatch, nIndex);
                break;
            }
        }
    }

    if (nBatch < m_nCurrentBatch)
    {
        SSPICTURES_BATCH * pBatch = (SSPICTURES_BATCH *) DSA_GetItemPtr(m_hdsaBatches, nBatch);

        if (pBatch && ((void *)-1 != pBatch))
        {
            hr = S_OK;
            for (int nIndex = 0; (nIndex < ARRAYSIZE(pBatch->pInfo)); nIndex++)
            {
                if (pBatch->pInfo[nIndex])
                {
                    SAFE_RELEASE(pBatch->pInfo[nIndex]->pTexture);
                    pBatch->pInfo[nIndex]->fInABatch = FALSE;
                    pBatch->pInfo[nIndex] = NULL;
                }
            }
        }
    }
    else
    {
        DXUtil_Trace(TEXT("ERROR: ReleaseBatch() and batch is bad.  nBatch=%d, m_nCurrentBatch=%d\n"), nBatch, m_nCurrentBatch);
        hr = E_UNEXPECTED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__706F9FE5_FCA6_11D2_A4B0_005004208000__INCLUDED_)
#define AFX_STDAFX_H__706F9FE5_FCA6_11D2_A4B0_005004208000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN       // Exclude rarely-used stuff from Windows headers
//#define STRICT
#define D3D_OVERLOADS




#include <windows.h>
#include <windowsx.h>

#undef __IShellFolder2_FWD_DEFINED__
#include <shlobj.h>
#include <shlwapi.h>

#include <mmsystem.h>
#include <math.h>
#include <time.h>


#include <d3d8.h>
#include <d3dx8.h>

#include <d3dsaver.h>
#include <d3d8rgbrast.h>
#include <util.h>
#include <..\D3DSaver\dxutil.h>



// Only use this feature if it speeds us up.
//#define FEATUER_USEVISIBILITY_CHECKING

#include "texture.h"




#endif // !defined(AFX_STDAFX_H__706F9FE5_FCA6_11D2_A4B0_005004208000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\texture.h ===
/*****************************************************************************\
    FILE: texture.h

    DESCRIPTION:
        Manage a texture for several instance for each monitor.  Also manage keeping the
    ratio correct when it's not square when loaded.

    BryanSt 2/9/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef TEXTURE_H
#define TEXTURE_H


#include "util.h"
#include "main.h"
#include "config.h"

extern int g_nTotalTexturesLoaded;
extern int g_nTexturesRenderedInThisFrame;

class CTexture                 : public IUnknown
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);


    // Member Functions
    IDirect3DTexture8 * GetTexture(float * pfScale = NULL);
    DWORD GetTextureWidth(void) {GetTexture(); return m_dxImageInfo.Width;}
    DWORD GetTextureHeight(void) {GetTexture(); return m_dxImageInfo.Height;}
    float GetScale(void) {GetTexture(); return m_fScale;}
    float GetSurfaceRatio(void) {GetTexture(); return 1.0f; /*(((float) m_dxImageInfo.Height) / ((float) m_dxImageInfo.Width));*/}

    BOOL IsLoadedInAnyDevice(void);
    BOOL IsLoadedForThisDevice(void);

    CTexture(CMSLogoDXScreenSaver * pMain, LPCTSTR pszPath, LPVOID pvBits, DWORD cbSize);
    CTexture(CMSLogoDXScreenSaver * pMain, LPCTSTR pszPath, LPCTSTR pszResource, float fScale);

    LPTSTR m_pszPath;

private:
    // Helper Functions
    void _Init(CMSLogoDXScreenSaver * pMain);
    HRESULT _GetPictureInfo(HRESULT hr, LPTSTR pszString, DWORD cchSize);
    BOOL _DoesImageNeedClipping(int * pnNewWidth, int * pnNewHeight);

    virtual ~CTexture();


    // Private Member Variables
    long                    m_cRef;

    // Member Variables
    IDirect3DTexture8 * m_pTexture[10];
    LPTSTR m_pszResource;
    LPVOID m_pvBits;          // The background thread will load the image into these bits.  The forground thread needs to create the interface.
    DWORD m_cbSize;           // The number of bytes in pvBits
    float m_fScale;           // The scale value.
    D3DXIMAGE_INFO m_dxImageInfo;

    CMSLogoDXScreenSaver * m_pMain;         // Weak reference
};



#endif // TEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\texture.cpp ===
/*****************************************************************************\
    FILE: texture.cpp

    DESCRIPTION:
        Manage a texture for several instance for each monitor.  Also manage keeping the
    ratio correct when it's not square when loaded.

    BryanSt 2/9/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"

#include "texture.h"
#include "util.h"


int g_nTotalTexturesLoaded = 0;
int g_nTexturesRenderedInThisFrame = 0;


CTexture::CTexture(CMSLogoDXScreenSaver * pMain, LPCTSTR pszPath, LPVOID pvBits, DWORD cbSize)
{
    _Init(pMain);

    Str_SetPtr(&m_pszPath, pszPath);
    m_pvBits = pvBits;
    m_cbSize = cbSize;
}


CTexture::CTexture(CMSLogoDXScreenSaver * pMain, LPCTSTR pszPath, LPCTSTR pszResource, float fScale)
{
    _Init(pMain);
    Str_SetPtr(&m_pszPath, pszPath);
    Str_SetPtr(&m_pszResource, pszResource);
    m_fScale = fScale;
}


CTexture::~CTexture()
{
    Str_SetPtr(&m_pszResource, NULL);
    Str_SetPtr(&m_pszPath, NULL);
    if (m_pvBits)
    {
        LocalFree(m_pvBits);
        m_pvBits = NULL;
        m_cbSize = 0;
    }

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pTexture); nIndex++)
    {
        if (m_pTexture[nIndex])
        {
            SAFE_RELEASE(m_pTexture[nIndex]);
            g_nTotalTexturesLoaded--;
        }
    }

    m_pMain = NULL;
}


void CTexture::_Init(CMSLogoDXScreenSaver * pMain)
{
    m_pszResource = NULL;
    m_fScale = 1.0f;
    m_pszPath = NULL;
    m_pvBits = NULL;
    m_cbSize = 0;

    m_dxImageInfo.Width = 0;
    m_dxImageInfo.Height = 0;
    m_dxImageInfo.Depth = 0;
    m_dxImageInfo.MipLevels = 0;
    m_dxImageInfo.Format = D3DFMT_UNKNOWN;

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pTexture); nIndex++)
    {
        m_pTexture[nIndex] = NULL;
    }

    m_cRef = 1;
    m_pMain = pMain;
}


BOOL CTexture::IsLoadedInAnyDevice(void)
{
    BOOL fIsLoaded = FALSE;

    for (int nIndex = 0; nIndex < ARRAYSIZE(m_pTexture); nIndex++)
    {
        if (m_pTexture[nIndex])
        {
            fIsLoaded = TRUE;
            break;
        }
    }

    return fIsLoaded;
}


BOOL CTexture::IsLoadedForThisDevice(void)
{
    BOOL fIsLoaded = FALSE;

    if (m_pMain)
    {
        int nCurrMonitor = m_pMain->GetCurrMonitorIndex();

        if (m_pTexture[nCurrMonitor])
        {
            fIsLoaded = TRUE;
        }
    }

    return fIsLoaded;
}


HRESULT CTexture::_GetPictureInfo(HRESULT hr, LPTSTR pszString, DWORD cchSize)
{
    int nCurrMonitor = m_pMain->GetCurrMonitorIndex();

    StrCpyN(pszString, TEXT("<NoInfo>"), cchSize);
    if (SUCCEEDED(hr) && m_pTexture[nCurrMonitor] && m_pMain)
    {
        D3DSURFACE_DESC d3dSurfaceDesc;

        if (SUCCEEDED(m_pTexture[nCurrMonitor]->GetLevelDesc(0, &d3dSurfaceDesc)))
        {
            wnsprintf(pszString, cchSize, TEXT("Size Orig=<%d,%d> Now=<%d,%d>"), 
                    m_dxImageInfo.Width, m_dxImageInfo.Height, d3dSurfaceDesc.Width, d3dSurfaceDesc.Height);
        }
    }

    return S_OK;
}


BOOL CTexture::_DoesImageNeedClipping(int * pnNewWidth, int * pnNewHeight)
{
    BOOL fClip = FALSE;

    *pnNewWidth = 512;
    *pnNewHeight = 512;
    if (m_pMain)
    {
        int nScreenWidth;
        int nScreenHeight;
        int nCurrMonitor = m_pMain->GetCurrMonitorIndex();
        D3DSURFACE_DESC d3dSurfaceDesc;

        if (FAILED(m_pMain->GetCurrentScreenSize(&nScreenWidth, &nScreenHeight)))
        {
            nScreenWidth = 800; // Fall back values
            nScreenHeight = 600;
        }

        if (!m_pTexture[nCurrMonitor] ||
            FAILED(m_pTexture[nCurrMonitor]->GetLevelDesc(0, &d3dSurfaceDesc)))
        {
            d3dSurfaceDesc.Width = 800;  // default values
            d3dSurfaceDesc.Height = 800;  // default values
        }

        int nCapWidth = 256;
        int nCapHeight = 256;

        if (d3dSurfaceDesc.Width > 256)
        {
            if (d3dSurfaceDesc.Width > 300)
            {
                nCapWidth = 512;

                if (d3dSurfaceDesc.Width > 512)
                {
                    if (d3dSurfaceDesc.Width > 640)     // 615 is 20% larger than 512
                    {
                        nCapWidth = 1024;
                        if (d3dSurfaceDesc.Width > 1024)     // 615 is 20% larger than 512
                        {
                            fClip = TRUE;       // We don't want it any larger than this
                        }
                    }
                    else
                    {
                        fClip = TRUE;       // We are forcing it down to 512
                    }
                }
            }
            else
            {
                fClip = TRUE;       // We are forcing it down to 256
            }
        }

        if (d3dSurfaceDesc.Height > 256)
        {
            if (d3dSurfaceDesc.Height > 300)
            {
                nCapHeight = 512;

                if (d3dSurfaceDesc.Height > 512)
                {
                    if (d3dSurfaceDesc.Height > 640)     // 615 is 20% larger than 512
                    {
                        nCapHeight = 1024;
                        if (d3dSurfaceDesc.Height > 1024)     // 615 is 20% larger than 512
                        {
                            fClip = TRUE;       // We don't want it any larger than this
                        }
                    }
                    else
                    {
                        fClip = TRUE;       // We are forcing it down to 512
                    }
                }
            }
            else
            {
                fClip = TRUE;       // We are forcing it down to 256
            }
        }

        if ((FALSE == fClip) && m_pMain->UseSmallImages())
        {
            // The caller wants to make sure we don't use anything larger than 512.
            if (512 < nCapHeight)
            {
                nCapHeight = 512;
                fClip = TRUE;
            }

            if (512 < nCapWidth)
            {
                nCapWidth = 512;
                fClip = TRUE;
            }
        }

        *pnNewWidth = nCapWidth;
        *pnNewHeight = nCapHeight;
    }

    return fClip;
}

IDirect3DTexture8 * CTexture::GetTexture(float * pfScale)
{
    IDirect3DTexture8 * pTexture = NULL;
    HRESULT hr = E_FAIL;
    TCHAR szPictureInfo[MAX_PATH];

    if (pfScale)
    {
        *pfScale = m_fScale;
    }

    // PERF NOTES: Often the background thread will only spend 107ms to load the file (ReadFile)
    // but it will take the forground thread 694ms in D3DXCreateTextureFromFileInMemoryEx to
    // load and decode the file.  This is because more memory is needed after the file is finished
    // being compressed and it takes a while to decompress.  After this, if the image is too large,
    // it will need to call D3DXCreateTextureFromFileInMemoryEx in order to load it into a smaller
    // size, which will take 902ms.
    // TODO: How should we solve this?
    if (m_pMain)
    {
        int nCurrMonitor = m_pMain->GetCurrMonitorIndex();

        pTexture = m_pTexture[nCurrMonitor];
        if (!pTexture)          // Cache is empty, so populate it.
        {
            if (m_pvBits)
            {
                DebugStartWatch();
                hr = D3DXCreateTextureFromFileInMemoryEx(m_pMain->GetD3DDevice(), m_pvBits, m_cbSize, 
                    D3DX_DEFAULT /* Size X*/, D3DX_DEFAULT /* Size Y*/, 5/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                    D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                    &(m_pTexture[nCurrMonitor]));
                _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                DXUtil_Trace(TEXT("PICTURE: It took %d ms for D3DXCreateTextureFromFileInMemoryEx(\"%ls\").  %s  hr=%#08lx\n"), DebugStopWatch(), m_pszPath, szPictureInfo, hr);
                if (SUCCEEDED(hr))
                {
                    int nNewWidth;
                    int nNewHeight;

                    g_nTotalTexturesLoaded++;

                    // In order to save memory, we never want to load images over 800x600.  If the render surface is small, we want to use
                    // even smaller max sizes.
                    if (_DoesImageNeedClipping(&nNewWidth, &nNewHeight))
                    {
                        SAFE_RELEASE(m_pTexture[nCurrMonitor]);
                        g_nTotalTexturesLoaded--;

                        DebugStartWatch();
                        // Now we found that we want to re-render the image, but this time shrink it, then we do that now.
                        hr = D3DXCreateTextureFromFileInMemoryEx(m_pMain->GetD3DDevice(), m_pvBits, m_cbSize, 
                            nNewWidth /* Size X*/, nNewHeight /* Size Y*/, 5/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                            D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                            &(m_pTexture[nCurrMonitor]));
                        _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                        DXUtil_Trace(TEXT("PICTURE: It took %d ms for D3DXCreateTextureFromFileInMemoryEx(\"%ls\") 2nd time.  %s  hr=%#08lx\n"), DebugStopWatch(), m_pszPath, szPictureInfo, hr);

                        if (SUCCEEDED(hr))
                        {
                            g_nTotalTexturesLoaded++;
                        }
                    }
                }
            }
            else
            {
                // This will give people a chance to customize the images.
                if (m_pszPath && PathFileExists(m_pszPath))
                {
                    int nOrigX;
                    int nOrigY;

                    DebugStartWatch();
                    hr = D3DXCreateTextureFromFileEx(m_pMain->GetD3DDevice(), m_pszPath, 
                        D3DX_DEFAULT /* Size X*/, D3DX_DEFAULT /* Size Y*/, 5/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                        D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                        &(m_pTexture[nCurrMonitor]));
                    _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                    DXUtil_Trace(TEXT("PICTURE: It took %d ms for FromFileEx(\"%ls\").  %s hr=%#08lx\n"), 
                                DebugStopWatch(), (PathFindFileName(m_pszPath) ? PathFindFileName(m_pszPath) : m_pszPath), szPictureInfo, hr);
                    if (SUCCEEDED(hr))
                    {
                        int nNewWidth;
                        int nNewHeight;

                        g_nTotalTexturesLoaded++;

                        // In order to save memory, we never want to load images over 800x600.  If the render surface is small, we want to use
                        // even smaller max sizes.
                        if (_DoesImageNeedClipping(&nNewWidth, &nNewHeight))
                        {
                            SAFE_RELEASE(m_pTexture[nCurrMonitor]);
                            g_nTotalTexturesLoaded--;

                            DebugStartWatch();
                            // Now we found that we want to re-render the image, but this time shrink it, then we do that now.
                            hr = D3DXCreateTextureFromFileEx(m_pMain->GetD3DDevice(), m_pszPath, 
                                nNewWidth /* Size X*/, nNewHeight /* Size Y*/, 5/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                                D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                                &(m_pTexture[nCurrMonitor]));
                            _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                            DXUtil_Trace(TEXT("PICTURE: It took %d ms for FromFileEx(\"%ls\") 2nd time. %s  hr=%#08lx\n"), 
                                    DebugStopWatch(), (PathFindFileName(m_pszPath) ? PathFindFileName(m_pszPath) : m_pszPath), szPictureInfo, hr);

                            if (SUCCEEDED(hr))
                            {
                                g_nTotalTexturesLoaded++;
                            }
                        }
                    }
                    else
                    {
                        // We failed to load the picture, so it may be a type we don't support,
                        // like .gif.  So stop trying to load it.
                        Str_SetPtr(&m_pszPath, NULL);
                    }
                }

                if (FAILED(hr) && m_pszResource)
                {
                    // Now, let's grab our standard value.
                    int nMipLevels = 5;

                    DebugStartWatch();
                    hr = D3DXCreateTextureFromResourceEx(m_pMain->GetD3DDevice(), HINST_THISDLL, m_pszResource, 
                        D3DX_DEFAULT /* Size X*/, D3DX_DEFAULT /* Size Y*/, nMipLevels/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                        D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                        &(m_pTexture[nCurrMonitor]));
                    _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                    DXUtil_Trace(TEXT("PICTURE: It took %d ms for D3DXCreateTextureFromResourceEx(\"%ls\").  %s  hr=%#08lx\n"), DebugStopWatch(), m_pszResource, szPictureInfo, hr);
                    if (SUCCEEDED(hr))
                    {
                        int nNewWidth;
                        int nNewHeight;

                        g_nTotalTexturesLoaded++;

                        // In order to save memory, we never want to load images over 800x600.  If the render surface is small, we want to use
                        // even smaller max sizes.
                        if (_DoesImageNeedClipping(&nNewWidth, &nNewHeight))
                        {
                            SAFE_RELEASE(m_pTexture[nCurrMonitor]);
                            g_nTotalTexturesLoaded--;

                            DebugStartWatch();
                            // Now we found that we want to re-render the image, but this time shrink it, then we do that now.
                            hr = D3DXCreateTextureFromResourceEx(m_pMain->GetD3DDevice(), HINST_THISDLL, m_pszResource, 
                                nNewWidth /* Size X*/, nNewHeight /* Size Y*/, 5/*MIP Levels*/, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_FILTER_LINEAR, 
                                D3DX_FILTER_BOX, 0, &m_dxImageInfo, NULL,
                                &(m_pTexture[nCurrMonitor]));
                            _GetPictureInfo(hr, szPictureInfo, ARRAYSIZE(szPictureInfo));
                            DXUtil_Trace(TEXT("PICTURE: It took %d ms for D3DXCreateTextureFromResourceEx(\"%ls\") 2nd time.  %s  hr=%#08lx\n"), DebugStopWatch(), m_pszResource, szPictureInfo, hr);

                            if (SUCCEEDED(hr))
                            {
                                g_nTotalTexturesLoaded++;
                            }
                        }
                    }
                    else
                    {
                        // We failed to load the picture, so it may be a type we don't support,
                        // like .gif.  So stop trying to load it.
                        Str_SetPtr(&m_pszPath, NULL);
                    }
                }
            }

            pTexture = m_pTexture[nCurrMonitor];
        }
    }

    return pTexture;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CTexture::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


ULONG CTexture::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


HRESULT CTexture::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CTexture, IUnknown),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\util.cpp ===
/*****************************************************************************\
    FILE: util.cpp

    DESCRIPTION:

    BryanSt 12/22/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#include "stdafx.h"
#include "..\\d3dsaver\\dxutil.h"

#define SECURITY_WIN32
#include <sspi.h>
extern "C" {
    #include <Secext.h>     // for GetUserNameEx()
}


// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "MSMUSEUM"
#define SZ_MODULE           "MSMUSEUM"
#define DECLARE_DEBUG


#undef __IShellFolder2_FWD_DEFINED__
#include <ccstock.h>
#include <debug.h>

#include "util.h"


BOOL g_fOverheadViewTest = FALSE;


#ifdef DEBUG
DWORD g_TLSliStopWatchStartHi = 0xFFFFFFFF;
DWORD g_TLSliStopWatchStartLo = 0xFFFFFFFF;
LARGE_INTEGER g_liStopWatchFreq = {0};
#endif // DEBUG


/////////////////////////////////////////////////////////////////////
// Debug Timing Helpers
/////////////////////////////////////////////////////////////////////

#ifdef DEBUG
void DebugStartWatch(void)
{
    LARGE_INTEGER liStopWatchStart;

    if (-1 == g_TLSliStopWatchStartHi)
    {
        g_TLSliStopWatchStartHi = TlsAlloc();
        g_TLSliStopWatchStartLo = TlsAlloc();
        liStopWatchStart.QuadPart = 0;

        QueryPerformanceFrequency(&g_liStopWatchFreq);      // Only a one time call since it's value can't change while the system is running.
    }
    else
    {
        liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
        liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    }

    QueryPerformanceCounter(&liStopWatchStart);

    TlsSetValue(g_TLSliStopWatchStartHi, IntToPtr(liStopWatchStart.HighPart));
    TlsSetValue(g_TLSliStopWatchStartLo, IntToPtr(liStopWatchStart.LowPart));
}

DWORD DebugStopWatch(void)
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liStopWatchStart;
    
    QueryPerformanceCounter(&liDiff);
    liStopWatchStart.HighPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartHi));
    liStopWatchStart.LowPart = PtrToUlong(TlsGetValue(g_TLSliStopWatchStartLo));
    liDiff.QuadPart -= liStopWatchStart.QuadPart;

    DWORD dwTime = (DWORD)((liDiff.QuadPart * 1000) / g_liStopWatchFreq.QuadPart);

    TlsSetValue(g_TLSliStopWatchStartHi, (LPVOID) 0);
    TlsSetValue(g_TLSliStopWatchStartLo, (LPVOID) 0);

    return dwTime;
}
#else // DEBUG

void DebugStartWatch(void)
{
}

DWORD DebugStopWatch(void)
{
    return 0;
}
#endif // DEBUG






float rnd(void)
{
    return (((FLOAT)rand() ) / RAND_MAX);
}

int GetRandomInt(int nMin, int nMax)
{
    int nDelta = (nMax - nMin + 1);
    float fRandom = (((float) rand()) / ((float) RAND_MAX));
    float fDelta = (fRandom * nDelta);

    int nAmount = (int)(fDelta);
    nAmount = min(nAmount, nDelta - 1);

    return (nMin + nAmount);
}


HRESULT SetBoxStripVertexes(MYVERTEX * ppvVertexs, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal)
{
    HRESULT hr = S_OK;
    float fTextureScale = 1.0f;     // How many repeats per 1 unit.

    // Draw Object
    if (vNormal.x)        // The object is in the y-z plane
    {
        ppvVertexs[0] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y, vLocation.z), vNormal, 0, fTextureScale);
        ppvVertexs[1] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y + vSize.y, vLocation.z), vNormal, 0, 0);
        ppvVertexs[2] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y, vLocation.z + vSize.z), vNormal, fTextureScale, fTextureScale);
        ppvVertexs[3] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y + vSize.y, vLocation.z + vSize.z), vNormal, fTextureScale, 0);
    }
    else if (vNormal.y)        // The object is in the x-z plane
    {
        ppvVertexs[0] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y, vLocation.z), vNormal, 0, fTextureScale);
        ppvVertexs[1] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y, vLocation.z + vSize.z), vNormal, 0, 0);
        ppvVertexs[2] = MYVERTEX(D3DXVECTOR3(vLocation.x + vSize.x, vLocation.y, vLocation.z), vNormal, fTextureScale, fTextureScale);
        ppvVertexs[3] = MYVERTEX(D3DXVECTOR3(vLocation.x + vSize.x, vLocation.y, vLocation.z + vSize.z), vNormal, fTextureScale, 0);
    }
    else
    {           // The object is in the x-y plane
        ppvVertexs[0] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y, vLocation.z), vNormal, 0, fTextureScale);
        ppvVertexs[1] = MYVERTEX(D3DXVECTOR3(vLocation.x, vLocation.y + vSize.y, vLocation.z), vNormal, 0, 0);
        ppvVertexs[2] = MYVERTEX(D3DXVECTOR3(vLocation.x + vSize.x, vLocation.y, vLocation.z), vNormal, fTextureScale, fTextureScale);
        ppvVertexs[3] = MYVERTEX(D3DXVECTOR3(vLocation.x + vSize.x, vLocation.y + vSize.y, vLocation.z), vNormal, fTextureScale, 0);
    }

    return hr;
}


float AddVectorComponents(D3DXVECTOR3 vDir)
{
    return (vDir.x + vDir.y + vDir.z);
}


int CALLBACK DPALocalFree_Callback(LPVOID p, LPVOID pData)
{
    LocalFree(p);       // NULLs will be ignored.
    return 1;
}


int CALLBACK DPAStrCompare(void * pv1, void * pv2, LPARAM lParam)
{
    LPCTSTR pszSearch = (LPCTSTR) pv1;
    LPCTSTR pszCurrent = (LPCTSTR) pv2;

    if (pszSearch && pszCurrent &&
        !StrCmpI(pszSearch, pszCurrent))
    {
        return 0;       // They match
    }

    return 1;
}


float GetSurfaceRatio(IDirect3DTexture8 * pTexture)
{
    float fX = 1.0f;
    float fY = 1.0f;

    if (pTexture)
    {
        D3DSURFACE_DESC desc;

        if (SUCCEEDED(pTexture->GetLevelDesc(0, &desc)))
        {
            fX = (float) desc.Width;
            fY = (float) desc.Height;
        }
    }

    if (0.0f == fX)
    {
        fX = 1.0f;      // Protect from zero divides
    }
    
    return (fY / fX);
}


int GetTextureHeight(IDirect3DTexture8 * pTexture)
{
    int nHeight = 0;

    if (pTexture)
    {
        D3DSURFACE_DESC desc;

        if (SUCCEEDED(pTexture->GetLevelDesc(0, &desc)))
        {
            nHeight = desc.Height;
        }
    }

    return nHeight;
}


int GetTextureWidth(IDirect3DTexture8 * pTexture)
{
    int nWidth = 0;

    if (pTexture)
    {
        D3DSURFACE_DESC desc;

        if (SUCCEEDED(pTexture->GetLevelDesc(0, &desc)))
        {
            nWidth = desc.Width;
        }
    }

    return nWidth;
}





/////////////////////////////////////////////////////////////////////
// Registry Helpers
/////////////////////////////////////////////////////////////////////
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
    DWORD dwError = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
    DWORD dwError = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrSHGetValue(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, OPTIONAL OUT LPDWORD pdwType,
                    OPTIONAL OUT LPVOID pvData, OPTIONAL OUT LPDWORD pcbData)
{
    DWORD dwError = SHGetValue(hKey, pszSubKey, pszValue, pdwType, pvData, pcbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrSHSetValue(IN HKEY hkey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwType, OPTIONAL OUT LPVOID pvData, IN DWORD cbData)
{
    DWORD dwError = SHSetValue(hkey, pszSubKey, pszValue, dwType, pvData, cbData);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT HrRegSetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, OUT LPCWSTR pszString)
{
    DWORD cbSize = ((lstrlenW(pszString) + 1) * sizeof(pszString[0]));

    return  HrSHSetValue(hKey, pszSubKey, pszValueName, REG_SZ, (BYTE *)pszString, cbSize);
}


HRESULT HrRegGetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, IN LPWSTR pszString, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszString[0]));

    HRESULT hr = HrSHGetValue(hKey, pszSubKey, pszValueName, &dwType, (BYTE *)pszString, &cbSize);
    if (SUCCEEDED(hr) && (REG_SZ != dwType))
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT HrRegGetDWORD(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, LPDWORD pdwValue, DWORD dwDefaultValue)
{
    DWORD dwType;
    DWORD cbSize = sizeof(*pdwValue);

    HRESULT hr = HrSHGetValue(hKey, pszSubKey, pszValue, &dwType, (void *) pdwValue, &cbSize);
    if (FAILED(hr))
    {
        *pdwValue = dwDefaultValue;
        hr = S_OK;
    }

    return hr;
}


HRESULT HrRegSetDWORD(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwValue)
{
    return HrSHSetValue(hKey, pszSubKey, pszValue, REG_DWORD, (void *) &dwValue, sizeof(dwValue));
}




// UI Wrappers
void SetCheckBox(HWND hwndDlg, UINT idControl, BOOL fChecked)
{
    SendMessage((HWND)GetDlgItem(hwndDlg, idControl), BM_SETCHECK, (WPARAM)fChecked, 0);
}


BOOL GetCheckBox(HWND hwndDlg, UINT idControl)
{
    return (BST_CHECKED == SendMessage((HWND)GetDlgItem(hwndDlg, idControl), BM_GETCHECK, 0, 0));
}


HRESULT ShellFolderParsePath(LPCWSTR pszPath, LPITEMIDLIST * ppidl)
{
    IShellFolder * psf;
    HRESULT hr = SHGetDesktopFolder(&psf);

    if (SUCCEEDED(hr))
    {
        hr = psf->ParseDisplayName(NULL, NULL, (LPOLESTR) pszPath, NULL, ppidl, NULL);
        psf->Release();
    }

    return hr;
}


HRESULT ShellFolderGetPath(LPCITEMIDLIST pidl, LPWSTR pszPath, DWORD cchSize)
{
    IShellFolder * psf;
    HRESULT hr = SHGetDesktopFolder(&psf);

    if (SUCCEEDED(hr))
    {
        IShellFolder * psfFolder;
        LPITEMIDLIST pidlParent = ILCloneParent(pidl);

        if (pidlParent) 
        {
            hr = psf->BindToObject(pidlParent, NULL, IID_IShellFolder, (void **) &psfFolder);
            if (SUCCEEDED(hr))
            {
                STRRET strRet = {0};
                LPITEMIDLIST pidlLast = ILFindLastID(pidl);

                hr = psfFolder->GetDisplayNameOf(pidlLast, (SHGDN_NORMAL | SHGDN_FORPARSING), &strRet);
                if (SUCCEEDED(hr))
                {
                    hr = StrRetToBuf(&strRet, pidlLast, pszPath, cchSize);
                }
                psfFolder->Release();
            }

            ILFree(pidlParent);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        psf->Release();
    }

    return hr;
}


BOOL PathDeleteDirectoryRecursively(LPCTSTR pszDir)
{
    BOOL fReturn = FALSE;
    HANDLE hFind;
    WIN32_FIND_DATA wfd;
    TCHAR szTemp[MAX_PATH];

    StrCpyN(szTemp, pszDir, ARRAYSIZE(szTemp));
    PathAppend(szTemp, TEXT("*.*"));
    hFind = FindFirstFile(szTemp, &wfd);

    if (INVALID_HANDLE_VALUE != hFind)
    {
        do
        {
            if (!PathIsDotOrDotDot(wfd.cFileName))
            {
                // build the path of the directory or file found
                StrCpyN(szTemp, pszDir, ARRAYSIZE(szTemp));
                PathAppend(szTemp, wfd.cFileName);

                if (FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes)
                {
                    // We found a directory - call this function recursively
                    // Note that since we use recursion, this can only go so far
                    // before it blows the stack.  If you plan on going into deep
                    // directories, put szTemp above on the heap.
                    fReturn = PathDeleteDirectoryRecursively(szTemp);
                }
                else
                {
                    DeleteFile(szTemp);
                }
            }
        }
        while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }

    fReturn = RemoveDirectory(pszDir);

    return fReturn;
}


ULONGLONG PathGetFileSize(LPCTSTR pszPath)
{
    ULONGLONG ullResult = 0;
    HANDLE hFile = CreateFile(pszPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        LARGE_INTEGER liFileSize;

        if (GetFileSizeEx(hFile, &liFileSize))
        {
            ullResult = liFileSize.QuadPart;
        }

        CloseHandle(hFile);
    }

    return ullResult;
}


void PrintLocation(LPTSTR pszTemplate, D3DXVECTOR3 vLoc, D3DXVECTOR3 vTangent)
{
    TCHAR szOut[1024];
    TCHAR szVector1[90];
    TCHAR szVector2[90];
    TCHAR szFloat1[20];
    TCHAR szFloat2[20];
    TCHAR szFloat3[20];

    FloatToString(vLoc.x, 4, szFloat1, ARRAYSIZE(szFloat1));
    FloatToString(vLoc.y, 4, szFloat2, ARRAYSIZE(szFloat2));
    FloatToString(vLoc.z, 4, szFloat3, ARRAYSIZE(szFloat3));
    wnsprintf(szVector1, ARRAYSIZE(szVector1), TEXT("<%s, %s, %s>"), szFloat1, szFloat2, szFloat3);

    FloatToString(vTangent.x, 4, szFloat1, ARRAYSIZE(szFloat1));
    FloatToString(vTangent.y, 4, szFloat2, ARRAYSIZE(szFloat2));
    FloatToString(vTangent.z, 4, szFloat3, ARRAYSIZE(szFloat3));
    wnsprintf(szVector2, ARRAYSIZE(szVector2), TEXT("<%s, %s, %s>\n"), szFloat1, szFloat2, szFloat3);

    wnsprintf(szOut, ARRAYSIZE(szOut), pszTemplate, szVector1, szVector2);
    DXUtil_Trace(szOut);
}


//-----------------------------------------------------------------------------
// Name: UpdateCullInfo()
// Desc: Sets up the frustum planes, endpoints, and center for the frustum
//       defined by a given view matrix and projection matrix.  This info will 
//       be used when culling each object in CullObject().
//-----------------------------------------------------------------------------
VOID UpdateCullInfo( CULLINFO* pCullInfo, D3DXMATRIX* pMatView, D3DXMATRIX* pMatProj )
{
    D3DXMATRIX mat;

    D3DXMatrixMultiply( &mat, pMatView, pMatProj );
    D3DXMatrixInverse( &mat, NULL, &mat );

    pCullInfo->vecFrustum[0] = D3DXVECTOR3(-1.0f, -1.0f,  0.0f); // xyz
    pCullInfo->vecFrustum[1] = D3DXVECTOR3( 1.0f, -1.0f,  0.0f); // Xyz
    pCullInfo->vecFrustum[2] = D3DXVECTOR3(-1.0f,  1.0f,  0.0f); // xYz
    pCullInfo->vecFrustum[3] = D3DXVECTOR3( 1.0f,  1.0f,  0.0f); // XYz
    pCullInfo->vecFrustum[4] = D3DXVECTOR3(-1.0f, -1.0f,  1.0f); // xyZ
    pCullInfo->vecFrustum[5] = D3DXVECTOR3( 1.0f, -1.0f,  1.0f); // XyZ
    pCullInfo->vecFrustum[6] = D3DXVECTOR3(-1.0f,  1.0f,  1.0f); // xYZ
    pCullInfo->vecFrustum[7] = D3DXVECTOR3( 1.0f,  1.0f,  1.0f); // XYZ

    pCullInfo->vecFrustumCenter = D3DXVECTOR3(0, 0, 0);
    for( INT i = 0; i < 8; i++ )
    {
        D3DXVec3TransformCoord( &pCullInfo->vecFrustum[i], &pCullInfo->vecFrustum[i], &mat );
        pCullInfo->vecFrustumCenter += pCullInfo->vecFrustum[i];
    }
    pCullInfo->vecFrustumCenter /= 8;

    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[0], &pCullInfo->vecFrustum[0], 
        &pCullInfo->vecFrustum[1], &pCullInfo->vecFrustum[2] ); // Near
    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[1], &pCullInfo->vecFrustum[6], 
        &pCullInfo->vecFrustum[7], &pCullInfo->vecFrustum[5] ); // Far
    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[2], &pCullInfo->vecFrustum[2], 
        &pCullInfo->vecFrustum[6], &pCullInfo->vecFrustum[4] ); // Left
    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[3], &pCullInfo->vecFrustum[7], 
        &pCullInfo->vecFrustum[3], &pCullInfo->vecFrustum[5] ); // Right
    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[4], &pCullInfo->vecFrustum[2], 
        &pCullInfo->vecFrustum[3], &pCullInfo->vecFrustum[6] ); // Top
    D3DXPlaneFromPoints( &pCullInfo->planeFrustum[5], &pCullInfo->vecFrustum[1], 
        &pCullInfo->vecFrustum[0], &pCullInfo->vecFrustum[4] ); // Bottom
}




//-----------------------------------------------------------------------------
// Name: CullObject()
// Desc: Determine the cullstate for an object.
//-----------------------------------------------------------------------------
CULLSTATE CullObject( CULLINFO* pCullInfo, D3DXVECTOR3* pVecBounds, 
                      D3DXPLANE* pPlaneBounds )
{
    BYTE bOutside[8];
    ZeroMemory( &bOutside, sizeof(bOutside) );

    // Check boundary vertices against all 6 frustum planes, 
    // and store result (1 if outside) in a bitfield
    for( int iPoint = 0; iPoint < 8; iPoint++ )
    {
        for( int iPlane = 0; iPlane < 6; iPlane++ )
        {
            if( pCullInfo->planeFrustum[iPlane].a * pVecBounds[iPoint].x +
                pCullInfo->planeFrustum[iPlane].b * pVecBounds[iPoint].y +
                pCullInfo->planeFrustum[iPlane].c * pVecBounds[iPoint].z +
                pCullInfo->planeFrustum[iPlane].d < 0)
            {
                bOutside[iPoint] |= (1 << iPlane);
            }
        }
        // If any point is inside all 6 frustum planes, it is inside
        // the frustum, so the object must be rendered.
        if( bOutside[iPoint] == 0 )
            return CS_INSIDE;
    }

    // If all points are outside any single frustum plane, the object is
    // outside the frustum
    if( (bOutside[0] & bOutside[1] & bOutside[2] & bOutside[3] & 
        bOutside[4] & bOutside[5] & bOutside[6] & bOutside[7]) != 0 )
    {
        return CS_OUTSIDE;
    }

    // Now see if any of the frustum edges penetrate any of the faces of
    // the bounding box
    D3DXVECTOR3 edge[12][2] = 
    {
        pCullInfo->vecFrustum[0], pCullInfo->vecFrustum[1], // front bottom
        pCullInfo->vecFrustum[2], pCullInfo->vecFrustum[3], // front top
        pCullInfo->vecFrustum[0], pCullInfo->vecFrustum[2], // front left
        pCullInfo->vecFrustum[1], pCullInfo->vecFrustum[3], // front right
        pCullInfo->vecFrustum[4], pCullInfo->vecFrustum[5], // back bottom
        pCullInfo->vecFrustum[6], pCullInfo->vecFrustum[7], // back top
        pCullInfo->vecFrustum[4], pCullInfo->vecFrustum[6], // back left
        pCullInfo->vecFrustum[5], pCullInfo->vecFrustum[7], // back right
        pCullInfo->vecFrustum[0], pCullInfo->vecFrustum[4], // left bottom
        pCullInfo->vecFrustum[2], pCullInfo->vecFrustum[6], // left top
        pCullInfo->vecFrustum[1], pCullInfo->vecFrustum[5], // right bottom
        pCullInfo->vecFrustum[3], pCullInfo->vecFrustum[7], // right top
    };
    D3DXVECTOR3 face[6][4] =
    {
        pVecBounds[0], pVecBounds[2], pVecBounds[3], pVecBounds[1], // front
        pVecBounds[4], pVecBounds[5], pVecBounds[7], pVecBounds[6], // back
        pVecBounds[0], pVecBounds[4], pVecBounds[6], pVecBounds[2], // left
        pVecBounds[1], pVecBounds[3], pVecBounds[7], pVecBounds[5], // right
        pVecBounds[2], pVecBounds[6], pVecBounds[7], pVecBounds[3], // top
        pVecBounds[0], pVecBounds[4], pVecBounds[5], pVecBounds[1], // bottom
    };
    D3DXVECTOR3* pEdge;
    D3DXVECTOR3* pFace;
    pEdge = &edge[0][0];
    for( INT iEdge = 0; iEdge < 12; iEdge++ )
    {
        pFace = &face[0][0];
        for( INT iFace = 0; iFace < 6; iFace++ )
        {
            if( EdgeIntersectsFace( pEdge, pFace, &pPlaneBounds[iFace] ) )
            {
                return CS_INSIDE_SLOW;
            }
            pFace += 4;
        }
        pEdge += 2;
    }

    // Now see if frustum is contained in bounding box
    // If the frustum center is outside any plane of the bounding box,
    // the frustum is not contained in the bounding box, so the object
    // is outside the frustum
    for( INT iPlane = 0; iPlane < 6; iPlane++ )
    {
        if( pPlaneBounds[iPlane].a * pCullInfo->vecFrustumCenter.x +
            pPlaneBounds[iPlane].b * pCullInfo->vecFrustumCenter.y +
            pPlaneBounds[iPlane].c * pCullInfo->vecFrustumCenter.z +
            pPlaneBounds[iPlane].d  < 0 )
        {
            return CS_OUTSIDE_SLOW;
        }
    }

    // Bounding box must contain the frustum, so render the object
    return CS_INSIDE_SLOW;
}




//-----------------------------------------------------------------------------
// Name: EdgeIntersectsFace()
// Desc: Determine if the edge bounded by the two vectors in pEdges intersects
//       the quadrilateral described by the four vectors in pFacePoints.  
//       Note: pPlanePoints could be derived from pFacePoints using 
//       D3DXPlaneFromPoints, but it is precomputed in advance for greater
//       speed.
//-----------------------------------------------------------------------------
BOOL EdgeIntersectsFace( D3DXVECTOR3* pEdges, D3DXVECTOR3* pFacePoints, 
                         D3DXPLANE* pPlane )
{
    // If both edge points are on the same side of the plane, the edge does
    // not intersect the face
    FLOAT fDist1;
    FLOAT fDist2;
    fDist1 = pPlane->a * pEdges[0].x + pPlane->b * pEdges[0].y +
             pPlane->c * pEdges[0].z + pPlane->d;
    fDist2 = pPlane->a * pEdges[1].x + pPlane->b * pEdges[1].y +
             pPlane->c * pEdges[1].z + pPlane->d;
    if( fDist1 > 0 && fDist2 > 0 ||
        fDist1 < 0 && fDist2 < 0 )
    {
        return FALSE;
    }

    // Find point of intersection between edge and face plane (if they're
    // parallel, edge does not intersect face and D3DXPlaneIntersectLine 
    // returns NULL)
    D3DXVECTOR3 ptIntersection;
    if( NULL == D3DXPlaneIntersectLine( &ptIntersection, pPlane, &pEdges[0], &pEdges[1] ) )
        return FALSE;

    // Project onto a 2D plane to make the pt-in-poly test easier
    FLOAT fAbsA = (pPlane->a > 0 ? pPlane->a : -pPlane->a);
    FLOAT fAbsB = (pPlane->b > 0 ? pPlane->b : -pPlane->b);
    FLOAT fAbsC = (pPlane->c > 0 ? pPlane->c : -pPlane->c);
    D3DXVECTOR2 facePoints[4];
    D3DXVECTOR2 point;
    if( fAbsA > fAbsB && fAbsA > fAbsC )
    {
        // Plane is mainly pointing along X axis, so use Y and Z
        for( INT i = 0; i < 4; i++)
        {
            facePoints[i].x = pFacePoints[i].y;
            facePoints[i].y = pFacePoints[i].z;
        }
        point.x = ptIntersection.y;
        point.y = ptIntersection.z;
    }
    else if( fAbsB > fAbsA && fAbsB > fAbsC )
    {
        // Plane is mainly pointing along Y axis, so use X and Z
        for( INT i = 0; i < 4; i++)
        {
            facePoints[i].x = pFacePoints[i].x;
            facePoints[i].y = pFacePoints[i].z;
        }
        point.x = ptIntersection.x;
        point.y = ptIntersection.z;
    }
    else
    {
        // Plane is mainly pointing along Z axis, so use X and Y
        for( INT i = 0; i < 4; i++)
        {
            facePoints[i].x = pFacePoints[i].x;
            facePoints[i].y = pFacePoints[i].y;
        }
        point.x = ptIntersection.x;
        point.y = ptIntersection.y;
    }

    // If point is on the outside of any of the face edges, it is
    // outside the face.  
    // We can do this by taking the determinant of the following matrix:
    // | x0 y0 1 |
    // | x1 y1 1 |
    // | x2 y2 1 |
    // where (x0,y0) and (x1,y1) are points on the face edge and (x2,y2) 
    // is our test point.  If this value is positive, the test point is
    // "to the left" of the line.  To determine whether a point needs to
    // be "to the right" or "to the left" of the four lines to qualify as
    // inside the face, we need to see if the faces are specified in 
    // clockwise or counter-clockwise order (it could be either, since the
    // edge could be penetrating from either side).  To determine this, we
    // do the same test to see if the third point is "to the right" or 
    // "to the left" of the line formed by the first two points.
    // See http://forum.swarthmore.edu/dr.math/problems/scott5.31.96.html
    FLOAT x0, x1, x2, y0, y1, y2;
    x0 = facePoints[0].x;
    y0 = facePoints[0].y;
    x1 = facePoints[1].x;
    y1 = facePoints[1].y;
    x2 = facePoints[2].x;
    y2 = facePoints[2].y;
    BOOL bClockwise = FALSE;
    if( x1*y2 - y1*x2 - x0*y2 + y0*x2 + x0*y1 - y0*x1 < 0 )
        bClockwise = TRUE;
    x2 = point.x;
    y2 = point.y;
    for( INT i = 0; i < 4; i++ )
    {
        x0 = facePoints[i].x;
        y0 = facePoints[i].y;
        if( i < 3 )
        {
            x1 = facePoints[i+1].x;
            y1 = facePoints[i+1].y;
        }
        else
        {
            x1 = facePoints[0].x;
            y1 = facePoints[0].y;
        }
        if( ( x1*y2 - y1*x2 - x0*y2 + y0*x2 + x0*y1 - y0*x1 > 0 ) == bClockwise )
            return FALSE;
    }

    // If we get here, the point is inside all four face edges, 
    // so it's inside the face.
    return TRUE;
}




BOOL Is3DRectViewable(CULLINFO* pCullInfo, D3DXMATRIX* pMatWorld, 
                      D3DXVECTOR3 vecMin, D3DXVECTOR3 vecMax)
{
    BOOL fViewable = TRUE;
    D3DXVECTOR3 vecBoundsLocal[8];
    D3DXVECTOR3 vecBoundsWorld[8];
    D3DXPLANE planeBoundsWorld[6];
    CULLSTATE cs;

    vecBoundsLocal[0] = D3DXVECTOR3( vecMin.x, vecMin.y, vecMin.z ); // xyz
    vecBoundsLocal[1] = D3DXVECTOR3( vecMax.x, vecMin.y, vecMin.z ); // Xyz
    vecBoundsLocal[2] = D3DXVECTOR3( vecMin.x, vecMax.y, vecMin.z ); // xYz
    vecBoundsLocal[3] = D3DXVECTOR3( vecMax.x, vecMax.y, vecMin.z ); // XYz
    vecBoundsLocal[4] = D3DXVECTOR3( vecMin.x, vecMin.y, vecMax.z ); // xyZ
    vecBoundsLocal[5] = D3DXVECTOR3( vecMax.x, vecMin.y, vecMax.z ); // XyZ
    vecBoundsLocal[6] = D3DXVECTOR3( vecMin.x, vecMax.y, vecMax.z ); // xYZ
    vecBoundsLocal[7] = D3DXVECTOR3( vecMax.x, vecMax.y, vecMax.z ); // XYZ

    for( int i = 0; i < 8; i++ )
    {
        D3DXVec3TransformCoord( &vecBoundsWorld[i], &vecBoundsLocal[i], pMatWorld );
    }

    // Determine planes of bounding box coords
    D3DXPlaneFromPoints( &planeBoundsWorld[0], &vecBoundsWorld[0], &vecBoundsWorld[1], &vecBoundsWorld[2] ); // Near
    D3DXPlaneFromPoints( &planeBoundsWorld[1], &vecBoundsWorld[6], &vecBoundsWorld[7], &vecBoundsWorld[5] ); // Far
    D3DXPlaneFromPoints( &planeBoundsWorld[2], &vecBoundsWorld[2], &vecBoundsWorld[6], &vecBoundsWorld[4] ); // Left
    D3DXPlaneFromPoints( &planeBoundsWorld[3], &vecBoundsWorld[7], &vecBoundsWorld[3], &vecBoundsWorld[5] ); // Right
    D3DXPlaneFromPoints( &planeBoundsWorld[4], &vecBoundsWorld[2], &vecBoundsWorld[3], &vecBoundsWorld[6] ); // Top
    D3DXPlaneFromPoints( &planeBoundsWorld[5], &vecBoundsWorld[1], &vecBoundsWorld[0], &vecBoundsWorld[4] ); // Bottom

    cs = CullObject( pCullInfo, vecBoundsWorld, planeBoundsWorld );

    fViewable = (cs != CS_OUTSIDE && cs != CS_OUTSIDE_SLOW);

    return fViewable;
}


HRESULT GetCurrentUserCustomName(LPWSTR pszDisplayName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    ULONG cchUserSize = cchSize;

    if (GetUserNameEx(NameDisplay, pszDisplayName, &cchUserSize))
    {
        // It succeeded, so use it.
    }
    else
    {
        // It failed, so load "My".  It's better than nothing.
        LoadString(HINST_THISDLL, IDS_LOBBY_TITLE, pszDisplayName, cchSize);
    }

    return hr;
}


D3DXVECTOR3 D3DXVec3Multiply(CONST D3DXVECTOR3 v1, CONST D3DXVECTOR3 v2)
{
    D3DXVECTOR3 vResults;

    vResults.x = (v1.x * v2.x);
    vResults.y = (v1.y * v2.y);
    vResults.z = (v1.z * v2.z);

    return vResults;
}


void FloatToString(float fValue, int nDecimalDigits, LPTSTR pszString, DWORD cchSize)
{
    int nIntValue = (int) fValue;
    float fDecimalValue = (float)((fValue - (float)nIntValue) * (pow(10, nDecimalDigits)));
    int nDecimalValue = (int) fDecimalValue;

    if (0 == nDecimalDigits)
    {
        wnsprintf(pszString, cchSize, TEXT("%d"), nIntValue);
    }
    else
    {
        wnsprintf(pszString, cchSize, TEXT("%d.%d"), nIntValue, nDecimalValue);
    }
}



///////
// Critical section helper stuff
//
#ifdef DEBUG
UINT g_CriticalSectionCount = 0;
DWORD g_CriticalSectionOwner = 0;
#ifdef STACKBACKTRACE
DBstkback g_CriticalSectionLastCall[4] = { 0 };
#endif


void Dll_EnterCriticalSection(CRITICAL_SECTION * pcsDll)
{
#ifdef STACKBACKTRACE
    int var0;       // *must* be 1st on frame
#endif

    EnterCriticalSection(pcsDll);
    if (g_CriticalSectionCount++ == 0)
    {
        g_CriticalSectionOwner = GetCurrentThreadId();
#ifdef STACKBACKTRACE
        int fp = (int) (1 + (int *)&var0);
        DBGetStackBack(&fp, g_CriticalSectionLastCall, ARRAYSIZE(g_CriticalSectionLastCall));
#endif
    }
}

void Dll_LeaveCriticalSection(CRITICAL_SECTION * pcsDll)
{
    if (--g_CriticalSectionCount == 0)
        g_CriticalSectionOwner = 0;
    LeaveCriticalSection(pcsDll);
}
#endif


#include <string.h>
#include <wchar.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\mystify\strings.h ===
#define idsDescription    1
#define idsPolygon        2
#define idsName         100

#include "..\common\comstrin.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\eval.h ===
//-----------------------------------------------------------------------------
// File: eval.h
//
// Desc: EVAL class
//       Evaluator composed of one or more sections that are evaluated
//       separately with OpenGL evaluators
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __EVAL_H__
#define __EVAL_H__

#define MAX_UORDER                      5 // this is per section
#define MAX_VORDER                      5
#define MAX_USECTIONS                   4
#define MAX_XC_PTS                      (MAX_UORDER * MAX_USECTIONS)

#define TEX_ORDER                       2
#define EVAL_ARC_ORDER                  4
#define EVAL_CYLINDER_ORDER             2
#define EVAL_ELBOW_ORDER                4

// # of components (eg. arcs) to form a complete cross-section
#define EVAL_XC_CIRC_SECTION_COUNT      4
#define EVAL_XC_POINT_COUNT             ( (EVAL_ARC_ORDER-1)*4 + 1 )
#define EVAL_CIRC_ARC_CONTROL           0.56f // for r=1




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class EVAL 
{
public:
    int             m_numSections;    // number of cross-sectional sections
    int             m_uOrder, m_vOrder;
    
    // assumed: all sections same order - uOrder is per
    // section; sections share vertex and texture control points
    int             m_uDiv, m_vDiv;    // figured out one level up ?
    D3DXVECTOR3*    m_pts;          // vertex control points

    // - texture always order 2 for s and t (linear mapping)
    BOOL            m_bTexture;
    TEX_POINT2D*    m_texPts;       // texture control points

    EVAL( BOOL bTexture );
    ~EVAL();

    void        Evaluate(); // evaluate/render the object
    void        SetVertexCtrlPtsXCTranslate( D3DXVECTOR3 *pts, float length, 
                                             XC *xcStart, XC *xcEnd );
    void        SetTextureControlPoints( float s_start, float s_end,
                                         float t_start, float t_end );
    void        ProcessXCPrimLinear( XC *xcStart, XC *xcEnd, float length );
    void        ProcessXCPrimBendSimple( XC *xcCur, int dir, float radius );
    void        ProcessXCPrimSingularity( XC *xcCur, float length, 
                                          BOOL bOpening );
};

extern void ResetEvaluator( BOOL bTexture );

#endif // __EVAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\museum\util.h ===
/*****************************************************************************\
    FILE: util.h

    DESCRIPTION:

    BryanSt 12/22/2000
    Copyright (C) Microsoft Corp 2000-2001. All rights reserved.
\*****************************************************************************/

#ifndef UTIL_H
#define UTIL_H

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)        (sizeof(a)/sizeof(*a))
#endif

//-----------------------------------------------------------------------------
// Name: enum CULLSTATE
// Desc: Represents the result of the culling calculation on an object.
//-----------------------------------------------------------------------------
enum CULLSTATE
{
    CS_UNKNOWN,      // cull state not yet computed
    CS_INSIDE,       // object bounding box is at least partly inside the frustum
    CS_OUTSIDE,      // object bounding box is outside the frustum
    CS_INSIDE_SLOW,  // OBB is inside frustum, but it took extensive testing to determine this
    CS_OUTSIDE_SLOW, // OBB is outside frustum, but it took extensive testing to determine this
};


//-----------------------------------------------------------------------------
// Name: struct CULLINFO
// Desc: Stores information that will be used when culling objects.  It needs
//       to be recomputed whenever the view matrix or projection matrix changes.
//-----------------------------------------------------------------------------
struct CULLINFO
{
    D3DXVECTOR3 vecFrustum[8];    // corners of the view frustum
    D3DXPLANE planeFrustum[6];    // planes of the view frustum
    D3DXVECTOR3 vecFrustumCenter; // center of the view frustum
};

#include "main.h"


#define HINST_THISDLL       g_hMainInstance


extern BOOL g_fOverheadViewTest;
extern HINSTANCE g_hMainInstance;


void FloatToString(float fValue, int nDecimalDigits, LPTSTR pszString, DWORD cchSize);
void PrintLocation(LPTSTR pszTemplate, D3DXVECTOR3 vLoc, D3DXVECTOR3 vTangent);


HRESULT SetBoxStripVertexes(MYVERTEX * ppvVertexs, D3DXVECTOR3 vLocation, D3DXVECTOR3 vSize, D3DXVECTOR3 vNormal);
float GetSurfaceRatio(IDirect3DTexture8 * pTexture);
float AddVectorComponents(D3DXVECTOR3 vDir);

int CALLBACK DPALocalFree_Callback(LPVOID p, LPVOID pData);
int CALLBACK DPAStrCompare(void * pv1, void * pv2, LPARAM lParam);
BOOL Is3DRectViewable(CULLINFO* pCullInfo, D3DXMATRIX* pMatWorld, 
                      D3DXVECTOR3 vMin, D3DXVECTOR3 vMax);

int GetTextureHeight(IDirect3DTexture8 * pTexture);
int GetTextureWidth(IDirect3DTexture8 * pTexture);


BOOL PathDeleteDirectoryRecursively(LPCTSTR pszDir);
ULONGLONG PathGetFileSize(LPCTSTR pszPath);



int GetRandomInt(int nMin, int nMax);
HRESULT GetCurrentUserCustomName(LPWSTR pszDisplayName, DWORD cchSize);
HRESULT ShellFolderParsePath(LPCWSTR pszPath, LPITEMIDLIST * ppidl);
HRESULT ShellFolderGetPath(LPCITEMIDLIST pidl, LPWSTR pszPath, DWORD cchSize);


// Reg Wrappers
HRESULT HrRegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
HRESULT HrRegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, 
       REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
HRESULT HrRegGetDWORD(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, LPDWORD pdwValue, DWORD dwDefaultValue);
HRESULT HrRegSetDWORD(IN HKEY hKey, IN LPCTSTR pszSubKey, OPTIONAL IN LPCTSTR pszValue, DWORD dwValue);
HRESULT HrRegGetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, IN LPWSTR pszString, IN DWORD cchSize);
HRESULT HrRegSetValueString(IN HKEY hKey, IN LPCTSTR pszSubKey, IN LPCTSTR pszValueName, OUT LPCWSTR pszString);


// UI Wrappers
void SetCheckBox(HWND hwndDlg, UINT idControl, BOOL fChecked);
BOOL GetCheckBox(HWND hwndDlg, UINT idControl);


// Prototypes for the culling functions
VOID UpdateCullInfo( CULLINFO* pCullInfo, D3DXMATRIX* pMatView, D3DXMATRIX* pMatProj );
CULLSTATE CullObject( CULLINFO* pCullInfo, D3DXVECTOR3* pVecBounds, D3DXPLANE* pPlaneBounds );
BOOL EdgeIntersectsFace( D3DXVECTOR3* pEdges, D3DXVECTOR3* pFaces, D3DXPLANE* pPlane );

// Other
void DebugStartWatch(void);
DWORD DebugStopWatch(void);

D3DXVECTOR3 D3DXVec3Multiply(CONST D3DXVECTOR3 v1, CONST D3DXVECTOR3 v2);


typedef struct
{
    float fTimeToRotate;
    float fTimeToWalk;
    float fTimeToLookAtPaintings;
    int nMinTurnFrames;
    int nMinWalkFrames;
    int nMaxTurnFrames;
    int nMaxWalkFrames;
} SPEED_SETTING;

#define MAX_SPEED                   11

extern SPEED_SETTING s_SpeedSettings[MAX_SPEED];

#define TaskBar_SetRange(hwndControl, fRedraw, nMin, nMax)  SendMessage(hwndControl, TBM_SETRANGE, (WPARAM) (BOOL) fRedraw, (LPARAM) MAKELONG(nMin, nMax))
#define TaskBar_SetPos(hwndControl, fRedraw, nPosition)  SendMessage(hwndControl, TBM_SETPOS, (WPARAM) (BOOL) fRedraw, (LPARAM) (LONG) nPosition)
#define TaskBar_GetPos(hwndControl)  (int) SendMessage(hwndControl, TBM_GETPOS, 0, 0)



float rnd(void);

#define ABS(i)  (((i) < 0) ? -(i) : (i))



//------------------------------------------------------------------------

////////////////
//
//  Critical section stuff
//
//  Helper macros that give nice debug support
//
EXTERN_C CRITICAL_SECTION g_csDll;
#ifdef DEBUG
EXTERN_C UINT g_CriticalSectionCount;
EXTERN_C DWORD g_CriticalSectionOwner;
EXTERN_C void Dll_EnterCriticalSection(CRITICAL_SECTION*);
EXTERN_C void Dll_LeaveCriticalSection(CRITICAL_SECTION*);
#if defined(__cplusplus) && defined(AssertMsg)
class DEBUGCRITICAL {
protected:
    BOOL fClosed;
public:
    DEBUGCRITICAL() {fClosed = FALSE;};
    void Leave() {fClosed = TRUE;};
    ~DEBUGCRITICAL() 
    {
        AssertMsg(fClosed, TEXT("you left scope while holding the critical section"));
    }
};
#define ENTERCRITICAL DEBUGCRITICAL debug_crit; Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL debug_crit.Leave(); Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#else // __cplusplus
#define ENTERCRITICAL Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#endif // __cplusplus
#define ASSERTCRITICAL ASSERT(g_CriticalSectionCount > 0 && GetCurrentThreadId() == g_CriticalSectionOwner)
#define ASSERTNONCRITICAL ASSERT(GetCurrentThreadId() != g_CriticalSectionOwner)
#else // DEBUG
#define ENTERCRITICAL EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT LeaveCriticalSection(&g_csDll)
#define ASSERTCRITICAL 
#define ASSERTNONCRITICAL
#endif // DEBUG



#endif // UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\mystify\ssmyst.c ===
/*  MYSTIFY.C
**
**  Copyright (C) Microsoft, 1991, All Rights Reserved.
**
**  Screensaver Control Panel Applet.  This type creates one or two polygons
**  which bounce around the screen.
**
**  History:
**       6/17/91        stevecat    ported to NT Windows
**       2/10/92        stevecat    snapped to latest ported to NT Windows
*/

#define  OEMRESOURCE
#include <windows.h>
#include <commctrl.h>
#include <scrnsave.h>
#include "mystify.dlg"
#include "strings.h"
#include "uniconv.h"


// void  SetFields (HWND, WORD);

DWORD AdjustColor      (DWORD dwSrc, DWORD dwDest, int nInc, int nCnt);
LONG  AppOwnerDraw     (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
WORD  AtoI             (LPTSTR lpszConvert);
BOOL  DrawBitmap       (HDC hdc, int x, int y, HBITMAP hbm, DWORD rop);
VOID  DrawPolygon      (HDC hDC, HPEN hPen, WORD wPolygon, WORD wLine);
VOID  FillR            (HDC hdc, LPRECT prc, DWORD rgb);
VOID  FrameR           (HDC hdc, LPRECT prc, DWORD rgb, int iFrame);
DWORD GenerateColor    (VOID);
WORD  GenerateVelocity (VOID);
VOID  GetFields        (VOID);
DWORD GetProfileRgb    (LPTSTR szApp, LPTSTR szItem, DWORD rgb);
VOID  PatB             (HDC hdc, int x, int y, int dx, int dy, DWORD rgb);
WORD  rand             (VOID);
VOID  ShadeWindows     (HWND hDlg, WORD wPoly, WORD wPolygon);
VOID  srand            (DWORD dwSeed);

#define RAND(x)  ((rand () % (x))+1)
#define ZRAND(x) (rand () % (x))

#define rgbBlack        RGB (0,0,0)
#define rgbWhite        RGB (255,255,255)
#define rgbGrey         RGB (128,128,128)
#define rgbMenu         GetSysColor (COLOR_MENU)
#define rgbMenuText     GetSysColor (COLOR_MENUTEXT)

#define BUFFER_SIZE     1025 // safe size for wsprintf
#define BUFFER2_SIZE    1025 // safe size for wsprintf

#define NUMBER_POLYGONS  2
#define MAXXVEL         12
#define MAXYVEL         12
#define MAXLINES        15
#define NUMLINES         8

TCHAR  szClearName[] = TEXT("Clear Screen");   // ClearScreen .INI key

DWORD dwRand = 1L;                      // current Random seed

TCHAR  szBuffer[BUFFER_SIZE];            // temp buffer

TCHAR  szBuffer2[BUFFER2_SIZE];          // temp buffer

BOOL  fOn[NUMBER_POLYGONS];             // flag for Active status of polygon

BOOL  fWalk[NUMBER_POLYGONS];           // color usage for each polygon

WORD  wLines[NUMBER_POLYGONS];          // number of lines for each polygon

WORD  wNumDisplay[2];
WORD  wFreeEntry[NUMBER_POLYGONS];      // colors for each polygon

DWORD dwStartColor[NUMBER_POLYGONS];
DWORD dwEndColor[NUMBER_POLYGONS];
DWORD dwCurrentColor[NUMBER_POLYGONS];
DWORD dwDestColor[NUMBER_POLYGONS];
DWORD dwSrcColor[NUMBER_POLYGONS];
WORD  wIncColor[NUMBER_POLYGONS];
WORD  wCurInc[NUMBER_POLYGONS];
TCHAR cblogpalPal[(MAXLINES*NUMBER_POLYGONS+1)
                           *sizeof (PALETTEENTRY)+sizeof (LOGPALETTE)];
POINT ptBox[MAXLINES*NUMBER_POLYGONS][4]; // array for points used in polygons

LPLOGPALETTE   lplogpalPal;
LPPALETTEENTRY lppePal;
HPALETTE       hPalette;
BOOL fClearScreen;                      // Global flag for ClearScreen state

//
// Help IDs
//
DWORD aMystDlgHelpIds[] = {
    ((DWORD) -1),((DWORD) -1),
    ID_SHAPE_LABEL,             IDH_DISPLAY_SCREENSAVER_MYSTIFY_SHAPE,
    ID_SHAPE,                   IDH_DISPLAY_SCREENSAVER_MYSTIFY_SHAPE,
    ID_ACTIVE,                  IDH_DISPLAY_SCREENSAVER_MYSTIFY_ACTIVE,
    ID_LINES_LABEL,             IDH_DISPLAY_SCREENSAVER_MYSTIFY_LINES,
    ID_LINES,                   IDH_DISPLAY_SCREENSAVER_MYSTIFY_LINES,
    ID_LINESARROW,              IDH_DISPLAY_SCREENSAVER_MYSTIFY_LINES,
    ID_COLORGROUP,              ((DWORD) -1),
    ID_2COLORS,                 IDH_DISPLAY_SCREENSAVER_MYSTIFY_TWO_COLORS,
    ID_COLOR1,                  IDH_DISPLAY_SCREENSAVER_MYSTIFY_TWO_COLORS,
    ID_COLOR2,                  IDH_DISPLAY_SCREENSAVER_MYSTIFY_TWO_COLORS,
    ID_RANDOMCOLORS,            IDH_DISPLAY_SCREENSAVER_MYSTIFY_RANDOM_COLORS,
    ID_CLEARSCREEN,             IDH_DISPLAY_SCREENSAVER_MYSTIFY_CLEAR_SCREEN,
    0,0
};

LRESULT ScreenSaverProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static POINT ptChange[MAXLINES*NUMBER_POLYGONS][4];
    static UINT_PTR  wTimer;
    WORD         wLoop1;
    WORD         wLoop2;
    WORD         wMainLoop;
    static WORD  wScreenX;
    static WORD  wScreenY;
    HPEN         hPen;
    static HPEN  hErasePen;
    HDC          hDC;
    HPALETTE     hOldPal;

    switch (message)
    {
    // Things to do while setting up the window...
    case WM_CREATE:
        GetFields ();
        wTimer = SetTimer (hWnd, 1, 10, NULL);

        // Make sure we use the entire virtual desktop size for multiple
        // displays
        wScreenX = (WORD) ((LPCREATESTRUCT)lParam)->cx;
        wScreenY = (WORD) ((LPCREATESTRUCT)lParam)->cy;

        srand (GetCurrentTime ());
        for (wMainLoop = 0; wMainLoop < NUMBER_POLYGONS; wMainLoop++)
        {
            if (fOn[wMainLoop])
            {
                for (wLoop1 = 0; wLoop1 < 4; wLoop1++)
                {
                    ptBox[wMainLoop*MAXLINES][wLoop1].x = RAND (wScreenX) - 1;
                    ptBox[wMainLoop*MAXLINES][wLoop1].y = RAND (wScreenY) - 1;
                    if ((ptChange[wMainLoop*MAXLINES][wLoop1].x =
                        RAND (MAXXVEL * 2)) > MAXXVEL)
                        ptChange[wMainLoop*MAXLINES][wLoop1].x =
                            -(ptChange[wMainLoop*MAXLINES][wLoop1].x
                            -MAXXVEL);
                    if ((ptChange[wMainLoop*MAXLINES][wLoop1].y =
                        RAND (MAXYVEL * 2)) > MAXYVEL)
                        ptChange[wMainLoop*MAXLINES][wLoop1].y =
                            -(ptChange[wMainLoop*MAXLINES][wLoop1].y
                            -MAXYVEL);
                }
                wNumDisplay[wMainLoop] = 1;
                wFreeEntry[wMainLoop] = 0;
                wCurInc[wMainLoop] = 0;
                wIncColor[wMainLoop] = 0;
                if (fWalk[wMainLoop])
                    dwDestColor[wMainLoop] = GenerateColor ();
                else
                    dwDestColor[wMainLoop] = dwStartColor[wMainLoop];
            }
        }
        lppePal = (LPPALETTEENTRY)(cblogpalPal + 4);
        lplogpalPal = (LPLOGPALETTE)cblogpalPal;
        lplogpalPal->palVersion = 0x300;
        lplogpalPal->palNumEntries = MAXLINES * NUMBER_POLYGONS + 1;
        for (wLoop1 = 0; wLoop1 <= MAXLINES * NUMBER_POLYGONS; wLoop1++)
        {
            lplogpalPal->palPalEntry[wLoop1].peRed = 0;
            lplogpalPal->palPalEntry[wLoop1].peGreen = 0;
            lplogpalPal->palPalEntry[wLoop1].peBlue = 0;
            lplogpalPal->palPalEntry[wLoop1].peFlags = PC_RESERVED;
        }
        hErasePen = CreatePen (PS_SOLID, 1,
            PALETTEINDEX (MAXLINES * NUMBER_POLYGONS));
        hPalette = CreatePalette (lplogpalPal);
        break;

    case WM_SIZE:
        wScreenX = LOWORD(lParam);
        wScreenY = HIWORD(lParam);
        break;



    case WM_ERASEBKGND:
        if (fClearScreen)
            break;
        return 0l;

    case WM_TIMER:
        // Get the display context...
        hDC = GetDC (hWnd);
        if (hDC != NULL)
        {
            // Now that we have changed the palette, make sure that it
            // gets updated by first unrealizing, and then realizing...
            hOldPal = SelectPalette (hDC, hPalette, 0);
            RealizePalette (hDC);

            for (wMainLoop = 0; wMainLoop < NUMBER_POLYGONS; wMainLoop++)
            {
                // Check to see if the current loop is on...
                if (fOn[wMainLoop])
                {
                    // If our current count is the same as the final count,
                    // generate a new count...
                    if (wCurInc[wMainLoop] == wIncColor[wMainLoop])
                    {
                        // Set the count to zero...
                        wCurInc[wMainLoop] = 0;

                        // Set an new variant...
                        wIncColor[wMainLoop] = GenerateVelocity ();

                        // Set up the cycling colors...
                        dwSrcColor[wMainLoop] = dwDestColor[wMainLoop];

                        if (fWalk[wMainLoop])
                            dwDestColor[wMainLoop] = GenerateColor ();
                        else if (dwSrcColor[wMainLoop] == dwEndColor[wMainLoop])
                            dwDestColor[wMainLoop] = dwStartColor[wMainLoop];
                        else
                            dwDestColor[wMainLoop] = dwEndColor[wMainLoop];
                    }
                    else
                        wCurInc[wMainLoop]++;

                    // Now adjust the color between the starting and the
                    // ending values...
                    dwCurrentColor[wMainLoop] = AdjustColor (dwSrcColor
                        [wMainLoop], dwDestColor[wMainLoop], wIncColor
                        [wMainLoop], wCurInc[wMainLoop]);
                    wLoop2 = wFreeEntry[wMainLoop] + wMainLoop * MAXLINES;

                    lplogpalPal->palPalEntry[wLoop2].peRed =
                                        GetRValue (dwCurrentColor[wMainLoop]);
                    lplogpalPal->palPalEntry[wLoop2].peGreen =
                                        GetGValue (dwCurrentColor[wMainLoop]);
                    lplogpalPal->palPalEntry[wLoop2].peBlue =
                                        GetBValue (dwCurrentColor[wMainLoop]);
                    lplogpalPal->palPalEntry[wLoop2].peFlags = PC_RESERVED;

                    // Adjust the palette...
                    AnimatePalette (hPalette, wLoop2, 1,
                                        &lplogpalPal->palPalEntry[wLoop2]);
                }
            }

            // Now cycle through again...
            for (wMainLoop = 0; wMainLoop < NUMBER_POLYGONS; wMainLoop++)
            {
                if (fOn[wMainLoop])
                {
                    /* If we are currently displaying all of the lines, then
                       delete the last line... */
                    if (wNumDisplay[wMainLoop] == wLines[wMainLoop])
                        /* Erase the last line... */
                        DrawPolygon (hDC, hErasePen, wMainLoop,
                                     (WORD) (wNumDisplay[wMainLoop] - 1));

                    /* Starting with the last entry, make it equal to the
                       entry before it... until we reach the first
                       entry... */
                    for (wLoop1 = (wNumDisplay[wMainLoop] - 1); wLoop1; wLoop1--)
                    {
                        /* Copy the points in the polygon over... */
                        for (wLoop2 = 0; wLoop2 < 4; wLoop2++)
                        {
                            ptBox[wLoop1+wMainLoop*MAXLINES][wLoop2].x =
                                ptBox[wLoop1-1+wMainLoop*MAXLINES][wLoop2].x;
                            ptBox[wLoop1+wMainLoop*MAXLINES][wLoop2].y =
                                ptBox[wLoop1-1+wMainLoop*MAXLINES][wLoop2].y;
                            ptChange[wLoop1+wMainLoop*MAXLINES][wLoop2].x =
                                ptChange[wLoop1-1+wMainLoop*MAXLINES]
                                [wLoop2].x;
                            ptChange[wLoop1+wMainLoop*MAXLINES][wLoop2].y =
                                ptChange[wLoop1-1+wMainLoop*MAXLINES]
                                [wLoop2].y;
                        }
                    }

                    /* Seeing as we now have entry 0 the same as entry 1,
                       generate a new entry 0... */
                    for (wLoop1 = 0; wLoop1 < 4; wLoop1++)
                    {
                        ptBox[wMainLoop*MAXLINES][wLoop1].x +=
                            ptChange[wMainLoop*MAXLINES][wLoop1].x;
                        ptBox[wMainLoop*MAXLINES][wLoop1].y +=
                            ptChange[wMainLoop*MAXLINES][wLoop1].y;
                        if (ptBox[wMainLoop*MAXLINES][wLoop1].x >=
                            (int)wScreenX)
                        {
                            ptBox[wMainLoop*MAXLINES][wLoop1].x =
                                ptBox[wMainLoop*MAXLINES][wLoop1].x
                                -2 * (ptBox[wMainLoop*MAXLINES][wLoop1].x
                                -wScreenX + 1);
                            ptChange[wMainLoop*MAXLINES][wLoop1].x =
                                -RAND (MAXXVEL);
                        }
                        if ((int)ptBox[wMainLoop*MAXLINES][wLoop1].x < 0)
                        {
                            ptBox[wMainLoop*MAXLINES][wLoop1].x =
                                -ptBox[wMainLoop*MAXLINES][wLoop1].x;
                            ptChange[wMainLoop*MAXLINES][wLoop1].x =
                                RAND (MAXXVEL);
                        }
                        if (ptBox[wMainLoop*MAXLINES][wLoop1].y >=
                            (int)wScreenY)
                        {
                            ptBox[wMainLoop*MAXLINES][wLoop1].y =
                                ptBox[wMainLoop*MAXLINES][wLoop1].y - 2 *
                                (ptBox[wMainLoop*MAXLINES][wLoop1].y
                                -wScreenY + 1);
                            ptChange[wMainLoop*MAXLINES][wLoop1].y =
                                -RAND (MAXYVEL);
                        }
                        if ((int)ptBox[wMainLoop*MAXLINES][wLoop1].y < 0)
                        {
                            ptBox[wMainLoop*MAXLINES][wLoop1].y =
                                -ptBox[wMainLoop*MAXLINES][wLoop1].y;
                            ptChange[wMainLoop*MAXLINES][wLoop1].y =
                                RAND (MAXYVEL);
                        }
                    }

                    /* Now redraw the new line... */
                    wLoop2 = wFreeEntry[wMainLoop] + wMainLoop * MAXLINES;
                    hPen = CreatePen (PS_SOLID, 1, PALETTEINDEX (wLoop2));
                    DrawPolygon (hDC, hPen, wMainLoop, 0);
                    if (hPen)
                        DeleteObject (hPen);

                    /* Now, as we are finished with the entry in the
                       palette, increment it such that the next time
                       around, it points at the next position... */
                    if ((++wFreeEntry[wMainLoop]) == wLines[wMainLoop])
                        wFreeEntry[wMainLoop] = 0;

                    /* Now, if we are not at the maximum number of lines,
                       then increment towards there... */
                    if (wNumDisplay[wMainLoop] < wLines[wMainLoop])
                        wNumDisplay[wMainLoop]++;
                }
            }

            /* Reselect the old palette... */
            if (hOldPal)
                SelectPalette (hDC, hOldPal, FALSE);

            /* Release the display context... */
            ReleaseDC (hWnd, hDC);
        }
        break;

    case WM_DESTROY:
        if (wTimer)
            KillTimer (hWnd, 1);
        if (hPalette)
            DeleteObject (hPalette);
        if (hErasePen)
            DeleteObject (hErasePen);
        break;
    }
    return (DefScreenSaverProc (hWnd, message, wParam, lParam));
}


VOID srand (DWORD dwSeed)
{
    dwRand = dwSeed;
}

WORD rand (VOID)
{
    dwRand = dwRand * 214013L + 2531011L;
    return (WORD)((dwRand >> 16) & 0xffff);
}

BOOL RegisterDialogClasses (HANDLE hInst)
{
    /* Register the custom controls.. */
    InitCommonControls();
    return TRUE;
}


//***************************************************************************

BOOL ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    WORD         nPal;
    DWORD        dwTemp = 0;
    HPALETTE     hPal;
    WORD         wLoop, wTemp;
    BOOL         fError;
    BYTE         byR, byG, byB;
    RECT         rDlgBox;
    TCHAR        szTemp[80];
    static HWND  hIDOK;
    static WORD  wPolygon;

    switch (message)
    {
    case WM_INITDIALOG:
        GetFields ();                // Read fields from CONTROL.INI

        GetWindowRect (hDlg, (LPRECT) & rDlgBox);
        hIDOK = GetDlgItem (hDlg, IDOK);

        // Set the global clear state...
        CheckDlgButton (hDlg, ID_CLEARSCREEN, fClearScreen);

        // Fill the boxes...
        for (wLoop = 0; wLoop < NUMBER_POLYGONS; wLoop++)
        {
            TCHAR   szBuffer[1025]; // safe for wsprintf size
            WORD    wTemp;

            LoadString (hMainInstance, idsPolygon, szTemp, CharSizeOf(szTemp));
            wsprintf (szBuffer, szTemp, wLoop + 1);
            wTemp = (WORD)SendDlgItemMessage (hDlg, ID_SHAPE, CB_ADDSTRING, 0,
                                              (LPARAM)szBuffer);
            SendDlgItemMessage (hDlg, ID_SHAPE, CB_SETITEMDATA, wTemp, wLoop);
        }

        hPal = GetStockObject (DEFAULT_PALETTE);
        GetObject (hPal, sizeof (WORD), (LPTSTR) &nPal);
        for (wTemp = 0; wTemp < nPal; wTemp++)
        {
            SendDlgItemMessage (hDlg, ID_COLOR1, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"a");
            SendDlgItemMessage (hDlg, ID_COLOR2, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"a");
        }

        // Start at the first polygon and let'r rip...
        SendDlgItemMessage (hDlg, ID_LINES, EM_LIMITTEXT, 2, 0l);
        SendDlgItemMessage( hDlg, ID_LINESARROW, UDM_SETRANGE, 0, MAKELONG(MAXLINES, 1));
        SendDlgItemMessage (hDlg, ID_SHAPE, CB_SETCURSEL, (wPolygon = 0), 0l);
        SendMessage (hDlg, WM_COMMAND, MAKELONG (ID_SHAPE, CBN_SELCHANGE), 0);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        // If we switch polygons, then update all of the info...
        case ID_SHAPE:
            if (HIWORD (wParam) == CBN_SELCHANGE)
            {
                WORD    wTemp;

                wTemp = (WORD)SendDlgItemMessage (hDlg, ID_SHAPE,
                                                    CB_GETCURSEL, 0, 0l);
                wPolygon = (WORD)SendDlgItemMessage (hDlg, ID_SHAPE,
                                                    CB_GETITEMDATA, wTemp, 0l);
                CheckDlgButton (hDlg, ID_ACTIVE, fOn[wPolygon]);
                SetDlgItemInt (hDlg, ID_LINES, wLines[wPolygon], FALSE);
                hPal = GetStockObject (DEFAULT_PALETTE);
                GetObject (hPal, sizeof (WORD), (LPTSTR) &nPal);
                if (SendDlgItemMessage (hDlg, ID_COLOR1, CB_SETCURSEL,
                    GetNearestPaletteIndex (hPal, dwStartColor[wPolygon]),
                    0l) == CB_ERR)
                    SendDlgItemMessage (hDlg, ID_COLOR1, CB_SETCURSEL, 0, 0l);
                if (SendDlgItemMessage (hDlg, ID_COLOR2, CB_SETCURSEL,
                    GetNearestPaletteIndex (hPal, dwEndColor[wPolygon]),
                    0l) == CB_ERR)
                    SendDlgItemMessage (hDlg, ID_COLOR2, CB_SETCURSEL, 0, 0l);

                // Set the walk state...
                CheckRadioButton (hDlg, ID_2COLORS, ID_RANDOMCOLORS, ID_2COLORS +
                    fWalk[wPolygon]);

                // Enable/disbale windows...
                ShadeWindows (hDlg, wPolygon, wPolygon);
            }
            break;

        // Toggle the actiavtion state...
        case ID_ACTIVE:
            fOn[wPolygon] ^= 1;
            CheckDlgButton (hDlg, LOWORD(wParam), fOn[wPolygon]);
            ShadeWindows (hDlg, wPolygon, wPolygon);
            break;

        case ID_CLEARSCREEN:
            fClearScreen ^= 1;
            CheckDlgButton (hDlg, LOWORD(wParam), fClearScreen);
            break;

        case ID_COLOR1:
        case ID_COLOR2:
            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                wTemp = (WORD)SendDlgItemMessage (hDlg, LOWORD(wParam), CB_GETCURSEL, 0, 0l);
                hPal = GetStockObject (DEFAULT_PALETTE);
                GetPaletteEntries (hPal, wTemp, 1, (LPPALETTEENTRY)(LPDWORD) & dwTemp);
                if ( LOWORD(wParam) == ID_COLOR1 )
                    dwStartColor[wPolygon] = dwTemp & 0xffffffL;
                else
                    dwEndColor[wPolygon] = dwTemp & 0xffffffL;
            }
            break;

        // Toggle the walk state...
        case ID_2COLORS:
        case ID_RANDOMCOLORS:
            fWalk[wPolygon] = LOWORD(wParam) - ID_2COLORS;
            CheckRadioButton (hDlg, ID_2COLORS, ID_RANDOMCOLORS, LOWORD(wParam));
            EnableWindow (GetDlgItem (hDlg, ID_COLOR1), !fWalk[wPolygon]);
            InvalidateRect (GetDlgItem (hDlg, ID_COLOR1), NULL, TRUE);
            EnableWindow (GetDlgItem (hDlg, ID_COLOR2), !fWalk[wPolygon]);
            InvalidateRect (GetDlgItem (hDlg, ID_COLOR2), NULL, TRUE);
            break;

        // Check to see if the edit texts have lost their focus. If so
        // update...
        case ID_LINES:
            if (HIWORD(wParam) == EN_UPDATE)
            {
                wLoop = (WORD) GetDlgItemInt (hDlg, LOWORD(wParam), &fError, FALSE);
                fError = fError && (wLoop >= 1 && wLoop <= MAXLINES);
                EnableWindow (GetDlgItem (hDlg, ID_LINESARROW), fError);
                EnableWindow (GetDlgItem (hDlg, IDOK), fError);
                if (fError)
                    wLines[wPolygon] = wLoop;
            }
            break;

        // Save the current parameters...
        case IDOK:
            wLines[wPolygon] = (WORD) GetDlgItemInt (hDlg, ID_LINES, &fError, FALSE);

            // Write the activation state of clearing the screen...
            wsprintf (szBuffer, TEXT("%d"), fClearScreen);
            WritePrivateProfileString (szAppName, szClearName, szBuffer, szIniFile);

            /* Write the updated versions of everything here... */
            for (wLoop = 0; wLoop < NUMBER_POLYGONS; wLoop++)
            {
                /* Set the activation state... */
                wsprintf (szBuffer, TEXT("Active%d"), wLoop + 1);
                wsprintf (szBuffer2, TEXT("%d"), fOn[wLoop]);
                WritePrivateProfileString (szAppName, szBuffer, szBuffer2, szIniFile);

                /* Set the walk state... */
                wsprintf (szBuffer, TEXT("WalkRandom%d"), wLoop + 1);
                wsprintf (szBuffer2, TEXT("%d"), fWalk[wLoop]);
                WritePrivateProfileString (szAppName, szBuffer, szBuffer2, szIniFile);

                /* Get the number of lines for the current polygon... */
                wsprintf (szBuffer, TEXT("Lines%d"), wLoop + 1);
                wsprintf (szBuffer2, TEXT("%d"), wLines[wLoop]);
                WritePrivateProfileString (szAppName, szBuffer, szBuffer2, szIniFile);

                /* Set the start color... */
                wsprintf (szBuffer, TEXT("StartColor%d"), wLoop + 1);
                byR = GetRValue (dwStartColor[wLoop]);
                byG = GetGValue (dwStartColor[wLoop]);
                byB = GetBValue (dwStartColor[wLoop]);
                wsprintf (szBuffer2, TEXT("%d %d %d"), byR, byG, byB);
                WritePrivateProfileString (szAppName, szBuffer, szBuffer2, szIniFile);

                /* Set the end color... */
                wsprintf (szBuffer, TEXT("EndColor%d"), wLoop + 1);
                byR = GetRValue (dwEndColor[wLoop]);
                byG = GetGValue (dwEndColor[wLoop]);
                byB = GetBValue (dwEndColor[wLoop]);
                wsprintf (szBuffer2, TEXT("%d %d %d"), byR, byG, byB);
                WritePrivateProfileString (szAppName, szBuffer, szBuffer2, szIniFile);
            }

        /* Bail out... */

        case IDCANCEL:
            EndDialog (hDlg, LOWORD(wParam) == IDOK);
            return TRUE;

        }
        break;

    case WM_DRAWITEM:
        return (BOOL)AppOwnerDraw (hDlg, message, wParam, lParam);

    case WM_MEASUREITEM:
        return (BOOL)AppOwnerDraw (hDlg, message, wParam, lParam);

    case WM_DELETEITEM:
        return (BOOL)AppOwnerDraw (hDlg, message, wParam, lParam);

    case WM_HELP: // F1
        WinHelp(
            (HWND) ((LPHELPINFO) lParam)->hItemHandle,
            szHelpFile,
            HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aMystDlgHelpIds
        );
        break;

    case WM_CONTEXTMENU:  // right mouse click
        WinHelp(
            (HWND) wParam,
            szHelpFile,
            HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aMystDlgHelpIds
        );
        break;

    default:
        break;
    }
    return FALSE;
}


VOID GetFields (VOID)
{
    WORD wLoop;
    //Load Global Strings from stringtable
    LoadString (hMainInstance, idsName, szName, CharSizeOf(szName));
    LoadString (hMainInstance, idsAppName, szAppName, CharSizeOf(szAppName));

    //Load Common Strings from stringtable...
    LoadString (hMainInstance, idsIniFile, szIniFile, CharSizeOf(szIniFile));
    LoadString (hMainInstance, idsScreenSaver, szScreenSaver, CharSizeOf(szScreenSaver));
    LoadString (hMainInstance, idsHelpFile, szHelpFile, CharSizeOf(szHelpFile));
    LoadString (hMainInstance, idsNoHelpMemory, szNoHelpMemory, CharSizeOf(szNoHelpMemory));

    /* Do we clear the screen when we start... */
    if ((fClearScreen = GetPrivateProfileInt (szAppName, szClearName, 1, szIniFile)) != 0)
        fClearScreen = 1;

    /* Loop through and get all of the field information... */
    for (wLoop = 0; wLoop < NUMBER_POLYGONS; wLoop++)
    {
        /* Get the activation state... */
        wsprintf (szBuffer, TEXT("Active%d"), wLoop + 1);
        if ((fOn[wLoop] = GetPrivateProfileInt (szAppName, szBuffer, 1, szIniFile)) != 0)
            fOn[wLoop] = 1;

        /* Get the walk state... */
        wsprintf (szBuffer, TEXT("WalkRandom%d"), wLoop + 1);
        if ((fWalk[wLoop] = GetPrivateProfileInt (szAppName, szBuffer, 1, szIniFile)) != 0)
            fWalk[wLoop] = 1;

        /* Get the number of lines for the current polygon... */
        wsprintf (szBuffer, TEXT("Lines%d"), wLoop + 1);
        wLines[wLoop] = (WORD) GetPrivateProfileInt (szAppName, szBuffer, 5, szIniFile);
        if ((int)wLines[wLoop] < 1)
            wLines[wLoop] = 1;
        if (wLines[wLoop] > MAXLINES)
            wLines[wLoop] = MAXLINES;

        /* Get the starting and ending colors (stored in DWORD format)... */
        wsprintf (szBuffer, TEXT("StartColor%d"), wLoop + 1);
        dwStartColor[wLoop] = GetProfileRgb (szAppName, szBuffer, RGB (0, 0, 0));
        wsprintf (szBuffer, TEXT("EndColor%d"), wLoop + 1);
        dwEndColor[wLoop] = GetProfileRgb (szAppName, szBuffer, RGB (255, 255, 255));
    }

    return;
}


VOID DrawPolygon (HDC hDC, HPEN hPen, WORD wPolygon, WORD wLine)
{
    HANDLE          hOldPen;
    WORD            wLoop1;

    hOldPen = SelectObject (hDC, hPen);
    MoveToEx (hDC, ptBox[wPolygon*MAXLINES+wLine][0].x,
                                ptBox[wPolygon*MAXLINES+wLine][0].y, NULL);
    for (wLoop1 = 0; wLoop1 < 4; wLoop1++)
        LineTo (hDC, ptBox[wPolygon*MAXLINES+wLine][(wLoop1+1)%4].x,
            ptBox[wPolygon*MAXLINES+wLine][(wLoop1+1)%4].y);
    if (hOldPen)
        SelectObject (hDC, hOldPen);
    return;
}

/* Adjust each of the rgb components according to the four input variables...*/

DWORD AdjustColor (DWORD dwSrc, DWORD dwDest, int nInc, int nCnt)
{
    DWORD dwTemp;
    WORD  wLoop;
    int      nSrc, nDst, nTmp;
    int      n1, n2, n3, n4, n5;

    /* Nullify the end value... */
    dwTemp = 0;

    /* Cycle through and compute the difference on each byte... */
    for (wLoop = 0; wLoop < 3; wLoop++)
    {
        nSrc = (int)((dwSrc >> (wLoop * 8)) % 256);
        nDst = (int)((dwDest >> (wLoop * 8)) % 256);
        n1 = nDst - nSrc;
        n2 = n1 * 10;
        n3 = n2 / nInc;
        n4 = n3 * nCnt;
        n5 = n4 / 10;
        nTmp = nSrc + n5;
        dwTemp += ((DWORD)nTmp) << (wLoop * 8);
    }
    return dwTemp;
}


/* Compute a random color that is within the accepted norms... */

DWORD GenerateColor (VOID)
{
    return (((DWORD)ZRAND (256)) + (((DWORD)ZRAND (256)) << 8) +
                    (((DWORD)ZRAND (256)) << 16));
}


/* Compute a random velocity that is within the accepted norms... */

WORD GenerateVelocity (VOID)
{
    return 255;
    return (RAND (30) + 20);
}


LONG AppOwnerDraw (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    RECT        rc;
    DWORD       rgbBg;
    static HBITMAP hbmCheck = NULL;
    LPMEASUREITEMSTRUCT     lpMIS = ((LPMEASUREITEMSTRUCT)lParam);
    LPDRAWITEMSTRUCT        lpDIS = ((LPDRAWITEMSTRUCT)lParam);

    switch (msg)
    {
    case WM_MEASUREITEM:
        lpMIS->itemHeight = 15;
        return TRUE;

    case WM_DRAWITEM:
        rc    = lpDIS->rcItem;
        rgbBg = PALETTEINDEX (lpDIS->itemID);

        if (lpDIS->itemState & ODS_SELECTED)
        {
            FrameR (lpDIS->hDC, &rc, rgbBlack, 2);
            InflateRect (&rc, -1, -1);
            FrameR (lpDIS->hDC, &rc, rgbWhite, 2);
            InflateRect (&rc, -1, -1);
        }
        if (lpDIS->itemState & ODS_DISABLED)
            FillR (lpDIS->hDC, &rc, rgbGrey);
        else
            FillR (lpDIS->hDC, &rc, rgbBg);
        return TRUE;

    case WM_DELETEITEM:
        return TRUE;
    }
    return TRUE;
}


VOID PatB (HDC hdc, int x, int y, int dx, int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor (hdc, rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut (hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}


VOID FillR (HDC hdc, LPRECT prc, DWORD rgb)
{
    SetBkColor (hdc, rgb);
    ExtTextOut (hdc, 0, 0, ETO_OPAQUE, prc, NULL, 0, NULL);
}


VOID FrameR (HDC hdc, LPRECT prc, DWORD rgb, int iFrame)
{
//    RECT    rc;
    int    dx, dy;

    dx = prc->right  - prc->left;
    dy = prc->bottom - prc->top - 2 * iFrame;

    PatB (hdc, prc->left, prc->top,          dx, iFrame,   rgb);
    PatB (hdc, prc->left, prc->bottom - iFrame, dx, iFrame,   rgb);

    PatB (hdc, prc->left,          prc->top + iFrame, iFrame, dy, rgb);
    PatB (hdc, prc->right - iFrame,  prc->top + iFrame, iFrame, dy, rgb);
}


BOOL DrawBitmap (HDC hdc, int x, int y, HBITMAP hbm, DWORD rop)
{
    HDC hdcBits;
    BITMAP bm;
//    HPALETTE hpalT;
    HBITMAP oldbm;
    BOOL f;

    if (!hdc || !hbm)
        return FALSE;

    hdcBits = CreateCompatibleDC (hdc);
    GetObject (hbm, sizeof (BITMAP), (LPTSTR) & bm);
    oldbm = SelectObject (hdcBits, hbm);
    f = BitBlt (hdc, x, y, bm.bmWidth, bm.bmHeight, hdcBits, 0, 0, rop);
    if (oldbm)
        SelectObject (hdcBits, oldbm);
    DeleteDC (hdcBits);

    return f;
}


DWORD GetProfileRgb (LPTSTR szApp, LPTSTR szItem, DWORD rgb)
{
    TCHAR    buf[80];
    LPTSTR   pch;
    WORD     r, g, b;

    GetPrivateProfileString (szApp, szItem, TEXT(""), buf, CharSizeOf(buf), szIniFile);

    if (*buf)
    {
        pch = buf;
        r = AtoI (pch);
        while (*pch && *pch != TEXT(' '))
            pch++;
        while (*pch && *pch == TEXT(' '))
            pch++;
        g = AtoI (pch);
        while (*pch && *pch != TEXT(' '))
            pch++;
        while (*pch && *pch == TEXT(' '))
            pch++;
        b = AtoI (pch);

        return RGB (r, g, b);
    }
    else
        return rgb;
}


WORD AtoI (LPTSTR lpszConvert)
{
    WORD wReturn = 0;

    while (*lpszConvert >= TEXT('0') && *lpszConvert <= TEXT('9'))
    {
        wReturn = wReturn * 10 + (WORD)(*lpszConvert - TEXT('0'));
        lpszConvert++;
    }
    return wReturn;
}


VOID ShadeWindows (HWND hDlg, WORD wPoly, WORD wPolygon)
{
    EnableWindow (GetDlgItem (hDlg, ID_COLORGROUP), fOn[wPolygon]);
    EnableWindow (GetDlgItem (hDlg, ID_2COLORS), fOn[wPolygon]);
    EnableWindow (GetDlgItem (hDlg, ID_RANDOMCOLORS), fOn[wPolygon]);
    EnableWindow (GetDlgItem (hDlg, ID_LINES), fOn[wPolygon]);
    EnableWindow (GetDlgItem (hDlg, ID_LINESARROW), fOn[wPolygon]);
    EnableWindow (GetDlgItem (hDlg, ID_COLOR1), !fWalk[wPolygon] && fOn[wPolygon]);
    InvalidateRect (GetDlgItem (hDlg, ID_COLOR1), NULL, TRUE);
    EnableWindow (GetDlgItem (hDlg, ID_COLOR2), !fWalk[wPolygon] && fOn[wPolygon]);
    InvalidateRect (GetDlgItem (hDlg, ID_COLOR2), NULL, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\fpipe.h ===
//-----------------------------------------------------------------------------
// File: fpipe.h
//
// Desc: Flexy pipe stuff
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __fpipe_h__
#define __fpipe_h__

// continuity types
enum 
{
    CONT_1 = 0,
    CONT_2
};

// cap types
enum 
{
    START_CAP = 0,
    END_CAP
};

#define CIRCUMFERENCE( r )         ( 2.0f * PI * ((float) r) )

// drawing schemes
enum 
{
    SC_EXTRUDED_XC,
    SC_TURNOMANIA,
    SC_VARIABLE_XC,
    SC_COUNT
};

#define TURNOMANIA_PIPE_COUNT 10




//-----------------------------------------------------------------------------
// Name: FLEX_PIPE class
// Desc: - Pipe has position and direction in node array
//-----------------------------------------------------------------------------
class FLEX_PIPE : public PIPE 
{
public:
    void        SetTexParams( TEXTUREINFO *pTex, IPOINT2D *pTexRep );

protected:
    XC*         m_xcCur;        // current xc, end xc
    XC*         m_xcEnd;  
    EVAL*       m_pEval;
    float       m_zTrans;       // pos'n of pipe back along current dir,
                                // from current node
    FLEX_PIPE( STATE *state );
    ~FLEX_PIPE();
    void        ChooseXCProfile();
    void        DrawExtrudedXCObject( float length );
    void        DrawXCElbow( int newDir, float radius );
    void        DrawCap( int type );

private:
    int         m_nSlices;        // intended # of slices around an xc (based on tessLevel)
    int         m_tangent;        // current tangent at curXC (usually PLUS_Z)
    float       m_sStart, m_sEnd;
    float       m_tStart, m_tEnd;
    float       m_sLength;        // length in WC's of texture width
    float       m_evalDivSize;    // ~size in WC's of an eval division

    void        CalcEvalLengthParams( float length );
};




//-----------------------------------------------------------------------------
// Name: REGULAR_FLEX_PIPE class
// Desc: 
//-----------------------------------------------------------------------------
class REGULAR_FLEX_PIPE : public FLEX_PIPE 
{
public:
    float       m_turnFactorMin;  // describes degree of bend in an elbow
    float       m_turnFactorMax;  //  [0-1]

    REGULAR_FLEX_PIPE( STATE *state );
    virtual void Start();
    virtual void Draw();
};




//-----------------------------------------------------------------------------
// Name: TURNING_FLEX_PIPE class
// Desc: 
//-----------------------------------------------------------------------------
class TURNING_FLEX_PIPE : public FLEX_PIPE 
{
public:
    TURNING_FLEX_PIPE( STATE *state );
    virtual void Start();
    virtual void Draw();
};

#endif // __fpipe_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\fstate.cpp ===
//-----------------------------------------------------------------------------
// File: fstate.cpp
//
// Desc: FLEX_STATE
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: FLEX_STATE constructor
// Desc: 
//-----------------------------------------------------------------------------
FLEX_STATE::FLEX_STATE( STATE *pMainState )
{
    m_pMainState = pMainState;
    Reset();
}




//-----------------------------------------------------------------------------
// Name: Reset
// Desc: Reset a frame of normal pipes.
//-----------------------------------------------------------------------------
void FLEX_STATE::Reset( )
{
    // Choose a random scheme for each frame

    if( CPipesScreensaver::iRand(2) )  // 50/50
        m_scheme = SC_EXTRUDED_XC;
    else
        m_scheme = SC_TURNOMANIA;
}




//-----------------------------------------------------------------------------
// Name: OKToUseChase
// Desc: Determines if we can use chase mode for flex pipes
//-----------------------------------------------------------------------------
BOOL FLEX_STATE::OKToUseChase()
{
    return m_scheme != SC_TURNOMANIA;
}




//-----------------------------------------------------------------------------
// Name: NewPipe
// Desc: Create a new pipe, based on current drawing scheme
//-----------------------------------------------------------------------------
PIPE* FLEX_STATE::NewPipe( STATE *pState )
{
    if( m_scheme == SC_TURNOMANIA )
        return new TURNING_FLEX_PIPE( pState );
    else
        return new REGULAR_FLEX_PIPE( pState );
}




//-----------------------------------------------------------------------------
// Name: GetMaxPipesPerFrame
// Desc: 
//-----------------------------------------------------------------------------
int FLEX_STATE::GetMaxPipesPerFrame( )
{
    if( m_scheme == SC_TURNOMANIA ) 
    {
        return TURNOMANIA_PIPE_COUNT;
    } 
    else 
    {
        return m_pMainState->m_bUseTexture ? NORMAL_TEX_PIPE_COUNT : NORMAL_PIPE_COUNT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\fpipe.cpp ===
//-----------------------------------------------------------------------------
// File: fpipe.cpp
//
// Desc: Flex pipes
//
//       All Draw routines start with current xc at the beginning, and create
//       a new one at the end.  Since it is common to just have 2 xc's for
//       each prim, xcCur holds the current xc, and xcEnd is available
//       for the draw routine to use as the end xc.
//       They also reset xcCur when done
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"

// defCylNotch shows the absolute notch for the default cylinder,
// given a direction (notch is always along +x axis)
static int defCylNotch[NUM_DIRS] = 
        { MINUS_Z, PLUS_Z, PLUS_X, PLUS_X, PLUS_X, MINUS_X };

static int GetRelativeDir( int lastDir, int notchVec, int newDir );




//-----------------------------------------------------------------------------
// Name: FLEX_PIPE constructor
// Desc: 
//-----------------------------------------------------------------------------
FLEX_PIPE::FLEX_PIPE( STATE *pState ) : PIPE( pState )
{
    float circ;

    // Create an EVAL object
    m_nSlices = pState->m_nSlices;

    // No XC's yet, they will be allocated at pipe Start()
    m_xcCur = m_xcEnd = NULL;

    // The EVAL will be used for all pEvals in the pipe, so should be
    // set to hold max. possible # of pts for the pipe.
    m_pEval = new EVAL( m_pState->m_bUseTexture );

    // Determine pipe tesselation
    // For now, this is based on global tesselation factor

//mf: maybe clean up this scheme a bit
    // Calculate evalDivSize, a reference value for the size of a UxV division.
    // This is used later for calculating texture coords.
    circ = CIRCUMFERENCE( pState->m_radius );
    m_evalDivSize = circ / (float) m_nSlices;
}




//-----------------------------------------------------------------------------
// Name: ~FLEX_PIPE
// Desc: 
//-----------------------------------------------------------------------------
FLEX_PIPE::~FLEX_PIPE( )
{
    delete m_pEval;

    // delete any XC's
    if( m_xcCur != NULL ) 
    {
        if( m_xcEnd == m_xcCur )
//mf: so far this can't happen...
            m_xcEnd = NULL; // xcCur and xcEnd can point to same xc !
        delete m_xcCur;
        m_xcCur = NULL;
    }

    if( m_xcEnd != NULL ) 
    {
        delete m_xcEnd;
        m_xcEnd = NULL;
    }
}




//-----------------------------------------------------------------------------
// Name: REGULAR_FLEX_PIPE constructor
// Desc: 
//-----------------------------------------------------------------------------
REGULAR_FLEX_PIPE::REGULAR_FLEX_PIPE( STATE *state ) : FLEX_PIPE( state )
{
    static float turnFactorRange = 0.1f;
    m_type = TYPE_FLEX_REGULAR;

    // figure out turning factor range (0 for min bends, 1 for max bends)
#if 1
    float avgTurn = CPipesScreensaver::fRand( 0.11f, 0.81f );
    // set min and max turn factors, and clamp to 0..1
    m_turnFactorMin = 
                SS_CLAMP_TO_RANGE( avgTurn - turnFactorRange, 0.0f, 1.0f );
    m_turnFactorMax = 
                SS_CLAMP_TO_RANGE( avgTurn + turnFactorRange, 0.0f, 1.0f );
#else
// debug: test max bend
    turnFactorMin = turnFactorMax = 1.0f;
#endif

    // choose straight weighting
// mf:for now, same as npipe - if stays same, put in pipe
    if( !CPipesScreensaver::iRand( 20 ) )
        m_weightStraight = CPipesScreensaver::iRand2( MAX_WEIGHT_STRAIGHT/4, MAX_WEIGHT_STRAIGHT );
    else
        m_weightStraight = CPipesScreensaver::iRand( 4 );
}




//-----------------------------------------------------------------------------
// Name: TURNING_FLEX_PIPE constructor
// Desc: 
//-----------------------------------------------------------------------------
TURNING_FLEX_PIPE::TURNING_FLEX_PIPE( STATE *state ) : FLEX_PIPE( state )
{
    m_type = TYPE_FLEX_TURNING;
}




//-----------------------------------------------------------------------------
// Name: SetTexIndex
// Desc: Set the texture index for this pipe, and calculate texture state dependent
//       on texRep values
//-----------------------------------------------------------------------------
void FLEX_PIPE::SetTexParams( TEXTUREINFO *pTex, IPOINT2D *pTexRep )
{
    if( m_pState->m_bUseTexture ) 
    {
/*
        float m_tSize;
        float circ;

        m_tStart = (float) pTexRep->y * 1.0f;
        m_tEnd = 0.0f;

        // calc height (m_tSize) of one rep of texture around circumference
        circ = CIRCUMFERENCE( m_radius );
        m_tSize = circ / pTexRep->y;

        // now calc corresponding width of the texture using its x/y ratio
        m_sLength = m_tSize / pTex->origAspectRatio;
        m_sStart = m_sEnd = 0.0f;
*/
//mf: this means we are 'standardizing' the texture size and proportions
// on pipe of radius 1.0 for entire program.  Might want to recalc this on
// a per-pipe basis ?
    }
}




//-----------------------------------------------------------------------------
// Name: ChooseXCProfile
// Desc: Initialize extruded pipe scheme.  This uses a randomly constructed 
//       XC, but it remains constant throughout the pipe
//-----------------------------------------------------------------------------
void FLEX_PIPE::ChooseXCProfile()
{
    static float turnFactorRange = 0.1f;
    float baseRadius = m_pState->m_radius;

    // initialize evaluator elements:
    m_pEval->m_numSections = EVAL_XC_CIRC_SECTION_COUNT;
    m_pEval->m_uOrder = EVAL_ARC_ORDER;

//mf: watch this - maybe should ROUND_UP uDiv
    // set uDiv per section (assumed uDiv multiple of numSections)
    m_pEval->m_uDiv = m_nSlices / m_pEval->m_numSections;

    // Setup XC's

    // The xc profile remains constant throughout in this case,
    // so we only need one xc.

    // Choose between elliptical or random cross-sections.  Since elliptical
    //  looks a little better, make it more likely
    if( CPipesScreensaver::iRand(4) )  // 3/4 of the time
        m_xcCur = new ELLIPTICAL_XC( CPipesScreensaver::fRand(1.2f, 2.0f) * baseRadius, 
                                           baseRadius );
    else
        m_xcCur = new RANDOM4ARC_XC( CPipesScreensaver::fRand(1.5f, 2.0f) * baseRadius );
}




//-----------------------------------------------------------------------------
// Name: REGULAR_FLEX_PIPE::Start
// Desc: Does startup of extruded-XC pipe drawing scheme 
//-----------------------------------------------------------------------------
void REGULAR_FLEX_PIPE::Start()
{
    NODE_ARRAY* nodes = m_pState->m_nodes;
    int newDir;

    // Set start position
    if( !SetStartPos() ) 
    {
        m_status = PIPE_OUT_OF_NODES;
        return;
    }

    // set material
    ChooseMaterial();

    // set XC profile
    ChooseXCProfile();

    // push matrix with zTrans and scene rotation
//    glPushMatrix();

    // Translate to current position
    TranslateToCurrentPosition();

    // set random lastDir
    m_lastDir = CPipesScreensaver::iRand( NUM_DIRS );

    // get a new node to draw to
    newDir = ChooseNewDirection();

    if( newDir == DIR_NONE ) 
    {
        // draw like one of those tea-pouring thingies...
        m_status = PIPE_STUCK;
//        glPopMatrix();
        return;
    } 
    else
    {
        m_status = PIPE_ACTIVE;
    }

    align_plusz( newDir ); // get us pointed in right direction

    // draw start cap, which will end right at current node
    DrawCap( START_CAP );

    // set initial notch vector, which is just the default notch, since
    // we didn't have to spin the start cap around z
    m_notchVec = defCylNotch[newDir];

    m_zTrans = - m_pState->m_view.m_divSize;  // distance back from new node

    UpdateCurrentPosition( newDir );

    m_lastDir = newDir;
}




//-----------------------------------------------------------------------------
// Name: TURNING_FLEX_PIPE::Start
// Desc: Does startup of turning extruded-XC pipe drawing scheme 
//-----------------------------------------------------------------------------
void TURNING_FLEX_PIPE::Start( )
{
    NODE_ARRAY* nodes = m_pState->m_nodes;

    // Set start position

    if( !SetStartPos() ) 
    {
        m_status = PIPE_OUT_OF_NODES;
        return;
    }

    // Set material
    ChooseMaterial();

    // Set XC profile
    ChooseXCProfile();

    // Push matrix with zTrans and scene rotation
//    glPushMatrix();

    // Translate to current position
    TranslateToCurrentPosition();

    // lastDir has to be set to something valid, in case we get stuck right
    // away, cuz Draw() will be called anyways on next iteration, whereupon
    // it finds out it really is stuck, AFTER calling ChooseNewTurnDirection,
    // which requires valid lastDir. (mf: fix this)
    m_lastDir = CPipesScreensaver::iRand( NUM_DIRS );

    // Pick a starting direction by finding a neihgbouring empty node
    int newDir = nodes->FindClearestDirection( &m_curPos );
    // We don't 'choose' it, or mark it as taken, because ChooseNewDirection
    // will always check it anyways

    if( newDir == DIR_NONE ) 
    {
        // we can't go anywhere
        // draw like one of those tea-pouring thingies...
        m_status = PIPE_STUCK;
//        glPopMatrix();
        return;
    } 
    else
    {
        m_status = PIPE_ACTIVE;
    }

    align_plusz( newDir ); // get us pointed in right direction

    // Draw start cap, which will end right at current node
    DrawCap( START_CAP );

    // Set initial notch vector, which is just the default notch, since
    // we didn't have to spin the start cap around z
    m_notchVec = defCylNotch[newDir];

    m_zTrans = 0.0f;  // right at current node

    m_lastDir = newDir;
}




//-----------------------------------------------------------------------------
// Name: REGULAR_FLEX_PIPE::Draw
// Desc: Draws the pipe using a constant random xc that is extruded
// 
//       Minimum turn radius can vary, since xc is not symmetrical across any
//       of its axes.  Therefore here we draw using a pipe/elbow sequence, so we
//       know what direction we're going in before drawing the elbow.  The current
//       node is the one we will draw thru next time.  Typically, the actual end
//       of the pipe is way back of this node, almost at the previous node, due
//       to the variable turn radius
//-----------------------------------------------------------------------------
void REGULAR_FLEX_PIPE::Draw()
{
    float turnRadius, minTurnRadius;
    float pipeLen, maxPipeLen, minPipeLen;
    int newDir, relDir;
    float maxXCExtent;
    NODE_ARRAY* nodes = m_pState->m_nodes;
    float divSize = m_pState->m_view.m_divSize;

    // get new direction

    newDir = ChooseNewDirection();
    if( newDir == DIR_NONE ) 
    {
        m_status = PIPE_STUCK;
        DrawCap( END_CAP );
//        glPopMatrix();
        return;
    }

    // draw pipe, and if turning, joint
    if( newDir != m_lastDir ) 
    { 
        // turning! - we have to draw joint

        // get relative turn, to figure turn radius

        relDir = GetRelativeDir( m_lastDir, m_notchVec, newDir );
        minTurnRadius = m_xcCur->MinTurnRadius( relDir );

        // now calc maximum straight section we can draw before turning
        // zTrans is current pos'n of end of pipe, from current node ??
        // zTrans is current pos'n of end of pipe, from last node

        maxPipeLen = (-m_zTrans) - minTurnRadius;

        // there is also a minimum requirement for the length of the straight
        // section, cuz if we turn too soon with a large turn radius, we
        // will swing up too close to the next node, and won't be able to
        // make one or more of the 4 possible turns from that point

        maxXCExtent = m_xcCur->MaxExtent(); // in case need it again
        minPipeLen = maxXCExtent - (divSize + m_zTrans);
        if( minPipeLen < 0.0f )
            minPipeLen = 0.0f;

        // Choose length of straight section
        // (we are translating from turnFactor to 'straightFactor' here)
        pipeLen = minPipeLen +
            CPipesScreensaver::fRand( 1.0f - m_turnFactorMax, 1.0f - m_turnFactorMin ) * 
                        (maxPipeLen - minPipeLen);

        // turn radius is whatever's left over:
        turnRadius = maxPipeLen - pipeLen + minTurnRadius;

        // draw straight section
        DrawExtrudedXCObject( pipeLen );
        m_zTrans += pipeLen; // not necessary for now, since elbow no use

        // draw elbow
        // this updates axes, notchVec to position at end of elbow
        DrawXCElbow( newDir, turnRadius );

        m_zTrans = -(divSize - turnRadius);  // distance back from node
    }
    else 
    {  
        // no turn

        // draw a straight pipe through the current node
        // length can vary according to the turnFactors (e.g. for high turn
        // factors draw a short pipe, so next turn can be as big as possible)

        minPipeLen = -m_zTrans; // brings us just up to last node
        maxPipeLen = minPipeLen + divSize - m_xcCur->MaxExtent();
        // brings us as close as possible to new node

        pipeLen = minPipeLen +
            CPipesScreensaver::fRand( 1.0f - m_turnFactorMax, 1.0f - m_turnFactorMin ) * 
                                      (maxPipeLen - minPipeLen);

        // draw pipe
        DrawExtrudedXCObject( pipeLen );
        m_zTrans += (-divSize + pipeLen);
    }

    UpdateCurrentPosition( newDir );

    m_lastDir = newDir;
}




//-----------------------------------------------------------------------------
// Name: DrawTurningXCPipe
// Desc: Draws the pipe using only turns
//          - Go straight if no turns available
//-----------------------------------------------------------------------------
void TURNING_FLEX_PIPE::Draw()
{
    float turnRadius;
    int newDir;
    NODE_ARRAY *nodes = m_pState->m_nodes;
    float divSize = m_pState->m_view.m_divSize;

    // get new direction

//mf: pipe may have gotten stuck on Start...(we don't check for this)

    newDir = nodes->ChooseNewTurnDirection( &m_curPos, m_lastDir );
    if( newDir == DIR_NONE ) 
    {
        m_status = PIPE_STUCK;
        DrawCap( END_CAP );
//        glPopMatrix();
        return;
    }

    if( newDir == DIR_STRAIGHT ) 
    {
        // No turns available - draw straight section and hope for turns
        //  on next iteration
        DrawExtrudedXCObject( divSize );
        UpdateCurrentPosition( m_lastDir );
        // ! we have to mark node as taken for this case, since
        // ChooseNewTurnDirection doesn't know whether we're taking the
        // straight option or not
        nodes->NodeVisited( &m_curPos );
    } 
    else 
    {
        // draw turning pipe

        // since xc is always located right at current node, turn radius
        // stays constant at one node division

        turnRadius = divSize;

        DrawXCElbow( newDir, turnRadius );

        // (zTrans stays at 0)

        // need to update 2 nodes
        UpdateCurrentPosition( m_lastDir );
        UpdateCurrentPosition( newDir );

        m_lastDir = newDir;
    }
}




//-----------------------------------------------------------------------------
// Name: DrawXCElbow
// Desc: Draw elbow from current position through new direction
//          - Extends current xc around bend
//          - Radius of bend is provided - this is distance from xc center to hinge
//            point, along newDir.  e.g. for 'normal pipes', radius=vc->radius
//-----------------------------------------------------------------------------
void FLEX_PIPE::DrawXCElbow( int newDir, float radius )
{
    int relDir;  // 'relative' direction of turn
    float length;

    length = (2.0f * PI * radius) / 4.0f; // average length of elbow

    // calc vDiv, texture params based on length
//mf: I think we should improve resolution of elbows - more vDiv's
// could rewrite this fn to take a vDivSize
    CalcEvalLengthParams( length );

    m_pEval->m_vOrder = EVAL_ARC_ORDER;

    // convert absolute dir to relative dir
    relDir = GetRelativeDir( m_lastDir, m_notchVec, newDir );

    // draw it - call simple bend function

    m_pEval->ProcessXCPrimBendSimple( m_xcCur, relDir, radius );
/*
    // set transf. matrix to new position by translating/rotating/translating
    // ! Based on simple elbow
    glTranslatef( 0.0f, 0.0f, radius );
    switch( relDir ) 
    {
        case PLUS_X:
            glRotatef( 90.0f, 0.0f, 1.0f, 0.0f );
            break;
        case MINUS_X:
            glRotatef( -90.0f, 0.0f, 1.0f, 0.0f );
            break;
        case PLUS_Y:
            glRotatef( -90.0f, 1.0f, 0.0f, 0.0f );
            break;
        case MINUS_Y:
            glRotatef( 90.0f, 1.0f, 0.0f, 0.0f );
            break;
    }
    glTranslatef( 0.0f, 0.0f, radius );
*/  
    // update notch vector using old function
    m_notchVec = notchTurn[m_lastDir][newDir][m_notchVec];
}




//-----------------------------------------------------------------------------
// Name: DrawExtrudedXCObject
// Desc: Draws object generated by extruding the current xc
//          Object starts at xc at origin in z=0 plane, and grows along +z axis 
//-----------------------------------------------------------------------------
void FLEX_PIPE::DrawExtrudedXCObject( float length )
{
    // calc vDiv, and texture coord stuff based on length
    // this also calcs pEval texture ctrl pt arrray now
    CalcEvalLengthParams( length );

    // we can fill in some more stuff:
    m_pEval->m_vOrder = EVAL_CYLINDER_ORDER;

#if 0
    // continuity stuff
    prim.contStart = prim.contEnd = CONT_1; // geometric continuity
#endif

    // draw it

//mf: this fn doesn't really handle continutity for 2 different xc's, so
// may as well pass it one xc
    m_pEval->ProcessXCPrimLinear( m_xcCur, m_xcCur, length );

    // update state draw axes position
//    glTranslatef( 0.0f, 0.0f, length );
}




//-----------------------------------------------------------------------------
// Name: DrawXCCap
// Desc: Cap the start of the pipe
//          Needs newDir, so it can orient itself.
//          Cap ends at current position with approppriate profile, starts a distance
//          'z' back along newDir.
//          Profile is a singularity at start point.
//-----------------------------------------------------------------------------
void FLEX_PIPE::DrawCap( int type )
{
    float radius;
    XC *xc = m_xcCur;
    BOOL bOpening = (type == START_CAP) ? TRUE : FALSE;
    float length;

    // set radius as average of the bounding box min/max's
    radius = ((xc->m_xRight - xc->m_xLeft) + (xc->m_yTop - xc->m_yBottom)) / 4.0f;

    length = (2.0f * PI * radius) / 4.0f; // average length of arc

    // calc vDiv, and texture coord stuff based on length
    CalcEvalLengthParams( length );

    // we can fill in some more stuff:
    m_pEval->m_vOrder = EVAL_ARC_ORDER;

    // draw it
    m_pEval->ProcessXCPrimSingularity( xc, radius, bOpening );
}




//-----------------------------------------------------------------------------
// Name: CalcEvalLengthParams 
// Desc: Calculate pEval values that depend on the length of the extruded object
//          - calculate vDiv, m_sStart, m_sEnd, and the texture control net array
//-----------------------------------------------------------------------------
void FLEX_PIPE::CalcEvalLengthParams( float length )
{
    m_pEval->m_vDiv = (int ) SS_ROUND_UP( length / m_evalDivSize ); 

    // calc texture start and end coords

    if( m_pState->m_bUseTexture ) 
    {
        float s_delta;

        // Don't let m_sEnd overflow : it should stay in range (0..1.0)
        if( m_sEnd > 1.0f )
            m_sEnd -= (int) m_sEnd;

        m_sStart = m_sEnd;
        s_delta = (length / m_sLength );
        m_sEnd = m_sStart + s_delta;
        
        // the texture ctrl point array can be calc'd here - it is always
        // a simple 2x2 array for each section
        m_pEval->SetTextureControlPoints( m_sStart, m_sEnd, m_tStart, m_tEnd );
    }
}




//-----------------------------------------------------------------------------
// Name: relDir
// Desc: this array tells you relative turn
//       format: relDir[lastDir][notchVec][newDir]
//-----------------------------------------------------------------------------
static int relDir[NUM_DIRS][NUM_DIRS][NUM_DIRS] = 
{
//      +x      -x      +y      -y      +z      -z (newDir)

// lastDir = +x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Y, MINUS_Y,
        iXX,    iXX,    MINUS_X,PLUS_X, MINUS_Y,PLUS_Y,
        iXX,    iXX,    MINUS_Y,PLUS_Y, PLUS_X, MINUS_X,
        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X,
// lastDir = -x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    PLUS_X, MINUS_X,MINUS_Y,PLUS_Y,
        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Y, MINUS_Y,
        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,
        iXX,    iXX,    MINUS_Y,PLUS_Y, MINUS_X,PLUS_X,

// lastDir = +y
        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y,
        MINUS_X,PLUS_X, iXX,    iXX,    PLUS_Y, MINUS_Y,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_X, MINUS_X,
        MINUS_Y,PLUS_Y, iXX,    iXX,    MINUS_X,PLUS_X,
// lastDir = -y
        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y,
        MINUS_X,PLUS_X, iXX,    iXX,    MINUS_Y,PLUS_Y,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_X, MINUS_X,
        PLUS_Y, MINUS_Y,iXX,    iXX,    MINUS_X,PLUS_X,

// lastDir = +z
        PLUS_X, MINUS_X,PLUS_Y, MINUS_Y,iXX,    iXX,
        MINUS_X,PLUS_X, MINUS_Y,PLUS_Y, iXX,    iXX,
        MINUS_Y,PLUS_Y, PLUS_X, MINUS_X,iXX,    iXX,
        PLUS_Y, MINUS_Y,MINUS_X,PLUS_X, iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
// lastDir = -z
        PLUS_X, MINUS_X,MINUS_Y,PLUS_Y, iXX,    iXX,
        MINUS_X,PLUS_X, PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,iXX,    iXX,
        MINUS_Y,PLUS_Y, MINUS_X,PLUS_X, iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX
};




//-----------------------------------------------------------------------------
// Name: GetRelativeDir 
// Desc: Calculates relative direction of turn from lastDir, notchVec, newDir
//          - Use look up table for now.
//          - Relative direction is from xy-plane, and can be +x,-x,+y,-y   
//          - In current orientation, +z is along lastDir, +x along notchVec
//-----------------------------------------------------------------------------
static int GetRelativeDir( int lastDir, int notchVec, int newDir )
{
    return( relDir[lastDir][notchVec][newDir] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\fstate.h ===
//-----------------------------------------------------------------------------
// File: fstate.h
//
// Desc: FLEX_STATE
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __fstate_h__
#define __fstate_h__

class PIPE;
class STATE;


//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class FLEX_STATE 
{
public:
    int             m_scheme;         // current drawing scheme (right now this
                                    // is a per-frame thing)
    STATE*          m_pMainState;       

    FLEX_STATE( STATE *pState );
    PIPE*           NewPipe( STATE *pState );
    void            Reset();
    BOOL            OKToUseChase();
    int             GetMaxPipesPerFrame();
};

#endif // __fstate_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\eval.cpp ===
//-----------------------------------------------------------------------------
// File: eval.cpp
//
// Desc: EVAL class
//       Evaluator composed of one or more sections that are evaluated
//       separately with OpenGL evaluators
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"

typedef enum 
{
    X_PLANE = 0,
    Y_PLANE,
    Z_PLANE
};

#define EVAL_VSIZE 3  // vertex size in floats

#define TMAJOR_ORDER 2
#define TMINOR_ORDER 2

#define VDIM 3
#define TDIM 2

static void RotatePointSet( D3DXVECTOR3 *inPts, int numPts, float angle, int dir, 
                      float radius, D3DXVECTOR3 *outPts );
static void ExtrudePointSetDir( D3DXVECTOR3 *inPts, int numPts, float *acPts, 
                      int dir, D3DXVECTOR3 *outPts );




//-----------------------------------------------------------------------------
// Name: EVAL
// Desc: Evaluator constructor
//-----------------------------------------------------------------------------
EVAL::EVAL( BOOL bTex )
{
    m_bTexture = bTex; 

    // Allocate points buffer

    //mf: might want to use less than max in some cases
    int size = MAX_USECTIONS * MAX_UORDER * MAX_VORDER * sizeof(D3DXVECTOR3);
    m_pts = (D3DXVECTOR3 *) LocalAlloc( LMEM_FIXED, size );
    assert( m_pts != NULL && "EVAL constructor\n" );
    
    // Alloc texture points buffer
    if( m_bTexture ) 
    {
        size = MAX_USECTIONS * TEX_ORDER * TEX_ORDER * sizeof(TEX_POINT2D);
        m_texPts = (TEX_POINT2D *) LocalAlloc( LMEM_FIXED, size );
        assert( m_texPts != NULL && "EVAL constructor\n" );
    }
    
    ResetEvaluator( m_bTexture );
}




//-----------------------------------------------------------------------------
// Name: ~EVAL
// Desc: Evaluator destructor
//-----------------------------------------------------------------------------
EVAL::~EVAL( )
{
    LocalFree( m_pts );
    if( m_bTexture )
        LocalFree( m_texPts );
}




//-----------------------------------------------------------------------------
// Name: Reset
// Desc: Reset evaluator to generate 3d vertices and vertex normals
//-----------------------------------------------------------------------------
void ResetEvaluator( BOOL bTexture )
{
/*
    if( bTexture ) 
    {
        glEnable( GL_MAP2_TEXTURE_COORD_2 );
    }

    glEnable( GL_MAP2_VERTEX_3 );
    glEnable( GL_AUTO_NORMAL );
    glFrontFace( GL_CW ); // cuz
*/

    // mf: !!! if mixing Normal and Flex, have to watch out for this, cuz normal
    // needs CCW
}




//-----------------------------------------------------------------------------
// Name: SetTextureControlPoints
// Desc: Set texture control point net
//       
//       This sets up 'numSections' sets of texture coordinate control points, based
//       on starting and ending s and t values.
//       
//       s coords run along pipe direction, t coords run around circumference
//-----------------------------------------------------------------------------
void EVAL::SetTextureControlPoints( float s_start, float s_end, 
                                    float t_start, float t_end )
{
    int i;
    TEX_POINT2D *ptexPts = m_texPts;
    float t_delta = (t_end - t_start) / m_numSections;
    float t = t_start;

    // calc ctrl pts for each quadrant
    for( i = 0; i < m_numSections; i++, ptexPts += (TDIM*TDIM) ) 
    {
        // s, t coords
        ptexPts[0].t = ptexPts[2].t = t;
        t += t_delta;
        ptexPts[1].t = ptexPts[3].t = t;
        ptexPts[0].s = ptexPts[1].s = s_start;
        ptexPts[2].s = ptexPts[3].s = s_end;
    } 
}




//-----------------------------------------------------------------------------
// Name: SetVertexCtrlPtsXCTranslate
// Desc: Builds 3D control eval control net from 2 xcObjs displaced along the
//       z-axis by 'length'.
//       
//       First xc used to generate points in z=0 plane.
//       Second xc generates points in z=length plane.
//       ! Replicates the last point around each u.
//-----------------------------------------------------------------------------
void EVAL::SetVertexCtrlPtsXCTranslate( D3DXVECTOR3 *pts, float length, 
                                        XC *xcStart, XC *xcEnd )
{
    int i;
    D3DXVECTOR2 *ptsStart, *ptsEnd;
    D3DXVECTOR3 *pts1, *pts2;
    int     numPts = xcStart->m_numPts;

    numPts++;  // due to last point replication

    ptsStart = xcStart->m_pts;
    ptsEnd   = xcEnd->m_pts;
    pts1     = pts;
    pts2     = pts + numPts;

    for( i = 0; i < (numPts-1); i++, pts1++, pts2++ ) 
    {
        // copy over x,y from each xc
        *( (D3DXVECTOR2 *) pts1) = *ptsStart++;
        *( (D3DXVECTOR2 *) pts2) = *ptsEnd++;
        // set z for each
        pts1->z = 0.0f;
        pts2->z = length;
    }

    // Replicate last point in each u-band
    *pts1 = *pts;
    *pts2 = *(pts + numPts);
}




//-----------------------------------------------------------------------------
// Name: ProcessXCPrimLinear
// Desc: Processes a prim according to evaluator data
//       - Only valid for colinear xc's (along z)
//       - XC's may be identical (extrusion).  If not identical, may have
//         discontinuities at each end.
//       - Converts 2D XC pts to 3D pts
//-----------------------------------------------------------------------------
void EVAL::ProcessXCPrimLinear( XC *xcStart, XC *xcEnd, float length )
{
    if( length <= 0.0f )
        // nuttin' to do
        return;

    // Build a vertex control net from 2 xcObj's a distance 'length' apart
    // this will displace the end xcObj a distance 'length' down the z-axis
    SetVertexCtrlPtsXCTranslate( m_pts, length, xcStart, xcEnd );

    Evaluate( );
}




//-----------------------------------------------------------------------------
// Name: ProcessXCPrimBendSimple
// Desc: Processes a prim by bending along dir from xcCur
//       - dir is relative from xc in x-y plane
//       - adds C2 continuity at ends
//-----------------------------------------------------------------------------
void EVAL::ProcessXCPrimBendSimple( XC *xcCur, int dir, float radius )
{
    D3DXVECTOR3 *ptsSrc, *ptsDst;
    static float acPts[MAX_XC_PTS+1];
    int ptSetStride = xcCur->m_numPts + 1; // pt stride for output pts buffer

    // We will be creating 4 cross-sectional control point sets here.

    // Convert 2D pts in xcCur to 3D pts at z=0 for 1st point set
    xcCur->ConvertPtsZ( m_pts, 0.0f );

    // Calc 4th point set by rotating 1st set as per dir
    ptsDst = m_pts + 3*ptSetStride;
    RotatePointSet( m_pts, ptSetStride, 90.0f, dir, radius, ptsDst );

    // angles != 90, hard, cuz not easy to extrude 3rd set from 4th

    // Next, have to figure out ac values.  Need to extend each xc's points
    // into bend to generate ac net.  For circular bend (and later for general
    // case elliptical bend), need to know ac distance from xc for each point.
    // This is based on the point's turn radius - a function of its distance
    // from the 'hinge' of the turn.

    // Can take advantage of symmetry here.  Figure for one xc, good for 2nd.
    // This assumes 90 deg turn.  (also,last point replicated)
    xcCur->CalcArcACValues90( dir, radius, acPts );
    
    // 2) extrude each point's ac from xcCur (extrusion in +z)
    // apply values to 1st to get 2nd
    // MINUS_Z, cuz subtracts *back* from dir
    ExtrudePointSetDir( m_pts, ptSetStride, acPts, MINUS_Z, 
                                                    m_pts + ptSetStride );

    // 3) extrude each point's ac from xcEnd (extrusion in -dir)
    ptsSrc = m_pts + 3*ptSetStride;
    ptsDst = m_pts + 2*ptSetStride;
    ExtrudePointSetDir( ptsSrc, ptSetStride, acPts, dir, ptsDst );

    Evaluate();
}




//-----------------------------------------------------------------------------
// Name: EVAL::ProcessXCPrimSingularity
// Desc: Processes a prim by joining singularity to an xc
//       - Used for closing or opening the pipe
//       - If bOpening is true, starts with singularity, otherwise ends with one
//       - the xc side is always in z=0 plane
//       - singularity side is radius on either side of xc
//       - adds C2 continuity at ends (perpendicular to +z at singularity end)
//-----------------------------------------------------------------------------
void EVAL::ProcessXCPrimSingularity( XC *xcCur, float length, BOOL bOpening )
{
    D3DXVECTOR3 *ptsSing, *ptsXC;
    static float acPts[MAX_XC_PTS+1];
    float zSing; // z-value at singularity
    int ptSetStride = xcCur->m_numPts + 1; // pt stride for output pts buffer
    int i;
    XC xcSing(xcCur);

    // create singularity xc - which is an extremely scaled-down version
    //  of xcCur (this prevents any end-artifacts, unless of course we were
    //  to zoom it ultra-large).

    xcSing.Scale( .0005f );

    // We will be creating 4 cross-sectional control point sets here.
    // mf: 4 is like hard coded; what about for different xc component levels ?

    if( bOpening ) 
    {
        ptsSing = m_pts;
        ptsXC = m_pts + 3*ptSetStride;
    } 
    else 
    {
        ptsSing = m_pts + 3*ptSetStride;
        ptsXC = m_pts;
    }

    // Convert 2D pts in xcCur to 3D pts at 'xc' point set
    xcCur->ConvertPtsZ( ptsXC, 0.0f );

    // Set z-value for singularity point set
    zSing = bOpening ? -length : length;
    xcSing.ConvertPtsZ( ptsSing, zSing );

    // The arc control for each point is based on a radius value that is
    //  each xc point's distance from the xc center
    xcCur->CalcArcACValuesByDistance( acPts );

    // Calculate point set near xc
    if( bOpening )
        ExtrudePointSetDir( ptsXC, ptSetStride, acPts, PLUS_Z, 
                                                    ptsXC - ptSetStride );
    else
        ExtrudePointSetDir( ptsXC, ptSetStride, acPts, MINUS_Z, 
                                                    ptsXC + ptSetStride );

    // Point set near singularity is harder, as the points must generate
    // a curve between the singularity and each xc point
    // No, easier, just scale each point by universal arc controller !
    D3DXVECTOR3* ptsDst = m_pts;
    ptsDst = bOpening ? ptsSing + ptSetStride : ptsSing - ptSetStride;
    for( i = 0; i < ptSetStride; i ++, ptsDst++ ) 
    {
        ptsDst->x = EVAL_CIRC_ARC_CONTROL * ptsXC[i].x;
        ptsDst->y = EVAL_CIRC_ARC_CONTROL * ptsXC[i].y;
        ptsDst->z = zSing;
    }

    Evaluate();
}




//-----------------------------------------------------------------------------
// Name: Evaluate
// Desc: Evaluates the EVAL object
//       - There may be 1 or more lengthwise sections around an xc
//       - u is minor, v major
//       - u,t run around circumference, v,s lengthwise
//       - Texture maps are 2x2 for each section
//       - ! uDiv is per section !
//-----------------------------------------------------------------------------
void EVAL::Evaluate()
{
    int i;
    D3DXVECTOR3 *ppts = m_pts; 
    TEX_POINT2D *ptexPts = m_texPts;
    // total # pts in cross-section:
    int xcPointCount = (m_uOrder-1)*m_numSections + 1;

    for( i = 0; i < m_numSections; i ++, 
                                 ppts += (m_uOrder-1),
                                 ptexPts += (TEX_ORDER*TEX_ORDER) ) 
    {
/*
        // map texture coords
        if( bTexture ) 
        {
            glMap2f(GL_MAP2_TEXTURE_COORD_2, 
                    0.0f, 1.0f, TDIM, TEX_ORDER, 
                    0.0f, 1.0f, TEX_ORDER*TDIM, TEX_ORDER, 
                    (float *) ptexPts );
        }

        // map vertices
        glMa
        
          p2f(GL_MAP2_VERTEX_3, 
               0.0f, 1.0f, VDIM, uOrder, 
               0.0f, 1.0f, xcPointCount*VDIM, vOrder,
               (float *) ppts );

        // evaluate
        glMapGrid2f(uDiv, 0.0f, 1.0f, ``vDiv, 0.0f, 1.0f);
        glEvalMesh2( GL_FILL, 0, uDiv, 0, vDiv);
*/
    }
}




//-----------------------------------------------------------------------------
// Name: ExtrudePointSetDir
// Desc: Extrude a point set back from the current direction
//       Generates C2 continuity at the supplied point set xc, by generating another
//       point set back of the first, using supplied subtraction values.
//-----------------------------------------------------------------------------
static void ExtrudePointSetDir( D3DXVECTOR3 *inPts, int numPts, float *acPts, int dir, 
                                D3DXVECTOR3 *outPts )
{
    int i;
    float sign;
    int offset;

    switch( dir ) 
    {
        case PLUS_X:
            offset = 0;
            sign = -1.0f;
            break;
        case MINUS_X:
            offset = 0;
            sign =  1.0f;
            break;
        case PLUS_Y:
            offset = 1;
            sign = -1.0f;
            break;
        case MINUS_Y:
            offset = 1;
            sign =  1.0f;
            break;
        case PLUS_Z:
            offset = 2;
            sign = -1.0f;
            break;
        case MINUS_Z:
            offset = 2;
            sign =  1.0f;
            break;
    }

    for( i = 0; i < numPts; i++, inPts++, outPts++, acPts++ ) 
    {
        *outPts = *inPts;
        ((float *)outPts)[offset] = ((float *)inPts)[offset] + (sign * (*acPts));
    }
}




//-----------------------------------------------------------------------------
// Name: RotatePointSet
// Desc: Rotate point set by angle, according to dir and radius
//       - Put points in supplied outPts buffer
//-----------------------------------------------------------------------------
static void RotatePointSet( D3DXVECTOR3 *inPts, int numPts, float angle, int dir, 
                            float radius, D3DXVECTOR3 *outPts )
{
    D3DXMATRIX matrix1, matrix2, matrix3;
    int i;
    D3DXVECTOR3 rot = D3DXVECTOR3(0, 0, 0);
    D3DXVECTOR3 anchor = D3DXVECTOR3(0, 0, 0);

    //  dir      rot
    //  +x       90 y
    //  -x       -90 y
    //  +y       -90 x
    //  -y       90 x

    // convert angle to radians
    //mf: as noted in objects.c, we have to take negative angle to make
    // it work in familiar 'CCW rotation is positive' mode.  The ss_* rotate
    // routines must work in the 'CW is +'ve' mode, as axis pointing at you.
    angle = SS_DEG_TO_RAD(-angle);

    // set axis rotation and anchor point
    switch( dir ) 
    {
        case PLUS_X:
            rot.y = angle;
            anchor.x = radius;
            break;
        case MINUS_X:
            rot.y = -angle;
            anchor.x = -radius;
            break;
        case PLUS_Y:
            rot.x = -angle;
            anchor.y = radius;
            break;
        case MINUS_Y:
            rot.x = angle;
            anchor.y = -radius;
            break;
    }

    // translate anchor point to origin
    D3DXMatrixIdentity( &matrix1 );
    D3DXMatrixTranslation( &matrix1, -anchor.x, -anchor.y, -anchor.z );

    // rotate 
    D3DXMatrixIdentity( &matrix2 );
    D3DXMatrixRotationYawPitchRoll( &matrix2, rot.y, rot.x, rot.z ); // TODO: right?

    // concat these 2
    D3DXMatrixMultiply( &matrix3, &matrix2, &matrix1 );

    // translate back
    D3DXMatrixIdentity( &matrix2 );
    D3DXMatrixTranslation( &matrix2,  anchor.x,  anchor.y,  anchor.z );

    // concat these 2
    D3DXMatrixMultiply( &matrix1, &matrix2, &matrix3 );

    for( i = 0; i < numPts; i ++, outPts++, inPts++ ) 
    {
        // D3DXVec3TransformCoord( &tmp, inPts, &matrix1 ); // TODO: which?

        D3DXVECTOR4 tmp;
        D3DXVec3Transform( &tmp, inPts, &matrix1 );
        outPts->x = tmp.x;
        outPts->y = tmp.y;
        outPts->z = tmp.z;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\npipe.h ===
//-----------------------------------------------------------------------------
// File: npipe.h
//
// Desc: Normal pipes code
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __npipe_h__
#define __npipe_h__

class NORMAL_STATE;


//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class NORMAL_PIPE : public PIPE 
{
public:
    NORMAL_STATE* m_pNState;

    NORMAL_PIPE( STATE *state );
    void        Start();
    int         ChooseElbow( int oldDir, int newDir);
    void        DrawJoint( int newDir );
    void        Draw( ); //mf: could take param to draw n sections
    void        DrawStartCap( int newDir );
    void        DrawEndCap();
    void        align_plusy( int oldDir, int newDir );
    void        align_notch( int newDir, int notch );
};


#endif // __npipe_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\node.h ===
//-----------------------------------------------------------------------------
// File: node.h
//
// Desc: Node stuff
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __node_h__
#define __node_h__

#define NUM_NODE (NUM_DIV - 1)  // num nodes in longest dimension

// maximum weighting of going straight for direction choosing functions
#define MAX_WEIGHT_STRAIGHT 100




//-----------------------------------------------------------------------------
// Name: Node class
// Desc: 
//-----------------------------------------------------------------------------
class Node 
{
public:
    void        MarkAsTaken() { m_empty = FALSE; }
    void        MarkAsEmpty() { m_empty = TRUE; }
    BOOL        IsEmpty() { return m_empty; }
private:
    BOOL        m_empty;
};




//-----------------------------------------------------------------------------
// Name: Node array class
// Desc: - 3d array of nodes
//       - Functions to access node neighbours, query if taken or not, etc. 
//       - Not only is this the node array, but a set of methods that operates on it
//-----------------------------------------------------------------------------
class NODE_ARRAY 
{
public:
    NODE_ARRAY();
    ~NODE_ARRAY();
    void        Resize( IPOINT3D *pNewSize ); // new array size
    void        Reset();       // set all nodes to empty
    int         ChooseRandomDirection( IPOINT3D *pos, int dir, int weight );
    int         ChoosePreferredDirection( IPOINT3D *pos, int dir, int *prefDirs,
                                          int nPrefDirs );
    int         ChooseNewTurnDirection( IPOINT3D *pos, int dir );
    int         FindClearestDirection( IPOINT3D *pos );
    int         GetBestPossibleTurns( IPOINT3D *pos, int dir, int *turnDirs );
    BOOL        FindRandomEmptyNode( IPOINT3D *ip3dEmpty );
    BOOL        FindRandomEmptyNode2D( IPOINT3D *pos, int plane, int *box );
    BOOL        TakeClosestEmptyNode( IPOINT3D *newPos, IPOINT3D *pos );
    void        NodeVisited( IPOINT3D *pos );
    void        GetNodeCount( IPOINT3D *pos );

private:
    Node*       m_nodes;         // ptr to node array
    int         m_lock;          // semaphore lock for >1 drawing pipes
    IPOINT3D    m_numNodes;      // x,y,z dimensions of node array
    int         m_nodeDirInc[NUM_DIRS]; // array offset between nodes for each dir

    void        GetNeighbours( IPOINT3D *pos, Node **nNode );
    Node*       GetNode( IPOINT3D *pos );
    Node*       GetNextNode( IPOINT3D *pos, int dir );
    BOOL        GetNextNodePos( IPOINT3D *curPos, IPOINT3D *nextPos, int dir );
    int         GetEmptyNeighbours( Node **nNode, int *nEmpty ); 
    int         GetEmptyTurnNeighbours( Node **nNode, int *nEmpty, int lastDir ); 
    int         GetEmptyNeighboursAlongDir( IPOINT3D *pos, int dir,
                                            int searchRadius );
};


#endif // __node_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\npipe.cpp ===
//-----------------------------------------------------------------------------
// File: npipe.cpp
//
// Desc: Normal pipes code
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"


static void align_notch( int newDir, int notch );
static void align_plusy( int oldDir, int newDir );

// defCylNotch shows where the notch for the default cylinder will be,
//  in absolute coords, once we do an align_plusz
static int defCylNotch[NUM_DIRS] = 
        { PLUS_Y, PLUS_Y, MINUS_Z, PLUS_Z, PLUS_Y, PLUS_Y };




//-----------------------------------------------------------------------------
// Name: NORMAL_PIPE constructor
// Desc: 
//-----------------------------------------------------------------------------
NORMAL_PIPE::NORMAL_PIPE( STATE *pState ) : PIPE( pState )
{
    m_type = TYPE_NORMAL;
    m_pNState = pState->m_pNState;

    // choose weighting of going straight
    if( ! CPipesScreensaver::iRand( 20 ) )
        m_weightStraight = CPipesScreensaver::iRand2( MAX_WEIGHT_STRAIGHT/4, MAX_WEIGHT_STRAIGHT );
    else
        m_weightStraight = 1 + CPipesScreensaver::iRand( 4 );
}




//-----------------------------------------------------------------------------
// Name: Start
// Desc: Start drawing a new normal pipe
//       - Draw a start cap and short pipe in new direction
//-----------------------------------------------------------------------------
void NORMAL_PIPE::Start()
{
    int newDir;

    // Set start position
    if( !SetStartPos() ) 
    {
        m_status = PIPE_OUT_OF_NODES;
        return;
    }

    // set a material
    ChooseMaterial();

    m_pState->m_pd3dDevice->SetTexture( 0, m_pState->m_textureInfo[0].pTexture );
    m_pState->m_pd3dDevice->SetMaterial( m_pMat );

    // push matrix that has initial zTrans and rotation
    m_pWorldMatrixStack->Push();

    // Translate to current position
    TranslateToCurrentPosition();

    // Pick a random lastDir
    m_lastDir = CPipesScreensaver::iRand( NUM_DIRS );

    newDir = ChooseNewDirection();

    if( newDir == DIR_NONE ) 
    {
        // pipe is stuck at the start node, draw nothing
        m_status = PIPE_STUCK;
        m_pWorldMatrixStack->Pop();
        return;
    } 
    else
    {
        m_status = PIPE_ACTIVE;
    }

    // set initial notch vector
    m_notchVec = defCylNotch[newDir];

    DrawStartCap( newDir );

    // move ahead 1.0*r to draw pipe
    m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, m_radius );
            
    // draw short pipe
    align_notch( newDir, m_notchVec );
    m_pNState->m_pShortPipe->Draw( m_pWorldMatrixStack->GetTop() );

    m_pWorldMatrixStack->Pop();

    UpdateCurrentPosition( newDir );

    m_lastDir = newDir;
}




//-----------------------------------------------------------------------------
// Name: Draw
// Desc: - if turning, draws a joint and a short cylinder, otherwise
//         draws a long cylinder.
//       - the 'current node' is set as the one we draw thru the NEXT
//         time around.
//-----------------------------------------------------------------------------
void NORMAL_PIPE::Draw()
{
    int newDir;

    m_pState->m_pd3dDevice->SetTexture( 0, m_pState->m_textureInfo[0].pTexture );
    m_pState->m_pd3dDevice->SetMaterial( m_pMat );

    newDir = ChooseNewDirection();

    if( newDir == DIR_NONE ) 
    {  
        // no empty nodes - nowhere to go
        DrawEndCap();
        m_status = PIPE_STUCK;
        return;
    }

    // push matrix that has initial zTrans and rotation
    m_pWorldMatrixStack->Push();

    // Translate to current position
    TranslateToCurrentPosition();

    // draw joint if necessary, and pipe
    if( newDir != m_lastDir ) 
    { 
        // turning! - we have to draw joint
        DrawJoint( newDir );

        // draw short pipe
        align_notch( newDir, m_notchVec );
        m_pNState->m_pShortPipe->Draw( m_pWorldMatrixStack->GetTop() );
    }
    else 
    {  
        // no turn -- draw long pipe, from point 1.0*r back
        align_plusz( newDir );
        align_notch( newDir, m_notchVec );
        m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, -m_radius );
        m_pNState->m_pLongPipe->Draw( m_pWorldMatrixStack->GetTop() );
    }

    m_pWorldMatrixStack->Pop();

    UpdateCurrentPosition( newDir );

    m_lastDir = newDir;
}




//-----------------------------------------------------------------------------
// Name: DrawStartCap
// Desc: Cap the start of the pipe with a ball
//-----------------------------------------------------------------------------
void NORMAL_PIPE::DrawStartCap( int newDir )
{
    if( m_pState->m_bUseTexture ) 
    {
        align_plusz( newDir );
        m_pNState->m_pBallCap->Draw( m_pWorldMatrixStack->GetTop() );
    }
    else 
    {
        // draw big ball in default orientation
        m_pNState->m_pBigBall->Draw( m_pWorldMatrixStack->GetTop() );
        align_plusz( newDir );
    }
}




//-----------------------------------------------------------------------------
// Name: DrawEndCap():
// Desc: - Draws a ball, used to cap end of a pipe
//-----------------------------------------------------------------------------
void NORMAL_PIPE::DrawEndCap()
{
    m_pWorldMatrixStack->Push();

    // Translate to current position
    TranslateToCurrentPosition();

    if( m_pState->m_bUseTexture ) 
    {
        align_plusz( m_lastDir );
        align_notch( m_lastDir, m_notchVec );
        m_pNState->m_pBallCap->Draw( m_pWorldMatrixStack->GetTop() );
    }
    else
    {
        m_pNState->m_pBigBall->Draw( m_pWorldMatrixStack->GetTop() );
    }

    m_pWorldMatrixStack->Pop();
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: this array supplies the sequence of elbow notch vectors, given
//       oldDir and newDir  (0's are don't cares)
//       it is also used to determine the ending notch of an elbow
//-----------------------------------------------------------------------------
static int notchElbDir[NUM_DIRS][NUM_DIRS][4] = 
{
// oldDir = +x
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Y,         MINUS_Z,        MINUS_Y,        PLUS_Z,
        MINUS_Y,        PLUS_Z,         PLUS_Y,         MINUS_Z,
        PLUS_Z,         PLUS_Y,         MINUS_Z,        MINUS_Y,
        MINUS_Z,        MINUS_Y,        PLUS_Z,         PLUS_Y,
// oldDir = -x
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Y,         PLUS_Z,         MINUS_Y,        MINUS_Z,
        MINUS_Y,        MINUS_Z,        PLUS_Y,         PLUS_Z,
        PLUS_Z,         MINUS_Y,        MINUS_Z,        PLUS_Y,
        MINUS_Z,        PLUS_Y,         PLUS_Z,         MINUS_Y,

// oldDir = +y
        PLUS_X,         PLUS_Z,         MINUS_X,        MINUS_Z,
        MINUS_X,        MINUS_Z,        PLUS_X,         PLUS_Z,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Z,         MINUS_X,        MINUS_Z,        PLUS_X,
        MINUS_Z,        PLUS_X,         PLUS_Z,         MINUS_X,
// oldDir = -y
        PLUS_X,         MINUS_Z,        MINUS_X,        PLUS_Z,
        MINUS_X,        PLUS_Z,         PLUS_X,         MINUS_Z,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Z,         PLUS_X,         MINUS_Z,        MINUS_X,
        MINUS_Z,        MINUS_X,        PLUS_Z,         PLUS_X,

// oldDir = +z
        PLUS_X,         MINUS_Y,        MINUS_X,        PLUS_Y,
        MINUS_X,        PLUS_Y,         PLUS_X,         MINUS_Y,
        PLUS_Y,         PLUS_X,         MINUS_Y,        MINUS_X,
        MINUS_Y,        MINUS_X,        PLUS_Y,         PLUS_X,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
// oldDir = -z
        PLUS_X,         PLUS_Y,         MINUS_X,        MINUS_Y,
        MINUS_X,        MINUS_Y,        PLUS_X,         PLUS_Y,
        PLUS_Y,         MINUS_X,        MINUS_Y,        PLUS_X,
        MINUS_Y,        PLUS_X,         PLUS_Y,         MINUS_X,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX
};




//-----------------------------------------------------------------------------
// Name: ChooseElbow
// Desc: - Decides which elbow to draw
//       - The beginning of each elbow is aligned along +y, and we have
//         to choose the one with the notch in correct position
//       - The 'primary' start notch (elbow[0]) is in same direction as
//         newDir, and successive elbows rotate this notch CCW around +y
//-----------------------------------------------------------------------------
int NORMAL_PIPE::ChooseElbow( int oldDir, int newDir )
{
    int i;

    // precomputed table supplies correct elbow orientation
    for( i=0; i<4; i++ ) 
    {
        if( notchElbDir[oldDir][newDir][i] == m_notchVec )
            return i;
    }

    // we shouldn't arrive here
    return -1;
}




//-----------------------------------------------------------------------------
// Name: DrawJoint
// Desc: Draw a joint between 2 pipes
//-----------------------------------------------------------------------------
void NORMAL_PIPE::DrawJoint( int newDir )
{
    int jointType;
    int iBend;
    
    jointType = m_pNState->ChooseJointType();
#if PIPES_DEBUG
    if( newDir == oppositeDir[lastDir] )
        OutputDebugString( "Warning: opposite dir chosen!\n" );
#endif
    
    switch( jointType ) 
    {
        case BALL_JOINT:
        {
            if( m_pState->m_bUseTexture ) 
            {
                // use special texture-friendly ballJoints           
                align_plusz( newDir );
                m_pWorldMatrixStack->Push();
            
                align_plusy( m_lastDir, newDir );
            
                // translate forward 1.0*r along +z to get set for drawing elbow
                m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, m_radius );

                // decide which elbow orientation to use
                iBend = ChooseElbow( m_lastDir, newDir );
                m_pNState->m_pBallJoints[iBend]->Draw( m_pWorldMatrixStack->GetTop() );
            
                m_pWorldMatrixStack->Pop();
            }
            else 
            {
                // draw big ball in default orientation
                m_pNState->m_pBigBall->Draw( m_pWorldMatrixStack->GetTop() );
                align_plusz( newDir );
            }

            // move ahead 1.0*r to draw pipe
            m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, m_radius );
            break;
        }
        
        case ELBOW_JOINT:
        default:
        {
            align_plusz( newDir );

            // the align_plusy() here will mess up 
            // our notch calcs, so we push-pop        
            m_pWorldMatrixStack->Push();
        
            align_plusy( m_lastDir, newDir );
        
            // translate forward 1.0*r along +z to get set for drawing elbow
            m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, m_radius );

            // decide which elbow orientation to use
            iBend = ChooseElbow( m_lastDir, newDir );
            if( iBend == -1 ) 
            {
#if PIPES_DEBUG
                OutputDebugString( "Bad result from ChooseElbow()\n" );
#endif
                iBend = 0; // recover
            }
            m_pNState->m_pElbows[iBend]->Draw( m_pWorldMatrixStack->GetTop() );
        
            m_pWorldMatrixStack->Pop();
       
            m_pWorldMatrixStack->TranslateLocal( 0.0f, 0.0f, m_radius );
            break;
        }
    }
    
    // update the current notch vector
    m_notchVec = notchTurn[m_lastDir][newDir][m_notchVec];
    
#if PIPES_DEBUG
    if( m_notchVec == iXX )
        OutputDebugString( "notchTurn gave bad value\n" );
#endif
}




//-----------------------------------------------------------------------------
// Name: align_plusy
// Desc: - Assuming +z axis is already aligned with newDir, align        
//         +y axis BACK along lastDir                                    
//-----------------------------------------------------------------------------
void NORMAL_PIPE::align_plusy( int oldDir, int newDir )
{
    static D3DXVECTOR3 zAxis = D3DXVECTOR3(0.0f,0.0f,1.0f);
    static float RotZ[NUM_DIRS][NUM_DIRS] = 
    {
              0.0f,   0.0f,  90.0f,  90.0f,  90.0f, -90.0f,
              0.0f,   0.0f, -90.0f, -90.0f, -90.0f,  90.0f,
            180.0f, 180.0f,   0.0f,   0.0f, 180.0f, 180.0f,
              0.0f,   0.0f,   0.0f,   0.0f,   0.0f,   0.0f,
            -90.0f,  90.0f,   0.0f, 180.0f,   0.0f,   0.0f,
             90.0f, -90.0f, 180.0f,   0.0f,   0.0f,   0.0f 
    };

    float rotz = RotZ[oldDir][newDir];
    if( rotz != 0.0f )
        m_pWorldMatrixStack->RotateAxisLocal( &zAxis, SS_DEG_TO_RAD(rotz) );
}




//-----------------------------------------------------------------------------
// Name: align_notch
// Desc: - a cylinder is notched, and we have to line this up            
//         with the previous primitive's notch which is maintained as    
//         notchVec.                                                     
//         - this adds a rotation around z to achieve this                
//-----------------------------------------------------------------------------
void NORMAL_PIPE::align_notch( int newDir, int notch )
{
    float rotz;
    int curNotch;

    // figure out where notch is presently after +z alignment
    curNotch = defCylNotch[newDir];
    // (don't need this now we have lut)

    // given a dir, determine how much to rotate cylinder around z to match notches
    // format is [newDir][notchVec]
    static float alignNotchRot[NUM_DIRS][NUM_DIRS] = 
    {
            fXX,    fXX,    0.0f,   180.0f,  90.0f, -90.0f,
            fXX,    fXX,    0.0f,   180.0f,  -90.0f, 90.0f,
            -90.0f, 90.0f,  fXX,    fXX,    180.0f, 0.0f,
            -90.0f, 90.0f,  fXX,    fXX,    0.0f,   180.0f,
            -90.0f, 90.0f,  0.0f,   180.0f, fXX,    fXX,
            90.0f,  -90.0f, 0.0f,   180.0f, fXX,    fXX
    };

    // look up rotation value in table
    rotz = alignNotchRot[newDir][notch];

#if PIPES_DEBUG
    if( rotz == fXX ) 
    {
        printf( "align_notch(): unexpected value\n" );
        return;
    }
#endif

    static D3DXVECTOR3 zAxis = D3DXVECTOR3(0.0f,0.0f,1.0f);
    if( rotz != 0.0f )
        m_pWorldMatrixStack->RotateAxisLocal( &zAxis, SS_DEG_TO_RAD(rotz) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\nstate.h ===
//-----------------------------------------------------------------------------
// File: nstate.h
//
// Desc: NORMAL_STATE
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __nstate_h__
#define __nstate_h__

#define NORMAL_PIPE_COUNT       5
#define NORMAL_TEX_PIPE_COUNT   3
#define NUM_JOINT_STYLES        3


// styles for pipe joints
enum 
{
    ELBOWS = 0,
    BALLS,
    EITHER
};

// joint types
enum 
{
    ELBOW_JOINT = 0,
    BALL_JOINT
};

// shchemes for choosing directions
enum 
{
    NORMAL_SCHEME_CHOOSE_DIR_RANDOM,
    NORMAL_SCHEME_CHOOSE_DIR_TURN,
    NORMAL_SCHEME_CHOOSE_DIR_STRAIGHT
};

// this used for traditional pipe drawing
class PIPE_OBJECT;
class ELBOW_OBJECT;
class SPHERE_OBJECT;
class BALLJOINT_OBJECT;
class STATE;




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class NORMAL_STATE 
{
public:
    int                 m_jointStyle;
    int                 m_bCycleJointStyles;
    IDirect3DDevice8*   m_pd3dDevice;
    
    PIPE_OBJECT*        m_pShortPipe;
    PIPE_OBJECT*        m_pLongPipe;
    ELBOW_OBJECT*       m_pElbows[4];
    SPHERE_OBJECT*      m_pBallCap;
    SPHERE_OBJECT*      m_pBigBall;
    BALLJOINT_OBJECT*   m_pBallJoints[4];

    NORMAL_STATE( STATE *pState );
    ~NORMAL_STATE();

    void            Reset();
    void            BuildObjects( float radius, float divSize, int nSlices,
                                  BOOL bTexture, IPOINT2D *pTexRep );  
    int             ChooseJointType();
};

#endif // __nstate_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\objects.cpp ===
//-----------------------------------------------------------------------------
// File: objects.cpp
//
// Desc: Creates command lists for pipe primitive objects
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: OBJECT constructor
// Desc: 
//-----------------------------------------------------------------------------
OBJECT::OBJECT( IDirect3DDevice8* pd3dDevice )
{
    m_pd3dDevice = pd3dDevice;
    m_pVB = NULL;
    m_dwNumTriangles = 0;
}




//-----------------------------------------------------------------------------
// Name: OBJECT destructor
// Desc: 
//-----------------------------------------------------------------------------
OBJECT::~OBJECT( )
{
    SAFE_RELEASE( m_pVB );
}




//-----------------------------------------------------------------------------
// Name: Draw
// Desc: - Draw the object by calling its display list
//-----------------------------------------------------------------------------
void OBJECT::Draw( D3DXMATRIX* pWorldMat )
{
    if( m_pVB )
    {
        m_pd3dDevice->SetTransform( D3DTS_WORLD, pWorldMat );

        m_pd3dDevice->SetVertexShader( D3DFVF_VERTEX );
        m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(D3DVERTEX) );
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST,
                                     0, m_dwNumTriangles );
    }
}




//-----------------------------------------------------------------------------
// Name: PIPE_OBJECT constructors
// Desc: 
//-----------------------------------------------------------------------------
PIPE_OBJECT::PIPE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, float len ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, len, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
PIPE_OBJECT::PIPE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, float len, 
                          float s_start, float s_end ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, len, s_start, s_end );
}




//-----------------------------------------------------------------------------
// Name: ELBOW_OBJECT constructors
// Desc: 
//-----------------------------------------------------------------------------
ELBOW_OBJECT::ELBOW_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, 
                            int notch ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, notch, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
ELBOW_OBJECT::ELBOW_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, int notch, float s_start, float s_end ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, notch, s_start, s_end );
}




//-----------------------------------------------------------------------------
// Name: BALLJOINT_OBJECT constructor
// Desc: 
//-----------------------------------------------------------------------------
BALLJOINT_OBJECT::BALLJOINT_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, 
                                    int notch, float s_start, float s_end ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, notch, s_start, s_end );
}




//-----------------------------------------------------------------------------
// Name: SPHERE_OBJECT constructors
// Desc: 
//-----------------------------------------------------------------------------
SPHERE_OBJECT::SPHERE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, float radius ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, radius, 0.0f, 0.0f );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
SPHERE_OBJECT::SPHERE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *pBuildInfo, 
                              float radius, float s_start, float s_end ) : OBJECT(pd3dDevice)
{
    Build( pBuildInfo, radius, s_start, s_end );
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: rotate circle around x-axis, with edge attached to anchor
//-----------------------------------------------------------------------------
static void TransformCircle( float angle, D3DXVECTOR3 *inPoint, D3DXVECTOR3 *outPoint, 
                             int num, D3DXVECTOR3 *anchor )
{
    D3DXMATRIX matrix1, matrix2, matrix3;
    int i;

    // translate anchor point to origin
    D3DXMatrixIdentity( &matrix1 );
    D3DXMatrixTranslation( &matrix1, -anchor->x, -anchor->y, -anchor->z );

    // rotate by angle, cw around x-axis
    D3DXMatrixIdentity( &matrix2 );
    D3DXMatrixRotationYawPitchRoll( &matrix2, 0.0f, angle, 0.0f ); 

    // concat these 2
    D3DXMatrixMultiply( &matrix3, &matrix1, &matrix2  );

    // translate back
    D3DXMatrixIdentity( &matrix2 );
    D3DXMatrixTranslation( &matrix2,  anchor->x,  anchor->y,  anchor->z );

    // concat these 2
    D3DXMatrixMultiply( &matrix1, &matrix3, &matrix2  );

    // transform all the points, + center
    for( i = 0; i < num; i ++, outPoint++, inPoint++ ) 
    {
        D3DXVECTOR4 tmp;
        D3DXVec3Transform( &tmp, inPoint, &matrix1 );
        outPoint->x = tmp.x;
        outPoint->y = tmp.y;
        outPoint->z = tmp.z;
    }
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
static void CalcNormals( D3DXVECTOR3 *p, D3DXVECTOR3 *n, D3DXVECTOR3 *center,
                         int num )
{
    D3DXVECTOR3 vec;
    int i;

    for( i = 0; i < num; i ++, n++, p++ ) 
    {
        n->x = p->x - center->x;
        n->y = p->y - center->y;
        n->z = p->z - center->z;
        D3DXVec3Normalize( n, n );
    }
}




#define CACHE_SIZE      100     




//-----------------------------------------------------------------------------
// Name: BuildElbow
// Desc: - builds elbows, by rotating a circle in the y=r plane          
//         centered at (0,r,-r), CW around the x-axis at anchor pt.      
//         (r = radius of the circle)                                    
//         - rotation is 90.0 degrees, ending at circle in z=0 plane,     
//         centered at origin.                                           
//         - in order to 'mate' texture coords with the cylinders         
//         generated with glu, we generate 4 elbows, each corresponding  
//         to the 4 possible CW 90 degree orientations of the start point
//         for each circle.                                              
//         - We call this start point the 'notch'.  If we characterize    
//         each notch by the axis it points down in the starting and     
//         ending circles of the elbow, then we get the following axis   
//         pairs for our 4 notches:                                      
//              - +z,+y                                                 
//              - +x,+x                                                 
//              - -z,-y                                                 
//               - -x,-x                                                 
//         Since the start of the elbow always points down +y, the 4     
//         start notches give all possible 90.0 degree orientations      
//         around y-axis.                                                
//         - We can keep track of the current 'notch' vector to provide   
//         proper mating between primitives.                             
//         - Each circle of points is described CW from the start point,  
//         assuming looking down the +y axis(+y direction).              
//         - texture 's' starts at 0.0, and goes to 2.0*r/divSize at      
//         end of the elbow.  (Then a short pipe would start with this   
//         's', and run it to 1.0).                                      
//-----------------------------------------------------------------------------
void ELBOW_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, int notch, 
                          float s_start, float s_end )
{
    int   stacks, slices;
    float angle, startAng;
    int numPoints;
    float s_delta;
    D3DXVECTOR3 pi[CACHE_SIZE]; // initial row of points + center
    D3DXVECTOR3 p0[CACHE_SIZE]; // 2 rows of points
    D3DXVECTOR3 p1[CACHE_SIZE];
    D3DXVECTOR3 n0[CACHE_SIZE]; // 2 rows of normals
    D3DXVECTOR3 n1[CACHE_SIZE];
    float tex_t[CACHE_SIZE];// 't' texture coords
    float* curTex_t;
    float tex_s[2];  // 's' texture coords
    D3DXVECTOR3 center;  // center of circle
    D3DXVECTOR3 anchor;  // where circle is anchored
    D3DXVECTOR3* pA;
    D3DXVECTOR3* pB;
    D3DXVECTOR3* nA;
    D3DXVECTOR3* nB;

    D3DXVECTOR3* pTA;
    D3DXVECTOR3* pTB;
    D3DXVECTOR3* nTA;
    D3DXVECTOR3* nTB;

    int i,j;
    IPOINT2D* texRep = pBuildInfo->m_texRep;
    float radius = pBuildInfo->m_radius;

    slices = pBuildInfo->m_nSlices;
    stacks = slices / 2;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;

    s_delta = s_end - s_start;

    // calculate 't' texture coords
    if( texRep )
    {
        for( i = 0; i <= slices; i ++ ) 
        {
            tex_t[i] = (float) i * texRep->y / slices;
        }
    }

    numPoints = slices + 1;

    // starting angle increment 90.0 degrees each time
    startAng = notch * PI / 2;

    // calc initial circle of points for circle centered at 0,r,-r
    // points start at (0,r,0), and rotate circle CCW

    for( i = 0; i <= slices; i ++ ) 
    {
        angle = startAng + (2 * PI * i / slices);
        pi[i].x = radius * (float) sin(angle);
        pi[i].y = radius;
        // translate z by -r, cuz these cos calcs are for circle at origin
        pi[i].z = radius * (float) cos(angle) - radius;
    }

    // center point, tacked onto end of circle of points
    pi[i].x =  0.0f;
    pi[i].y =  radius;
    pi[i].z = -radius;
    center = pi[i];

    // anchor point
    anchor.x = anchor.z = 0.0f;
    anchor.y = radius;

    // calculate initial normals
    CalcNormals( pi, n0, &center, numPoints );

    // initial 's' texture coordinate
    tex_s[0] = s_start;

    // setup pointers
    pA = pi;
    pB = p0;
    nA = n0;
    nB = n1;

    DWORD dwNumQuadStripsPerStack = numPoints - 1;
    DWORD dwNumQuadStrips = dwNumQuadStripsPerStack * stacks;
    m_dwNumTriangles = dwNumQuadStrips * 2;
    DWORD dwNumVertices = m_dwNumTriangles * 3;
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(D3DVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_VERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
        return;

    D3DVERTEX* vQuad;
    D3DVERTEX* vCurQuad;
    vQuad = new D3DVERTEX[dwNumVertices];
    ZeroMemory( vQuad, sizeof(D3DVERTEX) * dwNumVertices );

    vCurQuad = vQuad;
    for( i = 1; i <= stacks; i ++ ) 
    {
        // ! this angle must be negative, for correct vertex orientation !
        angle = - 0.5f * PI * i / stacks;

        // transform to get next circle of points + center
        TransformCircle( angle, pi, pB, numPoints+1, &anchor );

        // calculate normals
        center = pB[numPoints];
        CalcNormals( pB, nB, &center, numPoints );

        // calculate next 's' texture coord
        tex_s[1] = (float) s_start + s_delta * i / stacks;

        curTex_t = tex_t;
        pTA = pA;
        pTB = pB;
        nTA = nA;
        nTB = nB;

        for (j = 0; j < numPoints; j++) 
        {
            vCurQuad->p = *pTA++;
            vCurQuad->n = *nTA++;
            if( texRep )
            {
                vCurQuad->tu = (float) tex_s[0];
                vCurQuad->tv = (float) *curTex_t;
            }
            vCurQuad++;

            vCurQuad->p = *pTB++;
            vCurQuad->n = *nTB++;
            if( texRep )
            {
                vCurQuad->tu = (float) tex_s[1];
                vCurQuad->tv = (float) *curTex_t++;
            }
            vCurQuad++;
        }

        // reset pointers
        pA = pB;
        nA = nB;
        pB = (pB == p0) ? p1 : p0;
        nB = (nB == n0) ? n1 : n0;
        tex_s[0] = tex_s[1];
    }

    D3DVERTEX* v;
    DWORD dwCurQuad = 0;
    DWORD dwVert = 0;

    m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );

    for (j = 0; j < stacks; j++) 
    {
        for (i = 0; i < numPoints; i++) 
        {
            if(  i==0 )
            {
                dwCurQuad++;
                continue;
            }

            // Vertices 2n-1, 2n, 2n+2, and 2n+1 define quadrilateral n
            DWORD dwTemp = dwCurQuad*2-1;

            v[dwVert++] = vQuad[dwTemp];
            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+2];

            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+1];
            v[dwVert++] = vQuad[dwTemp+2];

            dwCurQuad++;
        }
    }

    m_pVB->Unlock();

    SAFE_DELETE_ARRAY( vQuad );
}




//-----------------------------------------------------------------------------
// Name: BuildBallJoint
// Desc: - These are very similar to the elbows, in that the starting    
//         and ending positions are almost identical.   The difference   
//         here is that the circles in the sweep describe a sphere as    
//         they are rotated.                                            
//-----------------------------------------------------------------------------
void BALLJOINT_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, int notch, 
                              float s_start, float s_end )
{
    float ballRadius;
    float angle, delta_a, startAng, theta;
    int numPoints;
    float s_delta;
    D3DXVECTOR3 pi0[CACHE_SIZE]; // 2 circles of untransformed points
    D3DXVECTOR3 pi1[CACHE_SIZE];
    D3DXVECTOR3 p0[CACHE_SIZE]; // 2 rows of transformed points
    D3DXVECTOR3 p1[CACHE_SIZE];
    D3DXVECTOR3 n0[CACHE_SIZE]; // 2 rows of normals
    D3DXVECTOR3 n1[CACHE_SIZE];
    float   r[CACHE_SIZE];  // radii of the circles
    float tex_t[CACHE_SIZE];// 't' texture coords
    float tex_s[2];  // 's' texture coords
    D3DXVECTOR3 center;  // center of circle
    D3DXVECTOR3 anchor;  // where circle is anchored
    D3DXVECTOR3 *pA, *pB, *nA, *nB;
    float* curTex_t;
    D3DXVECTOR3* pTA;
    D3DXVECTOR3* pTB;
    D3DXVECTOR3* nTA;
    D3DXVECTOR3* nTB;
    int i, j, k;
    int   stacks, slices;
    IPOINT2D *texRep = pBuildInfo->m_texRep;
    float radius = pBuildInfo->m_radius;

    slices = pBuildInfo->m_nSlices;
    stacks = slices;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;

    // calculate the radii for each circle in the sweep, where
    // r[i] = y = sin(angle)/r

    angle = PI / 4;  // first radius always at 45.0 degrees
    delta_a = (PI / 2.0f) / stacks;

    ballRadius = ROOT_TWO * radius;
    for( i = 0; i <= stacks; i ++, angle += delta_a ) 
    {
        r[i] = (float) sin(angle) * ballRadius;
    }

    // calculate 't' texture coords
    for( i = 0; i <= slices; i ++ ) 
    {
        tex_t[i] = (float) i * texRep->y / slices;
    }

    s_delta = s_end - s_start;
 
    numPoints = slices + 1;

    // unlike the elbow, the center for the ball joint is constant
    center.x = center.y = 0.0f;
    center.z = -radius;

    // starting angle along circle, increment 90.0 degrees each time
    startAng = notch * PI / 2;

    // calc initial circle of points for circle centered at 0,r,-r
    // points start at (0,r,0), and rotate circle CCW

    delta_a = 2 * PI / slices;
    for( i = 0, theta = startAng; i <= slices; i ++, theta += delta_a ) 
    {
        pi0[i].x = r[0] * (float) sin(theta);
        pi0[i].y = radius;
        // translate z by -r, cuz these cos calcs are for circle at origin
        pi0[i].z = r[0] * (float) cos(theta) - r[0];
    }

    // anchor point
    anchor.x = anchor.z = 0.0f;
    anchor.y = radius;

    // calculate initial normals
    CalcNormals( pi0, n0, &center, numPoints );

    // initial 's' texture coordinate
    tex_s[0] = s_start;

    // setup pointers
    pA = pi0; // circles of transformed points
    pB = p0;
    nA = n0; // circles of transformed normals
    nB = n1;

    DWORD dwNumQuadStripsPerStack = numPoints - 1;
    DWORD dwNumQuadStrips = dwNumQuadStripsPerStack * stacks;
    m_dwNumTriangles = dwNumQuadStrips * 2;
    DWORD dwNumVertices = m_dwNumTriangles * 3;
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(D3DVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_VERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
        return;

    D3DVERTEX* vQuad;
    D3DVERTEX* vCurQuad;
    vQuad = new D3DVERTEX[dwNumVertices];
    ZeroMemory( vQuad, sizeof(D3DVERTEX) * dwNumVertices );

    vCurQuad = vQuad;
    for( i = 1; i <= stacks; i ++ ) 
    {
        // ! this angle must be negative, for correct vertex orientation !
        angle = - 0.5f * PI * i / stacks;

        for( k = 0, theta = startAng; k <= slices; k ++, theta+=delta_a ) 
        {
            pi1[k].x = r[i] * (float) sin(theta);
            pi1[k].y = radius;
            // translate z by -r, cuz calcs are for circle at origin
            pi1[k].z = r[i] * (float) cos(theta) - r[i];
        }

        // transform to get next circle of points + center
        TransformCircle( angle, pi1, pB, numPoints, &anchor );

        // calculate normals
        CalcNormals( pB, nB, &center, numPoints );

        // calculate next 's' texture coord
        tex_s[1] = (float) s_start + s_delta * i / stacks;

        curTex_t = tex_t;
        pTA = pA;
        pTB = pB;
        nTA = nA;
        nTB = nB;

        for (j = 0; j < numPoints; j++) 
        {
            vCurQuad->p = *pTA++;
            vCurQuad->n = *nTA++;
            if( texRep )
            {
                vCurQuad->tu = (float) tex_s[0];
                vCurQuad->tv = (float) *curTex_t;
            }
            vCurQuad++;

            vCurQuad->p = *pTB++;
            vCurQuad->n = *nTB++;
            if( texRep )
            {
                vCurQuad->tu = (float) tex_s[1];
                vCurQuad->tv = (float) *curTex_t++;
            }
            vCurQuad++;
        }

        // reset pointers
        pA = pB;
        nA = nB;
        pB = (pB == p0) ? p1 : p0;
        nB = (nB == n0) ? n1 : n0;
        tex_s[0] = tex_s[1];
    }

    D3DVERTEX* v;
    DWORD dwCurQuad = 0;
    DWORD dwVert = 0;

    m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );

    for (j = 0; j < stacks; j++) 
    {
        for (i = 0; i < numPoints; i++) 
        {
            if(  i==0 )
            {
                dwCurQuad++;
                continue;
            }

            // Vertices 2n-1, 2n, 2n+2, and 2n+1 define quadrilateral n
            DWORD dwTemp = dwCurQuad*2-1;

            v[dwVert++] = vQuad[dwTemp];
            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+2];

            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+1];
            v[dwVert++] = vQuad[dwTemp+2];

            dwCurQuad++;
        }
    }

    m_pVB->Unlock();
    
    SAFE_DELETE_ARRAY( vQuad );
}

// 'glu' routines
#ifdef _EXTENSIONS_
#define COS cosf
#define SIN sinf
#define SQRT sqrtf
#else
#define COS cos
#define SIN sin
#define SQRT sqrt
#endif




//-----------------------------------------------------------------------------
// Name: BuildCylinder
// Desc: 
//-----------------------------------------------------------------------------
void PIPE_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, float length, float s_start, 
                         float s_end )
{
    int   stacks, slices;
    int   i,j;
    float sinCache[CACHE_SIZE];
    float cosCache[CACHE_SIZE];
    float sinCache2[CACHE_SIZE];
    float cosCache2[CACHE_SIZE];
    float angle;
    float zNormal;
    float s_delta;
    float zHigh, zLow;
    IPOINT2D *texRep = pBuildInfo->m_texRep;
    float radius = pBuildInfo->m_radius;

    slices = pBuildInfo->m_nSlices;
    stacks = (int) SS_ROUND_UP( (length/pBuildInfo->m_divSize) * (float)slices) ;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;
    zNormal = 0.0f;

    s_delta = s_end - s_start;

    for (i = 0; i < slices; i++) 
    {
        angle = 2 * PI * i / slices;
        sinCache2[i] = (float) SIN(angle);
        cosCache2[i] = (float) COS(angle);
        sinCache[i] = (float) SIN(angle);
        cosCache[i] = (float) COS(angle);
    }

    sinCache[slices] = sinCache[0];
    cosCache[slices] = cosCache[0];
    sinCache2[slices] = sinCache2[0];
    cosCache2[slices] = cosCache2[0];

    DWORD dwNumQuadStripsPerStack = slices;
    DWORD dwNumQuadStrips = dwNumQuadStripsPerStack * stacks;
    m_dwNumTriangles = dwNumQuadStrips * 2;
    DWORD dwNumVertices = m_dwNumTriangles * 3;
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(D3DVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_VERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
        return;

    D3DVERTEX* vQuad;
    D3DVERTEX* vCurQuad;
    vQuad = new D3DVERTEX[dwNumVertices];
    ZeroMemory( vQuad, sizeof(D3DVERTEX) * dwNumVertices );

    vCurQuad = vQuad;
    for (j = 0; j < stacks; j++) 
    {
        zLow = j * length / stacks;
        zHigh = (j + 1) * length / stacks;

        for (i = 0; i <= slices; i++) 
        {
            vCurQuad->p = D3DXVECTOR3( radius * sinCache[i], radius * cosCache[i], zLow );
            vCurQuad->n = D3DXVECTOR3( sinCache2[i], cosCache2[i], zNormal );
            if( texRep )
            {
                vCurQuad->tu = (float) s_start + s_delta * j / stacks;
                vCurQuad->tv = (float) i * texRep->y / slices;
            }
            vCurQuad++;

            vCurQuad->p = D3DXVECTOR3( radius * sinCache[i], radius * cosCache[i], zHigh );
            vCurQuad->n = D3DXVECTOR3( sinCache2[i], cosCache2[i], zNormal );
            if( texRep )
            {
                vCurQuad->tu = (float) s_start + s_delta*(j+1) / stacks;
                vCurQuad->tv = (float) i * texRep->y / slices;
            }
            vCurQuad++;
        }
    }

    D3DVERTEX* v;
    DWORD dwCurQuad = 0;
    DWORD dwVert = 0;

    m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );

    for (j = 0; j < stacks; j++) 
    {
        for (i = 0; i <= slices; i++) 
        {
            if(  i==0 )
            {
                dwCurQuad++;
                continue;
            }
            // Vertices 2n-1, 2n, 2n+2, and 2n+1 define quadrilateral n
            DWORD dwTemp = dwCurQuad*2-1;

            v[dwVert++] = vQuad[dwTemp];
            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+2];

            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+1];
            v[dwVert++] = vQuad[dwTemp+2];

            dwCurQuad++;
        }
    }

    m_pVB->Unlock();

    SAFE_DELETE_ARRAY( vQuad );
}




//-----------------------------------------------------------------------------
// Name: pipeSphere
// Desc: 
//-----------------------------------------------------------------------------
void SPHERE_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, float radius, 
                           float s_start, float s_end)
{
    int i,j;
    float sinCache1a[CACHE_SIZE];
    float cosCache1a[CACHE_SIZE];
    float sinCache2a[CACHE_SIZE];
    float cosCache2a[CACHE_SIZE];
    float sinCache1b[CACHE_SIZE];
    float cosCache1b[CACHE_SIZE];
    float sinCache2b[CACHE_SIZE];
    float cosCache2b[CACHE_SIZE];
    float angle;
    float s_delta;
    int   stacks, slices;
    IPOINT2D *texRep = pBuildInfo->m_texRep;

    slices = pBuildInfo->m_nSlices;
    stacks = slices;
    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;

    // invert sense of s - it seems the glu sphere is not built similarly
    // to the glu cylinder
    // (this probably means stacks don't grow along +z - check it out)
    s_delta = s_start;
    s_start = s_end;
    s_end = s_delta; 

    s_delta = s_end - s_start;

    // Cache is the vertex locations cache
    //  Cache2 is the various normals at the vertices themselves
    for (i = 0; i < slices; i++) 
    {
        angle = 2 * PI * i / slices;
        sinCache1a[i] = (float) SIN(angle);
        cosCache1a[i] = (float) COS(angle);
        sinCache2a[i] = sinCache1a[i];
        cosCache2a[i] = cosCache1a[i];
    }

    for (j = 0; j <= stacks; j++) 
    {
        angle = PI * j / stacks;
        sinCache2b[j] = (float) SIN(angle);
        cosCache2b[j] = (float) COS(angle);
        sinCache1b[j] = radius * (float) SIN(angle);
        cosCache1b[j] = radius * (float) COS(angle);
    }

    // Make sure it comes to a point 
    sinCache1b[0] = 0.0f;
    sinCache1b[stacks] = 0.0f;

    sinCache1a[slices] = sinCache1a[0];
    cosCache1a[slices] = cosCache1a[0];
    sinCache2a[slices] = sinCache2a[0];
    cosCache2a[slices] = cosCache2a[0];

    int start, finish;
    float zLow, zHigh;
    float sintemp1, sintemp2, sintemp3, sintemp4;
    float costemp3, costemp4;

    start = 0;
    finish = stacks;

    DWORD dwNumQuadStripsPerStack = slices;
    DWORD dwNumQuadStrips = dwNumQuadStripsPerStack * (finish-start);
    m_dwNumTriangles = dwNumQuadStrips * 2;
    DWORD dwNumVertices = m_dwNumTriangles * 3;
    if( FAILED( m_pd3dDevice->CreateVertexBuffer( dwNumVertices*sizeof(D3DVERTEX),
                                                  D3DUSAGE_WRITEONLY, D3DFVF_VERTEX,
                                                  D3DPOOL_MANAGED, &m_pVB ) ) )
        return;

    D3DVERTEX* vQuad;
    D3DVERTEX* vCurQuad;
    vQuad = new D3DVERTEX[dwNumVertices];
    ZeroMemory( vQuad, sizeof(D3DVERTEX) * dwNumVertices );

    vCurQuad = vQuad;
    for (j = 0; j < stacks; j++) 
    {
        zLow = cosCache1b[j];
        zHigh = cosCache1b[j+1];
        sintemp1 = sinCache1b[j];
        sintemp2 = sinCache1b[j+1];

        sintemp3 = sinCache2b[j+1];
        costemp3 = cosCache2b[j+1];
        sintemp4 = sinCache2b[j];
        costemp4 = cosCache2b[j];

        for (i = 0; i <= slices; i++) 
        {

            vCurQuad->p = D3DXVECTOR3( sintemp2 * sinCache1a[i], sintemp2 * cosCache1a[i], zHigh );
            vCurQuad->n = D3DXVECTOR3( sinCache2a[i] * sintemp3, cosCache2a[i] * sintemp3, costemp3 );
            if( texRep )
            {
                vCurQuad->tu = (float) s_start + s_delta*(j+1) / stacks;
                vCurQuad->tv = (float) i * texRep->y / slices;
            }
            vCurQuad++;

            vCurQuad->p = D3DXVECTOR3( sintemp1 * sinCache1a[i], sintemp1 * cosCache1a[i], zLow );
            vCurQuad->n = D3DXVECTOR3( sinCache2a[i] * sintemp4, cosCache2a[i] * sintemp4, costemp4 );
            if( texRep )
            {
                vCurQuad->tu = (float) s_start + s_delta * j / stacks;
                vCurQuad->tv = (float) i * texRep->y / slices;
            }
            vCurQuad++;

        }
    }

    D3DVERTEX* v;
    DWORD dwCurQuad = 0;
    DWORD dwVert = 0;

    m_pVB->Lock( 0, 0, (BYTE**)&v, 0 );

    for (j = 0; j < stacks; j++) 
    {
        for (i = 0; i <= slices; i++) 
        {
            if(  i==0 )
            {
                dwCurQuad++;
                continue;
            }
            // Vertices 2n-1, 2n, 2n+2, and 2n+1 define quadrilateral n
            DWORD dwTemp = dwCurQuad*2-1;

            v[dwVert++] = vQuad[dwTemp];
            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+2];

            v[dwVert++] = vQuad[dwTemp-1];
            v[dwVert++] = vQuad[dwTemp+1];
            v[dwVert++] = vQuad[dwTemp+2];

            dwCurQuad++;
        }
    }

    m_pVB->Unlock();

    SAFE_DELETE_ARRAY( vQuad );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\node.cpp ===
//-----------------------------------------------------------------------------
// File: node.cpp
//
// Desc: Pipes node array
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: NODE_ARRAY constructor
// Desc: 
//-----------------------------------------------------------------------------
NODE_ARRAY::NODE_ARRAY()
{
    m_nodes = NULL; // allocated on Resize

    m_numNodes.x = 0;
    m_numNodes.y = 0;
    m_numNodes.z = 0;
}




//-----------------------------------------------------------------------------
// Name: NODE_ARRAY destructor
// Desc: 
//-----------------------------------------------------------------------------
NODE_ARRAY::~NODE_ARRAY( )
{
    if( m_nodes )
        delete m_nodes;
}




//-----------------------------------------------------------------------------
// Name: Resize
// Desc: 
//-----------------------------------------------------------------------------
void NODE_ARRAY::Resize( IPOINT3D *pNewSize )
{
    if( (m_numNodes.x == pNewSize->x) &&
        (m_numNodes.y == pNewSize->y) &&
        (m_numNodes.z == pNewSize->z) )
        return;

    m_numNodes = *pNewSize;

    int elemCount = m_numNodes.x * m_numNodes.y * m_numNodes.z;

    if( m_nodes )
        delete m_nodes;

    m_nodes = new Node[elemCount];

    assert( m_nodes && "NODE_ARRAY::Resize : can't alloc nodes\n" );
    if( m_nodes == NULL )
        return;

    // Reset the node states to empty

    int i;
    Node *pNode = m_nodes;
    for( i = 0; i < elemCount; i++, pNode++ )
        pNode->MarkAsEmpty();

    // precalculate direction offsets between nodes for speed
    m_nodeDirInc[PLUS_X] = 1;
    m_nodeDirInc[MINUS_X] = -1;
    m_nodeDirInc[PLUS_Y] = m_numNodes.x;
    m_nodeDirInc[MINUS_Y] = - m_nodeDirInc[PLUS_Y];
    m_nodeDirInc[PLUS_Z] = m_numNodes.x * m_numNodes.y;
    m_nodeDirInc[MINUS_Z] = - m_nodeDirInc[PLUS_Z];
}




//-----------------------------------------------------------------------------
// Name: Reset
// Desc: 
//-----------------------------------------------------------------------------
void NODE_ARRAY::Reset( )
{
    int i;
    Node* pNode = m_nodes;

    // Reset the node states to empty
    for( i = 0; i < (m_numNodes.x)*(m_numNodes.y)*(m_numNodes.z); i++, pNode++ )
        pNode->MarkAsEmpty();
}




//-----------------------------------------------------------------------------
// Name: GetNodeCount
// Desc: 
//-----------------------------------------------------------------------------
void NODE_ARRAY::GetNodeCount( IPOINT3D *count )
{
    *count = m_numNodes;
}




//-----------------------------------------------------------------------------
// Name: ChooseRandomDirection
// Desc: Choose randomnly among the possible directions.  The likelyhood of going
//       straight is controlled by weighting it.
//-----------------------------------------------------------------------------
int NODE_ARRAY::ChooseRandomDirection( IPOINT3D *pos, int dir, int weightStraight )
{
    Node *nNode[NUM_DIRS];
    int numEmpty, newDir;
    int choice;
    Node *straightNode = NULL;
    int emptyDirs[NUM_DIRS];

    assert( (dir >= 0) && (dir < NUM_DIRS) && 
            "NODE_ARRAY::ChooseRandomDirection: invalid dir\n" );

    // Get the neigbouring nodes
    GetNeighbours( pos, nNode );

    // Get node in straight direction if necessary
    if( weightStraight && nNode[dir] && nNode[dir]->IsEmpty() ) 
    {
        straightNode = nNode[dir];
        // if maximum weight, choose and return
        if( weightStraight == MAX_WEIGHT_STRAIGHT ) 
        {
            straightNode->MarkAsTaken();
            return dir;
        }
    } 
    else
    {
        weightStraight = 0;
    }

    // Get directions of possible turns
    numEmpty = GetEmptyTurnNeighbours( nNode, emptyDirs, dir );

    // Make a random choice
    if( (choice = (weightStraight + numEmpty)) == 0 )
        return DIR_NONE;
    choice = CPipesScreensaver::iRand( choice );

    if( choice < weightStraight && straightNode != NULL ) 
    {
        straightNode->MarkAsTaken();
        return dir;
    } 
    else 
    {
        // choose one of the turns
        newDir = emptyDirs[choice - weightStraight];
        nNode[newDir]->MarkAsTaken();
        return newDir;
    }
}




//-----------------------------------------------------------------------------
// Name: ChoosePreferredDirection
// Desc: Choose randomnly from one of the supplied preferred directions.  If none
//       of these are available, then try and choose any empty direction
//-----------------------------------------------------------------------------
int NODE_ARRAY::ChoosePreferredDirection( IPOINT3D *pos, int dir, int *prefDirs,
                                          int nPrefDirs )
{
    Node *nNode[NUM_DIRS];
    int numEmpty, newDir;
    int emptyDirs[NUM_DIRS];
    int *pEmptyPrefDirs;
    int i, j;

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::ChoosePreferredDirection : invalid dir\n" );

    // Get the neigbouring nodes
    GetNeighbours( pos, nNode );

    // Create list of directions that are both preferred and empty

    pEmptyPrefDirs = emptyDirs;
    numEmpty = 0;

    for( i = 0, j = 0; (i < NUM_DIRS) && (j < nPrefDirs); i++ ) 
    {
        if( i == *prefDirs ) 
        {
            prefDirs++;
            j++;
            if( nNode[i] && nNode[i]->IsEmpty() ) 
            {
                // add it to list
                *pEmptyPrefDirs++ = i;
                numEmpty++;
            }
        }
    }

    // if no empty preferred dirs, then any empty dirs become preferred
    
    if( !numEmpty ) 
    {
        numEmpty = GetEmptyNeighbours( nNode, emptyDirs );
        if( numEmpty == 0 )
            return DIR_NONE;
    }
                
    // Pick a random dir from the empty set

    newDir = emptyDirs[CPipesScreensaver::iRand( numEmpty )];
    nNode[newDir]->MarkAsTaken();
    return newDir;
}




//-----------------------------------------------------------------------------
// Name: FindClearestDirection
// Desc: Finds the direction with the most empty nodes in a line 'searchRadius'
//       long.  Does not mark any nodes as taken.
//-----------------------------------------------------------------------------
int NODE_ARRAY::FindClearestDirection( IPOINT3D *pos )
{
    static Node *neighbNode[NUM_DIRS];
    static int emptyDirs[NUM_DIRS];
    int nEmpty, newDir;
    int maxEmpty = 0;
    int searchRadius = 3;
    int count = 0;
    int i;

    // Get ptrs to neighbour nodes
    GetNeighbours( pos, neighbNode );

    // find empty nodes in each direction
    for( i = 0; i < NUM_DIRS; i ++ ) 
    {
        if( neighbNode[i] && neighbNode[i]->IsEmpty() )
        {
            // find number of contiguous empty nodes along this direction
            nEmpty = GetEmptyNeighboursAlongDir( pos, i, searchRadius );
            if( nEmpty > maxEmpty ) 
            {
                // we have a new winner
                count = 0;
                maxEmpty = nEmpty;
                emptyDirs[count++] = i;
            }
            else if( nEmpty == maxEmpty ) 
            {
                // tied with current max
                emptyDirs[count++] = i;
            }
        }
    }

    if( count == 0 )
        return DIR_NONE;

    // randomnly choose a direction
    newDir = emptyDirs[CPipesScreensaver::iRand( count )];

    return newDir;
}




//-----------------------------------------------------------------------------
// Name: ChooseNewTurnDirection
// Desc: Choose a direction to turn
// 
//       This requires finding a pair of nodes to turn through.  The first node
//       is in the direction of the turn from the current node, and the second node
//       is at right angles to this at the end position.  The prim will not draw
//       through the first node, but may sweep close to it, so we have to mark it
//       as taken.
//       - if next node is free, but there are no turns available, return
//         DIR_STRAIGHT, so the caller can decide what to do in this case
//       - The turn possibilities are based on the orientation of the current xc, with
//         4 relative directions to seek turns in.
//-----------------------------------------------------------------------------
int NODE_ARRAY::ChooseNewTurnDirection( IPOINT3D *pos, int dir )
{
    int turns[NUM_DIRS], nTurns;
    IPOINT3D nextPos;
    int newDir;
    Node *nextNode;

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::ChooseNewTurnDirection : invalid dir\n" );

    // First, check if next node along current dir is empty

    if( !GetNextNodePos( pos, &nextPos, dir ) )
        return DIR_NONE; // node out of bounds or not empty

    // Ok, the next node is free - check the 4 possible turns from here

    nTurns = GetBestPossibleTurns( &nextPos, dir, turns );
    if( nTurns == 0 )
        return DIR_STRAIGHT; // nowhere to turn, but could go straight

    // randomnly choose one of the possible turns
    newDir = turns[ CPipesScreensaver::iRand( nTurns ) ];

    assert( (newDir >= 0) && (newDir < NUM_DIRS) &&
            "NODE_ARRAY::ChooseNewTurnDirection : invalid newDir\n" );


    // mark taken nodes

    nextNode = GetNode( &nextPos );
    nextNode->MarkAsTaken();

    nextNode = GetNextNode( &nextPos, newDir );

    if( nextNode != NULL )
        nextNode->MarkAsTaken();

    return newDir;
}




//-----------------------------------------------------------------------------
// Name: GetBestPossibleTurns
// Desc: From supplied direction and position, figure out which of 4 possible 
//       directions are best to turn in.
//       
//       Turns that have the greatest number of empty nodes after the turn are the
//       best, since a pipe is less likely to hit a dead end in this case.
//       - We only check as far as 'searchRadius' nodes along each dir.
//       - Return direction indices of best possible turns in turnDirs, and return 
//       count of these turns in fuction return value.
//-----------------------------------------------------------------------------
int NODE_ARRAY::GetBestPossibleTurns( IPOINT3D *pos, int dir, int *turnDirs )
{
    Node *neighbNode[NUM_DIRS]; // ptrs to 6 neighbour nodes
    int i, count = 0;
    BOOL check[NUM_DIRS] = {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE};
    int nEmpty, maxEmpty = 0;
    int searchRadius = 2;

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::GetBestPossibleTurns : invalid dir\n" );

    GetNeighbours( pos, neighbNode );

    switch( dir ) 
    {
        case PLUS_X:    
        case MINUS_X:
            check[PLUS_X] = FALSE;
            check[MINUS_X] = FALSE;
            break;
        case PLUS_Y:    
        case MINUS_Y:
            check[PLUS_Y] = FALSE;
            check[MINUS_Y] = FALSE;
            break;
        case PLUS_Z:    
        case MINUS_Z:
            check[PLUS_Z] = FALSE;
            check[MINUS_Z] = FALSE;
            break;
    }

    // check approppriate directions
    for( i = 0; i < NUM_DIRS; i ++ ) 
    {
        if( check[i] && neighbNode[i] && neighbNode[i]->IsEmpty() )
        {
            // find number of contiguous empty nodes along this direction
            nEmpty = GetEmptyNeighboursAlongDir( pos, i, searchRadius );
            if( nEmpty > maxEmpty ) 
            {
                // we have a new winner
                count = 0;
                maxEmpty = nEmpty;
                turnDirs[count++] = i;
            }
            else if( nEmpty == maxEmpty ) 
            {
                // tied with current max
                turnDirs[count++] = i;
            }
        }
    }

    return count;
}




//-----------------------------------------------------------------------------
// Name: GetNeighbours
// Desc: Get neigbour nodes relative to supplied position
//          - get addresses of the neigbour nodes,
//          and put them in supplied matrix
//          - boundary hits are returned as NULL
//-----------------------------------------------------------------------------
void NODE_ARRAY::GetNeighbours( IPOINT3D *pos, Node **nNode )
{
    Node *centerNode = GetNode( pos );

    nNode[PLUS_X]  = pos->x == (m_numNodes.x - 1) ? NULL : 
                                            centerNode + m_nodeDirInc[PLUS_X];
    nNode[PLUS_Y]  = pos->y == (m_numNodes.y - 1) ? NULL :
                                            centerNode + m_nodeDirInc[PLUS_Y];
    nNode[PLUS_Z]  = pos->z == (m_numNodes.z - 1) ? NULL : 
                                            centerNode + m_nodeDirInc[PLUS_Z];

    nNode[MINUS_X] = pos->x == 0 ? NULL : centerNode + m_nodeDirInc[MINUS_X];
    nNode[MINUS_Y] = pos->y == 0 ? NULL : centerNode + m_nodeDirInc[MINUS_Y];
    nNode[MINUS_Z] = pos->z == 0 ? NULL : centerNode + m_nodeDirInc[MINUS_Z];
}




//-----------------------------------------------------------------------------
// Name: NodeVisited
// Desc: Mark the node as non-empty
//-----------------------------------------------------------------------------
void NODE_ARRAY::NodeVisited( IPOINT3D *pos )
{
    (GetNode( pos ))->MarkAsTaken();
}




//-----------------------------------------------------------------------------
// Name: GetNode
// Desc: Get ptr to node from position
//-----------------------------------------------------------------------------
Node* NODE_ARRAY::GetNode( IPOINT3D *pos )
{
    return m_nodes +
           pos->x +
           pos->y * m_numNodes.x +
           pos->z * m_numNodes.x * m_numNodes.y;
}




//-----------------------------------------------------------------------------
// Name: GetNextNode
// Desc: Get ptr to next node from pos and dir
//-----------------------------------------------------------------------------
Node* NODE_ARRAY::GetNextNode( IPOINT3D *pos, int dir )
{
    Node *curNode = GetNode( pos );

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::GetNextNode : invalid dir\n" );

    switch( dir ) 
    {
        case PLUS_X:
            return( pos->x == (m_numNodes.x - 1) ? NULL : 
                              curNode + m_nodeDirInc[PLUS_X]);
            break;
        case MINUS_X:
            return( pos->x == 0 ? NULL : 
                              curNode + m_nodeDirInc[MINUS_X]);
            break;
        case PLUS_Y:
            return( pos->y == (m_numNodes.y - 1) ? NULL : 
                              curNode + m_nodeDirInc[PLUS_Y]);
            break;
        case MINUS_Y:
            return( pos->y == 0 ? NULL : 
                              curNode + m_nodeDirInc[MINUS_Y]);
            break;
        case PLUS_Z:
            return( pos->z == (m_numNodes.z - 1) ? NULL : 
                              curNode + m_nodeDirInc[PLUS_Z]);
            break;
        case MINUS_Z:
            return( pos->z == 0 ? NULL : 
                              curNode + m_nodeDirInc[MINUS_Z]);
            break;
        default:
            return NULL;
    }
}




//-----------------------------------------------------------------------------
// Name: GetNextNodePos
// Desc: Get position of next node from curPos and lastDir
//       Returns FALSE if boundary hit or node empty
//-----------------------------------------------------------------------------
BOOL NODE_ARRAY::GetNextNodePos( IPOINT3D *curPos, IPOINT3D *nextPos, int dir )
{
    static Node *neighbNode[NUM_DIRS]; // ptrs to 6 neighbour nodes

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::GetNextNodePos : invalid dir\n" );

    //mf: don't need to get all neighbours, just one in next direction
    GetNeighbours( curPos, neighbNode );

    *nextPos = *curPos;

    // bail if boundary hit or node not empty
    if( (neighbNode[dir] == NULL) || !neighbNode[dir]->IsEmpty() )
        return FALSE;

    switch( dir ) 
    {
        case PLUS_X:
            nextPos->x = curPos->x + 1;
            break;

        case MINUS_X:
            nextPos->x = curPos->x - 1;
            break;

        case PLUS_Y:
            nextPos->y = curPos->y + 1;
            break;

        case MINUS_Y:
            nextPos->y = curPos->y - 1;
            break;

        case PLUS_Z:
            nextPos->z = curPos->z + 1;
            break;

        case MINUS_Z:
            nextPos->z = curPos->z - 1;
            break;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: GetEmptyNeighbours()
// Desc: - get list of direction indices of empty node neighbours,
//         and put them in supplied matrix
//       - return number of empty node neighbours
//-----------------------------------------------------------------------------
int NODE_ARRAY::GetEmptyNeighbours( Node **nNode, int *nEmpty )
{
    int i, count = 0;

    for( i = 0; i < NUM_DIRS; i ++ ) 
    {
        if( nNode[i] && nNode[i]->IsEmpty() )
            nEmpty[count++] = i;
    }

    return count;
}




//-----------------------------------------------------------------------------
// Name: GetEmptyTurnNeighbours()
// Desc: - get list of direction indices of empty node neighbours,
//          and put them in supplied matrix
//       - don't include going straight
//       - return number of empty node neighbours
//-----------------------------------------------------------------------------
int NODE_ARRAY::GetEmptyTurnNeighbours( Node** nNode, int* nEmpty, int lastDir )
{
    int i, count = 0;

    for( i = 0; i < NUM_DIRS; i ++ ) 
    {
        if( nNode[i] && nNode[i]->IsEmpty() ) 
        {
            if( i == lastDir )
                continue;
            nEmpty[count++] = i;
        }
    }

    return count;
}




//-----------------------------------------------------------------------------
// Name: GetEmptyNeighboursAlongDir
// Desc: Sort of like above, but just gets one neigbour according to supplied dir
//          Given a position and direction, find out how many contiguous empty nodes 
//          there are in that direction.
//          - Can limit search with searchRadius parameter
//          - Return contiguous empty node count
//-----------------------------------------------------------------------------
int NODE_ARRAY::GetEmptyNeighboursAlongDir( IPOINT3D *pos, int dir,
                                            int searchRadius )
{
    Node *curNode = GetNode( pos );
    int nodeStride;
    int maxSearch;
    int count = 0;

    assert( (dir >= 0) && (dir < NUM_DIRS) &&
            "NODE_ARRAY::GetEmptyNeighboursAlongDir : invalid dir\n" );

    nodeStride = m_nodeDirInc[dir];

    switch( dir ) 
    {
        case PLUS_X:    
            maxSearch = m_numNodes.x - pos->x - 1;
            break;
        case MINUS_X:
            maxSearch = pos->x;
            break;
        case PLUS_Y:    
            maxSearch = m_numNodes.y - pos->y - 1;
            break;
        case MINUS_Y:
            maxSearch = pos->y;
            break;
        case PLUS_Z:    
            maxSearch = m_numNodes.z - pos->z - 1;
            break;
        case MINUS_Z:
            maxSearch = pos->z;
            break;
    }
    
    if( searchRadius > maxSearch )
        searchRadius = maxSearch;

    if( !searchRadius )
        return 0;

    while( searchRadius-- ) 
    {
        curNode += nodeStride;
        if( ! curNode->IsEmpty() )
            return count;
        count++;
    }
    return count;
}




//-----------------------------------------------------------------------------
// Name: FindRandomEmptyNode
// Desc:    - Search for an empty node to start drawing
//          - Return position of empty node in supplied pos ptr
//          - Returns FALSE if couldn't find a node
//          - Marks node as taken (mf: renam fn to ChooseEmptyNode ?
//      If random search takes longer than twice the total number
//      of nodes, give up the random search.  There may not be any
//      empty nodes.
//-----------------------------------------------------------------------------
#define INFINITE_LOOP   (2 * NUM_NODE * NUM_NODE * NUM_NODE)

BOOL NODE_ARRAY::FindRandomEmptyNode( IPOINT3D *pos )
{
    int infLoopDetect = 0;

    while( TRUE ) 
    {
        // Pick a random node.
        pos->x = CPipesScreensaver::iRand( m_numNodes.x );
        pos->y = CPipesScreensaver::iRand( m_numNodes.y );
        pos->z = CPipesScreensaver::iRand( m_numNodes.z );

        // If its empty, we're done.
        if( GetNode(pos)->IsEmpty() ) 
        {
            NodeVisited( pos );
            return TRUE;
        } 
        else 
        {
            // Watch out for infinite loops!  After trying for
            // awhile, give up on the random search and look
            // for the first empty node.

            if ( infLoopDetect++ > INFINITE_LOOP ) 
            {
                // Search for first empty node.
                for ( pos->x = 0; pos->x < m_numNodes.x; pos->x++ )
                {
                    for ( pos->y = 0; pos->y < m_numNodes.y; pos->y++ )
                    {
                        for ( pos->z = 0; pos->z < m_numNodes.z; pos->z++ )
                        {
                            if( GetNode(pos)->IsEmpty() ) 
                            {
                                NodeVisited( pos );
                                return TRUE;
                            }
                        }
                    }
                }

                // There are no more empty nodes.
                // Reset the pipes and exit.

                return FALSE;
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: FindRandomEmptyNode2D
// Desc: - Like FindRandomEmptyNode, but limits search to a 2d plane of the supplied
//          box.
//-----------------------------------------------------------------------------
#define INFINITE_LOOP   (2 * NUM_NODE * NUM_NODE * NUM_NODE)
#define MIN_VAL 1
#define MAX_VAL 0

BOOL NODE_ARRAY::FindRandomEmptyNode2D( IPOINT3D *pos, int plane, int *box )
{
    int *newx, *newy;
    int *xDim, *yDim;

    switch( plane ) 
    {
        case PLUS_X:
        case MINUS_X:
            pos->x = box[plane];
            newx = &pos->z;
            newy = &pos->y;
            xDim = &box[PLUS_Z]; 
            yDim = &box[PLUS_Y]; 
            break;
        case PLUS_Y:
        case MINUS_Y:
            pos->y = box[plane];
            newx = &pos->x;
            newy = &pos->z;
            xDim = &box[PLUS_X]; 
            yDim = &box[PLUS_Z]; 
            break;
        case PLUS_Z:
        case MINUS_Z:
            newx = &pos->x;
            newy = &pos->y;
            pos->z = box[plane];
            xDim = &box[PLUS_X]; 
            yDim = &box[PLUS_Y]; 
            break;
    }

    int infLoop = 2 * (xDim[MAX_VAL] - xDim[MIN_VAL] + 1) *
                      (yDim[MAX_VAL] - yDim[MIN_VAL] + 1);
    int infLoopDetect = 0;

    while( TRUE ) 
    {
        // Pick a random node.
        *newx = CPipesScreensaver::iRand2( xDim[MIN_VAL], xDim[MAX_VAL] );
        *newy = CPipesScreensaver::iRand2( yDim[MIN_VAL], yDim[MAX_VAL] );

        // If its empty, we're done.
        if( GetNode(pos)->IsEmpty() ) 
        {
            NodeVisited( pos );
            return TRUE;
        } 
        else 
        {
            // Watch out for infinite loops!  After trying for
            // awhile, give up on the random search and look
            // for the first empty node.

            if ( ++infLoopDetect > infLoop ) 
            {

                // Do linear search for first empty node.

                for ( *newx = xDim[MIN_VAL]; *newx <= xDim[MAX_VAL]; (*newx)++ )
                {
                    for ( *newy = yDim[MIN_VAL]; *newy <= yDim[MAX_VAL]; (*newy)++ )
                    {
                        if( GetNode(pos)->IsEmpty() ) 
                        {
                            NodeVisited( pos );
                            return TRUE;
                        }
                    }
                }

                // There are no empty nodes in this plane.
                return FALSE;
            }
        }
    }
}




//-----------------------------------------------------------------------------
// Name: TakeClosestEmptyNode
// Desc: - Search for an empty node closest to supplied node position
//          - Returns FALSE if couldn't find a node
//          - Marks node as taken
//          - mf: not completely opimized - if when dilating the box, a side gets
//          clamped against the node array, this side will continue to be searched
//-----------------------------------------------------------------------------
static void DilateBox( int *box, IPOINT3D *bounds );

BOOL NODE_ARRAY::TakeClosestEmptyNode( IPOINT3D *newPos, IPOINT3D *pos )
{
    static int searchRadius = SS_MAX( m_numNodes.x, m_numNodes.y ) / 3;

    // easy out
    if( GetNode(pos)->IsEmpty() ) 
    {
        NodeVisited( pos );
        *newPos = *pos;
        return TRUE;
    }

    int box[NUM_DIRS] = {pos->x, pos->x, pos->y, pos->y, pos->z, pos->z};
    int clip[NUM_DIRS] = {0};

    // do a random search on successively larger search boxes
    for( int i = 0; i < searchRadius; i++ ) 
    {
        // Increase box size
        DilateBox( box, &m_numNodes );
        // start looking in random 2D face of the box
        int dir = CPipesScreensaver::iRand( NUM_DIRS );
        for( int j = 0; j < NUM_DIRS; j++, dir = (++dir == NUM_DIRS) ? 0 : dir ) 
        {
            if( FindRandomEmptyNode2D( newPos, dir, box ) )
                return TRUE;
        }
    }

    // nothing nearby - grab a random one
    return FindRandomEmptyNode( newPos );
}




//-----------------------------------------------------------------------------
// Name: DilateBox
// Desc: - Increase box radius without exceeding bounds
//-----------------------------------------------------------------------------
static void DilateBox( int *box, IPOINT3D *bounds )
{
    int *min = (int *) &box[MINUS_X];
    int *max = (int *) &box[PLUS_X];
    int *boundMax = (int *) bounds;
    
    // boundMin always 0
    for( int i = 0; i < 3; i ++, min+=2, max+=2, boundMax++ ) 
    {
        if( *min > 0 )
            (*min)--;
        if( *max < (*boundMax - 1) )
            (*max)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\nstate.cpp ===
//-----------------------------------------------------------------------------
// File: nstate.cpp
//
// Desc: NORMAL_STATE
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: NORMAL_STATE constructor
// Desc: 
//-----------------------------------------------------------------------------
NORMAL_STATE::NORMAL_STATE( STATE *pState )
{
    m_pd3dDevice = pState->m_pd3dDevice;

    // init joint types from dialog settings
    m_bCycleJointStyles = 0;

    switch( pState->m_pConfig->nJointType ) 
    {
        case JOINT_ELBOW:
            m_jointStyle = ELBOWS;
            break;

        case JOINT_BALL:
            m_jointStyle = BALLS;
            break;

        case JOINT_MIXED:
            m_jointStyle = EITHER;
            break;

        case JOINT_CYCLE:
            m_bCycleJointStyles = 1;
            m_jointStyle = EITHER;
            break;

        default:
            break;
    }

    // Build the objects
    BuildObjects( pState->m_radius, pState->m_view.m_divSize, pState->m_nSlices,
                  pState->m_bUseTexture, &pState->m_texRep[0] );
}




//-----------------------------------------------------------------------------
// Name: NORMAL_STATE destructor
// Desc: Some of the objects are always created, so don't have to check if they
//       exist. Others may be NULL.
//-----------------------------------------------------------------------------
NORMAL_STATE::~NORMAL_STATE()
{
    SAFE_DELETE( m_pShortPipe );
    SAFE_DELETE( m_pLongPipe );
    SAFE_DELETE( m_pBallCap );
    SAFE_DELETE( m_pBigBall );

    for( int i = 0; i < 4; i ++ ) 
    {
        SAFE_DELETE( m_pElbows[i] );
        SAFE_DELETE( m_pBallJoints[i] );
    }
}




//-----------------------------------------------------------------------------
// Name: BuildObjects
// Desc: - Build all the pipe primitives
//       - Different prims are built based on bTexture flag
//-----------------------------------------------------------------------------
void NORMAL_STATE::BuildObjects( float radius, float divSize, int nSlices, 
                                 BOOL bTexture, IPOINT2D *texRep )
{
    OBJECT_BUILD_INFO buildInfo;
    buildInfo.m_radius   = radius;
    buildInfo.m_divSize  = divSize;
    buildInfo.m_nSlices  = nSlices;
    buildInfo.m_bTexture = bTexture;
    buildInfo.m_texRep   = NULL;

    if( bTexture ) 
    {
        buildInfo.m_texRep = texRep;
        
        // Calc s texture intersection values
        float s_max = (float) texRep->y;
        float s_trans =  s_max * 2.0f * radius / divSize;

        // Build short and long pipes
        m_pShortPipe = new PIPE_OBJECT( m_pd3dDevice, &buildInfo, divSize - 2*radius,
                                       s_trans, s_max );
        m_pLongPipe = new PIPE_OBJECT( m_pd3dDevice, &buildInfo, divSize, 0.0f, s_max );

        // Build elbow and ball joints
        for( int i = 0; i < 4; i ++ ) 
        {
            m_pElbows[i] = new ELBOW_OBJECT( m_pd3dDevice, &buildInfo, i, 0.0f, s_trans );
            m_pBallJoints[i] = new BALLJOINT_OBJECT( m_pd3dDevice, &buildInfo, i, 0.0f, s_trans );
        }

        m_pBigBall = NULL;

        // Build end cap
        float s_start = - texRep->x * (ROOT_TWO - 1.0f) * radius / divSize;
        float s_end = texRep->x * (2.0f + (ROOT_TWO - 1.0f)) * radius / divSize;

        // calc compensation value, to prevent negative s coords
        float comp_s = (int) ( - s_start ) + 1.0f;
        s_start += comp_s;
        s_end += comp_s;
        m_pBallCap = new SPHERE_OBJECT( m_pd3dDevice, &buildInfo, ROOT_TWO*radius, s_start, s_end );
    } 
    else 
    {
        // Build pipes, elbows
        m_pShortPipe = new PIPE_OBJECT( m_pd3dDevice, &buildInfo, divSize - 2*radius );
        m_pLongPipe = new PIPE_OBJECT( m_pd3dDevice, &buildInfo, divSize );
        for( int i = 0; i < 4; i ++ ) 
        {
            m_pElbows[i] = new ELBOW_OBJECT( m_pd3dDevice, &buildInfo, i );
            m_pBallJoints[i] = NULL;
        }

        // Build just one ball joint when not texturing.  It is slightly
        // larger than standard ball joint, to prevent any pipe edges from
        // 'sticking' out of the ball.
        m_pBigBall = new SPHERE_OBJECT( m_pd3dDevice, &buildInfo,  
                                ROOT_TWO*radius / ((float) cos(PI/nSlices)) );

        // build end cap
        m_pBallCap = new SPHERE_OBJECT( m_pd3dDevice, &buildInfo, ROOT_TWO*radius );
    }
}




//-----------------------------------------------------------------------------
// Name: Reset
// Desc: Reset frame attributes for normal pipes.
//-----------------------------------------------------------------------------
void NORMAL_STATE::Reset()
{
    // Set the joint style
    if( m_bCycleJointStyles ) 
    {
        if( ++(m_jointStyle) >= NUM_JOINT_STYLES )
            m_jointStyle = 0;
    }
}




//-----------------------------------------------------------------------------
// Name: ChooseJointType
// Desc: - Decides which type of joint to draw 
//-----------------------------------------------------------------------------
int NORMAL_STATE::ChooseJointType()
{
    switch( m_jointStyle ) 
    {
        case ELBOWS:
            return ELBOW_JOINT;

        case BALLS:
            return BALL_JOINT;

        case EITHER:
        default:
            // otherwise an elbow or a ball (1/3 ball)
            if( !CPipesScreensaver::iRand(3) )
                return BALL_JOINT;
            else
                return ELBOW_JOINT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\pipe.h ===
//-----------------------------------------------------------------------------
// File: pipe.h
//
// Desc: PIPE base class
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __pipe_h__
#define __pipe_h__

// pipe drawing status
enum 
{
    PIPE_ACTIVE,
    PIPE_STUCK,
    PIPE_OUT_OF_NODES
};

// pipe types
enum 
{
    TYPE_NORMAL,
    TYPE_FLEX_REGULAR,
    TYPE_FLEX_TURNING
};

// ways pipe choose directions
enum 
{
    CHOOSE_DIR_RANDOM_WEIGHTED,
    CHOOSE_DIR_CHASE // when chasing a lead pipe
};

// ways pipe choose start positions
enum 
{
    CHOOSE_STARTPOS_RANDOM,
    CHOOSE_STARTPOS_FURTHEST // furthest from last position
};




//-----------------------------------------------------------------------------
// Name: PIPE class
// Desc: - Describes a pipe that draws thru the node array
//       - Could have more than one pipe drawing in each array at same time
//       - Pipe has position and direction in node array
//-----------------------------------------------------------------------------
class STATE;

class PIPE 
{
public:
    int         m_type;
    IPOINT3D    m_curPos;         // current node position of pipe
    D3DMATERIAL8* m_pMat;

    STATE*      m_pState;        // for state value access

    void        SetChooseDirectionMethod( int method );
    void        SetChooseStartPosMethod( int method );
    int         ChooseNewDirection();
    BOOL        IsStuck();      // if pipe is stuck or not
    BOOL        NowhereToRun()          { return m_status == PIPE_OUT_OF_NODES; }

    PIPE( STATE *state );
    virtual ~PIPE();
    virtual void Start() = 0;
    virtual void Draw() = 0;

protected:
    float       m_radius;         // ideal radius (fluctuates for FPIPE)
    int         m_status;         // ACTIVE/STUCK/STOPPED, etc.
    int         m_lastDir;        // last direction taken by pipe
    int         m_notchVec;       // current notch vector
    int         m_weightStraight; // current weighting of going straight
    ID3DXMatrixStack* m_pWorldMatrixStack;

    BOOL        SetStartPos();  // starting node position
    void        ChooseMaterial();
    void        UpdateCurrentPosition( int dir );
    void        TranslateToCurrentPosition();
    void        align_plusz( int newDir );

private:
    int         m_chooseDirMethod;
    int         m_chooseStartPosMethod;

    int         GetBestDirsForChase( int *bestDirs );
};

extern void align_plusz( int newDir );
extern int notchTurn[NUM_DIRS][NUM_DIRS][NUM_DIRS];

#endif // __pipe_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\objects.h ===
//-----------------------------------------------------------------------------
// File: objects.h
//
// Desc: 
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __objects_h__
#define __objects_h__



//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class OBJECT_BUILD_INFO 
{
public:
    float       m_radius;
    float       m_divSize;
    int         m_nSlices;
    BOOL        m_bTexture;
    IPOINT2D*   m_texRep;
};




//-----------------------------------------------------------------------------
// Name: OBJECT classes
// Desc: - Display list objects
//-----------------------------------------------------------------------------
class OBJECT 
{
protected:
    int         m_listNum;
    int         m_nSlices;

    IDirect3DDevice8*       m_pd3dDevice;
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwNumTriangles;

public:
    void        Draw( D3DXMATRIX* pWorldMat );

    OBJECT( IDirect3DDevice8* pd3dDevice );
    ~OBJECT();
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class PIPE_OBJECT : public OBJECT 
{
private:
    void Build( OBJECT_BUILD_INFO *state, float length, float start_s, float s_end );
public:
    PIPE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, float length );
    PIPE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, float length, float start_s, float end_s );
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class ELBOW_OBJECT : public OBJECT 
{
private:
    void Build( OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
public:
    ELBOW_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, int notch );
    ELBOW_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class BALLJOINT_OBJECT : public OBJECT 
{
private:
    void Build( OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
public:
    // texturing version only
    BALLJOINT_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class SPHERE_OBJECT : public OBJECT 
{
private:
    void Build( OBJECT_BUILD_INFO *state, float radius, float start_s, float end_s );
public:
    SPHERE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, float radius, float start_s, float end_s );
    SPHERE_OBJECT( IDirect3DDevice8* pd3dDevice, OBJECT_BUILD_INFO *state, float radius );
};


#endif // __objects_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\pipe.cpp ===
//-----------------------------------------------------------------------------
// File: pipe.cpp
//
// Desc: Pipe base class stuff
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: PIPE constructor
// Desc: 
//-----------------------------------------------------------------------------
PIPE::PIPE( STATE *state )
{
    m_pState = state;
    m_pWorldMatrixStack = m_pState->m_pWorldMatrixStack;
    m_radius = m_pState->m_radius;

    // default direction choosing is random
    m_chooseDirMethod = CHOOSE_DIR_RANDOM_WEIGHTED;
    m_chooseStartPosMethod = CHOOSE_STARTPOS_RANDOM;
    m_weightStraight = 1;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
PIPE::~PIPE()
{
}




//-----------------------------------------------------------------------------
// Name: ChooseMaterial
// Desc: 
//-----------------------------------------------------------------------------
void PIPE::ChooseMaterial( )
{
    if( m_pState->m_bUseTexture )
        m_pMat = RandomTexMaterial();
    else
        m_pMat = RandomTeaMaterial();
}




//-----------------------------------------------------------------------------
// Name: SetChooseDirectionMethod
// Desc: 
//-----------------------------------------------------------------------------
void PIPE::SetChooseDirectionMethod( int method )
{
    m_chooseDirMethod = method;
}




//-----------------------------------------------------------------------------
// Name: ChooseNewDirection
// Desc: Call direction-finding function based on current method
//       This is a generic entry point that is used by some pipe types
//-----------------------------------------------------------------------------
int PIPE::ChooseNewDirection()
{
    NODE_ARRAY* nodes = m_pState->m_nodes;
    int bestDirs[NUM_DIRS], nBestDirs;

    // figger out which fn to call
    switch( m_chooseDirMethod ) 
    {
        case CHOOSE_DIR_CHASE:
            if( nBestDirs = GetBestDirsForChase( bestDirs ) )
                return nodes->ChoosePreferredDirection( &m_curPos, m_lastDir, 
                                                        bestDirs, nBestDirs );
            // else lead pipe must have died, so fall thru:

        case CHOOSE_DIR_RANDOM_WEIGHTED :
        default:
            return nodes->ChooseRandomDirection( &m_curPos, m_lastDir, m_weightStraight );
    }
}




//-----------------------------------------------------------------------------
// Name: GetBestDirsForChase
// Desc: Find the best directions to take to close in on the lead pipe in chase mode.
//
//       mf: ? but want to use similar scheme for turning flex pipes !! (later) 
//-----------------------------------------------------------------------------
int PIPE::GetBestDirsForChase( int *bestDirs )
{
    // Figure out best dirs to close in on leadPos

    //mf: will have to 'protect' leadPos with GetLeadPos() for multi-threading
    IPOINT3D* leadPos = &m_pState->m_pLeadPipe->m_curPos;
    IPOINT3D delta;
    int numDirs = 0;

    delta.x = leadPos->x - m_curPos.x;
    delta.y = leadPos->y - m_curPos.y;
    delta.z = leadPos->z - m_curPos.z;

    if( delta.x ) 
    {
        numDirs++;
        *bestDirs++ = delta.x > 0 ? PLUS_X : MINUS_X;
    }

    if( delta.y ) 
    {
        numDirs++;
        *bestDirs++ = delta.y > 0 ? PLUS_Y : MINUS_Y;
    }

    if( delta.z ) 
    {
        numDirs++;
        *bestDirs++ = delta.z > 0 ? PLUS_Z : MINUS_Z;
    }

    // It should be impossible for numDirs = 0 (all deltas = 0), as this
    // means curPos = leadPos
    return numDirs;
}




//-----------------------------------------------------------------------------
// Name: SetChooseStartPosMethod
// Desc: 
//-----------------------------------------------------------------------------
void PIPE::SetChooseStartPosMethod( int method )
{
    m_chooseStartPosMethod = method;
}




//-----------------------------------------------------------------------------
// Name: PIPE::SetStartPos
// Desc: - Find an empty node to start the pipe on
//-----------------------------------------------------------------------------
BOOL PIPE::SetStartPos()
{
    NODE_ARRAY* nodes = m_pState->m_nodes;

    switch( m_chooseStartPosMethod ) 
    {
        case CHOOSE_STARTPOS_RANDOM:
        default:
            if( !nodes->FindRandomEmptyNode( &m_curPos ) ) 
            {
                return FALSE;
            }
            return TRUE;
        
        case CHOOSE_STARTPOS_FURTHEST:
            // find node furthest away from curPos
            IPOINT3D refPos, numNodes;
            nodes->GetNodeCount( &numNodes );
            refPos.x = (m_curPos.x >= (numNodes.x / 2)) ? 0 : numNodes.x - 1;
            refPos.y = (m_curPos.y >= (numNodes.y / 2)) ? 0 : numNodes.y - 1;
            refPos.z = (m_curPos.z >= (numNodes.z / 2)) ? 0 : numNodes.z - 1;

            if( !nodes->TakeClosestEmptyNode( &m_curPos, &refPos ) ) 
            {
                return FALSE;
            }
            return TRUE;
    }
}




//-----------------------------------------------------------------------------
// Name: PIPE::IsStuck
// Desc: 
//-----------------------------------------------------------------------------
BOOL PIPE::IsStuck()
{
    return m_status == PIPE_STUCK;
}




//-----------------------------------------------------------------------------
// Name: PIPE::TranslateToCurrentPosition
// Desc: 
//-----------------------------------------------------------------------------
void PIPE::TranslateToCurrentPosition()
{
    IPOINT3D numNodes;

    float divSize = m_pState->m_view.m_divSize;

    // this requires knowing the size of the node array
    m_pState->m_nodes->GetNodeCount( &numNodes );

    m_pWorldMatrixStack->TranslateLocal( (m_curPos.x - (numNodes.x - 1)/2.0f )*divSize,
                                    (m_curPos.y - (numNodes.y - 1)/2.0f )*divSize,
                                    (m_curPos.z - (numNodes.z - 1)/2.0f )*divSize );

}




//-----------------------------------------------------------------------------
// Name: UpdateCurrentPosition
// Desc: Increment current position according to direction taken
//-----------------------------------------------------------------------------
void PIPE::UpdateCurrentPosition( int newDir )
{
    switch( newDir ) 
    {
        case PLUS_X:
            m_curPos.x += 1;
            break;
        case MINUS_X:
            m_curPos.x -= 1;
            break;
        case PLUS_Y:
            m_curPos.y += 1;
            break;
        case MINUS_Y:
            m_curPos.y -= 1;
            break;
        case PLUS_Z:
            m_curPos.z += 1;
            break;
        case MINUS_Z:
            m_curPos.z -= 1;
            break;
    }
}




//-----------------------------------------------------------------------------
// Name: align_plusz
// Desc: - Aligns the z axis along specified direction
//       - Used for all types of pipes
//-----------------------------------------------------------------------------
void PIPE::align_plusz( int newDir )
{
    static D3DXVECTOR3 xAxis = D3DXVECTOR3(1.0f,0.0f,0.0f);
    static D3DXVECTOR3 yAxis = D3DXVECTOR3(0.0f,1.0f,0.0f);

    // align +z along new direction
    switch( newDir ) 
    {
        case PLUS_X:
            m_pWorldMatrixStack->RotateAxisLocal( &yAxis, PI/2.0f );
            break;
        case MINUS_X:
            m_pWorldMatrixStack->RotateAxisLocal( &yAxis, -PI/2.0f );
            break;
        case PLUS_Y:
            m_pWorldMatrixStack->RotateAxisLocal( &xAxis, -PI/2.0f );
            break;
        case MINUS_Y:
            m_pWorldMatrixStack->RotateAxisLocal( &xAxis, PI/2.0f );
            break;
        case PLUS_Z:
            m_pWorldMatrixStack->RotateAxisLocal( &yAxis, 0.0f );
            break;
        case MINUS_Z:
            m_pWorldMatrixStack->RotateAxisLocal( &yAxis, PI );
            break;

    }
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: this array tells you which way the notch will be once you make
//       a turn
//       format: notchTurn[oldDir][newDir][notchVec] 
//-----------------------------------------------------------------------------
int notchTurn[NUM_DIRS][NUM_DIRS][NUM_DIRS] = 
{
// oldDir = +x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Z, MINUS_Z,
        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,
        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X,
        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,
// oldDir = -x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,
        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Z, MINUS_Z,
        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,
        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X,

// oldDir = +y
        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_Z, MINUS_Z,
        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_Z, MINUS_Z,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y,
        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y,
// oldDir = -y
        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_Z, MINUS_Z,
        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_Z, MINUS_Z,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y,
        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y,

// oldDir = +z
        MINUS_Z,PLUS_Z, PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_Z, MINUS_Z,PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_X, MINUS_X,MINUS_Z,PLUS_Z, iXX,    iXX,
        PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
// oldDir = -z
        PLUS_Z, MINUS_Z,PLUS_Y, MINUS_Y,iXX,    iXX,
        MINUS_Z,PLUS_Z, PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,iXX,    iXX,
        PLUS_X, MINUS_X,MINUS_Z,PLUS_Z, iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Pipes.rc
//

#define IDS_DESCRIPTION			1
#define IDD_CONFIGURE                   106
#define IDB_DEFTEX                      107

#define IDI_MAIN_ICON                   101
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201

#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016

#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112

#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212



#define IDC_RADIO_SINGLE_PIPE           3000
#define IDC_RADIO_MULTIPLE_PIPES        3001
#define IDC_RADIO_NORMAL                3002
#define IDC_RADIO_FLEX                  3003
#define IDC_STATIC_TESS_GRP             3004
#define IDC_STATIC_JOINTTYPE            3005
#define IDC_RADIO_SOLID                 3006
#define IDC_RADIO_TEX                   3007
#define DLG_COMBO_JOINTTYPE             3008
#define IDC_STATIC_TESS_MIN             3009
#define IDC_STATIC_TESS_MAX             3010
#define DLG_SETUP_TESSEL                3011
#define DLG_SETUP_TEXTURE               3012
#define IDC_SCREENSETTINGS	        3013
#define IDC_SPEED_SLIDER                3014
#define IDS_TEXTUREFILTER               3015
#define IDS_TEXTUREDIALOGTITLE          3016
#define IDS_TITLE			3017

#define IDS_JOINT_FIRST 		IDS_JOINT_ELBOW
#define IDS_JOINT_ELBOW                 4001
#define IDS_JOINT_BALL                  4002
#define IDS_JOINT_MIXED                 4003
#define IDS_JOINT_CYCLE                 4004
#define IDS_JOINT_LAST 			IDS_JOINT_CYCLE
#define IDS_JOINT_COUNT 		(IDS_JOINT_LAST-IDS_JOINT_FIRST+1)

#define IDS_JOINTTYPE                   9000
#define IDS_SURFSTYLE                   9001
#define IDS_TEXQUAL                     9002
#define IDS_MULTIPIPES                  9003
#define IDS_SAVERNAME                   9004
#define IDS_INIFILE                     9005
#define IDS_TEXTURE                     9006
    
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40000
#define _APS_NEXT_CONTROL_VALUE         3015
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\pipes.cpp ===
//-----------------------------------------------------------------------------
// File: Pipes.cpp
//
// Desc: Fun screen saver.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: struct MYVERTEX
// Desc: D3D vertex type for this app
//-----------------------------------------------------------------------------
struct MYVERTEX
{
    D3DXVECTOR3 p;     // Position
    FLOAT       tu;    // Vertex texture coordinates
    FLOAT       tv;
    
    MYVERTEX(D3DXVECTOR3 pInit, FLOAT tuInit, FLOAT tvInit)
        { p = pInit; tu = tuInit; tv = tvInit; }
};

#define D3DFVF_MYVERTEX (D3DFVF_XYZ | D3DFVF_TEX1)



#define BUF_SIZE 255
TCHAR g_szSectName[BUF_SIZE];
TCHAR g_szFname[BUF_SIZE];


CPipesScreensaver* g_pMyPipesScreensaver = NULL;



//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
{
    HRESULT hr;
    CPipesScreensaver pipesScreensaverSS;

    if( FAILED( hr = pipesScreensaverSS.Create( hInst ) ) )
    {
        pipesScreensaverSS.DisplayErrorMsg( hr );
        return 0;
    }

    return pipesScreensaverSS.Run();
}




//-----------------------------------------------------------------------------
// Name: CPipesScreensaver()
// Desc: Constructor
//-----------------------------------------------------------------------------
CPipesScreensaver::CPipesScreensaver( )
{
    g_pMyPipesScreensaver = this;

    InitCommonControls();

    for( int i=0; i<MAX_DEVICE_OBJECTS; i++ )
    {
        m_DeviceObjects[i].m_pState = NULL;
    }

    LoadString( NULL, IDS_DESCRIPTION, m_strWindowTitle, 200 );
    m_bUseDepthBuffer = TRUE;
    m_SwapEffectFullscreen = D3DSWAPEFFECT_COPY;
    m_SwapEffectWindowed = D3DSWAPEFFECT_COPY_VSYNC;
    m_pDeviceObjects = NULL;
    lstrcpy( m_strRegPath, TEXT("Software\\Microsoft\\ScreenSavers\\Pipes") );

    m_Config.bMultiPipes     = FALSE;
    m_Config.nJointType      = JOINT_ELBOW;
    m_Config.bTextured       = FALSE;
    m_Config.bDefaultTexture = TRUE;
    lstrcpy( m_Config.strTextureName[0], TEXT("") );
    m_Config.bFlexMode       = FALSE;
    m_Config.dwTesselFact    = 0;
    m_Config.dwSpeed         = 16;
    
    m_iRenderUnit = 0;

    RandInit();
}



//-----------------------------------------------------------------------------
// Name: SetDevice()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::SetDevice( UINT iDevice )
{
    m_pDeviceObjects = &m_DeviceObjects[iDevice];
    m_iRenderUnit = iDevice;
}




//-----------------------------------------------------------------------------
// Name: RegisterSoftwareDevice()
// Desc: This can register the D3D8RGBRasterizer or any other
//       pluggable software rasterizer.
//-----------------------------------------------------------------------------
HRESULT CPipesScreensaver::RegisterSoftwareDevice()
{ 
    m_pD3D->RegisterSoftwareDevice( D3D8RGBRasterizer );

    return S_OK; 
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CPipesScreensaver::FrameMove()
{
    m_pDeviceObjects->m_pState->FrameMove( m_fElapsedTime );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DoPaint()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::DoPaint(HWND hwnd, HDC hdc)
{
    CD3DScreensaver::DoPaint( hwnd, hdc );

    for( int iDevice=0; iDevice<MAX_DEVICE_OBJECTS; iDevice++ )
    {
        if( m_DeviceObjects[iDevice].m_pState )
            m_DeviceObjects[iDevice].m_pState->Repaint();
    }
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CPipesScreensaver::Render()
{
    BOOL bRenderNewPiece = FALSE;

    if( m_Config.dwSpeed == 20 )
    {
        bRenderNewPiece = TRUE;
    }
    else
    {
        FLOAT fCurTime = DXUtil_Timer( TIMER_GETAPPTIME );
        if( fCurTime - m_pDeviceObjects->m_pState->m_fLastTime > 
                            (20-m_Config.dwSpeed) * 0.005 )
        {
            bRenderNewPiece = TRUE;
            m_pDeviceObjects->m_pState->m_fLastTime = fCurTime;
        }
    }

    if( bRenderNewPiece )
    {       
        // Begin the scene 
        if( SUCCEEDED( m_pd3dDevice->BeginScene() ) )
        {
            m_pDeviceObjects->m_pState->Render();

            // End the scene.
            m_pd3dDevice->EndScene();
        }
    }
    else
    {
        if( m_iRenderUnit == 0 )
        {
            // Wait for a little while so we don't draw the pipes too fast
            Sleep(10);
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CPipesScreensaver::RestoreDeviceObjects()
{
    if( m_pd3dDevice == NULL )
        return S_OK;
    
    m_pDeviceObjects->m_pState    = new STATE( &m_Config );
    m_pDeviceObjects->m_pState->InitDeviceObjects( m_pd3dDevice );
    m_pDeviceObjects->m_pState->RestoreDeviceObjects();

    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         0x00000000, 1.0f, 0L );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CPipesScreensaver::InvalidateDeviceObjects()
{
    m_pDeviceObjects->m_pState->InvalidateDeviceObjects();
    m_pDeviceObjects->m_pState->DeleteDeviceObjects();
    SAFE_DELETE( m_pDeviceObjects->m_pState );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ConfigureDialogProcHelper()
// Desc: 
//-----------------------------------------------------------------------------
INT_PTR CALLBACK ConfigureDialogProcHelper( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return g_pMyPipesScreensaver->ConfigureDialogProc( hwndDlg, uMsg, wParam, lParam );
}




//-----------------------------------------------------------------------------
// Name: DoConfig()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::DoConfig()
{
    DialogBox( NULL, MAKEINTRESOURCE(IDD_CONFIGURE), m_hWndParent, ConfigureDialogProcHelper );
}




//-----------------------------------------------------------------------------
// Name: ConfigureDialogProc()
// Desc: 
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CPipesScreensaver::ConfigureDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    static CONFIG s_TempConfig;

    switch (uMsg)
    {
        case WM_INITDIALOG:       
        {
            ReadSettings();
            s_TempConfig = m_Config;
            lstrcpy( s_TempConfig.strTextureName[0], m_Config.strTextureName[0] );

            if( s_TempConfig.bMultiPipes )       
                CheckRadioButton(hwndDlg, IDC_RADIO_SINGLE_PIPE, IDC_RADIO_MULTIPLE_PIPES,
                                 IDC_RADIO_MULTIPLE_PIPES);
            else
                CheckRadioButton(hwndDlg, IDC_RADIO_SINGLE_PIPE, IDC_RADIO_MULTIPLE_PIPES,
                                 IDC_RADIO_SINGLE_PIPE);

            HWND hCtrl = GetDlgItem(hwndDlg, DLG_COMBO_JOINTTYPE);
            SendMessage(hCtrl, CB_RESETCONTENT, 0, 0);

            TCHAR strJointNames[IDS_JOINT_COUNT][MAX_PATH];
            for (int i = 0; i < IDS_JOINT_COUNT; i++)
            {
                LoadString( NULL, i+IDS_JOINT_FIRST, strJointNames[i],
                            sizeof(strJointNames)/IDS_JOINT_COUNT );
                SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)strJointNames[i]);
            }
            SendMessage(hCtrl, CB_SETCURSEL, s_TempConfig.nJointType, 0);

            if( !s_TempConfig.bTextured )
            {
                CheckRadioButton(hwndDlg, IDC_RADIO_SOLID, IDC_RADIO_TEX,
                                 IDC_RADIO_SOLID);
                EnableWindow( GetDlgItem( hwndDlg, DLG_SETUP_TEXTURE ), FALSE );
            }
            else
            {
                CheckRadioButton(hwndDlg, IDC_RADIO_SOLID, IDC_RADIO_TEX,
                                 IDC_RADIO_TEX);
                EnableWindow( GetDlgItem( hwndDlg, DLG_SETUP_TEXTURE ), TRUE );
            }
        
            SendDlgItemMessage( hwndDlg, IDC_SPEED_SLIDER, TBM_SETRANGE, (WPARAM) TRUE, (LPARAM) MAKELONG( 0, 20 ) );
            SendDlgItemMessage( hwndDlg, IDC_SPEED_SLIDER, TBM_SETPOS,   (WPARAM) TRUE, (LPARAM) m_Config.dwSpeed );
            SendDlgItemMessage( hwndDlg, IDC_SPEED_SLIDER, TBM_SETPAGESIZE, (WPARAM) 0, (LPARAM) 5 );
            SendDlgItemMessage( hwndDlg, IDC_SPEED_SLIDER, TBM_SETLINESIZE, (WPARAM) 0, (LPARAM) 1 );
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch( LOWORD( wParam ) )
            {
                case IDC_RADIO_TEX:
                    EnableWindow( GetDlgItem( hwndDlg, DLG_SETUP_TEXTURE ), TRUE );
                    break;

                case IDC_RADIO_SOLID:
                    EnableWindow( GetDlgItem( hwndDlg, DLG_SETUP_TEXTURE ), FALSE );
                    break;

                case DLG_SETUP_TEXTURE:
                {
                    if( SelectTextureFile( hwndDlg, s_TempConfig.strTextureName[0] ) )
                    {
                        CheckRadioButton(hwndDlg, IDC_RADIO_SOLID, IDC_RADIO_TEX,
                                         IDC_RADIO_TEX);
                        s_TempConfig.bDefaultTexture = FALSE;
                    }
                    else
                    {
                        s_TempConfig.bDefaultTexture = TRUE;
                    }
                    break;
                }

                case IDC_SCREENSETTINGS:
                {
                    DoScreenSettingsDialog( hwndDlg ); 
                    break;
                }

                case IDOK:
                {
                    s_TempConfig.bMultiPipes = IsDlgButtonChecked(hwndDlg, IDC_RADIO_MULTIPLE_PIPES);
                    HWND hCtrl = GetDlgItem(hwndDlg, DLG_COMBO_JOINTTYPE);
                    s_TempConfig.nJointType = (DWORD) SendMessage(hCtrl, CB_GETCURSEL, 0, 0);
                    s_TempConfig.bTextured = IsDlgButtonChecked(hwndDlg, IDC_RADIO_TEX);
                    s_TempConfig.dwSpeed = (DWORD) SendDlgItemMessage( hwndDlg, IDC_SPEED_SLIDER, TBM_GETPOS, 0, 0 );

                    m_Config = s_TempConfig;
                    lstrcpy( m_Config.strTextureName[0], s_TempConfig.strTextureName[0] );

                    WriteSettings();
                    EndDialog(hwndDlg, IDOK);
                    break;
                }

                case IDCANCEL:
                {
                    EndDialog(hwndDlg, IDCANCEL);
                    break;
                }
            }
            return TRUE;
        }
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
// Name: SelectTextureFile()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CPipesScreensaver::SelectTextureFile( HWND hDlg, TCHAR* origPathName )
{
    TCHAR fn[MAX_PATH] = TEXT("\0");
    TCHAR szDialogTitle[MAX_PATH];
    TCHAR szTextureFilter[MAX_PATH];
    TCHAR szTitle[MAX_PATH];

    LoadString(NULL, IDS_TEXTUREFILTER, szTextureFilter, MAX_PATH);
    // Filter strings are weird because they contain nulls.
    // The string loaded from a resource has # where nulls
    // should be inserted.
    for( TCHAR* pch = szTextureFilter; *pch != TEXT('\0'); pch++ )
    {
        if (*pch == TEXT('#'))
            *pch = TEXT('\0');
    }
    LoadString(NULL, IDS_TEXTUREDIALOGTITLE, szDialogTitle, MAX_PATH);
    LoadString(NULL, IDS_TITLE, szTitle, MAX_PATH);

    TCHAR szWindowsDir[MAX_PATH + 1];
    if( 0 == GetWindowsDirectory( szWindowsDir, MAX_PATH + 1 ) )
        szWindowsDir[0] = TEXT('\0');

    OPENFILENAME    ofn;
    memset( &ofn, 0, sizeof(ofn) );
    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hDlg;
    ofn.hInstance       = m_hInstance;
    ofn.lpstrFilter     = szTextureFilter;
    ofn.nFilterIndex    = 1;
    ofn.lpstrFile       = origPathName;
    ofn.nMaxFile        = sizeof(fn);
    ofn.lpstrTitle      = szDialogTitle;
    ofn.Flags           = OFN_ENABLESIZING|OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt     = TEXT("BMP");
    if( lstrlen( origPathName ) == 0 )
        ofn.lpstrInitialDir = szWindowsDir;

    if( GetOpenFileName( &ofn ) )
    {
        lstrcpy( origPathName, ofn.lpstrFile );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::ReadSettings()
{
    HKEY hkey;

    // Read OpenGL settings first, so OS upgrade cases work
    ss_ReadSettings();

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        ReadScreenSettings( hkey );

//        DXUtil_ReadBoolRegKey( hkey, TEXT("Flex Mode"), &m_Config.bFlexMode, m_Config.bFlexMode );
        DXUtil_ReadBoolRegKey( hkey, TEXT("MultiPipes"), &m_Config.bMultiPipes, m_Config.bMultiPipes );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Textured"), &m_Config.bTextured, m_Config.bTextured );
        DXUtil_ReadBoolRegKey( hkey, TEXT("Default Texture"), &m_Config.bDefaultTexture, m_Config.bDefaultTexture );
        DXUtil_ReadIntRegKey( hkey, TEXT("Tessel Factor"), &m_Config.dwTesselFact, m_Config.dwTesselFact );
        if( m_Config.dwTesselFact >= 4 )
            m_Config.dwTesselFact = 4;
        DXUtil_ReadIntRegKey( hkey, TEXT("Joint Type"), &m_Config.nJointType, m_Config.nJointType );
        if( m_Config.nJointType >= NUM_JOINTTYPES )
            m_Config.nJointType = JOINT_ELBOW;
        DXUtil_ReadIntRegKey( hkey, TEXT("Speed"), &m_Config.dwSpeed, m_Config.dwSpeed );
        DXUtil_ReadStringRegKey( hkey, TEXT("Texture Name"), m_Config.strTextureName[0], MAX_PATH, m_Config.strTextureName[0] );

        RegCloseKey( hkey );
    }
}




//-----------------------------------------------------------------------------
// Name: ss_ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::ss_ReadSettings()
{
    // Get registry settings
    if( ss_RegistrySetup( IDS_SAVERNAME, IDS_INIFILE ) )
    {
        m_Config.nJointType = ss_GetRegistryInt( IDS_JOINTTYPE, 0 );
        m_Config.bTextured = (ss_GetRegistryInt( IDS_SURFSTYLE, 0 ) == 1);
        if( m_Config.bTextured )
            m_Config.bDefaultTexture = TRUE;

        m_Config.bMultiPipes = ss_GetRegistryInt( IDS_MULTIPIPES, 0 );
        ss_GetRegistryString( IDS_TEXTURE, 0, m_Config.strTextureName[0], MAX_PATH);
        if( lstrlen(m_Config.strTextureName[0]) > 0 )
            m_Config.bDefaultTexture = FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CPipesScreensaver::ss_RegistrySetup( int section, int file )
{
    if( LoadString(m_hInstance, section, g_szSectName, BUF_SIZE) &&
        LoadString(m_hInstance, file, g_szFname, BUF_SIZE) ) 
    {
        TCHAR pBuffer[100];
        DWORD dwRealSize = GetPrivateProfileSection( g_szSectName, pBuffer, 100, g_szFname );
        if( dwRealSize > 0 )
            return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
int CPipesScreensaver::ss_GetRegistryInt( int name, int iDefault )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        return GetPrivateProfileInt(g_szSectName, szItemName, iDefault, g_szFname);

    return 0;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::ss_GetRegistryString( int name, LPTSTR lpDefault, 
                                                         LPTSTR lpDest, int bufSize )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        GetPrivateProfileString(g_szSectName, szItemName, lpDefault, lpDest,
                                bufSize, g_szFname);

    return;
}




//-----------------------------------------------------------------------------
// Name: WriteSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::WriteSettings()
{
    HKEY hkey;
    DWORD dwType = REG_DWORD;
    DWORD dwLength = sizeof(DWORD);

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        WriteScreenSettings( hkey );

//        DXUtil_WriteBoolRegKey( hkey, TEXT("Flex Mode"), m_Config.bFlexMode );
        DXUtil_WriteBoolRegKey( hkey, TEXT("MultiPipes"), m_Config.bMultiPipes );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Textured"), m_Config.bTextured );
        DXUtil_WriteBoolRegKey( hkey, TEXT("Default Texture"), m_Config.bDefaultTexture );
        DXUtil_WriteIntRegKey( hkey, TEXT("Tessel Factor"), m_Config.dwTesselFact );
        DXUtil_WriteIntRegKey( hkey, TEXT("Joint Type"), m_Config.nJointType );
        DXUtil_WriteStringRegKey( hkey, TEXT("Texture Name"), m_Config.strTextureName[0] );
        DXUtil_WriteIntRegKey( hkey, TEXT("Speed"), m_Config.dwSpeed );
        
        RegCloseKey( hkey );
    }
}




//-----------------------------------------------------------------------------
// Name: iRand()
// Desc: Generates integer random number 0..(max-1)
//-----------------------------------------------------------------------------
int CPipesScreensaver::iRand( int max )
{
    return (int) ( max * ( ((float)rand()) / ((float)(RAND_MAX+1)) ) );
}




//-----------------------------------------------------------------------------
// Name: iRand2()
// Desc: Generates integer random number min..max
//-----------------------------------------------------------------------------
int CPipesScreensaver::iRand2( int min, int max )
{
    if( min == max )
    {
        return min;
    }
    else if( max < min ) 
    {
        int temp = min;
        min = max;
        max = temp;
    }

    return min + (int) ( (max-min+1) * ( ((float)rand()) / ((float)(RAND_MAX+1)) ) );
}




//-----------------------------------------------------------------------------
// Name: fRand()
// Desc: Generates float random number min...max
//-----------------------------------------------------------------------------
FLOAT CPipesScreensaver::fRand( FLOAT min, FLOAT max )
{
    FLOAT diff;

    diff = max - min;
    return min + ( diff * ( ((float)rand()) / ((float)(RAND_MAX)) ) );
}




//-----------------------------------------------------------------------------
// Name: RandInit()
// Desc: Initializes the randomizer
//-----------------------------------------------------------------------------
VOID CPipesScreensaver::RandInit()
{
    struct _timeb time;

    _ftime( &time );
    srand( time.millitm );

    for( int i = 0; i < 10; i ++ )
        rand();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\pipes.h ===
//-----------------------------------------------------------------------------
// File: Pipes.h
//
// Desc: 
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _PIPES_H
#define _PIPES_H


#define MAX_DEVICE_OBJECTS 10

struct DeviceObjects
{
    STATE*    m_pState;
};

struct CONFIG
{
    BOOL  bMultiPipes;
    DWORD nJointType;
    BOOL  bTextured;
    BOOL  bDefaultTexture;
    TCHAR strTextureName[MAX_PATH][MAX_TEXTURES];
    DWORD dwSpeed;
    BOOL  bFlexMode;
    DWORD dwTesselFact;
};



//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class CPipesScreensaver : public CD3DScreensaver
{
protected:
    DeviceObjects  m_DeviceObjects[MAX_DEVICE_OBJECTS];
    DeviceObjects* m_pDeviceObjects;
    int            m_iRenderUnit;

    D3DXCOLOR m_col3;

protected:
    virtual HRESULT RegisterSoftwareDevice();
    virtual VOID    DoConfig();
    virtual VOID    ReadSettings();
            VOID    WriteSettings();
    virtual VOID    DoPaint( HWND hwnd, HDC hdc );

    virtual VOID    SetDevice( UINT iDevice );
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();

    VOID    Randomize( INT* piNum, INT iMax );


public:
    CPipesScreensaver();

    CONFIG  m_Config;
    D3DSURFACE_DESC* GetSurfaceDesc() { return &m_d3dsdBackBuffer; };
    BOOL SelectTextureFile( HWND hDlg, TCHAR* origPathName );

    VOID ss_ReadSettings();
    BOOL ss_RegistrySetup( int section, int file );
    int  ss_GetRegistryInt( int name, int iDefault );
    VOID ss_GetRegistryString( int name, LPTSTR lpDefault, LPTSTR lpDest, int bufSize );
    
    // Override from CD3DScreensaver
    INT_PTR CALLBACK ConfigureDialogProc( HWND hwndDlg, UINT uMsg, 
                                          WPARAM wParam, LPARAM lParam );

    static int iRand( int max );
    static int iRand2( int min, int max );
    static FLOAT fRand( FLOAT min, FLOAT max );
    static VOID RandInit();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\material.cpp ===
//-----------------------------------------------------------------------------
// File: material.cpp
//
// Desc: materials
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"




// 24 tea materials (from teapots app)
#define NUM_TEA_MATERIALS 24

enum 
{
    EMERALD = 0,
    JADE,
    OBSIDIAN,
    PEARL,
    RUBY,
    TURQUOISE,
    BRASS,
    BRONZE,
    CHROME,
    COPPER,
    GOLD,
    SILVER,
    BLACK_PLASTIC,
    CYAN_PLASTIC,
    GREEN_PLASTIC,
    RED_PLASTIC,
    WHITE_PLASTIC,
    YELLOW_PLASTIC,
    BLACK_RUBBER,
    CYAN_RUBBER,
    GREEN_RUBBER,
    RED_RUBBER,
    WHITE_RUBBER,
    YELLOW_RUBBER
};

// 'white' materials, for texturing
#define NUM_TEX_MATERIALS 4

enum 
{
    BRIGHT_WHITE = NUM_TEA_MATERIALS,
    WHITE,
    WARM_WHITE,
    COOL_WHITE
};

#define NUM_GOOD_MATERIALS 16  // 'good' ones among the 24 tea materials

int goodMaterials[NUM_GOOD_MATERIALS] = {
        EMERALD, JADE, PEARL, RUBY, TURQUOISE, BRASS, BRONZE,
        COPPER, GOLD, SILVER, CYAN_PLASTIC, WHITE_PLASTIC, YELLOW_PLASTIC,
        CYAN_RUBBER, GREEN_RUBBER, WHITE_RUBBER };

// materials:  emerald, jade, obsidian, pearl, ruby, turquoise
//              brass, bronze, chrome, copper, gold, silver
//              black, cyan, green, red, white, yellow plastic
//              black, cyan, green, red, white, yellow rubber
// 
// description: ambient(RGB), diffuse(RGB), specular(RGB), shininess
 
// 'tea' materials, from aux teapots program
static float teaMaterialData[NUM_TEA_MATERIALS*10] = 
{
    // EMERALD = 0,
    0.0215f, 0.1745f, 0.0215f, 0.07568f, 0.61424f, 0.07568f, 0.633f, 0.727811f, 0.633f, 0.6f,

    // JADE,
    0.135f, 0.2225f, 0.1575f, 0.54f, 0.89f, 0.63f, 0.316228f, 0.316228f, 0.316228f, 0.1f,

    // OBSIDIAN,
    0.05375f, 0.05f, 0.06625f, 0.18275f, 0.17f, 0.22525f, 0.332741f, 0.328634f, 0.346435f, 0.3f,

    // PEARL,
    0.25f, 0.20725f, 0.20725f, 1.0f, 0.829f, 0.829f, 0.296648f, 0.296648f, 0.296648f, 0.088f,

    // RUBY,
    0.1745f, 0.01175f, 0.01175f, 0.61424f, 0.04136f, 0.04136f, 0.727811f, 0.626959f, 0.626959f, 0.6f,

    // TURQUOISE,
    0.1f, 0.18725f, 0.1745f, 0.396f, 0.74151f, 0.69102f, 0.297254f, 0.30829f, 0.306678f, 0.1f,

    // BRASS,
    0.329412f, 0.223529f, 0.027451f, 0.780392f, 0.568627f, 0.113725f, 0.992157f, 0.941176f, 0.807843f, 0.21794872f,

    // BRONZE,
    0.2125f, 0.1275f, 0.054f, 0.714f, 0.4284f, 0.18144f, 0.393548f, 0.271906f, 0.166721f, 0.2f,

    // CHROME,
    0.25f, 0.25f, 0.25f,  0.4f, 0.4f, 0.4f, 0.774597f, 0.774597f, 0.774597f, 0.6f,

    // COPPER,
    0.19125f, 0.0735f, 0.0225f, 0.7038f, 0.27048f, 0.0828f, 0.256777f, 0.137622f, 0.086014f, 0.1f,

    // GOLD,
    0.24725f, 0.1995f, 0.0745f, 0.75164f, 0.60648f, 0.22648f, 0.628281f, 0.555802f, 0.366065f, 0.4f,

    // SILVER,
    0.19225f, 0.19225f, 0.19225f, 0.50754f, 0.50754f, 0.50754f, 0.508273f, 0.508273f, 0.508273f, 0.4f,

    // BLACK_PLASTIC,
    0.0f, 0.0f, 0.0f, 0.01f, 0.01f, 0.01f, 0.50f, 0.50f, 0.50f, .25f,

    // CYAN_PLASTIC,
    0.0f, 0.1f, 0.06f, 0.0f, 0.50980392f, 0.50980392f, 0.50196078f, 0.50196078f, 0.50196078f, .25f,

    // GREEN_PLASTIC,
    0.0f, 0.0f, 0.0f, 0.1f, 0.35f, 0.1f, 0.45f, 0.55f, 0.45f, .25f,

    // RED_PLASTIC,
    0.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, 0.7f, 0.6f, 0.6f, .25f,

    // WHITE_PLASTIC,
    0.0f, 0.0f, 0.0f, 0.55f, 0.55f, 0.55f, 0.70f, 0.70f, 0.70f, .25f,

    // YELLOW_PLASTIC,
    0.0f, 0.0f, 0.0f, 0.5f, 0.5f, 0.0f, 0.60f, 0.60f, 0.50f, .25f,

    // BLACK_RUBBER,
    0.02f, 0.02f, 0.02f, 0.01f, 0.01f, 0.01f, 0.4f, 0.4f, 0.4f, .078125f,

    // CYAN_RUBBER,
    0.0f, 0.05f, 0.05f, 0.4f, 0.5f, 0.5f, 0.04f, 0.7f, 0.7f, .078125f,

    // GREEN_RUBBER,
    0.0f, 0.05f, 0.0f, 0.4f, 0.5f, 0.4f, 0.04f, 0.7f, 0.04f, .078125f,

    // RED_RUBBER,
    0.05f, 0.0f, 0.0f, 0.5f, 0.4f, 0.4f, 0.7f, 0.04f, 0.04f, .078125f,

    // WHITE_RUBBER,
    0.05f, 0.05f, 0.05f, 0.5f, 0.5f, 0.5f, 0.7f, 0.7f, 0.7f, .078125f,

    // YELLOW_RUBBER
    0.05f, 0.05f, 0.0f, 0.5f, 0.5f, 0.4f, 0.7f, 0.7f, 0.04f, .078125f 
};

// generally white materials for texturing

static float texMaterialData[NUM_TEX_MATERIALS*10] = 
{
// bright white
     0.2f, 0.2f, 0.2f,
        1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.5f,
// less bright white
     0.2f, 0.2f, 0.2f,
        0.9f, 0.9f, 0.9f, 0.9f, 0.9f, 0.9f, 0.5f,
// warmish white
     0.3f, 0.2f, 0.2f,
        1.0f, 0.9f, 0.8f, 1.0f, 0.9f, 0.8f, 0.5f,
// coolish white
     0.2f, 0.2f, 0.3f,
        0.8f, 0.9f, 1.0f, 0.8f, 0.9f, 1.0f, 0.5f
};

D3DMATERIAL8 g_Materials[NUM_TEA_MATERIALS + NUM_TEX_MATERIALS];

//-----------------------------------------------------------------------------
// Name: InitMaterials
// Desc: Initialize MATERIAL structures with data
//       - Set alpha to 0.5 for all materials
//-----------------------------------------------------------------------------
void InitMaterials()
{
    int i;
    float* pf;
    D3DMATERIAL8* pMat;

    pf = &teaMaterialData[0];
    for( i = 0; i < NUM_TEA_MATERIALS; i++ ) 
    {        
        pMat = &g_Materials[i];
        pMat->Ambient.r = *pf++;
        pMat->Ambient.g = *pf++;
        pMat->Ambient.b = *pf++;
        pMat->Ambient.a = 1.0f;

        pMat->Diffuse.r = *pf++;
        pMat->Diffuse.g = *pf++;
        pMat->Diffuse.b = *pf++;
        pMat->Diffuse.a = 1.0f;

        pMat->Specular.r = *pf++;
        pMat->Specular.g = *pf++;
        pMat->Specular.b = *pf++;
        pMat->Specular.a = 1.0f;

        pMat->Power = 128* (*pf++);
    }
   
    pf = &texMaterialData[0];
    for( i = 0; i < NUM_TEX_MATERIALS; i++ ) 
    {        
        pMat = &g_Materials[i+NUM_TEA_MATERIALS];
        pMat->Ambient.r = *pf++;
        pMat->Ambient.g = *pf++;
        pMat->Ambient.b = *pf++;
        pMat->Ambient.a = 1.0f;

        pMat->Diffuse.r = *pf++;
        pMat->Diffuse.g = *pf++;
        pMat->Diffuse.b = *pf++;
        pMat->Diffuse.a = 1.0f;

        pMat->Specular.r = *pf++;
        pMat->Specular.g = *pf++;
        pMat->Specular.b = *pf++;
        pMat->Specular.a = 1.0f;

        pMat->Power = *pf++;
    }
}




//-----------------------------------------------------------------------------
// Name: RandomTeaMaterial
// Desc: Select a random TeaMaterial
//-----------------------------------------------------------------------------
D3DMATERIAL8* RandomTeaMaterial()
{
    int index = goodMaterials[ CPipesScreensaver::iRand(NUM_GOOD_MATERIALS) ];   
    return &g_Materials[ index ];
}




//-----------------------------------------------------------------------------
// Name: RandomTexMaterial
// Desc: Select a random TexMaterial
//-----------------------------------------------------------------------------
D3DMATERIAL8* RandomTexMaterial()
{
    int index = NUM_TEA_MATERIALS + CPipesScreensaver::iRand(NUM_TEX_MATERIALS);   
    return &g_Materials[ index ];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\state.cpp ===
//-----------------------------------------------------------------------------
// File: state.cpp
//
// Desc: STATE
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: STATE constructor
// Desc: global state init
//       translates variables set from the dialog boxes
//-----------------------------------------------------------------------------
STATE::STATE( CONFIG* pConfig )
{
    ZeroMemory( &m_textureInfo, sizeof(TEXTUREINFO)*MAX_TEXTURES );

    m_pConfig           = pConfig; 
    m_resetStatus       = 0;
    m_pClearVB          = NULL;
    m_pNState           = NULL;
    m_pd3dDevice        = NULL;
    m_pWorldMatrixStack = NULL;
    m_pLeadPipe         = NULL;
    m_nodes             = NULL;
    m_pFState           = NULL;
    m_maxDrawThreads    = 0;
    m_nTextures         = 0;
    m_bUseTexture       = FALSE;
    m_nSlices           = 0;
    m_radius            = 0;
    m_drawMode          = 0;
    m_maxPipesPerFrame  = 0;
    m_nPipesDrawn       = 0;
    m_nDrawThreads      = 0;
    m_fLastTime         = 0.0f;
    m_drawScheme        = FRAME_SCHEME_RANDOM;     // default draw scheme
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STATE::InitDeviceObjects( IDirect3DDevice8* pd3dDevice )
{
    m_pd3dDevice = pd3dDevice;

    if( m_view.SetWinSize( g_pMyPipesScreensaver->GetSurfaceDesc()->Width, 
                           g_pMyPipesScreensaver->GetSurfaceDesc()->Height ) )
        m_resetStatus |= RESET_RESIZE_BIT;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STATE::RestoreDeviceObjects()
{
    int anDefaultResource[1];
    anDefaultResource[0] = IDB_DEFTEX;

    m_bUseTexture = FALSE;
    if( m_pConfig->bTextured )
    {
        if( SUCCEEDED( LoadTextureFiles( 1, m_pConfig->strTextureName, anDefaultResource ) ) )
            m_bUseTexture = TRUE;
    }

    DRAW_THREAD* pThread = m_drawThreads;
    for( int i=0; i<m_maxDrawThreads; i++ ) 
    {
        pThread->InitDeviceObjects( m_pd3dDevice );
        pThread->RestoreDeviceObjects();
        pThread++;
    }

    D3DXCreateMatrixStack( 0, &m_pWorldMatrixStack );

    m_view.SetProjMatrix( m_pd3dDevice );

    D3DCAPS8 d3d8caps;
    ZeroMemory( &d3d8caps, sizeof(D3DCAPS8) );

    m_pd3dDevice->GetDeviceCaps( &d3d8caps );

    if( d3d8caps.TextureOpCaps & D3DTEXOPCAPS_MODULATE )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    } 
    else if( d3d8caps.TextureOpCaps & D3DTEXOPCAPS_SELECTARG1 )
    {
        if( m_bUseTexture )
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        else
            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_DIFFUSE );

        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    }

    if( d3d8caps.TextureFilterCaps & D3DPTFILTERCAPS_MINFLINEAR )
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    else if( d3d8caps.TextureFilterCaps & D3DPTFILTERCAPS_MINFPOINT )
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );

    if( d3d8caps.TextureFilterCaps & D3DPTFILTERCAPS_MAGFLINEAR )
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    else if( d3d8caps.TextureFilterCaps & D3DPTFILTERCAPS_MAGFPOINT )
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );

    if( d3d8caps.TextureAddressCaps & D3DPTADDRESSCAPS_WRAP )
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP );
        m_pd3dDevice->SetRenderState( D3DRS_WRAP0,             D3DWRAP_U | D3DWRAP_V );
    }
    else if( d3d8caps.TextureAddressCaps & D3DPTADDRESSCAPS_CLAMP ) 
    {
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP );
    }

    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,          D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,         D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,          0x00 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,         D3DCMP_GREATER );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE,      TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE,    TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,           TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_NORMALIZENORMALS,  TRUE );

    if( d3d8caps.PrimitiveMiscCaps & D3DPMISCCAPS_CULLCW ) 
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,          D3DCULL_CW );
    else
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,          D3DCULL_NONE );

    // Set up the lighting states
    ZeroMemory( &m_light, sizeof(D3DLIGHT8) );
    m_light.Type        = D3DLIGHT_DIRECTIONAL;
    m_light.Diffuse.r   = 1.0f;
    m_light.Diffuse.g   = 1.0f;
    m_light.Diffuse.b   = 1.0f;
    m_light.Diffuse.a   = 1.0f;
    if( m_bUseTexture )        
    {
        m_light.Specular.r   = 0.0f;
        m_light.Specular.g   = 0.0f;
        m_light.Specular.b   = 0.0f;
    }
    else
    {
        m_light.Specular.r   = 0.6f;
        m_light.Specular.g   = 0.6f;
        m_light.Specular.b   = 0.6f;
    }
    m_light.Specular.a   = 1.0f;
    m_light.Position.x   = 0.0f;
    m_light.Position.y   = -50.0f;
    m_light.Position.z   = -150.0f;
    m_light.Ambient.r = 0.1f;
    m_light.Ambient.g = 0.1f;
    m_light.Ambient.b = 0.1f;
    m_light.Ambient.a = 1.1f;
    D3DXVec3Normalize( (D3DXVECTOR3*)&m_light.Direction, &D3DXVECTOR3(m_light.Position.x, m_light.Position.y, m_light.Position.z) );
    m_light.Range        = 1000.0f;
    m_pd3dDevice->SetLight( 0, &m_light );
    m_pd3dDevice->LightEnable( 0, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
    if( m_bUseTexture )        
        m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0xFF2F2F2F );
    else
        m_pd3dDevice->SetRenderState( D3DRS_AMBIENT, 0xFFFFFFFF );

    InitMaterials();

    // set 'reference' radius value
    m_radius = 1.0f;

    // convert tesselation from dwTesselFact(0.0-2.0) to tessLevel(0-MAX_TESS)
    int tessLevel = (int) (m_pConfig->dwTesselFact * (MAX_TESS+1) / 2.0001f);
    m_nSlices = (tessLevel+2) * 4;

    // Allocate basic NODE_ARRAY
    // NODE_ARRAY size is determined in Reshape (based on window size)
    m_nodes = new NODE_ARRAY;

    // Set drawing mode, and initialize accordingly.  For now, either all normal
    // or all flex pipes are drawn, but they could be combined later.
    // Can assume here that if there's any possibility that normal pipes
    // will be drawn, NORMAL_STATE will be initialized so that dlists are
    // built
    
    // Again, since have either NORMAL or FLEX, set maxPipesPerFrame,
    // maxDrawThreads
    if( m_pConfig->bMultiPipes )
        m_maxDrawThreads = MAX_DRAW_THREADS;
    else
        m_maxDrawThreads = 1;
    m_nDrawThreads = 0; // no active threads yet
    m_nPipesDrawn = 0;
    // maxPipesPerFrame is set in Reset()

    // Create a square for rendering the clear transition
    SAFE_RELEASE( m_pClearVB );
    m_pd3dDevice->CreateVertexBuffer( 4*sizeof(D3DTLVERTEX),
                                      D3DUSAGE_WRITEONLY, D3DFVF_TLVERTEX,
                                      D3DPOOL_MANAGED, &m_pClearVB );
    // Size the background image
    D3DTLVERTEX* vBackground;
    m_pClearVB->Lock( 0, 0, (BYTE**)&vBackground, 0 );
    for( i=0; i<4; i ++ )
    {
        vBackground[i].p = D3DXVECTOR4( 0.0f, 0.0f, 0.95f, 1.0f );
        vBackground[i].color = 0x20000000;
    }
    vBackground[0].p.y = (FLOAT)m_view.m_winSize.height;
    vBackground[1].p.y = (FLOAT)m_view.m_winSize.height;
    vBackground[1].p.x = (FLOAT)m_view.m_winSize.width;
    vBackground[3].p.x = (FLOAT)m_view.m_winSize.width;
    m_pClearVB->Unlock();

    if( m_pConfig->bFlexMode ) 
    {
        m_drawMode = DRAW_FLEX;
        m_pFState = new FLEX_STATE( this );
        m_pNState = NULL;
    } 
    else 
    {
        m_drawMode = DRAW_NORMAL;
        m_pNState = new NORMAL_STATE( this );
        m_pFState = NULL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STATE::FrameMove( FLOAT fElapsedTime )
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render
// Desc: - Top-level pipe drawing routine
//       - Each pipe thread keeps drawing new pipes until we reach maximum number
//       of pipes per frame - then each thread gets killed as soon as it gets
//       stuck.  Once number of drawing threads reaches 0, we start a new
//       frame
//-----------------------------------------------------------------------------
HRESULT STATE::Render()
{
    int i;
    int nKilledThreads = 0;
    BOOL bChooseNewLead = FALSE;
    DRAW_THREAD* pThread;

    // Reset the frame if its time
    if( m_resetStatus != 0 )
    {
        if( FALSE == FrameReset() )
            return S_OK;
    }

    // Check each pipe's status
    pThread = m_drawThreads;
    for( i=0; i<m_nDrawThreads; i++ ) 
    {
        if( pThread->m_pPipe->IsStuck() ) 
        {
            m_nPipesDrawn++;
            if( m_nPipesDrawn > m_maxPipesPerFrame ) 
            {
                // Reaching pipe saturation - kill this pipe thread
                if( (m_drawScheme == FRAME_SCHEME_CHASE) &&
                    (pThread->m_pPipe == m_pLeadPipe) ) 
                    bChooseNewLead = TRUE;

                pThread->KillPipe();
                nKilledThreads++;
            } 
            else 
            {
                // Start up another pipe
                if( ! pThread->StartPipe() )
                {
                    // we won't be able to draw any more pipes this frame
                    // (probably out of nodes)
                    m_maxPipesPerFrame = m_nPipesDrawn;
                }
            }
        }

        pThread++;
    }

    // Whenever one or more pipes are killed, compact the thread list
    if( nKilledThreads ) 
    {
        CompactThreadList();
        m_nDrawThreads -= nKilledThreads;
    }

    if( m_nDrawThreads == 0 ) 
    {
        // This frame is finished - mark for reset on next Draw
        m_resetStatus |= RESET_NORMAL_BIT;
        return S_OK;
    }

    if( bChooseNewLead ) 
    {
        // We're in 'chase mode' and need to pick a new lead pipe
        ChooseNewLeadPipe();
    }

    // Draw each pipe
    pThread = m_drawThreads;
    for( i=0; i<m_nDrawThreads; i++ ) 
    {
        pThread->Render();
        pThread++;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STATE::InvalidateDeviceObjects()
{
    int i;

    // Cleanup threads
    DRAW_THREAD* pThread = m_drawThreads;
    for( i=0; i<m_maxDrawThreads; i++ ) 
    {
        pThread->InvalidateDeviceObjects();
        pThread->DeleteDeviceObjects();
        pThread++;
    }

    SAFE_RELEASE( m_pClearVB );

    // Cleanup textures
    for( i=0; i<m_nTextures; i++ ) 
    {
        SAFE_RELEASE( m_textureInfo[i].pTexture );
    }

    SAFE_RELEASE( m_pWorldMatrixStack );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT STATE::DeleteDeviceObjects()
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: STATE destructor
// Desc: 
//-----------------------------------------------------------------------------
STATE::~STATE()
{
    SAFE_DELETE( m_pNState );
    SAFE_DELETE( m_pFState );
    SAFE_DELETE( m_nodes );

    // Delete any RC's - should be done by ~THREAD, but since common lib
    // deletes shareRC, have to do it here

    DRAW_THREAD* pThread = m_drawThreads;
    for( int i=0; i<m_maxDrawThreads; i++ ) 
    {
        pThread->KillPipe();
        pThread++;
    }
}




//-----------------------------------------------------------------------------
// Name: CalcTexRepFactors 
// Desc: 
//-----------------------------------------------------------------------------
void STATE::CalcTexRepFactors()
{
    ISIZE winSize;
    D3DXVECTOR2 texFact;

    winSize = m_view.m_winSize;

    // Figure out repetition factor of texture, based on bitmap size and
    // screen size.
    //
    // We arbitrarily decide to repeat textures that are smaller than
    // 1/8th of screen width or height.
    for( int i = 0; i < m_nTextures; i++ ) 
    {
        m_texRep[i].x = m_texRep[i].y = 1;

        if( (texFact.x = winSize.width / m_textureInfo[i].width / 8.0f) >= 1.0f)
            m_texRep[i].x = (int) (texFact.x+0.5f);

        if( (texFact.y = winSize.height / m_textureInfo[i].height / 8.0f) >= 1.0f)
            m_texRep[i].y = (int) (texFact.y+0.5f);
    }
    
    // ! If display list based normal pipes, texture repetition is embedded
    // in the dlists and can't be changed. So use the smallest rep factors.
    // mf: Should change this so smaller textures are replicated close to
    // the largest texture, then same rep factor will work well for all
    
    if( m_pNState ) 
    {
        //put smallest rep factors in texRep[0]; (mf:this is ok for now, as
        // flex pipes and normal pipes don't coexist)
    
        for( i = 1; i < m_nTextures; i++ ) 
        {
            if( m_texRep[i].x < m_texRep[0].x )
                m_texRep[0].x = m_texRep[i].x;
            if( m_texRep[i].y < m_texRep[0].y )
                m_texRep[0].y = m_texRep[i].y;
        }
    } 
}




//-----------------------------------------------------------------------------
// Name: LoadTextureFiles
// Desc: - Load user texture files.  If texturing on but no user textures, or
//       problems loading them, load default texture resource
//       mf: later, may want to have > 1 texture resource
//-----------------------------------------------------------------------------
HRESULT STATE::LoadTextureFiles( int nTextures, TCHAR strTextureFileNames[MAX_PATH][MAX_TEXTURES], int* anDefaultTextureResource )
{
    HRESULT hr;
    m_nTextures = 0;

    for( int i=0; i<nTextures; i++ )
    {
        SAFE_RELEASE( m_textureInfo[i].pTexture );

        if( !m_pConfig->bDefaultTexture )
        {
            WIN32_FIND_DATA findFileData;
            HANDLE hFind = FindFirstFile( strTextureFileNames[i], &findFileData);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                // Load texture in strTextureFileNames[i] using D3DX
                hr = D3DXCreateTextureFromFileEx( m_pd3dDevice, strTextureFileNames[i], 
                            D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, 
                            D3DPOOL_MANAGED, D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 
                            D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 0, NULL, NULL, &m_textureInfo[i].pTexture );
                if( FAILED( hr ) )
                {
                    SAFE_RELEASE( m_textureInfo[i].pTexture );
                }
            }
        }

        if( m_textureInfo[i].pTexture == NULL )
        {
            // Load default texture in resource anDefaultTextureResource[i]
            hr = D3DXCreateTextureFromResourceEx( m_pd3dDevice, NULL, MAKEINTRESOURCE( anDefaultTextureResource[i] ), 
                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, 
                        D3DPOOL_MANAGED, D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 
                        D3DX_FILTER_TRIANGLE|D3DX_FILTER_MIRROR, 0, NULL, NULL, &m_textureInfo[i].pTexture );
            if( FAILED( hr ) )
            {
                SAFE_RELEASE( m_textureInfo[i].pTexture );
            }
        }

        if( m_textureInfo[i].pTexture == NULL )
        {
            // Couldn't load texture
            return E_FAIL;
        }
        else
        {
            D3DSURFACE_DESC d3dDesc;
            ZeroMemory( &d3dDesc, sizeof(D3DSURFACE_DESC) );
            m_textureInfo[i].pTexture->GetLevelDesc( 0, &d3dDesc );
            m_textureInfo[i].width  = d3dDesc.Width;
            m_textureInfo[i].height = d3dDesc.Height;
        }
    }

    m_nTextures = nTextures;
    CalcTexRepFactors();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Repaint
// Desc: This is called when a WM_PAINT msg has been sent to the window.   The paint
//       will overwrite the frame buffer, screwing up the scene if pipes is in single
//       buffer mode.  We set resetStatus accordingly to clear things up on next
//       draw. 
//-----------------------------------------------------------------------------
void STATE::Repaint()
{
    m_resetStatus |= RESET_REPAINT_BIT;
}




//-----------------------------------------------------------------------------
// Name: Reshape
// Desc: - called on resize, expose
//       - always called on app startup
//       - set new window size for VIEW object, and set resetStatus for validation
//         at draw time
//-----------------------------------------------------------------------------
void STATE::Reshape( int width, int height )
{
}




//-----------------------------------------------------------------------------
// Name: ResetView
// Desc: Called on FrameReset resulting from change in viewing paramters (e.g. from
//       a Resize event).
//-----------------------------------------------------------------------------
void STATE::ResetView()
{
    IPOINT3D numNodes;

    // Have VIEW calculate the node array size based on view params
    m_view.CalcNodeArraySize( &numNodes );

    // Resize the node array
    m_nodes->Resize( &numNodes );
}




//-----------------------------------------------------------------------------
// Name: FrameReset
// Desc: Start a new frame of pipes
//       The resetStatus parameter indicates what triggered the Reset.
//-----------------------------------------------------------------------------
BOOL STATE::FrameReset()
{    
    int i;
    float xRot = 0.0f;
    float zRot = 0.0f;

    // Kill off any active pipes ! (so they can shut down ok)
    DRAW_THREAD* pThread = m_drawThreads;
    for( i=0; i<m_nDrawThreads; i++ ) 
    {
        pThread->KillPipe();
        pThread++;
    }
    m_nDrawThreads = 0;
    
    // Clear the screen
    if( FALSE == Clear() )
        return FALSE;

    // Check for window resize status
    if( m_resetStatus & RESET_RESIZE_BIT ) 
    {
        ResetView();
    }

    // Reset the node states to empty
    m_nodes->Reset();

    // Call any pipe-specific state resets, and get any recommended
    // pipesPerFrame counts
    if( m_pNState ) 
    {
        m_pNState->Reset();
    }

    if( m_pFState ) 
    {
        m_pFState->Reset();

        //mf: maybe should figure out min spherical view dist
        xRot = CPipesScreensaver::fRand(-5.0f, 5.0f);
        zRot = CPipesScreensaver::fRand(-5.0f, 5.0f);
    }
    m_maxPipesPerFrame = CalcMaxPipesPerFrame();

    // Set new number of drawing threads
    if( m_maxDrawThreads > 1 ) 
    {
        // Set maximum # of pipes per frame
        m_maxPipesPerFrame = (int) (m_maxPipesPerFrame * 1.5);

        // Set # of draw threads
        m_nDrawThreads = SS_MIN( m_maxPipesPerFrame, CPipesScreensaver::iRand2( 2, m_maxDrawThreads ) );
        // Set chase mode if applicable, every now and then
        BOOL bUseChase = m_pNState || (m_pFState && m_pFState->OKToUseChase());
        if( bUseChase && (!CPipesScreensaver::iRand(5)) ) 
        {
            m_drawScheme = FRAME_SCHEME_CHASE;
        }
    } 
    else 
    {
        m_nDrawThreads = 1;
    }
    m_nPipesDrawn = 0;

    // for now, either all NORMAL or all FLEX for each frame
    pThread = m_drawThreads;
    for( i=0; i<m_nDrawThreads; i++ ) 
    {
        PIPE* pNewPipe;
        
        // Rotate Scene
        D3DXVECTOR3 xAxis = D3DXVECTOR3(1.0f,0.0f,0.0f);
        D3DXVECTOR3 yAxis = D3DXVECTOR3(0.0f,1.0f,0.0f);
        D3DXVECTOR3 zAxis = D3DXVECTOR3(0.0f,0.0f,1.0f);

        // Set up the modeling view
        m_pWorldMatrixStack->LoadIdentity();
        m_pWorldMatrixStack->RotateAxis( &yAxis, m_view.m_yRot );

        // create approppriate pipe for this thread slot
        switch( m_drawMode ) 
        {
            case DRAW_NORMAL:
                pNewPipe = (PIPE*) new NORMAL_PIPE(this);
                break;

            case DRAW_FLEX:
                // There are several kinds of FLEX pipes 
                // so have FLEX_STATE decide which one to create
                pNewPipe = m_pFState->NewPipe( this );
                break;
        }

        pThread->SetPipe( pNewPipe );

        if( m_drawScheme == FRAME_SCHEME_CHASE ) 
        {
            if( i == 0 ) 
            {
                // this will be the lead pipe
                m_pLeadPipe = pNewPipe;
                pNewPipe->SetChooseDirectionMethod( CHOOSE_DIR_RANDOM_WEIGHTED );
            } 
            else 
            {
                pNewPipe->SetChooseDirectionMethod( CHOOSE_DIR_CHASE );
            }
        }

        // If texturing, pick a random texture for this thread
        if( m_bUseTexture ) 
        {
            int index = PickRandomTexture( i, m_nTextures );
            pThread->SetTexture( &m_textureInfo[index] );

            // Flex pipes need to be informed of the texture, so they 
            // can dynamically calculate various texture params
            if( m_pFState )
                ((FLEX_PIPE *) pNewPipe)->SetTexParams( &m_textureInfo[index], 
                                                        &m_texRep[index] );
        }

        // Launch the pipe (assumed: always more nodes than pipes starting, so
        // StartPipe cannot fail)

        // ! All pipe setup needs to be done before we call StartPipe, as this
        // is where the pipe starts drawing
        pThread->StartPipe();

        // Kind of klugey, but if in chase mode, I set chooseStartPos here,
        // since first startPos used in StartPipe() should be random
        if( (i == 0) && (m_drawScheme == FRAME_SCHEME_CHASE) )
            pNewPipe->SetChooseStartPosMethod( CHOOSE_STARTPOS_FURTHEST );

        pThread++;
        m_nPipesDrawn++;
    }

    // Increment scene rotation for normal reset case
    if( m_resetStatus & RESET_NORMAL_BIT )
        m_view.IncrementSceneRotation();

    // clear reset status
    m_resetStatus = 0;

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: CalcMaxPipesPerFrame
// Desc: 
//-----------------------------------------------------------------------------
int STATE::CalcMaxPipesPerFrame()
{
    int nCount=0, fCount=0;

    if( m_pFState )
        fCount = m_pFState->GetMaxPipesPerFrame();

    if( m_pNState )
        nCount = m_bUseTexture ? NORMAL_TEX_PIPE_COUNT : NORMAL_PIPE_COUNT;

    return SS_MAX( nCount, fCount );
}




//-----------------------------------------------------------------------------
// Name: PickRandomTexture
// Desc: Pick a random texture index from a list.  Remove entry from list as it
//       is picked.  Once all have been picked, or starting a new frame, reset.
//-----------------------------------------------------------------------------
int STATE::PickRandomTexture( int iThread, int nTextures )
{
    if( nTextures == 0 )
        return 0;

    static int pickSet[MAX_TEXTURES] = {0};
    static int nPicked = 0;
    int i, index;

    if( iThread == 0 )
    {
        // new frame - force reset
        nPicked = nTextures;
    }

    // reset condition
    if( ++nPicked > nTextures ) 
    {
        for( i = 0; i < nTextures; i ++ ) pickSet[i] = 0;
        nPicked = 1; // cuz
    }

    // Pick a random texture index
    index = CPipesScreensaver::iRand( nTextures );
    while( pickSet[index] ) 
    {
        // this index has alread been taken, try the next one
        if( ++index >= nTextures )
            index = 0;
    }

    // Hopefully, the above loop will exit :).  This means that we have
    // found a texIndex that is available
    pickSet[index] = 1; // mark as taken
    return index;
}




//-----------------------------------------------------------------------------
// Name: Clear
// Desc: Clear the screen.  Depending on resetStatus, use normal clear or
//       fancy transitional clear.
//-----------------------------------------------------------------------------
BOOL STATE::Clear()
{
    if( m_resetStatus & RESET_NORMAL_BIT )
    {
        // do the normal transitional clear
        static DWORD s_dwCount = 0;
        static FLOAT s_fLastStepTime = DXUtil_Timer( TIMER_GETAPPTIME );

        if( s_dwCount == 0 )
            s_dwCount = 30;

        float fCurTime = DXUtil_Timer( TIMER_GETAPPTIME );
        if( fCurTime - s_fLastStepTime > 0.016 )
        {
            s_fLastStepTime = fCurTime;

            s_dwCount--;
            if( s_dwCount == 0 )
            {
                m_pd3dDevice->SetTexture( 0, NULL );
                m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
                m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 
                                     0x00000000, 1.0f, 0L );

                return TRUE;
            }
            else
            {
                m_pd3dDevice->SetTexture( 0, NULL );
                m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );
                m_pd3dDevice->SetVertexShader( D3DFVF_TLVERTEX );
                m_pd3dDevice->SetStreamSource( 0, m_pClearVB, sizeof(D3DTLVERTEX) );
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }
    else 
    {
        // do a fast one-shot clear
        m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 
                             0x00000000, 1.0f, 0L );
        return TRUE;
    }
}




//-----------------------------------------------------------------------------
// Name: DrawValidate
// Desc: Validation done before every Draw
//       For now, this just involves checking resetStatus
//-----------------------------------------------------------------------------
void STATE::DrawValidate()
{    
}




//-----------------------------------------------------------------------------
// Name: CompactThreadList
// Desc: - Compact the thread list according to number of pipe threads killed
//       - The pipes have been killed, but the RC's in each slot are still valid
//       and reusable.  So we swap up entries with valid pipes. This means that
//       the ordering of the RC's in the thread list will change during the life
//       of the program.  This should be OK.
//-----------------------------------------------------------------------------
#define SWAP_SLOT( a, b ) \
    DRAW_THREAD pTemp; \
    pTemp = *(a); \
    *(a) = *(b); \
    *(b) = pTemp;
    
void STATE::CompactThreadList()
{
    if( m_nDrawThreads <= 1 )
        // If only one active thread, it must be in slot 0 from previous
        // compactions - so nothing to do
        return;

    int iEmpty = 0;
    DRAW_THREAD* pThread = m_drawThreads;
    for( int i=0; i<m_nDrawThreads; i++ ) 
    {
        if( pThread->m_pPipe ) 
        {
            if( iEmpty < i ) 
            {
                // swap active pipe thread and empty slot
                SWAP_SLOT( &(m_drawThreads[iEmpty]), pThread );
            }

            iEmpty++;
        }
        pThread++;
    }
}




//-----------------------------------------------------------------------------
// Name: ChooseNewLeadPipe
// Desc: Choose a new lead pipe for chase mode.
//-----------------------------------------------------------------------------
void STATE::ChooseNewLeadPipe()
{
    // Pick one of the active pipes at random to become the new lead

    int iLead = CPipesScreensaver::iRand( m_nDrawThreads );
    m_pLeadPipe = m_drawThreads[iLead].m_pPipe;
    m_pLeadPipe->SetChooseStartPosMethod( CHOOSE_STARTPOS_FURTHEST );
    m_pLeadPipe->SetChooseDirectionMethod( CHOOSE_DIR_RANDOM_WEIGHTED );
}




//-----------------------------------------------------------------------------
// Name: DRAW_THREAD constructor
// Desc: 
//-----------------------------------------------------------------------------
DRAW_THREAD::DRAW_THREAD()
{
    m_pd3dDevice    = NULL;
    m_pPipe         = NULL;
    m_pTextureInfo  = NULL;
}




//-----------------------------------------------------------------------------
// Name: DRAW_THREAD destructor
// Desc: 
//-----------------------------------------------------------------------------
DRAW_THREAD::~DRAW_THREAD()
{
}




//-----------------------------------------------------------------------------
// Name: SetPipe
// Desc: 
//-----------------------------------------------------------------------------
void DRAW_THREAD::SetPipe( PIPE* pPipe )
{
    m_pPipe = pPipe;
}




//-----------------------------------------------------------------------------
// Name: SetTexture
// Desc: 
//-----------------------------------------------------------------------------
void DRAW_THREAD::SetTexture( TEXTUREINFO* pTextureInfo )
{
    m_pTextureInfo = pTextureInfo;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::InitDeviceObjects( IDirect3DDevice8* pd3dDevice )
{
    m_pd3dDevice = pd3dDevice;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::RestoreDeviceObjects()
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::FrameMove( FLOAT fElapsedTime )
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: - Draw pipe in thread slot, according to its type
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::Render()
{
    m_pPipe->Draw();
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::InvalidateDeviceObjects()
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
HRESULT DRAW_THREAD::DeleteDeviceObjects()
{
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: StartPipe
// Desc: Starts up pipe of the approppriate type.  If can't find an empty node
//       for the pipe to start on, returns FALSE;
//-----------------------------------------------------------------------------
BOOL DRAW_THREAD::StartPipe()
{
    // call pipe-type specific Start function
    m_pPipe->Start();

    // check status
    if( m_pPipe->NowhereToRun() )
        return FALSE;
    else
        return TRUE;
}




//-----------------------------------------------------------------------------
// Name: KillPipe
// Desc: 
//-----------------------------------------------------------------------------
void DRAW_THREAD::KillPipe()
{
    SAFE_DELETE( m_pPipe );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\state.h ===
//-----------------------------------------------------------------------------
// File: state.h
//
// Desc: STATE
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __state_h__
#define __state_h__

#define MAX_DRAW_THREADS    4
#define MAX_TESS            3

// type(s) of pipes that are drawn
enum 
{
    DRAW_NORMAL,
    DRAW_FLEX,
    DRAW_BOTH  // not currently used
};

// Reset status
#define  RESET_STARTUP_BIT  (1L << 0)
#define  RESET_NORMAL_BIT   (1L << 1)
#define  RESET_RESIZE_BIT   (1L << 2)
#define  RESET_REPAINT_BIT  (1L << 3)

// Frame draw schemes
enum 
{
    FRAME_SCHEME_RANDOM,  // pipes draw randomly
    FRAME_SCHEME_CHASE,   // pipes chase a lead pipe
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class DRAW_THREAD 
{
private:

public:
    TEXTUREINFO*        m_pTextureInfo;
    IDirect3DDevice8*   m_pd3dDevice;
    PIPE*               m_pPipe;       // generic pipe ptr
    int                 m_priority;

    DRAW_THREAD();
    ~DRAW_THREAD();

    HRESULT InitDeviceObjects( IDirect3DDevice8* pd3dDevice );
    HRESULT RestoreDeviceObjects();
    HRESULT InvalidateDeviceObjects();
    HRESULT DeleteDeviceObjects();
    HRESULT Render();
    HRESULT FrameMove( FLOAT fElapsedTime );

    void        SetTexture( TEXTUREINFO* pTextureInfo );
    void        SetPipe( PIPE* pPipe );
    BOOL        StartPipe();
    void        KillPipe();
};


// Program existence instance
class NORMAL_STATE;
class FLEX_STATE;


struct CONFIG;

//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class STATE 
{
public:
    CONFIG*         m_pConfig;
    BOOL            m_bUseTexture;              // global texture enable
    TEXTUREINFO     m_textureInfo[MAX_TEXTURES];
    int             m_nTextures;
    IDirect3DDevice8* m_pd3dDevice;
    ID3DXMatrixStack* m_pWorldMatrixStack;
    D3DLIGHT8       m_light;
    FLOAT           m_fLastTime;

    PIPE*           m_pLeadPipe;     // lead pipe for chase scenarios
    int             m_nSlices;      // reference # of slices around a pipe
    IPOINT2D        m_texRep[MAX_TEXTURES];
    VIEW            m_view;           // viewing parameters
    float           m_radius;         // 'reference' pipe radius value
    NODE_ARRAY*     m_nodes;         // for keeping track of draw space
    NORMAL_STATE*   m_pNState;
    FLEX_STATE*     m_pFState;
    LPDIRECT3DVERTEXBUFFER8 m_pClearVB;

    STATE( CONFIG* pConfig );
    ~STATE();
    void        Reshape( int width, int height );
    void        Repaint();

    HRESULT InitDeviceObjects( IDirect3DDevice8* pd3dDevice );
    HRESULT RestoreDeviceObjects();
    HRESULT InvalidateDeviceObjects();
    HRESULT DeleteDeviceObjects();
    HRESULT Render();
    HRESULT FrameMove( FLOAT fElapsedTime );

private:
    int         m_drawMode;       // drawing mode (flex or normal for now)
    int         m_drawScheme;     // random or chase
    int         m_maxPipesPerFrame; // max number of separate pipes/frame
    int         m_nPipesDrawn;    // number of pipes drawn or drawing in frame
    int         m_maxDrawThreads; // max number of concurrently drawing pipes
    int         m_nDrawThreads;   // number of live threads
    DRAW_THREAD m_drawThreads[MAX_DRAW_THREADS];
    int         m_resetStatus;

    HRESULT     LoadTextureFiles( int nTextures, TCHAR strTextureFileNames[MAX_PATH][MAX_TEXTURES], int* anDefaultTextureResource );
    int         PickRandomTexture( int iThread, int nTextures );

    BOOL        Clear();
    void        ChooseNewLeadPipe();
    void        CompactThreadList();
    void        GLInit();
    void        DrawValidate();  // validation to do before each Draw
    void        ResetView();
    BOOL        FrameReset();
    void        CalcTexRepFactors();
    int         CalcMaxPipesPerFrame();
};

#endif // __state_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\stdafx.h ===
//-----------------------------------------------------------------------------
// File: stdafx.h
//
// Desc: Global header for 3D Pipes screen saver.
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <commdlg.h>
#include <sys/timeb.h>
#include <sys/types.h>
#include <assert.h>
#include <time.h>
#include <math.h>
#include <commctrl.h>
#include <d3dx8.h>
#include <d3d8rgbrast.h>
#include <tchar.h>

#define iXX -1
#define fXX -0.01f

// These are absolute directions, with origin in center of screen,
// looking down -z
enum 
{
    PLUS_X = 0,
    MINUS_X,
    PLUS_Y,
    MINUS_Y,
    PLUS_Z,
    MINUS_Z,
    NUM_DIRS,
    DIR_NONE,
    DIR_STRAIGHT
};

enum 
{
    JOINT_ELBOW=0,
    JOINT_BALL,
    JOINT_MIXED,
    JOINT_CYCLE,
    NUM_JOINTTYPES
};

// surface styles
enum 
{
    SURFSTYLE_SOLID = 0,
    SURFSTYLE_TEX,
    SURFSTYLE_WIREFRAME
};

#define NUM_DIV 16              // divisions in window in longest dimension
#define MAX_TEXTURES 8

// texture quality level
enum 
{
    TEXQUAL_DEFAULT = 0,
    TEXQUAL_HIGH
};

typedef struct _ipoint2d 
{
    int x;
    int y;
} IPOINT2D;

typedef struct _ipoint3d 
{
    int x;
    int y;
    int z;
} IPOINT3D;

typedef struct _texpoint2d 
{
    float s;
    float t;
} TEX_POINT2D;

typedef struct _isize 
{
    int width;
    int height;
} ISIZE;

typedef struct _fsize 
{
    float width;
    float height;
} FSIZE;

typedef struct _glrect 
{
    int x, y;
    int width, height;
} GLRECT;

typedef struct 
{
    int     type;
    int     name;
} TEX_RES;

typedef struct 
{
    int     nOffset;  // filename offset into pathname
    TCHAR   szPathName[MAX_PATH];  // texture pathname
} TEXFILE;

// texture data
typedef struct 
{
    LPDIRECT3DTEXTURE8 pTexture;
    int     width;
    int     height;
//    GLenum  format;
//    GLsizei components;
    float   origAspectRatio; // original width/height aspect ratio
//    unsigned char *data;
//    GLuint  texObj;          // texture object
//    RGBQUAD *pal;
} TEXTUREINFO;

struct D3DVERTEX
{
    D3DXVECTOR3 p;
    D3DXVECTOR3 n;
    FLOAT       tu, tv;
};

#define D3DFVF_VERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

struct D3DTLVERTEX  // Vertex type used for rendering background
{
    D3DXVECTOR4 p;
    DWORD       color;
};

#define D3DFVF_TLVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)



#define PI 3.14159265358979323846f
// double version of PI
#define PI_D 3.14159265358979323846264338327950288419716939937510
#define ONE_OVER_PI (1.0f / PI)
#define ROOT_TWO 1.414213562373f

// degree<->radian macros
#define ONE_OVER_180                (1.0f / 180.0f)
#define SS_DEG_TO_RAD( a )          ( (a*PI) * ONE_OVER_180 )
#define SS_RAD_TO_DEG( a )          ( (a*180.0f) * D3DX_1BYPI )

// Useful macros
#define SS_MAX( a, b )              ( a > b ? a : b )
#define SS_MIN( a, b )              ( a < b ? a : b )

// macro to round up floating values
#define SS_ROUND_UP( fval )         ( (((fval) - (FLOAT)(int)(fval)) > 0.0f) ? (int) ((fval)+1.0f) : (int) (fval) )

// macros to clamp a value within a range
#define SS_CLAMP_TO_RANGE( a, lo, hi )      ( (a < lo) ? lo : ((a > hi) ? hi : a) )
#define SS_CLAMP_TO_RANGE2( a, lo, hi )     ( a = (a < lo) ? lo : ((a > hi) ? hi : a) )

#include "d3dsaver.h"
#include "dxutil.h"
#include "resource.h"

#include "xc.h"
#include "eval.h"
#include "fstate.h"
#include "nstate.h"
#include "node.h"
#include "pipe.h"
#include "npipe.h"
#include "fpipe.h"
#include "objects.h"
#include "view.h"
#include "state.h"
#include "pipes.h"

extern void InitMaterials();
extern D3DMATERIAL8* RandomTexMaterial();
extern D3DMATERIAL8* RandomTeaMaterial();

extern CPipesScreensaver* g_pMyPipesScreensaver;

#endif // __STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\view.h ===
//-----------------------------------------------------------------------------
// File: view.h
//
// Desc: 
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __view_h__
#define __view_h__


typedef struct 
{
    float viewAngle;            // field of view angle for height
    float zNear;                // near z clip value
    float zFar;                 // far z clip value
} Perspective;  // perspective view description




//-----------------------------------------------------------------------------
// Name: 
// Desc: 
//-----------------------------------------------------------------------------
class VIEW 
{
public:
    float       m_zTrans;         // z translation
    float       m_yRot;           // current yRotation
    float       m_viewDist;       // viewing distance, usually -zTrans
    int         m_numDiv;         // # grid divisions in x,y,z
    float       m_divSize;        // distance between divisions
    ISIZE       m_winSize;        // window size in pixels

    VIEW();
    BOOL        SetWinSize( int width, int height );
    void        CalcNodeArraySize( IPOINT3D *pNodeDim );
    void        SetProjMatrix( IDirect3DDevice8* pd3dDevice );
    void        IncrementSceneRotation();
private:
    BOOL        m_bProjMode;      // projection mode
    Perspective m_persp;          // perspective view description
    float       m_aspectRatio;    // x/y window aspect ratio
    D3DXVECTOR3 m_world;          // view area in world space
};

#endif // __view_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\view.cpp ===
//-----------------------------------------------------------------------------
// File: view.cpp
//
// Desc: 
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "stdafx.h"




//-----------------------------------------------------------------------------
// Name: 
// Desc: VIEW constructor
//-----------------------------------------------------------------------------
VIEW::VIEW()
{
    m_bProjMode = TRUE;

    // set some initial viewing and size params
    m_zTrans = -75.0f;
    m_viewDist = -m_zTrans;

    m_numDiv = NUM_DIV;
    assert( m_numDiv >= 2 && "VIEW constructor: not enough divisions\n" );
    // Because number of nodes in a dimension is derived from (numDiv-1), and
    // can't be 0

    m_divSize = 7.0f;

    m_persp.viewAngle = D3DX_PI / 2.0f; //90.0f;
    m_persp.zNear = 1.0f;

    m_yRot = 0.0f;

    m_winSize.width = m_winSize.height = 0; 
}




//-----------------------------------------------------------------------------
// Name: SetProjMatrix
// Desc: Set Projection matrix
//-----------------------------------------------------------------------------
void VIEW::SetProjMatrix( IDirect3DDevice8* pd3dDevice )
{
    // Rotate the camera about the y-axis
    D3DXVECTOR3 vFromPt   = D3DXVECTOR3( 0.0f, 0.0f, -m_zTrans );
    D3DXVECTOR3 vLookatPt = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpVec    = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vFromPt, &vLookatPt, &vUpVec );
    pd3dDevice->SetTransform( D3DTS_VIEW, &matView );

    // Set the projection matrix
    D3DXMATRIX matProj;
    D3DXMatrixPerspectiveFovLH( &matProj, m_persp.viewAngle, m_aspectRatio, m_persp.zNear, m_persp.zFar );
    pd3dDevice->SetTransform( D3DTS_PROJECTION, &matProj );
}




//-----------------------------------------------------------------------------
// Name: CalcNodeArraySize
// Desc: Based on the viewing width and height, and numDiv, calculate the x,y,z array
//       node dimensions.
//-----------------------------------------------------------------------------
void VIEW::CalcNodeArraySize( IPOINT3D *pNodeDim )
{
    // mf: !!! if aspect ratio deviates too much from 1, then nodes will get
    // clipped as view rotates
    if( m_winSize.width >= m_winSize.height ) 
    {
        pNodeDim->x = m_numDiv - 1;
        pNodeDim->y = (int) (pNodeDim->x / m_aspectRatio) ;
        if( pNodeDim->y < 1 )
            pNodeDim->y = 1;
        pNodeDim->z = pNodeDim->x;
    }
    else 
    {
        pNodeDim->y = m_numDiv - 1;
        pNodeDim->x = (int) (m_aspectRatio * pNodeDim->y);
        if( pNodeDim->x < 1 )
            pNodeDim->x = 1;
        pNodeDim->z = pNodeDim->y;
    }
}




//-----------------------------------------------------------------------------
// Name: SetWinSize
// Desc: Set the window size for the view, derive other view params.
//       Return FALSE if new size same as old.
//-----------------------------------------------------------------------------
BOOL VIEW::SetWinSize( int width, int height )
{
    if( (width == m_winSize.width) &&
        (height == m_winSize.height) )
        return FALSE;

    m_winSize.width = width;
    m_winSize.height = height;

    m_aspectRatio = m_winSize.height == 0 ? 1.0f : (float)m_winSize.width/m_winSize.height;

    if( m_winSize.width >= m_winSize.height ) 
    {
        m_world.x = m_numDiv * m_divSize;
        m_world.y = m_world.x / m_aspectRatio;
        m_world.z = m_world.x;
    }
    else 
    {
        m_world.y = m_numDiv * m_divSize;
        m_world.x = m_world.y * m_aspectRatio;
        m_world.z = m_world.y;
    }

    m_persp.zFar = m_viewDist + m_world.z*2;

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: SetSceneRotation 
// Desc: 
//-----------------------------------------------------------------------------
void VIEW::IncrementSceneRotation()
{
    m_yRot += 9.73156f;
    if( m_yRot >= 360.0f )
        // prevent overflow
        m_yRot -= 360.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\stdafx.cpp ===
//-----------------------------------------------------------------------------
// File: stdafx.cpp
//
// Desc: 
//
// Copyright (c) 1995-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#define INITGUID
#include "stdafx.h"

DEFINE_GUID(IID_IUnknown, 
0x000000000, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\stars\strings.h ===
#include "..\common\comstrin.h"

#define idsDescription    1
#define idsName         100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\xc.h ===
//-----------------------------------------------------------------------------
// File: xc.h
//
// Desc: Cross_section (xc) class
//
// Copyright (c) 1994-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#ifndef __XC_H__
#define __XC_H__


// useful for xc-coords
enum 
{
    RIGHT = 0,
    TOP,
    LEFT,
    BOTTOM
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: Cross_section (xc) class
//-----------------------------------------------------------------------------
class XC 
{
public:
    float           m_xLeft, m_xRight;  // bounding box
    float           m_yTop, m_yBottom;
    int             m_numPts;
    D3DXVECTOR2*    m_pts;        // CW points around the xc, from +x

    XC( int numPts );
    XC( const XC& xc );
    XC( XC *xc );
    ~XC();

    void        Scale( float scale );
    float       MaxExtent();
    float       MinTurnRadius( int relDir );
    void        CalcArcACValues90( int dir, float r, float *acPts );
    void        CalcArcACValuesByDistance(  float *acPts );
    void        ConvertPtsZ( D3DXVECTOR3 *pts, float z );

protected:
    void        CalcBoundingBox();
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: Specific xc's derived from base xc class
//-----------------------------------------------------------------------------
class ELLIPTICAL_XC : public XC 
{
public:
    ELLIPTICAL_XC( float r1, float r2 );
    ~ELLIPTICAL_XC();

private:
    void SetControlPoints( float r1, float r2 );
};




//-----------------------------------------------------------------------------
// Name: 
// Desc: Specific xc's derived from base xc class
//-----------------------------------------------------------------------------
class RANDOM4ARC_XC : public XC 
{
public:
    RANDOM4ARC_XC( float r );
    ~RANDOM4ARC_XC();

private:
    void SetControlPoints( float radius );
};


#endif __XC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\stars\ssstars.c ===
/*

STARS.C

Starfield simulator screensaver.

  History:
       6/17/91        stevecat    ported to NT Windows
       2/10/92        stevecat    snapped to latest ported to NT Windows
*/

#include <windows.h>
#include <scrnsave.h>
#include <commctrl.h>
#include "stars.dlg"
#include "strings.h"
#include "uniconv.h"


#define SCOPE       256
#define MAXWARP     10              // Maximum warp speed
#define MINWARP     0               // Minimum warp speed
#define CLICKRANGE (MAXWARP-MINWARP)// Range for WarpSpeed scroll bar
#define MINSTARS    10              // Minimum number of stars in field
#define MAXSTARS    200             // Maximum number of stars in field
#define WARPFACTOR  10              // Warp Factor 10 Mr. Sulu!
#define SIZE        64
#define DEF_DENSITY 25              // Default number of stars in field
#define RAND(x)     ((rand() % (x))+1)
#define ZRAND(x)    (rand() % (x))
#define MINTIMERSPEED 50

VOID CreateStar            (WORD wIndex);
LONG GetDlgItemLong        (HWND hDlg, WORD wID, BOOL *pfTranslated, BOOL fSigned);
VOID GetIniEntries         (VOID);
LONG GetPrivateProfileLong (LPTSTR pszApp, LPTSTR pszKey, LONG lDefault);
WORD rand                  (VOID);
VOID srand                 (DWORD dwSeed);

DWORD dwRand;                           // Current random seed

TCHAR  szWarpSpeed [] = TEXT("WarpSpeed");     // .INI WarpSpeed key

TCHAR  szDensity [] = TEXT("Density");         // .INI Density key

LONG  nX[MAXSTARS],
      nY[MAXSTARS],
      nZ[MAXSTARS];
WORD  wXScreen,
      wYScreen,
      wX2Screen,
      wY2Screen;
WORD  wWarpSpeed,                       // Global WarpSpeed value
      wDensity;                         // Global starfield density value

//
// Help IDs
//
DWORD aStarsDlgHelpIds[] = {
    ((DWORD) -1), ((DWORD) -1),
    ID_SPEED_SLOW,              IDH_DISPLAY_SCREENSAVER_STARFIELD_WARP,
    ID_SPEED_FAST,              IDH_DISPLAY_SCREENSAVER_STARFIELD_WARP,
    ID_SPEED,                   IDH_DISPLAY_SCREENSAVER_STARFIELD_WARP,
    ID_DENSITY_LABEL,           IDH_DISPLAY_SCREENSAVER_STARFIELD_DENSITY,
    ID_DENSITY,                 IDH_DISPLAY_SCREENSAVER_STARFIELD_DENSITY,
    ID_DENSITYARROW,            IDH_DISPLAY_SCREENSAVER_STARFIELD_DENSITY,
    0,0
};

#define DIVIDE_SAFE(nNumber)            ((0 == (nNumber)) ? 1 : (nNumber))

/* This is the main window procedure to be used when the screen saver is
    activated in a screen saver mode ( as opposed to configure mode ).  This
    function must be declared as an EXPORT in the EXPORTS section of the
    DEFinition file... */

LRESULT ScreenSaverProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT         rRect;
    WORD         wLoop;
    static UINT_PTR wTimer;
    static WORD  wWarp;
    static WORD  wTimerSet=MINTIMERSPEED;
    static WORD  wCurrentWarp;
    static int   nPassCount=0;
    int          nXTemp, nYTemp, nTemp;
    BOOL         fHyperSpace = TRUE;
    HDC          hDC;

    switch (message)
    {
    case WM_CREATE:
        /* Do anything that you need to do when you initialize the window
           here... */
        GetIniEntries ();
        srand (GetCurrentTime ());

        /* Make sure we use the entire virtual desktop size for multiple
           displays... */

        wXScreen = (WORD) ((LPCREATESTRUCT)lParam)->cx;
        wYScreen = (WORD) ((LPCREATESTRUCT)lParam)->cy;


        wX2Screen = wXScreen / 2;
        wY2Screen = wYScreen / 2;
        for (wLoop = 0; wLoop < wDensity; wLoop++)
            CreateStar (wLoop);
        wWarp = wWarpSpeed * WARPFACTOR + WARPFACTOR; // ZRAND (((wWarpSpeed)*WARPFACTOR)+1)+1;

        wTimer = SetTimer (hWnd, 1, wTimerSet, NULL);
        break;

    case WM_SIZE:
        wXScreen = LOWORD(lParam);
        wYScreen = HIWORD(lParam);
        break;


    case WM_TIMER:
    {
        MSG msg;

        hDC = GetDC (hWnd);
        /* Begin to loop through each star, accelerating so it seems that
           we are traversing the starfield... */
        for (wLoop = 0; wLoop < wDensity; wLoop++)
        {
            nXTemp = (int)((nX[wLoop] * (LONG)(SCOPE * WARPFACTOR))
                                                / DIVIDE_SAFE(nZ[wLoop])) + wX2Screen;
            nYTemp = (int)((nY[wLoop] * SCOPE * WARPFACTOR) / DIVIDE_SAFE(nZ[wLoop]))
                                                     + wY2Screen;
            nTemp = (int)((SCOPE * WARPFACTOR - nZ[wLoop]) /
                                                    (SIZE * WARPFACTOR)) + 1;
            PatBlt (hDC, nXTemp, nYTemp, nTemp, nTemp, BLACKNESS);

            if (wCurrentWarp < wWarp)
                wCurrentWarp++;
            else if (wCurrentWarp > wWarp)
                wCurrentWarp--;

            nZ[wLoop] = max (0, (int)(nZ[wLoop] - wCurrentWarp));
            if (!nZ[wLoop])
                CreateStar (wLoop);

            nXTemp = (int)((nX[wLoop] * (LONG)(SCOPE * WARPFACTOR))
                                                    / DIVIDE_SAFE(nZ[wLoop])) + wX2Screen;
            nYTemp = (int)((nY[wLoop] * SCOPE * WARPFACTOR)
                                                    / DIVIDE_SAFE(nZ[wLoop])) + wY2Screen;
            if ((nXTemp < 0 || nYTemp < 0) ||
                (nXTemp > (int) wXScreen || nYTemp > (int) wYScreen))
            {
                CreateStar (wLoop);
                nXTemp = (int)((nX[wLoop] * (LONG)(SCOPE * WARPFACTOR))
                                                 / DIVIDE_SAFE(nZ[wLoop])) + wX2Screen;
                nYTemp = (int)((nY[wLoop] * SCOPE * WARPFACTOR)
                                                 / DIVIDE_SAFE(nZ[wLoop])) + wY2Screen;
            }
            nTemp = (int)((SCOPE * WARPFACTOR - nZ[wLoop]) /
                                                (SIZE * WARPFACTOR)) + 1;
            PatBlt (hDC, nXTemp, nYTemp, nTemp, nTemp, WHITENESS);
        }
        ReleaseDC (hWnd, hDC);

        if (PeekMessage(&msg, hWnd, WM_TIMER, WM_TIMER, PM_REMOVE))
        {
            // There is another WM_TIMER message in the queue.  We have
            // removed it, but now we want to adjust the timer a bit so
            // hopefully we won't get another WM_TIMER message before we
            // finish the screen update. (bug #8423)  TG:11/25/91

            wTimerSet += 10;
            SetTimer(hWnd, 1, wTimerSet, NULL);
            nPassCount = 0;
        }
        else
            ++nPassCount;

        if (nPassCount >= 100)
        {
            nPassCount = 0;
            wTimerSet -= 100;
            if ((short)wTimerSet < MINTIMERSPEED)
                wTimerSet = MINTIMERSPEED;
            SetTimer(hWnd, 1, wTimerSet, NULL);
        }
        break;
    }

    case WM_ERASEBKGND:
            /* If you want something put on the background, do it right here
                using wParam as a handle to a device context.  Remember to
                unrealize a brush if it is not a solid color.  If you do
                something here, you want to use the line:
                    return 0l;
                So the program knows not to take the default action. Otherwise
                just use:
                    break;
                */
        break;
        GetClientRect (hWnd, &rRect);
        FillRect ((HDC) wParam, &rRect, GetStockObject (GRAY_BRUSH));
        return 0l;

    case WM_DESTROY:
        /* Anything that needs to be deleted when the window is closed
                goes here... */
        if (wTimer)
            KillTimer (hWnd, wTimer);
        break;
    }
    /* Unless it is told otherwise, the program will take default actions... */
    return (DefScreenSaverProc (hWnd, message, wParam, lParam));
}


//***************************************************************************

BOOL ScreenSaverConfigureDialog (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL    fError;                         // Error flag

    UINT    wTemp;
    TCHAR   szTemp[1025];                   // Temporary string buffer (safe size for wsprintf)

    static WORD wPause, wScroll;
    static HWND hWarpSpeed,                 // window handle of Speed scrollbar
                hIDOK,                      // window handle of OK button
                hSetPassword,               // window handle of SetPassword button
                hDensity;                   // window handle of Density EditControl

    static WORD wIncScroll = 1;             // density spin button parameters

    static WORD wStartScroll = 1;
    static WORD wStartPause = 1;
    static WORD wMaxScroll = 10;
    static WORD wPauseScroll = 20;
    static LONG lMinScroll = MINSTARS;
    static LONG lMaxScroll = MAXSTARS;


    switch (message)
    {
    case WM_INITDIALOG:
        GetIniEntries ();
        hWarpSpeed = GetDlgItem (hDlg, ID_SPEED);
        hIDOK = GetDlgItem (hDlg, IDOK);
        hDensity = GetDlgItem (hDlg, ID_DENSITY);
        SendMessage (hDensity, EM_LIMITTEXT, 3, 0);

        SendDlgItemMessage( hDlg, ID_DENSITYARROW, UDM_SETBUDDY, (WPARAM)hDensity, 0);
        SendDlgItemMessage( hDlg, ID_DENSITYARROW, UDM_SETRANGE, 0, MAKELONG(lMaxScroll, lMinScroll));

        SetScrollRange (hWarpSpeed, SB_CTL, MINWARP, MAXWARP, FALSE);
        SetScrollPos (hWarpSpeed, SB_CTL, wWarpSpeed, TRUE);

        SetDlgItemInt (hDlg, ID_DENSITY, wDensity, FALSE);
        return TRUE;

    case WM_HSCROLL:
        switch (LOWORD(wParam))
        {
        case SB_LINEUP:
        case SB_PAGEUP:
            --wWarpSpeed;
            break;

        case SB_LINEDOWN:
        case SB_PAGEDOWN:
            ++wWarpSpeed;
            break;

        case SB_THUMBPOSITION:
            wWarpSpeed = HIWORD (wParam);
            break;

        case SB_TOP:
            wWarpSpeed = MINWARP;
            break;

        case SB_BOTTOM:
            wWarpSpeed = MAXWARP;
            break;

        case SB_THUMBTRACK:
        case SB_ENDSCROLL:
            return TRUE;
            break;
        }
        if ((int)((short)wWarpSpeed) <= MINWARP)
            wWarpSpeed = MINWARP;
        if ((int)wWarpSpeed >= MAXWARP)
            wWarpSpeed = MAXWARP;

        SetScrollPos ((HWND) lParam, SB_CTL, wWarpSpeed, TRUE);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case ID_DENSITY:
            if (HIWORD(wParam) == EN_UPDATE)
            {
                wTemp = GetDlgItemInt (hDlg, ID_DENSITY, &fError, FALSE);
                fError = ((wTemp <= MAXSTARS) && (wTemp >= MINSTARS));
                EnableWindow (GetDlgItem (hDlg, ID_DENSITYARROW), fError);
                EnableWindow (GetDlgItem (hDlg, IDOK), fError);
            }
            break;

        case IDOK:
            wTemp = GetDlgItemInt (hDlg, ID_DENSITY, &fError, FALSE);
            wsprintf (szTemp, TEXT("%d"), wTemp);
            WritePrivateProfileString (szAppName, szDensity, szTemp, szIniFile);
            wsprintf (szTemp, TEXT("%d"), wWarpSpeed);
            WritePrivateProfileString (szAppName, szWarpSpeed, szTemp, szIniFile);

        case IDCANCEL:
            EndDialog (hDlg, LOWORD(wParam) == IDOK);
            return TRUE;

        }
        break;

    case WM_HELP: // F1
        WinHelp(
            (HWND) ((LPHELPINFO) lParam)->hItemHandle,
            szHelpFile,
            HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aStarsDlgHelpIds
        );
        break;

    case WM_CONTEXTMENU:  // right mouse click
        WinHelp(
            (HWND) wParam,
            szHelpFile,
            HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aStarsDlgHelpIds
        );
        break;

    default:
        break;
    }
    return FALSE;
}


/* This procedure is called right before the dialog box above is created in
   order to register any child windows that are custom controls.  If no
   custom controls need to be registered, then simply return TRUE.
   Otherwise, register the child controls however is convenient... */

BOOL RegisterDialogClasses (HANDLE hInst)
{
    InitCommonControls();

    return TRUE;
}

VOID srand (DWORD dwSeed)
{
    dwRand = dwSeed;
}

WORD rand (VOID)
{
    dwRand = dwRand * 214013L + 2531011L;
    return (WORD)((dwRand >> 16) & 0xffff);
}

VOID CreateStar (WORD wIndex)
{
    nX[wIndex] = wXScreen ? (LONG)((int)(ZRAND (wXScreen)) - (int)wX2Screen) : 0;
    nY[wIndex] = wXScreen ? (LONG)((int)(ZRAND (wYScreen)) - (int)wY2Screen) : 0;
    nZ[wIndex] = SCOPE * WARPFACTOR;
}

LONG GetDlgItemLong (HWND hDlg, WORD wID, BOOL *pfTranslated, BOOL fSigned)
{
    TCHAR szTemp[20];
    LPTSTR pszTemp;
    LONG lTemp = 0l;
    BOOL fNegative;

    if (!GetDlgItemText (hDlg, wID, szTemp, CharSizeOf(szTemp)))
        goto GetDlgItemLongError;

    szTemp[19] = TEXT('\0');
    pszTemp = szTemp;
    while (*pszTemp == TEXT(' ') || *pszTemp == TEXT('\t'))
        pszTemp++;
    if ((!fSigned && *pszTemp == TEXT('-')) || !*pszTemp)
        goto GetDlgItemLongError;
    fNegative = (*pszTemp == TEXT('-')) ? TRUE : FALSE;
    while (*pszTemp >= TEXT('0') && *pszTemp <= TEXT('9'))
        lTemp = lTemp * 10l + (LONG)(*(pszTemp++) - TEXT('0'));
    if (*pszTemp)
        goto GetDlgItemLongError;
    if (fNegative)
        lTemp *= -1;
    *pfTranslated = TRUE;
    return lTemp;

GetDlgItemLongError:
    *pfTranslated = FALSE;
    return 0l;
}


LONG GetPrivateProfileLong (LPTSTR pszApp, LPTSTR pszKey, LONG lDefault)
{
    LONG    lTemp = 0l;
    TCHAR    szTemp[20];
    LPTSTR pszTemp;

    if (!GetPrivateProfileString (pszApp, pszKey, TEXT(""), szTemp, CharSizeOf(szTemp), szIniFile))
        goto GetProfileLongError;

    szTemp[19] = TEXT('\0');
    pszTemp = szTemp;
    while (*pszTemp >= TEXT('0') && *pszTemp <= TEXT('9'))
        lTemp = lTemp * 10l + (LONG)(*(pszTemp++) - TEXT('0'));
    if (*pszTemp)
        goto GetProfileLongError;
    return lTemp;

GetProfileLongError:
    return lDefault;
}


VOID GetIniEntries (VOID)
{
    LoadString (hMainInstance, idsName, szName, CharSizeOf(szName));
    LoadString (hMainInstance, idsAppName, szAppName, CharSizeOf(szAppName));

    //Load Common Strings from stringtable...
    LoadString (hMainInstance, idsIniFile, szIniFile, CharSizeOf(szIniFile));
    LoadString (hMainInstance, idsScreenSaver, szScreenSaver, CharSizeOf(szScreenSaver));
    LoadString (hMainInstance, idsHelpFile, szHelpFile, CharSizeOf(szHelpFile));
    LoadString (hMainInstance, idsNoHelpMemory, szNoHelpMemory, CharSizeOf(szNoHelpMemory));

    wWarpSpeed = (WORD) GetPrivateProfileInt (szAppName, szWarpSpeed, MINWARP + ((MAXWARP - MINWARP) / 2), szIniFile);
    if (wWarpSpeed > MAXWARP)
        wWarpSpeed = MINWARP + ((MAXWARP - MINWARP) / 2);

    wDensity = (WORD) GetPrivateProfileInt (szAppName, szDensity, DEF_DENSITY, szIniFile);
    if (wDensity > MAXSTARS)
        wDensity = MAXSTARS;
    if (wDensity < MINSTARS)
        wDensity = MINSTARS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\pipes\xc.cpp ===
//-----------------------------------------------------------------------------
// File: xc.cpp
//
// Desc: Cross-section (xc) object stuff
//
// Copyright (c) 1995-2000 Microsoft Corporation
//-----------------------------------------------------------------------------
#include "stdafx.h"





//-----------------------------------------------------------------------------
// Name: XC::CalcArcACValues90
// Desc: Calculate arc control points for a 90 degree rotation of an xc
// 
//       Arc is a quarter-circle
//       - 90 degree is much easier, so we special case it
//       radius is distance from xc-origin to hinge of turn
//-----------------------------------------------------------------------------
void XC::CalcArcACValues90( int dir, float radius, float *acPts )
{
    int i;
    float sign;
    int offset;
    float* ppts = (float *) m_pts;

    // 1) calc 'r' values for each point (4 turn possibilities/point).  From
    //  this can determine ac, which is extrusion of point from xc face
    switch( dir ) 
    {
        case PLUS_X:
            offset = 0;
            sign = -1.0f;
            break;
        case MINUS_X:
            offset = 0;
            sign =  1.0f;
            break;
        case PLUS_Y:
            offset = 1;
            sign = -1.0f;
            break;
        case MINUS_Y:
            offset = 1;
            sign =  1.0f;
            break;
    }

    for( i = 0; i < m_numPts; i++, ppts+=2, acPts++ ) 
    {
        *acPts = EVAL_CIRC_ARC_CONTROL * (radius + (sign * ppts[offset]));
    }

    // replicate !
    *acPts = *(acPts - m_numPts);
}




//-----------------------------------------------------------------------------
// Name: XC::CalcArcACValuesByDistance
// Desc: Use the distance of each xc point from the xc origin, as the radius for
//       an arc control value.
//-----------------------------------------------------------------------------
void XC::CalcArcACValuesByDistance( float *acPts )
{
    int i;
    float r;
    D3DXVECTOR2* ppts = m_pts;

    for( i = 0; i < m_numPts; i++, ppts++ ) 
    {
        r = (float) sqrt( ppts->x*ppts->x + ppts->y*ppts->y );
        *acPts++ = EVAL_CIRC_ARC_CONTROL * r;
    }

    // replicate !
    *acPts = *(acPts - m_numPts);
}




//-----------------------------------------------------------------------------
// Name: ELLIPTICAL_XC::SetControlPoints
// Desc: Set the 12 control points for a circle at origin in z=0 plane
//-----------------------------------------------------------------------------
void ELLIPTICAL_XC::SetControlPoints( float r1, float r2 )
{
    float ac1, ac2; 

    ac1 = EVAL_CIRC_ARC_CONTROL * r2;
    ac2 = EVAL_CIRC_ARC_CONTROL * r1;

    // create 12-pt. set CCW from +x

    // last 2 points of right triplet
    m_pts[0].x = r1;
    m_pts[0].y = 0.0f;
    m_pts[1].x = r1;
    m_pts[1].y = ac1;

    // top triplet
    m_pts[2].x = ac2;
    m_pts[2].y = r2;
    m_pts[3].x = 0.0f;
    m_pts[3].y = r2;
    m_pts[4].x = -ac2;
    m_pts[4].y = r2;

    // left triplet
    m_pts[5].x = -r1;
    m_pts[5].y = ac1;
    m_pts[6].x = -r1;
    m_pts[6].y = 0.0f;
    m_pts[7].x = -r1;
    m_pts[7].y = -ac1;

    // bottom triplet
    m_pts[8].x = -ac2;
    m_pts[8].y = -r2;
    m_pts[9].x = 0.0f;
    m_pts[9].y = -r2;
    m_pts[10].x = ac2;
    m_pts[10].y = -r2;

    // first point of first triplet
    m_pts[11].x = r1;
    m_pts[11].y = -ac1;
}




//-----------------------------------------------------------------------------
// Name: RANDOM4ARC_XC::SetControlPoints
// Desc: Set random control points for xc
//       Points go CCW from +x
//-----------------------------------------------------------------------------
void RANDOM4ARC_XC::SetControlPoints( float radius )
{
    int i;
    float r[4];
    float rMin = 0.5f * radius;
    float distx, disty;

    // figure the radius of each side first

    for( i = 0; i < 4; i ++ )
        r[i] = CPipesScreensaver::fRand( rMin, radius );

    // The 4 r's now describe a box around the origin - this restricts stuff

    // Now need to select a point along each edge of the box as the joining
    // points for each arc (join points are at indices 0,3,6,9)

    m_pts[0].x = r[RIGHT];
    m_pts[3].y = r[TOP];
    m_pts[6].x = -r[LEFT];
    m_pts[9].y = -r[BOTTOM];

    // quarter of distance between edges
    disty = (r[TOP] - -r[BOTTOM]) / 4.0f;
    distx = (r[RIGHT] - -r[LEFT]) / 4.0f;
    
    // uh, put'em somwhere in the middle half of each side
    m_pts[0].y = CPipesScreensaver::fRand( -r[BOTTOM] + disty, r[TOP] - disty );
    m_pts[6].y = CPipesScreensaver::fRand( -r[BOTTOM] + disty, r[TOP] - disty );
    m_pts[3].x = CPipesScreensaver::fRand( -r[LEFT] + distx, r[RIGHT] - distx );
    m_pts[9].x = CPipesScreensaver::fRand( -r[LEFT] + distx, r[RIGHT] - distx );

    // now can calc ac's
    // easy part first:
    m_pts[1].x = m_pts[11].x = m_pts[0].x;
    m_pts[2].y = m_pts[4].y  = m_pts[3].y;
    m_pts[5].x = m_pts[7].x  = m_pts[6].x;
    m_pts[8].y = m_pts[10].y = m_pts[9].y;

    // right side ac's
    disty = (r[TOP] - m_pts[0].y) / 4.0f;
    m_pts[1].y = CPipesScreensaver::fRand( m_pts[0].y + disty, r[TOP] );
    disty = (m_pts[0].y - -r[BOTTOM]) / 4.0f;
    m_pts[11].y = CPipesScreensaver::fRand( -r[BOTTOM], m_pts[0].y - disty );

    // left side ac's
    disty = (r[TOP] - m_pts[6].y) / 4.0f;
    m_pts[5].y = CPipesScreensaver::fRand( m_pts[6].y + disty, r[TOP]);
    disty = (m_pts[6].y - -r[BOTTOM]) / 4.0f;
    m_pts[7].y = CPipesScreensaver::fRand( -r[BOTTOM], m_pts[6].y - disty );

    // top ac's
    distx = (r[RIGHT] - m_pts[3].x) / 4.0f;
    m_pts[2].x = CPipesScreensaver::fRand( m_pts[3].x + distx, r[RIGHT] );
    distx = (m_pts[3].x - -r[LEFT]) / 4.0f;
    m_pts[4].x = CPipesScreensaver::fRand( -r[LEFT],  m_pts[3].x - distx );

    // bottom ac's
    distx = (r[RIGHT] - m_pts[9].x) / 4.0f;
    m_pts[10].x = CPipesScreensaver::fRand( m_pts[9].x + distx, r[RIGHT] );
    distx = (m_pts[9].x - -r[LEFT]) / 4.0f;
    m_pts[8].x = CPipesScreensaver::fRand( -r[LEFT], m_pts[9].x - distx );
}




//-----------------------------------------------------------------------------
// Name: ConvertPtsZ
// Desc: Convert the 2D pts in an xc, to 3D pts in point buffer, with z.
// 
//       Also replicate the last point.
//-----------------------------------------------------------------------------
void XC::ConvertPtsZ( D3DXVECTOR3 *newpts, float z )
{
    int i;
    D3DXVECTOR2* xcPts = m_pts;

    for( i = 0; i < m_numPts; i++, newpts++ ) 
    {
        *( (D3DXVECTOR2 *) newpts ) = *xcPts++;
        newpts->z = z;
    }

    *newpts = *(newpts - m_numPts);
}




//-----------------------------------------------------------------------------
// Name: XC::CalcBoundingBox
// Desc: Calculate bounding box in x/y plane for xc
//-----------------------------------------------------------------------------
void XC::CalcBoundingBox( )
{
    D3DXVECTOR2* ppts = m_pts;
    int i;
    float xMin, xMax, yMax, yMin;

    // initialize to really insane numbers
    xMax = yMax = -FLT_MAX;
    xMin = yMin = FLT_MAX;

    // compare with rest of points
    for( i = 0; i < m_numPts; i ++, ppts++ ) 
    {
        if( ppts->x < xMin )
            xMin = ppts->x;
        else if( ppts->x > xMax )
            xMax = ppts->x;
        if( ppts->y < yMin )
            yMin = ppts->y;
        else if( ppts->y > yMax )
            yMax = ppts->y;
    }

    m_xLeft   = xMin;
    m_xRight  = xMax;
    m_yBottom = yMin;
    m_yTop    = yMax;
}




//-----------------------------------------------------------------------------
// Name: MinTurnRadius
// Desc: Get minimum radius for the xc to turn in given direction. 
//
//       If the turn radius is less than this minimum, then primitive will 'fold'
//       over itself at the inside of the turn, creating ugliness.
//-----------------------------------------------------------------------------
float XC::MinTurnRadius( int relDir )
{
    // For now, assume xRight, yTop positive, xLeft, yBottom negative
    // otherwise, might want to consider 'negative'radius
    switch( relDir ) 
    {
        case PLUS_X:
            return( m_xRight );
        case MINUS_X:
            return( - m_xLeft );
        case PLUS_Y:
            return( m_yTop );
        case MINUS_Y:
            return( - m_yBottom );
        default:
            return(0.0f);
    }
}




//-----------------------------------------------------------------------------
// Name: XC::MaxExtent
// Desc: Get maximum extent of the xc in x and y
//-----------------------------------------------------------------------------
float XC::MaxExtent( )
{
    float max;

    max = m_xRight;

    if( m_yTop > max )
        max = m_yTop;
    if( -m_xLeft > max )
        max = -m_xLeft;
    if( -m_yBottom > max )
        max = -m_yBottom;

    return max;
}




//-----------------------------------------------------------------------------
// Name: XC::Scale
// Desc: Scale an XC's points and extents by supplied scale value
//-----------------------------------------------------------------------------
void XC::Scale( float scale )
{
    int i;
    D3DXVECTOR2* ppts = m_pts;
    if( ppts == NULL )
        return;

    for( i = 0; i < m_numPts; i ++, ppts++ ) 
    {
        ppts->x *= scale;
        ppts->y *= scale;
    }

    m_xLeft   *= scale;
    m_xRight  *= scale;
    m_yBottom *= scale;
    m_yTop    *= scale;
}




//-----------------------------------------------------------------------------
// Name: ~XC::XC
// Desc: Destructor
//-----------------------------------------------------------------------------
XC::~XC()
{
    if( m_pts )
        LocalFree( m_pts );
}




//-----------------------------------------------------------------------------
// Name: XC::XC
// Desc: Constructor
//       Allocates point buffer for the xc
//-----------------------------------------------------------------------------
XC::XC( int nPts )
{
    m_numPts = nPts;
    m_pts = (D3DXVECTOR2 *)  LocalAlloc( LMEM_FIXED, m_numPts * sizeof(D3DXVECTOR2) );
    assert( m_pts != 0 && "XC constructor\n" );
}





//-----------------------------------------------------------------------------
// Name: XC::XC
// Desc: Constructor
//       Allocates point buffer for the xc from another XC
//-----------------------------------------------------------------------------
XC::XC( XC *xc )
{
    m_numPts = xc->m_numPts;
    m_pts = (D3DXVECTOR2 *)  LocalAlloc( LMEM_FIXED, m_numPts * sizeof(D3DXVECTOR2) );
    assert( m_pts != 0 && "XC constructor\n" );
    if( m_pts != NULL )
        RtlCopyMemory( m_pts, xc->m_pts, m_numPts * sizeof(D3DXVECTOR2) );

    m_xLeft   = xc->m_xLeft;
    m_xRight  = xc->m_xRight;
    m_yBottom = xc->m_yBottom;
    m_yTop    = xc->m_yTop;
}




//-----------------------------------------------------------------------------
// Name: ELLIPTICAL_XC::ELLIPTICALXC
// Desc: Elliptical XC constructor
//       These have 4 sections of 4 pts each, with pts shared between sections.
//-----------------------------------------------------------------------------
ELLIPTICAL_XC::ELLIPTICAL_XC( float r1, float r2 )
    // initialize base XC with numPts
    : XC( (int) EVAL_XC_CIRC_SECTION_COUNT * (EVAL_ARC_ORDER - 1))
{
    SetControlPoints( r1, r2 );
    CalcBoundingBox( );
}




//-----------------------------------------------------------------------------
// Name: RANDOM4ARC_XC::RANDOM4ARC_XC
// Desc: Random 4-arc XC constructor
//       The bounding box is 2*r each side
//       These have 4 sections of 4 pts each, with pts shared between sections.
//-----------------------------------------------------------------------------
RANDOM4ARC_XC::RANDOM4ARC_XC( float r )
    // initialize base XC with numPts
    : XC( (int) EVAL_XC_CIRC_SECTION_COUNT * (EVAL_ARC_ORDER - 1))
{
    SetControlPoints( r );
    CalcBoundingBox( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\swoosh\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Swoosh.rc
//
#define IDB_BITMAP1                     101
#define IDB_BLOB                        101
#define IDI_ICON                        102
#define IDD_SETTINGS                    103
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201
#define IDC_COLOUR1_MULTI               1000
#define IDC_COLOUR1_FIXED               1001
#define IDC_COLOUR1_PICK                1002
#define IDC_COLOUR2_MULTI               1003
#define IDC_COLOUR2_FIXED               1004
#define IDC_COLOUR2_PICK                1005
#define IDC_COLOUR_MIX                  1006
#define IDC_ROLL_RATE                   1007
#define IDC_YAW_RATE                    1008
#define IDC_FLOW_RATE                   1009
#define IDC_PARTICLE_SIZE               1010
#define IDC_NUM_PARTICLES               1011
#define IDC_SCREEN_SETTINGS             1012
#define IDC_RESET                       1013
#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016
#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112
#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\swoosh\swoosh.h ===
#ifndef	_SWOOSH_H
#define	_SWOOSH_H

//**********************************************************************************

#include	<windows.h>
#include	<d3d8.h>
#include    <d3d8rgbrast.h>
#include	<d3dx8.h>
#include	<d3dsaver.h>

//**********************************************************************************
class	CSwoosh : public CD3DScreensaver
{
public:
	CSwoosh();

	virtual	HRESULT	Create( HINSTANCE hInstance );

protected:
	// Key stuff to override from CD3DScreensaver
    virtual HRESULT RegisterSoftwareDevice();
    virtual void    SetDevice( UINT iDevice );
    virtual HRESULT Render();
    virtual HRESULT FrameMove();
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();
	virtual	void	ReadSettings();
	virtual	void	DoConfig();

	// All the settings for the screensaver
	DWORD	m_dwNumParticles;
	DWORD	m_dwColourMix;
	DWORD	m_dwColour1;
	DWORD	m_dwColour2;
	DWORD	m_dwFixedColour1;
	DWORD	m_dwFixedColour2;
	float	m_fFlowRate;
	float	m_fRollRate;
	float	m_fYawRate;
	float	m_fParticleSize;

	// Stuff we need to keep track of on a per-device basis (textures, whathaveyou)
	// We update the m_pDeviceObjects pointer in SetDevice to point to the current set
	struct DeviceObjects
	{
		DeviceObjects();

		IDirect3DTexture8*			pBlobTexture;
		IDirect3DVertexBuffer8*		pParticleVB;
		IDirect3DIndexBuffer8*		pParticleIB;
	};
	enum { MAX_DEVICE_OBJECTS = 10 };
    DeviceObjects	m_DeviceObjects[MAX_DEVICE_OBJECTS];
    DeviceObjects*	m_pDeviceObjects;
	DWORD			m_dwVertMemType;

	struct	Particle
	{
		D3DXVECTOR3	pos;
		D3DCOLOR	colour;
	};
	enum { MAX_PARTICLES = 8192 };
	Particle		m_Particles[MAX_PARTICLES];
	D3DXMATRIX		m_Camera;

	void	InitParticles();
	void	UpdateParticles();
	void	RenderParticles();
	void	UpdateCamera();
	void	WriteSettings();

	float	m_fCameraYaw,m_fCameraRoll;
	float	m_fYawDirection;
	float	m_fYawPause;

	static BOOL CALLBACK	ConfigDlgProcStub( HWND hDlg , UINT msg , WPARAM wParam , LPARAM lParam );
	BOOL					ConfigDlgProc( HWND hDlg , UINT msg , WPARAM wParam , LPARAM lParam );
	void					ExtractDialogSettings( HWND hDlg );
	DWORD					PickColour( HWND hParent , DWORD defcolour );
};

//**********************************************************************************
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\text3d\text3d.h ===
//-----------------------------------------------------------------------------
// File: TextSaver.h
//
// Desc: Fun screen saver
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef _TEXTSAVER_H
#define _TEXTSAVER_H

//***************************************************************************************
#define MAX_DISPLAY_STRING  20

enum SurfType
{
    color = 0,
    environment = 1,
    texture = 2
};

enum RotType
{
    none = 0,
    spin = 1,
    seesaw = 2,
    wobble = 3,
    tumble = 4
};

//***************************************************************************************
#define MAX_DEVICE_OBJECTS 10

struct DeviceObjects
{
    ID3DXMesh*          m_pObject;
    IDirect3DTexture8*  m_pTexture;
    DWORD               m_dwMeshUpdateCounter;
};


//-----------------------------------------------------------------------------
// Name: struct FLOATRECT
// Desc: Floating viewport rect
//-----------------------------------------------------------------------------
struct FLOATRECT
{
    FLOAT xMin;           
    FLOAT yMin;
    FLOAT xSize;
    FLOAT ySize;
    FLOAT xVel;
    FLOAT yVel;
};



class CTextScreensaver : public CD3DScreensaver
{
public:
    CTextScreensaver();

    virtual VOID        DoConfig();

protected:
    // Overrides from CD3DScreensaver
    virtual HRESULT RegisterSoftwareDevice();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();
    virtual HRESULT RestoreDeviceObjects();
    virtual HRESULT InvalidateDeviceObjects();
    virtual HRESULT ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, 
                                  D3DFORMAT fmtBackBuffer);
    virtual VOID    SetDevice( UINT iDevice );

    DeviceObjects  m_DeviceObjects[MAX_DEVICE_OBJECTS];
    DeviceObjects* m_pDeviceObjects;

    FLOATRECT      m_floatrect;
    HFONT          m_hFont;
    FLOAT          m_fTextMinX,m_fTextMaxX;
    FLOAT          m_fTextMinY,m_fTextMaxY;
    FLOAT          m_fTextOffsetX,m_fTextOffsetY;

    FLOAT          m_fAngleX,m_fAngleY,m_fAngleZ;

    DWORD          m_dwLastTick;
    DWORD          m_dwMeshUpdateCounter;

    IDirect3DTexture8*  CreateTextureFromFile( const TCHAR* filename );
    HRESULT        BuildTextMesh( const TCHAR* text );
    VOID           UpdateAngles( DWORD elapsed );
    BOOL           UpdateTimeString( TCHAR* string );
    VOID           SetPerFrameStates();

    // Configuration stuff
    TCHAR          m_szDisplayString[MAX_DISPLAY_STRING+1];
    LOGFONT        m_Font;
    BOOL           m_bDisplayTime;
    SurfType       m_SurfType;
    BOOL           m_bSpecular;
    DWORD          m_dwRotationSpeed;
    DWORD          m_dwSize;
    RotType        m_RotType;
    COLORREF       m_SurfaceColor;
    BOOL           m_bUseCustomColor;
    BOOL           m_bUseCustomTexture;
    BOOL           m_bUseCustomEnvironment;
    TCHAR          m_szCustomTexture[_MAX_PATH];
    TCHAR          m_szCustomEnvironment[_MAX_PATH];
    DWORD          m_dwMeshQuality;
    D3DXMATRIX     m_matWorld;
    D3DXMATRIX     m_matView;

    virtual VOID   ReadSettings();

    VOID ss_ReadSettings();
    BOOL ss_RegistrySetup( int section, int file );
    int  ss_GetRegistryInt( int name, int iDefault );
    VOID ss_GetRegistryString( int name, LPTSTR lpDefault, LPTSTR lpDest, int bufSize );
    
    static INT_PTR CALLBACK SettingsDialogProcStub( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
    BOOL           SettingsDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
    VOID           InitItems( HWND hDlg );
    VOID           ExtractAndWriteSettings( HWND hDlg );
    VOID           SelectSurfaceColor( HWND hDlg );
    VOID           SelectFont( HWND hDlg );
    VOID           SelectCustomTexture( HWND hDlg );
    VOID           SelectCustomEnvironment( HWND hDlg );
    VOID           EnableTextureWindows( HWND hDlg , SurfType sel );
};

//***************************************************************************************
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\text3d\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Text3D.rc
//
#define IDS_DESCRIPTION                 1
#define IDI_ICON1                       101
#define IDB_TEXTURE                     102
#define IDB_SPHEREMAP                   103
#define IDD_SETTINGS                    105
#define IDD_ABOUT                       116
#define IDD_SINGLEMONITORSETTINGS       200
#define IDD_MULTIMONITORSETTINGS        201
#define IDC_DEVICE_SELECT               1000
#define IDS_DEFAULTTEXT                 1000
#define IDC_MODE_SELECT                 1001
#define IDC_SCREENSETTINGS              1002
#define IDC_RADIO_TIME                  1004
#define IDC_RADIO_TEXT                  1005
#define IDC_RADIO_COLOR                 1007
#define IDS_NONE                        1008
#define IDC_RADIO_TEXTURE               1008
#define IDS_SPIN                        1009
#define IDC_RADIO_REFLECTION            1009
#define IDS_SEESAW                      1010
#define IDS_WOBBLE                      1011
#define IDC_SPECULAR                    1012
#define IDS_TUMBLE                      1012
#define IDC_ROTATION_SPEED              1013
#define IDS_FILEFILTER                  1013
#define IDC_ROTATION_STYLE              1014
#define IDS_OPENTEXTURETITLE            1014
#define IDC_ABOUT                       1015
#define IDS_OPENENVIRONMENTMAPTITLE     1015
#define IDS_FONT                        1016
#define IDC_RESOLUTION                  1016
#define IDC_SURFACE_COLOR               1017
#define IDC_VIEWPORTSIZE                1020
#define IDC_BROWSE_TEXTURE              1022
#define IDC_BROWSE_ENVIRONMENT          1024
#define IDC_USE_CUSTOM_TEXTURE          1025
#define IDC_USE_CUSTOM_ENVIRONMENT      1026
#define IDC_USE_CUSTOM_COLOR            1027
#define IDC_SELECT_FONT                 1028
#define IDC_DISPLAY_STRING              1029
#define DLG_SELECT_FONT                 1543
#define IDS_INIFILE                     9105
#define IDS_INI_SECTION                 9106
#define IDS_SAVERNAME                   9107
#define IDS_OPTIONS                     9108
#define IDS_OBJTYPE                     9109
#define IDS_TEXTURE                     9110
#define IDS_TEXTURE_FILE_OFFSET         9111
#define IDS_SIZE                        9112
#define IDS_TESSELATION                 9113
#define IDS_GENNAME                     9114
#define IDS_DEFFONT                     9115
#define IDS_DEFCHARSET	                9116
#define IDS_DEMOTYPE                    9117
#define IDS_SURFSTYLE                   9118
#define IDS_FONT_REG                    9119
#define IDS_FONT_ATTRIBUTES             9120
#define IDS_CHARSET                     9121
#define IDS_TEXT                        9122
#define IDS_SPEED                       9123
#define IDS_ROTSTYLE                    9124
#define IDC_MONITORSTAB                 2000
#define IDC_TABNAMEFMT                  2001
#define IDC_ADAPTERNAME                 2002
#define IDC_RENDERING                   2003
#define IDC_MOREINFO                    2004
#define IDC_DISABLEHW                   2005
#define IDC_SCREENUSAGEBOX              2006
#define IDC_RENDER                      2007
#define IDC_LEAVEBLACK                  2008
#define IDC_DISPLAYMODEBOX              2009
#define IDC_MODESSTATIC                 2010
#define IDC_MODESCOMBO                  2011
#define IDC_AUTOMATIC                   2012
#define IDC_DISPLAYMODENOTE             2013
#define IDC_GENERALBOX                  2014
#define IDC_SAME                        2015
#define IDC_MODEFMT                     2016
#define IDS_ERR_GENERIC                 2100
#define IDS_ERR_NODIRECT3D              2101
#define IDS_ERR_NOWINDOWEDHAL           2102
#define IDS_ERR_CREATEDEVICEFAILED      2103
#define IDS_ERR_NOCOMPATIBLEDEVICES     2104
#define IDS_ERR_NOHARDWAREDEVICE        2105
#define IDS_ERR_HALNOTCOMPATIBLE        2106
#define IDS_ERR_NOHALTHISMODE           2107
#define IDS_ERR_MEDIANOTFOUND           2108
#define IDS_ERR_RESIZEFAILED            2109
#define IDS_ERR_OUTOFMEMORY             2110
#define IDS_ERR_OUTOFVIDEOMEMORY        2111
#define IDS_ERR_NOPREVIEW               2112
#define IDS_INFO_GOODHAL                2200
#define IDS_INFO_BADHAL_GOODSW          2201
#define IDS_INFO_BADHAL_BADSW           2202
#define IDS_INFO_BADHAL_NOSW            2203
#define IDS_INFO_NOHAL_GOODSW           2204
#define IDS_INFO_NOHAL_BADSW            2205
#define IDS_INFO_NOHAL_NOSW             2206
#define IDS_INFO_DISABLEDHAL_GOODSW     2207
#define IDS_INFO_DISABLEDHAL_BADSW      2208
#define IDS_INFO_DISABLEDHAL_NOSW       2209
#define IDS_RENDERING_HAL               2210
#define IDS_RENDERING_SW                2211
#define IDS_RENDERING_NONE              2212

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\access.c ===
// **************************************************************************
// Access.c
//
// Accessability Property sheet page creator
//
// **************************************************************************

#include "Access.h"

#ifdef  UNICODE     // Windows uses UNICODE
#define _UNICODE    // but tchar.h uses _UNICODE
#endif

DWORD g_dwOrigFKFlags;
BOOL g_bFKOn;

#include <stdlib.h>
#include <stddef.h>
#include <tchar.h>

#define OLDDISABLED     32760

#ifndef FKF_VALID
#define FKF_VALID           0x0000007F
#endif

#ifndef SKF_VALID
#define SKF_VALID           0x000001FF
#endif

#ifndef MKF_VALID
#define MKF_VALID           0x000000FF
#endif

#ifndef ATF_VALID
#define ATF_VALID           0x00000003
#endif

#ifndef SSF_VALID
#define SSF_VALID           0x00000007
#endif

#ifndef TKF_VALID
#define TKF_VALID           0x0000003F
#endif

//////////////////////////////////////////////////////////////////////////

// collection of data that represents the saved accessability state
typedef struct ACCSTATE   // as
{
    // Keyboard property page
    STICKYKEYS     sk;
    FILTERKEYS     fk;
    TOGGLEKEYS     tk;
    BOOL           fExtraKeyboardHelp;

    // Sound Property page
    SOUNDSENTRY    ss;
    BOOL           fShowSounds;

    // Display Property page
    HIGHCONTRAST   hc;
    TCHAR          szDefaultScheme[256];  // hc.lpszDefaultScheme
    CARET_SETTINGS cs;

    // Mouse Property page
    MOUSEKEYS      mk;

    // General Property page
    BOOL               fShowWarnMsgOnFeatureActivate;
    BOOL               fPlaySndOnFeatureActivate;

    ACCESSTIMEOUT  ato;
    SERIALKEYS     serk;
    TCHAR          szActivePort[MAX_PATH];  // serk.szActivePort
    TCHAR          szPort[MAX_PATH];                // serk.szPort
} ACCSTATE, *PACCSTATE;


//////////////////////////////////////////////////////////////////////////
extern BOOL g_SPISetValue = FALSE;

static ACCSTATE s_asOrg;          // original settings from app start-up
static ACCSTATE s_asPrev;         // previous saved settings

extern BOOL  g_fWinNT = -1;       // TRUE if we're running on NT and must
                                  // disable some features

extern BOOL  g_fSaveSettings = TRUE;
extern BOOL  g_fShowWarnMsgOnFeatureActivate = TRUE;
extern BOOL  g_fPlaySndOnFeatureActivate = TRUE;
extern BOOL  g_fCopyToLogon = FALSE;
extern BOOL  g_fCopyToDefault = FALSE;
// Keyboard property page
// extern STICKYKEYS     g_sk = {0};
STICKYKEYS     g_sk;
FILTERKEYS     g_fk;
   // g_dwLastBounceKeySetting, g_nLastRepeatDelay, g_nLastRepeatRate
   //  and g_nLastWait are part of FilterKeys
   DWORD g_dwLastBounceKeySetting = 0;
   DWORD g_nLastRepeatDelay = 0;
   DWORD g_nLastRepeatRate = 0;
   DWORD g_nLastWait = 0;

TOGGLEKEYS     g_tk;
BOOL           g_fExtraKeyboardHelp = TRUE;

// Sound Property page
SOUNDSENTRY    g_ss;
BOOL           g_fShowSounds;

// Display Property page
HIGHCONTRAST   g_hc;
CARET_SETTINGS g_cs;

// Mouse Property page
MOUSEKEYS      g_mk;

// General Property page
ACCESSTIMEOUT  g_ato;
SERIALKEYS     g_serk;
TCHAR          g_szActivePort[MAX_PATH];
TCHAR          g_szPort[MAX_PATH];

#define CONTROL_PANEL_DESKTOP TEXT("Control Panel\\Desktop")
#define CURSOR_BLINK_RATE TEXT("CursorBlinkRate")
#define DEFAULT_BLINK_RATE 530

//////////////////////////////////////////////////////////////////////////

void CopyHighContrast(LPHIGHCONTRAST phcDest, LPHIGHCONTRAST phcSrc)
{
    LPTSTR lpszDefaultScheme = phcDest->lpszDefaultScheme;

    memcpy(phcDest, phcSrc, sizeof(*phcDest));
    phcDest->lpszDefaultScheme = lpszDefaultScheme;

    if (NULL != phcDest->lpszDefaultScheme)
    {
        lstrcpy(phcDest->lpszDefaultScheme, phcSrc->lpszDefaultScheme);
    }
}

//////////////////////////////////////////////////////////////////////////

BOOL IsHighContrastEqual(LPHIGHCONTRAST phcDest, LPHIGHCONTRAST phcSrc)
{
    BOOL fIsEqual = FALSE;
    LPTSTR lpszDefaultScheme = phcDest->lpszDefaultScheme;

    // Temporarily make the pointers match
    phcDest->lpszDefaultScheme = phcSrc->lpszDefaultScheme;

    // match the bits of the structures and the pointed to data
    fIsEqual = (0 == memcmp(phcDest, phcSrc, sizeof(*phcDest)) &&
                0 == lstrcmp(lpszDefaultScheme, phcSrc->lpszDefaultScheme));

    phcDest->lpszDefaultScheme = lpszDefaultScheme;

    return(fIsEqual);
}


//////////////////////////////////////////////////////////////////////////

void CopySerialKeys(LPSERIALKEYS pskDest, LPSERIALKEYS pskSrc)
{
    LPTSTR lpszActivePort = pskDest->lpszActivePort;
    LPTSTR lpszPort = pskDest->lpszPort;

    memcpy(pskDest, pskSrc, sizeof(*pskDest));
    pskDest->lpszActivePort = lpszActivePort;

    if (NULL != pskDest->lpszActivePort)
    {
        lstrcpy(pskDest->lpszActivePort, pskSrc->lpszActivePort);
    }

    pskDest->lpszPort = lpszPort;
    if (NULL != pskDest->lpszPort)
    {
        lstrcpy(pskDest->lpszPort, pskSrc->lpszPort);
    }
}

//////////////////////////////////////////////////////////////////////////

BOOL IsSerialKeysEqual(LPSERIALKEYS pskDest, LPSERIALKEYS pskSrc)
{
    BOOL fIsEqual = FALSE;
    LPTSTR lpszActivePort = pskDest->lpszActivePort;
    LPTSTR lpszPort = pskDest->lpszPort;

    // Temporarily make the pointers match
    pskDest->lpszActivePort = pskSrc->lpszActivePort;
    pskDest->lpszPort = pskSrc->lpszPort;

    // match the bits of the structures and the pointed to data
    fIsEqual = (0 == memcmp(pskDest, pskSrc, sizeof(*pskDest)) &&
        (NULL == lpszActivePort ||
                0 == lstrcmp(lpszActivePort, pskSrc->lpszActivePort)) &&
        (NULL == lpszPort ||
                0 == lstrcmp(lpszPort, pskSrc->lpszPort)));

    pskDest->lpszActivePort = lpszActivePort;
    pskDest->lpszPort = lpszPort;

    return(fIsEqual);
}

//////////////////////////////////////////////////////////////////////////

BOOL IsAccStateEqual(PACCSTATE pasDest, PACCSTATE pasSrc)
{
    BOOL fIsEqual = FALSE;
    HIGHCONTRAST   hc = pasDest->hc;
    SERIALKEYS     serk = pasDest->serk;
    int nLen;

    // Clear out the unused sections of the string buffers
    nLen = lstrlen(pasDest->szDefaultScheme);
    memset(&pasDest->szDefaultScheme[nLen], 0,
        sizeof(pasDest->szDefaultScheme)-nLen*sizeof(*pasDest->szDefaultScheme));

    nLen = lstrlen(pasDest->szActivePort);
    memset(&pasDest->szActivePort[nLen], 0,
        sizeof(pasDest->szActivePort)-nLen*sizeof(*pasDest->szActivePort));

    nLen = lstrlen(pasDest->szPort);
    memset(&pasDest->szPort[nLen], 0,
            sizeof(pasDest->szPort)-nLen*sizeof(*pasDest->szPort));

    nLen = lstrlen(pasSrc->szDefaultScheme);
    memset(&pasSrc->szDefaultScheme[nLen], 0,
            sizeof(pasSrc->szDefaultScheme)-nLen*sizeof(*pasSrc->szDefaultScheme));

    nLen = lstrlen(pasSrc->szActivePort);
    memset(&pasSrc->szActivePort[nLen], 0,
            sizeof(pasSrc->szActivePort)-nLen*sizeof(*pasSrc->szActivePort));

    nLen = lstrlen(pasSrc->szActivePort);
    memset(&pasSrc->szPort[nLen], 0,
            sizeof(pasSrc->szPort)-nLen*sizeof(*pasSrc->szPort));

    // Temporarily make the elements with pointers match
    pasDest->hc = pasSrc->hc;
    pasDest->serk = pasSrc->serk;

    // match the bits of the structures and the elements with pointers
    fIsEqual = (0 == memcmp(pasDest, pasSrc, sizeof(*pasDest)) &&
            IsHighContrastEqual(&hc, &pasSrc->hc) &&
            IsSerialKeysEqual(&serk, &pasSrc->serk));

    pasDest->hc = hc;
    pasDest->serk = serk;

    return(fIsEqual);
}


//////////////////////////////////////////////////////////////////////////


int WINAPI RegQueryInt (int nDefault, HKEY hkey, LPTSTR lpSubKey, LPTSTR lpValueName) {

   DWORD dwType;
   DWORD dwVal = nDefault;
   DWORD cbData = sizeof(int);
   if (ERROR_SUCCESS == RegOpenKeyEx(hkey, lpSubKey, 0, KEY_QUERY_VALUE, &hkey)) {
      RegQueryValueEx(hkey, lpValueName, NULL, &dwType, (PBYTE) &dwVal, &cbData);
      RegCloseKey(hkey);
   }
   return(dwVal);
}


//////////////////////////////////////////////////////////////////////////


BOOL WINAPI RegSetInt (HKEY hkey, LPTSTR lpSubKey, LPTSTR lpValueName, int nVal) {
   BOOL fOk = FALSE;
   DWORD dwDisposition;
   LONG lRet;

   if (ERROR_SUCCESS == RegCreateKeyEx(hkey, lpSubKey, 0, NULL, REG_OPTION_NON_VOLATILE,
      KEY_SET_VALUE, NULL, &hkey, &dwDisposition)) {

      lRet = RegSetValueEx(hkey, lpValueName, 0, REG_DWORD, (CONST BYTE *) &nVal, sizeof(nVal));
      fOk = (ERROR_SUCCESS == lRet);
      RegCloseKey(hkey);
   }
   return fOk;
}


//////////////////////////////////////////////////////////////////////////


void WINAPI RegQueryStr(
   LPTSTR lpDefault,
   HKEY hkey,
   LPTSTR lpSubKey,
   LPTSTR lpValueName,
   LPTSTR lpszValue,
   DWORD cbData) // note this is bytes, not characters.
{
   DWORD dwType;
   DWORD dwOrigCount = cbData;
   lstrcpy(lpszValue, lpDefault);
   if (ERROR_SUCCESS == RegOpenKeyEx(hkey, lpSubKey, 0, KEY_QUERY_VALUE, &hkey)) {
      RegQueryValueEx(hkey, lpValueName, NULL, &dwType, (PBYTE) lpszValue, &cbData);
      lpszValue[dwOrigCount/sizeof (TCHAR)-1] = TEXT('\0');
      RegCloseKey(hkey);
   }
}

/***************************************************************************\
**AccessWriteProfileString
*
* History:
* 12-19-95 a-jimhar 	Created (was called AccessWriteProfileString)
* 02-08-95 a-jimhar     revised and moved from accrare.c to access.c
\***************************************************************************/
BOOL RegSetStr(
    HKEY hkey,
    LPCTSTR lpSection,
    LPCTSTR lpKeyName,
    LPCTSTR lpString)
{
    BOOL fRet = FALSE;
    LONG lErr;
    DWORD dwDisposition;

    lErr = RegCreateKeyEx(
            hkey,
            lpSection,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hkey,
            &dwDisposition);

    if (ERROR_SUCCESS == lErr)
    {
        if (NULL != lpString)
        {
            lErr = RegSetValueEx(
                    hkey,
                    lpKeyName,
                    0,
                    REG_SZ,
                    (CONST BYTE *)lpString,
                    (lstrlen(lpString) + 1) * sizeof(*lpString));
        }
        else
        {
            lErr = RegSetValueEx(
                    hkey,
                    lpKeyName,
                    0,
                    REG_SZ,
                    (CONST BYTE *)__TEXT(""),
                    1 * sizeof(*lpString));
        }

        if (ERROR_SUCCESS == lErr)
        {
            fRet = TRUE;
        }
        RegCloseKey(hkey);
    }
    return(fRet);
}


DWORD WINAPI RegQueryStrDW(
    DWORD dwDefault,
    HKEY hkey,
    LPTSTR lpSubKey,
    LPTSTR lpValueName)
{
    DWORD dwRet = dwDefault;

    TCHAR szTemp[40];
    TCHAR szDefault[40];

    const LPTSTR pwszd = __TEXT("%d");

    wsprintf(szDefault, pwszd, dwDefault);

    RegQueryStr(
        szDefault,
        hkey,
        lpSubKey,
        lpValueName,
        szTemp,
        sizeof(szTemp));

    dwRet = _ttol(szTemp);

    return dwRet;
}


BOOL RegSetStrDW(
    HKEY hkey,
    LPTSTR lpSection,
    LPCTSTR lpKeyName,
    DWORD dwValue)
{
    BOOL fRet;
    TCHAR szTemp[40];
    const LPTSTR pwszd = __TEXT("%d");

    wsprintf(szTemp, pwszd, dwValue);
    fRet = RegSetStr(hkey, lpSection, lpKeyName, szTemp);

    return fRet;
}


//////////////////////////////////////////////////////////////////////////


/*------------------------------------------------------------------
 * Function void KillAccStat()
 *
 * Purpose     Check if accstat is already running.  If it is we need
 *             to check to see if it should be.  It should only be running
 *             if each feature that is on also has the 'show status on
 *             screen flag checked.  If not we want to kill accstat.
 *
 * Params:     None
 *
 * Return:     TRUE if we had to kill accstat
 *             FALSE if accstat not running/valid session
 *------------------------------------------------------------------*/

void KillAccStat (void) {
   BOOL fCanTurnOff = FALSE;     // Can we turn off accstat due to invalid feature?
   BOOL fValidFeature = FALSE;   // Are there any valid features?

   // Accstat may be running.  Determine if it should be running
   // We need to check the FilterKeys, MouseKeys and StickyKeys
   if (g_sk.dwFlags & SKF_STICKYKEYSON)
      if (!(g_sk.dwFlags & SKF_INDICATOR))
         fCanTurnOff = TRUE;   // A mismatched flag - we MAY be able to turn off.
      else
         fValidFeature = TRUE; // A valid feature - we CAN't turn off accstat.

   if (g_fk.dwFlags & FKF_FILTERKEYSON)
      if (!(g_fk.dwFlags & FKF_INDICATOR))
         fCanTurnOff = TRUE;   // A mismatched flag - we MAY be able to turn off.
      else
         fValidFeature = TRUE; // A valid feature - we CAN't turn off accstat.

   if (g_mk.dwFlags & MKF_MOUSEKEYSON)
      if (!(g_mk.dwFlags & MKF_INDICATOR))
         fCanTurnOff = TRUE;   // A mismatched flag - we MAY be able to turn off.
      else
         fValidFeature = TRUE; // A valid feature - we CAN't turn off accstat.

   // Now we have two flags: fCanTurnOff is TRUE if there is a mismatched flag set
   // ie, feature on, indicator off.  ValidFeature is TRUE if any feature has
   // ON and INDICATOR set which implies accstat must remain active.
   if (!fValidFeature && fCanTurnOff) {
      TCHAR szBuf[256];
      HWND hwndAccStat;
      LoadString(g_hinst, IDS_ACCSTAT_WINDOW_TITLE, szBuf, ARRAY_SIZE(szBuf));
      if (IsWindow(hwndAccStat = FindWindow(NULL, szBuf))) {
         // Note sending 1 as the lParam tells accstat to shutup and
         // go away NOW.
         SendMessage(hwndAccStat, WM_SYSCOMMAND, SC_CLOSE, 1);
      }
   }
}


//////////////////////////////////////////////////////////////////////////


void WINAPI GetAccessibilitySettings (void) {
   BOOL fUpdate;

   if (g_fWinNT == -1) {
      OSVERSIONINFO osvi;
      osvi.dwOSVersionInfoSize = sizeof(osvi);
      GetVersionEx(&osvi);
      g_fWinNT = (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);
   }

   g_fShowWarnMsgOnFeatureActivate = (BOOL) RegQueryInt(TRUE, HKEY_CURRENT_USER,
      GENERAL_KEY, WARNING_SOUNDS);

   s_asPrev.fShowWarnMsgOnFeatureActivate = g_fShowWarnMsgOnFeatureActivate;

   // Query the Sound On Activation entry
   g_fPlaySndOnFeatureActivate = (BOOL) RegQueryInt(TRUE, HKEY_CURRENT_USER,
      GENERAL_KEY, SOUND_ON_ACTIVATION);

   s_asPrev.fPlaySndOnFeatureActivate = g_fPlaySndOnFeatureActivate;

   g_fSaveSettings = TRUE;

   // Keyboard property page
   g_sk.cbSize = sizeof(g_sk);
   AccessSystemParametersInfo(SPI_GETSTICKYKEYS, sizeof(g_sk), &g_sk, 0);
   s_asPrev.sk = g_sk;

   g_fk.cbSize = sizeof(g_fk);
   AccessSystemParametersInfo(SPI_GETFILTERKEYS, sizeof(g_fk), &g_fk, 0);
   g_fk.dwFlags |= FKF_AVAILABLE;

   // FILTERKEYS used to use OLDDISABLED as it's "unused" flag.  This doesn't
   // work very well on NT (SPI_SETFILTERKEYS calls fail).  We now use 0
   // for disabled values.  Take this opertunity to change any OLDDISABLED
   // values to 0 and save if needed.

   fUpdate = FALSE;

   if (OLDDISABLED == g_fk.iBounceMSec)
   {
      g_fk.iBounceMSec = 0;
      fUpdate = TRUE;
   }
   if (OLDDISABLED == g_fk.iDelayMSec)
   {
      g_fk.iDelayMSec = 0;
      fUpdate = TRUE;
   }
   if (OLDDISABLED == g_fk.iRepeatMSec)
   {
      g_fk.iRepeatMSec = 0;
      fUpdate = TRUE;
   }
   if (OLDDISABLED == g_fk.iWaitMSec)
   {
       g_fk.iWaitMSec = 0;
       fUpdate = TRUE;
   }

   if (fUpdate)
   {
        AccessSystemParametersInfo(
                SPI_SETFILTERKEYS, sizeof(g_fk), &g_fk, SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
   }

   s_asPrev.fk = g_fk;
   // fix Filter keys bug
   g_dwOrigFKFlags = g_fk.dwFlags;
   g_bFKOn = g_fk.dwFlags & FKF_FILTERKEYSON;

   // g_dwLastBounceKeySetting, g_nLastRepeatDelay, g_nLastRepeatRate
   // and g_nLastWait are part of FilterKeys

   if (0 != g_fk.iBounceMSec) {
      // Bounce keys enabeled
      g_fk.iDelayMSec = 0;
      g_fk.iRepeatMSec = 0;
      g_fk.iWaitMSec = 0;

      g_dwLastBounceKeySetting = g_fk.iBounceMSec;
      g_nLastRepeatDelay = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_DELAY);
      g_nLastRepeatRate = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_RATE);
      g_nLastWait = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_WAIT);
   }
   else
   {
      if (0 == g_fk.iDelayMSec)
      {
          g_fk.iRepeatMSec = 0;
      }
      g_dwLastBounceKeySetting = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_BOUNCE_SETTING);
      g_nLastRepeatDelay = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_DELAY);
      g_nLastRepeatRate = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_RATE);
      if (0 != g_fk.iWaitMSec)
      {
         g_nLastWait = g_fk.iWaitMSec;
      }
      else
      {
         g_nLastWait = RegQueryInt(0, HKEY_CURRENT_USER, FILTER_KEY, LAST_WAIT);
      }
   }

   g_tk.cbSize = sizeof(g_tk);
   AccessSystemParametersInfo(SPI_GETTOGGLEKEYS, sizeof(g_tk), &g_tk, 0);
   s_asPrev.tk = g_tk;

   AccessSystemParametersInfo(SPI_GETKEYBOARDPREF, 0, &g_fExtraKeyboardHelp, 0);
   s_asPrev.fExtraKeyboardHelp = g_fExtraKeyboardHelp;

   // Sound Property page
   g_ss.cbSize = sizeof(g_ss);
   AccessSystemParametersInfo(SPI_GETSOUNDSENTRY, sizeof(g_ss), &g_ss, 0);
   s_asPrev.ss = g_ss;

   SystemParametersInfo(SPI_GETSHOWSOUNDS, 0, &g_fShowSounds, 0);

   // BUG, BUG GetSystemMetrics() is not updating value on reboot :a-anilk
   // g_fShowSounds = GetSystemMetrics(SM_SHOWSOUNDS);
   s_asPrev.fShowSounds = g_fShowSounds;

   // Display Property page
   g_hc.cbSize = sizeof(g_hc);
   AccessSystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(g_hc), &g_hc, 0);

   // Currently NT will not store these flags.  We fake them so we
   // can tell if they actually changed.

   s_asPrev.hc.lpszDefaultScheme = s_asPrev.szDefaultScheme;
   CopyHighContrast(&s_asPrev.hc, &g_hc);

   SystemParametersInfo(SPI_GETCARETWIDTH, 0, (PVOID)&g_cs.dwCaretWidth, 0);
   g_cs.dwCaretBlinkRate = RegQueryStrDW(
								 DEFAULT_BLINK_RATE
							   , HKEY_CURRENT_USER
							   , CONTROL_PANEL_DESKTOP
							   , CURSOR_BLINK_RATE);
   if (g_cs.dwCaretBlinkRate == BLINK_OFF)
       g_cs.dwCaretBlinkRate = CURSORMAX;
   s_asPrev.cs.dwCaretBlinkRate = g_cs.dwCaretBlinkRate;
   s_asPrev.cs.dwCaretWidth = g_cs.dwCaretWidth;

   // Mouse Property page
   g_mk.cbSize = sizeof(g_mk);
   AccessSystemParametersInfo(SPI_GETMOUSEKEYS, sizeof(g_mk), &g_mk, 0);
   s_asPrev.mk = g_mk;

   // General Property page
   g_ato.cbSize = sizeof(g_ato);
   AccessSystemParametersInfo(SPI_GETACCESSTIMEOUT, sizeof(g_ato), &g_ato, 0);
   s_asPrev.ato = g_ato;

   g_serk.cbSize = sizeof(g_serk);
   g_serk.lpszActivePort = g_szActivePort;
   g_serk.lpszPort = g_szPort;
   AccessSystemParametersInfo(SPI_GETSERIALKEYS, sizeof(g_serk), &g_serk, 0);

   s_asPrev.serk.lpszActivePort = s_asPrev.szActivePort;
   s_asPrev.serk.lpszPort = s_asPrev.szPort;
   CopySerialKeys(&s_asPrev.serk, &g_serk);

   if (NULL == s_asOrg.hc.lpszDefaultScheme)
   {
      // s_asOrg has not yet been initialized
      s_asOrg = s_asPrev;
      s_asOrg.hc.lpszDefaultScheme = s_asOrg.szDefaultScheme;
      s_asOrg.serk.lpszActivePort = s_asOrg.szActivePort;
      s_asOrg.serk.lpszPort = s_asOrg.szPort;
   }
}


//////////////////////////////////////////////////////////////////////////

//a-anilk: Change, Admin options, Keyboard flags: 05/06/99
void WINAPI SetAccessibilitySettings (void) {
   HKEY hkey;
   DWORD dwDisposition;
   UINT fWinIni = SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE;
   BOOL fAnyNotifyChange = FALSE;

   g_SPISetValue = TRUE;

   SetCursor(LoadCursor(NULL, IDC_WAIT));

   if (g_fShowWarnMsgOnFeatureActivate) {
      g_hc.dwFlags |= HCF_CONFIRMHOTKEY;
      g_fk.dwFlags |= FKF_CONFIRMHOTKEY;
      g_sk.dwFlags |= SKF_CONFIRMHOTKEY;
      g_mk.dwFlags |= MKF_CONFIRMHOTKEY;
      g_tk.dwFlags |= TKF_CONFIRMHOTKEY;
   } else {
      g_hc.dwFlags &= ~HCF_CONFIRMHOTKEY;
      g_fk.dwFlags &= ~FKF_CONFIRMHOTKEY;
      g_sk.dwFlags &= ~SKF_CONFIRMHOTKEY;
      g_mk.dwFlags &= ~MKF_CONFIRMHOTKEY;
      g_tk.dwFlags &= ~TKF_CONFIRMHOTKEY;
   }

   if (g_fPlaySndOnFeatureActivate) {
      g_hc.dwFlags  |= HCF_HOTKEYSOUND;
      g_fk.dwFlags  |= FKF_HOTKEYSOUND;
      g_sk.dwFlags  |= SKF_HOTKEYSOUND;
      g_mk.dwFlags  |= MKF_HOTKEYSOUND;
      g_tk.dwFlags  |= TKF_HOTKEYSOUND;
      g_ato.dwFlags |= ATF_ONOFFFEEDBACK;
   } else {
      g_hc.dwFlags  &= ~HCF_HOTKEYSOUND;
      g_fk.dwFlags  &= ~FKF_HOTKEYSOUND;
      g_sk.dwFlags  &= ~SKF_HOTKEYSOUND;
      g_mk.dwFlags  &= ~MKF_HOTKEYSOUND;
      g_tk.dwFlags  &= ~TKF_HOTKEYSOUND;
      g_ato.dwFlags &= ~ATF_ONOFFFEEDBACK;
   }


   // Keyboard property page

   if (0 != memcmp(&g_sk, &s_asPrev.sk, sizeof(g_sk)))
   {
      if (g_fWinNT)
      {
         g_sk.dwFlags &= SKF_VALID;
      }
      AccessSystemParametersInfo(SPI_SETSTICKYKEYS, sizeof(g_sk), &g_sk, fWinIni);
      s_asPrev.sk = g_sk;
      fAnyNotifyChange = TRUE;
   }

	if (g_bFKOn)
		g_fk.dwFlags |= FKF_FILTERKEYSON;
	else
		g_fk.dwFlags &= ~FKF_FILTERKEYSON;

	g_dwOrigFKFlags = g_fk.dwFlags;

   if (0 != memcmp(&g_fk, &s_asPrev.fk, sizeof(g_fk)))
   {
      if (g_fWinNT)
      {
         g_fk.dwFlags &= FKF_VALID;
      }

      // g_dwLastBounceKeySetting, g_nLastRepeatDelay, g_nLastRepeatRate
      // and g_nLastWait are part of FilterKeys

      if (0 != g_fk.iBounceMSec) {
         // Bounce keys enabeled
         g_fk.iDelayMSec = 0;
         g_fk.iRepeatMSec = 0;
         g_fk.iWaitMSec = 0;

         g_dwLastBounceKeySetting = g_fk.iBounceMSec;
      }
      else
      {
         g_nLastWait = g_fk.iWaitMSec;
         if (0 != g_fk.iDelayMSec)
         {
            // Slow key enabled
            g_nLastRepeatDelay = g_fk.iDelayMSec;
            g_nLastRepeatRate = g_fk.iRepeatMSec;
         }
         else
         {
            // neither Bounce or Slow
            g_fk.iRepeatMSec = 0;
         }
      }

      AccessSystemParametersInfo(SPI_SETFILTERKEYS, sizeof(g_fk), &g_fk, fWinIni);
      s_asPrev.fk = g_fk;

      fAnyNotifyChange = TRUE;
   }

   // always save these
   RegSetInt(HKEY_CURRENT_USER, FILTER_KEY, LAST_BOUNCE_SETTING, g_dwLastBounceKeySetting);
   RegSetInt(HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_DELAY, g_nLastRepeatDelay);
   RegSetInt(HKEY_CURRENT_USER, FILTER_KEY, LAST_REPEAT_RATE, g_nLastRepeatRate);
   RegSetInt(HKEY_CURRENT_USER, FILTER_KEY, LAST_WAIT, g_nLastWait);

   if (0 != memcmp(&g_tk, &s_asPrev.tk, sizeof(g_tk)))
   {
      if (g_fWinNT)
      {
         g_tk.dwFlags &= TKF_VALID;
      }
      AccessSystemParametersInfo(SPI_SETTOGGLEKEYS, sizeof(g_tk), &g_tk, fWinIni);
      s_asPrev.tk = g_tk;
      fAnyNotifyChange = TRUE;
   }

   if (g_fExtraKeyboardHelp != s_asPrev.fExtraKeyboardHelp)
   {
	   // Set this too. Some controls check this flag...0x100B
      AccessSystemParametersInfo(SPI_SETKEYBOARDCUES, 0, IntToPtr(g_fExtraKeyboardHelp), fWinIni);

      AccessSystemParametersInfo(SPI_SETKEYBOARDPREF, g_fExtraKeyboardHelp, 0, fWinIni);
      s_asPrev.fExtraKeyboardHelp = g_fExtraKeyboardHelp;
      fAnyNotifyChange = TRUE;
   }

   // Display Property page

   if (!IsHighContrastEqual(&g_hc, &s_asPrev.hc))
   {
      AccessSystemParametersInfo(SPI_SETHIGHCONTRAST, sizeof(g_hc), &g_hc, fWinIni);
      if (ERROR_SUCCESS == RegCreateKeyEx(
         HKEY_CURRENT_USER,
         HC_KEY,
         0,
         __TEXT(""),
         REG_OPTION_NON_VOLATILE,
         KEY_SET_VALUE,
         NULL,
         &hkey,
         &dwDisposition))
      {
         RegSetValueEx(hkey, HIGHCONTRAST_SCHEME, 0, REG_SZ, (PBYTE) g_hc.lpszDefaultScheme,
            (lstrlen(g_hc.lpszDefaultScheme) + 1) * sizeof(*g_hc.lpszDefaultScheme));
         RegSetValueEx(hkey, VOLATILE_SCHEME, 0, REG_SZ, (PBYTE) g_hc.lpszDefaultScheme,
            (lstrlen(g_hc.lpszDefaultScheme) + 1) * sizeof(*g_hc.lpszDefaultScheme));
         RegCloseKey(hkey);
         hkey = NULL;
      }
      CopyHighContrast(&s_asPrev.hc, &g_hc);
      fAnyNotifyChange = TRUE;
   }

   if (g_cs.dwCaretBlinkRate != s_asPrev.cs.dwCaretBlinkRate)
   {
       DWORD dwCaretBlinkRate = (g_cs.dwCaretBlinkRate < CURSORMAX)?g_cs.dwCaretBlinkRate:BLINK_OFF;

	   // Set the blink rate for this session
       SetCaretBlinkTime(dwCaretBlinkRate);

	   // and persist it to the registry
	   RegSetStrDW(HKEY_CURRENT_USER, CONTROL_PANEL_DESKTOP, CURSOR_BLINK_RATE, dwCaretBlinkRate);
   }

   if (g_cs.dwCaretWidth != s_asPrev.cs.dwCaretWidth)
       AccessSystemParametersInfo(SPI_SETCARETWIDTH, 0, IntToPtr(g_cs.dwCaretWidth), fWinIni);

   s_asPrev.cs = g_cs;

   // Mouse Property page
   if (0 != memcmp(&g_mk, &s_asPrev.mk, sizeof(g_mk)))
   {
      if (g_fWinNT)
      {
         g_mk.dwFlags &= MKF_VALID;
      }
      AccessSystemParametersInfo(SPI_SETMOUSEKEYS, sizeof(g_mk), &g_mk, fWinIni);
      s_asPrev.mk = g_mk;
      fAnyNotifyChange = TRUE;
   }

   // General Property page
   if (g_fPlaySndOnFeatureActivate) {
      g_ato.dwFlags |= ATF_ONOFFFEEDBACK;
   } else {
      g_ato.dwFlags &= ~ATF_ONOFFFEEDBACK;
   }

   if (0 != memcmp(&g_ato, &s_asPrev.ato, sizeof(g_ato)))
   {
      if (g_fWinNT)
      {
         g_ato.dwFlags &= ATF_VALID;
      }
      AccessSystemParametersInfo(SPI_SETACCESSTIMEOUT, sizeof(g_ato), &g_ato, fWinIni);
      s_asPrev.ato = g_ato;
      fAnyNotifyChange = TRUE;
   }

   if (!IsSerialKeysEqual(&g_serk, &s_asPrev.serk))
   {
      AccessSystemParametersInfo(SPI_SETSERIALKEYS, sizeof(g_serk), &g_serk, fWinIni);
      CopySerialKeys(&s_asPrev.serk, &g_serk);
      fAnyNotifyChange = TRUE;
   }

   if (g_fSaveSettings) {
      if (RegCreateKeyEx(HKEY_CURRENT_USER, GENERAL_KEY, 0, __TEXT(""), REG_OPTION_NON_VOLATILE,
         KEY_SET_VALUE, NULL, &hkey, &dwDisposition) == ERROR_SUCCESS) {

         // Save the Warning Sounds entry
          if (g_fShowWarnMsgOnFeatureActivate != s_asPrev.fShowWarnMsgOnFeatureActivate)
          {
               RegSetValueEx(hkey, WARNING_SOUNDS, 0, REG_DWORD, (PBYTE) &g_fShowWarnMsgOnFeatureActivate,
                  sizeof(g_fShowWarnMsgOnFeatureActivate));
               s_asPrev.fShowWarnMsgOnFeatureActivate = g_fShowWarnMsgOnFeatureActivate;
          }

         // Save the Sound On Activation entry
          if (g_fPlaySndOnFeatureActivate != s_asPrev.fPlaySndOnFeatureActivate)
          {
              RegSetValueEx(hkey, SOUND_ON_ACTIVATION, 0, REG_DWORD, (PBYTE) &g_fPlaySndOnFeatureActivate,
                sizeof(g_fPlaySndOnFeatureActivate));
              s_asPrev.fPlaySndOnFeatureActivate = g_fPlaySndOnFeatureActivate;
          }
         RegCloseKey(hkey);
         hkey = NULL;
      }
   }

   // Sound Property page
   if (0 != memcmp(&g_ss, &s_asPrev.ss, sizeof(g_ss)))
   {
      if (g_fWinNT)
      {
         g_ss.dwFlags &= SSF_VALID;
      }
      AccessSystemParametersInfo(SPI_SETSOUNDSENTRY, sizeof(g_ss), &g_ss, fWinIni);
      s_asPrev.ss = g_ss;
      fAnyNotifyChange = TRUE;
   }


   // We do the sound property page last because the SPI_SETSHOWSOUNDS call is used
   // to send out notifications.  We make this call if either g_fShowSounds changed
   // or we need to send out notifications
   // Changed Nov.18 '98 to send out WM_SETTINGSCHANGE Seperately.

   if (g_fShowSounds != s_asPrev.fShowSounds /*||
      (fAnyNotifyChange && g_fSaveSettings)*/)
   {
      // if (g_fSaveSettings) fWinIni |= SPIF_SENDWININICHANGE;

      AccessSystemParametersInfo(SPI_SETSHOWSOUNDS, g_fShowSounds, NULL, fWinIni);
      s_asPrev.fShowSounds = g_fShowSounds;
   }

   g_SPISetValue = FALSE;

   // Do Admin options
   SaveDefaultSettings(g_fCopyToLogon, g_fCopyToDefault);

   SetCursor(LoadCursor(NULL, IDC_ARROW));
}


//////////////////////////////////////////////////////////////////////////


INT_PTR WINAPI KeyboardDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR WINAPI SoundDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR WINAPI GeneralDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR WINAPI DisplayDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR WINAPI MouseDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#define MAX_PAGES 10


// ************************************************************************
// OpenAccessPropertySheet
// Opens property sheet
// ************************************************************************

BOOL OpenAccessPropertySheet (HWND hwnd, int nID) {
   HPROPSHEETPAGE rPages[MAX_PAGES];
   PROPSHEETPAGE psp;
   PROPSHEETHEADER psh;
   INT_PTR nPsRet;

   KillAccStat();
   GetAccessibilitySettings();

   // Simple errorchecking - only allow control to move to tabs 0-4.
   // Any tab request greater than 4 is invalid - so default to tab 0
   if ((nID < 0) || (nID > 4)) nID = 0;

   // Initialize the property sheets
   psh.dwSize = sizeof(psh);
   // SteveDon 5-26-98
   // no longer use PSH_PROPTITLE because we want it to read "Accessibility Options"
   // rather than "Accessibility Properties" or "Properties for Accessibility"
   psh.dwFlags = 0;     // psh.dwFlags = PSH_PROPTITLE; // | PSH_PROPSHEETPAGE | PSP_USEICONID;
   psh.hwndParent = hwnd;
   psh.hInstance = g_hinst;
   psh.pszCaption = MAKEINTRESOURCE(IDS_PROPERTY_TITLE); //ACCESSIBILITY);
   psh.pszIcon = MAKEINTRESOURCE(IDI_ACCESS);
   psh.nPages = 0;
   psh.nStartPage = 0;
   psh.phpage = rPages;

   // Add First Sheet, keyboard
   psp.dwSize = sizeof(psp);
   psp.dwFlags = PSP_DEFAULT;
   psp.hInstance = g_hinst;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_KEYBOARD);
   psp.pfnDlgProc = KeyboardDlg;
   psp.lParam = 0;

   psh.phpage[psh.nPages] = CreatePropertySheetPage(&psp);
   if (psh.phpage[psh.nPages]) psh.nPages++;

   // Add second sheet, Sound
   psp.dwSize = sizeof(psp);
   psp.dwFlags = PSP_DEFAULT;
   psp.hInstance = g_hinst;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_SOUND);
   psp.pfnDlgProc = SoundDlg;
   psp.lParam = 0;

   psh.phpage[psh.nPages] = CreatePropertySheetPage(&psp);
   if (psh.phpage[psh.nPages]) psh.nPages++;

   // Add third sheet, Display
   psp.dwSize = sizeof(psp);
   psp.dwFlags = PSP_DEFAULT;
   psp.hInstance = g_hinst;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_DISPLAY);
   psp.pfnDlgProc = DisplayDlg;
   psp.lParam = 0;

   psh.phpage[psh.nPages] = CreatePropertySheetPage(&psp);
   if (psh.phpage[psh.nPages]) psh.nPages++;

   // Add fourth sheet, Mouse
   psp.dwSize = sizeof(psp);
   psp.dwFlags = PSP_DEFAULT;
   psp.hInstance = g_hinst;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_MOUSE);
   psp.pfnDlgProc = MouseDlg;
   psp.lParam = 0;

   psh.phpage[psh.nPages] = CreatePropertySheetPage(&psp);
   if (psh.phpage[psh.nPages]) psh.nPages++;

   // Add fifth sheet, General
   psp.dwSize = sizeof(psp);
   psp.dwFlags = PSP_DEFAULT;
   psp.hInstance = g_hinst;
   psp.pszTemplate = MAKEINTRESOURCE(IDD_GENERAL);
   psp.pfnDlgProc = GeneralDlg;
   psp.lParam = 0;

   psh.phpage[psh.nPages] = CreatePropertySheetPage(&psp);
   if (psh.phpage[psh.nPages]) psh.nPages++;

   // Simple errorchecking - only allow control to move to tabs 0 to psh.nPages
   // Any tab request greater than psh.nPages is invalid
   if (0 <= nID && nID < (int)psh.nPages)
   {
      psh.nStartPage = nID;
   }

   nPsRet = PropertySheet(&psh);

   if ( nPsRet <= 0 )
       return FALSE;
   else
       return TRUE;
}

///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\swoosh\swoosh.cpp ===
#include	"Swoosh.h"
#include	"Resource.h"
#include	<commdlg.h>
#include	<commctrl.h>

#define	SAFE_RELEASE(p) if(p){(p)->Release();(p)=NULL;};

struct	SimpleVertex
{
	D3DXVECTOR3	pos;
	D3DCOLOR	colour;
	float		u,v;
};
#define	FVF_SimpleVertex	(D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)

#define	PARTICLES_PER_VB	256

typedef	unsigned char UBYTE;

CSwoosh	g_Swoosh;	

const float	pi = 3.1415926536f;
const float	pi2 = pi * 2.0f;

const float	TUBE_LENGTH = 20.0f;
const float	TUBE_RADIUS = 5.0f;
const float	FALLOFF_FACTOR = (255.0f/((TUBE_LENGTH*TUBE_LENGTH)+(TUBE_RADIUS*TUBE_RADIUS)))*0.98f;

const float	MAX_FLOW_RATE = 8.0f;
const float MAX_ROLL_RATE = 4.0f;
const float MAX_YAW_RATE = 5.0f;
const float MIN_PARTICLE_SIZE = 0.01f;
const float MAX_PARTICLE_SIZE = 0.5f;

//**********************************************************************************
int WINAPI	WinMain( HINSTANCE hInstance , HINSTANCE , LPSTR lpCmdLine , int )
{
	if ( FAILED(g_Swoosh.Create( hInstance )) )
		return -1;

	return	g_Swoosh.Run();
}

//**********************************************************************************
CSwoosh::CSwoosh()
{
	D3DXMatrixLookAtLH( &m_Camera , &D3DXVECTOR3(0,0,0) , &D3DXVECTOR3(0,0,1) ,
						&D3DXVECTOR3(0,1,0) );
	m_fCameraYaw = m_fCameraRoll = 0;
	m_fYawDirection = 0;
	m_fYawPause = 6.0f;

	m_fParticleSize = 0.15f;
	m_dwNumParticles = MAX_PARTICLES;
	m_dwColourMix = 0x2000;
	m_dwColour1 = 0xffffff;
	m_dwColour2 = 0x0000ff;
	m_fFlowRate = 4.0f;
	m_fRollRate = 1.0f;
	m_fYawRate = 1.0f;
	m_dwFixedColour1 = 0xffffff;
	m_dwFixedColour2 = 0x1111ff;
}

//**********************************************************************************
HRESULT	CSwoosh::Create( HINSTANCE hInstance )
{
	// Do base class Create
	HRESULT	rc = CD3DScreensaver::Create( hInstance );
	if ( FAILED(rc) )
		return rc;

	// Initialise particles
	InitParticles();

	return S_OK;
}

//**********************************************************************************
CSwoosh::DeviceObjects::DeviceObjects()
{
	pBlobTexture = NULL;
}

//**********************************************************************************
HRESULT CSwoosh::RegisterSoftwareDevice()
{ 
    m_pD3D->RegisterSoftwareDevice( D3D8RGBRasterizer );

    return S_OK; 
}


//**********************************************************************************
void	CSwoosh::InitParticles()
{
	// Initialise particles, by evenly distributing them in a cylinder along the
	// z-axis [-30,30] with radius 3.0. Choose colours based on colour settings

	Particle*	pparticle = m_Particles;
	for ( int i = 0 ; i < MAX_PARTICLES ; i++ )
	{
		// Pick z position for particle, evenly distribute in range [-TUBE_LENGTH,TUBE_LENGTH]
		pparticle->pos.z = (float(rand()&0x7fff) * (TUBE_LENGTH*2.0f/32767.0f)) - TUBE_LENGTH;

		// Pick (x,y) position for particle. We evenly distribute in a circle radius 3.0f
		float	rad = (float(rand()&0x7fff) * (1.0f/32767.0f));
		rad = sqrtf(rad);
		rad *= TUBE_RADIUS;
		float	angle = float(rand()&0x7fff) * (pi2/32767.0f);
		pparticle->pos.x = rad * sinf(angle);
		pparticle->pos.y = rad * cosf(angle);

		// Pick colour for particle. It's one of the two colour sets. Each colour set is
		// either one particular colour, or random (denoted by 0xffffffff)
		if ( DWORD(rand()&0x3fff) > m_dwColourMix )
		{
			if ( m_dwColour1 != 0xffffffff )
				pparticle->colour = m_dwColour1;
			else
				pparticle->colour = (rand()&0xff)|((rand()&0xff)<<8)|((rand()&0xff)<<16);
		}
		else
		{
			if ( m_dwColour2 != 0xffffffff )
				pparticle->colour = m_dwColour2;
			else
				pparticle->colour = (rand()&0xff)|((rand()&0xff)<<8)|((rand()&0xff)<<16);
		}

		pparticle++;
	}
}

//**********************************************************************************
void    CSwoosh::SetDevice( UINT iDevice )
{
	// Point at the correct set of device data
	m_pDeviceObjects = &m_DeviceObjects[iDevice];

	// Figure out if vertices for this device should be software VP or not
	if ( m_RenderUnits[iDevice].dwBehavior & D3DCREATE_HARDWARE_VERTEXPROCESSING )
		m_dwVertMemType = 0;
	else
		m_dwVertMemType = D3DUSAGE_SOFTWAREPROCESSING;
}

//**********************************************************************************
HRESULT CSwoosh::RestoreDeviceObjects()
{
	HRESULT	rc;

	// Create "blob" texture
	rc = D3DXCreateTextureFromResource( m_pd3dDevice , NULL , MAKEINTRESOURCE(IDB_BLOB) ,
										&m_pDeviceObjects->pBlobTexture );
	if ( FAILED(rc) )
		return rc;

	// Create vertex buffer to hold particles
	rc = m_pd3dDevice->CreateVertexBuffer( sizeof(SimpleVertex)*4*PARTICLES_PER_VB ,
										   D3DUSAGE_DYNAMIC|D3DUSAGE_WRITEONLY|m_dwVertMemType ,
										   FVF_SimpleVertex , D3DPOOL_DEFAULT ,
										   &m_pDeviceObjects->pParticleVB );
	if ( FAILED(rc) )
		return rc;

	// Create index buffer to hold particle indices
	rc = m_pd3dDevice->CreateIndexBuffer( sizeof(WORD)*6*PARTICLES_PER_VB ,
										  D3DUSAGE_WRITEONLY|m_dwVertMemType ,
										  D3DFMT_INDEX16 , D3DPOOL_DEFAULT ,
										  &m_pDeviceObjects->pParticleIB );
	if ( FAILED(rc) )
		return rc;

	// Populate index buffer with indices for a series of disjoint quads
	WORD*	pidx;
	m_pDeviceObjects->pParticleIB->Lock( 0 , sizeof(WORD)*6*PARTICLES_PER_VB , (BYTE**)&pidx ,
										 D3DLOCK_NOSYSLOCK );
	WORD	index = 0;
	for ( int i = 0 ; i < PARTICLES_PER_VB ; i++ )
	{
		*pidx++ = index; *pidx++ = index+1; *pidx++ = index+3;
		*pidx++ = index; *pidx++ = index+3; *pidx++ = index+2;
		index += 4;
	}
	m_pDeviceObjects->pParticleIB->Unlock();

	// Set up world and view matrices
	D3DXMATRIX	world;
	D3DXMatrixIdentity( &world );
	m_pd3dDevice->SetTransform( D3DTS_WORLDMATRIX(0) , &world );
	m_pd3dDevice->SetTransform( D3DTS_VIEW , &m_Camera );

	// Set alpha blending mode to SRCALPHA:ONE
	m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE , TRUE );
	m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND , D3DBLEND_SRCALPHA );
	m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND , D3DBLEND_ONE );

	// Set pixel pipe to single texture modulated by diffuse colour
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLOROP , D3DTOP_MODULATE );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG1 , D3DTA_TEXTURE );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG2 , D3DTA_DIFFUSE );
	m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_COLOROP , D3DTOP_DISABLE );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ALPHAOP , D3DTOP_SELECTARG2 );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ALPHAARG1 , D3DTA_TEXTURE );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ALPHAARG2 , D3DTA_DIFFUSE );
	m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_ALPHAOP , D3DTOP_DISABLE );

	// Bind "blob" texture to stage 0, and set filter mode to bilinear
	m_pd3dDevice->SetTexture( 0 , m_pDeviceObjects->pBlobTexture );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MAGFILTER , D3DTEXF_LINEAR );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MINFILTER , D3DTEXF_LINEAR );
	m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MIPFILTER , D3DTEXF_POINT );

	// Disable culling, lighting, and specular
	m_pd3dDevice->SetRenderState( D3DRS_CULLMODE , D3DCULL_NONE );
	m_pd3dDevice->SetRenderState( D3DRS_LIGHTING , FALSE );
	m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE , FALSE );

	// Set vertex shader to fixed-function pipeline for SimpleVertex
	m_pd3dDevice->SetVertexShader( FVF_SimpleVertex );

	// Bind vertex stream 0 and index source to the particle VB/IB
	m_pd3dDevice->SetStreamSource( 0 , m_pDeviceObjects->pParticleVB , sizeof(SimpleVertex) );
	m_pd3dDevice->SetIndices( m_pDeviceObjects->pParticleIB , 0 );

	return S_OK;
}

//**********************************************************************************
HRESULT CSwoosh::InvalidateDeviceObjects()
{
	SAFE_RELEASE(m_pDeviceObjects->pParticleVB);
	SAFE_RELEASE(m_pDeviceObjects->pParticleIB);
	SAFE_RELEASE(m_pDeviceObjects->pBlobTexture);

	return S_OK;
}

//**********************************************************************************
HRESULT CSwoosh::FrameMove()
{
	UpdateParticles();
	UpdateCamera();
	return S_OK;
}

//**********************************************************************************
void	CSwoosh::UpdateCamera()
{
	// Adjust camera roll
	m_fCameraRoll += m_fElapsedTime * m_fRollRate;

	// Adjust camera yaw. If we're not yawing, then countdown pause timer
	if ( m_fYawDirection == 0.0f )
	{
		m_fYawPause -= m_fElapsedTime;
		if ( m_fYawPause <= 0.0f )
		{
			// Done pausing, so reset timer and pick yaw direction
			m_fYawPause = 6.0f;

			if ( m_fCameraYaw == 0.0f )
				m_fYawDirection = m_fYawRate;
			else
				m_fYawDirection = -m_fYawRate;
		}
	}
	else
	{
		// Yawing, so adjust yaw parameter
		m_fCameraYaw += m_fElapsedTime * m_fYawDirection;

		// If we've hit the end, stop yawing
		if ( m_fYawDirection == m_fYawRate )
		{
			if ( m_fCameraYaw >= pi )
			{
				m_fCameraYaw = pi;
				m_fYawDirection = 0.0f;
			}
		}
		else
		{
			if ( m_fCameraYaw <= 0.0f )
			{
				m_fCameraYaw = 0.0f;
				m_fYawDirection = 0.0f;
			}
		}
	}

	// Compute matrices for roll and yaw components of orientation
	// We smooth out the yaw via a cos to give a nice slow rolloff at each end
	D3DXMATRIX	roll,yaw;
	D3DXMatrixRotationZ( &roll , m_fCameraRoll );
	D3DXMatrixRotationY( &yaw , pi * 0.5f * (1.0f - cosf(m_fCameraYaw)) );
	D3DXMatrixLookAtLH( &m_Camera , &D3DXVECTOR3(0,0,0) , &D3DXVECTOR3(0,0,1) ,
						&D3DXVECTOR3(0,1,0) );

	// Compute final camera matrix
	m_Camera = m_Camera * yaw * roll;
}

//**********************************************************************************
void	CSwoosh::UpdateParticles()
{
	Particle*	pparticle = m_Particles;
	for ( DWORD i = 0 ; i < m_dwNumParticles ; i++ )
	{
		// Flow particle along cylinder
		pparticle->pos.z -= m_fElapsedTime * m_fFlowRate;

		// If we reached the end, warp to other end of cylinder
		if ( pparticle->pos.z < -TUBE_LENGTH )
			pparticle->pos.z += TUBE_LENGTH*2.0f;			

		// Compute particle distance to camera and scale alpha
		// value by distance (to give slight fade out)
		float	dist = (pparticle->pos.x * pparticle->pos.x) +
					   (pparticle->pos.y * pparticle->pos.y) +
					   (pparticle->pos.z * pparticle->pos.z);
		UBYTE	alpha = UBYTE(255.0f - (dist * FALLOFF_FACTOR));
		pparticle->colour |= (alpha<<24);

		pparticle++;
	}
}

//**********************************************************************************
HRESULT CSwoosh::Render()
{
	// Clear the buffer, and set up projection matrix for this device
	m_pd3dDevice->Clear( 0 , NULL , D3DCLEAR_TARGET , 0 , 1.0f , 0 );
	SetProjectionMatrix( 0.1f , 200.0f );

	// Set camera
	m_pd3dDevice->SetTransform( D3DTS_VIEW , &m_Camera );

	m_pd3dDevice->BeginScene();

	RenderParticles();

	m_pd3dDevice->EndScene();

	return S_OK;
}

//**********************************************************************************
void	CSwoosh::RenderParticles()
{
	DWORD		particles_left = m_dwNumParticles;
	Particle*	pparticle = m_Particles;

	// Compute offsets from particle center to make camera facing billboard
	// We cheat a little and use the same offsets for all the particles, orienting
	// them to be perpendicular to the view direction rather than to the view vector
	// to the particle centre. It's faster and the effect is close enough.
	D3DXVECTOR3	offset[4];
	D3DXVECTOR3	dx,dy;
	dx.x = m_Camera._11; dx.y = m_Camera._21; dx.z = m_Camera._31;
	dy.x = m_Camera._12; dy.y = m_Camera._22; dy.z = m_Camera._32;
	dx *= m_fParticleSize;
	dy *= m_fParticleSize;
	offset[0] = -dx+dy;
	offset[1] =  dx+dy;
	offset[2] = -dx-dy;
	offset[3] =  dx-dy;

	D3DXVECTOR3	look;
	look.x = m_Camera._13; look.y = m_Camera._23; look.z = m_Camera._33;

	DWORD			batch_size = 0;
	SimpleVertex*	pverts;
	m_pDeviceObjects->pParticleVB->Lock( 0 , 0 , (BYTE**)&pverts ,
										 D3DLOCK_DISCARD|D3DLOCK_NOSYSLOCK );
	for ( DWORD i = 0 ; i < m_dwNumParticles ; i++ , pparticle++ )
	{
		// Don't render if it's behind us
		if ( ((pparticle->pos.x*look.x) + (pparticle->pos.y*look.y) +
			  (pparticle->pos.z*look.z)) <= 0 )
			  continue;

		// Tack particle onto buffer
		pverts->pos = pparticle->pos + offset[0];
		pverts->colour = pparticle->colour;
		pverts->u = 0; pverts->v = 0;
		pverts++;
		pverts->pos = pparticle->pos + offset[1];
		pverts->colour = pparticle->colour;
		pverts->u = 1; pverts->v = 0;
		pverts++;
		pverts->pos = pparticle->pos + offset[2];
		pverts->colour = pparticle->colour;
		pverts->u = 0; pverts->v = 1;
		pverts++;
		pverts->pos = pparticle->pos + offset[3];
		pverts->colour = pparticle->colour;
		pverts->u = 1; pverts->v = 1;
		pverts++;

		// If we've hit the buffer max, then flush it
		if ( ++batch_size == PARTICLES_PER_VB )
		{
			m_pDeviceObjects->pParticleVB->Unlock();
			m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST , 0 , 4*PARTICLES_PER_VB ,
											   0 , 2*PARTICLES_PER_VB );
			m_pDeviceObjects->pParticleVB->Lock( 0 , 0 , (BYTE**)&pverts ,
												 D3DLOCK_DISCARD|D3DLOCK_NOSYSLOCK );
			batch_size = 0;
		}
	}

	// Flush last batch
	m_pDeviceObjects->pParticleVB->Unlock();
	if ( batch_size > 0 )
	{
		m_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST , 0 , 4*batch_size ,
											0 , 2*batch_size );
	}
}

//**********************************************************************************
void	CSwoosh::ReadSettings()
{
    HKEY hkey;
    DWORD dwType = REG_DWORD;
    DWORD dwLength = sizeof(DWORD);

// Couple of macros to reduce typing. We just want to check if the registry read was okay, if it wasn't
// then we set a default value, if it was then we check against valid boundaries. For floats we also make
// sure the float is finite (not NaN or +/-INF).
#define	DEFAULT_AND_BOUND(v,d,l,h) if (rc!=ERROR_SUCCESS){v=d;}else if(v<=l){v=l;}else if(v>h){v=h;};
#define	DEFAULT_AND_BOUND_FLOAT(v,d,l,h) if (rc!=ERROR_SUCCESS||!_finite(v)){v=d;}else if(v<l){v=l;}else if(v>h){v=h;};

	// Open our reg key
    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Swoosh"), 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
		LONG	rc;

		// Read NumParticles
        rc = RegQueryValueEx( hkey, TEXT("NumParticles"), NULL, &dwType, (BYTE*)&m_dwNumParticles, &dwLength);
		DEFAULT_AND_BOUND(m_dwNumParticles,MAX_PARTICLES/2,1,MAX_PARTICLES);

		// Read FlowRate (float, but we munge into DWORD datatype)
        rc = RegQueryValueEx( hkey, TEXT("fFlowRate"), NULL, &dwType, (BYTE*)&m_fFlowRate, &dwLength);
		DEFAULT_AND_BOUND_FLOAT(m_fFlowRate,4.0f,0,MAX_FLOW_RATE);

		// Read RollRate (float, but we munge into DWORD datatype)
        rc = RegQueryValueEx( hkey, TEXT("fRollRate"), NULL, &dwType, (BYTE*)&m_fRollRate, &dwLength);
		DEFAULT_AND_BOUND_FLOAT(m_fRollRate,1.0f,0,MAX_ROLL_RATE);

		// Read YawRate (float, but we munge into DWORD datatype)
        rc = RegQueryValueEx( hkey, TEXT("fYawRate"), NULL, &dwType, (BYTE*)&m_fYawRate, &dwLength);
		DEFAULT_AND_BOUND_FLOAT(m_fYawRate,1.0f,0,MAX_YAW_RATE);

		// Read ParticleSize (float, but we munge into DWORD datatype)
        rc = RegQueryValueEx( hkey, TEXT("fParticleSize"), NULL, &dwType, (BYTE*)&m_fParticleSize, &dwLength);
		DEFAULT_AND_BOUND_FLOAT(m_fParticleSize,0.15f,MIN_PARTICLE_SIZE,MAX_PARTICLE_SIZE);

		// Read ColourMix
        rc = RegQueryValueEx( hkey, TEXT("ColourMix"), NULL, &dwType, (BYTE*)&m_dwColourMix, &dwLength);
		DEFAULT_AND_BOUND(m_dwColourMix,0x2000,0,0x4000);

		// Read Colours
        rc = RegQueryValueEx( hkey, TEXT("Colour1"), NULL, &dwType, (BYTE*)&m_dwColour1, &dwLength);
		if ( rc != ERROR_SUCCESS )
			m_dwColour1 = 0xffffff;
		else if ( m_dwColour1 != 0xffffffff )
			m_dwColour1 &= 0x00ffffff;
        rc = RegQueryValueEx( hkey, TEXT("Colour2"), NULL, &dwType, (BYTE*)&m_dwColour2, &dwLength);
		if ( rc != ERROR_SUCCESS )
			m_dwColour2 = 0xffffffff;
		else if ( m_dwColour2 != 0xffffffff )
			m_dwColour2 &= 0x00ffffff;
        rc = RegQueryValueEx( hkey, TEXT("FixedColour1"), NULL, &dwType, (BYTE*)&m_dwFixedColour1, &dwLength);
		if ( rc != ERROR_SUCCESS )
			m_dwFixedColour1 = 0xffffff;
		else
			m_dwFixedColour1 &= 0x00ffffff;
        rc = RegQueryValueEx( hkey, TEXT("FixedColour2"), NULL, &dwType, (BYTE*)&m_dwFixedColour2, &dwLength);
		if ( rc != ERROR_SUCCESS )
			m_dwFixedColour2 = 0xffffff;
		else
			m_dwFixedColour2 &= 0x00ffffff;

		// Read settings for screen setup (multimon gubbins)
        ReadScreenSettings( hkey );

		// Done
        RegCloseKey( hkey );
    }
}

//**********************************************************************************
void	CSwoosh::WriteSettings()
{
    HKEY hkey;
    DWORD dwType = REG_DWORD;
    DWORD dwLength = sizeof(DWORD);

	// Open our reg key
    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Swoosh"), 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
		// Write out all the settings (we munge floats into DWORDs)
        RegSetValueEx( hkey, TEXT("NumParticles"), NULL, REG_DWORD, (BYTE*)&m_dwNumParticles, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("ColourMix"), NULL, REG_DWORD, (BYTE*)&m_dwColourMix, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("Colour1"), NULL, REG_DWORD, (BYTE*)&m_dwColour1, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("Colour2"), NULL, REG_DWORD, (BYTE*)&m_dwColour2, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("fFlowRate"), NULL, REG_DWORD, (BYTE*)&m_fFlowRate, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("fRollRate"), NULL, REG_DWORD, (BYTE*)&m_fRollRate, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("fYawRate"), NULL, REG_DWORD, (BYTE*)&m_fYawRate, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("fParticleSize"), NULL, REG_DWORD, (BYTE*)&m_fParticleSize, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FixedColour1"), NULL, REG_DWORD, (BYTE*)&m_dwFixedColour1, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FixedColour2"), NULL, REG_DWORD, (BYTE*)&m_dwFixedColour2, sizeof(DWORD) );

		// Write screen settings out (multimon gubbins)
        WriteScreenSettings( hkey );

		// Done
        RegCloseKey( hkey );
    }
}

//**********************************************************************************
void	CSwoosh::DoConfig()
{
	// Make sure we've got the common controls we need loaded
    InitCommonControls();

	// Do the dialog box
	DialogBox( m_hInstance , MAKEINTRESOURCE(IDD_SETTINGS) , NULL , ConfigDlgProcStub );
}

//**********************************************************************************
BOOL CALLBACK CSwoosh::ConfigDlgProcStub( HWND hDlg , UINT msg , WPARAM wParam , LPARAM lParam )
{
	return g_Swoosh.ConfigDlgProc( hDlg , msg , wParam , lParam );
}

//**********************************************************************************
BOOL	CSwoosh::ConfigDlgProc( HWND hDlg , UINT msg , WPARAM wParam , LPARAM lParam )
{
	HWND	hNumParticles = GetDlgItem( hDlg , IDC_NUM_PARTICLES );
	HWND	hColourMix = GetDlgItem( hDlg , IDC_COLOUR_MIX );
	HWND	hFlowRate = GetDlgItem( hDlg , IDC_FLOW_RATE );
	HWND	hRollRate = GetDlgItem( hDlg , IDC_ROLL_RATE );
	HWND	hYawRate = GetDlgItem( hDlg , IDC_YAW_RATE );
	HWND	hParticleSize = GetDlgItem( hDlg , IDC_PARTICLE_SIZE );

	switch ( msg )
	{
		case WM_INITDIALOG:
			// Set up ranges on the sliders. Map floats into integer range [0,10000]
			SendMessage( hNumParticles , TBM_SETRANGE , FALSE , MAKELONG(0,MAX_PARTICLES) );
			SendMessage( hColourMix , TBM_SETRANGE , FALSE , MAKELONG(0,0x4000) );
			SendMessage( hFlowRate , TBM_SETRANGE , FALSE , MAKELONG(0,10000) );
			SendMessage( hRollRate , TBM_SETRANGE , FALSE , MAKELONG(0,10000) );
			SendMessage( hYawRate , TBM_SETRANGE , FALSE , MAKELONG(0,10000) );
			SendMessage( hParticleSize , TBM_SETRANGE , FALSE , MAKELONG(0,10000) );

			// Set initial values on the sliders
			SendMessage( hNumParticles , TBM_SETPOS , TRUE , m_dwNumParticles );
			SendMessage( hColourMix , TBM_SETPOS , TRUE , m_dwColourMix );
			SendMessage( hFlowRate , TBM_SETPOS , TRUE , DWORD(m_fFlowRate * (10000.0f/MAX_FLOW_RATE)) );
			SendMessage( hRollRate , TBM_SETPOS , TRUE , DWORD(m_fRollRate * (10000.0f/MAX_ROLL_RATE)) );
			SendMessage( hYawRate , TBM_SETPOS , TRUE , DWORD(m_fYawRate * (10000.0f/MAX_YAW_RATE)) );
			SendMessage( hParticleSize , TBM_SETPOS , TRUE ,
						 DWORD((m_fParticleSize-MIN_PARTICLE_SIZE)*(10000.0f/(MAX_PARTICLE_SIZE-MIN_PARTICLE_SIZE))) );

			// Set up radio buttons for colour sets. Disable "pick.." button if multicoloured is selected
			if ( m_dwColour1 == 0xffffffff )
			{
				CheckRadioButton( hDlg , IDC_COLOUR1_MULTI , IDC_COLOUR1_FIXED , IDC_COLOUR1_MULTI );
				EnableWindow( GetDlgItem( hDlg , IDC_COLOUR1_PICK ) , FALSE );
			}
			else
				CheckRadioButton( hDlg , IDC_COLOUR1_MULTI , IDC_COLOUR1_FIXED , IDC_COLOUR1_FIXED );

			if ( m_dwColour2 == 0xffffffff )
			{
				CheckRadioButton( hDlg , IDC_COLOUR2_MULTI , IDC_COLOUR2_FIXED , IDC_COLOUR2_MULTI );
				EnableWindow( GetDlgItem( hDlg , IDC_COLOUR2_PICK ) , FALSE );
			}
			else
				CheckRadioButton( hDlg , IDC_COLOUR2_MULTI , IDC_COLOUR2_FIXED , IDC_COLOUR2_FIXED );

			return FALSE;

		case WM_COMMAND:
			switch ( LOWORD(wParam) )
			{
				case IDOK:
					ExtractDialogSettings( hDlg );
					WriteSettings();
					EndDialog( hDlg , IDOK );
					break;

				case IDCANCEL:
					EndDialog( hDlg , IDCANCEL );
					break;

				case IDC_SCREEN_SETTINGS:
					DoScreenSettingsDialog( hDlg );
					break;

				case IDC_COLOUR1_MULTI:
					EnableWindow( GetDlgItem( hDlg , IDC_COLOUR1_PICK ) , FALSE );
					break;

				case IDC_COLOUR2_MULTI:
					EnableWindow( GetDlgItem( hDlg , IDC_COLOUR2_PICK ) , FALSE );
					break;

				case IDC_COLOUR1_FIXED:
					EnableWindow( GetDlgItem( hDlg , IDC_COLOUR1_PICK ) , TRUE );
					break;

				case IDC_COLOUR2_FIXED:
					EnableWindow( GetDlgItem( hDlg , IDC_COLOUR2_PICK ) , TRUE );
					break;

				case IDC_COLOUR1_PICK:
					m_dwFixedColour1 = PickColour( hDlg , m_dwFixedColour1 );
					break;

				case IDC_COLOUR2_PICK:
					m_dwFixedColour2 = PickColour( hDlg , m_dwFixedColour2 );
					break;
			}
			return TRUE;

		default:
			return FALSE;
	}
}

//**********************************************************************************
DWORD	CSwoosh::PickColour( HWND hParent , DWORD defcolour )
{
	CHOOSECOLOR		choose;
	static COLORREF	custom[16];

	choose.lStructSize = sizeof(choose);
	choose.hwndOwner = hParent;
	choose.rgbResult = ((defcolour&0xff)<<16)|((defcolour&0xff00))|((defcolour&0xff0000)>>16);
	choose.lpCustColors = custom;
	choose.Flags = CC_ANYCOLOR|CC_FULLOPEN|CC_RGBINIT;

	if ( ChooseColor( &choose ) )
		return ((choose.rgbResult&0xff)<<16)|((choose.rgbResult&0xff00)|(choose.rgbResult&0xff0000)>>16);
	else
		return defcolour;
}

//**********************************************************************************
void	CSwoosh::ExtractDialogSettings( HWND hDlg )
{
	HWND	hNumParticles = GetDlgItem( hDlg , IDC_NUM_PARTICLES );
	HWND	hColourMix = GetDlgItem( hDlg , IDC_COLOUR_MIX );
	HWND	hFlowRate = GetDlgItem( hDlg , IDC_FLOW_RATE );
	HWND	hRollRate = GetDlgItem( hDlg , IDC_ROLL_RATE );
	HWND	hYawRate = GetDlgItem( hDlg , IDC_YAW_RATE );
	HWND	hParticleSize = GetDlgItem( hDlg , IDC_PARTICLE_SIZE );

	float	f;

	m_dwNumParticles = SendMessage( hNumParticles , TBM_GETPOS , 0 , 0 );
	m_dwColourMix = SendMessage( hColourMix , TBM_GETPOS , 0 , 0 );

	f = (float)SendMessage( hFlowRate , TBM_GETPOS , 0 , 0 );
	m_fFlowRate = f * (MAX_FLOW_RATE/10000.0f);

	f = (float)SendMessage( hRollRate , TBM_GETPOS , 0 , 0 );
	m_fRollRate = f * (MAX_ROLL_RATE/10000.0f);

	f = (float)SendMessage( hYawRate , TBM_GETPOS , 0 , 0 );
	m_fYawRate = f * (MAX_YAW_RATE/10000.0f);

	f = (float)SendMessage( hParticleSize , TBM_GETPOS , 0 , 0 );
	m_fParticleSize = (f * ((MAX_PARTICLE_SIZE-MIN_PARTICLE_SIZE)/10000.0f)) + MIN_PARTICLE_SIZE;

	if ( IsDlgButtonChecked( hDlg , IDC_COLOUR1_MULTI ) )
		m_dwColour1 = 0xffffffff;
	else
		m_dwColour1 = m_dwFixedColour1;

	if ( IsDlgButtonChecked( hDlg , IDC_COLOUR2_MULTI ) )
		m_dwColour2 = 0xffffffff;
	else
		m_dwColour2 = m_dwFixedColour2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\control\scrnsave\text3d\text3d.cpp ===
//-----------------------------------------------------------------------------
// File: Text3D.cpp
//
// Desc: Fun screen saver.
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <Windows.h>
#include <d3d8.h>
#include <d3dx8.h>
#include <d3dsaver.h>
#include <d3d8rgbrast.h>
#include <time.h>
#include <commdlg.h>
#include <commctrl.h>
#include "Text3D.h"
#include "Resource.h"
#include "dxutil.h"


CTextScreensaver* g_pMyTextScreensaver = NULL;



#define BUF_SIZE 255
TCHAR g_szSectName[BUF_SIZE];
TCHAR g_szFname[BUF_SIZE];


//-----------------------------------------------------------------------------
// Name: WinMain()
// Desc: Entry point to the program. Initializes everything, and goes into a
//       message-processing loop. Idle time is used to render the scene.
//-----------------------------------------------------------------------------
INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR, INT )
{
    HRESULT hr;
    CTextScreensaver textSS;

    if( FAILED( hr = textSS.Create( hInst ) ) )
    {
        textSS.DisplayErrorMsg( hr );
        return 0;
    }

    return textSS.Run();
}




//-----------------------------------------------------------------------------
// Name: LoadTextureFromResource()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT LoadTextureFromResource( LPDIRECT3DDEVICE8 pd3dDevice, 
    TCHAR* strRes, TCHAR* strResType, LPDIRECT3DTEXTURE8* ppTex )
{
    HRESULT hr;
    HMODULE hModule = NULL;
    HRSRC rsrc;
    HGLOBAL hgData;
    LPVOID pvData;
    DWORD cbData;

    rsrc = FindResource( hModule, strRes, strResType );
    if( rsrc != NULL )
    {
        cbData = SizeofResource( hModule, rsrc );
        if( cbData > 0 )
        {
            hgData = LoadResource( hModule, rsrc );
            if( hgData != NULL )
            {
                pvData = LockResource( hgData );
                if( pvData != NULL )
                {
                    if( FAILED( hr = D3DXCreateTextureFromFileInMemory( pd3dDevice, 
                        pvData, cbData, ppTex ) ) )
                    {
                        return hr;
                    }
                }
            }
        }
    }
    
    if( *ppTex == NULL)
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CTextScreensaver()
// Desc: Constructor
//-----------------------------------------------------------------------------
CTextScreensaver::CTextScreensaver()
{
    g_pMyTextScreensaver = this;

    LoadString( NULL, IDS_DESCRIPTION, m_strWindowTitle, 200 );
    InitCommonControls();
    
    ZeroMemory( m_DeviceObjects, sizeof(m_DeviceObjects) );
    m_hFont = NULL; 
    m_bUseDepthBuffer = TRUE;
    m_dwMinDepthBits = 16;
    m_floatrect.xSize = 0.0f;
    lstrcpy( m_strRegPath, TEXT("Software\\Microsoft\\Screensavers\\Text3D") );

    m_fAngleX = 0.0f;
    m_fAngleY = 0.0f;
    m_fAngleZ = 0.0f;

    m_dwMeshUpdateCounter = 0;

    srand((UINT)time(NULL)); // seed random number generator
}




//-----------------------------------------------------------------------------
// Name: RegisterSoftwareDevice()
// Desc: This can register the D3D8RGBRasterizer or any other
//       pluggable software rasterizer.
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::RegisterSoftwareDevice()
{ 
    m_pD3D->RegisterSoftwareDevice( D3D8RGBRasterizer );

    return S_OK; 
}


//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::FrameMove()
{
    DWORD   tick = GetTickCount();
    DWORD   elapsed = tick - m_dwLastTick;
    m_dwLastTick = tick;

    // update floatrect
    RECT rcBounceBounds;

    if( m_floatrect.xSize == 0.0f )
    {
        // Initialize floatrect
        RECT rcBounds;
        DWORD dwParentWidth;
        DWORD dwParentHeight;

        rcBounds = m_rcRenderTotal;

        dwParentWidth = rcBounds.right - rcBounds.left;
        dwParentHeight = rcBounds.bottom - rcBounds.top;

        FLOAT sizeFact;
        FLOAT sizeScale;
        DWORD size;

        sizeScale = m_dwSize / 10.0f;
        sizeFact = 0.25f + (0.75f * sizeScale);     // range 25-100%
        size = (DWORD) (sizeFact * ( dwParentWidth > dwParentHeight ? dwParentHeight : dwParentWidth ) );

        if( size > dwParentWidth )
            size = dwParentWidth;
        if( size > dwParentHeight )
            size = dwParentHeight;

        // Start floatrect centered on first RenderUnit's screen
        if( !m_bWindowed )
        {
            INT iMonitor = m_RenderUnits[0].iMonitor;
            rcBounds = m_Monitors[iMonitor].rcScreen;
        }
        m_floatrect.xMin = rcBounds.left + ((rcBounds.right - rcBounds.left) - size) / 2.0f;
        m_floatrect.yMin = rcBounds.top + ((rcBounds.bottom - rcBounds.top) - size) / 2.0f;
        m_floatrect.xSize = (FLOAT)size;
        m_floatrect.ySize = (FLOAT)size;

        m_floatrect.xVel = 0.01f * (FLOAT) size;
        if( rand() % 2 == 0 )
            m_floatrect.xVel = -m_floatrect.xVel;

        m_floatrect.yVel = 0.01f * (FLOAT) size;
        if( rand() % 2 == 0 )
            m_floatrect.yVel = -m_floatrect.yVel;
    }

    rcBounceBounds = m_rcRenderTotal;

    FLOAT xMinOld = m_floatrect.xMin;
    FLOAT yMinOld = m_floatrect.yMin;

    m_floatrect.xMin += m_floatrect.xVel * 20.0f * m_fElapsedTime;
    m_floatrect.yMin += m_floatrect.yVel * 20.0f * m_fElapsedTime;
    if( m_floatrect.xVel < 0 && m_floatrect.xMin < rcBounceBounds.left || 
        m_floatrect.xVel > 0 && (m_floatrect.xMin + m_floatrect.xSize) > rcBounceBounds.right )
    {
        m_floatrect.xMin = xMinOld; // undo last move
        m_floatrect.xVel = -m_floatrect.xVel; // change direction
    }
    if( m_floatrect.yVel < 0 && m_floatrect.yMin < rcBounceBounds.top || 
        m_floatrect.yVel > 0 && (m_floatrect.yMin + m_floatrect.ySize) > rcBounceBounds.bottom )
    {
        m_floatrect.yMin = yMinOld; // undo last move
        m_floatrect.yVel = -m_floatrect.yVel; // change direction
    }

    UpdateAngles( elapsed );

    if ( m_bDisplayTime )
    {
        if ( UpdateTimeString( m_szDisplayString ) )
        {
            m_dwMeshUpdateCounter++; // provoke a mesh update at render tiem
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::Render()
{
    D3DVIEWPORT8 vp;

    // First, clear the entire back buffer to the background color
    vp.X = 0;
    vp.Y = 0;
    vp.Width = m_rcRenderCurDevice.right - m_rcRenderCurDevice.left;
    vp.Height = m_rcRenderCurDevice.bottom - m_rcRenderCurDevice.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff000000, 1.0f, 0L );

    // Now determine what part of the floatrect, if any, intersects the current screen
    RECT rcFloatThisScreen;
    RECT rcFloatThisScreenClipped;

    rcFloatThisScreen.left = (INT)m_floatrect.xMin;
    rcFloatThisScreen.top = (INT)m_floatrect.yMin;
    rcFloatThisScreen.right = rcFloatThisScreen.left + (INT)m_floatrect.xSize;
    rcFloatThisScreen.bottom = rcFloatThisScreen.top + (INT)m_floatrect.ySize;

    if( !IntersectRect(&rcFloatThisScreenClipped, &rcFloatThisScreen, &m_rcRenderCurDevice) )
    {
        return S_OK; // no intersection, so nothing further to render on this screen
    }

    // Convert rcFloatThisScreen from screen to window coordinates
    OffsetRect(&rcFloatThisScreen, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);
    OffsetRect(&rcFloatThisScreenClipped, -m_rcRenderCurDevice.left, -m_rcRenderCurDevice.top);

    // Now set up the viewport to render to the clipped rect
    vp.X = rcFloatThisScreenClipped.left;
    vp.Y = rcFloatThisScreenClipped.top;
    vp.Width = rcFloatThisScreenClipped.right - rcFloatThisScreenClipped.left;
    vp.Height = rcFloatThisScreenClipped.bottom - rcFloatThisScreenClipped.top;
    vp.MinZ = 0.0f;
    vp.MaxZ = 1.0f;
    m_pd3dDevice->SetViewport( &vp );
//    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, 0xff0000ff, 1.0f, 0L );

    // Now set up the projection matrix to only render the onscreen part of the
    // rect to the viewport
    D3DXMATRIX matProj;
    FLOAT l,r,b,t;
    l = -0.8f;
    r =  0.8f;
    b =  0.8f;
    t = -0.8f;
    FLOAT cxUnclipped = (rcFloatThisScreen.right + rcFloatThisScreen.left) / 2.0f;
    FLOAT cyUnclipped = (rcFloatThisScreen.bottom + rcFloatThisScreen.top) / 2.0f;
    l *= (rcFloatThisScreenClipped.left - cxUnclipped) / (rcFloatThisScreen.left - cxUnclipped);
    r *= (rcFloatThisScreenClipped.right - cxUnclipped) / (rcFloatThisScreen.right - cxUnclipped);
    t *= (rcFloatThisScreenClipped.top - cyUnclipped) / (rcFloatThisScreen.top - cyUnclipped);
    b *= (rcFloatThisScreenClipped.bottom - cyUnclipped) / (rcFloatThisScreen.bottom - cyUnclipped);
    D3DXMatrixPerspectiveOffCenterLH( &matProj, l, r, t, b, 1.0f, 50.0f );
    m_pd3dDevice->SetTransform( D3DTS_PROJECTION , &matProj );

    // Mesh updates happen in Render() instead of FrameMove() since they
    // are per-device
    if( m_pDeviceObjects->m_dwMeshUpdateCounter != m_dwMeshUpdateCounter )
    {
        BuildTextMesh( m_szDisplayString );
        m_pDeviceObjects->m_dwMeshUpdateCounter = m_dwMeshUpdateCounter;
    }

    m_pd3dDevice->BeginScene();

    // Set world matrix
    D3DXMATRIX  rotx,roty,rotz,trans,trans2;
    D3DXMatrixTranslation( &trans , m_fTextOffsetX , m_fTextOffsetY , 0.25f );
    D3DXMatrixRotationX( &rotx , m_fAngleX );
    D3DXMatrixRotationY( &roty , m_fAngleY );
    D3DXMatrixRotationZ( &rotz , m_fAngleZ );
    D3DXMatrixTranslation( &trans2, 0, 0, 1.5f + (m_fTextMaxX - m_fTextMinX) );
    m_matWorld = trans * rotx * roty * rotz * trans2;
    m_pd3dDevice->SetTransform( D3DTS_WORLDMATRIX(0) , &m_matWorld );

    // Set other per-frame states
    SetPerFrameStates();

    // Draw mesh
    m_pDeviceObjects->m_pObject->DrawSubset( 0 );

    m_pd3dDevice->EndScene();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::RestoreDeviceObjects()
{
    HRESULT rc;

    // Set up sensible view matrix
    D3DXMatrixLookAtLH( &m_matView , &D3DXVECTOR3(0,0,0) , &D3DXVECTOR3(0,0,1) , &D3DXVECTOR3(0,1,0) );
    m_pd3dDevice->SetTransform( D3DTS_VIEW , &m_matView );

    // Set some basic renderstates
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZWRITEENABLE , D3DZB_TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ZFUNC , D3DCMP_LESSEQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_DITHERENABLE , TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE , m_bSpecular );

    // Create the GDI font object
    LONG    h = m_Font.lfHeight;
    m_Font.lfHeight = 100;
    m_hFont = CreateFontIndirect( &m_Font );
    m_Font.lfHeight = h;
    if ( m_hFont == NULL )
        return E_FAIL;

    // Initialise time string
    if ( m_bDisplayTime )
        UpdateTimeString( m_szDisplayString );

    // Make mesh for text string
    if ( FAILED(rc = BuildTextMesh( m_szDisplayString )) )
        return rc;

    // Update offsets for mesh
    m_fTextOffsetX = (m_fTextMinX + m_fTextMaxX) * -0.5f;
    m_fTextOffsetY = (m_fTextMinY + m_fTextMaxY) * -0.5f;

    // Load appropriate texture (if any)
    switch ( m_SurfType )
    {
        case color:
            m_pDeviceObjects->m_pTexture = NULL;
            break;

        case environment:
            if ( m_bUseCustomEnvironment )
            {
                m_pDeviceObjects->m_pTexture = CreateTextureFromFile( m_szCustomEnvironment );
            }
            if ( m_pDeviceObjects->m_pTexture == NULL )
            {
                LoadTextureFromResource( m_pd3dDevice, MAKEINTRESOURCE(IDB_SPHEREMAP), 
                    TEXT("JPG"), &m_pDeviceObjects->m_pTexture );
            }
            break;

        case texture:
            if ( m_bUseCustomTexture )
            {
                m_pDeviceObjects->m_pTexture = CreateTextureFromFile( m_szCustomTexture );
            }
            if ( m_pDeviceObjects->m_pTexture == NULL )
            {
                LoadTextureFromResource( m_pd3dDevice, MAKEINTRESOURCE(IDB_TEXTURE), 
                    TEXT("JPG"), &m_pDeviceObjects->m_pTexture );
            }
            break;

        default:
            return E_FAIL;
    }

    // Set per-frame states
    SetPerFrameStates();

    m_dwLastTick = GetTickCount();

    return S_OK;
}




//**********************************************************************************
VOID CTextScreensaver::SetPerFrameStates()
{
    m_pd3dDevice->SetTexture( 0 , m_pDeviceObjects->m_pTexture );

    // Set up texture pipeline
    if ( m_SurfType == color )
    {
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLOROP , D3DTOP_SELECTARG1 );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG1 , D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG2 , D3DTA_DIFFUSE );
    }
    else
    {
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLOROP , D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG1 , D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_COLORARG2 , D3DTA_DIFFUSE );
    }
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ALPHAOP , D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MAGFILTER , D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MINFILTER , D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_MIPFILTER , D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ADDRESSU , D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_ADDRESSV , D3DTADDRESS_WRAP );
    m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_COLOROP , D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1 , D3DTSS_ALPHAOP , D3DTOP_DISABLE );

    // Set up lighting
    m_pd3dDevice->SetRenderState( D3DRS_LIGHTING , TRUE );
    if ( !m_bSpecular )
        m_pd3dDevice->SetRenderState( D3DRS_AMBIENT , 0x646464 );
    else
        m_pd3dDevice->SetRenderState( D3DRS_AMBIENT , 0x464646 );
    D3DLIGHT8   light;
    light.Type = D3DLIGHT_DIRECTIONAL;
    light.Diffuse = D3DXCOLOR(1,1,1,0);
    light.Specular = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
    light.Ambient = D3DXCOLOR(0,0,0,0);
    light.Direction = D3DXVECTOR3(0.5,-0.5,1);
    light.Position = D3DXVECTOR3(0,0,0);
    light.Range = 10000;
    light.Falloff = light.Attenuation0 = light.Attenuation1 = light.Attenuation2 = 0;
    light.Phi = light.Theta = 0;
    m_pd3dDevice->SetLight( 0 , &light );
    m_pd3dDevice->LightEnable( 0 , TRUE );

    // Set up material
    D3DMATERIAL8    mat;
    if ( m_SurfType == color )
    {
        DWORD dwColor;
        if( m_bUseCustomColor )
            dwColor = m_SurfaceColor;
        else
            dwColor = 0x00777777;

        mat.Diffuse.r = FLOAT(dwColor&0xff)/255.0f;
        mat.Diffuse.g = FLOAT((dwColor>>8)&0xff)/255.0f;
        mat.Diffuse.b = FLOAT((dwColor>>16)&0xff)/255.0f;
    }
    else
    {
        mat.Diffuse = D3DXCOLOR(1,1,1,0);
    }
    mat.Ambient = mat.Diffuse;
    mat.Specular = D3DXCOLOR(1.0f,1.0f,1.0f,0);
    mat.Emissive = D3DXCOLOR(0,0,0,0);
    mat.Power = 5;
    m_pd3dDevice->SetMaterial( &mat );

    // Set up texture coordinate generation if we're environment mapping or just force to passthrough
    if ( m_SurfType == environment )
    {
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_TEXCOORDINDEX , D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_TEXTURETRANSFORMFLAGS , D3DTTFF_COUNT2 );

        D3DXMATRIX  envmat;
        D3DXMatrixIdentity( &envmat );

        envmat._11 = envmat._22 = 0.5f;
        envmat._31 = envmat._32 = 0.5f;
        m_pd3dDevice->SetTransform( D3DTS_TEXTURE0 , &envmat );
    }
    else
    {
        D3DXMATRIX matWorldView;
        D3DXMATRIX matWorldViewInv;

        matWorldView = m_matWorld * m_matView;
        D3DXMatrixInverse( &matWorldViewInv, NULL, &matWorldView );
        m_pd3dDevice->SetTransform( D3DTS_TEXTURE0, &matWorldViewInv );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_TEXCOORDINDEX , D3DTSS_TCI_CAMERASPACEPOSITION );
        m_pd3dDevice->SetTextureStageState( 0 , D3DTSS_TEXTURETRANSFORMFLAGS , D3DTTFF_COUNT2 );
    }

    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE , FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE , FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_SPECULARENABLE , m_bSpecular );
    m_pd3dDevice->SetRenderState( D3DRS_WRAP0 , D3DWRAP_U|D3DWRAP_V );
    m_pd3dDevice->SetRenderState( D3DRS_POINTSPRITEENABLE , FALSE );

    m_pd3dDevice->SetTexture( 0, m_pDeviceObjects->m_pTexture );
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::InvalidateDeviceObjects()
{
    SAFE_RELEASE(m_pDeviceObjects->m_pTexture);
    SAFE_RELEASE(m_pDeviceObjects->m_pObject);
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ConfirmDevice()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CTextScreensaver::ConfirmDevice(D3DCAPS8* pCaps, DWORD dwBehavior, 
                                        D3DFORMAT fmtBackBuffer)
{
    // Need D3DVTXPCAPS_TEXGEN for D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR
    if( ( ( dwBehavior & D3DCREATE_HARDWARE_VERTEXPROCESSING ) ||
          ( dwBehavior & D3DCREATE_MIXED_VERTEXPROCESSING ) ) &&
        ( pCaps->VertexProcessingCaps & D3DVTXPCAPS_TEXGEN ) == 0 )
    {
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetDevice()
// Desc: 
//-----------------------------------------------------------------------------
VOID CTextScreensaver::SetDevice( UINT iDevice )
{
    m_pDeviceObjects = &m_DeviceObjects[iDevice];
}




//***************************************************************************************
IDirect3DTexture8*  CTextScreensaver::CreateTextureFromFile( const TCHAR* filename )
{
    IDirect3DTexture8*  texture;
    if ( FAILED(D3DXCreateTextureFromFile( m_pd3dDevice , filename , &texture )) )
        return NULL;
    else
        return texture;
}




//***************************************************************************************
HRESULT CTextScreensaver::BuildTextMesh( const TCHAR* text )
{
    // Release any old text mesh we built
    SAFE_RELEASE(m_pDeviceObjects->m_pObject);

    // Create temporary DC and select the correct font into it
    HDC hdc = CreateDC( TEXT("DISPLAY") , NULL , NULL , NULL );
    SelectObject( hdc , m_hFont );

    TCHAR szText[MAX_DISPLAY_STRING+1];
    lstrcpyn( szText, text, MAX_DISPLAY_STRING+1 );

    // Build new mesh
    FLOAT               max_deviation = 5.0f / FLOAT(m_dwMeshQuality+10);
    GLYPHMETRICSFLOAT   metrics[MAX_DISPLAY_STRING+1];
    HRESULT             rc;
    rc = D3DXCreateText( m_pd3dDevice , hdc , szText , max_deviation, 0.5f , &m_pDeviceObjects->m_pObject , NULL, metrics );
    if( FAILED( rc ) )
    {
        // We might have failed because the string had no glyphs, so try 
        // the default text instead
        LoadString( NULL, IDS_DEFAULTTEXT, szText, MAX_DISPLAY_STRING );
        rc = D3DXCreateText( m_pd3dDevice , hdc , szText , max_deviation, 0.5f , &m_pDeviceObjects->m_pObject , NULL, metrics );
    }

    // Delete temporary DC
    DeleteDC( hdc );
    if ( FAILED(rc) )
        return rc;

    // Compute the bounding box for the mesh by stepping through the glyph metrics structures
    int len = lstrlen( szText );
    m_fTextMinX = 1000000;
    m_fTextMaxX = -1000000;
    m_fTextMinY = 1000000;
    m_fTextMaxY = -1000000;
    FLOAT   originx = 0;
    FLOAT   originy = 0;
    GLYPHMETRICSFLOAT*  pglyph = metrics;
    for ( int i = 0 ; i < len ; i++ , pglyph++ )
    {
        if ( (pglyph->gmfptGlyphOrigin.x + originx) < m_fTextMinX )
            m_fTextMinX = (pglyph->gmfptGlyphOrigin.x + originx);
        if ( (pglyph->gmfptGlyphOrigin.x + originx + pglyph->gmfBlackBoxX) > m_fTextMaxX )
            m_fTextMaxX = (pglyph->gmfptGlyphOrigin.x + originx + pglyph->gmfBlackBoxX);

        if ( (pglyph->gmfptGlyphOrigin.y + originy) > m_fTextMaxY )
            m_fTextMaxY = (pglyph->gmfptGlyphOrigin.y + originy);
        if ( (pglyph->gmfptGlyphOrigin.y + originy - pglyph->gmfBlackBoxY) < m_fTextMinY )
            m_fTextMinY = (pglyph->gmfptGlyphOrigin.y + originy - pglyph->gmfBlackBoxY);

        originx += pglyph->gmfCellIncX;
        originy += pglyph->gmfCellIncY;
    }

    return S_OK;
}




//*********************************************************************************
VOID CTextScreensaver::UpdateAngles( DWORD elapsed )
{
    static FLOAT    x,y,z,t;
    const FLOAT     pi2 = 3.1415926536f * 2.0f;

    FLOAT inc = FLOAT(elapsed * m_dwRotationSpeed);

    switch ( m_RotType )
    {
        case spin:
            y += inc * 0.00002f;
            break;

        case seesaw:
            t += inc * 0.000025f;
            y = (FLOAT(sin((t * pi2))) * 0.17f) + 1.0f;
            break;

        case wobble:
            t += inc * 0.000025f;
            y = (FLOAT(sin((t * pi2))) * 0.17f) + 1.0f;
            z = (FLOAT(cos((t * pi2))) * 0.09f) + 1.0f;
            break;

        case tumble:
            x += inc * 0.000004f;
            y += inc * 0.000018f;
            z += inc * 0.000007f;
            break;
    }

    x = x - int(x);
    y = y - int(y);
    z = z - int(z);

    m_fAngleX = x * pi2;
    m_fAngleY = y * pi2;
    m_fAngleZ = z * pi2;
}




//***************************************************************************************
BOOL CTextScreensaver::UpdateTimeString( TCHAR* string )
{
    TCHAR    str[MAX_DISPLAY_STRING+1];

    GetTimeFormat( LOCALE_USER_DEFAULT, 0, NULL, NULL, str, MAX_DISPLAY_STRING+1 );

    if ( lstrcmp( string , str ) )
    {
        lstrcpy( string , str );
        return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CTextScreensaver::ReadSettings()
{
    HKEY hkey;
    DWORD dwType = REG_DWORD;
    DWORD dwLength = sizeof(DWORD);

    // Defaults
    LoadString( NULL, IDS_DEFAULTTEXT, m_szDisplayString, MAX_DISPLAY_STRING );
    m_Font.lfHeight = 96;
    m_Font.lfWidth = 0;
    m_Font.lfEscapement = 0;
    m_Font.lfOrientation = 0;
    m_Font.lfWeight = 0;
    m_Font.lfItalic = 0;
    m_Font.lfUnderline = 0;
    m_Font.lfStrikeOut = 0;
    m_Font.lfCharSet = DEFAULT_CHARSET;
    m_Font.lfOutPrecision = OUT_DEFAULT_PRECIS;
    m_Font.lfClipPrecision = OUT_DEFAULT_PRECIS;
    m_Font.lfQuality = DEFAULT_QUALITY;
    m_Font.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
    LoadString( NULL, IDS_FONT, m_Font.lfFaceName, LF_FACESIZE ); 
    m_bDisplayTime = FALSE;
    m_dwMeshQuality = 500;
    m_SurfType = SurfType(environment);
    m_bSpecular = TRUE;
    m_dwRotationSpeed = 10;
    m_dwSize = 10;
    m_RotType = RotType(spin);
    m_SurfaceColor = 0x00777777;
    m_bUseCustomColor = FALSE;
    m_bUseCustomTexture = FALSE;
    m_bUseCustomEnvironment = FALSE;
    lstrcpy( m_szCustomTexture, TEXT("") );
    lstrcpy( m_szCustomEnvironment, TEXT("") );

    // Read OpenGL settings first, so OS upgrade cases work
    ss_ReadSettings();

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        dwLength = (MAX_DISPLAY_STRING + 1) * sizeof(TCHAR);
        RegQueryValueEx( hkey, TEXT("DisplayString"), NULL, &dwType, (BYTE*)m_szDisplayString, &dwLength );

        dwLength = sizeof(DWORD);
        RegQueryValueEx( hkey, TEXT("FontHeight"), NULL, &dwType, (BYTE*)&m_Font.lfHeight, &dwLength );

        RegQueryValueEx( hkey, TEXT("FontWeight"), NULL, &dwType, (BYTE*)&m_Font.lfWeight, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("FontItalic"), NULL, &dwType, (BYTE*)&m_Font.lfItalic, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("FontCharSet"), NULL, &dwType, (BYTE*)&m_Font.lfCharSet, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("FontPitchFamily"), NULL, &dwType, (BYTE*)&m_Font.lfPitchAndFamily, &dwLength );

        dwLength = sizeof(m_Font.lfFaceName);
        RegQueryValueEx( hkey, TEXT("FontFace"), NULL, &dwType, (BYTE*)m_Font.lfFaceName, &dwLength );

        dwLength = sizeof(DWORD);
        RegQueryValueEx( hkey, TEXT("DisplayTime"), NULL, &dwType, (BYTE*)&m_bDisplayTime, &dwLength );

        RegQueryValueEx( hkey, TEXT("MeshQuality"), NULL, &dwType, (BYTE*)&m_dwMeshQuality, &dwLength );
        if ( m_dwMeshQuality > 1000 )
            m_dwMeshQuality = 1000;

        RegQueryValueEx( hkey, TEXT("SurfaceType"), NULL, &dwType, (BYTE*)&m_SurfType, &dwLength );

        RegQueryValueEx( hkey, TEXT("Specular"), NULL, &dwType, (BYTE*)&m_bSpecular, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("RotationSpeed"), NULL, &dwType, (BYTE*)&m_dwRotationSpeed, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("Size"), NULL, &dwType, (BYTE*)&m_dwSize, &dwLength );
        if( m_dwSize < 1 )
            m_dwSize = 1;
        if( m_dwSize > 10 )
            m_dwSize = 10;
        
        RegQueryValueEx( hkey, TEXT("RotationStyle"), NULL, &dwType, (BYTE*)&m_RotType, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("SurfaceColor"), NULL, &dwType, (BYTE*)&m_SurfaceColor, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("UseCustomColor"), NULL, &dwType, (BYTE*)&m_bUseCustomColor, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("UseCustomTexture"), NULL, &dwType, (BYTE*)&m_bUseCustomTexture, &dwLength );
        
        RegQueryValueEx( hkey, TEXT("UseCustomEnvironment"), NULL, &dwType, (BYTE*)&m_bUseCustomEnvironment, &dwLength );
        
        dwLength = sizeof(m_szCustomTexture);
        RegQueryValueEx( hkey, TEXT("CustomTexture"), NULL, &dwType, (BYTE*)m_szCustomTexture, &dwLength );
        
        dwLength = sizeof(m_szCustomEnvironment);
        RegQueryValueEx( hkey, TEXT("CustomEnvironment"), NULL, &dwType, (BYTE*)m_szCustomEnvironment, &dwLength );

        ReadScreenSettings( hkey );

        RegCloseKey( hkey );
    }
}




//-----------------------------------------------------------------------------
// Name: ss_ReadSettings()
// Desc: 
//-----------------------------------------------------------------------------
VOID CTextScreensaver::ss_ReadSettings()
{
    int    options;
    int    optMask = 1;

    // Get registry settings
    if( ss_RegistrySetup( IDS_SAVERNAME, IDS_INIFILE ) )
    {
        // get demo type
        int demoType = ss_GetRegistryInt( IDS_DEMOTYPE, 0 );
        if( demoType == 1 )
        {
            m_bDisplayTime = TRUE;
        }

        // get rotation style
        m_RotType = (RotType) (ss_GetRegistryInt( IDS_ROTSTYLE, 0 ) + 1); // add 1
        if( m_RotType == 1 ) // 1==none,2=right,3=right,4=random->spin
            m_RotType = none;
        if( m_RotType > 3 )  
            m_RotType = spin;

        // get tesselation
        m_dwMeshQuality = ss_GetRegistryInt( IDS_TESSELATION, 0 ); // 0-100
        m_dwMeshQuality = m_dwMeshQuality*10 + 1; // 1-1000
        if ( m_dwMeshQuality > 1000 )
            m_dwMeshQuality = 1000;

        // get size 
        m_dwSize = ss_GetRegistryInt( IDS_SIZE, 0 ); // 0-100
        m_dwSize = (unsigned) ( ((m_dwSize / 100.0f) * 90.0f + 10.0f) / 10.0f ); // 1-10

        // get speed
        m_dwRotationSpeed = ss_GetRegistryInt( IDS_SPEED, 0 ); // 0-100
        m_dwRotationSpeed = (unsigned) ( ((m_dwRotationSpeed / 100.0f) * 190.0f + 10.0f) / 10.0f ); // 1-20

        // get font, attributes, and charset
        ss_GetRegistryString( IDS_FONT_REG, TEXT(""),
                              m_Font.lfFaceName, LF_FACESIZE );

        options = ss_GetRegistryInt( IDS_FONT_ATTRIBUTES, 0 );
        if( options >= 0 ) 
        {
            optMask = 1;
            m_Font.lfWeight = ((options & optMask) != 0) ? FW_BOLD : FW_NORMAL;
            optMask <<=1;
            m_Font.lfItalic = ((options & optMask) != 0) ? (BYTE) 1 : 0;
        }

        m_Font.lfCharSet = (BYTE)ss_GetRegistryInt( IDS_CHARSET, 0 );

        // get display string
        ss_GetRegistryString( IDS_TEXT, TEXT(""), m_szDisplayString, MAX_DISPLAY_STRING );

        m_SurfType = (SurfType) ss_GetRegistryInt( IDS_SURFSTYLE, color );
        if( m_SurfType >= 1 )
            m_SurfType = texture;

        // Is there a texture specified in the registry that overrides the default?
        ss_GetRegistryString( IDS_TEXTURE, NULL, m_szCustomTexture, MAX_PATH );
        if( lstrlen( m_szCustomTexture ) > 0 )
        {
            m_bUseCustomTexture = TRUE;
        }
    }
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
BOOL CTextScreensaver::ss_RegistrySetup( int section, int file )
{
    if( LoadString(m_hInstance, section, g_szSectName, BUF_SIZE) &&
        LoadString(m_hInstance, file, g_szFname, BUF_SIZE) ) 
    {
        TCHAR pBuffer[100];
        DWORD dwRealSize = GetPrivateProfileSection( g_szSectName, pBuffer, 100, g_szFname );
        if( dwRealSize > 0 )
            return TRUE;
    }
    
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryInt()
// Desc: 
//-----------------------------------------------------------------------------
int CTextScreensaver::ss_GetRegistryInt( int name, int iDefault )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        return GetPrivateProfileInt(g_szSectName, szItemName, iDefault, g_szFname);

    return 0;
}




//-----------------------------------------------------------------------------
// Name: ss_GetRegistryString()
// Desc: 
//-----------------------------------------------------------------------------
VOID CTextScreensaver::ss_GetRegistryString( int name, LPTSTR lpDefault, 
                                                         LPTSTR lpDest, int bufSize )
{
    TCHAR szItemName[BUF_SIZE];

    if( LoadString( m_hInstance, name, szItemName, BUF_SIZE ) ) 
        GetPrivateProfileString(g_szSectName, szItemName, lpDefault, lpDest,
                                bufSize, g_szFname);

    return;
}




//-----------------------------------------------------------------------------
// Name: DoConfig()
// Desc: 
//-----------------------------------------------------------------------------
VOID CTextScreensaver::DoConfig()
{
    ReadSettings();
    DialogBox( NULL, MAKEINTRESOURCE( IDD_SETTINGS ),
               m_hWndParent, SettingsDialogProcStub );
}




INT_PTR CALLBACK CTextScreensaver::SettingsDialogProcStub( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{ 
    return g_pMyTextScreensaver->SettingsDialogProc( hDlg, message, wParam, lParam ); 
};




BOOL CTextScreensaver::SettingsDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch ( message )
    {
        case WM_INITDIALOG:
            InitItems( hDlg );
            return FALSE;

        case WM_COMMAND:
            switch ( HIWORD(wParam) )
            {
                case BN_CLICKED:
                {
                    switch( LOWORD(wParam) )
                    {
                        case IDOK:
                            ExtractAndWriteSettings( hDlg );
                            EndDialog( hDlg, TRUE );
                            break;

                        case IDCANCEL:
                            ReadSettings();
                            EndDialog( hDlg, FALSE );
                            break;

                        case IDC_SELECT_FONT:
                            SelectFont( hDlg );
                            break;

                        case IDC_RADIO_TIME:
                            EnableWindow( GetDlgItem( hDlg , IDC_DISPLAY_STRING ) , FALSE );
                            break;

                        case IDC_RADIO_TEXT:
                            EnableWindow( GetDlgItem( hDlg , IDC_DISPLAY_STRING ) , TRUE );
                            break;

                        case IDC_RADIO_COLOR:
                        case IDC_RADIO_TEXTURE:
                        case IDC_RADIO_REFLECTION:
                        case IDC_USE_CUSTOM_COLOR:
                        case IDC_USE_CUSTOM_TEXTURE:
                        case IDC_USE_CUSTOM_ENVIRONMENT:
                        {
                            if( IsDlgButtonChecked( hDlg, IDC_RADIO_COLOR ) )
                                m_SurfType = color;
                            else if( IsDlgButtonChecked( hDlg, IDC_RADIO_TEXTURE ) )
                                m_SurfType = texture;
                            else if( IsDlgButtonChecked( hDlg, IDC_RADIO_REFLECTION ) )
                                m_SurfType = environment;
                            EnableTextureWindows( hDlg , SurfType(m_SurfType) );
                        }
                        break;

                        case IDC_SURFACE_COLOR:
                            SelectSurfaceColor( hDlg );
                            break;

                        case IDC_BROWSE_TEXTURE:
                            SelectCustomTexture( hDlg );
                            break;

                        case IDC_BROWSE_ENVIRONMENT:
                            SelectCustomEnvironment( hDlg );
                            break;

                        case IDC_SCREENSETTINGS:
                            DoScreenSettingsDialog( hDlg );
                            break;
                    }
                }
                break;

                case EN_CHANGE:
                    if ( LOWORD(wParam) == IDC_DISPLAY_STRING )
                    {
                        GetDlgItemText( hDlg , IDC_DISPLAY_STRING , m_szDisplayString , MAX_DISPLAY_STRING );
                    }
                    break;
            }
            return FALSE;
    }

    return FALSE;
}




VOID CTextScreensaver::InitItems( HWND hDlg )
{
    TCHAR sz[100];

    // Set the limit of the text box
    SendDlgItemMessage( hDlg, IDC_DISPLAY_STRING, EM_SETLIMITTEXT, MAX_DISPLAY_STRING, 0 );

    // Set the text string
    SetDlgItemText( hDlg, IDC_DISPLAY_STRING, m_szDisplayString );

    // Set the radio button for time/text display
    if ( m_bDisplayTime )
    {
        EnableWindow( GetDlgItem( hDlg, IDC_DISPLAY_STRING ), FALSE );
        CheckRadioButton( hDlg, IDC_RADIO_TIME, IDC_RADIO_TEXT, IDC_RADIO_TIME );
    }
    else
    {
        EnableWindow( GetDlgItem( hDlg, IDC_DISPLAY_STRING ), TRUE );
        CheckRadioButton( hDlg, IDC_RADIO_TIME, IDC_RADIO_TEXT, IDC_RADIO_TEXT );
    }

    switch( m_SurfType )
    {
    case color:
        CheckRadioButton( hDlg, IDC_RADIO_COLOR, IDC_RADIO_REFLECTION, IDC_RADIO_COLOR );
        break;
    case texture:
        CheckRadioButton( hDlg, IDC_RADIO_COLOR, IDC_RADIO_REFLECTION, IDC_RADIO_TEXTURE );
        break;
    case environment:
        CheckRadioButton( hDlg, IDC_RADIO_COLOR, IDC_RADIO_REFLECTION, IDC_RADIO_REFLECTION );
        break;
    }

    // Check/uncheck the specular box
    SendDlgItemMessage( hDlg, IDC_SPECULAR, BM_SETCHECK,
                        m_bSpecular ? BST_CHECKED : BST_UNCHECKED, 0 );

    // Enable/disable surface color button
    EnableWindow( GetDlgItem( hDlg, IDC_SURFACE_COLOR ), m_SurfType == color );

    // Check/uncheck the custom texture boxes
    SendDlgItemMessage( hDlg, IDC_USE_CUSTOM_COLOR, BM_SETCHECK,
                        m_bUseCustomColor ? BST_CHECKED : BST_UNCHECKED, 0 );
    SendDlgItemMessage( hDlg, IDC_USE_CUSTOM_TEXTURE, BM_SETCHECK,
                        m_bUseCustomTexture ? BST_CHECKED : BST_UNCHECKED, 0 );
    SendDlgItemMessage( hDlg, IDC_USE_CUSTOM_ENVIRONMENT, BM_SETCHECK,
                        m_bUseCustomEnvironment ? BST_CHECKED : BST_UNCHECKED, 0 );

    // Enable all the texture windows as appropriate
    EnableTextureWindows( hDlg, m_SurfType );

    // Fill the rotation style combo box
    LoadString( NULL, IDS_NONE, sz, 100 );
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_ADDSTRING, 0, (LPARAM) sz );
    LoadString( NULL, IDS_SPIN, sz, 100 );
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_ADDSTRING, 0, (LPARAM) sz );
    LoadString( NULL, IDS_SEESAW, sz, 100 );
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_ADDSTRING, 0, (LPARAM) sz );
    LoadString( NULL, IDS_WOBBLE, sz, 100 );
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_ADDSTRING, 0, (LPARAM) sz );
    LoadString( NULL, IDS_TUMBLE, sz, 100 );
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_ADDSTRING, 0, (LPARAM) sz );

    // Set the current rotation style selection
    SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_SETCURSEL, m_RotType, 0 );

    // Set up the rotation speed slider
    SendDlgItemMessage( hDlg, IDC_ROTATION_SPEED, TBM_SETRANGE, TRUE, MAKELONG(1,20) );
    SendDlgItemMessage( hDlg, IDC_ROTATION_SPEED, TBM_SETPOS, TRUE, m_dwRotationSpeed );

    // Set up the resolution slider
    SendDlgItemMessage( hDlg, IDC_RESOLUTION, TBM_SETRANGE, TRUE, MAKELONG(1,10) );
    SendDlgItemMessage( hDlg, IDC_RESOLUTION, TBM_SETPOS, TRUE, m_dwMeshQuality / 100 );

    // Set up the size slider
    SendDlgItemMessage( hDlg, IDC_VIEWPORTSIZE, TBM_SETRANGE, TRUE, MAKELONG(1,10) );
    SendDlgItemMessage( hDlg, IDC_VIEWPORTSIZE, TBM_SETPOS, TRUE, m_dwSize );
}



  
VOID CTextScreensaver::ExtractAndWriteSettings( HWND hDlg )
{
    LRESULT ret;
    HKEY hkey = NULL;

    m_bSpecular = IsDlgButtonChecked( hDlg, IDC_SPECULAR );

    m_bUseCustomColor = IsDlgButtonChecked( hDlg, IDC_USE_CUSTOM_COLOR );
    m_bUseCustomTexture = IsDlgButtonChecked( hDlg, IDC_USE_CUSTOM_TEXTURE );
    m_bUseCustomEnvironment = IsDlgButtonChecked( hDlg, IDC_USE_CUSTOM_ENVIRONMENT );

    if ( (ret = SendDlgItemMessage( hDlg, IDC_ROTATION_STYLE, CB_GETCURSEL, 0, 0 )) != CB_ERR )
        m_RotType = RotType(ret);

    m_dwSize = (DWORD)SendDlgItemMessage( hDlg, IDC_VIEWPORTSIZE, TBM_GETPOS, 0, 0 );
    m_dwRotationSpeed = (DWORD)SendDlgItemMessage( hDlg, IDC_ROTATION_SPEED, TBM_GETPOS, 0, 0 );
    m_dwMeshQuality = 100 * (DWORD)SendDlgItemMessage( hDlg, IDC_RESOLUTION, TBM_GETPOS, 0, 0 );

    GetDlgItemText( hDlg, IDC_DISPLAY_STRING, m_szDisplayString, MAX_DISPLAY_STRING + 1 );

    if ( IsDlgButtonChecked( hDlg, IDC_RADIO_TIME ) )
        m_bDisplayTime = TRUE;
    else
        m_bDisplayTime = FALSE;

    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER, m_strRegPath, 
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL ) )
    {
        WriteScreenSettings( hkey );
        RegSetValueEx( hkey, TEXT("SurfaceType"), NULL, REG_DWORD, (BYTE*)&m_SurfType, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("Specular"), NULL, REG_DWORD, (BYTE*)&m_bSpecular, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("SurfaceColor"), NULL, REG_DWORD, (BYTE*)&m_SurfaceColor, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("CustomTexture"), NULL, REG_SZ, (BYTE*)&m_szCustomTexture, (lstrlen(m_szCustomTexture) + 1) * sizeof(TCHAR) );
        RegSetValueEx( hkey, TEXT("CustomEnvironment"), NULL, REG_SZ, (BYTE*)&m_szCustomEnvironment, (lstrlen(m_szCustomEnvironment) + 1) * sizeof(TCHAR) );
        RegSetValueEx( hkey, TEXT("UseCustomColor"), NULL, REG_DWORD, (BYTE*)&m_bUseCustomColor, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("UseCustomTexture"), NULL, REG_DWORD, (BYTE*)&m_bUseCustomTexture, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("UseCustomEnvironment"), NULL, REG_DWORD, (BYTE*)&m_bUseCustomEnvironment, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("MeshQuality"), NULL, REG_DWORD, (BYTE*)&m_dwMeshQuality, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("Size"), NULL, REG_DWORD, (BYTE*)&m_dwSize, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("RotationSpeed"), NULL, REG_DWORD, (BYTE*)&m_dwRotationSpeed, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("RotationStyle"), NULL, REG_DWORD, (BYTE*)&m_RotType, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("DisplayString"), NULL, REG_SZ, (BYTE*)&m_szDisplayString, (lstrlen(m_szDisplayString) + 1) * sizeof(TCHAR) );
        RegSetValueEx( hkey, TEXT("DisplayTime"), NULL, REG_DWORD, (BYTE*)&m_bDisplayTime, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontWeight"), NULL, REG_DWORD, (BYTE*)&m_Font.lfWeight, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontHeight"), NULL, REG_DWORD, (BYTE*)&m_Font.lfHeight, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontItalic"), NULL, REG_DWORD, (BYTE*)&m_Font.lfItalic, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontCharSet"), NULL, REG_DWORD, (BYTE*)&m_Font.lfCharSet, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontPitchFamily"), NULL, REG_DWORD, (BYTE*)&m_Font.lfPitchAndFamily, sizeof(DWORD) );
        RegSetValueEx( hkey, TEXT("FontFace"), NULL, REG_SZ, (BYTE*)&m_Font.lfFaceName, (lstrlen(m_Font.lfFaceName) + 1) * sizeof(TCHAR) );
        RegCloseKey( hkey );
    }
}




//***************************************************************************************
VOID CTextScreensaver::SelectSurfaceColor( HWND hDlg )
{
    static COLORREF cust_colors[16];

    CHOOSECOLOR choose;
    choose.lStructSize = sizeof(choose);
    choose.hwndOwner = hDlg;
    choose.hInstance = HWND(m_hInstance);
    choose.rgbResult = m_SurfaceColor;
    choose.lpCustColors = cust_colors;
    choose.Flags = CC_ANYCOLOR|CC_FULLOPEN|CC_RGBINIT;
    choose.lCustData = 0;
    choose.lpfnHook = NULL;
    choose.lpTemplateName = NULL;

    if ( ChooseColor( &choose ) )
        m_SurfaceColor = choose.rgbResult;
}




//***************************************************************************************
VOID CTextScreensaver::SelectFont( HWND hDlg )
{
    CHOOSEFONT  choose;

    choose.lStructSize = sizeof(choose);
    choose.hwndOwner = hDlg;
    choose.hDC;
    choose.iPointSize = 720;
    choose.lpLogFont = &m_Font;
    choose.Flags = CF_TTONLY|CF_FORCEFONTEXIST|CF_NOVERTFONTS|CF_SCREENFONTS|CF_INITTOLOGFONTSTRUCT|CF_ENABLETEMPLATE;
    choose.lpTemplateName = MAKEINTRESOURCE(DLG_SELECT_FONT);
    choose.hInstance = m_hInstance;

    if ( ChooseFont( &choose ) )
        m_Font = *choose.lpLogFont;
}




//***************************************************************************************
VOID CTextScreensaver::SelectCustomTexture( HWND hDlg )
{
    TCHAR    fn[MAX_PATH] = TEXT("\0");
    TCHAR    strTitle[100];
    LoadString( NULL, IDS_OPENTEXTURETITLE, strTitle, 100 );

    lstrcpy( fn, m_szCustomTexture );

    TCHAR    filter[200];
    LoadString( NULL, IDS_FILEFILTER, filter, 200); 
    for( TCHAR* pch = filter; *pch != TEXT('\0'); pch++ )
    {
        if( *pch == TEXT('#') )
            *pch = TEXT('\0');
    }

    TCHAR szWindowsDir[MAX_PATH+1];
    if( 0 == GetWindowsDirectory( szWindowsDir, MAX_PATH+1 ) )
	    szWindowsDir[0] = TEXT('\0');

    OPENFILENAME    ofn;
    memset( &ofn , 0 , sizeof(ofn) );
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = m_hInstance;
    ofn.lpstrFilter = filter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = fn;
    ofn.nMaxFile = sizeof(fn);
    ofn.lpstrTitle = strTitle;
    ofn.Flags = OFN_ENABLESIZING|OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = TEXT("mid");
    if( lstrlen( fn ) == 0 )
        ofn.lpstrInitialDir = szWindowsDir;

    if ( GetOpenFileName( &ofn ) )
        lstrcpy( m_szCustomTexture , ofn.lpstrFile );
}




//***************************************************************************************
VOID CTextScreensaver::SelectCustomEnvironment( HWND hDlg )
{
    TCHAR    fn[MAX_PATH] = TEXT("\0");
    TCHAR    strTitle[100];
    LoadString( NULL, IDS_OPENENVIRONMENTMAPTITLE, strTitle, 100 );

    TCHAR    filter[200];
    LoadString( NULL, IDS_FILEFILTER, filter, 200); 
    for( TCHAR* pch = filter; *pch != TEXT('\0'); pch++ )
    {
        if( *pch == TEXT('#') )
            *pch = TEXT('\0');
    }

    TCHAR szWindowsDir[MAX_PATH+1];
    if( 0 == GetWindowsDirectory( szWindowsDir, MAX_PATH+1 ) )
	    szWindowsDir[0] = TEXT('\0');

    OPENFILENAME    ofn;
    memset( &ofn , 0 , sizeof(ofn) );
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = m_hInstance;
    ofn.lpstrFilter = filter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = fn;
    ofn.nMaxFile = sizeof(fn);
    ofn.lpstrTitle = strTitle;
    ofn.Flags = OFN_ENABLESIZING|OFN_FILEMUSTEXIST;
    ofn.lpstrDefExt = TEXT("mid");
    if( lstrlen( fn ) == 0 )
        ofn.lpstrInitialDir = szWindowsDir;

    if ( GetOpenFileName( &ofn ) )
        lstrcpy( m_szCustomEnvironment , ofn.lpstrFile );
}




//***************************************************************************************
VOID CTextScreensaver::EnableTextureWindows( HWND hDlg , SurfType sel )
{
    HWND    use_color = GetDlgItem( hDlg , IDC_USE_CUSTOM_COLOR );
    HWND    use_texture = GetDlgItem( hDlg , IDC_USE_CUSTOM_TEXTURE );
    HWND    use_environ = GetDlgItem( hDlg , IDC_USE_CUSTOM_ENVIRONMENT );
    HWND    browse_color = GetDlgItem( hDlg , IDC_SURFACE_COLOR );
    HWND    browse_texture = GetDlgItem( hDlg , IDC_BROWSE_TEXTURE );
    HWND    browse_environ = GetDlgItem( hDlg , IDC_BROWSE_ENVIRONMENT );

    BOOL    color_checked = IsDlgButtonChecked( hDlg , IDC_USE_CUSTOM_COLOR );
    BOOL    texture_checked = IsDlgButtonChecked( hDlg , IDC_USE_CUSTOM_TEXTURE );
    BOOL    environment_checked = IsDlgButtonChecked( hDlg , IDC_USE_CUSTOM_ENVIRONMENT );

    switch ( sel )
    {
        case environment:
            EnableWindow( use_color , FALSE );
            EnableWindow( use_texture , FALSE );
            EnableWindow( use_environ , TRUE );
            EnableWindow( browse_color , FALSE );
            EnableWindow( browse_texture , FALSE );
            EnableWindow( browse_environ , environment_checked );
            break;

        case texture:
            EnableWindow( use_color , FALSE );
            EnableWindow( use_texture , TRUE );
            EnableWindow( use_environ , FALSE );
            EnableWindow( browse_color , FALSE );
            EnableWindow( browse_texture , texture_checked );
            EnableWindow( browse_environ , FALSE );
            break;

        case color:
        default:
            EnableWindow( use_color , TRUE );
            EnableWindow( use_texture , FALSE );
            EnableWindow( use_environ , FALSE );
            EnableWindow( browse_color , color_checked );
            EnableWindow( browse_texture , FALSE );
            EnableWindow( browse_environ , FALSE );
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\access.h ===
/******************************************************************************
Module name: Access.h
Purpose: defines for all accstat
******************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <cpl.h>
//#include <shellapi.h>
#include <commctrl.h>

#include "acchelp.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////////////


#define ARRAY_SIZE(a)      (sizeof(a) / sizeof((a)[0]))
#define MEMBER_SIZE(s,m)   sizeof(((s *)0)->m)

// Debugging defs
#if defined(DEBUG) || defined(MEMCHECK) || defined(_DEBUG)

//Assert based on boolean f.
#define Assert(f) assert(f)

#else

#define Assert(f) ((void)0)

#endif


//////////////////////////////////////////////////////////////////////////////

extern BOOL g_SPISetValue;
extern HINSTANCE g_hinst;
extern BOOL      g_fWinNT;       // TRUE if we're running on NT and must disable
                                 // some features.

extern const DWORD g_aIds[];     // array mapping control id's to help id's

// This functions makes it easy to access the registry.
int  WINAPI RegQueryInt(int nDefault, HKEY hkey, LPTSTR lpSubKey, LPTSTR lpValueName);
BOOL WINAPI RegSetInt(HKEY hkey, LPTSTR lpSubKey, LPTSTR lpValueName, int nVal);

void WINAPI RegQueryStr(
    LPTSTR lpDefault, 
    HKEY hkey, 
    LPTSTR lpSubKey, 
    LPTSTR lpValueName,
    LPTSTR lpszValue, 
    DWORD cbData);

BOOL RegSetStr(HKEY hkey, LPCTSTR lpSection, LPCTSTR lpKeyName, LPCTSTR lpString);

DWORD WINAPI RegQueryStrDW(
    DWORD dwDefault,
    HKEY hkey, 
    LPTSTR lpSubKey, 
    LPTSTR lpValueName);

BOOL RegSetStrDW(HKEY hkey, LPTSTR lpSection, LPCTSTR lpKeyName, DWORD dwValue);

   // This function takes the current state of the variables below
// and updates the system settings.
void WINAPI SetAccessibilitySettings (void);

// These values are declared in General.c
extern BOOL  g_fSaveSettings;
extern BOOL  g_fShowWarnMsgOnFeatureActivate;
extern BOOL  g_fPlaySndOnFeatureActivate;
// Admin options in general
extern BOOL  g_fCopyToLogon;
extern BOOL  g_fCopyToDefault;

// Keyboard property page
extern STICKYKEYS     g_sk;
extern FILTERKEYS     g_fk;
   // g_dwLastBounceKeySetting is part of FilterKeys
   extern DWORD g_dwLastBounceKeySetting;
   extern DWORD g_nLastRepeatDelay;
   extern DWORD g_nLastRepeatRate;
   extern DWORD g_nLastWait;

extern TOGGLEKEYS     g_tk;
extern BOOL           g_fExtraKeyboardHelp;

// Sound Property page
extern SOUNDSENTRY    g_ss;
extern BOOL           g_fShowSounds;

// Display Property page
#define BLINK           1000
#define BLINK_OFF       -1

#define CURSORMIN       200
#define CURSORMAX       1300
#define CURSORSUM       (CURSORMIN + CURSORMAX)
#define CURSORRANGE     (CURSORMAX - CURSORMIN)

typedef struct CARET_SETTINGS {
    DWORD dwCaretBlinkRate;
    DWORD dwCaretWidth;
    DWORD dwNewCaretBlinkRate;
    DWORD dwNewCaretWidth;
} CARET_SETTINGS;
extern HIGHCONTRAST   g_hc;
extern CARET_SETTINGS g_cs;
extern TCHAR          g_szScheme[256];

// Mouse Property page
extern MOUSEKEYS      g_mk;

// General Property page
extern ACCESSTIMEOUT  g_ato;
extern SERIALKEYS     g_serk;
extern TCHAR          g_szActivePort[MAX_PATH];
//extern TCHAR        g_szPort[MAX_PATH];  // Currently reserved, should be NULL.


//////////////////////////////////////////////////////////////////////////////


// AccessSystemParametersInfo is actually defined in AccRare.c and is
// a replacement for SysParamInfoBugFix

BOOL AccessSystemParametersInfo(
	UINT wFlag,
	DWORD wParam,
	PVOID lParam,
	UINT flags);

//////////////////////////////////////////////////////////////////////////////


// Define strings for registry.
#define GENERAL_KEY           __TEXT("Control Panel\\Accessibility")
#define FILTER_KEY            __TEXT("Control Panel\\Accessibility\\Keyboard Response")
#define HC_KEY                __TEXT("Control Panel\\Accessibility\\HighContrast")
#define CONTROL_KEY           __TEXT("Control Panel\\Appearance\\Schemes")
#define WARNING_SOUNDS        __TEXT("Warning Sounds")
#define SOUND_ON_ACTIVATION   __TEXT("Sound on Activation")
#define APPLY_GLOBALLY        __TEXT("Restore Settings")
#define NORMALSCHEME          __TEXT("Current Normal Scheme")
#define HIGHCONTRAST_SCHEME   __TEXT("High Contrast Scheme")
#define VOLATILE_SCHEME       __TEXT("Volital HC Scheme")
#define WHITEBLACK_HC         __TEXT("High Contrast Black (large)")
#define LAST_BOUNCE_SETTING   __TEXT("Last BounceKey Setting")
#define LAST_REPEAT_RATE      __TEXT("Last Valid Repeat")
#define LAST_REPEAT_DELAY     __TEXT("Last Valid Delay")
#define LAST_WAIT             __TEXT("Last Valid Wait")
#define CURR_HC_SCHEME        __TEXT("High Contrast Scheme")
#define APPEARANCE_KEY        __TEXT("Control Panel\\Appearance")
#define CURR_NONHC_SCHEME     __TEXT("Current")


#define IDSENG_BLACKWHITE_SCHEME   __TEXT("High Contrast White (large)")
#define IDSENG_WHITEBLACK_SCHEME   __TEXT("High Contrast Black (large)")



//////////////////////////////////////////////////////////////////////////////


// Define prototypes
INT_PTR WINAPI HighContrastDlg (HWND, UINT , WPARAM , LPARAM);
INT_PTR WINAPI ToggleKeySettingsDlg (HWND, UINT, WPARAM, LPARAM);
INT_PTR WINAPI StickyKeyDlg (HWND, UINT , WPARAM, LPARAM);
INT_PTR WINAPI FilterKeyDlg (HWND, UINT , WPARAM, LPARAM);
INT_PTR WINAPI MouseKeyDlg (HWND, UINT, WPARAM, LPARAM);
INT_PTR WINAPI SerialKeyDlg (HWND, UINT, WPARAM, LPARAM);

int HandleScroll (HWND hwnd, WPARAM wParam, HWND hwndScroll);


DWORD SaveDefaultSettings(BOOL saveL, BOOL saveU);
BOOL IsDefaultWritable(void);


typedef
LANGID (WINAPI *pfnGetUserDefaultUILanguage)(void);

typedef
LANGID (WINAPI *pfnGetSystemDefaultUILanguage)(void);

BOOL IsMUI_Enabled();




///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\acchelp.h ===
//
// Help file equates.
//

#define NO_HELP						((DWORD) -1)

#define IDH_ACCESS_CONFIRMHOTKEY	1000
#define IDH_ACCESS_SOUNDONHOTKEY	1010
#define IDH_ACCESS_TIMEOUT		1015
#define	IDH_ACCESS_TIMEOUT_MINUTES	1016
#define IDH_FILTERKEYS_BEEPONKEYPRESS	1020
#define IDH_FILTERKEYS_BKSETTINGS 1024
#define IDH_FILTERKEYS_SETTINGS_REPEAT	1025
#define IDH_FILTERKEYS_DELAY            1030
#define IDH_REPEAT_DELAY                1031
#define IDH_FILTERKEYS_ENABLE		1035
#define IDH_FILTERKEYS_HOTKEY		1040
#define IDH_FILTERKEYS_IGNORE_REPEAT	1045
#define IDH_FILTERKEYS_KEYSPEED		1050
#define IDH_FILTERKEYS_NO_REPEAT	1055
#define IDH_FILTERKEYS_RATE		1060
#define IDH_FILTERKEYS_REPEATKEYS	1065
#define IDH_FILTERKEYS_SETTINGS		1070
#define IDH_FILTERKEYS_BOUNCEKEYS	1075
#define IDH_FILTERKEYS_SETTINGS_QUICK	1080
#define IDH_FILTERKEYS_SLOW		1085
#define IDH_FILTERKEYS_SPAWNSTATUSAPP	1090
#define IDH_FILTERKEYS_TEST1		1095
#define IDH_FILTERKEYS_TEST2		1100
#define IDH_FILTERKEYS_TESTBOX		1105
#define IDH_HIGHCONTRAST_DEFAULTSCHEME	1110
#define IDH_HC_NONHCSCHEME          1111
#define IDH_HIGHCONTRAST_ENABLE		1115
#define IDH_HIGHCONTRAST_HOTKEY		1120
#define IDH_KCURSOR_RATE            1121
#define IDH_KCURSOR_WIDTH           1122
#define IDH_KCURSOR_OPTS            1123

#define IDH_HIGHCONTRAST_SETTINGS	1125
#define IDH_MOUSEKEYS_ACCELERATION	1130
#define IDH_MOUSEKEYS_ENABLE		1135
#define IDH_MOUSEKEYS_HOTKEY		1140
#define IDH_MOUSEKEYS_MAXSPEED		1145
#define IDH_MOUSEKEYS_NUMLOCKMODE	1150
#define IDH_MOUSEKEYS_SETTINGS		1155
#define IDH_MOUSEKEYS_SPAWNSTATUSAPP	1160
#define IDH_MOUSEKEYS_USEMODIFIERKEYS	1165
#define IDH_SERIALKEYS_BAUD		1170
#define IDH_SERIALKEYS_ENABLE		1175
#define IDH_SERIALKEYS_SERIAL		1180
#define IDH_SERIALKEYS_SETTINGS		1185
#define IDH_SHOWSOUNDS_ENABLE		1190
#define IDH_SOUNDSENTRY_ENABLE		1195
#define IDH_SOUNDSENTRY_GRAPHICS	1200
#define IDH_SOUNDSENTRY_WINDOWED	1215
#define IDH_STICKYKEYS_2KEYS		1220
#define IDH_STICKYKEYS_ENABLE		1225
#define IDH_STICKYKEYS_HOTKEY		1230
#define IDH_STICKYKEYS_LOCK		1235
#define IDH_STICKYKEYS_SETTINGS		1240
#define IDH_STICKYKEYS_SOUND		1245
#define IDH_STICKYKEYS_STATUS		1250
#define IDH_TOGGLEKEYS_ENABLE		1255
#define IDH_TOGGLEKEYS_HOTKEY		1260
#define IDH_TOGGLEKEYS_SETTINGS		1265
#define IDH_VALID_KEY_TIME		1068
#define IDH_REPEAT_RATE			1067
#define IDH_IDLE_TIMEOUT		1038
#define IDH_KEY_PRESS_TIME		1056

// New helps from new dialogs

// #define IDH_SLOWKEYS_ACCEPTDELAY	2000
// #define IDH_SLOWKEYS_ENABLEREPEAT	2001
// #define IDH_SLOWKEYS_DELAYTIME		2002
// #define IDH_SLOWKEYS_REPEATTIME		2003
// #define IDH_BOUNCKEYS_BOUNCETIME	2004

#define IDH_ACCESS_FILTER_KEYS		2006
#define IDH_ACCESS_MOUSE_KEYS		2007
#define IDH_ACCESS_STICKY_KEYS		2008
#define IDH_SHOW_KEYBOARD_HELP		2009
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\accrare.c ===
/****************************** Module Header ******************************\
* Module Name: accrare.c
*
* Copyright (c) 1985-95, Microsoft Corporation
*
* History:
* 12-18-95 a-jimhar 	Created based on rare.c
\***************************************************************************/


#include "Access.h"

#define REGSTR_PATH_SERIALKEYS  __TEXT("Control Panel\\Accessibility\\SerialKeys")
#define REGSTR_VAL_ACTIVEPORT   __TEXT("ActivePort")
#define REGSTR_VAL_BAUDRATE     __TEXT("BaudRate")
#define REGSTR_VAL_FLAGS        __TEXT("Flags")
#define REGSTR_VAL_PORTSTATE    __TEXT("PortState")

#define PMAP_STICKYKEYS            __TEXT("Control Panel\\Accessibility\\StickyKeys")
#define PMAP_KEYBOARDRESPONSE  __TEXT("Control Panel\\Accessibility\\Keyboard Response")
#define PMAP_MOUSEKEYS		   __TEXT("Control Panel\\Accessibility\\MouseKeys")
#define PMAP_TOGGLEKEYS 	   __TEXT("Control Panel\\Accessibility\\ToggleKeys")
#define PMAP_TIMEOUT		   __TEXT("Control Panel\\Accessibility\\TimeOut")
#define PMAP_SOUNDSENTRY	   __TEXT("Control Panel\\Accessibility\\SoundSentry")
#define PMAP_SHOWSOUNDS 	   __TEXT("Control Panel\\Accessibility\\ShowSounds")

#define ISACCESSFLAGSET(s, flag) ((s).dwFlags & flag)

#define SK_SPI_INITUSER -1

typedef int (*PSKEY_SPI)(
	UINT uAction, 
	UINT uParam, 
	LPSERIALKEYS lpvParam, 
	BOOL fuWinIni);


/****************************************************************************/

BOOL AccessSKeySystemParametersInfo(
	UINT uAction, 
	UINT uParam, 
	LPSERIALKEYS psk, 
	BOOL fu)
{
	BOOL fRet = FALSE;
    static PSKEY_SPI s_pSKEY_SystemParametersInfo =NULL;
    static BOOL s_fSKeySPIAttemptedLoad = FALSE;
#ifdef UNICODE
	static BOOL s_fMustConvert = FALSE;
	CHAR szActivePort[MAX_PATH]; 
	CHAR szPort[MAX_PATH]; 
	PWSTR pszActivePort = NULL; 
	PWSTR pszPort = NULL; 

	Assert(sizeof(szActivePort) == sizeof(g_szActivePort));
    Assert(sizeof(szPort) == sizeof(g_szPort));

#endif


	if (NULL == s_pSKEY_SystemParametersInfo && !s_fSKeySPIAttemptedLoad)
	{
		BOOL fRc = FALSE;
		HINSTANCE hinst = LoadLibrary(__TEXT("SKDLL.DLL"));

		if (NULL != hinst) 
		{

#ifdef UNICODE

			s_pSKEY_SystemParametersInfo = (PSKEY_SPI)GetProcAddress(
				(HMODULE)hinst, "SKEY_SystemParametersInfoW");
			if (NULL == s_pSKEY_SystemParametersInfo) 
			{
				s_pSKEY_SystemParametersInfo = (PSKEY_SPI)GetProcAddress(
					(HMODULE)hinst, "SKEY_SystemParametersInfo");
				s_fMustConvert = TRUE;
			}

#else
			s_pSKEY_SystemParametersInfo = (PSKEY_SPI)GetProcAddress(
				(HMODULE)hinst, "SKEY_SystemParametersInfo");

#endif // UNICODE

			// We don't bother calling FreeLibrary(hinst), the library will be freed
			// when the app terminates
		}
        s_fSKeySPIAttemptedLoad = TRUE;
	}

    if (NULL != s_pSKEY_SystemParametersInfo)
    {

#ifdef UNICODE

		if (s_fMustConvert) 
		{
            memset(szActivePort, 0, sizeof(szActivePort));
            memset(szPort, 0, sizeof(szPort));
            
	        pszActivePort = psk->lpszActivePort; 
            pszPort = psk->lpszPort; 

			if (NULL != psk->lpszActivePort)
			{
				psk->lpszActivePort = (PTSTR)szActivePort;
			}

			if (NULL != psk->lpszPort)
			{
				psk->lpszPort = (PTSTR)szPort; 
			}

            if (SPI_SETSERIALKEYS == uAction)
			{
				if (NULL != psk->lpszActivePort)
				{					
                    WideCharToMultiByte(
						CP_ACP, 0, pszActivePort, -1, 
						(PCHAR)psk->lpszActivePort, MAX_PATH, NULL, NULL);
				}
				if (NULL != psk->lpszPort)
				{				    
					WideCharToMultiByte(
						CP_ACP, 0, pszPort, -1, 
						(PCHAR)psk->lpszPort, MAX_PATH, NULL, NULL);
				}
			}
		}
#endif // UNICODE

		fRet = (BOOL)(*s_pSKEY_SystemParametersInfo)(
    		uAction, 
			uParam, 
			psk, 
			fu);
#ifdef UNICODE

		if (s_fMustConvert && SPI_GETSERIALKEYS == uAction) 
		{

			if (NULL != psk->lpszActivePort)
			{
				MultiByteToWideChar(
					CP_ACP, 0, (PCHAR)psk->lpszActivePort, -1,
					pszActivePort, MAX_PATH);
			}
			if (NULL != psk->lpszPort)
			{
				MultiByteToWideChar(
					CP_ACP, 0, (PCHAR)psk->lpszPort, -1,
					pszPort, MAX_PATH);
			}
		}
		if (NULL != psk->lpszActivePort)
		{
			psk->lpszActivePort = pszActivePort;
		}

		if (NULL != psk->lpszPort)
		{
			psk->lpszPort = pszPort; 
		}

#endif // UNICODE

    }
    return(fRet);
}


/***************************************************************************\
* FixupAndRetrySystemParametersInfo
*
* Used by access but not implemented by NT's SPI:
*
* SPI_GETKEYBOARDPREF
* SPI_SETKEYBOARDPREF
*
* SPI_GETHIGHCONTRAST
* SPI_SETHIGHCONTRAST
*
* SPI_GETSERIALKEYS
* SPI_SETSERIALKEYS
*
*
* History:
* 12-18-95 a-jimhar 	Created, derived from xxxSystemParametersInfo
* 01-22-95 a-jimhar 	Removed old code that worked around NT bugs
*
* On NT this function fixes the parameters and calls SystemParametersInfo
*
\***************************************************************************/

static BOOL FixupAndRetrySystemParametersInfo(
	UINT wFlag,
	DWORD wParam,
	PVOID lParam,
	UINT flags)	// we ignoring this flag 
				// could add support for SPIF_UPDATEINIFILE and SPIF_SENDCHANGE
{
	BOOL fRet = FALSE;
	BOOL fCallSpi = FALSE;
	BOOL fChanged = FALSE;

	if (NULL != (PVOID)lParam)
	{
		switch (wFlag) {


		// Fake support
		case SPI_GETKEYBOARDPREF:
			{
				*(PBOOL) lParam = FALSE;
				fRet = TRUE;
				fCallSpi = FALSE;
			}
			break;

		case SPI_GETSERIALKEYS:
            {
		        LPSERIALKEYS psk = (LPSERIALKEYS)lParam;

			    if (NULL != psk &&
			       (sizeof(*psk) == psk->cbSize || 0 == psk->cbSize))
			    {
					fRet = AccessSKeySystemParametersInfo(
						wFlag, 
						0, 
						psk, 
						TRUE);
                }
                fCallSpi = FALSE;
            }
			break;

		case SPI_SETSERIALKEYS:
            {
		        LPSERIALKEYS psk = (LPSERIALKEYS)lParam;

			    if (NULL != psk &&
			       (sizeof(*psk) == psk->cbSize || 0 == psk->cbSize))
			    {
					fRet = AccessSKeySystemParametersInfo(
						wFlag, 
						0, 
						psk, 
						TRUE);
	    			fChanged = TRUE;
                }
		        fCallSpi = FALSE;
            }
			break;

		default:
			// This function is only for fix-up and second chance calls.
			// We didn't fix anything, don't call SPI.
			fCallSpi = FALSE;
			fRet = FALSE;
			break;
		}
	}

	if (fCallSpi)
	{
		fRet = SystemParametersInfo(wFlag, wParam, lParam, flags);
	}
	else if (fChanged && (flags & SPIF_SENDCHANGE))
	{
        DWORD_PTR dwResult;

        SendMessageTimeout(
			HWND_BROADCAST, 
			WM_WININICHANGE, 
			wFlag, 
			(LONG_PTR)NULL,
            SMTO_NORMAL, 
			100, 
			&dwResult);
	}
	return(fRet);
}

/***************************************************************************\
* AccessSystemParametersInfo
*
* History:
* 12-18-95 a-jimhar 	Created.
\***************************************************************************/

BOOL AccessSystemParametersInfo(
	UINT wFlag,
	DWORD wParam,
	PVOID lParam,
	UINT flags)
{
	BOOL fRet;

	// first give the system SPI a chance

	fRet = SystemParametersInfo(wFlag, wParam, lParam, flags);

	if (!fRet && g_fWinNT)
	{
		// the system SPI failed, fixup the params and try again

		fRet = FixupAndRetrySystemParametersInfo(wFlag, wParam, lParam, flags);
	}

	return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\keybd.c ===
/*******************************************************************
 *    DESCRIPTION: Keyboard Dialog handler
 *******************************************************************/


#include "Access.h"
extern GetAccessibilitySettings();
extern BOOL g_SPISetValue;

extern BOOL g_bFKOn;
extern DWORD g_dwOrigFKFlags ;

extern LPTSTR HelpFile();

// *******************************************************************
// KeyboardDialog handler
// *******************************************************************
BOOL WINAPI KeyboardDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
   STICKYKEYS sk;       // Tmp holder for settings.
   FILTERKEYS fk;
   TOGGLEKEYS tk;
   BOOL fProcessed = TRUE;

   switch (uMsg) {
      case WM_INITDIALOG:
         CheckDlgButton(hwnd, IDC_STK_ENABLE, (g_sk.dwFlags & SKF_STICKYKEYSON) ? TRUE : FALSE);
         if (!(g_sk.dwFlags & SKF_AVAILABLE)) {
            EnableWindow(GetDlgItem(hwnd, IDC_STK_SETTINGS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_STK_ENABLE), FALSE);
         }

         CheckDlgButton(hwnd, IDC_FK_ENABLE, (g_fk.dwFlags & FKF_FILTERKEYSON) ? TRUE : FALSE);
         CheckDlgButton(hwnd, IDC_TK_ENABLE, (g_tk.dwFlags & TKF_TOGGLEKEYSON) ? TRUE : FALSE);
         if (!(g_tk.dwFlags & TKF_AVAILABLE)) {
            EnableWindow(GetDlgItem(hwnd, IDC_TK_SETTINGS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_TK_ENABLE), FALSE);
         }

         CheckDlgButton(hwnd, IDC_SHOWEXTRAKYBDHELP, g_fExtraKeyboardHelp);
         break;

    case WM_HELP:  // F1
         WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
         break;

    case WM_CONTEXTMENU:   // right mouse click
         WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
         break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDC_STK_ENABLE:
               g_sk.dwFlags ^= SKF_STICKYKEYSON;
               SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;

            case IDC_FK_ENABLE:
               g_fk.dwFlags ^= FKF_FILTERKEYSON;
               SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
			   g_bFKOn = !g_bFKOn;
               break;

            case IDC_TK_ENABLE:
               g_tk.dwFlags ^= TKF_TOGGLEKEYSON;
               SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;

            case IDC_STK_SETTINGS:
               sk = g_sk;
               if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_STICKYSETTINGS), hwnd, StickyKeyDlg) == IDCANCEL)
                  g_sk = sk;
               else SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;

            case IDC_FK_SETTINGS:
               fk = g_fk;
               if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_FILTERSETTINGS), hwnd, FilterKeyDlg) == IDCANCEL)
                  g_fk = fk;
               else SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;

            case IDC_TK_SETTINGS:
               tk = g_tk;
               if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_TOGGLESETTINGS), hwnd, ToggleKeySettingsDlg) == IDCANCEL) {
                  g_tk = tk;
               } else SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;

            case IDC_SHOWEXTRAKYBDHELP:
               g_fExtraKeyboardHelp = !g_fExtraKeyboardHelp;
               CheckDlgButton(hwnd, IDC_SHOWEXTRAKYBDHELP, g_fExtraKeyboardHelp);
               SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
               break;
         }
         break;

        case WM_SETTINGCHANGE:

            // This is because, When you setting the values could generate this
           /* if ( FALSE == g_SPISetValue )
            {
                // This needs to be monitered, as in the cases where settings chnage (say in 
                // case of hotkey press. The settings are re-loaded. This is done here so that
                // Keyboard dialog is shown first. a-anilk
                // NOTE: But if you get this up from system tary icons. BUG still EXISTS!!!
                GetAccessibilitySettings();
            }*/
            break;

      case WM_NOTIFY:
         switch (((NMHDR *)lParam)->code) {
            case PSN_APPLY: SetAccessibilitySettings(); break;
         }
         break;

      default: fProcessed = FALSE; break;
   }

   return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\display.c ===
/******************************************************************************
Module name: Display.C
Purpose: Display Dialog handler
******************************************************************************/


#ifdef UNICODE
#define _UNICODE
#endif

#include "tchar.h"
#include "Access.h"
#include "winuserp.h"

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#include "shlobj.h"

static BOOL s_fBlink = TRUE;
static RECT s_rCursor;

#define ARRAYSIZE( a )  (sizeof(a) / sizeof(a[0]))

LPTSTR HelpFile()
{
    static BOOL bFirstTime = TRUE;
    const TCHAR c_szHelp[] = TEXT("\\Help\\access.hlp");
    static TCHAR szHelpFilePath[MAX_PATH+ARRAYSIZE(c_szHelp)];

    if (bFirstTime)
    {
        LPTSTR pszDestEnd;
        size_t cchRemaining;
        szHelpFilePath[0] = TEXT('\0');
        if (GetSystemWindowsDirectory(szHelpFilePath, MAX_PATH))
        {
            int cch = lstrlen(szHelpFilePath);
            StringCchCopyEx(szHelpFilePath+cch, ARRAYSIZE(szHelpFilePath)-cch,
                c_szHelp,  &pszDestEnd, &cchRemaining, STRSAFE_NULL_ON_FAILURE);
        }
        bFirstTime = FALSE;
    }
    return (LPTSTR)szHelpFilePath;
}

//////////////////////////////////////////////////////////////////////////////
/*******************************************************************
 *	  DESCRIPTION: High Contrast dialog handler
 *******************************************************************/

VOID FillCustonSchemeBox (HWND hwndCB) {
    HKEY hkey;
    int i;
    DWORD dwDisposition;

    // Get the class name and the value count.
    if (RegCreateKeyEx(HKEY_CURRENT_USER, CONTROL_KEY, 0, __TEXT(""),
        REG_OPTION_NON_VOLATILE, KEY_ENUMERATE_SUB_KEYS | KEY_EXECUTE | KEY_QUERY_VALUE,
        NULL, &hkey, &dwDisposition) != ERROR_SUCCESS) return;

    // Enumerate the child keys.
    for (i = 0; ; i++) {
        DWORD cbValueName;
        TCHAR szValueName[MAX_SCHEME_NAME_SIZE];
        LONG l;

        cbValueName = MAX_SCHEME_NAME_SIZE;
        l = RegEnumValue(hkey, i, szValueName, &cbValueName, NULL, NULL, NULL, NULL);
        if (ERROR_NO_MORE_ITEMS == l) break;

        // Add each value to a combobox.
        if (lstrlen(szValueName) == 0) lstrcpy(szValueName, __TEXT("<NO NAME>"));
        ComboBox_AddString(hwndCB, ((szValueName[0] == 0) ? __TEXT("<NO NAME>") : szValueName));
    }
    RegCloseKey(hkey);
}



// ****************************************************************************
// Main HC Dialog handler
// ****************************************************************************
INT_PTR WINAPI HighContrastDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    HKEY  hkey;
    HWND  hwndCB = GetDlgItem(hwnd, IDC_HC_DEFAULTSCHEME);
    int   i;
    DWORD dwDisposition;
    BOOL  fProcessed = TRUE;

    switch (uMsg) {
    case WM_INITDIALOG:
        CheckDlgButton(hwnd, IDC_HC_HOTKEY, (g_hc.dwFlags & HCF_HOTKEYACTIVE) ? TRUE : FALSE);

        //
        // Put possible high contrast schemes in combo
        // box and show the current one
        //
        // ISSUE: If MUI is enabled then displaying the strings from the registry may
        //        be incorrect.  It should be in the language currently selected.

        FillCustonSchemeBox(hwndCB);

        // Set the proper selection in the combobox (handle case where it's not set yet)
        if (g_hc.lpszDefaultScheme[0] == 0) 
        {
            if (!IsMUI_Enabled())
            {
                // get scheme name from resources if not MUI enabled
                LoadString(g_hinst, IDS_WHITEBLACK_SCHEME, g_hc.lpszDefaultScheme, 200);
            }
            else
            {
                // else set scheme name in english
                lstrcpy(g_hc.lpszDefaultScheme, IDSENG_WHITEBLACK_SCHEME);
            }
        }
        if (ComboBox_SelectString(hwndCB, -1, g_hc.lpszDefaultScheme) == CB_ERR) {
            // Not found, select the 1st one 
            // TODO this is bad! When MUI enabled we will rarely find the correct scheme!
            ComboBox_SetCurSel(hwndCB, 0);
        }
        break;

    case WM_HELP:         // F1
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_CONTEXTMENU:  // right mouse click
        WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
        break;

   // Handle the generic commands
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_HC_HOTKEY:
               g_hc.dwFlags ^=  HCF_HOTKEYACTIVE;
               break;

        case IDC_HC_DEFAULTSCHEME:
               if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE) {
                       // Get the current string into our variable
                       i = ComboBox_GetCurSel(hwndCB);
                       ComboBox_GetLBText(hwndCB, i, g_hc.lpszDefaultScheme);
               }
               break;

        case IDOK:
               // Save the current custom scheme to the registry.
               if (ERROR_SUCCESS == RegCreateKeyEx(
                      HKEY_CURRENT_USER,
                      HC_KEY,
                      0,
                      __TEXT(""),
                      REG_OPTION_NON_VOLATILE,
                      KEY_EXECUTE | KEY_QUERY_VALUE | KEY_SET_VALUE,
                      NULL,
                      &hkey,
                      &dwDisposition)) {

                      TCHAR szCust[MAX_SCHEME_NAME_SIZE];

                      i = ComboBox_GetCurSel(hwndCB);
                      ComboBox_GetLBText(hwndCB, i, szCust);
                      // Abandon "Last Custom Scheme" (never written correctly (#954))
                      RegSetValueEx(hkey
                          , CURR_HC_SCHEME
                          , 0, REG_SZ
                          , (PBYTE) szCust
                          , lstrlen(szCust)*sizeof(TCHAR));
               }
               EndDialog(hwnd, IDOK);
               break;

        case IDCANCEL:
               EndDialog(hwnd, IDCANCEL);
               break;
        }
        break;

        default:
               fProcessed = FALSE; break;
   }
   return((INT_PTR) fProcessed);
}

void DrawCaret(HWND hwnd, BOOL fClearFirst)
{
    HWND hwndCursor = GetDlgItem(hwnd, IDC_KCURSOR_BLINK);
    HDC hDC = GetDC(hwnd);
    if (hDC)
    {
        HBRUSH hBrush;
        if (fClearFirst)
        {
            hBrush = GetSysColorBrush(COLOR_MENU);
            if (hBrush)
            {
                RECT rect;
                GetWindowRect(hwndCursor, &rect);
                MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT)&rect, 2);
                FillRect(hDC, &rect, hBrush);
                InvalidateRect(hwndCursor, &rect, TRUE);
            }
        }
        hBrush = GetSysColorBrush(COLOR_BTNTEXT);
        if (hBrush)
        {
            FillRect(hDC, &s_rCursor, hBrush);
            InvalidateRect(hwndCursor, &s_rCursor, TRUE);
        }
        ReleaseDC(hwnd,hDC);
    }
}

void OnTimer( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    if (wParam == BLINK)
    {
        BOOL fNoBlinkRate = (g_cs.dwNewCaretBlinkRate == CURSORMAX)?TRUE:FALSE;
        if (s_fBlink || fNoBlinkRate)
        {
            DrawCaret(hwnd, fNoBlinkRate);
        }
        else
	    {
            InvalidateRect(GetDlgItem(hwnd, IDC_KCURSOR_BLINK), NULL, TRUE);
	    }

        if (fNoBlinkRate)
            KillTimer(hwnd, wParam);

        s_fBlink = !s_fBlink;
    }
}

void OnHScroll( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    if ((HWND)lParam == GetDlgItem(hwnd, IDC_KCURSOR_RATE))
    {
        // blink rate setting

        int nCurrent = (int)SendMessage( (HWND)lParam, TBM_GETPOS, 0, 0L );
        g_cs.dwNewCaretBlinkRate = CURSORSUM - (nCurrent * 100);

        // reset the bink rate timer

        SetTimer(hwnd, BLINK, g_cs.dwNewCaretBlinkRate, NULL);

        if (g_cs.dwNewCaretBlinkRate == CURSORMAX) // draw the caret immediately; if we wait
            DrawCaret(hwnd, TRUE);      // for the timer there is a visible delay
        
        SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
    }
    else if ((HWND)lParam == GetDlgItem(hwnd, IDC_KCURSOR_WIDTH))
    {
        // cursor width setting

        g_cs.dwNewCaretWidth = (int)SendMessage( (HWND)lParam, TBM_GETPOS, 0, 0L );
	    
	    s_rCursor.right = s_rCursor.left + g_cs.dwNewCaretWidth;
        DrawCaret(hwnd, (g_cs.dwNewCaretBlinkRate == CURSORMAX));
        SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
    }
}

void InitCursorCtls(HWND hwnd)
{
    g_cs.dwNewCaretWidth = g_cs.dwCaretWidth;
    g_cs.dwNewCaretBlinkRate = g_cs.dwCaretBlinkRate;

    // Update the Caret UI
    SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_WIDTH), TBM_SETRANGE, 0, MAKELONG(1, 20));
    SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_WIDTH), TBM_SETPOS, TRUE, (LONG)g_cs.dwCaretWidth);

    SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_RATE), TBM_SETRANGE, 0, MAKELONG(CURSORMIN / 100, CURSORMAX / 100));
    SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_RATE), TBM_SETPOS, TRUE, (LONG)(CURSORSUM - g_cs.dwCaretBlinkRate) / 100);

    // Update Blink and caret size
    GetWindowRect(GetDlgItem(hwnd, IDC_KCURSOR_BLINK), &s_rCursor);
    MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT)&s_rCursor, 2);
    s_rCursor.right = s_rCursor.left + g_cs.dwCaretWidth;
}

// *******************************************************************
// DisplayDialog handler
// *******************************************************************
INT_PTR WINAPI DisplayDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
   HIGHCONTRAST hc;
   TCHAR szScheme[MAX_SCHEME_NAME_SIZE];
   BOOL fProcessed = TRUE;

   switch (uMsg) {
   case WM_INITDIALOG:
	  CheckDlgButton(hwnd, IDC_HC_ENABLE,
		 (g_hc.dwFlags & HCF_HIGHCONTRASTON) ? TRUE : FALSE);

	  if (!(g_hc.dwFlags & HCF_AVAILABLE)) {
		 EnableWindow(GetDlgItem(hwnd, IDC_HC_SETTINGS), FALSE);
		 EnableWindow(GetDlgItem(hwnd,IDC_HC_ENABLE), FALSE);
	  }
      InitCursorCtls(hwnd);
	  break;

   case WM_TIMER:
      OnTimer(hwnd, wParam, lParam);
      break;

   case WM_HSCROLL:
      OnHScroll(hwnd, wParam, lParam);
      break;

   case WM_HELP:
	  WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
	  break;

   case WM_CONTEXTMENU:
	  WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
	  break;

    // sliders don't get this message so pass it on
	case WM_SYSCOLORCHANGE:
		SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_WIDTH), WM_SYSCOLORCHANGE, 0, 0);
		SendMessage(GetDlgItem(hwnd, IDC_KCURSOR_RATE), WM_SYSCOLORCHANGE, 0, 0);
		break;

   case WM_COMMAND:
	  switch (GET_WM_COMMAND_ID(wParam, lParam)) {
	  case IDC_HC_ENABLE:
		 g_hc.dwFlags ^= HCF_HIGHCONTRASTON;
		 SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
		 break;

	  case IDC_HC_SETTINGS:
          {
              INT_PTR RetValue;

              hc = g_hc;
              lstrcpy(szScheme, g_hc.lpszDefaultScheme);
              RetValue = DialogBox(g_hinst, MAKEINTRESOURCE(IDD_HIGHCONSETTINGS), hwnd, HighContrastDlg);
              
              if ( RetValue == IDCANCEL) 
              {
                  g_hc = hc;
                  lstrcpy(g_hc.lpszDefaultScheme, szScheme);
              } 
              else 
              {
                  SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
              }
          }
          break;
	  }
	  break;

   case WM_NOTIFY:
	  switch (((NMHDR *)lParam)->code) {
	  case PSN_APPLY: SetAccessibilitySettings(); break;
      case PSN_KILLACTIVE: 
         KillTimer(hwnd, BLINK); 
         g_cs.dwCaretBlinkRate = g_cs.dwNewCaretBlinkRate;
         g_cs.dwCaretWidth = g_cs.dwNewCaretWidth;
         break;

      case PSN_SETACTIVE:
         SetTimer(hwnd
                , BLINK
                , (g_cs.dwNewCaretBlinkRate < CURSORMAX)?g_cs.dwNewCaretBlinkRate:0
                , NULL);
         break;
	  }
	  break;

   default:
	  fProcessed = FALSE;
	  break;
   }

   return(fProcessed);
}

BOOL IsMUI_Enabled()
{

    OSVERSIONINFO verinfo;
    LANGID        rcLang;
    HMODULE       hModule;
    pfnGetUserDefaultUILanguage gpfnGetUserDefaultUILanguage;     
    pfnGetSystemDefaultUILanguage gpfnGetSystemDefaultUILanguage; 
    static        g_bPFNLoaded=FALSE;
    static        g_bMUIStatus=FALSE;


    if(g_bPFNLoaded)
       return g_bMUIStatus;

    g_bPFNLoaded = TRUE;

    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);    
    GetVersionEx( &verinfo) ;

    if (verinfo.dwMajorVersion == 5)        
    {   

       hModule = GetModuleHandle(TEXT("kernel32.dll"));
       if (hModule)
       {
          gpfnGetSystemDefaultUILanguage =
          (pfnGetSystemDefaultUILanguage)GetProcAddress(hModule,"GetSystemDefaultUILanguage");
          if (gpfnGetSystemDefaultUILanguage)
          {
             rcLang = (LANGID) gpfnGetSystemDefaultUILanguage();
             if (rcLang == 0x409 )
             {  
                gpfnGetUserDefaultUILanguage =
                (pfnGetUserDefaultUILanguage)GetProcAddress(hModule,"GetUserDefaultUILanguage");
                
                if (gpfnGetUserDefaultUILanguage)
                {
                   if (rcLang != (LANGID)gpfnGetUserDefaultUILanguage() )
                   {
                       g_bMUIStatus = TRUE;
                   }

                }
             }
          }
       }
    }
    return g_bMUIStatus;
}



///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\general.c ===
/*******************************************************************
 *    DESCRIPTION: General Dialog handler
 *******************************************************************/

#include "Access.h"

extern INT_PTR WINAPI SerialKeyDlg(HWND, UINT, WPARAM, LPARAM);
extern LPTSTR HelpFile();

// *******************************************************************
// GeneralDialog handler
// *******************************************************************
INT_PTR WINAPI GeneralDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
   int i;
   SERIALKEYS serk;
   BOOL fProcessed = TRUE;
   char tempPort[10];   // Max 10 characters for a port name
   BOOL isAdmin = TRUE;

	switch (uMsg) {
		case WM_INITDIALOG:
        {
            TCHAR szMinutes[50];
            int ctch = LoadString(g_hinst, IDS_MINUTES, szMinutes, ARRAY_SIZE(szMinutes));
            Assert(ctch);
			CheckDlgButton(hwnd, IDC_TO_ENABLE, (g_ato.dwFlags & ATF_TIMEOUTON) ? TRUE : FALSE);

			// Init the timeout combobox
			for (i= 0; i < 6; i++) {
				TCHAR szBuf[256];
				wsprintf(szBuf, __TEXT("%d %s"), ((i + 1) * 5), szMinutes);
				ComboBox_AddString(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL), szBuf);
			}
			ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL), g_ato.iTimeOutMSec / (1000 * 60 * 5) - 1);
			if (!(g_ato.dwFlags & ATF_TIMEOUTON))
				EnableWindow(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL), FALSE);

            // Notification: Give wanring...         
			CheckDlgButton(hwnd, IDC_WARNING_SOUND, g_fShowWarnMsgOnFeatureActivate);				

            // Notification: Make a sound...
			CheckDlgButton(hwnd, IDC_SOUND_ONOFF, g_fPlaySndOnFeatureActivate);				

            // Support SerialKey devices
			CheckDlgButton(hwnd, IDC_SK_ENABLE, (g_serk.dwFlags & SERKF_SERIALKEYSON) ? TRUE : FALSE);
			if (!(g_serk.dwFlags & SERKF_AVAILABLE)) {
				EnableWindow(GetDlgItem(hwnd, IDC_SK_SETTINGS), FALSE);
				EnableWindow(GetDlgItem(hwnd, IDC_SK_ENABLE), FALSE);
			}

            // JMR: What is this for?
            CheckDlgButton(hwnd, IDC_SAVE_SETTINGS, !g_fSaveSettings);

		    // Administrative options: 
		    // Enable/Disable all admin options.
		    isAdmin = IsDefaultWritable();
		    EnableWindow(GetDlgItem(hwnd, IDC_GEN_GROUP_4), isAdmin);
		    EnableWindow(GetDlgItem(hwnd, IDC_ADMIN_LOGON), isAdmin);
		    EnableWindow(GetDlgItem(hwnd, IDC_ADMIN_DEFAULT), isAdmin);
        }
        break;

      case WM_HELP:
			WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
			break;

      case WM_CONTEXTMENU:
         WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
			break;

    	case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))  {
				case IDC_WARNING_SOUND:
					g_fShowWarnMsgOnFeatureActivate = !g_fShowWarnMsgOnFeatureActivate;
	    	      SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SOUND_ONOFF:
					g_fPlaySndOnFeatureActivate = !g_fPlaySndOnFeatureActivate;
	    	      SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SAVE_SETTINGS:
					g_fSaveSettings = !g_fSaveSettings;
	    	      SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_TO_ENABLE:
					g_ato.dwFlags ^= ATF_TIMEOUTON;
					if (!(g_ato.dwFlags & ATF_TIMEOUTON))
						EnableWindow(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL), FALSE);
					else
						EnableWindow(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL), TRUE);
	    	      SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SK_ENABLE:
					g_serk.dwFlags ^= SERKF_SERIALKEYSON;
	    	      SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SK_SETTINGS:

                    // HACK. Here the pointers are copied. So, When you change 
                    // in the dialog. temporary variable 'serk' looses its original value
                    // Save that in tempPort and use that instead a-anilk
					 serk = g_serk;
                     lstrcpy((LPTSTR)tempPort, g_serk.lpszActivePort);

					if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_SERKEYSETTING), hwnd, SerialKeyDlg) == IDCANCEL) 
                    {
                         g_serk = serk;
                         lstrcpy(g_serk.lpszActivePort, (LPCTSTR)tempPort);
                    }
					else SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_TO_TIMEOUTVAL:
					switch(HIWORD(wParam)) {
						case CBN_CLOSEUP:
							i = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_TO_TIMEOUTVAL));
							g_ato.iTimeOutMSec = (ULONG) ((long) ((i + 1) * 5) * 60 * 1000);
		                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
							break;
					}					
					break;
				case IDC_ADMIN_LOGON:
					g_fCopyToLogon = !g_fCopyToLogon;
					SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_ADMIN_DEFAULT:
					g_fCopyToDefault = !g_fCopyToDefault;
					SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;
			}
			break;

        case WM_NOTIFY:
			switch (((NMHDR *)lParam)->code) {
				case PSN_APPLY: SetAccessibilitySettings(); break;
			}
			break;

		default:
			fProcessed = FALSE;
			break;
	}
	return(fProcessed);
}

///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\main.c ===
// ********************************************************************
// Main.c
// Main init entry into the Human Accessibilities Control panel applet
// ********************************************************************

#include <assert.h>

#pragma comment(lib, "comctl32.lib")

#include "Access.h"

HINSTANCE g_hinst = NULL;

BOOL OpenAccessPropertySheet (HWND, int);

// Define our help data structure
const DWORD g_aIds[] = {
#if 1
   IDC_NO_HELP_1,			NO_HELP,
   IDC_STK_ENABLE,			IDH_STICKYKEYS_ENABLE,
   IDC_SK_TEXT,             IDH_STICKYKEYS_ENABLE,
   IDC_STK_SETTINGS,		IDH_STICKYKEYS_SETTINGS,
   IDC_FK_ENABLE,			IDH_FILTERKEYS_ENABLE,
   IDC_FK_TEXT,             IDH_FILTERKEYS_ENABLE,
   IDC_FK_SETTINGS,			IDH_FILTERKEYS_SETTINGS,
   IDC_TK_ENABLE,			IDH_TOGGLEKEYS_ENABLE,
   IDC_TK_TEXT,             IDH_TOGGLEKEYS_ENABLE,
   IDC_TK_SETTINGS,			IDH_TOGGLEKEYS_SETTINGS,
   IDC_STK_HOTKEY,			IDH_STICKYKEYS_HOTKEY,
   IDC_STK_TEXT,            IDH_STICKYKEYS_HOTKEY,
   IDC_STK_LOCK,			IDH_STICKYKEYS_LOCK,
   IDC_STK_2KEYS,			IDH_STICKYKEYS_2KEYS,
   IDC_STK_SOUNDMOD,		IDH_STICKYKEYS_SOUND,
   IDC_STK_STATUS,			IDH_STICKYKEYS_STATUS,
   IDC_FK_HOTKEY,			IDH_FILTERKEYS_HOTKEY,
   IDC_FK_TEXT1,            IDH_FILTERKEYS_HOTKEY,
   IDC_FK_REPEAT,			IDH_FILTERKEYS_REPEATKEYS,
   IDC_BK_SETTINGS,                     IDH_FILTERKEYS_BKSETTINGS,
   IDC_FK_BOUNCE,			IDH_FILTERKEYS_BOUNCEKEYS,
   IDC_RK_SETTINGS,			IDH_FILTERKEYS_SETTINGS_REPEAT,
   IDC_FK_TESTBOX,			IDH_FILTERKEYS_TESTBOX,
   IDC_FK_SOUND,			IDH_FILTERKEYS_BEEPONKEYPRESS,
   IDC_FK_STATUS,			IDH_FILTERKEYS_SPAWNSTATUSAPP,
   IDC_RK_NOREPEAT,			IDH_FILTERKEYS_NO_REPEAT,
   IDC_RK_REPEAT,			IDH_FILTERKEYS_SLOW,
   IDC_RK_DELAYRATE_LBL,        IDH_REPEAT_DELAY,
   IDC_CMB_RK_DELAYRATE,        IDH_FILTERKEYS_DELAY,
   IDC_RK_REPEATRATE_LBL,   IDH_REPEAT_RATE,
   IDC_CMB_RK_REPEATRATE,           IDH_FILTERKEYS_RATE,
   IDC_RK_ACCEPTRATE_LBL,       IDH_VALID_KEY_TIME,
   IDC_CMB_RK_ACCEPTRATE,		IDH_FILTERKEYS_KEYSPEED,
   IDC_RK_TESTBOX,			IDH_FILTERKEYS_TEST1,
   IDC_BK_TIME_LBL1,            IDH_FILTERKEYS_IGNORE_REPEAT,
   IDC_BK_TIME_LBL2,            IDH_KEY_PRESS_TIME,
   IDC_CMB_BK_BOUNCERATE,           IDH_FILTERKEYS_IGNORE_REPEAT,
   IDC_BK_TESTBOX,			IDH_FILTERKEYS_TEST2,
   IDC_TK_HOTKEY,			IDH_TOGGLEKEYS_HOTKEY,
   IDC_TK_TEXT1,            IDH_TOGGLEKEYS_HOTKEY,
   IDC_SS_ENABLE_SOUND,		IDH_SOUNDSENTRY_ENABLE,
   IDC_SS_TEXT,             IDH_SOUNDSENTRY_ENABLE,
   IDC_SS_ENABLE_SHOW,		IDH_SHOWSOUNDS_ENABLE,
   IDC_SS_TEXT1,            IDH_SHOWSOUNDS_ENABLE,
   IDC_SS_WINDOWED,			IDH_SOUNDSENTRY_WINDOWED,
   IDC_SS_CHOOSE,           IDH_SOUNDSENTRY_WINDOWED,
   IDC_HC_ENABLE,			IDH_HIGHCONTRAST_ENABLE,
   IDC_HC_TEXT,             IDH_HIGHCONTRAST_ENABLE,
   IDC_HC_SETTINGS,			IDH_HIGHCONTRAST_SETTINGS,
   IDC_HC_HOTKEY,			IDH_HIGHCONTRAST_HOTKEY,
   IDC_HC_TEXT1,            IDH_HIGHCONTRAST_HOTKEY,
   IDC_KCURSOR_RATE,            IDH_KCURSOR_RATE,
   IDC_KCUR_TEXT_RATE,          IDH_KCURSOR_RATE,
   IDC_KCUR_TEXT_NONE,               IDH_KCURSOR_RATE,
   IDC_KCUR_TEXT_FAST,               IDH_KCURSOR_RATE,
   IDC_KCURSOR_WIDTH,           IDH_KCURSOR_WIDTH,
   IDC_KCUR_TEXT_WIDTH,         IDH_KCURSOR_WIDTH,
   IDC_KCUR_TEXT_NARR,              IDH_KCURSOR_WIDTH,
   IDC_KCUR_TEXT_WIDE,              IDH_KCURSOR_WIDTH,
   IDC_KCURSOR_OPTS,        IDH_KCURSOR_OPTS,
   IDC_HC_DEFAULTSCHEME,	IDH_HIGHCONTRAST_DEFAULTSCHEME,
   IDC_HC_CURSCHEME,        IDH_HIGHCONTRAST_DEFAULTSCHEME,
   IDC_MK_ENABLE,			IDH_MOUSEKEYS_ENABLE,
   IDC_MK_TEXT,             IDH_MOUSEKEYS_ENABLE,
   IDC_MK_SETTINGS,			IDH_MOUSEKEYS_SETTINGS,
   IDC_MK_HOTKEY,			IDH_MOUSEKEYS_HOTKEY,
   IDC_MK_TEXT1,            IDH_MOUSEKEYS_HOTKEY,
   IDC_MK_TOPSPEED,			IDH_MOUSEKEYS_MAXSPEED,
   IDC_MK_SPEED,             IDH_MOUSEKEYS_MAXSPEED,
   IDC_MK_SPEED_LOW,         IDH_MOUSEKEYS_MAXSPEED,
   IDC_MK_SPEED_HIGH,        IDH_MOUSEKEYS_MAXSPEED,
   IDC_MK_ACCEL,			IDH_MOUSEKEYS_ACCELERATION,
   IDC_MK_ACCELER,  		IDH_MOUSEKEYS_ACCELERATION,
   IDC_MK_ACCELER_SLOW,     IDH_MOUSEKEYS_ACCELERATION,
   IDC_MK_ACCELER_FAST,     IDH_MOUSEKEYS_ACCELERATION,
   IDC_MK_USEMODKEYS,		IDH_MOUSEKEYS_USEMODIFIERKEYS,
   IDC_MK_NLOFF,			IDH_MOUSEKEYS_NUMLOCKMODE,
   IDC_MK_NLON,				IDH_MOUSEKEYS_NUMLOCKMODE,
   IDC_MK_TEXT2,            IDH_MOUSEKEYS_NUMLOCKMODE,
   IDC_MK_STATUS,			IDH_MOUSEKEYS_SPAWNSTATUSAPP,
//   IDC_SAVE_SETTINGS,           IDH_ACCESS_SAVESETTINGS,
   IDC_TO_ENABLE,			IDH_ACCESS_TIMEOUT,
   IDC_TO_TIMEOUTVAL,                   IDH_ACCESS_TIMEOUT,
   IDC_WARNING_SOUND,		IDH_ACCESS_CONFIRMHOTKEY,
   IDC_SOUND_ONOFF,			IDH_ACCESS_SOUNDONHOTKEY,
   IDC_SK_ENABLE,			IDH_SERIALKEYS_ENABLE,
   IDC_SERKEY_TEXT,         IDH_SERIALKEYS_ENABLE,
   IDC_SK_SETTINGS,			IDH_SERIALKEYS_SETTINGS,
   IDC_SK_PORT,				IDH_SERIALKEYS_SERIAL,
   IDC_SK_PORTEXT,          IDH_SERIALKEYS_SERIAL,
   IDC_SK_BAUD,				IDH_SERIALKEYS_BAUD,
   IDC_SK_BAUD_TEXT,        IDH_SERIALKEYS_BAUD,
   IDC_CHECK1,                          IDH_SHOW_KEYBOARD_HELP,
   IDC_ADMIN_LOGON,          2010,
   IDC_ADMIN_DEFAULT,        2011,
#endif
   0, 0
} ;

// ************************************************************************
// Our entry point...
// ************************************************************************
BOOL WINAPI DllMain (HANDLE hinstDll, DWORD dwReason, LPVOID lpReserved) {
	switch (dwReason) {
      case DLL_PROCESS_ATTACH:   g_hinst = hinstDll; break;
      case DLL_PROCESS_DETACH:   break;
      case DLL_THREAD_DETACH:    break;
      case DLL_THREAD_ATTACH:    break;
   }
   return(TRUE);
}

#define SPI_OFF(T, M) \
{ \
	T s; \
	s.cbSize = sizeof(T); \
	if (!SystemParametersInfo(SPI_GET##T, s.cbSize, &s, 0)) \
		return E_FAIL; \
 \
	if (s.dwFlags & M) \
	{ \
		s.dwFlags &= ~M; \
		if (!SystemParametersInfo(SPI_SET##T, s.cbSize, &s, 0)) \
			return E_FAIL; \
	} \
}

HRESULT WINAPI DllUnregisterServer(void)
{
	SPI_OFF(FILTERKEYS, FKF_HOTKEYACTIVE)
	SPI_OFF(HIGHCONTRAST, HCF_HOTKEYACTIVE)
	SPI_OFF(MOUSEKEYS, MKF_HOTKEYACTIVE)
	SPI_OFF(STICKYKEYS, SKF_HOTKEYACTIVE)
	SPI_OFF(TOGGLEKEYS, TKF_HOTKEYACTIVE)
	return S_OK;
}

HRESULT WINAPI DllRegisterServer(void)
{
	return S_OK;
}


// This is the RUNDLLPROC prototype
// I got it from Win95 source code \WIN\CORE\SHELL\CPLS\MSPRINT\MSPRINT\MSPRINT.C
// It should be in some Windows header file but I could not find it!
typedef VOID (WINAPI *RUNDLLPROC)(HWND, HINSTANCE, LPTSTR, int);

VOID WINAPI DebugMain (HWND hwnd, HINSTANCE hinstExe, LPSTR pszCmdLine, int nCmdShow) {
   OpenAccessPropertySheet(hwnd, 0);
}


/////////////////////////////////////////////////////////////////////////////
// CplApplet:
// The main applet information manager.
/////////////////////////////////////////////////////////////////////////////
LONG WINAPI CPlApplet (HWND hwnd, UINT uMsg, LPARAM lParam1, LPARAM lParam2) {

   LONG lRetVal = TRUE;

   switch (uMsg) {
      case CPL_INIT:
         // If initialization is successful, return TRUE; else FALSE
         break;

      case CPL_GETCOUNT:
         // There is only 1 applet in this DLL
         lRetVal = 1;
         break;

      case CPL_INQUIRE:
         Assert(lParam1 == 0);   // Applet number in the DLL
         #define lpOldCPlInfo ((LPCPLINFO) lParam2)
         lpOldCPlInfo->idIcon = IDI_ACCESS;
         lpOldCPlInfo->idName = IDS_ACCESS;
         lpOldCPlInfo->idInfo = IDS_ACCESSINFO;
         lpOldCPlInfo->lData = 0;
         break;

      case CPL_NEWINQUIRE:
         Assert(lParam1 == 0);   // Applet number in the DLL
         #define lpCPlInfo ((LPNEWCPLINFO) lParam2)
         lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
         lpCPlInfo->dwFlags = 0;
         lpCPlInfo->dwHelpContext = 0;
         lpCPlInfo->lData = 0;
         lpCPlInfo->hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ACCESS));
         LoadString(g_hinst, IDS_ACCESS, lpCPlInfo->szName, ARRAY_SIZE(lpCPlInfo->szName));
         LoadString(g_hinst, IDS_ACCESSINFO, lpCPlInfo->szInfo, ARRAY_SIZE(lpCPlInfo->szInfo));
         lpCPlInfo->szHelpFile[0] = 0;
         #undef lpCPlInfo
         lRetVal = 1;      // Tell the system that we responded to this message
         // Returning 1 causes the system to NOT send the CPL_INQUIRE message
         break;

      case CPL_STARTWPARMS:
         Assert(lParam1 == 0);   // Applet number in the DLL
         OpenAccessPropertySheet(hwnd, (int) ((* (PBYTE) lParam2) - 0x31));
         lRetVal = TRUE;
         break;

      case CPL_DBLCLK:
         Assert(lParam1 == 0);   // Applet number in the DLL
         OpenAccessPropertySheet(hwnd, 0);
         lRetVal = 0;      // Success
         break;

      case CPL_EXIT:
         // Free up any allocations of resources made.
         // If de-initialization is successful, return TRUE; else FALSE
         break;
   }
   return(lRetVal);
}

// ***********************************************************************
// FeatureUnavailible
// Show the "I can't do that" dialog box for features that are currently
// disabled.
// ***********************************************************************

void FeatureUnavailible (HWND hwnd) {
   TCHAR szTitle[100];
   TCHAR szText[256];

   if (LoadString(g_hinst, IDS_UNAVAIL_TITLE, szTitle, ARRAY_SIZE(szTitle)))
      if (LoadString(g_hinst, IDS_UNAVAIL_TEXT, szText, ARRAY_SIZE(szText)))
         MessageBox(hwnd, szText, szTitle, MB_OK);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\fltrkeys.c ===
// **************************************************************************
// Filterkeys dialogs
// Process the filterkeys dialogs
// **************************************************************************


#include "Access.h"

extern DWORD g_dwOrigFKFlags;
extern BOOL g_bFKOn;
extern LPTSTR HelpFile();

#define SWAP(A, B)   ( A ^= B, B ^= A, A ^= B )

// Prototypes
INT_PTR WINAPI BKDlg (HWND, UINT, WPARAM, LPARAM);
INT_PTR WINAPI RKDlg (HWND, UINT, WPARAM, LPARAM);
BOOL WINAPI NotificationDlg (HWND, UINT, WPARAM, LPARAM);
BOOL SubclassFilterKeysTestBox (UINT uIdTestBox,HWND hDlg);
BOOL SubclassRepeatKeysTestBox (UINT uIdTestBox,HWND hDlg);

// All these are for subclassing, so that pressing TAB stops at the next 
// control after test areas. a-anilk
LRESULT CALLBACK SubclassWndProcFKPrev(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
LRESULT CALLBACK SubclassWndProcFKNext(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
LRESULT CALLBACK SubclassWndProcRKPrev(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
LRESULT CALLBACK SubclassWndProcRKNext(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

// Times are in milliseconds
#define DELAYSIZE	5
UINT uDelayTable[] = { 300, 700, 1000, 1500, 2000 };

// Times are in milliseconds
#define RATESIZE 6
UINT uRateTable[] = { 300, 500, 700, 1000, 1500, 2000 };

// Times are in milliseconds
#define BOUNCESIZE 5
UINT uBounceTable[] = { 500, 700, 1000, 1500, 2000 };

// Times are in milliseconds
// TODO 5, 10, and 20 sec needs change to kernel code (SystemParametersInfo)
#define ACCEPTSIZE 10
UINT uAcceptTable[] = { 0, 300, 500, 700, 1000, 1400, 2000, 5000, 10000, 20000 };

// these are wndprocs for subclassed windows to ignore repeated tab keys in
// some situations.
WNDPROC g_WndProcFKPrev = NULL;
WNDPROC g_WndProcFKNext = NULL;
WNDPROC g_WndProcRKPrev = NULL;
WNDPROC g_WndProcRKNext = NULL;

// other definitions for the keyboard
// UP means key was up before this message, DOWN means key was down
// PRESS means the key is being pressed, RELEASE means key being released

#define KEY_UP      0
#define KEY_DOWN    1

#define KEY_PRESS   0
#define KEY_RELEASE 1

// Macros to look at the lParam of keyboard messages
//
#define SCAN_CODE(theParam)  (LOBYTE (HIWORD(theParam)))
#define EXTENDED(theParam)   ( (HIWORD (theParam) & 0x0100) > 0)
#define SYSKEY(theParam)     ( (HIWORD (theParam) & 0x2000) > 0)
#define MENUMODE(theParam)   ( (HIWORD (theParam) & 0x1000) > 0)
#define PREV_STATE(theParam) ( (HIWORD (theParam) & 0x4000) > 0)
#define TRAN_STATE(theParam) ( (HIWORD (theParam) & 0x8000) > 0)

#define MAKE(theParam)    (TRAN_STATE(theParam) == KEY_PRESS)
#define BREAK(theParam)   (TRAN_STATE(theParam) == KEY_RELEASE)
#define WASUP(theParam)   (PREV_STATE(theParam) == KEY_UP)
#define WASDOWN(theParam) (PREV_STATE(theParam) == KEY_DOWN)

#define FIRSTHIT(theParam) (WASUP(theParam) && MAKE(theParam))

// *************************************************************************
// Process the scrolling messages from our trackbars.
// GENERIC CODE - called for any TrackBar handler.
// Passed in the hwnd, wParam, hwndScroll
// 	we can do all handling and return the new trackbar value without
//    knowing what control it is.
// Returns -1 to mean don't do anything 
// *************************************************************************

int HandleScroll (HWND hwnd, WPARAM wParam, HWND hwndScroll) {
    int nCurSliderPos = (int) SendMessage(
            hwndScroll, TBM_GETPOS, 0, 0);
    int nMaxVal = (int) SendMessage(
                            hwndScroll, TBM_GETRANGEMAX, 0, 0);
    int nMinVal = (int) SendMessage(
                            hwndScroll, TBM_GETRANGEMIN, 0, 0);

    switch (LOWORD(wParam)) {
    case TB_LINEUP:
    case TB_LINEDOWN:
    case TB_THUMBTRACK:
    case TB_THUMBPOSITION:
    case SB_ENDSCROLL:
        break;

    case TB_BOTTOM:
        nCurSliderPos = nMaxVal;
        break;

    case TB_TOP:
        nCurSliderPos = nMinVal;
        break;
    }

    if (nCurSliderPos < nMinVal)
    {
        nCurSliderPos = nMinVal;
    }

    if (nCurSliderPos > nMaxVal)
    {
        nCurSliderPos = nMaxVal;
    }

   SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
   return(nCurSliderPos);
}

// Helper functions

__inline WriteFloat(LPTSTR pszBuf, UINT uVal, LPCTSTR pszUnits)
{
    wsprintf(pszBuf, TEXT("%d.%d %s"), uVal/1000, (uVal % 1000)/100, pszUnits);
}

__inline void HandleSelection(HWND hwnd, UINT *puTable, DWORD *pdwNewValue)
{
    LRESULT i = SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    *pdwNewValue = (i != CB_ERR)?puTable[i]:0;
}

int GetIndex(DWORD dwValue, UINT *puTable, int cSize)
{
    int i;
    for (i = 0; i < cSize; i++) 
    {
        if (puTable[i] >= dwValue) 
            break;
    }

    if (i >= cSize) 
        i = cSize - 1;

    return i;
}

void FillAndSetCombo(HWND hwnd, UINT *puTable, int cItems, int iCurPos, LPCTSTR pszUnits)
{
    int i;
    TCHAR pszItem[100];

    SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
    for (i=0;i<cItems;i++)
    {
        WriteFloat(pszItem, puTable[i], pszUnits);
        SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)pszItem);
    }
    SendMessage(hwnd, CB_SETCURSEL, iCurPos, 0);
}

void TestFilterKeys (BOOL fTurnTestOn)
{
	if (fTurnTestOn) 
	{
		g_fk.dwFlags &= ~FKF_INDICATOR;
		g_fk.dwFlags |= FKF_FILTERKEYSON;
	} 
	else 
	{
		if (g_dwOrigFKFlags & FKF_FILTERKEYSON)
		{
			g_fk.dwFlags |= FKF_FILTERKEYSON;
		}
		else
		{
			g_fk.dwFlags &= ~FKF_FILTERKEYSON;
		}

		if (g_dwOrigFKFlags & FKF_INDICATOR)
		{
			g_fk.dwFlags |= FKF_INDICATOR;
		}
		else
		{
			g_fk.dwFlags &= ~FKF_INDICATOR;
		}
	}

	AccessSystemParametersInfo(SPI_SETFILTERKEYS, sizeof(g_fk), &g_fk, 0);
}


// ****************************************************************************
// Main filter keys dialog handler
// ****************************************************************************

INT_PTR WINAPI FilterKeyDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    FILTERKEYS fk;
    BOOL fProcessed = TRUE;

    switch (uMsg) {
    case WM_INITDIALOG:
        // Setup hotkey
        CheckDlgButton(hwnd, IDC_FK_HOTKEY, (g_fk.dwFlags & FKF_HOTKEYACTIVE) ? TRUE : FALSE);

        // Setup the radio buttons for SLOW vs BOUNCE keys
        if (0 != g_fk.iBounceMSec) {
            // Bounce keys enabeled
            CheckRadioButton(hwnd, IDC_FK_BOUNCE, IDC_FK_REPEAT, IDC_FK_BOUNCE);
            EnableWindow(GetDlgItem(hwnd, IDC_BK_SETTINGS), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_RK_SETTINGS), FALSE);
        }
        else
        {
            // Slow key enabled
            CheckRadioButton(hwnd, IDC_FK_BOUNCE, IDC_FK_REPEAT, IDC_FK_REPEAT);
            EnableWindow(GetDlgItem(hwnd, IDC_BK_SETTINGS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_RK_SETTINGS), TRUE);
        }

        CheckDlgButton(hwnd, IDC_FK_SOUND, (g_fk.dwFlags & FKF_CLICKON) ? TRUE : FALSE);
        CheckDlgButton(hwnd, IDC_FK_STATUS, (g_fk.dwFlags & FKF_INDICATOR) ? TRUE : FALSE);
        // 
        // SteveDon 5/15/98
        // If the focus is in the TestBox and "Ignore Quick Keystrokes" is on,
        // you have to hold down tab to get out. But as soon as focus leaves,
        // Ignore Quick Keystrokes gets turned off and the tab keys ends up
        // autorepeating very quickly, which (usually) lands you back in the 
        // TestBox. 
        // Solution: ignore repeated tabs in this dialog.
        // Problem: keys don't go to the dialog, they go to the focused
        // control. So: we can try to ignore repeated tab keys for the controls
        // just after the test box and just before the test box, which means 
        // that we need to subclass those window procs.
        if (!SubclassFilterKeysTestBox (IDC_FK_TESTBOX,hwnd))
            return (FALSE);

        break;

    case WM_HELP:
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
        break;
         
    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
               break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_FK_HOTKEY:
            g_fk.dwFlags ^= FKF_HOTKEYACTIVE;
            break;

        case IDC_FK_REPEAT:
            g_fk.iBounceMSec = 0;

            if (g_fk.iDelayMSec == 0)
            {
               g_fk.iDelayMSec = g_nLastRepeatDelay;
               g_fk.iRepeatMSec = g_nLastRepeatRate;
               g_fk.iWaitMSec = g_nLastWait;
            }

            CheckRadioButton(hwnd, IDC_FK_REPEAT, IDC_FK_BOUNCE, IDC_FK_REPEAT);
            EnableWindow(GetDlgItem(hwnd, IDC_BK_SETTINGS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_RK_SETTINGS), TRUE);
            break;

        case IDC_FK_BOUNCE:
            g_fk.iDelayMSec = 0;
            g_fk.iRepeatMSec = 0;
            g_fk.iWaitMSec = 0;

            if (g_fk.iBounceMSec == 0)
            {
                g_fk.iBounceMSec = g_dwLastBounceKeySetting;
            }

            CheckRadioButton(hwnd, IDC_FK_REPEAT, IDC_FK_BOUNCE, IDC_FK_BOUNCE);
            EnableWindow(GetDlgItem(hwnd, IDC_BK_SETTINGS), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_RK_SETTINGS), FALSE);
            break;

        // Settings dialogs
        case IDC_RK_SETTINGS:  // This is RepeatKeys
            fk = g_fk;
            if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_ADVCHARREPEAT), hwnd, RKDlg) == IDCANCEL) {
                    g_fk = fk;
            }
            break;

        case IDC_BK_SETTINGS:    // This is BounceKeys
            fk = g_fk;
            if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_ADVKEYBOUNCE), hwnd, BKDlg) == IDCANCEL) {
                    g_fk = fk;
            }
            break;

        case IDC_FK_SOUND:
            g_fk.dwFlags ^= FKF_CLICKON;
            break;

        case IDC_FK_STATUS:
            g_fk.dwFlags ^= FKF_INDICATOR;
            break;

        // The test edit box is a special control for us.  When we get the
        // focus we turn on the current filterkeys settings, when we
        // leave the text box, we turn them back to what they were.
        case IDC_FK_TESTBOX:
            switch (HIWORD(wParam)) {
            case EN_SETFOCUS:  TestFilterKeys(TRUE); break;
            case EN_KILLFOCUS: TestFilterKeys(FALSE); break;
            }
            break;

        case IDOK:
            if (g_dwLastBounceKeySetting == 0)
                g_dwLastBounceKeySetting = uBounceTable[0];
            EndDialog(hwnd, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;
        }
        break;

    default:
        fProcessed = FALSE; break;
    }
    return(fProcessed);
}


void PutNumInEdit (HWND hwndEdit, int nNum) 
{
   TCHAR szBuf[10], szBuf2[20];
   wsprintf(szBuf, __TEXT("%d.%d"), nNum / 1000, (nNum % 1000) / 100);
   GetNumberFormat(LOCALE_USER_DEFAULT, 0, szBuf, NULL, szBuf2, 20);
   SetWindowText(hwndEdit, szBuf2);
}


// **************************************************************************
// BKDlg
// Process the BounceKeys dialog.
// **************************************************************************
INT_PTR WINAPI BKDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    int     i;
    BOOL fProcessed = TRUE;
    TCHAR pszSeconds[50];
    int ctch;
   
    switch (uMsg) {
    case WM_INITDIALOG:
        ctch = LoadString(g_hinst, IDS_SECONDS, pszSeconds, ARRAY_SIZE(pszSeconds));
        Assert(ctch);
        // Determine the bounce.  Make sure its a valide value.
        if (g_dwLastBounceKeySetting == 0)
            g_dwLastBounceKeySetting = 500;

        if (g_fk.iBounceMSec == 0)
            g_fk.iBounceMSec = g_dwLastBounceKeySetting;

        i = GetIndex(g_fk.iBounceMSec, uBounceTable, BOUNCESIZE);
        FillAndSetCombo(GetDlgItem(hwnd, IDC_CMB_BK_BOUNCERATE), uBounceTable, BOUNCESIZE, i, pszSeconds);
        break;

    case WM_HELP:      // F1
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        // The test edit box is a special control for us.  When we get the
        // focus we turn on the current filterkeys settings, when we
        // leave the text box, we turn them back to what they were.
        case IDC_BK_TESTBOX:
            switch (HIWORD(wParam)) {
            case EN_SETFOCUS:  TestFilterKeys(TRUE); break;
            case EN_KILLFOCUS: TestFilterKeys(FALSE); break;
            }
            break;
        
        case IDC_CMB_BK_BOUNCERATE:
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                HandleSelection(GetDlgItem(hwnd, IDC_CMB_BK_BOUNCERATE), uBounceTable, &g_fk.iBounceMSec);
                break;
            }
            break;

        case IDOK:
            // Save the last known valid setting.
            g_dwLastBounceKeySetting = g_fk.iBounceMSec;
            EndDialog(hwnd, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;
        }
        break;

    default: fProcessed = FALSE; break;
    }
    return(fProcessed);
}

// **************************************************************************
// RKDlg
// Process the RepeatKeys dialog.
// **************************************************************************

INT_PTR WINAPI RKDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    int     i;
    BOOL  fProcessed = TRUE;
    static s_fRepeating = TRUE;
    static DWORD s_nLastRepeatDelayOld;
    static DWORD s_nLastRepeatRateOld;
    static DWORD s_nLastWaitOld;
    TCHAR pszItem[100];
    TCHAR pszSeconds[50];
    int ctch;
    LPARAM lParamT;

    switch(uMsg) {
    case WM_INITDIALOG:
        ctch = LoadString(g_hinst, IDS_SECONDS, pszSeconds, ARRAY_SIZE(pszSeconds));
        Assert(ctch);

        s_nLastRepeatDelayOld = g_nLastRepeatDelay;
        s_nLastRepeatRateOld = g_nLastRepeatRate;
        s_nLastWaitOld = g_nLastWait;

        s_fRepeating = (0 != g_fk.iDelayMSec);
        CheckRadioButton(hwnd, IDC_RK_NOREPEAT, IDC_RK_REPEAT,
             s_fRepeating ? IDC_RK_REPEAT : IDC_RK_NOREPEAT);

        if (!s_fRepeating) {
            // Set FilterKey values to LastRepeat values
            // so the sliders will still get initialized correctly
            g_fk.iDelayMSec = g_nLastRepeatDelay;
            g_fk.iRepeatMSec = g_nLastRepeatRate;
        }

        // Initialize the Acceptance combo box to last valid state
        i = GetIndex(g_fk.iWaitMSec, uAcceptTable, ACCEPTSIZE);
        FillAndSetCombo(GetDlgItem(hwnd, IDC_CMB_RK_ACCEPTRATE), uAcceptTable, ACCEPTSIZE, i, pszSeconds);
        g_fk.iWaitMSec = uAcceptTable[i];

        // Initialize the Delay combo box
        i = GetIndex(g_fk.iDelayMSec, uDelayTable, DELAYSIZE);
        FillAndSetCombo(GetDlgItem(hwnd, IDC_CMB_RK_DELAYRATE), uDelayTable, DELAYSIZE, i, pszSeconds);
        g_fk.iDelayMSec = uDelayTable[i];

        // Initialize the Repeat Rate Slider  Note -1 is set via the checkbox.
        i = GetIndex(g_fk.iRepeatMSec, uRateTable, RATESIZE);
        FillAndSetCombo(GetDlgItem(hwnd, IDC_CMB_RK_REPEATRATE), uRateTable, RATESIZE, i, pszSeconds);
        g_fk.iRepeatMSec = uRateTable[i];

        // Now cleanup from initialization. Disable controls
        // that usable... Swap back any params needed
        if (!s_fRepeating) 
        {
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_REPEATRATE), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_DELAYRATE), FALSE);

            // If we're not repeating, now set the value to 0
            // which indicates max repeat rate.
            g_fk.iDelayMSec = 0;
            g_fk.iRepeatMSec = 0;
        }
        // 
        // SteveDon 5/15/98
        // If the focus is in the TestBox and "Ignore Quick Keystrokes" is on,
        // you have to hold down tab to get out. But as soon as focus leaves,
        // Ignore Quick Keystrokes gets turned off and the tab keys ends up
        // autorepeating very quickly, which (usually) lands you back in the 
        // TestBox. 
        // Solution: ignore repeated tabs in this dialog.
        // Problem: keys don't go to the dialog, they go to the focused
        // control. So: we can try to ignore repeated tab keys for the controls
        // just after the test box and just before the test box, which means 
        // that we need to subclass those window procs.
        if (!SubclassRepeatKeysTestBox (IDC_RK_TESTBOX,hwnd))
            return (FALSE);
        break;

    case WM_HELP:      // F1
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        // Turn on repeat keys - We're disabling via CPL rather than any flags in the call
        case IDC_RK_REPEAT:
            if (!s_fRepeating) {
                g_fk.iDelayMSec = g_nLastRepeatDelay;
                g_fk.iRepeatMSec = g_nLastRepeatRate;
            }

            // Now that we have valid parameters, continue with setting the sliders.
            s_fRepeating = TRUE;
            CheckRadioButton(hwnd, IDC_RK_NOREPEAT, IDC_RK_REPEAT, IDC_RK_REPEAT);
            if (g_fk.iRepeatMSec == 0) 
                g_fk.iRepeatMSec = uRateTable[0];
            if (g_fk.iDelayMSec == 0)
                g_fk.iDelayMSec = uDelayTable[0];

            i = GetIndex(g_fk.iRepeatMSec, uRateTable, RATESIZE);
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_REPEATRATE), TRUE);
            SendDlgItemMessage(hwnd, IDC_CMB_RK_REPEATRATE, CB_SETCURSEL, i, 0);
            i = GetIndex(g_fk.iDelayMSec, uDelayTable, DELAYSIZE);
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_DELAYRATE), TRUE);
            SendDlgItemMessage(hwnd, IDC_CMB_RK_DELAYRATE, CB_SETCURSEL, i, 0);
            break;

        // Turn OFF repeat keys
        case IDC_RK_NOREPEAT:
            s_fRepeating = FALSE;
            CheckRadioButton(hwnd, IDC_RK_NOREPEAT, IDC_RK_REPEAT, IDC_RK_NOREPEAT);
            g_fk.iDelayMSec = 0;
            g_fk.iRepeatMSec = 0;
            SendDlgItemMessage(hwnd, IDC_CMB_RK_DELAYRATE, CB_SETCURSEL, -1, 0);
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_DELAYRATE), FALSE);
            SendDlgItemMessage(hwnd, IDC_CMB_RK_REPEATRATE, CB_SETCURSEL, -1, 0);
            EnableWindow(GetDlgItem(hwnd, IDC_CMB_RK_REPEATRATE), FALSE);
            break;

        // Process the test box - turnon filterkeys while inside it.
        case IDC_RK_TESTBOX:
            switch (HIWORD(wParam)) {
            case EN_SETFOCUS:  TestFilterKeys(TRUE); break;
            case EN_KILLFOCUS: TestFilterKeys(FALSE); break;
            }
            break;
        
        case IDC_CMB_RK_DELAYRATE:
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                HandleSelection(GetDlgItem(hwnd, IDC_CMB_RK_DELAYRATE), uDelayTable, &g_fk.iDelayMSec);
                break;
            }
            break;
        
        case IDC_CMB_RK_REPEATRATE:
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                HandleSelection(GetDlgItem(hwnd, IDC_CMB_RK_REPEATRATE), uRateTable, &g_fk.iRepeatMSec);
                break;
            }
            break;
        
        case IDC_CMB_RK_ACCEPTRATE:
            switch (HIWORD(wParam))
            {
                case CBN_SELCHANGE:
                HandleSelection(GetDlgItem(hwnd, IDC_CMB_RK_ACCEPTRATE), uAcceptTable, &g_fk.iWaitMSec);
                break;
            }
            break;

        case IDOK:
            // Save off repeating values to registry
            EndDialog(hwnd, IDOK);
            break;

        case IDCANCEL:
            g_nLastRepeatDelay = s_nLastRepeatDelayOld;
            g_nLastRepeatRate = s_nLastRepeatRateOld;
            g_nLastWait = s_nLastWaitOld;

            EndDialog(hwnd, IDCANCEL);
            break;
        }

        break;

    default:
        fProcessed = FALSE;
        break;
    }
    return(fProcessed);
}

// **************************************************************************
// SubclassFilterKeysTestBox
//
// This takes the dialog ID of an edit field, and then finds the controls
// near the edit field (the controls 2 windows before and 2 windows after the 
// edit control in the z-order). These are the nearest controls that get
// keyboard messages. It subclasses both of these controls
// so that they ignore any WM_KEYDOWN messages when the key being pressed is
// the tab key and the key is already down (i.e. this is a repeated message)
//
// **************************************************************************
BOOL SubclassFilterKeysTestBox (UINT uIdTestBox,HWND hDlg)
{
	HWND	hwndPrev,
			hwndNext,
			hwndTestBox;

    hwndTestBox = GetDlgItem (hDlg,uIdTestBox);
	// BE CAREFUL IF DIALOG CHANGES! Right now the 
	// Previous Previous window is the "S&ettings" push button,
	// and the Next Next is the "&Beep when keys pressed..."
	// checkbox. If the order changes, this code might have to change too.
	// Could make it more general where it searches for controls before
	// and after that can get keyboard focus.
    hwndPrev = GetNextDlgTabItem (hDlg,hwndTestBox,TRUE);
    if (!hwndPrev)
        return FALSE;

	g_WndProcFKPrev = (WNDPROC) GetWindowLongPtr (hwndPrev, GWLP_WNDPROC);
	SetWindowLongPtr (hwndPrev,GWLP_WNDPROC,(LPARAM)SubclassWndProcFKPrev);

    hwndNext = GetNextDlgTabItem (hDlg,hwndTestBox,FALSE);
    if (!hwndNext)
        return FALSE;

	g_WndProcFKNext = (WNDPROC) GetWindowLongPtr (hwndNext, GWLP_WNDPROC);
	SetWindowLongPtr (hwndNext,GWLP_WNDPROC,(LPARAM)SubclassWndProcFKNext);
	
	return TRUE;
}

// **************************************************************************
// SubclassWndProcFKPrev
//
//  This is the WndProc used to ignore repeated presses of the tab key for 
//  the first focusable control that precedes the test box.
//
// **************************************************************************
LRESULT CALLBACK SubclassWndProcFKPrev(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
		case WM_KEYDOWN:
			if ((int)wParam == VK_TAB)
			{
				if (WASDOWN (lParam))
				{
					return (0);
				}
				// if not a repeat, need to move the focus. For some reason,
				// just calling CallWindowProc won't do it for us.
				if (GetKeyState(VK_SHIFT) < 0)
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,1,0);
				}
				else
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,0,0);
				}
			}
			break;
		
		case WM_GETDLGCODE:
			return (DLGC_WANTTAB | CallWindowProc (g_WndProcFKPrev,hwnd,uMsg,wParam,lParam));
			break;
    }
    return (CallWindowProc(g_WndProcFKPrev,hwnd,uMsg,wParam,lParam));
}

// **************************************************************************
// SubclassWndProcFKNext
//
//  This is the WndProc used to ignore repeated presses of the tab key for 
//  the first focusable control that follows the test box.
//
// **************************************************************************
LRESULT CALLBACK SubclassWndProcFKNext(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
		case WM_KEYDOWN:
			if ((int)wParam == VK_TAB)
			{
				if (WASDOWN(lParam))
				{
					return (0);
				}
				// if not a repeat, need to move the focus. For some reason,
				// just calling CallWindowProc won't do it for us.
				if (GetKeyState(VK_SHIFT) < 0)
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,1,0);
				}
				else
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,0,0);
				}
			}
			break;
		
		case WM_GETDLGCODE:
			return (DLGC_WANTTAB | CallWindowProc (g_WndProcFKNext,hwnd,uMsg,wParam,lParam));
			break;
    }
    return (CallWindowProc(g_WndProcFKNext,hwnd,uMsg,wParam,lParam));
}

// **************************************************************************
// SubclassRepeatKeysTestBox
//
//  Same as SubclassFilterKeysTestBox, but keeps it's info in different
//  globals so that one doesn't overwrite the other.
//
// **************************************************************************
BOOL SubclassRepeatKeysTestBox (UINT uIdTestBox,HWND hDlg)
{
	HWND	hwndPrev,
			hwndNext,
			hwndTestBox;

    hwndTestBox = GetDlgItem (hDlg,uIdTestBox);
	// BE CAREFUL IF DIALOG CHANGES! Right now the 
	// Previous Previous window is the "S&ettings" push button,
	// and the Next Next is the "&Beep when keys pressed..."
	// checkbox. If the order changes, this code might have to change too.
	// Could make it more general where it searches for controls before
	// and after that can get keyboard focus.
    hwndPrev = GetNextDlgTabItem (hDlg,hwndTestBox,TRUE);
	g_WndProcRKPrev = (WNDPROC) GetWindowLongPtr (hwndPrev,GWLP_WNDPROC);
	SetWindowLongPtr (hwndPrev,GWLP_WNDPROC,(LPARAM)SubclassWndProcRKPrev);

    hwndNext = GetNextDlgTabItem (hDlg,hwndTestBox,FALSE);
	g_WndProcRKNext = (WNDPROC) GetWindowLongPtr (hwndNext,GWLP_WNDPROC);
	SetWindowLongPtr (hwndNext,GWLP_WNDPROC,(LPARAM)SubclassWndProcRKNext);
	
	return (TRUE);
}

// **************************************************************************
// SubclassWndProcRKPrev
//
// **************************************************************************
LRESULT CALLBACK SubclassWndProcRKPrev(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
		case WM_KEYDOWN:
			if ((int)wParam == VK_TAB)
			{
				if (WASDOWN (lParam))
				{
					return (0);
				}
				// if not a repeat, need to move the focus. For some reason,
				// just calling CallWindowProc won't do it for us.
				if (GetKeyState(VK_SHIFT) < 0)
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,1,0);
				}
				else
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,0,0);
				}
			}
			break;
		
		case WM_GETDLGCODE:
			return (DLGC_WANTTAB | CallWindowProc (g_WndProcRKPrev,hwnd,uMsg,wParam,lParam));
			break;
    }
    return (CallWindowProc(g_WndProcRKPrev,hwnd,uMsg,wParam,lParam));
}

// **************************************************************************
// SubclassWndProcRKNext
//
// **************************************************************************
LRESULT CALLBACK SubclassWndProcRKNext(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
		case WM_KEYDOWN:
			if ((int)wParam == VK_TAB)
			{
				if (WASDOWN(lParam))
				{
					return (0);
				}
				// if not a repeat, need to move the focus. For some reason,
				// just calling CallWindowProc won't do it for us.
				if (GetKeyState(VK_SHIFT) < 0)
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,1,0);
				}
				else
				{
					SendMessage (GetParent(hwnd),WM_NEXTDLGCTL,0,0);
				}
			}
			break;
		
		case WM_GETDLGCODE:
			return (DLGC_WANTTAB | CallWindowProc (g_WndProcRKNext,hwnd,uMsg,wParam,lParam));
			break;
    }
    return (CallWindowProc(g_WndProcRKNext,hwnd,uMsg,wParam,lParam));
}

///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\mouse.c ===
/*******************************************************************
 *
 *    DESCRIPTION: Mouse Dialog handler
 *
 *    HISTORY:    			 
 *
 *******************************************************************/

#include <assert.h>

/*******************************************************************
 *
 *    DESCRIPTION: Mouse Keys Dialog handler
 *
 *    HISTORY:    			 
 *
 *******************************************************************/

#include "Access.h"

#define TICKCOUNT 9

extern LPTSTR HelpFile();

INT_PTR WINAPI MouseKeyDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    static UINT uSpeedTable[TICKCOUNT] = 
              { 10, 20, 30, 40, 60, 80, 120, 180, 360 };

    int  i;
    BOOL fProcessed = TRUE;

    switch (uMsg) {
    case WM_INITDIALOG:
        CheckDlgButton(hwnd, IDC_MK_HOTKEY, (g_mk.dwFlags & MKF_HOTKEYACTIVE) ? TRUE : FALSE);

        // Determine settings on our scroll bars for accel and top speed.

        for (i = 0;
            i < ARRAY_SIZE(uSpeedTable) && uSpeedTable[i] < g_mk.iMaxSpeed;
                i++)
        {
        }

        if (ARRAY_SIZE(uSpeedTable) <= i)
        {
                i = ARRAY_SIZE(uSpeedTable);
        }

        SendDlgItemMessage(
                hwnd,
                IDC_MK_TOPSPEED,
                TBM_SETRANGE,
                TRUE,
                MAKELONG(0, ARRAY_SIZE(uSpeedTable)-1));

        SendDlgItemMessage(
                hwnd, IDC_MK_TOPSPEED, TBM_SETPOS, TRUE, i);

        // Acceleration
        i = (TICKCOUNT+1) - g_mk.iTimeToMaxSpeed/500;
        if (i > TICKCOUNT-1)
        {
                i = TICKCOUNT-1;
        }
        if (i < 0)
        {
                i = 0;
        }

        SendDlgItemMessage(
                hwnd,
                IDC_MK_ACCEL,
                TBM_SETRANGE,
                TRUE,
                MAKELONG(0, TICKCOUNT-1));

        SendDlgItemMessage(
                hwnd,
                IDC_MK_ACCEL,
                TBM_SETPOS,
                TRUE,
                i);

        // Hold down Ctrl to speed up and Shift to slow down
        CheckDlgButton(hwnd, IDC_MK_USEMODKEYS, (g_mk.dwFlags & MKF_MODIFIERS) ? TRUE : FALSE);

        // Use MouseKeys when NumLock is on/off
        if (g_mk.dwFlags & MKF_REPLACENUMBERS)
            CheckRadioButton(hwnd, IDC_MK_NLOFF, IDC_MK_NLON, IDC_MK_NLON);
        else
            CheckRadioButton(hwnd, IDC_MK_NLOFF, IDC_MK_NLON, IDC_MK_NLOFF);

         // Show MouseKey status on screen
        CheckDlgButton(hwnd, IDC_MK_STATUS, (g_mk.dwFlags & MKF_INDICATOR) ? TRUE : FALSE);

       // 3/15/95 -
       // Always init the control speed to 1/8 of the screen width/
       g_mk.iCtrlSpeed = GetSystemMetrics(SM_CXSCREEN) / 16;
       break;

    case WM_HSCROLL:
    {
        int nScrollCode = (int) LOWORD(wParam); // scroll bar value
        int nPos = (short int) HIWORD(wParam);  // scroll box position
        HWND hwndScrollBar = (HWND) lParam;     // handle of scroll bar

        // Set the scrolls position
        i = HandleScroll(hwnd, wParam, hwndScrollBar);
        if (-1 != i)
        {
            // Update it.
            switch(GetWindowLong(hwndScrollBar, GWL_ID))
            {
            case IDC_MK_TOPSPEED:
                g_mk.iMaxSpeed = uSpeedTable[i];
                break;
            case IDC_MK_ACCEL:
                g_mk.iTimeToMaxSpeed = (TICKCOUNT+1-i) * 500;
                break;
            default:
                Assert(!"Got WM_HSCROLL from unknown control");
                break;
            }
        }
    }
        break;

    case WM_HELP:      // F1
                      WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
                      break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
        break;

              // Handle the generic commands
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_MK_HOTKEY:
                g_mk.dwFlags ^= MKF_HOTKEYACTIVE; break;

        case IDC_MK_STATUS:
                g_mk.dwFlags ^= MKF_INDICATOR; break;

        case IDC_MK_USEMODKEYS:
                g_mk.dwFlags ^= MKF_MODIFIERS; break;

        case IDC_MK_NLOFF:
                g_mk.dwFlags &= ~MKF_REPLACENUMBERS;
                CheckRadioButton(hwnd, IDC_MK_NLOFF, IDC_MK_NLON, IDC_MK_NLOFF);
                break;

        case IDC_MK_NLON:
                g_mk.dwFlags |= MKF_REPLACENUMBERS;
                CheckRadioButton(hwnd, IDC_MK_NLOFF,IDC_MK_NLON, IDC_MK_NLON);
                break;

        case IDOK:
                EndDialog(hwnd, IDOK);
                break;

        case IDCANCEL:
                EndDialog(hwnd, IDCANCEL);
                break;

        }
        break;

        default: fProcessed = FALSE; break;
    }
    return(fProcessed);
}



// *******************************************************************
// Mouse Dialog handler
// *******************************************************************
INT_PTR WINAPI MouseDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    MOUSEKEYS mk;
    BOOL fProcessed = TRUE;

    switch (uMsg) {
    case WM_INITDIALOG:
        CheckDlgButton(hwnd, IDC_MK_ENABLE, (g_mk.dwFlags & MKF_MOUSEKEYSON) ? TRUE : FALSE);
        if (!(g_mk.dwFlags & MKF_AVAILABLE)) {
            EnableWindow(GetDlgItem(hwnd, IDC_MK_SETTINGS), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_MK_ENABLE), FALSE);
        }
        break;

    case WM_HELP:      // F1
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
                      break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_MK_ENABLE:
            g_mk.dwFlags ^= MKF_MOUSEKEYSON;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
                                    break;

        case IDC_MK_SETTINGS:
            mk = g_mk;  // Save settings before letting the user play with global
            if (DialogBox(g_hinst, MAKEINTRESOURCE(IDD_MOUSESETTINGS), hwnd, MouseKeyDlg) == IDCANCEL) {
              // User cancelled, restore settings.
                g_mk = mk;
            } else SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {
        case PSN_APPLY: SetAccessibilitySettings(); break;
        }
        break;

    default: fProcessed = FALSE; break;
    }

    return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\reg.c ===
/****************************** Module Header ******************************\
* Module Name: reg.c
*
* Copyright (c) 1985-95, Microsoft Corporation
*
* History:
* 01-02-96 a-jimhar 	Created based on reg.c from access351.exe
\***************************************************************************/

/*
1. on startup, check to see if we're administrator
  a) use RegOpenKeyEx on HKEY_USERS\.DEFAULT\Software with read/write
    access writes.  if it fails, we're not administrator
  b) if not, grey menu option
2. on startup
  a) use RegOpenKeyEx on HKEY_CURRENTUSER\Software...
  b) if it fails, create these keys with default values.
3. creating keys
  a) RegCreateKeyEx
  b) RegSetValue
  c) RegCloseKey

*/
#include "TCHAR.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "Access.h"

BOOL DoAccessRegEntriesExist( HKEY hkeyRoot );
BOOL CheckRegEntry( HKEY hkeyRoot, LPSTR lpsz, REGSAM sam );
BOOL SetRegString( HKEY hkey, LPSTR lpszEntry, LPSTR lpszValue );

DWORD CopyKey( HKEY hkeySrc, HKEY hkeyDst, LPSTR szKey );


char szAccessRegPath[] = "Control Panel\\Accessibility";
char szHcColorRegPath[] = "Control Panel\\Colors";
char szHcDeskRegPath[] = "Control Panel\\Desktop";

/********************************************************************/
//
BOOL IsDefaultWritable( void )
{
    return CheckRegEntry( HKEY_USERS, ".Default", KEY_ALL_ACCESS );
}

/********************************************************************/
BOOL DoAccessRegEntriesExist( HKEY hkeyRoot )
{
    char sz[128];
    strcpy( sz, szAccessRegPath );
    strcat( sz, "\\StickyKeys" );
    return CheckRegEntry( hkeyRoot, sz, KEY_READ ); // execute means readonly
}

/********************************************************************/
BOOL CheckRegEntry( HKEY hkeyRoot, LPSTR lpsz, REGSAM sam )
{
    HKEY hkey;
    BOOL fOk = (ERROR_SUCCESS == RegOpenKeyExA( hkeyRoot, lpsz, 0, sam, &hkey ));

    if(fOk)
    {
        RegCloseKey(hkey);
    }
    
	return fOk;
}



/********************************************************************/
BOOL SetRegString( HKEY hkey, LPSTR lpszEntry, LPSTR lpszValue )
{
    DWORD dwResult;
    dwResult = RegSetValueExA( hkey,
                              lpszEntry,
                              0,
                              REG_SZ,
                              lpszValue,
                              strlen( lpszValue ) + sizeof( TCHAR ) );
    if( dwResult != ERROR_SUCCESS )
    {
        ; // should do something like print a message
        return FALSE;
    }
    else
        return TRUE;
}

/***********************************************************************/
#define TEMP_PROFILE     "Temp profile (access.cpl)"

typedef BOOL (*PFNGETDEFAULTUSERPROFILEDIRECTORYA)(LPSTR lpProfile, LPDWORD dwSize);

DWORD SaveDefaultSettings( BOOL saveL, BOOL saveU )
{
    NTSTATUS Status;
    DWORD iStatus = ERROR_SUCCESS;
    DWORD dwSize;
    HKEY hkeyDst;
    BOOLEAN WasEnabled;
    char acFile[MAX_PATH];
    HANDLE hInstDll;
    PFNGETDEFAULTUSERPROFILEDIRECTORYA pfnGetDefaultUserProfileDirectory;

    // If save to Logon
    if ( saveL )
    {
        iStatus  = RegOpenKeyExA( HKEY_USERS, ".DEFAULT", 0, KEY_WRITE |
			KEY_ENUMERATE_SUB_KEYS,
			&hkeyDst );
        if( iStatus != ERROR_SUCCESS )
            return iStatus;
        iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szAccessRegPath );
    
        // a-anilk 
        // Now copy the colors and Desktop to .Default required for HighContrast setting
        iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szHcColorRegPath );
        iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szHcDeskRegPath );

        RegCloseKey( hkeyDst );
    }

    if ( saveU )
    {
        hInstDll = LoadLibrary (TEXT("userenv.dll"));

        if (!hInstDll) {
            return (GetLastError());
        }
        pfnGetDefaultUserProfileDirectory = (PFNGETDEFAULTUSERPROFILEDIRECTORYA)GetProcAddress (hInstDll,
                                            "GetDefaultUserProfileDirectoryA");

        if (!pfnGetDefaultUserProfileDirectory) {
            FreeLibrary (hInstDll);
            return (GetLastError());
        }

        dwSize = MAX_PATH;
        if (!pfnGetDefaultUserProfileDirectory(acFile, &dwSize)) {
            FreeLibrary (hInstDll);
            return (GetLastError());
        }

        FreeLibrary (hInstDll);

        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

        if (!NT_SUCCESS(Status)) return iStatus;

        strcat(acFile,"\\ntuser.dat");
        iStatus = RegLoadKeyA(HKEY_USERS, TEMP_PROFILE, acFile);

        if (iStatus == ERROR_SUCCESS) {

            iStatus  = RegOpenKeyExA( HKEY_USERS, TEMP_PROFILE, 0, KEY_WRITE |
			KEY_ENUMERATE_SUB_KEYS, &hkeyDst );
            if( iStatus == ERROR_SUCCESS ) {

                iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szAccessRegPath );
                // a-anilk 
                // Now copy the colors and Desktop to .Default required for HighContrast setting
                iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szHcColorRegPath );
                iStatus = CopyKey( HKEY_CURRENT_USER, hkeyDst, szHcDeskRegPath );

                RegCloseKey( hkeyDst );
            }

            RegUnLoadKeyA(HKEY_USERS, TEMP_PROFILE);
        }
        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    }
    return iStatus;
}

/***********************************************************************/
// CopyKey( hKey, hKeyDst, name )
//     create the destination key
//     for each value
//         CopyValue
//     for each subkey
//         CopyKey

DWORD CopyKey( HKEY hkeySrc, HKEY hkeyDst, LPSTR szKey )
{
    HKEY hkeyOld, hkeyNew;
    char szValue[128];
    char szData[128];
    char szBuffer[128];
    DWORD iStatus;
    UINT nValue, nKey;
    UINT iValueLen, iDataLen;
	DWORD dwType;

    iStatus = RegOpenKeyExA( hkeySrc, szKey, 0, KEY_WRITE |
			KEY_ENUMERATE_SUB_KEYS, &hkeyOld );
    if( iStatus != ERROR_SUCCESS )
        return iStatus;
    iStatus = RegOpenKeyExA( hkeyDst, szKey, 0, KEY_WRITE |
			KEY_ENUMERATE_SUB_KEYS, &hkeyNew );
    if( iStatus != ERROR_SUCCESS )
    {
        iStatus = RegCreateKeyExA( hkeyDst, szKey, 0, "", 0, KEY_WRITE |
			KEY_ENUMERATE_SUB_KEYS, NULL, &hkeyNew, NULL );
        if( iStatus != ERROR_SUCCESS )
        {
            RegCloseKey( hkeyOld );
            return iStatus;
        }
    }
    //*********** copy the values **************** //

    for( nValue = 0, iValueLen=sizeof szValue, iDataLen=sizeof szValue;
         ERROR_SUCCESS == (iStatus = RegEnumValueA(hkeyOld,
                                                  nValue,
                                                  szValue,
                                                  &iValueLen,
                                                  NULL, // reserved
                                                  &dwType, // don't need type
                                                  szData,
                                                  &iDataLen ) );
         nValue ++, iValueLen=sizeof szValue, iDataLen=sizeof szValue )
     {
         iStatus = RegSetValueExA( hkeyNew,
                                  szValue,
                                  0, // reserved
                                  dwType,
                                  szData,
                                  iDataLen);
     }
    if( iStatus != ERROR_NO_MORE_ITEMS )
    {
        RegCloseKey( hkeyOld );
        RegCloseKey( hkeyNew );
        return iStatus;
    }

    //*********** copy the subtrees ************** //

    for( nKey = 0;
         ERROR_SUCCESS == (iStatus = RegEnumKeyA(hkeyOld,nKey,szBuffer,sizeof(szBuffer)));
         nKey ++ )
     {
         iStatus = CopyKey( hkeyOld, hkeyNew, szBuffer );
         if( iStatus != ERROR_NO_MORE_ITEMS && iStatus != ERROR_SUCCESS )
            {
                RegCloseKey( hkeyOld );
                RegCloseKey( hkeyNew );
                return iStatus;
            }
     }
    RegCloseKey( hkeyOld );
    RegCloseKey( hkeyNew );
    if( iStatus == ERROR_NO_MORE_ITEMS )
        return ERROR_SUCCESS;
    else
        return iStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by access.rc
//
#define IDS_ACCESSIBILITY               1
#define IDS_ACCESS                      4
#define IDS_ACCESSINFO                  5
#define IDS_WINDOWED                    6
#define IDS_STRING7                     7
#define IDS_WINDOWED1                   7
#define IDS_STRING8                     8
#define IDS_WINDOWED2                   8
#define IDS_STRING9                     9
#define IDS_WINDOWED3                   9
#define IDS_TEXT                        10
#define IDS_STRING11                    11
#define IDS_TEXT1                       11
#define IDS_STRING12                    12
#define IDS_TEXT2                       12
#define IDS_STRING15                    13
#define IDS_TEXT3                       13
#define IDS_GRAPHICS                    14
#define IDS_STRING14                    15
#define IDS_GRAPHICS1                   15
#define IDS_COMPORT                     16
#define IDS_UNAVAIL_TITLE               24
#define IDS_UNAVAIL_TEXT                25
#define IDS_BLACKWHITE_SCHEME           27
#define IDS_WHITEBLACK_SCHEME           28
#define IDS_PROPERTY_TITLE              29
#define IDS_ACCSTAT_WINDOW_TITLE        30
#define IDS_SAVE_DEFAULT_TITLE          32
#define IDS_SAVE_DEFAULT_TEXT           33
#define IDS_SECONDS                     34
#define IDS_MINUTES                     35
#define IDI_ACCESS                      110
#define IDD_KEYBOARD                    201
#define IDD_SOUND                       202
#define IDD_GENERAL                     203
#define IDD_DISPLAY                     204
#define IDD_MOUSE                       205
#define IDD_STICKYSETTINGS              206
#define IDD_FILTERSETTINGS              207
#define IDD_TOGGLESETTINGS              208
#define IDD_ADVCHARREPEAT               209
#define IDD_MOUSESETTINGS               210
#define IDD_SOUNDSETTINGS               211
#define IDD_HIGHCONSETTINGS             212
#define IDD_SERKEYSETTING               214
#define IDD_ADVKEYBOUNCE                217
#define IDC_MK_TOPSPEED                 603
#define IDC_MK_ACCEL                    604
#define IDC_CHECK1                      1000
#define IDC_SHOWEXTRAKYBDHELP           1000
#define IDC_MK_HOTKEY                   1001
#define IDC_MK_USEMODKEYS               1002
#define IDC_MK_SETTINGS                 1003
#define IDC_MK_STATUS                   1004
#define IDC_STK_SOUNDMOD                1007
#define IDC_SK_ENABLE                   1010
#define IDC_STK_STATUS                  1011
#define IDC_SK_PORT                     1013
#define IDC_MK_NLOFF                    1018
#define IDC_MK_NLON                     1019
#define IDC_RK_TESTBOX                  1021
#define IDC_STK_ENABLE                  1031
#define IDC_STK_SETTINGS                1032
#define IDC_TK_SETTINGS                 1033
#define IDC_HC_ENABLE                   1034
#define IDC_HC_SETTINGS                 1035
#define IDC_SAVE_SETTINGS               1036
#define IDC_TO_ENABLE                   1037
#define IDC_TO_TIMEOUTVAL               1038
#define IDC_WARNING_SOUND               1039
#define IDC_SOUND_ONOFF                 1040
#define IDC_SK_SETTINGS                 1041
#define IDC_TK_ENABLE                   1042
#define IDC_STK_HOTKEY                  1043
#define IDC_STK_LOCK                    1044
#define IDC_STK_2KEYS                   1045
#define IDC_FK_HOTKEY                   1046
#define IDC_FK_BOUNCE                   1047
#define IDC_FK_REPEAT                   1048
#define IDC_FK_TESTBOX                  1049
#define IDC_FK_SETTINGS                 1050
#define IDC_FK_ENABLE                   1055
#define IDC_BK_TESTBOX                  1058
#define IDC_BK_SETTINGS                 1059
#define IDC_RK_NOREPEAT                 1060
#define IDC_RK_REPEAT                   1061
#define IDC_RK_SETTINGS                 1066
#define IDC_FK_SOUND                    1069
#define IDC_FK_STATUS                   1070
#define IDC_HC_HOTKEY                   1071
#define IDC_HC_DEFAULTSCHEME            1075
#define IDC_TK_HOTKEY                   1076
#define IDC_SS_ENABLE_SOUND             1077
#define IDC_SS_CHOOSE                   1078
#define IDC_SS_ENABLE_SHOW              1079
#define IDC_SS_WINDOWED                 1080
#define IDC_MK_ENABLE                   1081
#define IDC_SK_BAUD                     1082
#define IDC_NO_HELP_1                   1086
#define IDC_BK_TIME_LBL1                1087
#define IDC_BK_TIME_LBL2                1088
#define IDC_RK_DELAYRATE_LBL            1111
#define IDC_RK_REPEATRATE_LBL           1112
#define IDC_RK_ACCEPTRATE_LBL           1113
#define IDC_CMB_RK_DELAYRATE            1115
#define IDC_CMB_RK_REPEATRATE           1116
#define IDC_CMB_RK_ACCEPTRATE           1117
#define IDC_ADMIN_LOGON                 1114
#define IDC_CMB_BK_BOUNCERATE           1118
#define IDC_ADMIN_DEFAULT               1119
#define IDC_GEN_GROUP_4                 1120
#define IDC_KCURSOR_BLINK               1121
#define IDC_KCURSOR_RATE                1122
#define IDC_KCURSOR_WIDTH               1123
#define IDC_KCUR_TEXT_NARR              1126
#define IDC_KCUR_TEXT_WIDE              1127
#define IDC_KCUR_TEXT_NONE              1128
#define IDC_KCUR_TEXT_FAST              1129
#define IDC_KCURSOR_OPTS                1130
#define IDC_SK_TEXT                     1132
#define IDC_FK_TEXT                     1133
#define IDC_TK_TEXT                     1134
#define IDC_SS_TEXT                     1135
#define IDC_SS_TEXT1                    1136
#define IDC_SERKEY_TEXT                 1137
#define IDC_HC_TEXT                     1138
#define IDC_KCUR_TEXT_RATE              1139
#define IDC_KCUR_TEXT_WIDTH             1140
#define IDC_MK_TEXT                     1141
#define IDC_STK_TEXT                    1142
#define IDC_TK_TEXT1                    1143
#define IDC_MK_TEXT1                    1144
#define IDC_MK_SPEED                    1145
#define IDC_MK_SPEED_LOW                1146
#define IDC_MK_SPEED_HIGH               1147
#define IDC_MK_ACCELER                  1148
#define IDC_MK_ACCELER_SLOW             1149
#define IDC_MK_ACCELER_FAST             1150
#define IDC_MK_TEXT2                    1151
#define IDC_HC_TEXT1                    1152
#define IDC_HC_CURSCHEME                1153
#define IDC_SK_PORTEXT                  1154
#define IDC_SK_BAUD_TEXT                1155
#define IDC_FK_TEXT1                    1156

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        235
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1157
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\serlkey.c ===
/*******************************************************************
 *
 *    DESCRIPTION: Serial Keys Dialog handler
 *
 *    HISTORY:    			
 *
 *******************************************************************/

#include "Access.h"

#define NUMPORTS 8
#define NUMRATES 6

extern LPTSTR HelpFile();

INT_PTR WINAPI SerialKeyDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	int  i;
	UINT uBaud;
   UINT uBaudRates[] = { 300, 1200, 2400, 4800, 9600, 19200 };
	TCHAR szBuf[256];
   BOOL fProcessed = TRUE;

	switch (uMsg) {
		case WM_INITDIALOG:
  			LoadString(g_hinst, IDS_COMPORT, szBuf, ARRAY_SIZE(szBuf));
			for (i=1; i <= 4; i++) {
				TCHAR szBuf2[256];

				// Make a correct port name and add it to the list box.
				wsprintf(szBuf2, __TEXT("%s%d"), szBuf, i);
				ComboBox_AddString(GetDlgItem(hwnd, IDC_SK_PORT), szBuf2);									
			}

			// Select the current com port.
			if (g_serk.lpszActivePort[0] != '\0') {
				int cport;

				// For now we assume that the format of the string is
				// com[digit].  So comport[3] = the com port number
				// Set all invalid ports to 'COM1'
				cport = g_serk.lpszActivePort[3] - '1';
				if (cport < 0) cport = 0;
				if (cport > 4) cport = 0;

				// Set the active port.
				ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SK_PORT), cport);				
			} else {
				// Else default to COM1.
				ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SK_PORT), 0);
				lstrcpy(g_serk.lpszActivePort, __TEXT("COM1"));
			}

			// Fill in the BAUD RATE options
			uBaud = 1;		// Default baud rate.

			for (i = 0; i < NUMRATES; i++) {
                TCHAR szBuf1[256]; // renamed to avoid name clash with szBuf
                wsprintf(szBuf1, __TEXT("%d"), uBaudRates[i]);
                ComboBox_AddString(GetDlgItem(hwnd, IDC_SK_BAUD), szBuf1);              
				if (g_serk.iBaudRate == uBaudRates[i]) uBaud = i;	
			}
			ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SK_BAUD), uBaud);
			break;

      case WM_HELP:	 // F1
			WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
			break;

      case WM_CONTEXTMENU:	// right mouse click
         WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
			break;

		case WM_COMMAND:
      	switch (GET_WM_COMMAND_ID(wParam, lParam)) {
				// Watch for combobox changes.
				case IDC_SK_BAUD:
					switch (HIWORD(wParam)) {
						case CBN_CLOSEUP:
						case CBN_SELCHANGE:
							i = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_SK_BAUD));
                     g_serk.iBaudRate = uBaudRates[i];
		    	         SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
							break;
					}					
					break;

				case IDC_SK_PORT:
					switch (HIWORD(wParam)) {
						case CBN_SELCHANGE:
							i = 1 + ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_SK_PORT));
                     wsprintf(g_serk.lpszActivePort, __TEXT("COM%d"), i);
                     EnableWindow(GetDlgItem(hwnd, IDC_SK_BAUD), TRUE);
							break;
					}					
					break;

				case IDOK: case IDCANCEL:
					EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
					break;
			}
			break;

		default:
			fProcessed = FALSE; break;
	}
	return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\sound.c ===
/*******************************************************************
 *    DESCRIPTION: Sound Dialog handler
 *******************************************************************/

#include "Access.h"

extern LPTSTR HelpFile();

// *******************************************************************
// SoundDialog handler
// *******************************************************************
INT_PTR CALLBACK SoundDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    SOUNDSENTRY ss;
    BOOL fSSOn;
    BOOL fProcessed = TRUE;
    TCHAR szBuf[100];
    int i;
				
	switch (uMsg) {
		case WM_INITDIALOG:
            // init sound sentry options

			for (i= 0; i < 4; i++) 
            {
				LoadString(g_hinst, IDS_WINDOWED + i, szBuf, ARRAY_SIZE(szBuf));
				ComboBox_AddString(GetDlgItem(hwnd, IDC_SS_WINDOWED), szBuf);				
            }

            // init controls based on current settings

            fSSOn = g_ss.dwFlags & SSF_SOUNDSENTRYON;
			CheckDlgButton(hwnd, IDC_SS_ENABLE_SOUND, (fSSOn) ? TRUE : FALSE);

			if (!(g_ss.dwFlags & SSF_AVAILABLE)) 
            {
				EnableWindow(GetDlgItem(hwnd, IDC_SS_ENABLE_SOUND), FALSE);
				EnableWindow(GetDlgItem(hwnd, IDC_SS_WINDOWED), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_SS_CHOOSE), FALSE);
			    ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SS_WINDOWED), -1);			
            }
			if (!fSSOn) 
            {
				EnableWindow(GetDlgItem(hwnd, IDC_SS_WINDOWED), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_SS_CHOOSE), FALSE);
                g_ss.iWindowsEffect = 0;
			    ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SS_WINDOWED), g_ss.iWindowsEffect);				
            } else
            {
			    // Select the correct items from the comboboxes.
			    ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SS_WINDOWED), g_ss.iWindowsEffect);				
            }
            CheckDlgButton(hwnd, IDC_SS_ENABLE_SHOW, g_fShowSounds);

			break;

      case WM_HELP:	 // F1
			WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
			break;

      case WM_CONTEXTMENU:	// right mouse click
         WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
			break;

    	case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))  {
				case IDC_SS_ENABLE_SOUND:
					g_ss.dwFlags ^= SSF_SOUNDSENTRYON;
                    if (!(g_ss.dwFlags & SSF_SOUNDSENTRYON))
                    {
                        EnableWindow(GetDlgItem(hwnd, IDC_SS_CHOOSE), FALSE);
				        EnableWindow(GetDlgItem(hwnd, IDC_SS_WINDOWED), FALSE);
                        g_ss.iWindowsEffect = 0;
                    } else
                    {
                        EnableWindow(GetDlgItem(hwnd, IDC_SS_CHOOSE), TRUE);
				        EnableWindow(GetDlgItem(hwnd, IDC_SS_WINDOWED), TRUE);
                        g_ss.iWindowsEffect = 1;
                    }
			        ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_SS_WINDOWED), g_ss.iWindowsEffect);
                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SS_ENABLE_SHOW:
					g_fShowSounds = !g_fShowSounds;
                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDC_SS_WINDOWED:
					switch (HIWORD(wParam)) 
                    {
                        DWORD dw;
						case CBN_CLOSEUP:
                            dw = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_SS_WINDOWED));
							if (dw != g_ss.iWindowsEffect)
                            {
                                g_ss.iWindowsEffect = dw;
                                SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
                            }
							break;
					}					
					break;
			}
			break;

		case WM_NOTIFY:
			switch (((NMHDR *)lParam)->code) {				
				case PSN_APPLY: SetAccessibilitySettings(); break;
					break;
			}
			break;

		default: fProcessed = FALSE; break;
	}
	return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\stkykey.c ===
// **************************************************************************
// StickyKeys
// Process the StickyKeys dialog
// **************************************************************************
#include "Access.h"

extern LPTSTR HelpFile();

INT_PTR WINAPI StickyKeyDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    BOOL fProcessed = TRUE;

    switch (uMsg) {
    case WM_INITDIALOG:
        CheckDlgButton(hwnd, IDC_STK_HOTKEY,
            (g_sk.dwFlags & SKF_HOTKEYACTIVE) ? TRUE : FALSE);

        CheckDlgButton(hwnd, IDC_STK_LOCK,
                (g_sk.dwFlags & SKF_TRISTATE) ? TRUE : FALSE);

        CheckDlgButton(hwnd, IDC_STK_2KEYS,
                (g_sk.dwFlags & SKF_TWOKEYSOFF) ? TRUE : FALSE);

        CheckDlgButton(hwnd, IDC_STK_SOUNDMOD,
                (g_sk.dwFlags & SKF_AUDIBLEFEEDBACK) ? TRUE : FALSE);

        CheckDlgButton(hwnd, IDC_STK_STATUS,
                (g_sk.dwFlags & SKF_INDICATOR) ? TRUE : FALSE);

        break;

    case WM_HELP:      // F1
                      WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
                      break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
                      break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDC_STK_HOTKEY:
            g_sk.dwFlags ^= SKF_HOTKEYACTIVE;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;

        case IDC_STK_LOCK:
            g_sk.dwFlags ^= SKF_TRISTATE;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;

        case IDC_STK_2KEYS:
            g_sk.dwFlags ^= SKF_TWOKEYSOFF;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;

        case IDC_STK_SOUNDMOD:
            g_sk.dwFlags ^= SKF_AUDIBLEFEEDBACK;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;
        case IDC_STK_STATUS:
            g_sk.dwFlags ^= SKF_INDICATOR;
            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam)); break;
        }
        break;

        default: fProcessed = FALSE; break;
    }
    return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\access\tgglkeys.c ===
/*******************************************************************
 *    DESCRIPTION: ToggleKeys dialog
 *******************************************************************/

#include "Access.h"

extern LPTSTR HelpFile();

// *******************************************************************
// Toggle Keys Settings handler
// *******************************************************************
INT_PTR CALLBACK ToggleKeySettingsDlg (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
   BOOL fProcessed = TRUE;

	switch (uMsg) {
		case WM_INITDIALOG:
			CheckDlgButton(hwnd, IDC_TK_HOTKEY, 
				(g_tk.dwFlags & TKF_HOTKEYACTIVE)?TRUE:FALSE );
			break;

      case WM_HELP:
			WinHelp(((LPHELPINFO) lParam)->hItemHandle, HelpFile(), HELP_WM_HELP, (DWORD_PTR) (LPSTR) g_aIds);
			break;

      case WM_CONTEXTMENU:
         WinHelp((HWND) wParam, HelpFile(), HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) g_aIds);
			break;

    	case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {											
				case IDC_TK_HOTKEY:				
					g_tk.dwFlags ^= MKF_HOTKEYACTIVE;
               SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM) hwnd, 0);
					break;

				case IDOK: case IDCANCEL:
					EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam)); break;
			}
			break;

		default: fProcessed = FALSE; break;
	}
	return(fProcessed);
}


///////////////////////////////// End of File /////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batmeter\batmeter.inc ===
#
#  Common settings for batmeter
#

CCSHELL_DIR=$(PROJECT_ROOT)
!include $(PROJECT_ROOT)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(PROJECT_ROOT)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batmeter\batstate.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       BATSTATE.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   BATSTATE.C contains helper function which maintain the global battery
*   state list.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>

#include <dbt.h>           
#include <devioctl.h>
#include <ntpoapi.h>
#include <poclass.h>

#include "powrprofp.h"
#include "batmeter.h"

// Simulated battery only for debug build.
#ifndef DEBUG
#undef SIM_BATTERY
#endif

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

// Global battery state list. This list has the composite system battery state
// as it's always present head. individual battery devices are linked to this
// head. Use WalkBatteryState(ALL, ... to walk the entire list, including the
// head. Use WalkBatteryState(DEVICES, ... to walk just the device list. If a
// battery is in this list, it's displayable. g_ulBatCount is the count of
// battery devices in this list. The composite battery is not counted.

extern BATTERY_STATE   g_bs;
extern ULONG           g_ulBatCount;
extern HWND            g_hwndBatMeter;

#ifdef WINNT
/*******************************************************************************
*
*  RegisterForDeviceNotification
*
*  DESCRIPTION:
*    Do registration for WM_DEVICECHANGED.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL RegisterForDeviceNotification(PBATTERY_STATE pbs)
{
   DEV_BROADCAST_HANDLE dbh;

   memset(&dbh, 0, sizeof(DEV_BROADCAST_HANDLE));

   dbh.dbch_size        = sizeof(DEV_BROADCAST_HANDLE);
   dbh.dbch_devicetype  = DBT_DEVTYP_HANDLE;
   dbh.dbch_handle      = pbs->hDevice;
   
   if (!g_hwndBatMeter) {
      BATTRACE(( "RegisterForDeviceNotification, NULL g_hwndBatMeter"));
      return FALSE;
   }

   pbs->hDevNotify = RegisterDeviceNotification(g_hwndBatMeter,
                                                &dbh, 
                                                DEVICE_NOTIFY_WINDOW_HANDLE);
   
   if (!pbs->hDevNotify) { 
      BATTRACE(( "RegisterDeviceNotification failed"));
      return FALSE;
   }
   return TRUE;
}

/*******************************************************************************
*
*  UnregisterForDeviceNotification
*
*  DESCRIPTION:
*    
*
*  PARAMETERS:
*
*******************************************************************************/

void UnregisterForDeviceNotification(PBATTERY_STATE pbs)
{
   if (pbs->hDevNotify) {
      UnregisterDeviceNotification(pbs->hDevNotify);
      pbs->hDevNotify = NULL;
   }
}
#endif

/*******************************************************************************
*
*  SystemPowerStatusToBatteryState
*
*  DESCRIPTION:
*   Fill in BATTERY_STATE fields based on passed SYSTEM_POWER_STATUS.
*
*  PARAMETERS:
*
*******************************************************************************/

void SystemPowerStatusToBatteryState(
    LPSYSTEM_POWER_STATUS lpsps,
    PBATTERY_STATE pbs
)
{
    pbs->ulPowerState = 0;
    if (lpsps->ACLineStatus == AC_LINE_ONLINE) {
        pbs->ulPowerState |= BATTERY_POWER_ON_LINE;
    }
    if (lpsps->BatteryFlag & BATTERY_FLAG_CHARGING) {
        pbs->ulPowerState |= BATTERY_CHARGING;
    }
    if (lpsps->BatteryFlag & BATTERY_FLAG_CRITICAL) {
        pbs->ulPowerState |= BATTERY_CRITICAL;
    }
    pbs->ulBatLifePercent = lpsps->BatteryLifePercent;
    pbs->ulBatLifeTime    = lpsps->BatteryLifeTime;
}

/*******************************************************************************
*
* WalkBatteryState
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL WalkBatteryState(
    PBATTERY_STATE pbsStart,
    WALKENUMPROC pfnWalkEnumProc,
    HWND hWnd,
    LPARAM lParam1,
    LPARAM lParam2
)
{
    PBATTERY_STATE pbsTmp;

    while (pbsStart) {
        // Save the next entry in case the current one is deleted.
        pbsTmp = pbsStart->bsNext;
        if (!pfnWalkEnumProc(pbsStart, hWnd, lParam1, lParam2)) {
            return FALSE;
        }
        pbsStart = pbsTmp;
    }

    return TRUE;
}

/*******************************************************************************
*
* UpdateBatInfoProc
*
*  DESCRIPTION:
*   Updates battery information for an individual battery device.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL UpdateBatInfoProc(
    PBATTERY_STATE pbs,
    HWND hWnd,
    LPARAM lParam1,
    LPARAM lParam2
)
{
    DWORD                       dwByteCount, dwIOCTL, dwWait;
    BATTERY_STATUS              bs;
    BATTERY_WAIT_STATUS         bws;
    BATTERY_INFORMATION         bi;
    BATTERY_QUERY_INFORMATION   bqi;

    if (pbs->hDevice == INVALID_HANDLE_VALUE) {
        BATTRACE(( "UpdateBatInfoProc, Bad battery driver handle, LastError: 0x%X", GetLastError()));
        return FALSE;
    }

    // If no tag, then don't update the battery info.
    dwIOCTL = IOCTL_BATTERY_QUERY_TAG;
    dwWait = 0;
    if (DeviceIoControl(pbs->hDevice, dwIOCTL,
                        &dwWait, sizeof(dwWait),
                        &(pbs->ulTag), sizeof(ULONG),
                        &dwByteCount, NULL)) {

        bqi.BatteryTag = pbs->ulTag;
        bqi.InformationLevel = BatteryInformation;
        bqi.AtRate = 0;
        
        dwIOCTL = IOCTL_BATTERY_QUERY_INFORMATION;
        if (DeviceIoControl(pbs->hDevice, dwIOCTL,
                            &bqi, sizeof(bqi),
                            &bi,  sizeof(bi),
                            &dwByteCount, NULL)) {

            if (bi.FullChargedCapacity != UNKNOWN_CAPACITY) {
                pbs->ulFullChargedCapacity = bi.FullChargedCapacity;
            }
            else {
                pbs->ulFullChargedCapacity = bi.DesignedCapacity;
            }

            memset(&bws, 0, sizeof(BATTERY_WAIT_STATUS));
            bws.BatteryTag = pbs->ulTag;
            dwIOCTL = IOCTL_BATTERY_QUERY_STATUS;
            if (DeviceIoControl(pbs->hDevice, dwIOCTL,
                                &bws, sizeof(BATTERY_WAIT_STATUS),
                                &bs,  sizeof(BATTERY_STATUS),
                                &dwByteCount, NULL)) {

                pbs->ulPowerState = bs.PowerState;
                if (pbs->ulFullChargedCapacity < bs.Capacity) {
                    pbs->ulFullChargedCapacity = bs.Capacity;
                    BATTRACE(( "UpdateBatInfoProc, unable to calculate ulFullChargedCapacity"));
                }
                if (pbs->ulFullChargedCapacity == 0) {
                    pbs->ulBatLifePercent = 0;
                }
                else {
                    pbs->ulBatLifePercent =
                        (100 * bs.Capacity) / pbs->ulFullChargedCapacity;
                }
                return TRUE;
            }
        }
    }
    else {
        pbs->ulTag = BATTERY_TAG_INVALID;

        // No battery tag, that's ok, the user may have removed the battery.
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            return TRUE;
        }
    }
    BATTRACE(( "UpdateBatInfoProc, IOCTL: %X Failure, BatNum: %d, LastError: %d\n", dwIOCTL, pbs->ulBatNum, GetLastError()));
    return FALSE;
}

/*******************************************************************************
*
* SimUpdateBatInfoProc
*
*  DESCRIPTION:
*   Simulate the update of battery information for an individual batter device.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL SimUpdateBatInfoProc(
    PBATTERY_STATE pbs,
    HWND hWnd,
    LPARAM lParam1,
    LPARAM lParam2
)
{
    pbs->ulTag = pbs->ulBatNum;
    if (pbs->ulBatNum == 1) {
        pbs->ulFullChargedCapacity  = 2000;
        pbs->ulFullChargedCapacity  = 1991;
        pbs->ulPowerState           = BATTERY_CHARGING | BATTERY_POWER_ON_LINE;
        pbs->ulBatLifePercent       =   75;
    }
    else {
        pbs->ulFullChargedCapacity  = 3000;
        pbs->ulFullChargedCapacity  = 2991;
        pbs->ulPowerState           = BATTERY_DISCHARGING | BATTERY_CRITICAL;
        pbs->ulBatLifePercent       =  3;
    }
    return TRUE;
}

/*******************************************************************************
*
*  AddBatteryStateDevice
*
*  DESCRIPTION:
*   Add only displayable batteries to the battery list. New entry is appended
*   to battery state list.
*
*  PARAMETERS:
*
*******************************************************************************/

PBATTERY_STATE AddBatteryStateDevice(LPTSTR lpszName, ULONG ulBatNum)
{
    PBATTERY_STATE  pbs, pbsTemp = &g_bs;
    LPTSTR          lpsz = NULL;
    DWORD strsize;

    if (!lpszName) {
        return NULL;
    }

    // Append to end of list
    while (pbsTemp->bsNext) {
        pbsTemp = pbsTemp->bsNext;
    }

    // Allocate storage for new battery device state.
    if (pbs = LocalAlloc(LPTR, sizeof(BATTERY_STATE))) {
        strsize = STRSIZE(lpszName);
        if (lpsz = LocalAlloc(0, strsize)) {
            lstrcpyn(lpsz, lpszName,strsize);
            pbs->lpszDeviceName = lpsz;
            pbs->ulSize = sizeof(BATTERY_STATE);
            pbs->ulBatNum = ulBatNum;

            // Open a handle to the battery driver.
            pbs->hDevice = CreateFile(lpszName,
                                      GENERIC_READ | GENERIC_WRITE,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL, OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL, NULL);
#ifdef WINNT
            // Setup for notification by PNP when battery goes away. 
            RegisterForDeviceNotification(pbs);
#endif
            // Get the current battery info from the battery driver.
            if (UpdateBatInfoProc(pbs, NULL, 0, 0)) {

                // Link the new battery device state into the list.
                pbsTemp->bsNext = pbs;
                pbs->bsPrev = pbsTemp;
                return pbs;
            }
            LocalFree(lpsz);
        }
        LocalFree(pbs);
    }
    return NULL;
}

/*******************************************************************************
*
*  SimAddBatteryStateDevice
*
*  DESCRIPTION:
*   Simulate the addition of displayable batteries to the battery list.
*   New entry is appended to battery state list.
*
*  PARAMETERS:
*
*******************************************************************************/

PBATTERY_STATE SimAddBatteryStateDevice(LPTSTR lpszName, ULONG ulBatNum)
{
    PBATTERY_STATE  pbs, pbsTemp = &g_bs;
    LPTSTR          lpsz = NULL;
    DWORD           strsize;

    if (!lpszName) {
        return NULL;
    }

    // Append to end of list
    while (pbsTemp->bsNext) {
        pbsTemp = pbsTemp->bsNext;
    }

    // Allocate storage for new battery device state.
    if (pbs = LocalAlloc(LPTR, sizeof(BATTERY_STATE))) {
        strsize = STRSIZE(lpszName);
        if (lpsz = LocalAlloc(0, strsize)) {
            lstrcpyn(lpsz, lpszName,strsize);
            pbs->lpszDeviceName = lpsz;
            pbs->ulSize = sizeof(BATTERY_STATE);
            pbs->ulBatNum = ulBatNum;

            // Open a handle to the battery driver.
            pbs->hDevice = (HANDLE) -1;

            // Get the current battery info from the battery driver.
            if (SimUpdateBatInfoProc(pbs, NULL, 0, 0)) {

                // Link the new battery device state into the list.
                pbsTemp->bsNext = pbs;
                pbs->bsPrev = pbsTemp;
                return pbs;
            }
            LocalFree(lpsz);
        }
        LocalFree(pbs);
    }
    return NULL;
}


/*******************************************************************************
*
* RemoveBatteryStateDevice
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL RemoveBatteryStateDevice(PBATTERY_STATE pbs)
{
    // Unlink
    if (pbs->bsNext) {
        pbs->bsNext->bsPrev = pbs->bsPrev;
    }
    if (pbs->bsPrev) {
        pbs->bsPrev->bsNext = pbs->bsNext;
    }

#ifdef winnt
    UnregisterForDeviceNotification(pbs);
#endif
    
    // Free the battery driver handle if one was opened.
    if (pbs->hDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(pbs->hDevice);
    }

    // Free the device name.
    LocalFree(pbs->lpszDeviceName);

    // Destroy any icons.
    if (pbs->hIconCache) {
        DestroyIcon(pbs->hIconCache);
    }
    if (pbs->hIconCache16) {
        DestroyIcon(pbs->hIconCache16);
    }

    // Free the associated storage.
    LocalFree(pbs);

    return TRUE;
}

/*******************************************************************************
*
*  RemoveMissingProc
*
*  DESCRIPTION:
*   Remove a battery from the global battery state list.
*
*  PARAMETERS:
*   lParam2 - REMOVE_MISSING or REMOVE_ALL
*
*******************************************************************************/

BOOL RemoveMissingProc(
    PBATTERY_STATE   pbs,
    HWND             hWnd,
    LPARAM           lParam1,
    LPARAM           lParam2)
{
    UINT    i;
    LPTSTR  *pszDeviceNames;

    if (lParam2 == REMOVE_MISSING) {
        if ((pszDeviceNames = (LPTSTR *)lParam1) != NULL) {
            for (i = 0; i < NUM_BAT; i++) {
                if (pszDeviceNames[i]) {
                    if (!lstrcmp(pbs->lpszDeviceName, pszDeviceNames[i])) {
                        // Device found in device list, leave it alone.
                        return TRUE;
                    }
                }
                else {
                    continue;
                }
            }
        }
    }

    // Device not in the device names list, remove it.
    RemoveBatteryStateDevice(pbs);
    return TRUE;
}

/*******************************************************************************
*
* FindNameProc
*
*  DESCRIPTION:
*   Returns FALSE (stop searching) if we find the name, else TRUE.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL FindNameProc(PBATTERY_STATE pbs, HWND hWnd, LPARAM lParam1, LPARAM lParam2)
{
    if (lParam1) {
        if (!lstrcmp(pbs->lpszDeviceName, (LPTSTR)lParam1)) {
            // Device found in device list.
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batmeter\bmresid.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       BMRESID.H
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*
*  Resource identifiers for the battery meter helper DLL.
*
*******************************************************************************/

#define IDC_STATIC                      -1

//  Dialog box control identifiers.
#define IDD_BATMETER                    100
#define IDD_BATDETAIL                   126
#define IDD_MOREINFO                    127

//  Control identifiers of IDD_BATMETER
#define IDC_BATTERYLEVEL                1001
#define IDC_REMAINING                   1002
#define IDC_POWERSTATUSICON             1003
#define IDC_POWERSTATUSBAR              1004
#define IDC_BARPERCENT                  1005
#define IDC_CHARGING                    1006
#define IDC_MOREINFO                    1007
#define IDC_BATNUM0                     1008
#define IDC_TOTALTIME                   1067
#define IDC_TIMEREMAINING               1068
#define IDC_CURRENTPOWERSOURCE          1069
#define IDC_TOTALBATPWRREMAINING        1070

// next eight must be consecutive...
#define IDC_POWERSTATUSICON1            1010
#define IDC_POWERSTATUSICON2            1011
#define IDC_POWERSTATUSICON3            1012
#define IDC_POWERSTATUSICON4            1013
#define IDC_POWERSTATUSICON5            1014
#define IDC_POWERSTATUSICON6            1015
#define IDC_POWERSTATUSICON7            1016
#define IDC_POWERSTATUSICON8            1017

// next eight must be consecutive...
#define IDC_REMAINING1                  1020
#define IDC_REMAINING2                  1021
#define IDC_REMAINING3                  1022
#define IDC_REMAINING4                  1023
#define IDC_REMAINING5                  1024
#define IDC_REMAINING6                  1025
#define IDC_REMAINING7                  1026
#define IDC_REMAINING8                  1027

// next eight must be consecutive...
#define IDC_STATUS1                     1030
#define IDC_STATUS2                     1031
#define IDC_STATUS3                     1032
#define IDC_STATUS4                     1033
#define IDC_STATUS5                     1034
#define IDC_STATUS6                     1035
#define IDC_STATUS7                     1036
#define IDC_STATUS8                     1037

// next eight must be consecutive...
#define IDC_BATNUM1                     1040
#define IDC_BATNUM2                     1041
#define IDC_BATNUM3                     1042
#define IDC_BATNUM4                     1043
#define IDC_BATNUM5                     1044
#define IDC_BATNUM6                     1045
#define IDC_BATNUM7                     1046
#define IDC_BATNUM8                     1047


//  Control identifiers of IDD_BATDETAIL
#define IDC_BAT_NUM_GROUP               1100
#define IDC_STATE                       1101
#define IDC_CHEM                        1102
#define IDC_DEVNAME                     1103
#define IDC_BATMANDATE                  1104
#define IDC_BATID                       1105
#define IDC_BATMANNAME                  1106
#define IDC_REFRESH                     1107
#define IDC_BATMETERGROUPBOX            1108
#define IDC_BATMETERGROUPBOX1           1109
#define IDC_BATTERYNAME                 1110
#define IDC_UNIQUEID                    1111
#define IDC_MANUFACTURE                 1112
#define IDC_DATEMANUFACTURED            1113
#define IDC_CHEMISTRY                   1114
#define IDC_POWERSTATE                  1115

// String identifiers of IDD_BATMETER.
#define IDS_ACLINEONLINE                        100
#define IDS_BATTERYLEVELFORMAT                  101
#define IDS_UNKNOWN                             102
#define IDS_PERCENTREMAININGFORMAT              104
#define IDS_TIMEREMFORMATHOUR                   105
#define IDS_TIMEREMFORMATMIN                    106
#define IDS_BATTERIES                           109
#define IDS_NOT_PRESENT                         110
#define IDS_BATTCHARGING                        111
#define IDS_BATNUM                              112
#define IDS_BATTERYNUMDETAILS                   113
#define IDS_BATTERY_POWER_ON_LINE               114
#define IDS_BATTERY_DISCHARGING                 115
#define IDS_BATTERY_CHARGING                    116
#define IDS_BATTERY_CRITICAL                    117

// Image identifiers for IDB_BATTS, the IDI_* values MUST be sequential
// and in this order. Images are contained in the IDB_BATTS resource.
#define IDI_BATFULL     200
#define IDI_BATHALF     201
#define IDI_BATLOW      202
#define IDI_BATDEAD     203
#define IDI_UNKNOWN     204
#define IDI_BATGONE     205
#define IDI_PLUG        206
#define IDI_CHARGE      207
#define IDI_BATTPLUG    208
#define IDI_BATTERY     209

// Bitmap identifiers of IDD_BATMETER.
#define IDB_BATTS                       300
#define IDB_BATTS16                     301

// Definitions for image list.
#define FIRST_ICON_IMAGE        IDI_BATFULL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batmeter\batmeter.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       BATMETER.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*
*   Implements the battery meter of the PowerCfg or SysTray battery
*   meter windows. The battery meter has two display modes, single and
*   multi-battery. In single mode, a representation of the total of all battery
*   capacity in a system is displayed. In multi-battery mode, battery
*   information is displayed for each individual battery as well as the total.
*
*   The battery meter parent window receives notification from USER when
*   any battery status has changed through the WM_POWERBROADCAST,
*   PBT_APMPOWERSTATUSCHANGE message.
*
*   ??? We need to add perfmon support: Create and maintain keys/values
*   under HKEY_PERFORMANCE_DATA.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>

#include <dbt.h>
#include <objbase.h>
#include <initguid.h>
#include <ntpoapi.h>
#include <poclass.h>

#include <setupapi.h>
#include <syssetup.h>
#include <setupbat.h>
#include <ccstock.h>

#include <help.h>

#include "powrprofp.h"
#include "batmeter.h"
#include "bmresid.h"
#include "..\powercfg\PwrMn_cs.h"
#include "shfusion.h"

// Simulated battery only for debug build.
#ifndef DEBUG
#undef SIM_BATTERY
#endif


// Define some things for debug.h.  Required when you include ccstock.h in
// one and only one file.
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "BATMETER"
#define SZ_MODULE           "BATMETER"
#define DECLARE_DEBUG

#include <debug.h>



/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

HINSTANCE   g_hInstance;        // Global instance handle of this DLL.
HWND        g_hwndParent;       // Parent of the battery meter.
HWND        g_hwndBatMeter;     // Battery meter.

// The following constant global array is used to walk through the
// control ID's in the battery metter dialog box. It makes getting
// a control ID from a battery number easy.

#define BAT_ICON      0
#define BAT_STATUS    1
#define BAT_REMAINING 2
#define BAT_NUM       3
#define BAT_LAST      BAT_NUM+1

UINT g_iMapBatNumToID [NUM_BAT+1][4]={
    {IDC_POWERSTATUSICON,  IDC_POWERSTATUSBAR, IDC_REMAINING, IDC_BATNUM0},
    {IDC_POWERSTATUSICON1, IDC_STATUS1, IDC_REMAINING1, IDC_BATNUM1},
    {IDC_POWERSTATUSICON2, IDC_STATUS2, IDC_REMAINING2, IDC_BATNUM2},
    {IDC_POWERSTATUSICON3, IDC_STATUS3, IDC_REMAINING3, IDC_BATNUM3},
    {IDC_POWERSTATUSICON4, IDC_STATUS4, IDC_REMAINING4, IDC_BATNUM4},
    {IDC_POWERSTATUSICON5, IDC_STATUS5, IDC_REMAINING5, IDC_BATNUM5},
    {IDC_POWERSTATUSICON6, IDC_STATUS6, IDC_REMAINING6, IDC_BATNUM6},
    {IDC_POWERSTATUSICON7, IDC_STATUS7, IDC_REMAINING7, IDC_BATNUM7},
    {IDC_POWERSTATUSICON8, IDC_STATUS8, IDC_REMAINING8, IDC_BATNUM8}
};

// Global battery state list. This list has the composite system battery state
// as it's always present head. individual battery devices are linked to this
// head. Use WalkBatteryState(ALL, ... to walk the entire list, including the
// head. Use WalkBatteryState(DEVICES, ... to walk just the device list. If a
// battery is in this list, it's displayable. g_uiBatCount is the count of
// battery devices in this list. The composite battery is not counted. The
// g_pbs array provides a handy UI battery number to pbs conversion. The
// following three variables are only changed during DeviceChanged.

BATTERY_STATE   g_bs;
UINT            g_uiBatCount;
PBATTERY_STATE  g_pbs[NUM_BAT+1];
LPTSTR          g_lpszDriverNames[NUM_BAT];
UINT            g_uiDriverCount;
BOOL            g_bShowingMulti;

// The following array provides context sensitive help associations between
// resource control identifiers and help resource string identifiers.

const DWORD g_ContextMenuHelpIDs[] =
{
    IDC_BATMETERGROUPBOX,       IDH_COMM_GROUPBOX,
    IDC_BATMETERGROUPBOX1,      IDH_COMM_GROUPBOX,
    IDC_POWERSTATUSICON,        NO_HELP,
    IDC_POWERSTATUSICON1,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON2,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON3,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON4,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON5,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON6,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON7,       IDH_BATMETER_CHARGING_ICON,
    IDC_POWERSTATUSICON8,       IDH_BATMETER_CHARGING_ICON,
    IDC_BATNUM1,                NO_HELP,
    IDC_BATNUM2,                NO_HELP,
    IDC_BATNUM3,                NO_HELP,
    IDC_BATNUM4,                NO_HELP,
    IDC_BATNUM5,                NO_HELP,
    IDC_BATNUM6,                NO_HELP,
    IDC_BATNUM7,                NO_HELP,
    IDC_BATNUM8,                NO_HELP,
    IDC_STATUS1,                NO_HELP,
    IDC_STATUS2,                NO_HELP,
    IDC_STATUS3,                NO_HELP,
    IDC_STATUS4,                NO_HELP,
    IDC_STATUS5,                NO_HELP,
    IDC_STATUS6,                NO_HELP,
    IDC_STATUS7,                NO_HELP,
    IDC_STATUS8,                NO_HELP,
    IDC_MOREINFO,               NO_HELP,
    IDC_CURRENTPOWERSOURCE,     IDH_BATMETER_CURPOWERSOURCE,
    IDC_BATTERYLEVEL,           IDH_BATMETER_CURPOWERSOURCE,
    IDC_TOTALBATPWRREMAINING,   IDH_BATMETER_TOTALBATPOWER,
    IDC_REMAINING,              IDH_BATMETER_TOTALBATPOWER,
    IDC_POWERSTATUSBAR,         IDH_BATMETER_TOTALBATPOWER,
    IDC_BARPERCENT,             IDH_BATMETER_TOTALBATPOWER,
    IDC_TOTALTIME,              IDH_BATMETER_TOTALTIME,
    IDC_TIMEREMAINING,          IDH_BATMETER_TOTALTIME,
    IDC_BATTERYNAME,            IDH_DETAILED_BATINFO_LABELS,
    IDC_DEVNAME,                IDH_DETAILED_BATINFO_LABELS,
    IDC_UNIQUEID,               IDH_DETAILED_BATINFO_LABELS,
    IDC_BATID,                  IDH_DETAILED_BATINFO_LABELS,
    IDC_MANUFACTURE,            IDH_DETAILED_BATINFO_LABELS,
    IDC_BATMANNAME,             IDH_DETAILED_BATINFO_LABELS,
    IDC_DATEMANUFACTURED,       IDH_DETAILED_BATINFO_LABELS,
    IDC_BATMANDATE,             IDH_DETAILED_BATINFO_LABELS,
    IDC_CHEMISTRY,              IDH_DETAILED_BATINFO_LABELS,
    IDC_CHEM,                   IDH_DETAILED_BATINFO_LABELS,
    IDC_POWERSTATE,             IDH_DETAILED_BATINFO_LABELS,
    IDC_STATE,                  IDH_DETAILED_BATINFO_LABELS,
    IDC_REFRESH,                IDH_DETAILED_BATINFO_REFRESH,
    0, 0
};

/*******************************************************************************
*
*               P U B L I C   E N T R Y   P O I N T S
*
*******************************************************************************/

/*******************************************************************************
*
*  DllInitialize
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL DllInitialize(IN PVOID hmod, IN ULONG ulReason, IN PCONTEXT pctx OPTIONAL)
{
    UNREFERENCED_PARAMETER(pctx);

    switch (ulReason) {

        case DLL_PROCESS_ATTACH:
            g_hInstance = hmod;
            DisableThreadLibraryCalls(g_hInstance);
            SHFusionInitializeFromModuleID(hmod, 124);
            break;

        case DLL_PROCESS_DETACH:
            SHFusionUninitialize();
            break;
    }
    return TRUE;
}

/*******************************************************************************
*
*  PowerCapabilities
*
*  DESCRIPTION:
*   This public function is used to determine if the system has any power
*   management capabilities which require UI support. Return TRUE if power
*   management UI should be displayed.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL PowerCapabilities()
{
    SYSTEM_POWER_CAPABILITIES   spc;
    int   dummy;

#ifndef SIM_BATTERY
    if (GetPwrCapabilities(&spc)) {
        if ((spc.PowerButtonPresent) ||
            (spc.SleepButtonPresent) ||
            (spc.LidPresent) ||
            (spc.SystemS1) ||
            (spc.SystemS2) ||
            (spc.SystemS3) ||
            (spc.SystemS4) ||
            (spc.SystemS5) ||
            (spc.DiskSpinDown) ||
            (spc.SystemBatteriesPresent)) {
            return TRUE;
        }
        else {
            if (SystemParametersInfo(SPI_GETLOWPOWERACTIVE, 0, &dummy, 0)) {
                return TRUE;
            }
        }
    }
    return FALSE;
#else
    return TRUE;
#endif
}

/*******************************************************************************
*
*  BatMeterCapabilities
*
*  DESCRIPTION:
*   This public function is used to determine if the battery meter library
*   can run on the host machine. Return TRUE on success (battery meter can run).
*
*  PARAMETERS:
*   ppuiBatCount - Points to a pointer which will be filled in with a pointer
*                  to the global battery count.
*
*******************************************************************************/

BOOL BatMeterCapabilities(
    PUINT   *ppuiBatCount
)
{
#ifndef SIM_BATTERY
    SYSTEM_POWER_CAPABILITIES   spc;
#endif // SIM_BATTERY

    if (ppuiBatCount) {
        *ppuiBatCount = &g_uiBatCount;
    }
    g_uiBatCount = 0;

#ifndef SIM_BATTERY
    // Make sure we have batteries to query.
    if (GetPwrCapabilities(&spc)) {
        if (spc.SystemBatteriesPresent) {
            g_uiDriverCount = GetBatteryDriverNames(g_lpszDriverNames);
            if (g_uiDriverCount != 0) {
                g_uiBatCount = g_uiDriverCount;

                return TRUE;
            }
            else {
                BATTRACE(( "BatMeterCapabilities, no battery drivers found."));
            }
        }
    }
    return FALSE;

#else // SIM_BATTERY
    g_uiBatCount = g_uiDriverCount = GetBatteryDriverNames(g_lpszDriverNames);
    return UpdateDriverList(g_lpszDriverNames, g_uiDriverCount);
#endif // SIM_BATTERY

}


/*******************************************************************************
*
*  CreateBatMeter
*
*  DESCRIPTION:
*   Create, fetch data for and draw the battery meter window. Returns a handle
*   to the newly created battery meter window on success, NULL on failure.
*
*  PARAMETERS:
*   hwndParent      - Parent of the battery meter dialog.
*   wndFrame        - Frame to locate the battery meter dialog.
*   bShowMulti      - Specifies the display mode (TRUE -> multiple battery).
*   pbsComposite    - Optional pointer to composite battery state.
*
*******************************************************************************/

HWND CreateBatMeter(
    HWND            hwndParent,
    HWND            hwndFrame,
    BOOL            bShowMulti,
    PBATTERY_STATE  pbsComposite
)
{
    INT iWidth, iHeight;
    RECT rFrame = {0};

    // Build the battery devices name list if hasn't already been built.
    if (!g_uiBatCount)
    {
        BatMeterCapabilities(NULL);
    }

    // Remember if we are showing details for each battery
    g_bShowingMulti = bShowMulti;

    // Make sure we have at least one battery.
    if (g_uiBatCount)
    {
        // Create the battery meter control.
        g_hwndParent = hwndParent;
        g_hwndBatMeter = CreateDialog(g_hInstance,
                                MAKEINTRESOURCE(IDD_BATMETER),
                                hwndParent,
                                BatMeterDlgProc);

        // Place the battery meter in the passed frame window.
        if ((g_hwndBatMeter) && (hwndFrame))
        {
            // Position the BatMeter dialog in the frame.
            if (!GetWindowRect(hwndFrame, &rFrame))
            {
                BATTRACE(( "CreateBatMeter, GetWindowRect failed, hwndFrame: %08X", hwndFrame));
            }

            iWidth  = rFrame.right  - rFrame.left;
            iHeight = rFrame.bottom - rFrame.top;

            if (IsBiDiLocalizedSystemEx(NULL))
            {
                // Whistler #209400: On BIDI systems, ScreenToClient() wants the right
                // coord in the left location because everything is flipped.
                rFrame.left = rFrame.right;
            }

            if (!ScreenToClient(hwndParent, (LPPOINT)&rFrame))
            {
                BATTRACE(( "CreateBatMeter, ScreenToClient failed"));
            }

            if (!MoveWindow(g_hwndBatMeter,
                         rFrame.left,
                         rFrame.top,
                         iWidth,
                         iHeight,
                         FALSE))
            {
                BATTRACE(( "CreateBatMeter, MoveWindow failed, %d, %d", rFrame.left, rFrame.top));
            }

            // Build the battery driver data list.
            if (!UpdateDriverList(g_lpszDriverNames, g_uiDriverCount))
            {
                return DestroyBatMeter(g_hwndBatMeter);
            }

            // Do the first update.
            UpdateBatMeter(g_hwndBatMeter, bShowMulti, TRUE, pbsComposite);
            ShowWindow(g_hwndBatMeter, SW_SHOWNOACTIVATE);
        }
    }

   return g_hwndBatMeter;
}

/*******************************************************************************
*
*  DestroyBatMeter
*
*  DESCRIPTION:
*
*******************************************************************************/

HWND DestroyBatMeter(HWND hWnd)
{
   SendMessage(hWnd, WM_DESTROYBATMETER, 0, 0);
   g_hwndBatMeter = NULL;
   return g_hwndBatMeter;
}

/*******************************************************************************
*
*  UpdateBatMeter
*
*  DESCRIPTION:
*   This function should be called when the battery meter parent window
*   receives a WM_POWERBROADCAST, PBT_APMPOWERSTATUSCHANGE message, it will
*   update the data in the global battery state list. If needed the display
*   will also be updated.
*
*  PARAMETERS:
*   HWND hwndBatMeter,          hWnd of the battery meter dialog
*   BOOL bShowMulti,            Specifies the display mode
*   BOOL bForceUpdate,          Forces a UI update
*   PBATTERY_STATE pbsComposite Optional pointer to composite battery state.
*
*******************************************************************************/

BOOL UpdateBatMeter(
    HWND            hWnd,
    BOOL            bShowMulti,
    BOOL            bForceUpdate,
    PBATTERY_STATE  pbsComposite
)
{
    BOOL bRet = FALSE;
    SYSTEM_POWER_STATUS sps;
    UINT uIconID;

    // Update the composite battery state.
    if (GetSystemPowerStatus(&sps) && hWnd) {
        if (sps.BatteryLifePercent > 100) {
            BATTRACE(( "GetSystemPowerStatuse, set BatteryLifePercent: %d", sps.BatteryLifePercent));
        }

        // Fill in the composite battery state.
        SystemPowerStatusToBatteryState(&sps, &g_bs);

        // Update the information in the battery state list if we have a battery.
        if (g_hwndBatMeter) {

#ifndef SIM_BATTERY
           WalkBatteryState(DEVICES,
                            (WALKENUMPROC)UpdateBatInfoProc,
                            NULL,
                            (LPARAM)NULL,
                            (LPARAM)NULL);
#else
           WalkBatteryState(DEVICES,
                            (WALKENUMPROC)SimUpdateBatInfoProc,
                            NULL,
                            (LPARAM)NULL,
                            (LPARAM)NULL);
#endif

           // See if the current display mode matches the requested mode.
           if ((g_bShowingMulti != bShowMulti) || (bForceUpdate)) {
               g_bShowingMulti = SwitchDisplayMode(hWnd, bShowMulti);
               bForceUpdate  = TRUE;
           }

           if (g_bShowingMulti) {
               // Walk the bs list, and update all battery displays.
               WalkBatteryState(ALL,
                                (WALKENUMPROC)UpdateBatMeterProc,
                                hWnd,
                                (LPARAM)g_bShowingMulti,
                                (LPARAM)bForceUpdate);
           }
           else {
               // Display only the comosite battery information.
               UpdateBatMeterProc(&g_bs,
                                  hWnd,
                                  (LPARAM)g_bShowingMulti,
                                  (LPARAM)bForceUpdate);
           }
           bRet = TRUE;
        }
    }
    else {
        // Fill in default composite info.
        g_bs.ulPowerState     = BATTERY_POWER_ON_LINE;
        g_bs.ulBatLifePercent = (UINT) -1;
        g_bs.ulBatLifeTime    = (UINT) -1;

        uIconID = MapBatInfoToIconID(&g_bs);
        g_bs.hIconCache = GetBattIcon(hWnd, uIconID, g_bs.hIconCache, FALSE, 32);
        g_bs.hIconCache16 = GetBattIcon(hWnd, uIconID, g_bs.hIconCache16, FALSE, 16);
    }

    // If a pointer is provided, copy the composite battery state data.
    if (pbsComposite) {
        if (pbsComposite->ulSize == sizeof(BATTERY_STATE)) {
            memcpy(pbsComposite, &g_bs, sizeof(BATTERY_STATE));
        }
        else {
            BATTRACE(( "UpdateBatMeter, passed BATTERY_STATE size is invalid"));
        }
    }
    return bRet;
}

/*******************************************************************************
*
*                 P R I V A T E   F U N C T I O N S
*
*******************************************************************************/

/*******************************************************************************
*
*  LoadDynamicString
*
*  DESCRIPTION:
*     Wrapper for the FormatMessage function that loads a string from our
*     resource table into a dynamically allocated buffer, optionally filling
*     it with the variable arguments passed.
*
*  PARAMETERS:
*     uiStringID    - resource identifier of the string to use.
*     ...           - Optional parameters to use to format the string message.
*
*******************************************************************************/

LPTSTR CDECL LoadDynamicString(UINT uiStringID, ... )
{
    va_list Marker;
    TCHAR szBuf[256];
    LPTSTR lpsz;
    int   iLen;

    // va_start is a macro...it breaks when you use it as an assign...on ALPHA.
    va_start(Marker, uiStringID);

    iLen = LoadString(g_hInstance, uiStringID, szBuf, ARRAYSIZE(szBuf));

    if (iLen == 0) {
        BATTRACE(( "LoadDynamicString: LoadString on: 0x%X failed", uiStringID));
        return NULL;
    }

    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                  (LPVOID) szBuf, 0, 0, (LPTSTR)&lpsz, 0, &Marker);

    return lpsz;
}

/*******************************************************************************
*
*  DisplayFreeStr
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

LPTSTR DisplayFreeStr(HWND hWnd, UINT uID, LPTSTR  lpsz, BOOL bFree)
{
    if (lpsz) {
        SetDlgItemText(hWnd, uID, lpsz);
        ShowWindow(GetDlgItem(hWnd, uID), SW_SHOWNOACTIVATE);
        if (bFree) {
            LocalFree(lpsz);
            return NULL;
        }
    }
    else {
        ShowWindow(GetDlgItem(hWnd, uID), SW_HIDE);
    }
    return lpsz;
}

/*******************************************************************************
*
*  ShowHideItem
*  ShowItem
*  HideItem
*
*  DESCRIPTION:
*     Handy helpers to show or hide dialog items in the battery meter dialog.
*
*  PARAMETERS:
*     hWnd - Battery meter dialog handle.
*     uID  - Control ID of control to be shown or hidden.
*
*******************************************************************************/

BOOL ShowHideItem(HWND hWnd, UINT uID, BOOL bShow)
{
    ShowWindow(GetDlgItem(hWnd, uID), (bShow)  ? SW_SHOWNOACTIVATE : SW_HIDE);
    return bShow;
}

void ShowItem(HWND hWnd, UINT uID)
{
    ShowWindow(GetDlgItem(hWnd, uID), SW_SHOWNOACTIVATE);
}

void HideItem(HWND hWnd, UINT uID)
{
    ShowWindow(GetDlgItem(hWnd, uID), SW_HIDE);
}

/*******************************************************************************
*
*  SwitchDisplayMode
*
*  DESCRIPTION:
*   Return TRUE if display is switched to multi battery mode.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL SwitchDisplayMode(HWND hWnd, BOOL bShowMulti)
{
    ULONG i, j;

    // Override request if multi-battery display is not possible.
    if ((bShowMulti) && (!g_uiBatCount)) {
        bShowMulti = FALSE;
    }

    if (!g_uiBatCount) {

        //
        // Hide all info if no batteries are installed
        //
        HideItem(hWnd, IDC_POWERSTATUSBAR);
        HideItem(hWnd, IDC_BARPERCENT);
        HideItem(hWnd, IDC_MOREINFO);

    } else if (bShowMulti) {
        HideItem(hWnd, IDC_POWERSTATUSBAR);
        HideItem(hWnd, IDC_BARPERCENT);
        ShowItem(hWnd, IDC_MOREINFO);

        for (i = 1; i <= g_uiBatCount; i++) {
            for (j = 0; j < BAT_LAST; j++) {
                ShowItem(hWnd, g_iMapBatNumToID[i][0]);
            }
        }
    }
    else {
        for (i = 1; i <= g_uiBatCount; i++) {
            for (j = 0; j < BAT_LAST; j++) {
                HideItem(hWnd, g_iMapBatNumToID[i][j]);
            }
        }

        ShowItem(hWnd, IDC_POWERSTATUSBAR);
        ShowItem(hWnd, IDC_BARPERCENT);
        HideItem(hWnd, IDC_MOREINFO);
    }
    return bShowMulti;
}

/*******************************************************************************
*
*  CleanupBatteryData
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void CleanupBatteryData(void)
{
   g_hwndBatMeter = NULL;

   // Mark all batteries as missing.
   memset(&g_pbs, 0, sizeof(g_pbs));

   // Walk the bs list, remove all devices and cleanup.
   WalkBatteryState(DEVICES,
                    (WALKENUMPROC)RemoveMissingProc,
                    NULL,
                    (LPARAM)NULL,
                    (LPARAM)REMOVE_ALL);

   // Free any old driver names.
   FreeBatteryDriverNames(g_lpszDriverNames);
   g_uiBatCount = 0;
}

/*******************************************************************************
*
*  BatMeterDlgProc
*
*  DESCRIPTION:
*   DialogProc for the Battery Meter control. Provide support for more battery
*   info.
*
*  PARAMETERS:
*
*******************************************************************************/

LRESULT CALLBACK BatMeterDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
#ifdef WINNT
    UINT i, j;
    PBATTERY_STATE pbsTemp;
#endif // WINNT

    UINT uiBatNum;

   switch (uMsg) {
      case WM_COMMAND:
         if ((HIWORD(wParam) == STN_CLICKED) ||
             (HIWORD(wParam) == BN_CLICKED)) {
            switch (LOWORD(wParam)) {
               case IDC_POWERSTATUSICON1:
               case IDC_POWERSTATUSICON2:
               case IDC_POWERSTATUSICON3:
               case IDC_POWERSTATUSICON4:
               case IDC_POWERSTATUSICON5:
               case IDC_POWERSTATUSICON6:
               case IDC_POWERSTATUSICON7:
               case IDC_POWERSTATUSICON8:
                  uiBatNum = LOWORD(wParam) - IDC_POWERSTATUSICON1 + 1;
                  // Allow battery details only for present batteries.
                  if ((g_pbs[uiBatNum]) &&
                      (g_pbs[uiBatNum]->ulTag != BATTERY_TAG_INVALID)) {
                     DialogBoxParam(g_hInstance,
                                    MAKEINTRESOURCE(IDD_BATDETAIL),
                                    hWnd,
                                    BatDetailDlgProc,
                                    (LPARAM)g_pbs[uiBatNum]);
                  }
                  break;
            }
         }
         break;

      case WM_DESTROYBATMETER:
         CleanupBatteryData();
         EndDialog(hWnd, wParam);
         break;

      case WM_DESTROY:
         CleanupBatteryData();
         break;

      case WM_DEVICECHANGE:
#ifdef WINNT
         if ((wParam == DBT_DEVICEQUERYREMOVE) || (wParam == DBT_DEVICEREMOVECOMPLETE)) {
            if ( ((PDEV_BROADCAST_HANDLE)lParam)->dbch_devicetype == DBT_DEVTYP_HANDLE) {

               //
               // Find Device that got removed
               //
               pbsTemp = DEVICES;
               while (pbsTemp) {
                  if (pbsTemp->hDevNotify == ((PDEV_BROADCAST_HANDLE)lParam)->dbch_hdevnotify) {
                     break;
                  }
                  pbsTemp = pbsTemp->bsNext;
               }
               if (!pbsTemp) {
                  break;
               }

               //
               // Close the handle to this device and release cached data.
               //
               RemoveBatteryStateDevice (pbsTemp);
               g_uiDriverCount--;
               g_uiBatCount = g_uiDriverCount;

               // Clear and rebuild g_pbs, the handy batttery number to pbs array.
               memset(&g_pbs, 0, sizeof(g_pbs));
               pbsTemp = &g_bs;
               for (i = 0; i <= g_uiBatCount; i++) {
                  if (pbsTemp) {
                     g_pbs[i] = pbsTemp;
                     pbsTemp->ulBatNum = i;
                     pbsTemp = pbsTemp->bsNext;
                  }
               }

               // Refresh display
               for (i = 1; i <= NUM_BAT; i++) {
                  for (j = 0; j < BAT_LAST; j++) {
                     HideItem(g_hwndBatMeter, g_iMapBatNumToID[i][j]);
                  }
               }

               g_bShowingMulti = SwitchDisplayMode (g_hwndBatMeter, g_bShowingMulti);
               if (g_bShowingMulti) {
                  // Walk the bs list, and update all battery displays.
                  WalkBatteryState(DEVICES,
                                   (WALKENUMPROC)UpdateBatMeterProc,
                                   g_hwndBatMeter,
                                   (LPARAM)g_bShowingMulti,
                                   (LPARAM)TRUE);
               }
            }
         }
#else
         if (wParam == DBT_DEVICEQUERYREMOVE) {
            if (g_hwndBatMeter) {
               // Close all of the batteries.
               CleanupBatteryData();
            }
         }
#endif
         return TRUE;

      case WM_HELP:             // F1
         WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_ContextMenuHelpIDs);
         return TRUE;

      case WM_CONTEXTMENU:      // right mouse click
         WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_ContextMenuHelpIDs);
         return TRUE;
   }
   return FALSE;
}

/*******************************************************************************
*
*  GetBattIcon
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

HICON PASCAL GetBattIcon(
    HWND    hWnd,
    UINT    uIconID,
    HICON   hIconCache,
    BOOL    bWantBolt,
    UINT    uiRes)
{
    static HIMAGELIST hImgLst32, hImgLst16;
    HIMAGELIST hImgLst;
    int ImageIndex;

    // Destroy the old cached icon.
    if (hIconCache) {
        DestroyIcon(hIconCache);
    }

    // Don't put the charging bolt over the top of IDI_BATGONE.
    if (uIconID == IDI_BATGONE) {
        bWantBolt = FALSE;
    }

    // Use the transparency color must match that in the bit maps.
    if (!hImgLst32 || !hImgLst16) {
        hImgLst32 = ImageList_LoadImage(g_hInstance,
                                        MAKEINTRESOURCE(IDB_BATTS),
                                        32, 0, RGB(255, 0, 255), IMAGE_BITMAP, 0);
        hImgLst16 = ImageList_LoadImage(g_hInstance,
                                        MAKEINTRESOURCE(IDB_BATTS16),
                                        16, 0, RGB(255, 0, 255), IMAGE_BITMAP, 0);
        ImageList_SetOverlayImage(hImgLst32, IDI_CHARGE-FIRST_ICON_IMAGE, 1);
        ImageList_SetOverlayImage(hImgLst16, IDI_CHARGE-FIRST_ICON_IMAGE, 1);
    }

    if (uiRes == 32) {
        hImgLst = hImgLst32;
    }
    else {
        hImgLst = hImgLst16;
    }

    ImageIndex = uIconID - FIRST_ICON_IMAGE;

    if (bWantBolt) {
        return ImageList_GetIcon(hImgLst, ImageIndex, INDEXTOOVERLAYMASK(1));
    }
    else {
        return ImageList_GetIcon(hImgLst, ImageIndex, ILD_NORMAL);
    }
}

/*******************************************************************************
*
*  CheckUpdateBatteryState
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

#define UPDATESTATUS_NOUPDATE        0
#define UPDATESTATUS_UPDATE          1
#define UPDATESTATUS_UPDATE_CHARGE   2

UINT CheckUpdateBatteryState(
    PBATTERY_STATE   pbs,
    BOOL             bForceUpdate
)
{
    UINT uiRetVal = UPDATESTATUS_NOUPDATE;

    // Check to see if anything in the battery status has changed
    // since last time.  If not then we have no work to do!

    if ((bForceUpdate) ||
        !((pbs->ulTag            == pbs->ulLastTag) &&
          (pbs->ulBatLifePercent == pbs->ulLastBatLifePercent) &&
          (pbs->ulBatLifeTime    == pbs->ulLastBatLifeTime) &&
          (pbs->ulPowerState     == pbs->ulLastPowerState))) {

        uiRetVal = UPDATESTATUS_UPDATE;

        //  Check for the special case where the charging state has changed.
        if ((pbs->ulPowerState     & BATTERY_CHARGING) !=
            (pbs->ulLastPowerState & BATTERY_CHARGING)) {
                uiRetVal |= UPDATESTATUS_UPDATE_CHARGE;
        }

        // Copy current battery state to last.
        pbs->ulLastTag            = pbs->ulTag;
        pbs->ulLastBatLifePercent = pbs->ulBatLifePercent;
        pbs->ulLastBatLifeTime    = pbs->ulBatLifeTime;
        pbs->ulLastPowerState     = pbs->ulPowerState;
    }
    return uiRetVal;
}

/*******************************************************************************
*
*  MapBatInfoToIconID
*
*  DESCRIPTION:
*    Map battery info to an Icon ID.
*
*  PARAMETERS:
*    ulBatNum - Zero implies composite system state
*
*******************************************************************************/

UINT MapBatInfoToIconID(PBATTERY_STATE pbs)
{
    UINT uIconID = IDI_BATDEAD;

    if (!pbs->ulBatNum) {
        if (pbs->ulPowerState & BATTERY_POWER_ON_LINE) {
            return IDI_PLUG;
        }
    }
    else {
        if (pbs->ulTag == BATTERY_TAG_INVALID) {
            return IDI_BATGONE;
        }
    }

    if  (pbs->ulPowerState & BATTERY_CRITICAL) {
        return IDI_BATDEAD;
    }

    if (pbs->ulBatLifePercent > 66) {
        uIconID = IDI_BATFULL;
    }
    else {
        if (pbs->ulBatLifePercent > 33) {
            uIconID = IDI_BATHALF;
        }
        else {
            if (pbs->ulBatLifePercent > 9) {
                uIconID = IDI_BATLOW;
            }
        }
    }

    return uIconID;
}

/*******************************************************************************
*
*  DisplayIcon
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

void DisplayIcon(
    HWND            hWnd,
    UINT            uIconID,
    PBATTERY_STATE  pbs,
    ULONG           ulUpdateStatus
)
{
    BOOL    bBolt;
    UINT    uiMsg;

    // Only redraw the icon if it has changed OR
    // if it has gone from charging to not charging.
    if ((uIconID != pbs->uiIconIDcache) ||
        (ulUpdateStatus != UPDATESTATUS_NOUPDATE)) {

        pbs->uiIconIDcache = uIconID;
        bBolt = (pbs->ulPowerState & BATTERY_CHARGING);

        pbs->hIconCache   = GetBattIcon(hWnd, uIconID, pbs->hIconCache, bBolt, 32);
        pbs->hIconCache16 = GetBattIcon(hWnd, uIconID, pbs->hIconCache16, bBolt, 16);

        if (pbs->ulBatNum) {
            uiMsg = BM_SETIMAGE;
        }
        else {
            uiMsg = STM_SETIMAGE;
        }
        SendDlgItemMessage(hWnd, g_iMapBatNumToID[pbs->ulBatNum][BAT_ICON],
                           uiMsg, IMAGE_ICON, (LPARAM) pbs->hIconCache);
        ShowItem(hWnd, g_iMapBatNumToID[pbs->ulBatNum][BAT_ICON]);
    }
}

/*******************************************************************************
*
*  UpdateBatMeterProc
*
*  DESCRIPTION:
*    Updates the System and per battery UI elements if needed.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL UpdateBatMeterProc(
    PBATTERY_STATE pbs,
    HWND hWnd,
    LPARAM bShowMulti,
    LPARAM bForceUpdate
)
{
    UINT   uIconID, uiHour, uiMin;
    LPTSTR lpsz, lpszRemaining;
    ULONG  ulUpdateStatus;

    ulUpdateStatus = CheckUpdateBatteryState(pbs, (BOOL) bForceUpdate);

    // Make sure there is work to do.
    if (ulUpdateStatus == UPDATESTATUS_NOUPDATE) {
       return TRUE;
    }

    // Determine which icon to display.
    uIconID = MapBatInfoToIconID(pbs);
    DisplayIcon(hWnd, uIconID, pbs, ulUpdateStatus);

    // Are we looking for system power status ?
    if (!pbs->ulBatNum) {

        // Display the Current Power Source text
        lpsz = LoadDynamicString(((pbs->ulPowerState & BATTERY_POWER_ON_LINE) ?
                                   IDS_ACLINEONLINE : IDS_BATTERIES));
        DisplayFreeStr(hWnd, IDC_BATTERYLEVEL, lpsz, FREE_STR);

        if (pbs->ulBatLifePercent <= 100) {
            lpsz = LoadDynamicString(IDS_PERCENTREMAININGFORMAT,
                                        pbs->ulBatLifePercent);
        }
        else {
            lpsz = LoadDynamicString(IDS_UNKNOWN);
        }
        DisplayFreeStr(hWnd, IDC_REMAINING, lpsz, NO_FREE_STR);

        ShowHideItem(hWnd, IDC_CHARGING, pbs->ulPowerState & BATTERY_CHARGING);

        // Show and Update the PowerStatusBar only if in single battery mode and
        // there is al least one battery installed.
        if (!bShowMulti && g_uiBatCount) {
            SendDlgItemMessage(hWnd, IDC_POWERSTATUSBAR, PBM_SETPOS,
                               (WPARAM) pbs->ulBatLifePercent, 0);
            lpsz = DisplayFreeStr(hWnd, IDC_BARPERCENT, lpsz, FREE_STR);
        }

        if (lpsz) {
            LocalFree(lpsz);
        }

        if (pbs->ulBatLifeTime != (UINT) -1) {
            uiHour = pbs->ulBatLifeTime / 3600;
            uiMin  = (pbs->ulBatLifeTime % 3600) / 60;
            if (uiHour) {
                lpsz = LoadDynamicString(IDS_TIMEREMFORMATHOUR, uiHour, uiMin);
            }
            else {
                lpsz = LoadDynamicString(IDS_TIMEREMFORMATMIN, uiMin);
            }
            DisplayFreeStr(hWnd, IDC_TIMEREMAINING, lpsz, FREE_STR);
            ShowHideItem(hWnd, IDC_TOTALTIME, TRUE);
        }
        else {
            ShowHideItem(hWnd, IDC_TOTALTIME, FALSE);
            ShowHideItem(hWnd, IDC_TIMEREMAINING, FALSE);
        }
    }
    else {

        // Here when getting the power status of each individual battery
        // when in multi-battery display mode.
        lpsz = LoadDynamicString(IDS_BATNUM, pbs->ulBatNum);
        DisplayFreeStr(hWnd, g_iMapBatNumToID[pbs->ulBatNum][BAT_NUM],
                       lpsz, FREE_STR);

        if (pbs->ulTag != BATTERY_TAG_INVALID) {
            if (pbs->ulPowerState & BATTERY_CHARGING) {
                lpsz = LoadDynamicString(IDS_BATTCHARGING);
            }
            else {
                lpsz = NULL;
            }
            lpszRemaining  = LoadDynamicString(IDS_PERCENTREMAININGFORMAT,
                                               pbs->ulBatLifePercent);
        }
        else {
            lpsz = LoadDynamicString(IDS_NOT_PRESENT);
            lpszRemaining  = NULL;
        }
        DisplayFreeStr(hWnd, g_iMapBatNumToID[pbs->ulBatNum][BAT_STATUS],
                       lpsz, FREE_STR);

        DisplayFreeStr(hWnd, g_iMapBatNumToID[pbs->ulBatNum][BAT_REMAINING],
                       lpszRemaining, FREE_STR);
    }
    return TRUE;
}

/*******************************************************************************
*
*  FreeBatteryDriverNames
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID FreeBatteryDriverNames(LPTSTR *lpszDriverNames)
{
    UINT i;

    // Free any old driver names.
    for (i = 0; i < NUM_BAT; i++) {
        if (lpszDriverNames[i]) {
            LocalFree(lpszDriverNames[i]);
            lpszDriverNames[i] = NULL;
        }
    }
}

/*******************************************************************************
*
*  GetBatteryDriverNames
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

UINT GetBatteryDriverNames(LPTSTR *lpszDriverNames)
{
    UINT                                uiDriverCount, uiIndex;
    DWORD                               dwReqSize;
    HDEVINFO                            hDevInfo;
    SP_INTERFACE_DEVICE_DATA            InterfaceDevData;
    PSP_INTERFACE_DEVICE_DETAIL_DATA    pFuncClassDevData;

    // Free any old driver names.
    FreeBatteryDriverNames(lpszDriverNames);
    uiDriverCount = 0;

#ifndef SIM_BATTERY
    // Use the SETUPAPI.DLL interface to get the
    // possible battery driver names.
    hDevInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVICE_BATTERY, NULL, NULL,
                                   DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);

    if (hDevInfo != INVALID_HANDLE_VALUE) {
        InterfaceDevData.cbSize = sizeof(SP_DEVINFO_DATA);

        uiIndex = 0;
        while (uiDriverCount < NUM_BAT) {
            if (SetupDiEnumInterfaceDevice(hDevInfo,
                                           0,
                                           (LPGUID)&GUID_DEVICE_BATTERY,
                                           uiIndex,
                                           &InterfaceDevData)) {

                // Get the required size of the function class device data.
                SetupDiGetInterfaceDeviceDetail(hDevInfo,
                                                &InterfaceDevData,
                                                NULL,
                                                0,
                                                &dwReqSize,
                                                NULL);

                pFuncClassDevData = LocalAlloc(0, dwReqSize);
                if (pFuncClassDevData != NULL) {
                    pFuncClassDevData->cbSize =
                        sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);

                    if (SetupDiGetInterfaceDeviceDetail(hDevInfo,
                                                        &InterfaceDevData,
                                                        pFuncClassDevData,
                                                        dwReqSize,
                                                        &dwReqSize,
                                                        NULL)) {

                        dwReqSize = (lstrlen(pFuncClassDevData->DevicePath) + 1) * sizeof(TCHAR);
                        lpszDriverNames[uiDriverCount] = LocalAlloc(0, dwReqSize);

                        if (lpszDriverNames[uiDriverCount]) {
                            lstrcpyn(lpszDriverNames[uiDriverCount],
                                     pFuncClassDevData->DevicePath,
                                     dwReqSize);
                            uiDriverCount++;
                        }
                    }
                    else {
                        BATTRACE(("SetupDiGetInterfaceDeviceDetail, failed: %d", GetLastError()));
                    }

                    LocalFree(pFuncClassDevData);
                }
            } else {
                if (ERROR_NO_MORE_ITEMS == GetLastError()) {
                    break;
                }
                else {
                    BATTRACE(("SetupDiEnumInterfaceDevice, failed: %d", GetLastError()));
                }
            }
            uiIndex++;
        }
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
    else {
        BATTRACE(("SetupDiGetClassDevs on GUID_DEVICE_BATTERY, failed: %d", GetLastError()));
    }
#else
   // Simulate batteries.
   {
      UINT i;
      static UINT uiState = 1;

      uiDriverCount = 0;
      for (i = 0; i <= uiState; i++) {
         lpszDriverNames[i] = LocalAlloc(0, STRSIZE(TEXT("SIMULATED_BATTERY_0")));
         if (lpszDriverNames[i]) {
            wsprintf(lpszDriverNames[i], TEXT("SIMULATED_BATTERY_%d"), i);
            uiDriverCount += 1;
         }
      }
      uiState++;       
      if (uiState >= NUM_BAT) {
         uiState = 0;
      }
   }
#endif
    return uiDriverCount;
}

/*******************************************************************************
*
*  UpdateDriverList
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL UpdateDriverList(
    LPTSTR *lpszDriverNames,
    UINT uiDriverCount
)
{
    UINT            i;
    PBATTERY_STATE  pbs;

    // Walk the bs list, and remove any devices which aren't in pszDeviceNames.
    WalkBatteryState(DEVICES,
                     (WALKENUMPROC)RemoveMissingProc,
                     NULL,
                     (LPARAM)g_lpszDriverNames,
                     (LPARAM)REMOVE_MISSING);

    // Scan the pszDeviceNames list and add any devices which aren't in bs.
    for (i = 0; i < uiDriverCount; i++) {

        if (WalkBatteryState(DEVICES,
                             (WALKENUMPROC)FindNameProc,
                             NULL,
                             (LPARAM)g_lpszDriverNames[i],
                             (LPARAM)NULL)) {

#ifndef SIM_BATTERY
            if (!AddBatteryStateDevice(g_lpszDriverNames[i], i + 1)) {
                // We weren't able get minimal info from driver, dec the
                // battery counts. g_uiBatCount should always be > 0.
                if (--g_uiDriverCount) {;
                    g_uiBatCount--;
                }
            }
#else
            SimAddBatteryStateDevice(g_lpszDriverNames[i], i + 1);
#endif
        }
    }

    // Clear and rebuild g_pbs, the handy batttery number to pbs array.
    memset(&g_pbs, 0, sizeof(g_pbs));
    pbs = &g_bs;
    for (i = 0; i <= g_uiBatCount; i++) {
        if (pbs) {
            g_pbs[i] = pbs;
            pbs = pbs->bsNext;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batmeter\test\bmtest.c ===
//*****************************************************************************
//
// BMTEST.C
//
// DESCRIPTION:
//
//
//*****************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <initguid.h>
#include <devguid.h>
#include <commctrl.h>

typedef LONG NTSTATUS;

#include <cfgmgr32.h>
#include <devioctl.h>
#include <ntpoapi.h>
#include <poclass.h>

#include "batmeter.h"
#include "bmtresid.h"

ULONG _cdecl DbgPrint(PCH Format, ...);

HINSTANCE g_hInstance;

DWORD g_dwCurBat;   // Battery we're currently displaying/editing.
PUINT g_puiBatCount;
BOOL  g_bShowMulti;

LRESULT CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    BOOL     Result;
    DWORD    Version, dwByteCount;


    InitCommonControls();

    g_hInstance = hInstance;

    // Get the battery count.
    if (BatMeterCapabilities(&g_puiBatCount)) {
        DialogBox(hInstance,
                  MAKEINTRESOURCE(IDD_BMTEST),
                  0,
                  DlgProc);
    }
    return 0;
}

//*****************************************************************************
//
// DlgProc
//
// DESCRIPTION:
//
// PARAMETERS:
//
//*****************************************************************************

LRESULT CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND hwndBatMeter;

    switch (uMsg) {
        case WM_INITDIALOG:
            if (*g_puiBatCount > 1) {
                CheckDlgButton(hDlg, IDC_ENABLEMULTI, g_bShowMulti);
            }
            else {
                // Battery meter will not run, disable the enable checkbox
                EnableWindow(GetDlgItem(hDlg, IDC_ENABLEMULTI), FALSE);
            }
            hwndBatMeter = CreateBatMeter(hDlg, GetDlgItem(hDlg, IDC_STATIC_FRAME),
                                          g_bShowMulti, NULL);
            return TRUE;

        case WM_COMMAND:
            switch (wParam) {

                case IDCANCEL:
                case IDOK:
                    EndDialog(hDlg, 0);
                    return TRUE ;

                case IDC_ENABLEMULTI:
                    if (IsDlgButtonChecked(hDlg, IDC_ENABLEMULTI)) {
                        g_bShowMulti = TRUE;
                    }
                    else {
                        g_bShowMulti = FALSE;
                    }
                    UpdateBatMeter(hwndBatMeter, g_bShowMulti, TRUE, NULL);

            } // switch (wParam)
            break;

        case WM_POWERBROADCAST:
            if (wParam == PBT_APMPOWERSTATUSCHANGE) {
                UpdateBatMeter(hwndBatMeter, g_bShowMulti, FALSE, NULL);
            }
            break;

        case WM_DEVICECHANGE:
            BatMeterDeviceChanged(0, 0);
            break;

    } // switch (uMsg)
 
    return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batmeter\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BATMETER.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1075
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batmeter\details.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       DETAILS.C
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Implements the Detailed Batery Information dialog.
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <commctrl.h>

#include <devioctl.h>
#include <ntpoapi.h>
#include <poclass.h>

#include "batmeter.h"
#include "bmresid.h"

/*******************************************************************************
*
*                     G L O B A L    D A T A
*
*******************************************************************************/

extern HINSTANCE   g_hInstance;             // Global instance handle of this DLL.
extern const DWORD g_ContextMenuHelpIDs[];  //Help ID's.

/*******************************************************************************
*
*  AppendStrID
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL 
AppendStrID(
    LPTSTR lpszDest, 
    DWORD DestBufferSizeInChars,
    UINT uiID, 
    BOOLEAN bUseComma)
{
    LPTSTR lpsz;
    DWORD len;
    BOOL RetVal = FALSE;

    if (DestBufferSizeInChars < 1) {
        return(FALSE);
    }

    lpszDest[0] = TEXT('\0');

    if (lpszDest) {
        lpsz = LoadDynamicString(uiID);        
        if (lpsz) {
            len = lstrlen(lpsz);
            if (bUseComma) {
                len += sizeof(TEXT(", ")); // includes null terminator.
                if (len <= DestBufferSizeInChars) {
                    lstrcat(lpszDest, TEXT(", "));
                }
            } else {
                len +=1; // null terminator
            }

            if (len <= DestBufferSizeInChars) {
                lstrcat(lpszDest, lpsz);
                RetVal = TRUE;
            }
            LocalFree(lpsz);            
        }
    }
    return(RetVal);
}
/*******************************************************************************
*
*  GetBatStatusDetails
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL GetBatStatusDetails(HWND hWnd, PBATTERY_STATE pbs)
{
    BATTERY_STATUS              bs;
    BATTERY_WAIT_STATUS         bws;
    DWORD                       dwByteCount;
    BATTERY_INFORMATION         bi;
    BATTERY_QUERY_INFORMATION   bqi;
    TCHAR                       szChem[5], szStatus[128];
    CHAR                        szaChem[5];
    LPTSTR                      lpsz;
    UINT                        uiIDS;
    BOOLEAN                     bUseComma;

    bqi.BatteryTag = pbs->ulTag;
    bqi.InformationLevel = BatteryInformation;
    bqi.AtRate = 0;

    if (DeviceIoControl(pbs->hDevice, IOCTL_BATTERY_QUERY_INFORMATION,
                        &bqi, sizeof(bqi),
                        &bi,  sizeof(bi),
                        &dwByteCount, NULL)) {

        // Set chemistry.
        memcpy(szaChem, bi.Chemistry, 4);
        szaChem[4] = 0;

        if (szaChem[0]) {
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0, szaChem, -1, szChem, 5);
            SetDlgItemText(hWnd, IDC_CHEM, szChem);
#else
            SetDlgItemText(hWnd, IDC_CHEM, szaChem);
#endif
        }
        else {
            ShowWindow(GetDlgItem(hWnd, IDC_CHEM), SW_HIDE);
            ShowWindow(GetDlgItem(hWnd, IDC_CHEMISTRY), SW_HIDE);
        }

        // Set up BATTERY_WAIT_STATUS for immediate return.
        memset(&bws, 0, sizeof(BATTERY_WAIT_STATUS));
        bws.BatteryTag = pbs->ulTag;

        if (DeviceIoControl(pbs->hDevice, IOCTL_BATTERY_QUERY_STATUS,
                            &bws, sizeof(BATTERY_WAIT_STATUS),
                            &bs,  sizeof(BATTERY_STATUS),
                            &dwByteCount, NULL)) {

            szStatus[0] = '\0';
            bUseComma = FALSE;
            if (bs.PowerState & BATTERY_POWER_ON_LINE) {
                AppendStrID(
                    szStatus, 
                    ARRAYSIZE(szStatus),
                    IDS_BATTERY_POWER_ON_LINE, 
                    bUseComma);
                bUseComma = TRUE;
            }
            if (bs.PowerState & BATTERY_DISCHARGING) {
                AppendStrID(
                    szStatus, 
                    ARRAYSIZE(szStatus),
                    IDS_BATTERY_DISCHARGING, 
                    bUseComma);
                bUseComma = TRUE;
            }
            if (bs.PowerState & BATTERY_CHARGING) {
                AppendStrID(
                    szStatus, 
                    ARRAYSIZE(szStatus),
                    IDS_BATTERY_CHARGING, 
                    bUseComma);
                bUseComma = TRUE;
            }
            if (bs.PowerState & BATTERY_CRITICAL) {
                AppendStrID(
                    szStatus, 
                    ARRAYSIZE(szStatus),
                    IDS_BATTERY_CRITICAL, 
                    bUseComma);
                bUseComma = TRUE;
            }
            SetDlgItemText(hWnd, IDC_STATE, szStatus);
            return TRUE;
        }
    }
    return FALSE;
}

/*******************************************************************************
*
*  GetBatQueryInfo
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL GetBatQueryInfo(
    PBATTERY_STATE              pbs,
    PBATTERY_QUERY_INFORMATION  pbqi,
    PVOID                       pData,
    ULONG                       ulSize
)
{
    DWORD dwByteCount;

    if (DeviceIoControl(pbs->hDevice, IOCTL_BATTERY_QUERY_INFORMATION,
                        pbqi, sizeof(BATTERY_QUERY_INFORMATION),
                        pData,  ulSize,
                        &dwByteCount, NULL)) {
        return TRUE;
    }
    return FALSE;
}

/*******************************************************************************
*
*  GetAndSetBatQueryInfoText
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL GetAndSetBatQueryInfoText(
    HWND                        hWnd,
    PBATTERY_STATE              pbs,
    PBATTERY_QUERY_INFORMATION  pbqi,
    UINT                        uiIDS,
    UINT                        uiLabelID
)
{
    WCHAR szBatStr[MAX_BATTERY_STRING_SIZE];

    memset(szBatStr, 0, sizeof(szBatStr));
    if (GetBatQueryInfo(pbs, pbqi, (PVOID)szBatStr, sizeof(szBatStr))) {
#ifdef UNICODE
        if (lstrcmp(szBatStr, TEXT(""))) {
            SetDlgItemText(hWnd, uiIDS, szBatStr);
            return TRUE;
        }
#else
        CHAR szaBatStr[MAX_BATTERY_STRING_SIZE];

        szaBatStr[0] = '\0';
        WideCharToMultiByte(CP_ACP, 0, szBatStr, -1,
                            szaBatStr, MAX_BATTERY_STRING_SIZE, NULL, NULL);
        if (szaBatStr[0]) {
            SetDlgItemText(hWnd, uiIDS, szaBatStr);
            return TRUE;
        }
#endif
    }
    ShowWindow(GetDlgItem(hWnd, uiIDS), SW_HIDE);
    ShowWindow(GetDlgItem(hWnd, uiLabelID), SW_HIDE);
    return FALSE;
}

/*******************************************************************************
*
*  GetBatOptionalDetails
*
*  DESCRIPTION:
*   Get optional battery data and set the dialog control.
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL GetBatOptionalDetails(HWND hWnd, PBATTERY_STATE pbs)
{
    BATTERY_QUERY_INFORMATION   bqi;
    ULONG                       ulData;
    LPTSTR                      lpsz = NULL;
    BATTERY_MANUFACTURE_DATE    bmd;
    TCHAR                       szDateBuf[128];
    SYSTEMTIME                  stDate;

    bqi.BatteryTag = pbs->ulTag;
    bqi.InformationLevel = BatteryManufactureDate;
    bqi.AtRate = 0;
    
    if (GetBatQueryInfo(pbs, &bqi, (PULONG)&bmd,
                        sizeof(BATTERY_MANUFACTURE_DATE))) {

        memset(&stDate, 0, sizeof(SYSTEMTIME));
        stDate.wYear  = (WORD) bmd.Year;
        stDate.wMonth = (WORD) bmd.Month;
        stDate.wDay   = (WORD) bmd.Day;

        GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE,
                      &stDate, NULL, szDateBuf, 128);
        SetDlgItemText(hWnd, IDC_BATMANDATE, szDateBuf);
    }
    else {
        ShowWindow(GetDlgItem(hWnd, IDC_BATMANDATE), SW_HIDE);
        ShowWindow(GetDlgItem(hWnd, IDC_DATEMANUFACTURED), SW_HIDE);
    }
    bqi.InformationLevel = BatteryDeviceName;
    GetAndSetBatQueryInfoText(hWnd, pbs, &bqi, IDC_DEVNAME, IDC_BATTERYNAME);

    bqi.InformationLevel = BatteryManufactureName;
    GetAndSetBatQueryInfoText(hWnd, pbs, &bqi, IDC_BATMANNAME, IDC_MANUFACTURE);

    bqi.InformationLevel = BatteryUniqueID;
    GetAndSetBatQueryInfoText(hWnd, pbs, &bqi, IDC_BATID, IDC_UNIQUEID);

    return TRUE;
}

/*******************************************************************************
*
*  InitBatDetailDlg
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL InitBatDetailDialogs(HWND hWnd, PBATTERY_STATE pbs)
{
    LPTSTR                      lpsz;
    DWORD                       dwByteCount;

    lpsz = LoadDynamicString(IDS_BATTERYNUMDETAILS, pbs->ulBatNum);
    if (lpsz) {
        SetWindowText(hWnd, lpsz);
        LocalFree(lpsz);
    }

    if (GetBatOptionalDetails(hWnd, pbs)) {
        return GetBatStatusDetails(hWnd, pbs);
    }
    return FALSE;
}

/*******************************************************************************
*
*  BatDetailDlgProc
*
*  DESCRIPTION:
*   DialogProc for the Detailed Battery Information dialog.
*
*  PARAMETERS:
*
*******************************************************************************/

LRESULT CALLBACK BatDetailDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UINT uiBatNum;
    static PBATTERY_STATE pbs;

    switch (uMsg) {
        case WM_INITDIALOG:
            pbs = (PBATTERY_STATE) lParam;
            return InitBatDetailDialogs(hWnd, pbs);

        case WM_COMMAND:
            switch (wParam) {
                case IDC_REFRESH:
                    GetBatStatusDetails(hWnd, pbs);
                    break;

                case IDCANCEL:
                case IDOK:
                    EndDialog(hWnd, wParam);
                    break;
            }
            break;

        case WM_HELP:             // F1
            WinHelp(((LPHELPINFO)lParam)->hItemHandle, PWRMANHLP, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)g_ContextMenuHelpIDs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND)wParam, PWRMANHLP, HELP_CONTEXTMENU, (ULONG_PTR)(LPTSTR)g_ContextMenuHelpIDs);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batmeter\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)
!include ..\batmeter.inc

SOURCES_USED    = ..\batmeter.inc
!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc


TARGETNAME      = batmeter
TARGETPATH      = obj
TARGETTYPE      = DYNLINK
DLLENTRY        = DllInitialize

TARGETLIBS      =                                               \
                  $(SDK_LIB_PATH)\advapi32.lib                  \
                  $(SHELL_LIB_PATH)\shfusion.lib                \
                  $(SDK_LIB_PATH)\kernel32.lib                  \
                  $(SDK_LIB_PATH)\ntdll.lib                     \
                  $(SDK_LIB_PATH)\powrprof.lib                  \
                  $(SDK_LIB_PATH)\setupapi.lib                  \
                  $(SDK_LIB_PATH)\user32.lib                    \
                  $(SHELL_LIB_PATH)\shlwapip.lib                \
                  $(CCSHELL_DIR)\lib\$(O)\stock.lib             

!if defined(TARGET_WIN95)
USE_LIBCMT      = 1
!else
PASS1_PUBLISH={$(O)\batmeter.lib=$(DDK_LIB_PATH)\batmeter.lib}
!endif

LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217 

DLLDEF          = $O\batmeter.def

SOURCES         = ..\batmeter.c      \
                  ..\batmeter.rc     \
                  ..\details.c       \
                  ..\batstate.c
 
 
# 
# Fusionized
# 
SXS_MANIFEST_RESOURCE_ID=124
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batmeter\test\bmtresid.h ===
#define IDD_BMTEST                      101

#define IDC_ENABLEMETER                 1000
#define IDC_POWERSTATUSGROUPBOX         1001
#define IDC_ENABLEMULTI                 1002
#define IDC_STATIC_FRAME                1003

#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batmeter\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BMTEST.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batt\ci.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ci.c

Abstract:

    Battery Class Installer

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

--*/



#include "proj.h"

#include <initguid.h>
#include <devguid.h>

#ifdef DEBUG
DWORD   BattDebugPrintLevel = TF_ERROR | TF_WARNING;
#endif      


BOOL APIENTRY LibMain(
    HANDLE hDll, 
    DWORD dwReason,  
    LPVOID lpReserved)
{
    
    switch( dwReason ) {
    case DLL_PROCESS_ATTACH:
        
        TRACE_MSG (TF_FUNC, ("Battery Class Installer Loaded\n"));
        DisableThreadLibraryCalls(hDll);

        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }


    
    return TRUE;
} 



DWORD
APIENTRY
BatteryClassInstall(
    IN DI_FUNCTION      DiFunction,
    IN HDEVINFO         DevInfoHandle,
    IN PSP_DEVINFO_DATA DevInfoData     OPTIONAL
    )       
/*++

Routine Description:

    This function is the class installer entry-point.

Arguments:

    DiFunction      - Requested installation function

    DevInfoHandle   - Handle to a device information set

    DevInfoData     - Pointer to device information about device to install

Return Value:

    

--*/
{
    DWORD                   status;
    SP_DEVINSTALL_PARAMS    devParams;

    
    //
    // Get the DeviceInstallParams, because some of the InstallFunction
    // handlers may find some of its fields useful.  Keep in mind not
    // to set the DeviceInstallParams using this same structure at the
    // end.  The handlers may have called functions which would change the
    // DeviceInstallParams, and simply calling SetupDiSetDeviceInstallParams
    // with this blanket structure would destroy those settings.
    //

    devParams.cbSize = sizeof(devParams);
    if (!SetupDiGetDeviceInstallParams(DevInfoHandle, DevInfoData, &devParams))
    {
        status = GetLastError();

    } else {
        TRACE_MSG (TF_GENERAL, ("DiFunction = %x\n", DiFunction));

        //
        // Dispatch the InstallFunction
        //

        switch (DiFunction) {
            case DIF_INSTALLDEVICE:
                status = InstallCompositeBattery (DevInfoHandle, DevInfoData, &devParams);
                if (status == ERROR_SUCCESS) {
                    // 
                    // Let the default device installer actually install the battery. 
                    //
                    
                    status = ERROR_DI_DO_DEFAULT;
                }
                break;


            default:
                status = ERROR_DI_DO_DEFAULT;
                break;
        }
    }


    return status;
}





DWORD
PRIVATE
InstallCompositeBattery (
    IN     HDEVINFO                DevInfoHandle,
    IN     PSP_DEVINFO_DATA        DevInfoData,         OPTIONAL
    IN OUT PSP_DEVINSTALL_PARAMS   DevInstallParams
    )
/*++

Routine Description:

    This function installs the composite battery if it hasn't already been
    installed.

Arguments:

    DevInfoHandle       - Handle to a device information set

    DevInfoData         - Pointer to device information about device to install

    DevInstallParams    - Device install parameters associated with device 

Return Value:

    

--*/
{
    DWORD                   status;
    PSP_DEVINFO_DATA        newDevInfoData;
    HDEVINFO                newDevInfoHandle;
    SP_DRVINFO_DATA         driverInfoData;
    
    
    //
    // Allocate local memory for a new device info structure
    //

    if(!(newDevInfoData = LocalAlloc(LPTR, sizeof(SP_DEVINFO_DATA)))) {
        status = GetLastError();
        TRACE_MSG (TF_ERROR, ("Couldn't allocate composite battery device info- %x\n", status));
        goto clean0;
    }

    
    //
    // Create a new device info list.  Since we are "manufacturing" a completely new 
    // device with the Composite Battery, we can't use any of the information from 
    // the battery device list.
    //

    newDevInfoHandle = SetupDiCreateDeviceInfoList ((LPGUID)&GUID_DEVCLASS_SYSTEM, DevInstallParams->hwndParent);
    if (newDevInfoHandle == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        TRACE_MSG (TF_ERROR, ("Can't create DevInfoList - %x\n", status));
        goto clean1;
    }
    
    
    //
    // Attempt to manufacture a new device information element for the root enumerated
    // composite battery.
    //
    
    newDevInfoData->cbSize = sizeof(SP_DEVINFO_DATA);
    if(!SetupDiCreateDeviceInfo(newDevInfoHandle,
                              TEXT("Root\\COMPOSITE_BATTERY\\0000"),
                              (LPGUID)&GUID_DEVCLASS_SYSTEM,
                              NULL,
                              DevInstallParams->hwndParent,  // same parent window as enumerated device
                              0,
                              newDevInfoData)) {

        status = GetLastError();

        if (status == ERROR_DEVINST_ALREADY_EXISTS) {
            //
            // The composite battery is already installed.  Our work is done.
            //

            TRACE_MSG (TF_GENERAL, ("Composite Battery Already Installed\n"));
            status = ERROR_SUCCESS;
            goto clean2;
        
        } else {

            TRACE_MSG (TF_ERROR, ("Error creating composite battery devinfo - %x\n", status));
            goto clean2;
        }
    }


    //
    // Register the device so it is not a phantom anymore
    //

    if (!SetupDiRegisterDeviceInfo(newDevInfoHandle, newDevInfoData, 0, NULL, NULL, NULL)) {
        status = GetLastError();
        TRACE_MSG (TF_ERROR, ("Couldn't register device - %x\n", status));
        goto clean3;
    }


    //
    // Set the hardware ID.  For the composite battery it will be COMPOSITE_BATTERY
    //    
    status = SetupDiSetDeviceRegistryProperty (
	                    newDevInfoHandle,
                        newDevInfoData,
                        SPDRP_HARDWAREID,
	                    TEXT("COMPOSITE_BATTERY\0"),
	                    sizeof(TEXT("COMPOSITE_BATTERY\0"))
	                    );

    if (!status) {
        status = GetLastError();
        TRACE_MSG(TF_ERROR, ("Couldn't set the HardwareID - %x\n", status));
        goto clean3;
    }


    //
    // Build a compatible driver list for this new device...
    //
    
    if(!SetupDiBuildDriverInfoList(newDevInfoHandle, newDevInfoData, SPDIT_COMPATDRIVER)) {
        status = GetLastError();
        TRACE_MSG(TF_ERROR, ("Couldn't build class driver list - %x\n", status));
        goto clean3;
    }


    //
    // Select the first driver in the list as this will be the most compatible
    //

    driverInfoData.cbSize = sizeof (SP_DRVINFO_DATA);
    if (!SetupDiEnumDriverInfo(newDevInfoHandle, newDevInfoData, SPDIT_COMPATDRIVER, 0, &driverInfoData)) {
        status = GetLastError();
        TRACE_MSG(TF_ERROR, ("Couldn't get driver list - %x\n", status));
        goto clean3;

    } else {
        TRACE_MSG(TF_GENERAL,("Driver info - \n"
                              "------------- DriverType     %x\n"
                              "------------- Description    %s\n"
                              "------------- MfgName        %s\n"
                              "------------- ProviderName   %s\n\n",
                              driverInfoData.DriverType,
                              driverInfoData.Description,
                              driverInfoData.MfgName,
                              driverInfoData.ProviderName));
	    if (!SetupDiSetSelectedDriver(newDevInfoHandle, newDevInfoData, &driverInfoData)) {
            status = GetLastError();
            TRACE_MSG (TF_ERROR, ("Couldn't select driver - %x\n", status));
            goto clean4;
        } 
    }

    
    //
    // Install the device
    //

    if (!SetupDiInstallDevice (newDevInfoHandle, newDevInfoData)) {
        status = GetLastError();
        TRACE_MSG (TF_ERROR, ("Couldn't install device - %x\n", status));
        goto clean4;
    }

    
    //
    // If we got here we were successful
    //

    status = ERROR_SUCCESS;
    SetLastError (status);
    goto clean1;


clean4:
    SetupDiDestroyDriverInfoList (newDevInfoHandle, newDevInfoData, SPDIT_COMPATDRIVER);

clean3:
    SetupDiDeleteDeviceInfo (newDevInfoHandle, newDevInfoData);

clean2:
    SetupDiDestroyDeviceInfoList (newDevInfoHandle);

clean1:
    LocalFree (newDevInfoData);

clean0:
    return status;
}

DWORD
APIENTRY
BatteryClassCoInstaller (
    IN DI_FUNCTION  InstallFunction,
    IN HDEVINFO  DeviceInfoSet,
    IN PSP_DEVINFO_DATA  DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA  Context
    )
{
    SYSTEM_BATTERY_STATE batteryState;
    GLOBAL_POWER_POLICY powerPolicy;
    NTSTATUS Status;
    int i;
    UINT policyId;
    DWORD RetVal;

    if ((InstallFunction != DIF_INSTALLDEVICE) && (InstallFunction != DIF_REMOVE)) {
        //
        // Only handle DIF_INSTALLDEVICE or DIF_REMOVE request
        //

        return (NO_ERROR);
    }

    if (!Context->PostProcessing) {
        //
        // Wait until device is installed before Adjusting levels
        //

        return (ERROR_DI_POSTPROCESSING_REQUIRED); 
    }

    RetVal = NO_ERROR;
    Status = NtPowerInformation (SystemBatteryState, NULL, 0, &batteryState, sizeof(batteryState));
    if (NT_SUCCESS(Status)) {
        if ((batteryState.BatteryPresent) && (batteryState.MaxCapacity != 0)) {
            //
            // Don't try to adjust levels if for some reason no battery was installed.
            //    
            if (ReadGlobalPwrPolicy (&powerPolicy)) {
                if (powerPolicy.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel < 
                    (100 * batteryState.DefaultAlert1)/batteryState.MaxCapacity) {
                    //
                    // If Critical level is less than DefaultAlert1, this idicates the settings 
                    // are messed up.  Reset both the Critical and the Low setting.
                    //
        
                    powerPolicy.user.DischargePolicy[DISCHARGE_POLICY_CRITICAL].BatteryLevel =
                        (100 * batteryState.DefaultAlert1)/batteryState.MaxCapacity;
                    powerPolicy.user.DischargePolicy[DISCHARGE_POLICY_LOW].BatteryLevel =
                        (100 * batteryState.DefaultAlert2)/batteryState.MaxCapacity;
        
                    //
                    // commit the fixed settings.
                    //
                    if (!WriteGlobalPwrPolicy (&powerPolicy)) {
                        RetVal = GetLastError();
                    }

                    //
                    // now make sure we commit these settings to the current policy as well.
                    //
                    if (GetActivePwrScheme (&policyId)) {
                        if (!SetActivePwrScheme (policyId, &powerPolicy, NULL)) {
                            RetVal = GetLastError();
                        }
                    } else {
                        RetVal = GetLastError();
                    }
                }
            }             
        } 
    } else {
        RetVal = ERROR_INTERNAL_ERROR;
    }

    return(RetVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\batt\proj.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    proj.h

Abstract:

    Battery Class Installer header

Author:

    Scott Brenden

Environment:

Notes:


Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>

#include <ntpoapi.h>


#include <setupapi.h>       // PnP setup/installer services
#include <cfgmgr32.h>


#include "powrprof.h"

//
// Debug stuff
//

#if DBG > 0 && !defined(DEBUG)
#define DEBUG
#endif

#if DBG > 0 && !defined(FULL_DEBUG)
#define FULL_DEBUG
#endif


//
// Trace flags
//

#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls




//
// Calling declarations
//
#define PUBLIC                      FAR PASCAL
#define CPUBLIC                     FAR CDECL
#define PRIVATE                     NEAR PASCAL


#ifdef DEBUG

extern DWORD    BattDebugPrintLevel;
#define TRACE_MSG(_FLAG,_RESTOFVARARG) if (BattDebugPrintLevel & _FLAG) DbgPrint _RESTOFVARARG

#else   // !defined(DEBUG)

#define TRACE_MSG

#endif



//
// Prototypes
//

DWORD
PRIVATE
InstallCompositeBattery (
    IN     HDEVINFO                DevInfoHandle,
    IN     PSP_DEVINFO_DATA        DevInfoData,         OPTIONAL
    IN OUT PSP_DEVINSTALL_PARAMS   DevInstallParams
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\intl\advdlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    advdlg.c

Abstract:

    This module implements the advanced property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <windowsx.h>
#include <setupapi.h>
#include <syssetup.h>
#include "intlhlp.h"
#include "maxvals.h"

#define STRSAFE_LIB
#include <strsafe.h>


//
//  Context Help Ids.
//

static int aAdvancedHelpIds[] =
{
    IDC_GROUPBOX1,             IDH_COMM_GROUPBOX,
    IDC_GROUPBOX2,             IDH_COMM_GROUPBOX,
    IDC_GROUPBOX3,             IDH_COMM_GROUPBOX,
    IDC_CODEPAGES,             IDH_INTL_ADV_CODEPAGES,
    IDC_SYSTEM_LOCALE,         IDH_INTL_ADV_SYSTEM_LOCALE,
    IDC_SYSTEM_LOCALE_TEXT1,   IDH_INTL_ADV_SYSTEM_LOCALE,
    IDC_SYSTEM_LOCALE_TEXT2,   IDH_INTL_ADV_SYSTEM_LOCALE,
    IDC_DEFAULT_USER,          IDH_INTL_ADV_CHANGE,

    0, 0
};





////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ListViewCustomDraw
//
//  Processing for a list view NM_CUSTOMDRAW notification message.
//
////////////////////////////////////////////////////////////////////////////

void Advanced_ListViewCustomDraw(
    HWND hDlg,
    LPNMLVCUSTOMDRAW pDraw)
{
    LPCODEPAGE pNode;

    //
    //  Tell the list view to notify me of item draws.
    //
    if (pDraw->nmcd.dwDrawStage == CDDS_PREPAINT)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW);
        return;
    }

    //
    //  Handle the Item Prepaint.
    //
    pNode = (LPCODEPAGE)(pDraw->nmcd.lItemlParam);
    if ((pDraw->nmcd.dwDrawStage & CDDS_ITEMPREPAINT) &&
        (pNode) && (pNode != (LPCODEPAGE)(LB_ERR)))
    {
        if (pNode->wStatus & (ML_PERMANENT | ML_DISABLE))
        {
            pDraw->clrText = (pDraw->nmcd.uItemState & CDIS_SELECTED)
                               ? ((GetSysColor(COLOR_HIGHLIGHT) ==
                                   GetSysColor(COLOR_GRAYTEXT))
                                      ? GetSysColor(COLOR_HIGHLIGHTTEXT)
                                      : GetSysColor(COLOR_GRAYTEXT))
                               : GetSysColor(COLOR_GRAYTEXT);
        }
    }

    //
    //  Do the default action.
    //
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ListViewChanging
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_ListViewChanging(
    HWND hDlg,
    NM_LISTVIEW *pLV)
{
    LPCODEPAGE pNode;

    //
    //  Make sure it's a state change message.
    //
    if ((((*pLV).hdr).idFrom != IDC_CODEPAGES) ||
        (!(pLV->uChanged & LVIF_STATE)) ||
        ((pLV->uNewState & 0x3000) == 0))
    {
        return (FALSE);
    }

    //
    //  Get the item data for the currently selected item.
    //
    pNode = (LPCODEPAGE)(pLV->lParam);

    //
    //  Make sure we're not trying to change a permanent or disabled
    //  code page.  If so, return TRUE to prevent the change.
    //
    if ((pNode) && (pNode->wStatus & (ML_PERMANENT | ML_DISABLE)))
    {
        return (TRUE);
    }

    //
    //  Return FALSE to allow the change.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ListViewChanged
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_ListViewChanged(
    HWND hDlg,
    int iID,
    NM_LISTVIEW *pLV)
{
    HWND hwndLV = GetDlgItem(hDlg, iID);
    LPCODEPAGE pNode;
    BOOL bChecked;
    int iCount;

    //
    //  Make sure it's a state change message.
    //
    if ((((*pLV).hdr).idFrom != IDC_CODEPAGES) ||
        (!(pLV->uChanged & LVIF_STATE)) ||
        ((pLV->uNewState & 0x3000) == 0))
    {
        return (FALSE);
    }

    //
    //  Get the state of the check box for the currently selected item.
    //
    bChecked = ListView_GetCheckState(hwndLV, pLV->iItem) ? TRUE : FALSE;

    //
    //  Get the item data for the currently selected item.
    //
    pNode = (LPCODEPAGE)(pLV->lParam);

    //
    //  Make sure we're not trying to change a permanent or disabled
    //  code page.  If so, set the check box to its appropriate state.
    //
    if (pNode->wStatus & (ML_PERMANENT | ML_DISABLE))
    {
        if (pNode->wStatus & ML_PERMANENT)
        {
            if (bChecked == FALSE)
            {
                ListView_SetCheckState(hwndLV, pLV->iItem, TRUE);
            }
        }
        else            // ML_DISABLE only
        {
            if ((bChecked == FALSE) && (pNode->wStatus & ML_ORIG_INSTALLED))
            {
                ListView_SetCheckState(hwndLV, pLV->iItem, TRUE);
            }
            else if ((bChecked == TRUE) && (!(pNode->wStatus & ML_ORIG_INSTALLED)))
            {
                ListView_SetCheckState(hwndLV, pLV->iItem, FALSE);
            }
        }
        return (FALSE);
    }

    //
    //  Store the proper info in the code page structure.
    //
    pNode->wStatus &= (ML_ORIG_INSTALLED | ML_STATIC);
    pNode->wStatus |= ((bChecked) ? ML_INSTALL : ML_REMOVE);

    //
    //  Deselect all items.
    //
    iCount = ListView_GetItemCount(hwndLV);
    while (iCount > 0)
    {
        ListView_SetItemState( hwndLV,
                               iCount - 1,
                               0,
                               LVIS_FOCUSED | LVIS_SELECTED );
        iCount--;
    }

    //
    //  Make sure this item is selected.
    //
    ListView_SetItemState( hwndLV,
                           pLV->iItem,
                           LVIS_FOCUSED | LVIS_SELECTED,
                           LVIS_FOCUSED | LVIS_SELECTED );

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ListViewClick
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_ListViewClick(
    HWND hDlg,
    LPNMHDR lpNmHdr)
{
    LV_HITTESTINFO ht;
    HWND hwndList = GetDlgItem(hDlg, IDC_CODEPAGES);

    //
    //  Remove unnecessary processing.
    //
    if (lpNmHdr->idFrom != IDC_CODEPAGES)
    {
        return (FALSE);
    }

    //
    //  Get where we were hit and then translate it to our
    //  window.
    //
    GetCursorPos(&ht.pt);
    ScreenToClient(hwndList, &ht.pt);
    ListView_HitTest(hwndList, &ht);
    if ((ht.iItem >= 0) && ((ht.flags & LVHT_ONITEM) == LVHT_ONITEMLABEL))
    {
        UINT state;

        //
        //  The user clicked on the item label.  Simulate a
        //  state change so we can process it.
        //
        state = ListView_GetItemState( hwndList,
                                       ht.iItem,
                                       LVIS_STATEIMAGEMASK );
        state ^= INDEXTOSTATEIMAGEMASK(LVIS_SELECTED | LVIS_FOCUSED);

        //
        //  The state is either selected or focused.  Flip the
        //  bits.  The SetItemState causes the system to bounce
        //  back a notification for LVN_ITEMCHANGED and the
        //  code then does the right thing.  Note -- we MUST
        //  check for LVHT_ONITEMLABEL.  If we do this code for
        //  LVHT_ONITEMSTATEICON, the code will get 2
        //  ITEMCHANGED notifications, and the state will stay
        //  where it is, which is not good.  If we want this
        //  to also fire if the guy clicks in the empty space
        //  right of the label text, we need to look for
        //  LVHT_ONITEM as well as LVHT_ONITEMLABEL.
        //
        ListView_SetItemState( hwndList,
                               ht.iItem,
                               state,
                               LVIS_STATEIMAGEMASK );
   }

   return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_GetSupportedCodePages
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_GetSupportedCodePages()
{
    UINT CodePage;
    HANDLE hCodePage;
    LPCODEPAGE pCP;
    INFCONTEXT Context;
    TCHAR szSection[MAX_PATH];
    int LineCount, LineNum;
    CPINFOEX Info;

    //
    //  Get the number of supported code pages from the inf file.
    //
    LineCount = (UINT)SetupGetLineCount(g_hIntlInf, TEXT("CodePages"));
    if (LineCount <= 0)
    {
        return (FALSE);
    }

    //
    //  Go through all supported code pages in the inf file.
    //
    for (LineNum = 0; LineNum < LineCount; LineNum++)
    {
        if (SetupGetLineByIndex(g_hIntlInf, TEXT("CodePages"), LineNum, &Context) &&
            SetupGetIntField(&Context, 0, &CodePage))
        {
            //
            //  Create the new node.
            //
            if (!(hCodePage = GlobalAlloc(GHND, sizeof(CODEPAGE))))
            {
                return (FALSE);
            }
            pCP = GlobalLock(hCodePage);

            //
            //  Fill in the new node with the appropriate info.
            //
            pCP->wStatus = 0;
            pCP->CodePage = CodePage;
            pCP->hCodePage = hCodePage;
            (pCP->pszName)[0] = 0;

            //
            //  Get the appropriate display string.
            //
            if (GetCPInfoEx(CodePage, 0, &Info))
            {
                //lstrcpy(pCP->pszName, Info.CodePageName);
                if(FAILED(StringCchCopy(pCP->pszName, MAX_PATH, Info.CodePageName)))
                {
                    return(FALSE);
                }
            }
            else if (!SetupGetStringField(&Context, 1, pCP->pszName, MAX_PATH, NULL))
            {
                GlobalUnlock(hCodePage);
                GlobalFree(hCodePage);
                continue;
            }

            //
            //  See if this code page can be removed.
            //
            //wsprintf(szSection, TEXT("%ws%d"), szCPRemovePrefix, CodePage);
            if(FAILED(StringCchPrintf(szSection, MAX_PATH, TEXT("%ws%d"), szCPRemovePrefix, CodePage)))
            {
                return(FALSE);
            }

            if ((CodePage == GetACP()) ||
                (CodePage == GetOEMCP()) ||
                (!SetupFindFirstLine( g_hIntlInf,
                                      szSection,
                                      TEXT("AddReg"),
                                      &Context )))
            {
                //
                //  Mark it as permanent.
                //  Also mark it as originally installed to avoid problems.
                //
                pCP->wStatus |= (ML_ORIG_INSTALLED | ML_PERMANENT);
            }

            //
            //  Add the code page to the front of the linked list.
            //
            pCP->pNext = pCodePages;
            pCodePages = pCP;
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_InitSystemLocales
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_InitSystemLocales(
    HWND hDlg)
{
    TCHAR szSystemBuf[SIZE_128];
    TCHAR szDefaultSystemBuf[SIZE_128];
    TCHAR szBuf[SIZE_128];
    DWORD dwIndex;
    HWND hSystemLocale = GetDlgItem(hDlg, IDC_SYSTEM_LOCALE);

    //
    //  Get the list of locales and fill in the system locale
    //  combo box.
    //
    Intl_EnumLocales(hDlg, hSystemLocale, TRUE);

    //
    //  Get the string for the system default setting.
    //  Special case Spanish.
    //
    if ((SysLocaleID == LCID_SPANISH_TRADITIONAL) ||
        (SysLocaleID == LCID_SPANISH_INTL))
    {
        LoadString(hInstance, IDS_SPANISH_NAME, szSystemBuf, SIZE_128);
    }
    else
    {
        GetLocaleInfo(SysLocaleID, LOCALE_SLANGUAGE, szSystemBuf, SIZE_128);
    }

    //
    //  Select the current system default locale id in the list.
    //
    dwIndex = ComboBox_FindStringExact(hSystemLocale, -1, szSystemBuf);
    if (dwIndex == CB_ERR)
    {
        dwIndex = ComboBox_FindStringExact(hSystemLocale, -1, szDefaultSystemBuf);
        if (dwIndex == CB_ERR)
        {
            GetLocaleInfo(US_LOCALE, LOCALE_SLANGUAGE, szBuf, SIZE_128);
            dwIndex = ComboBox_FindStringExact(hSystemLocale, -1, szBuf);
            if (dwIndex == CB_ERR)
            {
                dwIndex = 0;
            }
        }
    }
    ComboBox_SetCurSel(hSystemLocale, dwIndex);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_SetSystemLocale
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_SetSystemLocale(
    HWND hDlg)
{
    HWND hSystemLocale = GetDlgItem(hDlg, IDC_SYSTEM_LOCALE);
    DWORD dwLocale;
    LCID NewLocale;
    HCURSOR hcurSave;

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  Get the current selection.
    //
    dwLocale = ComboBox_GetCurSel(hSystemLocale);

    //
    //  Get the locale id for the current selection and save it.
    //
    NewLocale = (LCID)ComboBox_GetItemData(hSystemLocale, dwLocale);
    if (IsValidLocale(NewLocale, LCID_SUPPORTED))
    {
        SysLocaleID = NewLocale;
    }
    else
    {
        //
        //  This shouldn't happen, since the values in the combo box
        //  should already be installed via the language groups.
        //  Put up an error message just in case.
        //
        SetCursor(hcurSave);
        ShowMsg( NULL,
                 IDS_SETUP_STRING,
                 IDS_TITLE_STRING,
                 MB_OK_OOPS,
                 NULL );
        return (FALSE);
    }

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_InitCodePages
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_InitCodePages(
    HWND hDlg,
    BOOL bInitTime)
{
    HWND hwndCP = GetDlgItem(hDlg, IDC_CODEPAGES);
    LPCODEPAGE pCP;
    DWORD dwExStyle;
    RECT Rect;
    LV_COLUMN Column;
    LV_ITEM Item;
    int iIndex;
    int RegionalChgStateTemp = RegionalChgState;

    //
    //  Open the Inf file.
    //
    g_hIntlInf = SetupOpenInfFile(szIntlInf, NULL, INF_STYLE_WIN4, NULL);
    if (g_hIntlInf == INVALID_HANDLE_VALUE)
    {
        return (FALSE);
    }

    if (!SetupOpenAppendInfFile(NULL, g_hIntlInf, NULL))
    {
        SetupCloseInfFile(g_hIntlInf);
        g_hIntlInf = NULL;
        return (FALSE);
    }

    //
    //  Get all supported code pages from the inf file.
    //
    if (Advanced_GetSupportedCodePages() == FALSE)
    {
        return (FALSE);
    }

    //
    //  Close the inf file.
    //
    SetupCloseInfFile(g_hIntlInf);
    g_hIntlInf = NULL;

    //
    //  Enumerate all installed code pages.
    //
    if (EnumSystemCodePages(Intl_EnumInstalledCPProc, CP_INSTALLED) == FALSE)
    {
        return (FALSE);
    }

    //
    //  We only want to do this the first time we setup the list view.
    //  Otherwise, we get multiple columns created.
    //
    if (bInitTime)
    {
        //
        //  Create a column for the list view.
        //
        GetClientRect(hwndCP, &Rect);
        Column.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        Column.fmt = LVCFMT_LEFT;
        Column.cx = Rect.right - GetSystemMetrics(SM_CYHSCROLL);
        Column.pszText = NULL;
        Column.cchTextMax = 0;
        Column.iSubItem = 0;
        ListView_InsertColumn(hwndCP, 0, &Column);

        //
        //  Set extended list view style to use the check boxes.
        //
        dwExStyle = ListView_GetExtendedListViewStyle(hwndCP);
        ListView_SetExtendedListViewStyle( hwndCP,
                                           dwExStyle |
                                             LVS_EX_CHECKBOXES |
                                             LVS_EX_FULLROWSELECT );
    }

    //
    //  Go through the list of code pages and add each one to the
    //  list view and set the appropriate state.
    //
    pCP = pCodePages;
    while (pCP)
    {
        //
        //  Insert the item into the list view.
        //
        Item.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
        Item.iItem = 0;
        Item.iSubItem = 0;
        Item.state = 0;
        Item.stateMask = LVIS_STATEIMAGEMASK;
        Item.pszText = pCP->pszName;
        Item.cchTextMax = 0;
        Item.iImage = 0;
        Item.lParam = (LPARAM)pCP;

        iIndex = ListView_InsertItem(hwndCP, &Item);

        //
        //  Set the checked state.
        //
        //  There's a bug in the list view code such that the check mark
        //  isn't displayed when you set the state through InsertItem, so
        //  we have to set it explicitly using SetItemState.
        //
        if (iIndex >= 0)
        {
            ListView_SetItemState( hwndCP,
                                   iIndex,
                                   (pCP->wStatus & ML_ORIG_INSTALLED)
                                     ? INDEXTOSTATEIMAGEMASK(LVIS_SELECTED)
                                     : INDEXTOSTATEIMAGEMASK(LVIS_FOCUSED),
                                   LVIS_STATEIMAGEMASK );
        }

        //
        //  Advance to the next code page.
        //
        pCP = pCP->pNext;
    }

    //
    //  Deselect all items.
    //
    iIndex = ListView_GetItemCount(hwndCP);
    while (iIndex > 0)
    {
        ListView_SetItemState( hwndCP,
                               iIndex - 1,
                               0,
                               LVIS_FOCUSED | LVIS_SELECTED );
        iIndex--;
    }

    //
    //  Select the first one in the list.
    //
    ListView_SetItemState( hwndCP,
                           0,
                           LVIS_FOCUSED | LVIS_SELECTED,
                           LVIS_FOCUSED | LVIS_SELECTED );

    //
    // Restore the change state value for the whole dialog. Thia is required since
    // some of the ListView_SetItemState calls above are actually treated as changes 
    // to the list made by users.
    //
    RegionalChgState = RegionalChgStateTemp;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_FreeGlobalInfo
//
//  Processing for a WM_DESTROY message.
//
////////////////////////////////////////////////////////////////////////////

void Advanced_FreeGlobalInfo()
{
    LPCODEPAGE pPreCP, pCurCP;
    HANDLE hAlloc;

    //
    //  Remove Code Page info.
    //
    pCurCP = pCodePages;
    pCodePages = NULL;

    while (pCurCP)
    {
        pPreCP = pCurCP;
        pCurCP = pPreCP->pNext;
        hAlloc = pPreCP->hCodePage;
        GlobalUnlock(hAlloc);
        GlobalFree(hAlloc);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ClearValues
//
//  Reset each of the list boxes in the advanced property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Advanced_ClearValues(
    HWND hDlg)
{
    //
    //  Clear the system locale
    //
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SYSTEM_LOCALE));

    //
    //  Clear the Code Page list
    //
    ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_CODEPAGES));
    Advanced_FreeGlobalInfo();
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_SetValues
//
//  Initialize all of the controls in the advanced property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Advanced_SetValues(
    HWND hDlg,
    BOOL bInitTime)
{
    //
    //  Init system locale list.
    //
    Advanced_InitSystemLocales(hDlg);

    //
    //  Init code page list view.
    //
    Advanced_InitCodePages(hDlg, bInitTime);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ApplySettings
//
//  For every control that has changed (that affects the Locale settings),
//  call Set_Locale_Values to update the user locale information.  Notify
//  the parent of changes and reset the change flag stored in the property
//  sheet page structure appropriately.  Redisplay the time sample if
//  bRedisplay is TRUE.
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_ApplySettings(
    HWND hDlg)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;
    HWND hSystemLocale = GetDlgItem(hDlg, IDC_SYSTEM_LOCALE);
    DWORD dwLocale;
    LCID NewLocale;
    HCURSOR hcurSave;
    BOOL InvokeSysocmgr = FALSE;
    BOOL bReboot = FALSE;

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  See if there are any changes to the codepage conversions.
    //
    if (Changes & AD_CodePages)
    {
        LPCODEPAGE pCP;
        HINF hIntlInf;
        HSPFILEQ FileQueue;
        PVOID QueueContext;
        BOOL bInitInf = FALSE;
        BOOL fAdd;
        BOOL bRet = TRUE;
        TCHAR szSection[MAX_PATH];

        //
        //  Go through each code page node to see if anything needs to
        //  be done.
        //
        pCP = pCodePages;
        while (pCP)
        {
            //
            //  See if any changes are necessary for this code page.
            //
            if ((pCP->wStatus == ML_INSTALL) ||
                (pCP->wStatus == (ML_ORIG_INSTALLED | ML_REMOVE)))
            {
                //
                //  See if we're installing or removing.
                //
                fAdd = (pCP->wStatus == ML_INSTALL);

                //
                //  Initialize Inf stuff.
                //
                if ((!bInitInf) &&
                    (!Intl_InitInf(hDlg, &hIntlInf, szIntlInf, &FileQueue, &QueueContext)))
                {
                    SetCursor(hcurSave);
                    return (FALSE);
                }
                bInitInf = TRUE;

                //
                //  Get the inf section name.
                //
                //wsprintf( szSection,
                //          TEXT("%ws%d"),
                //          fAdd ? szCPInstallPrefix : szCPRemovePrefix,
                //          pCP->CodePage );
                if(FAILED(StringCchPrintf( szSection, 
                                 MAX_PATH, 
                                 TEXT("%ws%d"), 
                                 fAdd ? szCPInstallPrefix : szCPRemovePrefix, 
                                 pCP->CodePage )))
                {
                    //
                    //  Our wsprintf call failed.
                    //
                    ShowMsg( hDlg,
                             IDS_ML_COPY_FAILED,
                             0,
                             MB_OK_OOPS,
                             pCP->pszName );
                    pCP->wStatus = 0;
                }

                //
                //  Enqueue the code page files so that they may be
                //  copied.  This only handles the CopyFiles entries in the
                //  inf file.
                //
                if (!SetupInstallFilesFromInfSection( hIntlInf,
                                                      NULL,
                                                      FileQueue,
                                                      szSection,
                                                      pSetupSourcePath,
                                                      SP_COPY_NEWER ))
                {
                    //
                    //  Setup failed to find the code page.
                    //  This shouldn't happen - the inf file is messed up.
                    //
                    ShowMsg( hDlg,
                             IDS_ML_COPY_FAILED,
                             0,
                             MB_OK_OOPS,
                             pCP->pszName );
                    pCP->wStatus = 0;
                }
            }

            //
            //  Go to the next code page node.
            //
            pCP = pCP->pNext;
        }

        if (bInitInf)
        {
            DWORD d;

            //
            //  See if we need to install any files.
            //
            //  d = 0: User wants new files or some files were missing;
            //         Must commit queue.
            //
            //  d = 1: User wants to use existing files and queue is empty;
            //         Can skip committing queue.
            //
            //  d = 2: User wants to use existing files, but del/ren queues
            //         not empty.  Must commit queue.  The copy queue will
            //         have been emptied, so only del/ren functions will be
            //         performed.
            //
            if ((SetupScanFileQueue( FileQueue,
                                     SPQ_SCAN_PRUNE_COPY_QUEUE |
                                       SPQ_SCAN_FILE_VALIDITY,
                                     GetParent(hDlg),
                                     NULL,
                                     NULL,
                                     &d )) && (d != 1))
            {
                //
                //  Copy the files in the queue.
                //
                if (!SetupCommitFileQueue( GetParent(hDlg),
                                           FileQueue,
                                           Intl_MyQueueCallback,
                                           QueueContext ))
                {
                    //
                    //  This can happen if the user hits Cancel from within
                    //  the setup dialog.
                    //
                    ShowMsg( hDlg,
                             IDS_ML_SETUP_FAILED,
                             0,
                             MB_OK_OOPS,
                             NULL );
                    bRet = FALSE;
                    goto Advanced_CodepageConverionsSetupError;
                }
            }

            //
            //  Execute all of the other code page entries in the inf file.
            //
            pCP = pCodePages;
            while (pCP)
            {
                //
                //  See if any changes are necessary for this code page.
                //
                if ((pCP->wStatus == ML_INSTALL) ||
                    (pCP->wStatus == (ML_ORIG_INSTALLED | ML_REMOVE)))
                {
                    fAdd = (pCP->wStatus == ML_INSTALL);

                    //
                    //  Get the inf section name.
                    //
                    //wsprintf( szSection,
                    //          TEXT("%ws%d"),
                    //          fAdd ? szCPInstallPrefix : szCPRemovePrefix,
                    //          pCP->CodePage );
                    if(FAILED(StringCchPrintf( szSection, 
                                                MAX_PATH, 
                                                TEXT("%ws%d"), 
                                                fAdd ? szCPInstallPrefix : szCPRemovePrefix, 
                                                pCP->CodePage )))
                    {
                        //
                        //  This should be impossible but PREfast complains if we 
                        //  don't do something.
                        //
                        ShowMsg( hDlg,
                                 IDS_ML_INSTALL_FAILED,
                                 0,
                                 MB_OK_OOPS,
                                 pCP->pszName );
                        bRet = FALSE;
                        goto Advanced_CodepageConverionsSetupError;
                    }

                    //
                    //  Call setup to install other inf info for this
                    //  code page.
                    //
                    if (!SetupInstallFromInfSection( GetParent(hDlg),
                                                     hIntlInf,
                                                     szSection,
                                                     SPINST_ALL & ~SPINST_FILES,
                                                     NULL,
                                                     pSetupSourcePath,
                                                     0,
                                                     NULL,
                                                     NULL,
                                                     NULL,
                                                     NULL ))
                    {
                        //
                        //  Setup failed.
                        //
                        //  Already copied the code page file, so no need to
                        //  change the status of the code page info here.
                        //
                        //  This shouldn't happen - the inf file is messed up.
                        //
                        ShowMsg( hDlg,
                                 IDS_ML_INSTALL_FAILED,
                                 0,
                                 MB_OK_OOPS,
                                 pCP->pszName );
                    }

                    //
                    //  Reset the status to show the new state of this
                    //  code page.
                    //
                    pCP->wStatus &= (ML_STATIC);
                    if (fAdd)
                    {
                        pCP->wStatus |= ML_ORIG_INSTALLED;
                    }
                }

                //
                //  Clear out wStatus and go to the next code page node.
                //
                pCP->wStatus &= (ML_ORIG_INSTALLED | ML_STATIC);
                pCP = pCP->pNext;
            }

    Advanced_CodepageConverionsSetupError:
            //
            //  Close Inf stuff.
            //
            Intl_CloseInf(hIntlInf, FileQueue, QueueContext);
        }

        //
        //  Check if we need a reboot
        //
        if (RegionalChgState & AD_SystemLocale)
        {
            bReboot = TRUE;
        }
    }

    //
    //  See if there are any changes to the system locale.
    //
    if (Changes & AD_SystemLocale)
    {
        //
        //  Get the current selection.
        //
        dwLocale = ComboBox_GetCurSel(hSystemLocale);

        //
        //  Get the locale id for the current selection and save it.
        //
        NewLocale = (LCID)ComboBox_GetItemData(hSystemLocale, dwLocale);
        if (IsValidLocale(NewLocale, LCID_SUPPORTED))
        {
            SysLocaleID = NewLocale;
        }
        else
        {
            //
            //  This shouldn't happen, since the values in the combo box
            //  should already be installed via the language groups.
            //  Put up an error message just in case.
            //
            SetCursor(hcurSave);
            ShowMsg( NULL,
                     IDS_SETUP_STRING,
                     IDS_TITLE_STRING,
                     MB_OK_OOPS,
                     NULL );
            return (FALSE);
        }

        //
        //  See if the current selection is different from the original
        //  selection.
        //
        if (RegSysLocaleID != SysLocaleID)
        {
            //
            //  Call setup to install the option.
            //
            if (SetupChangeLocaleEx( hDlg,
                                     SysLocaleID,
                                     pSetupSourcePath,
                                     (g_bSetupCase)
                                       ? SP_INSTALL_FILES_QUIETLY
                                       : 0,
                                     NULL,
                                     0 ))
            {
                //
                //  If Setup fails, put up a message.
                //
                SetCursor(hcurSave);
                ShowMsg( NULL,
                         IDS_SETUP_STRING,
                         IDS_TITLE_STRING,
                         MB_OK_OOPS,
                         NULL );
                SysLocaleID = GetSystemDefaultLCID();
                return (FALSE);
            }

            //
            //  Check if we need to proceed with the Font Substitution
            //
            if (Intl_IsUIFontSubstitute() &&
                ((LANGID)LANGIDFROMLCID(SysLocaleID) == Intl_GetDotDefaultUILanguage()))
            {
                Intl_ApplyFontSubstitute(SysLocaleID);
            }

            //
            //  Reset the registry system locale value.
            //
            RegSysLocaleID = SysLocaleID;

            //
            //  Need to make sure the proper keyboard layout is installed.
            //
            Intl_InstallKeyboardLayout(hDlg, SysLocaleID, 0, FALSE, FALSE, TRUE);

            //
            //  See if we need to reboot.
            //
            if (SysLocaleID != GetSystemDefaultLCID())
            {
                bReboot = TRUE;
            }

            InvokeSysocmgr = TRUE;
        }
    }

    //
    //  If the system locale changed and we're not running
    //  in gui setup, then let's invoke sysocmgr.exe.
    //
    if (!g_bSetupCase && InvokeSysocmgr)
    {
        //
        //  Run any necessary apps (for FSVGA/FSNEC installation).
        //
        Intl_RunRegApps(c_szSysocmgr);
    }

    //
    //  Reset the property page settings.
    //
    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    Changes = AD_EverChg;

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  See if we need to display the reboot message.
    //
    if ((!g_bSetupCase) && (bReboot))
    {
        if(RegionalChgState & Process_Languages )
        {
            RegionalChgState &= ~(AD_CodePages | AD_SystemLocale);
        }
        else
        {
            if (ShowMsg( hDlg,
                         IDS_REBOOT_STRING,
                         IDS_TITLE_STRING,
                         MB_YESNO | MB_ICONQUESTION,
                         NULL ) == IDYES)
            {
                Intl_RebootTheSystem(TRUE);
            }
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Advanced_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= AD_EverChg)
    {
        return (TRUE);
    }

    //
    //  See if the system locale has changed.
    //
    if (Changes & AD_SystemLocale)
    {
        HWND hSystemLocale = GetDlgItem(hDlg, IDC_SYSTEM_LOCALE);
        DWORD dwLocale = ComboBox_GetCurSel(hSystemLocale);
        LCID NewLocale;

        //
        //  Get the locale id for the current selection and save it.
        //
        NewLocale = (LCID)ComboBox_GetItemData(hSystemLocale, dwLocale);
        if (IsValidLocale(NewLocale, LCID_SUPPORTED))
        {
            SysLocaleID = NewLocale;
        }
        else
        {
            //
            //  This shouldn't happen, since the values in the combo box
            //  should already be installed via the language groups.
            //  Put up an error message just in case.
            //
            ShowMsg( NULL,
                     IDS_SETUP_STRING,
                     IDS_TITLE_STRING,
                     MB_OK_OOPS,
                     NULL );
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Advanced_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Advanced_SetValues with the property
//  sheet handle to initialize all of the property sheet controls.  Limit
//  the length of the text in some of the ComboBoxes.
//
////////////////////////////////////////////////////////////////////////////

void Advanced_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    //
    //  The lParam holds a pointer to the property sheet page.  Save it
    //  for later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    //
    //  Set values.
    //
    if (pLanguageGroups == NULL)
    {
        Intl_LoadLanguageGroups(hDlg);
    }
    Advanced_SetValues(hDlg, TRUE);

    //
    //  If we are in setup mode, we need to disable the Default User
    //  Account UI.
    //
    if (g_bSetupCase)
    {
        HWND hUIDefUserBox = GetDlgItem(hDlg, IDC_GROUPBOX3);
        HWND hUIDefUser = GetDlgItem(hDlg, IDC_DEFAULT_USER);
    
        EnableWindow(hUIDefUserBox, FALSE);
        EnableWindow(hUIDefUser, FALSE);
        ShowWindow(hUIDefUserBox, SW_HIDE);
        ShowWindow(hUIDefUser, SW_HIDE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  AdvancedDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK AdvancedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch (message)
    {
        case ( WM_NOTIFY ) :
        {
            LPNMHDR lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Advanced)
                    {
                        Verified_Regional_Chg &= ~Process_Advanced;
                        Advanced_ClearValues(hDlg);
                        Advanced_SetValues(hDlg, FALSE);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                      DWLP_MSGRESULT,
                                      !Advanced_ValidatePPS(hDlg, lpPropSheet->lParam) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Advanced_ApplySettings(hDlg))
                    {
                        SetWindowLongPtr( hDlg,
                                          DWLP_MSGRESULT,
                                          PSNRET_NOERROR );

                        //
                        //  Zero out the AD_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                          DWLP_MSGRESULT,
                                          PSNRET_INVALID_NOCHANGEPAGE );
                    }


                    break;
                }
                case ( NM_CUSTOMDRAW ) :
                {
                    Advanced_ListViewCustomDraw(hDlg, (LPNMLVCUSTOMDRAW)lParam);
                    return (TRUE);
                }
                case ( LVN_ITEMCHANGING ) :
                {
                    Advanced_ListViewChanging(hDlg, (NM_LISTVIEW *)lParam);
                    break;
                }
                case ( LVN_ITEMCHANGED ) :
                {
                    //
                    //  Save the change to the code pages.
                    //
                    if (Advanced_ListViewChanged( hDlg,
                                                  IDC_CODEPAGES,
                                                  (NM_LISTVIEW *)lParam ))
                    {
                        //
                        //  Note that the code pages have changed and
                        //  enable the apply button.
                        //
                        lpPropSheet->lParam |= AD_CodePages;
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                        RegionalChgState |= AD_CodePages;
                    }
                    break;
                }
                case ( NM_CLICK ) :
                case ( NM_DBLCLK ) :
                {
                    Advanced_ListViewClick(hDlg, (NMHDR*)lParam);
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            Advanced_InitPropSheet(hDlg, lParam);
            break;
        }
        case ( WM_DESTROY ) :
        {
            Advanced_FreeGlobalInfo();
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aAdvancedHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aAdvancedHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_SYSTEM_LOCALE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        //
                        //  Set the AD_SystemLocale change flag.
                        //
                        lpPropSheet->lParam |= AD_SystemLocale;
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                        RegionalChgState |= AD_SystemLocale;
                    }
                    break;
                }
                case ( IDC_DEFAULT_USER ) :
                {
                    BOOL curState;

                    //
                    //  Verify the check box state.
                    //
                    if (IsDlgButtonChecked(hDlg, IDC_DEFAULT_USER))
                    {
                        ShowMsg( hDlg,
                                 IDS_DEF_USER_CONF,
                                 IDS_DEF_USER_CONF_TITLE,
                                 MB_OK_OOPS,
                                 NULL);
                                 
                        g_bDefaultUser = TRUE;
                    }
                    else
                    {
                        g_bDefaultUser = FALSE;
                    }

                    //
                    //  Set the AD_DefaultUser change flag.
                    //
                    if (g_bDefaultUser)
                    {
                        lpPropSheet->lParam |= AD_DefaultUser;
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                    else
                    {
                        lpPropSheet->lParam &= ~AD_DefaultUser;
                    }
                    break;
                }
            }

            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\intl\curdlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    curdlg.c

Abstract:

    This module implements the currency property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <tchar.h>
#include <windowsx.h>
#include "intlhlp.h"
#include "maxvals.h"

#define STRSAFE_LIB
#include <strsafe.h>

//
//  Global Variables.
//
static TCHAR sz_iCurrDigits[MAX_ICURRDIGITS+1];
static TCHAR sz_iCurrency[MAX_ICURRENCY+1];
static TCHAR sz_iNegCurr[MAX_INEGCURR+1];
static TCHAR sz_sCurrency[MAX_SCURRENCY+1];
static TCHAR sz_sMonDecimalSep[MAX_SMONDECSEP+1];
static TCHAR sz_sMonGrouping[MAX_SMONGROUPING+1];
static TCHAR sz_sMonThousandSep[MAX_SMONTHOUSEP+1];


//
//  Context Help Ids.
//
static int aCurrencyHelpIds[] =
{
    IDC_SAMPLELBL1,         IDH_INTL_CURR_POSVALUE,
    IDC_SAMPLE1,            IDH_INTL_CURR_POSVALUE,
    IDC_SAMPLELBL2,         IDH_INTL_CURR_NEGVALUE,
    IDC_SAMPLE2,            IDH_INTL_CURR_NEGVALUE,
    IDC_SAMPLELBL3,         IDH_COMM_GROUPBOX,
    IDC_POS_CURRENCY_SYM,   IDH_INTL_CURR_POSOFSYMBOL,
    IDC_CURRENCY_SYMBOL,    IDH_INTL_CURR_SYMBOL,
    IDC_NEG_NUM_FORMAT,     IDH_INTL_CURR_NEGNUMFMT,
    IDC_DECIMAL_SYMBOL,     IDH_INTL_CURR_DECSYMBOL,
    IDC_NUM_DECIMAL_DIGITS, IDH_INTL_CURR_DIGITSAFTRDEC,
    IDC_DIGIT_GROUP_SYMBOL, IDH_INTL_CURR_DIGITGRPSYMBOL,
    IDC_NUM_DIGITS_GROUP,   IDH_INTL_CURR_DIGITSINGRP,

    0, 0
};





////////////////////////////////////////////////////////////////////////////
//
//  Currency_DisplaySample
//
//  Updates the currency sample.  It formats the currency based on the
//  user's current locale settings.  It displays either a positive value
//  or a negative value based on the Positive/Negative radio buttons.
//
////////////////////////////////////////////////////////////////////////////

void Currency_DisplaySample(
    HWND hDlg)
{
    TCHAR szBuf[MAX_SAMPLE_SIZE];
    int nCharCount;

    //
    //  Get the string representing the currency format for the positive sample
    //  currency and, if the the value is valid, display it.  Perform the same
    //  operations for the negative currency sample.
    //
    nCharCount = GetCurrencyFormat( UserLocaleID,
                                    0,
                                    szSample_Number,
                                    NULL,
                                    szBuf,
                                    MAX_SAMPLE_SIZE );
    if (nCharCount)
    {
        SetDlgItemText(hDlg, IDC_SAMPLE1, szBuf);
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }

    nCharCount = GetCurrencyFormat( UserLocaleID,
                                    0,
                                    szNegSample_Number,
                                    NULL,
                                    szBuf,
                                    MAX_SAMPLE_SIZE );
    if (nCharCount)
    {
        SetDlgItemText(hDlg, IDC_SAMPLE2, szBuf);
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_SaveValues
//
//  Save values in the case that we need to restore them.
//
////////////////////////////////////////////////////////////////////////////

void Currency_SaveValues()
{
    //
    //  Save values.
    //
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_ICURRDIGITS,
                        sz_iCurrDigits,
                        MAX_ICURRDIGITS + 1 ))
    {
        //_tcscpy(sz_iCurrDigits, TEXT("2"));
        if(FAILED(StringCchCopy(sz_iCurrDigits, MAX_ICURRDIGITS+1, TEXT("2"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_ICURRENCY,
                        sz_iCurrency,
                        MAX_ICURRENCY + 1 ))
    {
        //_tcscpy(sz_iCurrency, TEXT("0"));
        if(FAILED(StringCchCopy(sz_iCurrency, MAX_ICURRENCY+1, TEXT("0"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_INEGCURR,
                        sz_iNegCurr,
                        MAX_INEGCURR + 1 ))
    {
        //_tcscpy(sz_iNegCurr, TEXT("0"));
        if(FAILED(StringCchCopy(sz_iNegCurr, MAX_INEGCURR+1, TEXT("0"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SCURRENCY,
                        sz_sCurrency,
                        MAX_SCURRENCY + 1 ))
    {
        //_tcscpy(sz_sCurrency, TEXT("$"));
        if(FAILED(StringCchCopy(sz_sCurrency, MAX_SCURRENCY+1, TEXT("$"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SMONDECIMALSEP,
                        sz_sMonDecimalSep,
                        MAX_SMONDECSEP + 1 ))
    {
        //_tcscpy(sz_sMonDecimalSep, TEXT("."));
        if(FAILED(StringCchCopy(sz_sMonDecimalSep, MAX_SMONDECSEP+1, TEXT("."))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SMONGROUPING,
                        sz_sMonGrouping,
                        MAX_SMONGROUPING + 1 ))
    {
        //_tcscpy(sz_sMonGrouping, TEXT("3;0"));
        if(FAILED(StringCchCopy(sz_sMonGrouping, MAX_SMONGROUPING+1, TEXT("3;0"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SMONTHOUSANDSEP,
                        sz_sMonThousandSep,
                        MAX_SMONTHOUSEP + 1 ))
    {
        //_tcscpy(sz_sMonThousandSep, TEXT(","));
        if(FAILED(StringCchCopy(sz_sMonThousandSep, MAX_SMONTHOUSEP+1, TEXT(","))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_RestoreValues
//
////////////////////////////////////////////////////////////////////////////

void Currency_RestoreValues()
{
    if (g_dwCustChange & Process_Curr)
    {
        SetLocaleInfo(UserLocaleID, LOCALE_ICURRDIGITS,     sz_iCurrDigits);
        SetLocaleInfo(UserLocaleID, LOCALE_ICURRENCY,       sz_iCurrency);
        SetLocaleInfo(UserLocaleID, LOCALE_INEGCURR,        sz_iNegCurr);
        SetLocaleInfo(UserLocaleID, LOCALE_SCURRENCY,       sz_sCurrency);
        SetLocaleInfo(UserLocaleID, LOCALE_SMONDECIMALSEP,  sz_sMonDecimalSep);
        SetLocaleInfo(UserLocaleID, LOCALE_SMONGROUPING,    sz_sMonGrouping);
        SetLocaleInfo(UserLocaleID, LOCALE_SMONTHOUSANDSEP, sz_sMonThousandSep);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_ClearValues
//
//  Reset each of the list boxes in the currency property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Currency_ClearValues(
    HWND hDlg)
{
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_CURRENCY_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_POS_CURRENCY_SYM));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NEG_NUM_FORMAT));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DECIMAL_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NUM_DECIMAL_DIGITS));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DIGIT_GROUP_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NUM_DIGITS_GROUP));
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_SetValues
//
//  Initialize all of the controls in the currency property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Currency_SetValues(
    HWND hDlg)
{
    HWND hCtrl1, hCtrl2;
    TCHAR szBuf[SIZE_128];
    int Index;
    const nMax_Array_Fill = (cInt_Str >= 10 ? 10 : cInt_Str);
    CURRENCYFMT cfmt;
    TCHAR szThousandSep[SIZE_128];
    TCHAR szEmpty[]  = TEXT("");
    TCHAR szSample[] = TEXT("123456789");

    //
    //  Initialize the dropdown box for the current locale setting for:
    //      Currency Symbol
    //      Currency Decimal Symbol
    //      Currency Grouping Symbol
    //
    DropDown_Use_Locale_Values(hDlg, LOCALE_SCURRENCY, IDC_CURRENCY_SYMBOL);
    DropDown_Use_Locale_Values(hDlg, LOCALE_SMONDECIMALSEP, IDC_DECIMAL_SYMBOL);
    DropDown_Use_Locale_Values(hDlg, LOCALE_SMONTHOUSANDSEP, IDC_DIGIT_GROUP_SYMBOL);

    //
    //  Fill in the Number of Digits after Decimal Symbol drop down list
    //  with the values of 0 through 10.  Get the user locale value and
    //  make it the current selection.  If GetLocaleInfo fails, simply
    //  select the first item in the list.
    //
    hCtrl1 = GetDlgItem(hDlg, IDC_NUM_DECIMAL_DIGITS);
    hCtrl2 = GetDlgItem(hDlg, IDC_NUM_DIGITS_GROUP);
    for (Index = 0; Index < nMax_Array_Fill; Index++)
    {
        ComboBox_InsertString(hCtrl1, -1, aInt_Str[Index]);
    }

    if (GetLocaleInfo(UserLocaleID, LOCALE_ICURRDIGITS, szBuf, SIZE_128))
    {
        ComboBox_SelectString(hCtrl1, -1, szBuf);
    }
    else
    {
        ComboBox_SetCurSel(hCtrl1, 0);
    }

    //
    //  Fill in the Number of Digits in "Thousands" Grouping's drop down
    //  list with the appropriate options.  Get the user locale value and
    //  make it the current selection.  If GetLocaleInfo fails, simply
    //  select the first item in the list.
    //
    cfmt.NumDigits = 0;                // no decimal in sample string
    cfmt.LeadingZero = 0;              // no decimal in sample string
    cfmt.lpDecimalSep = szEmpty;       // no decimal in sample string
    cfmt.NegativeOrder = 0;            // not a negative value
    cfmt.PositiveOrder = 0;            // prefix, no separation
    cfmt.lpCurrencySymbol = szEmpty;   // no currency symbol
    cfmt.lpThousandSep = szThousandSep;
    GetLocaleInfo(UserLocaleID, LOCALE_SMONTHOUSANDSEP, szThousandSep, SIZE_128);

    cfmt.Grouping = 0;
    if (GetCurrencyFormat(UserLocaleID, 0, szSample, &cfmt, szBuf, SIZE_128))
    {
        ComboBox_InsertString(hCtrl2, -1, szBuf);
    }
    cfmt.Grouping = 3;
    if (GetCurrencyFormat(UserLocaleID, 0, szSample, &cfmt, szBuf, SIZE_128))
    {
        ComboBox_InsertString(hCtrl2, -1, szBuf);
    }
    cfmt.Grouping = 32;
    if (GetCurrencyFormat(UserLocaleID, 0, szSample, &cfmt, szBuf, SIZE_128))
    {
        ComboBox_InsertString(hCtrl2, -1, szBuf);
    }

    if (GetLocaleInfo(UserLocaleID, LOCALE_SMONGROUPING, szBuf, SIZE_128) &&
        (szBuf[0]))
    {
        //
        //  Since only the values 0, 3;0, and 3;2;0 are allowed, simply
        //  ignore the ";#"s for subsequent groupings.
        //
        Index = 0;
        if (szBuf[0] == TEXT('3'))
        {
            if ((szBuf[1] == CHAR_SEMICOLON) && (szBuf[2] == TEXT('2')))
            {
                Index = 2;
            }
            else
            {
                Index = 1;
            }
        }
        else
        {
            //
            //  We used to allow the user to set #;0, where # is a value from
            //  0 - 9.  If it's 0, then fall through so that Index is 0.
            //
            if ((szBuf[0] > CHAR_ZERO) && (szBuf[0] <= CHAR_NINE) &&
                ((szBuf[1] == 0) || (lstrcmp(szBuf + 1, TEXT(";0")) == 0)))
            {
                cfmt.Grouping = szBuf[0] - CHAR_ZERO;
                if (GetCurrencyFormat(UserLocaleID, 0, szSample, &cfmt, szBuf, SIZE_128))
                {
                    Index = ComboBox_InsertString(hCtrl2, -1, szBuf);
                    if (Index >= 0)
                    {
                        ComboBox_SetItemData( hCtrl2,
                                              Index,
                                              (LPARAM)((DWORD)cfmt.Grouping) );
                    }
                    else
                    {
                        Index = 0;
                    }
                }
            }
        }
        ComboBox_SetCurSel(hCtrl2, Index);
    }
    else
    {
        ComboBox_SetCurSel(hCtrl2, 0);
    }

    //
    //  Initialize and Lock function.  If it succeeds, call enum function to
    //  enumerate all possible values for the list box via a call to EnumProc.
    //  EnumProc will call Set_List_Values for each of the string values it
    //  receives.  When the enumeration of values is complete, call
    //  Set_List_Values to clear the dialog item specific data and to clear the
    //  lock on the function.  Perform this set of operations for:
    //  Position of Currency Symbol and Negative Currency Format.
    //
    if (Set_List_Values(hDlg, IDC_POS_CURRENCY_SYM, 0))
    {
        EnumPosCurrency(EnumProcEx, UserLocaleID, 0);

        Set_List_Values(0, IDC_POS_CURRENCY_SYM, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_ICURRENCY, szBuf, SIZE_128))
        {
            ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_POS_CURRENCY_SYM),
                                Intl_StrToLong(szBuf) );
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }
    if (Set_List_Values(hDlg, IDC_NEG_NUM_FORMAT, 0))
    {
        EnumNegCurrency(EnumProcEx, UserLocaleID, 0);
        Set_List_Values(0, IDC_NEG_NUM_FORMAT, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_INEGCURR, szBuf, SIZE_128))
        {
            ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_NEG_NUM_FORMAT),
                                Intl_StrToLong(szBuf) );
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }

    //
    //  Display the current sample that represents all of the locale settings.
    //
    Currency_DisplaySample(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_ApplySettings
//
//  For every control that has changed (that affects the Locale settings),
//  call Set_Locale_Values to update the user locale information.  Notify
//  the parent of changes and reset the change flag stored in the property
//  sheet page structure appropriately.  Redisplay the currency sample
//  if bRedisplay is TRUE.
//
////////////////////////////////////////////////////////////////////////////

BOOL Currency_ApplySettings(
    HWND hDlg,
    BOOL bRedisplay)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;

    if (Changes & CC_SCurrency)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SCURRENCY,
                                IDC_CURRENCY_SYMBOL,
                                TEXT("sCurrency"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_CurrSymPos)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_ICURRENCY,
                                IDC_POS_CURRENCY_SYM,
                                TEXT("iCurrency"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_NegCurrFmt)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_INEGCURR,
                                IDC_NEG_NUM_FORMAT,
                                TEXT("iNegCurr"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_SMonDec)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SMONDECIMALSEP,
                                IDC_DECIMAL_SYMBOL,
                                0,
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_ICurrDigits)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_ICURRDIGITS,
                                IDC_NUM_DECIMAL_DIGITS,
                                TEXT("iCurrDigits"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_SMonThousand)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SMONTHOUSANDSEP,
                                IDC_DIGIT_GROUP_SYMBOL,
                                0,
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & CC_DMonGroup)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SMONGROUPING,
                                IDC_NUM_DIGITS_GROUP,
                                0,
                                TRUE,
                                0,
                                TEXT(";0"),
                                NULL ))
        {
            return (FALSE);
        }
    }

    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    lpPropSheet->lParam = CC_EverChg;

    //
    //  Display the current sample that represents all of the locale settings.
    //
    if (bRedisplay)
    {
        Currency_ClearValues(hDlg);
        Currency_SetValues(hDlg);
    }

    //
    //  Changes made in the second level.
    //
    if (Changes)
    {
        g_dwCustChange |= Process_Curr;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Currency_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= CC_EverChg)
    {
        return (TRUE);
    }

    //
    //  If the currency symbol has changed, ensure that there are no digits
    //  contained in the new symbol.
    //
    if ((Changes & CC_SCurrency) &&
        Item_Has_Digits(hDlg, IDC_CURRENCY_SYMBOL, FALSE))
    {
        No_Numerals_Error(hDlg, IDC_CURRENCY_SYMBOL, IDS_LOCALE_CURR_SYM);
        return (FALSE);
    }

    //
    //  If the currency's decimal symbol has changed, ensure that there are
    //  no digits contained in the new symbol.
    //
    if ((Changes & CC_SMonDec) &&
        Item_Has_Digits(hDlg, IDC_DECIMAL_SYMBOL, FALSE))
    {
        No_Numerals_Error(hDlg, IDC_DECIMAL_SYMBOL, IDS_LOCALE_CDECIMAL_SYM);
        return (FALSE);
    }

    //
    //  If the currency's thousands grouping symbol has changed, ensure that
    //  there are no digits contained in the new symbol.
    //
    if ((Changes & CC_SMonThousand) &&
        Item_Has_Digits(hDlg, IDC_DIGIT_GROUP_SYMBOL, FALSE))
    {
        No_Numerals_Error(hDlg, IDC_DIGIT_GROUP_SYMBOL, IDS_LOCALE_CGROUP_SYM);
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Currency_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Currency_SetValues with the property
//  sheet handle to initialize all of the property sheet controls.  Limit
//  the length of the text in some of the ComboBoxes.
//
////////////////////////////////////////////////////////////////////////////

void Currency_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    //
    //  The lParam holds a pointer to the property sheet page, save it
    //  for later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    Currency_SetValues(hDlg);

    ComboBox_LimitText(GetDlgItem(hDlg, IDC_CURRENCY_SYMBOL),    MAX_SCURRENCY);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_DECIMAL_SYMBOL),     MAX_SMONDECSEP);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_DIGIT_GROUP_SYMBOL), MAX_SMONTHOUSEP);
}


////////////////////////////////////////////////////////////////////////////
//
//  CurrencyDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK CurrencyDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch (message)
    {
        case ( WM_NOTIFY ) :
        {
            lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Curr)
                    {
                        Verified_Regional_Chg &= ~Process_Curr;
                        Currency_ClearValues(hDlg);
                        Currency_SetValues(hDlg);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                   DWLP_MSGRESULT,
                                   !Currency_ValidatePPS( hDlg,
                                                          lpPropSheet->lParam) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Currency_ApplySettings(hDlg, TRUE))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                        //
                        //  Zero out the CC_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                       DWLP_MSGRESULT,
                                       PSNRET_INVALID_NOCHANGEPAGE );
                    }

                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            Currency_InitPropSheet(hDlg, lParam);
            Currency_SaveValues();

            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aCurrencyHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aCurrencyHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch ( LOWORD(wParam) )
            {
                case ( IDC_CURRENCY_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= CC_SCurrency;
                    }
                    break;
                }
                case ( IDC_POS_CURRENCY_SYM ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= CC_CurrSymPos;
                    }
                    break;
                }
                case ( IDC_NEG_NUM_FORMAT ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= CC_NegCurrFmt;
                    }
                    break;
                }
                case ( IDC_DECIMAL_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= CC_SMonDec;
                    }
                    break;
                }
                case ( IDC_NUM_DECIMAL_DIGITS ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= CC_ICurrDigits;
                    }
                    break;
                }
                case ( IDC_DIGIT_GROUP_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= CC_SMonThousand;
                    }
                    break;
                }
                case ( IDC_NUM_DIGITS_GROUP ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= CC_DMonGroup;
                    }
                    break;
                }
            }

            //
            //  Turn on ApplyNow button.
            //
            if (lpPropSheet->lParam > CC_EverChg)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }

            break;
        }

        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\intl\intl.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    intl.c

Abstract:

    This module contains the main routines for the Regional Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <cpl.h>
#include <tchar.h>

#define STRSAFE_LIB
#include <strsafe.h>


//
//  Constant Declarations.
//

#define MAX_PAGES 3          // limit on the number of pages on the first level

#define LANGUAGE_PACK_KEY    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\LanguagePack")
#define LANGUAGE_PACK_VALUE  TEXT("COMPLEXSCRIPTS")
#define LANGUAGE_PACK_DLL    TEXT("lpk.dll")

static const TCHAR c_szLanguages[] =
    TEXT("System\\CurrentControlSet\\Control\\Nls\\Language");

static const TCHAR c_szControlPanelIntl[] =
    TEXT("Control Panel\\International");




//
//  Global Variables.
//

TCHAR aInt_Str[cInt_Str][3] = { TEXT("0"),
                                TEXT("1"),
                                TEXT("2"),
                                TEXT("3"),
                                TEXT("4"),
                                TEXT("5"),
                                TEXT("6"),
                                TEXT("7"),
                                TEXT("8"),
                                TEXT("9")
                              };

BOOL  g_bAdmin_Privileges = FALSE;
DWORD g_dwLastSorting;
DWORD g_dwCurSorting;
BOOL  g_bCustomize = FALSE;
BOOL  g_bDefaultUser = FALSE;
DWORD g_dwCustChange = 0L;
BOOL  g_bShowSortingTab = FALSE;
BOOL  g_bInstallComplex = FALSE;
BOOL  g_bInstallCJK = FALSE;

TCHAR szSample_Number[] = TEXT("123456789.00");
TCHAR szNegSample_Number[] = TEXT("-123456789.00");
TCHAR szTimeChars[]  = TEXT(" Hhmst,-./:;\\ ");
TCHAR szTCaseSwap[]  = TEXT("   MST");
TCHAR szTLetters[]   = TEXT("Hhmst");
TCHAR szSDateChars[] = TEXT(" dgMy,-./:;\\ ");
TCHAR szSDCaseSwap[] = TEXT(" DGmY");
TCHAR szSDLetters[]  = TEXT("dgMy");
TCHAR szLDateChars[] = TEXT(" dgMy,-./:;\\");
TCHAR szLDCaseSwap[] = TEXT(" DGmY");
TCHAR szLDLetters[]  = TEXT("dgHhMmsty");
TCHAR szStyleH[3];
TCHAR szStyleh[3];
TCHAR szStyleM[3];
TCHAR szStylem[3];
TCHAR szStyles[3];
TCHAR szStylet[3];
TCHAR szStyled[3];
TCHAR szStyley[3];
TCHAR szLocaleGetError[SIZE_128];
TCHAR szIntl[] = TEXT("intl");

TCHAR szInvalidSDate[] = TEXT("Mdyg'");
TCHAR szInvalidSTime[] = TEXT("Hhmst'");

HINSTANCE hInstance;
int Verified_Regional_Chg = 0;
int RegionalChgState = 0;
BOOL Styles_Localized;
LCID UserLocaleID;
LCID SysLocaleID;
LCID RegUserLocaleID;
LCID RegSysLocaleID;
BOOL bShowArabic;
BOOL bShowRtL;
BOOL bHebrewUI;
BOOL bLPKInstalled;
TCHAR szSetupSourcePath[MAX_PATH];
TCHAR szSetupSourcePathWithArchitecture[MAX_PATH];
LPTSTR pSetupSourcePath = NULL;
LPTSTR pSetupSourcePathWithArchitecture = NULL;

BOOL g_bCDROM = FALSE;

int  g_bSetupCase = 0;  // See Intl_IsSetupMode for info on possible values
BOOL g_bLog = FALSE;
BOOL g_bProgressBarDisplay = FALSE;
BOOL g_bDisableSetupDialog = FALSE;
BOOL g_bSettingsChanged = FALSE;
BOOL g_bUnttendMode = FALSE;
BOOL g_bMatchUIFont = FALSE;

const TCHAR c_szInstalledLocales[] = TEXT("System\\CurrentControlSet\\Control\\Nls\\Locale");
const TCHAR c_szLanguageGroups[] = TEXT("System\\CurrentControlSet\\Control\\Nls\\Language Groups");
const TCHAR c_szMUILanguages[] = TEXT("System\\CurrentControlSet\\Control\\Nls\\MUILanguages");
const TCHAR c_szLIPInstalled[] = TEXT("Software\\Microsoft\\Windows Interface Pack\\LIPInstalled");
const TCHAR c_szFontSubstitute[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes");
const TCHAR c_szGreFontInitialize[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\GRE_Initialize");
const TCHAR c_szSetupKey[] = TEXT("System\\Setup");
const TCHAR c_szCPanelIntl[] = TEXT("Control Panel\\International");
const TCHAR c_szCPanelIntl_DefUser[] = TEXT(".DEFAULT\\Control Panel\\International");
const TCHAR c_szCtfmon[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run");
const TCHAR c_szCtfmon_DefUser[] = TEXT(".DEFAULT\\Software\\Microsoft\\Windows\\CurrentVersion\\Run");
const TCHAR c_szCPanelDesktop[] = TEXT("Control Panel\\Desktop");
const TCHAR c_szCPanelDesktop_DefUser[] = TEXT(".DEFAULT\\Control Panel\\Desktop");
const TCHAR c_szKbdLayouts[] = TEXT("Keyboard Layout");
const TCHAR c_szKbdLayouts_DefUser[] = TEXT(".DEFAULT\\Keyboard Layout");
const TCHAR c_szInputMethod[] = TEXT("Control Panel\\Input Method");
const TCHAR c_szInputMethod_DefUser[] = TEXT(".DEFAULT\\Control Panel\\Input Method");
const TCHAR c_szInputTips[] = TEXT("Software\\Microsoft\\CTF");
const TCHAR c_szInputTips_DefUser[] = TEXT(".DEFAULT\\Software\\Microsoft\\CTF");
const TCHAR c_szMUIPolicyKeyPath[] = TEXT("Software\\Policies\\Microsoft\\Control Panel\\Desktop");
const TCHAR c_szMUIValue[] = TEXT("MultiUILanguageId");
const TCHAR c_szIntlRun[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\IntlRun");
const TCHAR c_szSysocmgr[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\IntlRun.OC");

TCHAR szIntlInf[]          = TEXT("intl.inf");
TCHAR szHelpFile[]         = TEXT("windows.hlp");
TCHAR szFontSubstitute[]   = TEXT("FontSubstitute");
TCHAR szLocaleListPrefix[] = TEXT("LOCALE_LIST_");
TCHAR szLGBasicInstall[]   = TEXT("LANGUAGE_COLLECTION.BASIC.INSTALL");
TCHAR szLGComplexInstall[] = TEXT("LANGUAGE_COLLECTION.COMPLEX.INSTALL");
TCHAR szLGComplexRemove[]  = TEXT("LANGUAGE_COLLECTION.COMPLEX.REMOVE");
TCHAR szLGExtInstall[]     = TEXT("LANGUAGE_COLLECTION.EXTENDED.INSTALL");
TCHAR szLGExtRemove[]      = TEXT("LANGUAGE_COLLECTION.EXTENDED.REMOVE");
TCHAR szCPInstallPrefix[]  = TEXT("CODEPAGE_INSTALL_");
TCHAR szCPRemovePrefix[]   = TEXT("CODEPAGE_REMOVE_");
TCHAR szKbdLayoutIds[]     = TEXT("KbdLayoutIds");
TCHAR szInputLibrary[]     = TEXT("input.dll");

TCHAR szUIFontSubstitute[] = TEXT("UIFontSubstitute");
TCHAR szSetupInProgress[]  = TEXT("SystemSetupInProgress");
TCHAR szMiniSetupInProgress[] = TEXT("MiniSetupInProgress");
TCHAR szSetupUpgrade[]     = TEXT("UpgradeInProgress");
TCHAR szMUILangPending[]   = TEXT("MUILanguagePending");
TCHAR szCtfmonValue[]      = TEXT("ctfmon.exe");

TCHAR szRegionalSettings[] = TEXT("RegionalSettings");
TCHAR szLanguageGroup[]    = TEXT("LanguageGroup");
TCHAR szLanguage[]         = TEXT("Language");
TCHAR szSystemLocale[]     = TEXT("SystemLocale");
TCHAR szUserLocale[]       = TEXT("UserLocale");
TCHAR szInputLocale[]      = TEXT("InputLocale");
TCHAR szMUILanguage[]      = TEXT("MUILanguage");
TCHAR szUserLocale_DefUser[]  = TEXT("UserLocale_DefaultUser");
TCHAR szInputLocale_DefUser[] = TEXT("InputLocale_DefaultUser");
TCHAR szMUILanguage_DefUSer[] = TEXT("MUILanguage_DefaultUser");

HINF g_hIntlInf = NULL;

LPLANGUAGEGROUP pLanguageGroups = NULL;
LPCODEPAGE pCodePages = NULL;

int g_NumAltSorts = 0;
HANDLE hAltSorts = NULL;
LPDWORD pAltSorts = NULL;

HINSTANCE hInputDLL = NULL;
BOOL (*pfnInstallInputLayout)(LCID, DWORD, BOOL, HKL, BOOL, BOOL) = NULL;
BOOL (*pfnUninstallInputLayout)(LCID, DWORD, BOOL) = NULL;

UILANGUAGEGROUP UILangGroup;




//
//  Function Prototypes.
//

void
DoProperties(
    HWND hwnd,
    LPCTSTR pCmdLine);





////////////////////////////////////////////////////////////////////////////
//
//  LibMain
//
//  This routine is called from LibInit to perform any initialization that
//  is required.
//
////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY LibMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            hInstance = hDll;

            DisableThreadLibraryCalls(hDll);

            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            break;
        }
        case ( DLL_THREAD_DETACH ) :
        {
            break;
        }
        case ( DLL_THREAD_ATTACH ) :
        default :
        {
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateGlobals
//
////////////////////////////////////////////////////////////////////////////

BOOL CreateGlobals()
{
    HKEY hKey;
    TCHAR szData[MAX_PATH];
    DWORD cbData;
    DWORD dwDisposition;

    //
    //  Get the localized strings.
    //
    LoadString(hInstance, IDS_LOCALE_GET_ERROR, szLocaleGetError, SIZE_128);
    LoadString(hInstance, IDS_STYLEUH,          szStyleH,         3);
    LoadString(hInstance, IDS_STYLELH,          szStyleh,         3);
    LoadString(hInstance, IDS_STYLEUM,          szStyleM,         3);
    LoadString(hInstance, IDS_STYLELM,          szStylem,         3);
    LoadString(hInstance, IDS_STYLELS,          szStyles,         3);
    LoadString(hInstance, IDS_STYLELT,          szStylet,         3);
    LoadString(hInstance, IDS_STYLELD,          szStyled,         3);
    LoadString(hInstance, IDS_STYLELY,          szStyley,         3);

    Styles_Localized = (szStyleH[0] != TEXT('H') || szStyleh[0] != TEXT('h') ||
                        szStyleM[0] != TEXT('M') || szStylem[0] != TEXT('m') ||
                        szStyles[0] != TEXT('s') || szStylet[0] != TEXT('t') ||
                        szStyled[0] != TEXT('d') || szStyley[0] != TEXT('y'));

    //
    //  Get the user and system default locale ids.
    //
    UserLocaleID = GetUserDefaultLCID();
    SysLocaleID = GetSystemDefaultLCID();

    //
    //  Get the system locale id from the registry.  This may be
    //  different from the current system default locale id if the user
    //  changed the system locale and chose not to reboot.
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      c_szLanguages,
                      0L,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        //
        //  Query the default locale id.
        //
        szData[0] = 0;
        cbData = sizeof(szData);
        RegQueryValueEx(hKey, TEXT("Default"), NULL, NULL, (LPBYTE)szData, &cbData);
        RegCloseKey(hKey);

        if ((RegSysLocaleID = TransNum(szData)) == 0)
        {
            RegSysLocaleID = SysLocaleID;
        }
    }
    else
    {
        RegSysLocaleID = SysLocaleID;
    }

    //
    // Validate the user locale
    //
    if(IsValidLocale(UserLocaleID, LCID_INSTALLED))
    {
        RegUserLocaleID = UserLocaleID;
    }
    else
    {
        //
        // The locale is invalid, so fall back to the system locale.
        // Use the actual system locale on the machine at this time.
        //
        RegUserLocaleID = SysLocaleID;
        UserLocaleID =  SysLocaleID;

        //
        //  We need to fix up the registry key to avoid future problems.
        //
        if( ! (Intl_InstallUserLocale(SysLocaleID, FALSE, TRUE)))
        {
            // Unable up update the user locale, no choice but to bail.
            ExitProcess((DWORD)-1);
        }
    }

    //
    //  Check to be sure the user intl key exists
    //
    if (RegCreateKeyEx( HKEY_CURRENT_USER,
                        c_szControlPanelIntl,
                        0L,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hKey,
                        &dwDisposition ) == ERROR_SUCCESS)
    {
        RegCloseKey(hKey);

        if(REG_CREATED_NEW_KEY == dwDisposition)
        {
            //
            // We created the key, so fill it in with default values
            //
            Intl_InstallUserLocale(UserLocaleID, FALSE, TRUE);
        }
    }
    else
    {
        // Unable up create the key, so just open the UI
    }

    //
    //  See if the user locale id is Arabic or/and right to left.
    //
    bShowRtL = IsRtLLocale(UserLocaleID);
    bShowArabic = (bShowRtL &&
                   (PRIMARYLANGID(LANGIDFROMLCID(UserLocaleID)) != LANG_HEBREW));
    bHebrewUI = (PRIMARYLANGID(UserLocaleID) == LANG_HEBREW);

    //
    //  See if there is an LPK installed.
    //
    if (GetModuleHandle(LANGUAGE_PACK_DLL))
    {
        bLPKInstalled = TRUE;
    }
    else
    {
        bLPKInstalled = FALSE;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyGlobals
//
////////////////////////////////////////////////////////////////////////////

void DestroyGlobals()
{
}


////////////////////////////////////////////////////////////////////////////
//
//  CPlApplet
//
////////////////////////////////////////////////////////////////////////////

LONG CALLBACK CPlApplet(
    HWND hwnd,
    UINT Msg,
    LPARAM lParam1,
    LPARAM lParam2)
{
    switch (Msg)
    {
        case ( CPL_INIT ) :
        {
            //
            //  First message to CPlApplet(), sent once only.
            //  Perform all control panel applet initialization and return
            //  true for further processing.
            //
            InitCommonControls();
            return (CreateGlobals());
        }
        case ( CPL_GETCOUNT ) :
        {
            //
            //  Second message to CPlApplet(), sent once only.
            //  Return the number of control applets to be displayed in the
            //  control panel window.  For this applet, return 1.
            //
            return (1);
        }
        case ( CPL_INQUIRE ) :
        {
            //
            //  Third message to CPlApplet().
            //  It is sent as many times as the number of applets returned by
            //  CPL_GETCOUNT message.  Each applet must register by filling
            //  in the CPLINFO structure referenced by lParam2 with the
            //  applet's icon, name, and information string.  Since there is
            //  only one applet, simply set the information for this
            //  singular case.
            //
            LPCPLINFO lpCPlInfo = (LPCPLINFO)lParam2;

            lpCPlInfo->idIcon = IDI_ICON;
            lpCPlInfo->idName = IDS_NAME;
            lpCPlInfo->idInfo = IDS_INFO;
            lpCPlInfo->lData  = 0;

            break;
        }
        case ( CPL_NEWINQUIRE ) :
        {
            //
            //  Third message to CPlApplet().
            //  It is sent as many times as the number of applets returned by
            //  CPL_GETCOUNT message.  Each applet must register by filling
            //  in the NEWCPLINFO structure referenced by lParam2 with the
            //  applet's icon, name, and information string.  Since there is
            //  only one applet, simply set the information for this
            //  singular case.
            //
            LPNEWCPLINFO lpNewCPlInfo = (LPNEWCPLINFO)lParam2;

            lpNewCPlInfo->dwSize = sizeof(NEWCPLINFO);
            lpNewCPlInfo->dwFlags = 0;
            lpNewCPlInfo->dwHelpContext = 0UL;
            lpNewCPlInfo->lData = 0;
            lpNewCPlInfo->hIcon = LoadIcon( hInstance,
                                            (LPCTSTR)MAKEINTRESOURCE(IDI_ICON) );
            LoadString(hInstance, IDS_NAME, lpNewCPlInfo->szName, 32);
            LoadString(hInstance, IDS_INFO, lpNewCPlInfo->szInfo, 64);
            lpNewCPlInfo->szHelpFile[0] = CHAR_NULL;

            break;
        }
        case ( CPL_SELECT ) :
        {
            //
            //  Applet has been selected, do nothing.
            //
            break;
        }
        case ( CPL_DBLCLK ) :
        {
            //
            //  Applet icon double clicked -- invoke property sheet with
            //  the first property sheet page on top.
            //
            DoProperties(hwnd, (LPCTSTR)NULL);
            break;
        }
        case ( CPL_STARTWPARMS ) :
        {
            //
            //  Same as CPL_DBLCLK, but lParam2 is a long pointer to
            //  a string of extra directions that are to be supplied to
            //  the property sheet that is to be initiated.
            //
            DoProperties(hwnd, (LPCTSTR)lParam2);
            break;
        }
        case ( CPL_STOP ) :
        {
            //
            //  Sent once for each applet prior to the CPL_EXIT msg.
            //  Perform applet specific cleanup.
            //
            break;
        }
        case ( CPL_EXIT ) :
        {
            //
            //  Last message, sent once only, before MMCPL.EXE calls
            //  FreeLibrary() on this DLL.  Do non-applet specific cleanup.
            //
            DestroyGlobals();
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DoProperties
//
////////////////////////////////////////////////////////////////////////////

void DoProperties(
    HWND hwnd,
    LPCTSTR pCmdLine)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETHEADER psh;
    LPARAM lParam = SETUP_SWITCH_NONE;
    LPTSTR pStartPage;
    LPTSTR pSrc;
    LPTSTR pSrcDrv;
    BOOL bShortDate = FALSE;
    BOOL bNoUI = FALSE;
    BOOL bUnattended = FALSE;
    TCHAR szUnattendFile[MAX_PATH * 2];
    HKEY hKey;
    TCHAR szSetupSourceDrive[MAX_PATH];

    //
    //  Log if the command line is not null.
    //
    if (pCmdLine != NULL)
    {
        g_bLog = TRUE;
    }

    //
    //  Begin Log and log command line parameters.
    //
    Intl_LogSimpleMessage(IDS_LOG_HEAD, NULL);
    Intl_LogMessage(pCmdLine);
    Intl_LogMessage(TEXT(""));        // add a carriage return and newline

    //
    //  Load the library used for Text Services.
    //
    if (!hInputDLL)
    {
        hInputDLL = LoadLibrary(szInputLibrary);
    }

    //
    //  Initialize the Install/Remove function from the Input applet.
    //
    if (hInputDLL)
    {
        //
        //  Initialize Install function.
        //
        pfnInstallInputLayout = (BOOL (*)(LCID, DWORD, BOOL, HKL, BOOL, BOOL))
                GetProcAddress(hInputDLL, MAKEINTRESOURCEA(ORD_INPUT_INST_LAYOUT));

        //
        //  Initialize Uninstall function.
        //
        pfnUninstallInputLayout = (BOOL (*)(LCID, DWORD, BOOL))
                GetProcAddress(hInputDLL, MAKEINTRESOURCEA(ORD_INPUT_UNINST_LAYOUT));
    }

    //
    //  See if there is a command line switch from Setup.
    //
    psh.nStartPage = (UINT)-1;
    while (pCmdLine && *pCmdLine)
    {
        if (*pCmdLine == TEXT('/'))
        {
            //
            //  Legend:
            //    gG: allow progress bar to show when setup is copying files
            //    iI: bring up the Input Locale page only
            //    rR: bring up the General page on top
            //    sS: setup source string passed on command line
            //            [example: /s:"c:\winnt"]
            //
            //  NO UI IS SHOWN IF THE FOLLOWING OPTIONS ARE SPECIFIED:
            //    fF: unattend mode file - no UI is shown
            //            [example: /f:"c:\unattend.txt"]
            //    uU: update short date format to 4-digit year - no UI is shown
            //        (registry only updated if current setting is the
            //         same as the default setting except for the
            //         "yy" vs. "yyyy")
            //    tT: Match system UI font with the default UI language
            //    dD: disable the setup dialog asking for the source location
            //
            switch (*++pCmdLine)
            {
                case ( TEXT('g') ) :
                case ( TEXT('G') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_G, NULL);

                    //
                    //  Do switch related processing.
                    //
                    g_bProgressBarDisplay = TRUE;
                    pCmdLine++;
                    break;
                }
                case ( TEXT('i') ) :
                case ( TEXT('I') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_I, NULL);

                    //
                    //  Do switch related processing
                    //
                    lParam |= SETUP_SWITCH_I;
                    psh.nStartPage = 0;
                    pCmdLine++;
                    break;
                }
                case ( TEXT('r') ) :
                case ( TEXT('R') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_R, NULL);

                    //
                    //  Do switch related processing
                    //
                    lParam |= SETUP_SWITCH_R;
                    psh.nStartPage = 0;
                    pCmdLine++;
                    break;
                }
                case ( TEXT('d') ) :
                case ( TEXT('D') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_D, NULL);

                    //
                    //  Do switch related processing
                    //
                    g_bDisableSetupDialog = TRUE;
                    pCmdLine++;
                    break;
                }
                case ( TEXT('s') ) :
                case ( TEXT('S') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_S, NULL);

                    //
                    //  Get the name of the setup source path.
                    //
                    lParam |= SETUP_SWITCH_S;
                    if ((*++pCmdLine == TEXT(':')) && (*++pCmdLine == TEXT('"')))
                    {
                        pCmdLine++;
                        pSrc = szSetupSourcePath;
                        pSrcDrv = szSetupSourceDrive;
                        while (*pCmdLine && (*pCmdLine != TEXT('"')))
                        {
                            *pSrc = *pCmdLine;
                            pSrc++;
                            *pSrcDrv = *pCmdLine;
                            pSrcDrv++;
                            pCmdLine++;
                        }
                        *pSrc = 0;
                        *pSrcDrv = 0;
                        //wcscpy(szSetupSourcePathWithArchitecture, szSetupSourcePath);
                        if(FAILED(StringCchCopy(szSetupSourcePathWithArchitecture, MAX_PATH, szSetupSourcePath)))
                        {
                            // This should be impossible, but we need to avoid PREfast complaints.
                        }
                        pSetupSourcePathWithArchitecture = szSetupSourcePathWithArchitecture;

                        //
                        //  Remove the architecture-specific portion of
                        //  the source path (that gui-mode setup sent us).
                        //
                        pSrc = wcsrchr(szSetupSourcePath, TEXT('\\'));
                        if (pSrc)
                        {
                            *pSrc = TEXT('\0');
                        }
                        pSetupSourcePath = szSetupSourcePath;
                    }
                    if (*pCmdLine == TEXT('"'))
                    {
                        pCmdLine++;
                    }
                    pSrcDrv = szSetupSourceDrive;
                    while (*pSrcDrv)
                    {
                        if (*pSrcDrv == TEXT('\\'))
                        {
                            pSrcDrv[1] = 0;
                        }
                        pSrcDrv++;
                    }
                    g_bCDROM = (GetDriveType(szSetupSourceDrive) == DRIVE_CDROM);
                    break;
                }
                case ( TEXT('f') ) :
                case ( TEXT('F') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_F, NULL);

                    //
                    //  Get the name of the unattend file.
                    //
                    g_bUnttendMode = TRUE;
                    bNoUI = TRUE;
                    szUnattendFile[0] = 0;
                    if ((*++pCmdLine == TEXT(':')) && (*++pCmdLine == TEXT('"')))
                    {
                        pCmdLine++;
                        pSrc = szUnattendFile;
                        while (*pCmdLine && (*pCmdLine != TEXT('"')))
                        {
                            *pSrc = *pCmdLine;
                            pSrc++;
                            pCmdLine++;
                        }
                        *pSrc = 0;
                    }
                    if (*pCmdLine == TEXT('"'))
                    {
                        pCmdLine++;
                    }
                    break;
                }
                case ( TEXT('u') ) :
                case ( TEXT('U') ) :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_U, NULL);

                    //
                    //  Do switch related processing.
                    //
                    bShortDate = TRUE;
                    bNoUI = TRUE;
                    break;
                }

                case ( TEXT('t') ) :
                case ( TEXT('T') ) :
                {
                    g_bMatchUIFont = TRUE;
                }

                default :
                {
                    //
                    //  Log switch.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_SWITCH_DEFAULT, pCmdLine);

                    //
                    //  Fall out, maybe it's a number...
                    //
                    break;
                }
            }
        }
        else if (*pCmdLine == TEXT(' '))
        {
            pCmdLine++;
        }
        else
        {
            break;
        }
    }

    //
    //  See if we are in setup mode.
    //
    g_bSetupCase = Intl_IsSetupMode();

    //
    //  See if the user has Administrative privileges by checking for
    //  write permission to the registry key.
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      c_szInstalledLocales,
                      0UL,
                      KEY_WRITE,
                      &hKey ) == ERROR_SUCCESS)
    {
        //
        //  See if the user can write into the registry.  Due to a registry
        //  modification, we can open a registry key with write access and
        //  be unable to write to the key... thanks to terminal server.
        //
        if (RegSetValueEx( hKey,
                           TEXT("Test"),
                           0UL,
                           REG_SZ,
                           (LPBYTE)TEXT("Test"),
                           (DWORD)(lstrlen(TEXT("Test")) + 1) * sizeof(TCHAR) ) == ERROR_SUCCESS)
        {
            //
            //  Delete the value created
            //
            RegDeleteValue(hKey, TEXT("Test"));

            //
            //  We can write to the HKEY_LOCAL_MACHINE key, so the user
            //  has Admin privileges.
            //
            g_bAdmin_Privileges = TRUE;
        }
        else
        {
            //
            //  The user does not have admin privileges.
            //
            g_bAdmin_Privileges = FALSE;
        }
        RegCloseKey(hKey);
    }

    //
    //  See if we are in setup mode.
    //
    if (g_bSetupCase)
    {
        //
        //  We need to remove the hard coded LPK registry key.
        //
        if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          LANGUAGE_PACK_KEY,
                          0L,
                          KEY_READ | KEY_WRITE,
                          &hKey ) == ERROR_SUCCESS)
        {
            RegDeleteValue(hKey, LANGUAGE_PACK_VALUE);
            RegCloseKey(hKey);
        }
    }

    //
    //  See if the unattend mode file switch was used.
    //
    if (g_bUnttendMode)
    {
        //
        //  Use the unattend mode file to carry out the appropriate commands.
        //
        Region_DoUnattendModeSetup(szUnattendFile);

        if (Intl_IsWinntUpgrade())
        {
            //
            //  Remove MUI files.
            //
            Intl_RemoveMUIFile();
        }
    }

    //
    //  If the update to 4-digit year switch was used and the user's short
    //  date setting is still set to the default for the chosen locale, then
    //  update the current user's short date setting to the new 4-digit year
    //  default.
    //
    if (bShortDate)
    {
        Region_UpdateShortDate();
    }

    //
    //  If we're not to show any UI, then return.
    //
    if (bNoUI)
    {
        return;
    }

    //
    //  Make sure we have a start page.
    //
    if (psh.nStartPage == (UINT)-1)
    {
        psh.nStartPage = 0;
        if (pCmdLine && *pCmdLine)
        {
            //
            //  Get the start page from the command line.
            //
            pStartPage = (LPTSTR)pCmdLine;
            while ((*pStartPage >= TEXT('0')) && (*pStartPage <= TEXT('9')))
            {
                psh.nStartPage *= 10;
                psh.nStartPage += *pStartPage++ - CHAR_ZERO;
            }

            //
            //  Make sure that the requested starting page is less than
            //  the max page for the selected applet.
            //
            if (psh.nStartPage >= MAX_PAGES)
            {
                psh.nStartPage = 0;
            }
        }
    }

    //
    //  Set up the property sheet information.
    //
    psh.dwSize = sizeof(psh);
    psh.dwFlags = 0;
    psh.hwndParent = hwnd;
    psh.hInstance = hInstance;
    psh.nPages = 0;
    psh.phpage = rPages;

    //
    //  Add the appropriate property pages.
    //
    if (lParam &= SETUP_SWITCH_I)
    {
        psh.pszCaption = MAKEINTRESOURCE(IDS_TEXT_INPUT_METHODS);
        Intl_AddExternalPage( &psh,
                              DLG_INPUT_LOCALES,
                              hInputDLL,
                              MAKEINTRESOURCEA(ORD_INPUT_DLG_PROC),
                              MAX_PAGES );   // One page
    }
    else
    {
        psh.pszCaption = MAKEINTRESOURCE(IDS_NAME);
        Intl_AddPage(&psh, DLG_GENERAL, GeneralDlgProc, lParam, MAX_PAGES);
        Intl_AddPage(&psh, DLG_LANGUAGES, LanguageDlgProc, lParam, MAX_PAGES);
        if (g_bAdmin_Privileges == TRUE)
        {
            Intl_AddPage(&psh, DLG_ADVANCED, AdvancedDlgProc, lParam, MAX_PAGES);
        }
    }

    //
    //  Make the property sheet.
    //
    PropertySheet(&psh);

    //
    //  Free the Text Services Library.
    //
    if (hInputDLL)
    {
        FreeLibrary(hInputDLL);
        pfnInstallInputLayout = NULL;
        pfnUninstallInputLayout = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  IsRtLLocale
//
////////////////////////////////////////////////////////////////////////////

#define MAX_FONTSIGNATURE    16   // length of font signature string

BOOL IsRtLLocale(
    LCID iLCID)
{
    WORD wLCIDFontSignature[MAX_FONTSIGNATURE];
    BOOL bRet = FALSE;

    //
    //  Verify that this is an RTL (BiDi) locale.  Call GetLocaleInfo with
    //  LOCALE_FONTSIGNATURE which always gives back 16 WORDs.
    //
    if (GetLocaleInfo( iLCID,
                       LOCALE_FONTSIGNATURE,
                       (LPTSTR) wLCIDFontSignature,
                       (sizeof(wLCIDFontSignature) / sizeof(TCHAR)) ))
    {
        //
        //  Verify the bits show a BiDi UI locale.
        //
        if (wLCIDFontSignature[7] & 0x0800)
        {
            bRet = TRUE;
        }
    }

    //
    //  Return the result.
    //
    return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\intl\datedlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    datedlg.c

Abstract:

    This module implements the date property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <windowsx.h>
#include <tchar.h>
#include <commctrl.h>
#include "intlhlp.h"
#include "maxvals.h"
#include "winnlsp.h"

#define STRSAFE_LIB
#include <strsafe.h>


//
//  Context Help Ids.
//

static int aDateHelpIds[] =
{
    IDC_GROUPBOX1,             IDH_COMM_GROUPBOX,
    IDC_GROUPBOX2,             IDH_COMM_GROUPBOX,
    IDC_GROUPBOX3,             IDH_COMM_GROUPBOX,
    IDC_SAMPLE1,               IDH_INTL_DATE_SHORTSAMPLE,
    IDC_SAMPLELBL1,            IDH_INTL_DATE_SHORTSAMPLE,
    IDC_SAMPLE1A,              IDH_INTL_DATE_SHORTSAMPLE_ARABIC,
    IDC_SAMPLELBL1A,           IDH_INTL_DATE_SHORTSAMPLE_ARABIC,
    IDC_SHORT_DATE_STYLE,      IDH_INTL_DATE_SHORTSTYLE,
    IDC_SEPARATOR,             IDH_INTL_DATE_SEPARATOR,
    IDC_SAMPLE2,               IDH_INTL_DATE_LONGSAMPLE,
    IDC_SAMPLELBL2,            IDH_INTL_DATE_LONGSAMPLE,
    IDC_SAMPLE2A,              IDH_INTL_DATE_LONGSAMPLE_ARABIC,
    IDC_SAMPLELBL2A,           IDH_INTL_DATE_LONGSAMPLE_ARABIC,
    IDC_LONG_DATE_STYLE,       IDH_INTL_DATE_LONGSTYLE,
    IDC_CALENDAR_TYPE_TEXT,    IDH_INTL_DATE_CALENDARTYPE,
    IDC_CALENDAR_TYPE,         IDH_INTL_DATE_CALENDARTYPE,
    IDC_TWO_DIGIT_YEAR_LOW,    IDH_INTL_DATE_TWO_DIGIT_YEAR,
    IDC_TWO_DIGIT_YEAR_HIGH,   IDH_INTL_DATE_TWO_DIGIT_YEAR,
    IDC_TWO_DIGIT_YEAR_ARROW,  IDH_INTL_DATE_TWO_DIGIT_YEAR,
    IDC_ADD_HIJRI_DATE,        IDH_INTL_DATE_ADD_HIJRI_DATE,
    IDC_ADD_HIJRI_DATE_TEXT,   IDH_INTL_DATE_ADD_HIJRI_DATE,

    0, 0
};



//
//  Global Variables.
//

TCHAR szNLS_LongDate[SIZE_128];
TCHAR szNLS_ShortDate[SIZE_128];

static TCHAR sz_iCalendarType[MAX_ICALTYPE + 1];
static TCHAR sz_sDate[MAX_SDATE + 1];
static TCHAR sz_sLongDate[MAX_SLONGDATE + 1];
static TCHAR sz_sShortDate[MAX_FORMAT + 1];


static const TCHAR c_szInternational[] = TEXT("Control Panel\\International");
static const TCHAR c_szAddHijriDate[]  = TEXT("AddHijriDate");
static const TCHAR c_szAddHijriDateTemp[] = TEXT("AddHijriDateTemp");
static const PTSTR c_szAddHijriDateValues[] =
{
  TEXT("AddHijriDate-2"),
  TEXT("AddHijriDate"),
  TEXT(""),
  TEXT("AddHijriDate+1"),
  TEXT("AddHijriDate+2")
};

static const TCHAR c_szTwoDigitYearKey[] = TEXT("Software\\Policies\\Microsoft\\Control Panel\\International\\Calendars\\TwoDigitYearMax");



//
//  Function Prototypes.
//

void Date_InitializeHijriDateComboBox(
    HWND hDlg);





////////////////////////////////////////////////////////////////////////////
//
//  Date_EnumerateDates
//
//  Enumerates the appropriate dates for the chosen calendar.
//
////////////////////////////////////////////////////////////////////////////

void Date_EnumerateDates(
    HWND hDlg,
    DWORD dwDateFlag)
{
    DWORD dwLocaleFlag;
    int nItemId;
    DWORD dwIndex;
    DWORD dwCalNum = 0;
    TCHAR szBuf[SIZE_128];
    HWND hCtrlDate;
    HWND hCtrlCal = GetDlgItem(hDlg, IDC_CALENDAR_TYPE);


    //
    //  Initialize variables according to the dwDateFlag parameter.
    //
    if (dwDateFlag == CAL_SSHORTDATE)
    {
        dwLocaleFlag = LOCALE_SSHORTDATE;
        nItemId = IDC_SHORT_DATE_STYLE;
    }
    else           // CAL_SLONGDATE
    {
        dwLocaleFlag = LOCALE_SLONGDATE;
        nItemId = IDC_LONG_DATE_STYLE;
    }
    hCtrlDate = GetDlgItem(hDlg, nItemId);

    //
    //  Initialize to reset the contents for the appropriate combo box.
    //
    if (!Set_List_Values(hDlg, nItemId, 0))
    {
        return;
    }

    //
    //  Reset the contents of the combo box.
    //
    ComboBox_ResetContent(hCtrlDate);

    //
    //  Get the currently selected calendar id.
    //
    dwIndex = ComboBox_GetCurSel(hCtrlCal);
    if (dwIndex != CB_ERR)
    {
        dwCalNum = (DWORD)ComboBox_GetItemData(hCtrlCal, dwIndex);
    }

    //
    //  Enumerate the dates for the currently selected calendar.
    //
    EnumCalendarInfo(EnumProc, UserLocaleID, dwCalNum, dwDateFlag);
    dwIndex = ComboBox_GetCount(hCtrlCal);
    if ((dwIndex == 0) || (dwIndex == CB_ERR))
    {
        EnumCalendarInfo(EnumProc, UserLocaleID, CAL_GREGORIAN, dwDateFlag);
    }

    //
    //  Add (if necesary) and select the current user setting in the
    //  combo box.
    //
    dwIndex = 0;
    if (GetLocaleInfo(UserLocaleID, dwLocaleFlag, szBuf, SIZE_128))
    {
        if ((dwIndex = ComboBox_FindStringExact(hCtrlDate, -1, szBuf)) == CB_ERR)
        {
            //
            //  Need to add this entry to the combo box.
            //
            Set_List_Values(0, 0, szBuf);
            if ((dwIndex = ComboBox_FindStringExact(hCtrlDate, -1, szBuf)) == CB_ERR)
            {
                dwIndex = 0;
            }
        }
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }
    Set_List_Values(0, nItemId, 0);

    Localize_Combobox_Styles(hDlg, nItemId, dwLocaleFlag);
    ComboBox_SetCurSel(hCtrlDate, dwIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_GetTwoDigitYearRangeFromPolicy
//
//  Read the two digit year from the Policy registry.
//
////////////////////////////////////////////////////////////////////////////

BOOL Date_GetTwoDigitYearRangeFromPolicy(
    CALID CalId)
{
    HKEY hKey;
    BYTE buf[MAX_PATH];
    TCHAR szCalId[MAX_PATH];
    DWORD dwResultLen = sizeof(buf), dwType;
    BOOL bRet = FALSE;


    //
    //  Convert CalendarId to a string.
    //
    //wsprintf(szCalId, TEXT("%d"), CalId);
    if(FAILED(StringCchPrintf(szCalId, ARRAYSIZE(szCalId), TEXT("%d"), CalId)))
    {
        return(FALSE);
    }

    if (RegOpenKey( HKEY_CURRENT_USER,
                    c_szTwoDigitYearKey,
                    &hKey ) == ERROR_SUCCESS)
    {
        if ((RegQueryValueEx( hKey,
                              szCalId,
                              NULL,
                              &dwType,
                              &buf[0],
                              &dwResultLen ) == ERROR_SUCCESS) &&
            (dwType == REG_SZ) &&
            (dwResultLen > 2))
        {
            bRet = TRUE;
        }

        RegCloseKey(hKey);
    }

    //
    //  Return the result.
    //
    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_GetTwoDigitYearRange
//
//  Fills in the two digit year range controls.
//
////////////////////////////////////////////////////////////////////////////

void Date_GetTwoDigitYearRange(
    HWND hDlg,
    CALID CalId)
{
    HWND hwndYearHigh = GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH);
    HWND hwndScroll = GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_ARROW);
    DWORD YearHigh, YearHighDefault;

    //
    //  Enable the high range control.
    //
    EnableWindow(hwndYearHigh, TRUE);
    EnableWindow(hwndScroll, TRUE);

    //
    //  Get the default two digit year upper boundary.
    //
    if (!GetCalendarInfo( LOCALE_USER_DEFAULT,
                          CalId,
                          CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER |
                            CAL_NOUSEROVERRIDE,
                          NULL,
                          0,
                          &YearHighDefault ))
    {
        YearHighDefault = 0;
    }

    //
    //  Disable the two digit year upper boundary control if it is
    //  enforced by a policy or if the default value is 99 or less.
    //
    if ((Date_GetTwoDigitYearRangeFromPolicy(CalId)) ||
        (YearHighDefault <= 99))
    {
        //
        //  Disable the two digit year max controls.
        //
        EnableWindow(hwndScroll, FALSE);
        EnableWindow(hwndYearHigh, FALSE);
    }

    //
    //  Get the two digit year upper boundary.  If the default is less
    //  than or equal to 99, then use the default value and ignore the
    //  registry.  This is done for calendars like the Japanese Era
    //  calendar where it doesn't make sense to have a sliding window.
    //
    if (YearHighDefault <= 99)
    {
        YearHigh = YearHighDefault;
    }
    else if (!GetCalendarInfo( LOCALE_USER_DEFAULT,
                               CalId,
                               CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                               NULL,
                               0,
                               &YearHigh ) ||
             (YearHigh < 99) || (YearHigh > 9999))
    {
        YearHigh = (YearHighDefault >= 99) ? YearHighDefault : 2029;
    }

    //
    //  Set the range on the controls.
    //
    SendMessage(hwndScroll, UDM_SETRANGE, 0, MAKELPARAM(9999, 99));
    SendMessage(hwndScroll, UDM_SETBUDDY, (WPARAM)hwndYearHigh, 0L);

    //
    //  Set the values of the controls.
    //
    SetDlgItemInt(hDlg, IDC_TWO_DIGIT_YEAR_LOW, (UINT)(YearHigh - 99), FALSE);
    SendMessage(hwndScroll, UDM_SETPOS, 0, MAKELONG((short)YearHigh, 0));
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_SetTwoDigitYearMax
//
//  Sets the two digit year max value in the registry.
//
////////////////////////////////////////////////////////////////////////////

BOOL Date_SetTwoDigitYearMax(
    HWND hDlg,
    CALID CalId)
{
    TCHAR szYear[SIZE_64];

    //
    //  Get the max year.
    //
    szYear[0] = 0;
    if (GetWindowText( GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH),
                       szYear,
                       SIZE_64 ) != 0)
    {
        //
        //  Set the two digit year upper boundary.
        //
        return (SetCalendarInfo( LOCALE_USER_DEFAULT,
                                 CalId,
                                 CAL_ITWODIGITYEARMAX,
                                 szYear ));
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_ChangeYear
//
//  Changes the lower bound based on the upper bound value.
//
////////////////////////////////////////////////////////////////////////////

void Date_ChangeYear(
    HWND hDlg)
{
    DWORD YearHigh;
    BOOL bSuccess;

    //
    //  Get the two digit year upper boundary.
    //
    YearHigh = GetDlgItemInt(hDlg, IDC_TWO_DIGIT_YEAR_HIGH, &bSuccess, FALSE);

    if ((!bSuccess) || (YearHigh < 99) || (YearHigh > 9999))
    {
        //
        //  Invalid value, so set the lower control to 0.
        //
        SetDlgItemInt(hDlg, IDC_TWO_DIGIT_YEAR_LOW, 0, FALSE);
    }
    else
    {
        //
        //  Set the value of the lower control.
        //
        SetDlgItemInt(hDlg, IDC_TWO_DIGIT_YEAR_LOW, (UINT)(YearHigh - 99), FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_DisplaySample
//
//  Updates the date samples.  It formats the date based on the user's
//  current locale settings.
//
////////////////////////////////////////////////////////////////////////////

void Date_DisplaySample(
    HWND hDlg)
{
    TCHAR szBuf[MAX_SAMPLE_SIZE];
    BOOL bNoError = TRUE;

    if (!bShowArabic) {
        // If user locale is not Arabic, make sure that the control for date samples are:
        //  * LTR reading orders for non-Hebrew locales
        //  * RTL reading orders for Hebrew locales.
        SetControlReadingOrder(bHebrewUI, GetDlgItem(hDlg, IDC_SAMPLE1));
        SetControlReadingOrder(bHebrewUI, GetDlgItem(hDlg, IDC_SAMPLE2));
    }

    // In Hebrew locale, we want to format the short date for left-to-right reading order.
    // If we make it right-to-left reading order, the Gregorian short date will display
    // in a complete different display order.  
    // The left-to-right reading order won't affect the Hebrew short date display.
    if (GetDateFormat( UserLocaleID,
                       (bHebrewUI ? DATE_LTRREADING :
                       (bShowRtL ? DATE_LTRREADING : 0)) | DATE_SHORTDATE,
                       NULL,
                       NULL,
                       szBuf,
                       MAX_SAMPLE_SIZE ))
    {
        SetDlgItemText(hDlg, IDC_SAMPLE1, szBuf);
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        bNoError = FALSE;
    }

    //
    //  Show or hide the Arabic info based on the current user locale id.
    //
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLELBL1A), bShowArabic ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLE1A), bShowArabic ? SW_SHOW : SW_HIDE);
    if (bShowArabic)
    {
        if (GetDateFormat( UserLocaleID,
                           DATE_RTLREADING | DATE_SHORTDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_SAMPLE1A, szBuf);
            SetDlgItemRTL(hDlg, IDC_SAMPLE1A);
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
            bNoError = FALSE;
        }
    }

    if (GetDateFormat( UserLocaleID,
                       (bHebrewUI ? DATE_RTLREADING :
                         (bShowRtL ? DATE_LTRREADING : 0)) | DATE_LONGDATE,
                       NULL,
                       NULL,
                       szBuf,
                       MAX_SAMPLE_SIZE ))
    {
        SetDlgItemText(hDlg, IDC_SAMPLE2, szBuf);
    }
    else if (bNoError)
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }

    //
    //  Show or hide the Right to left info based on the current user locale id.
    //
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLELBL2A), bShowArabic ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLE2A), bShowArabic ? SW_SHOW : SW_HIDE);
    if (bShowArabic)
    {
        if (GetDateFormat( UserLocaleID,
                           DATE_RTLREADING | DATE_LONGDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_SAMPLE2A, szBuf);
            SetDlgItemRTL(hDlg, IDC_SAMPLE2A);
        }
        else if (bNoError)
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_ClearValues
//
//  Reset each of the list boxes in the date property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Date_ClearValues(
    HWND hDlg)
{
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SHORT_DATE_STYLE));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_LONG_DATE_STYLE));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SEPARATOR));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_CALENDAR_TYPE));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_LOW));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH));
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_EnableHijriComboBox
//
//  Enables/Disables Show/Hides the Hijri date advance combo where necessary
//
////////////////////////////////////////////////////////////////////////////

void Date_EnableHijriComboBox(
    HWND hDlg,
    BOOL Status)
{
    HWND hAddHijriDateCB = GetDlgItem(hDlg, IDC_ADD_HIJRI_DATE);
    HWND hAddHijriDateText = GetDlgItem(hDlg, IDC_ADD_HIJRI_DATE_TEXT);
    INT iCount;

    //
    //  If the combo box is empty, then disable it.
    //
    iCount = (INT)SendMessage(hAddHijriDateCB, CB_GETCOUNT, 0L, 0L);
    if ((iCount == CB_ERR) || (iCount <= 0L))
    {
        Status = FALSE;
    }

    EnableWindow(hAddHijriDateCB, Status);
    ShowWindow(hAddHijriDateCB, Status ? SW_SHOW : SW_HIDE );

    EnableWindow(hAddHijriDateText, Status);
    ShowWindow(hAddHijriDateText, Status ? SW_SHOW : SW_HIDE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_SaveValues
//
//  Save values in the case that we need to restore them.
//
////////////////////////////////////////////////////////////////////////////

void Date_SaveValues()
{
    //
    //  Save registry values.
    //
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_ICALENDARTYPE,
                        sz_iCalendarType,
                        MAX_ICALTYPE + 1 ))
    {
        //_tcscpy(sz_iCalendarType, TEXT("1"));
        if(FAILED(StringCchCopy(sz_iCalendarType, MAX_ICALTYPE+1, TEXT("1"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SDATE,
                        sz_sDate,
                        MAX_SDATE + 1 ))
    {
        //_tcscpy(sz_sDate, TEXT("/"));
        if(FAILED(StringCchCopy(sz_sDate, MAX_SDATE+1, TEXT("/"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SLONGDATE,
                        sz_sLongDate,
                        MAX_SLONGDATE + 1 ))
    {
        //_tcscpy(sz_sLongDate, TEXT("dddd, MMMM dd, yyyy"));
        if(FAILED(StringCchCopy(sz_sLongDate, MAX_SLONGDATE+1, TEXT("dddd, MMMM dd, yyyy"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SSHORTDATE,
                        sz_sShortDate,
                        MAX_SSHORTDATE + 1 ))
    {
        //_tcscpy(sz_sShortDate, TEXT("M/d/yyyy"));
        if(FAILED(StringCchCopy(sz_sShortDate, MAX_SSHORTDATE+1, TEXT("M/d/yyyy"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_RestoreValues
//
////////////////////////////////////////////////////////////////////////////

void Date_RestoreValues()
{
    if (g_dwCustChange & Process_Date)
    {
        SetLocaleInfo(UserLocaleID, LOCALE_ICALENDARTYPE, sz_iCalendarType);
        SetLocaleInfo(UserLocaleID, LOCALE_SDATE,         sz_sDate);
        SetLocaleInfo(UserLocaleID, LOCALE_SLONGDATE,     sz_sLongDate);
        SetLocaleInfo(UserLocaleID, LOCALE_SSHORTDATE,    sz_sShortDate);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_SetValues
//
//  Initialize all of the controls in the date property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Date_SetValues(
    HWND hDlg)
{
    TCHAR szBuf[SIZE_128];
    int i, nItem;
    HWND hCtrl;
    LONG CalId;

    //
    //  Initialize the dropdown box for the current locale setting for the
    //  date separator.
    //
    DropDown_Use_Locale_Values(hDlg, LOCALE_SDATE, IDC_SEPARATOR);

    //
    //  Initialize and Lock function.  If it succeeds, call enum function to
    //  enumerate all possible values for the list box via a call to EnumProc.
    //  EnumProc will call Set_List_Values for each of the string values it
    //  receives.  When the enumeration of values is complete, call
    //  Set_List_Values to clear the dialog item specific data and to clear
    //  the lock on the function.  Perform this set of operations for:
    //  Calendar Type, Short Date Sytle, and Long Date Style.
    //
    if (Set_List_Values(hDlg, IDC_CALENDAR_TYPE, 0))
    {
        hCtrl = GetDlgItem(hDlg, IDC_CALENDAR_TYPE);
        EnumCalendarInfo(EnumProc, UserLocaleID, ENUM_ALL_CALENDARS, CAL_SCALNAME);
        Set_List_Values(0, IDC_CALENDAR_TYPE, 0);
        EnumCalendarInfo(EnumProc, UserLocaleID, ENUM_ALL_CALENDARS, CAL_ICALINTVALUE);
        Set_List_Values(0, IDC_CALENDAR_TYPE, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_ICALENDARTYPE, szBuf, SIZE_128))
        {
            TCHAR szBufTmp[SIZE_128] = {0};
            int iTmp = 0;
            LONG CalIdTmp;

            if( GetLocaleInfo( UserLocaleID,
                               LOCALE_ICALENDARTYPE | LOCALE_NOUSEROVERRIDE,
                               szBufTmp,
                               SIZE_128))
            {
                //
                //  Convert the id to a number.
                //
                CalId = Intl_StrToLong(szBuf);
                CalIdTmp = Intl_StrToLong(szBufTmp);

                //
                //  Search for calendars
                //
                nItem = ComboBox_GetCount(hCtrl);
                for (i = 0; i < nItem; i++)
                {
                    if (ComboBox_GetItemData(hCtrl, i) == CalId)
                    {
                        break;
                    }

                    if (ComboBox_GetItemData(hCtrl, i) == CalIdTmp)
                    {
                        iTmp = i;
                    }
                }

                //
                //  Look if we find something.
                //
                if (i < nItem)
                {
                    ComboBox_SetCurSel(hCtrl, i);
                }
                else
                {
                    CalId = CalIdTmp;
                    ComboBox_SetCurSel(hCtrl, iTmp);  // Zero or something else.
                }

                //
                //  Enable/disable the Add Hijri date check box.
                //
                Date_InitializeHijriDateComboBox(hDlg);
                Date_EnableHijriComboBox(hDlg, (CalId == CAL_HIJRI));

                //
                //  Set the two digit year range.
                //
                Date_GetTwoDigitYearRange(hDlg, (CALID)CalId);

                //
                //  Subtract 1 from calendar value because calendars are one
                //  based, not zero based like all other locale values.
                //
            }
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }

        //
        //  If more than one selection, enable dropdown box.
        //  Otherwise, disable it.
        //
        if (ComboBox_GetCount(hCtrl) > 1)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE_TEXT), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE), TRUE);
            ShowWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE_TEXT), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE), SW_SHOW);
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE_TEXT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE), FALSE);
            ShowWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CALENDAR_TYPE), SW_HIDE);
        }
    }
    Date_EnumerateDates(hDlg, CAL_SSHORTDATE);
    Date_EnumerateDates(hDlg, CAL_SLONGDATE);

    //
    //  Display the current sample that represents all of the locale settings.
    //
    Date_DisplaySample(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_SetHijriDate
//
//  Saves the Hijri date advance amount to the registry.
//
////////////////////////////////////////////////////////////////////////////

void Date_SetHijriDate(
    HWND hHijriComboBox)
{
    HKEY hKey;
    INT iIndex;

    //
    //  Get the string index to set.
    //
    iIndex = (INT)SendMessage(hHijriComboBox, CB_GETCURSEL, 0L, 0L);

    if (iIndex == CB_ERR)
    {
        return;
    }

    iIndex = (INT)SendMessage(hHijriComboBox, CB_GETITEMDATA, (WPARAM)iIndex, 0L);
    if (iIndex != CB_ERR)
    {
        if (RegOpenKeyEx( HKEY_CURRENT_USER,
                          c_szInternational,
                          0,
                          KEY_READ | KEY_WRITE,
                          &hKey ) == ERROR_SUCCESS)
        {
            RegSetValueEx( hKey,
                           c_szAddHijriDate,
                           0,
                           REG_SZ,
                           (LPBYTE)c_szAddHijriDateValues[iIndex],
                           (lstrlen(c_szAddHijriDateValues[iIndex]) + 1) * sizeof(TCHAR) );

            RegCloseKey(hKey);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_ApplySettings
//
//  For every control that has changed (that affects the Locale settings),
//  call Set_Locale_Values to update the user locale information.  Notify
//  the parent of changes and reset the change flag stored in the property
//  sheet page structure appropriately.  Redisplay the date sample if
//  bRedisplay is TRUE.
//
////////////////////////////////////////////////////////////////////////////

BOOL Date_ApplySettings(
    HWND hDlg,
    BOOL bRedisplay)
{
    TCHAR szBuf[SIZE_128];
    CALID CalId = 0;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;
    HWND hwndYearHigh = GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH);

    if (Changes & DC_ShortFmt)
    {
        //
        //  szNLS_ShortDate is set in Date_ValidatePPS.
        //
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SSHORTDATE,
                                IDC_SHORT_DATE_STYLE,
                                TEXT("sShortDate"),
                                FALSE,
                                0,
                                0,
                                szNLS_ShortDate ))
        {
            return (FALSE);
        }

        //
        //  If the date separator field has also been changed by the user,
        //  then don't update now.  It will be updated below.
        //
        if (!(Changes & DC_SDate))
        {
            //
            //  Since the short date style changed, reset date separator
            //  list box.
            //
            ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SEPARATOR));
            DropDown_Use_Locale_Values(hDlg, LOCALE_SDATE, IDC_SEPARATOR);
            if (!Set_Locale_Values( hDlg,
                                    LOCALE_SDATE,
                                    IDC_SEPARATOR,
                                    TEXT("sDate"),
                                    FALSE,
                                    0,
                                    0,
                                    NULL ))
            {
                return (FALSE);
            }
        }
    }
    if (Changes & DC_LongFmt)
    {
        //
        //  szNLS_LongDate is set in Date_ValidatePPS.
        //
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SLONGDATE,
                                IDC_LONG_DATE_STYLE,
                                TEXT("sLongDate"),
                                FALSE,
                                0,
                                0,
                                szNLS_LongDate ))
        {
            return (FALSE);
        }
    }
    if (Changes & DC_SDate)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SDATE,
                                IDC_SEPARATOR,
                                TEXT("sDate"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }

        //
        //  Since the date separator changed, reset the short date style
        //  list box.
        //
        Date_EnumerateDates(hDlg, CAL_SSHORTDATE);
    }
    if (Changes & DC_Calendar)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_ICALENDARTYPE,
                                IDC_CALENDAR_TYPE,
                                0,
                                TRUE,
                                1,
                                0,
                                NULL ))
        {
            return (FALSE);
        }

        if (GetLocaleInfo(UserLocaleID, LOCALE_ICALENDARTYPE, szBuf, SIZE_128))
        {
            CalId = Intl_StrToLong(szBuf);
            Date_InitializeHijriDateComboBox(hDlg);
            Date_EnableHijriComboBox(hDlg, (CalId == CAL_HIJRI));
        }
    }

    if (Changes & DC_Arabic_Calendar)
    {
        Date_SetHijriDate( GetDlgItem(hDlg, IDC_ADD_HIJRI_DATE) );
    }

    if (Changes & DC_TwoDigitYearMax)
    {
        if (CalId == 0)
        {
            HWND hCtrl = GetDlgItem(hDlg, IDC_CALENDAR_TYPE);
            int index;

            if ((index = ComboBox_GetCurSel(hCtrl)) == CB_ERR)
            {
                if (GetLocaleInfo( UserLocaleID,
                                   LOCALE_ICALENDARTYPE | LOCALE_NOUSEROVERRIDE,
                                   szBuf,
                                   SIZE_128))
                {
                    CalId = Intl_StrToLong(szBuf);
                }
                else
                {
                    return (FALSE);
                }
            }
            else
            {
                CalId = (CALID)ComboBox_GetItemData(hCtrl, index);
            }
        }
        if (!Date_SetTwoDigitYearMax(hDlg, CalId))
        {
            //
            //  Make sure that the API failed due to a reason other than
            //  the upper year two digit max is <= 99. This can easily
            //  be checked by seeing if the control is enabled or not.
            //
            if (IsWindowEnabled(hwndYearHigh))
            {
                return (FALSE);
            }
        }
    }

    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    lpPropSheet->lParam = DC_EverChg;

    //
    //  Display the current sample that represents all of the locale settings.
    //
    if (bRedisplay)
    {
        Date_DisplaySample(hDlg);
    }

    //
    //  Changes made in the second level.
    //
    if (Changes)
    {
        g_dwCustChange |= Process_Date;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Date_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= DC_EverChg)
    {
        return (TRUE);
    }

    //
    //  If the date separator has changed, ensure that there are no digits
    //  and no invalid characters contained in the new separator.
    //
    if (Changes & DC_SDate &&
        Item_Has_Digits_Or_Invalid_Chars( hDlg,
                                          IDC_SEPARATOR,
                                          FALSE,
                                          szInvalidSDate ))
    {
        No_Numerals_Error(hDlg, IDC_SEPARATOR, IDS_LOCALE_DATE_SEP);
        return (FALSE);
    }

    //
    //  If the short date style has changed, ensure that there are only
    //  characters in this set " dHhMmsty,-./:;\", the separator string,
    //  and text enclosed in single quotes.
    //
    if (Changes & DC_ShortFmt)
    {
        if (NLSize_Style( hDlg,
                          IDC_SHORT_DATE_STYLE,
                          szNLS_ShortDate,
                          LOCALE_SSHORTDATE ) ||
            Item_Check_Invalid_Chars( hDlg,
                                      szNLS_ShortDate,
                                      szSDateChars,
                                      IDC_SEPARATOR,
                                      FALSE,
                                      szSDCaseSwap,
                                      IDC_SHORT_DATE_STYLE ))
        {
            Invalid_Chars_Error(hDlg, IDC_SHORT_DATE_STYLE, IDS_LOCALE_SDATE);
            return (FALSE);
        }
    }

    //
    //  If the long date style has changed, ensure that there are only
    //  characters in this set " dgHhMmsty,-./:;\", the separator string,
    //  and text enclosed in single quotes.
    //
    if (Changes & DC_LongFmt)
    {
        if (NLSize_Style( hDlg,
                          IDC_LONG_DATE_STYLE,
                          szNLS_LongDate,
                          LOCALE_SLONGDATE ) ||
            Item_Check_Invalid_Chars( hDlg,
                                      szNLS_LongDate,
                                      szLDateChars,
                                      IDC_SEPARATOR,
                                      FALSE,
                                      szLDCaseSwap,
                                      IDC_LONG_DATE_STYLE ))
        {
            Invalid_Chars_Error(hDlg, IDC_LONG_DATE_STYLE, IDS_LOCALE_LDATE);
            return (FALSE);
        }
    }

    //
    //  If the two digit year has changed, make sure the value is between
    //  99 and 9999 (if the window is still enabled).
    //
    if (Changes & DC_TwoDigitYearMax)
    {
        DWORD YearHigh;
        BOOL bSuccess;

        if (IsWindowEnabled(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH)))
        {
            YearHigh = GetDlgItemInt( hDlg,
                                      IDC_TWO_DIGIT_YEAR_HIGH,
                                      &bSuccess,
                                      FALSE );

            if ((!bSuccess) || (YearHigh < 99) || (YearHigh > 9999))
            {
                TCHAR szBuf[SIZE_128];

                LoadString(hInstance, IDS_LOCALE_YEAR_ERROR, szBuf, SIZE_128);
                MessageBox(hDlg, szBuf, NULL, MB_OK | MB_ICONINFORMATION);
                SetFocus(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH));
                return (FALSE);
            }
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_InitializeHijriDateComboBox
//
//  Initialize the HijriDate advance combo box.
//
////////////////////////////////////////////////////////////////////////////

void Date_InitializeHijriDateComboBox(
    HWND hDlg)
{
    HWND hHijriDate = GetDlgItem(hDlg, IDC_ADD_HIJRI_DATE);
    HKEY hKey;
    TCHAR szBuf[128];
    TCHAR szCurrentValue[16];   // Max size ever needed should be 15 characters including the NULL
    INT iIndex;
    DWORD dwCtr, dwNumEntries, DataLen;


    //
    //  Clear contents.
    //
    SendMessage( hHijriDate,
                 CB_RESETCONTENT,
                 0L,
                 0L);

    if (RegOpenKeyEx( HKEY_CURRENT_USER,
                      c_szInternational,
                      0,
                      KEY_READ | KEY_WRITE,
                      &hKey ) == ERROR_SUCCESS)
    {
        //
        //  Read the default/current value.
        //

        // Use the byte count, the API expects that even for Unicode strings
        DataLen = sizeof(szCurrentValue);

        if (RegQueryValueEx( hKey,
                             c_szAddHijriDate,
                             NULL,
                             NULL,
                             (LPBYTE)szCurrentValue,
                             &DataLen ) != ERROR_SUCCESS)
        {
            szCurrentValue[0] = TEXT('\0');
        }

        dwNumEntries = (ARRAYSIZE(c_szAddHijriDateValues));
        for (dwCtr = 0; dwCtr < dwNumEntries; dwCtr++)
        {
            //
            //  Fill the combo box.
            //
            if (RegSetValueEx( hKey,
                               c_szAddHijriDateTemp,
                               0,
                               REG_SZ,
                               (LPBYTE)c_szAddHijriDateValues[dwCtr],
                               (lstrlen(c_szAddHijriDateValues[dwCtr]) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS)
            {
                //
                //  0x80000000 is a private flag to make GetDateFormat read
                //  the HijriDate setting from the temp reg value.
                //
                if (GetDateFormat( MAKELCID(MAKELANGID(LANG_ARABIC,
                                                       SUBLANG_DEFAULT),
                                            SORT_DEFAULT),
                                   DATE_ADDHIJRIDATETEMP | DATE_LONGDATE |
                                     DATE_RTLREADING,
                                   NULL,
                                   NULL,
                                   szBuf,
                                   ARRAYSIZE(szBuf)))
                {
                    iIndex = (INT)SendMessage(hHijriDate, CB_ADDSTRING, 0L, (LPARAM)szBuf);
                    if (iIndex != CB_ERR)
                    {
                        SendMessage(hHijriDate, CB_SETITEMDATA, iIndex, (LPARAM)dwCtr);

                        if (!lstrcmp(szCurrentValue, c_szAddHijriDateValues[dwCtr]))
                        {
                            SendMessage(hHijriDate, CB_SETCURSEL, iIndex, 0L);
                        }
                    }
                }
            }
        }

        //
        //  Delete the value after we're done.
        //
        RegDeleteValue(hKey, c_szAddHijriDateTemp);

        RegCloseKey(hKey);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Date_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Date_SetValues with the property
//  sheet handle and the value TRUE (to indicate that the Positive Value
//  button should also be initialized) to initialize all of the property
//  sheet controls.
//
////////////////////////////////////////////////////////////////////////////

void Date_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    //
    //  The lParam holds a pointer to the property sheet page, save it
    //  for later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    //
    //  Set the values.
    //
    Date_SetValues(hDlg);
    szNLS_ShortDate[0] = szNLS_LongDate[0] = 0;

    ComboBox_LimitText(GetDlgItem(hDlg, IDC_SEPARATOR),        MAX_SDATE);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_SHORT_DATE_STYLE), MAX_FORMAT);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_LONG_DATE_STYLE),  MAX_FORMAT);

    Edit_LimitText(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_LOW),   MAX_YEAR);
    Edit_LimitText(GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH),  MAX_YEAR);

    //
    //  Set the Add Hijri Date combo box appropriately.
    //
    if (bShowArabic)
    {
        Date_InitializeHijriDateComboBox(hDlg);
    }

    //
    //  Make sure the Apply button is off.
    //
    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    if (lParam)
    {
        ((LPPROPSHEETPAGE)lParam)->lParam = DC_EverChg;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DateDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DateDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    DWORD dwIndex;
    HWND hCtrl;

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            Date_InitPropSheet(hDlg, lParam);
            Date_SaveValues();
            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aDateHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aDateHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (!lpPropSheet)
            {
                break;
            }

            switch ( LOWORD(wParam) )
            {
                case ( IDC_SHORT_DATE_STYLE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= DC_ShortFmt;
                    }
                    break;
                }
                case ( IDC_LONG_DATE_STYLE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= DC_LongFmt;
                    }
                    break;
                }
                case ( IDC_SEPARATOR ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= DC_SDate;
                    }
                    break;
                }
                case ( IDC_CALENDAR_TYPE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= DC_Calendar;

                        hCtrl = GetDlgItem(hDlg, IDC_CALENDAR_TYPE);
                        dwIndex = ComboBox_GetCurSel(hCtrl);
                        if (dwIndex != CB_ERR)
                        {
                            dwIndex = (DWORD)ComboBox_GetItemData(hCtrl, dwIndex);
                            Date_InitializeHijriDateComboBox(hDlg);
                            Date_EnableHijriComboBox(hDlg, (dwIndex == CAL_HIJRI) );
                            Date_GetTwoDigitYearRange(hDlg, (CALID)dwIndex);
                        }

                        Date_EnumerateDates(hDlg, CAL_SSHORTDATE);
                        Date_EnumerateDates(hDlg, CAL_SLONGDATE);
                    }
                    break;
                }
                case ( IDC_ADD_HIJRI_DATE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= DC_Arabic_Calendar;
                    }
                    break;
                }
                case ( IDC_TWO_DIGIT_YEAR_HIGH ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        Date_ChangeYear(hDlg);
                        lpPropSheet->lParam |= DC_TwoDigitYearMax;
                    }
                    break;
                }
            }

            //
            //  Turn on ApplyNow button.
            //
            if (lpPropSheet->lParam > DC_EverChg)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }

            break;
        }
        case ( WM_NOTIFY ) :
        {
            lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Date)
                    {
                        Verified_Regional_Chg &= ~Process_Date;
                        Date_ClearValues(hDlg);
                        Date_SetValues(hDlg);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                   DWLP_MSGRESULT,
                                   !Date_ValidatePPS( hDlg,
                                                      lpPropSheet->lParam ) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Date_ApplySettings(hDlg, TRUE))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                        //
                        //  Zero out the DC_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                       DWLP_MSGRESULT,
                                       PSNRET_INVALID_NOCHANGEPAGE );
                    }

                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_VSCROLL ) :
        {
            if ((GET_WM_VSCROLL_CODE(wParam, lParam) == SB_ENDSCROLL) &&
                ((HWND)SendMessage( GET_WM_VSCROLL_HWND(wParam, lParam),
                                   UDM_GETBUDDY,
                                   0,
                                   0L ) == GetDlgItem(hDlg, IDC_TWO_DIGIT_YEAR_HIGH)))
            {
                DWORD YearHigh;

                //
                //  Get the high year.
                //
                YearHigh = (DWORD)SendDlgItemMessage( hDlg,
                                                      IDC_TWO_DIGIT_YEAR_ARROW,
                                                      UDM_GETPOS,
                                                      0,
                                                      0L );

                //
                //  Set the low year based on the high year.
                //
                SetDlgItemInt( hDlg,
                               IDC_TWO_DIGIT_YEAR_LOW,
                               (UINT)(YearHigh - 99),
                               FALSE );

                //
                //  Mark it as changed.
                //
                lpPropSheet->lParam |= DC_TwoDigitYearMax;

                //
                //  Turn on ApplyNow button.
                //
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }

            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\intl\intlhlp.h ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    intlhlp.h

Abstract:

    This module contains the help context ids for the Regional Options
    applet.

Revision History:

--*/



//
//  From help.h.
//
#define NO_HELP               ((DWORD) -1)  // Disables Help for a control

#define IDH_COMM_GROUPBOX              28548



//
//  Values must be in the range 3300 - 3499.
//

// General tab
#define IDH_INTL_GEN_CULTURE                3302
#define IDH_INTL_GEN_REGION                 3303
#define IDH_INTL_GEN_CUSTOMIZE              3304
#define IDH_INTL_GEN_SAMPLE                 3305

// Language tab
#define IDH_INTL_LANG_UI_LANGUAGE           3311
#define IDH_INTL_LANG_CHANGE                3312
#define IDH_INTL_LANG_INSTALL               3313

// Advanced tab
#define IDH_INTL_ADV_SYSTEM_LOCALE          3321
#define IDH_INTL_ADV_CODEPAGES              3322
#define IDH_INTL_ADV_CHANGE                 3323

// Time tab
#define IDH_INTL_TIME_SAMPLE                3331
#define IDH_INTL_TIME_AMSYMBOL              3332
#define IDH_INTL_TIME_PMSYMBOL              3333
#define IDH_INTL_TIME_SEPARATOR             3334
#define IDH_INTL_TIME_FORMAT_NOTATION       3335
#define IDH_INTL_TIME_SAMPLE_ARABIC         3336
#define IDH_INTL_TIME_FORMAT                3337

// Number tab
#define IDH_INTL_NUM_POSVALUE               3341
#define IDH_INTL_NUM_NEGVALUE               3342
#define IDH_INTL_NUM_DECSYMBOL              3343
#define IDH_INTL_NUM_DIGITSAFTRDEC          3344
#define IDH_INTL_NUM_DIGITGRPSYMBOL         3345
#define IDH_INTL_NUM_DIGITSINGRP            3346
#define IDH_INTL_NUM_NEGSIGNSYMBOL          3347
#define IDH_INTL_NUM_DISPLEADZEROS          3348
#define IDH_INTL_NUM_NEGNUMFORMAT           3349
#define IDH_INTL_NUM_MEASUREMNTSYS          3350
#define IDH_INTL_NUM_LISTSEPARATOR          3351
#define IDH_INTL_NUM_POSVALUE_ARABIC        3352
#define IDH_INTL_NUM_NEGVALUE_ARABIC        3353
#define IDH_INTL_NUM_NATIVE_DIGITS          3354
#define IDH_INTL_NUM_DIGIT_SUBST            3355

// Currency tab
#define IDH_INTL_CURR_POSVALUE              3361
#define IDH_INTL_CURR_NEGVALUE              3362
#define IDH_INTL_CURR_SYMBOL                3363
#define IDH_INTL_CURR_POSOFSYMBOL           3364
#define IDH_INTL_CURR_NEGNUMFMT             3365
#define IDH_INTL_CURR_DECSYMBOL             3366
#define IDH_INTL_CURR_DIGITSAFTRDEC         3367
#define IDH_INTL_CURR_DIGITGRPSYMBOL        3368
#define IDH_INTL_CURR_DIGITSINGRP           3369

// Date tab
#define IDH_INTL_DATE_SHORTSAMPLE           3370
#define IDH_INTL_DATE_SEPARATOR             3371
#define IDH_INTL_DATE_LONGSAMPLE            3372
#define IDH_INTL_DATE_LONGSTYLE             3373
#define IDH_INTL_DATE_SHORTSTYLE            3374
#define IDH_INTL_DATE_CALENDARTYPE          3375
#define IDH_INTL_DATE_SHORTSAMPLE_ARABIC    3376
#define IDH_INTL_DATE_LONGSAMPLE_ARABIC     3377
#define IDH_INTL_DATE_ADD_HIJRI_DATE        3378
#define IDH_INTL_DATE_TWO_DIGIT_YEAR        3379

// Sorting
#define IDH_INTL_SORT_SORTING               3381
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\intl\intl.h ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    intl.h

Abstract:

    This module contains the header information for the Regional Options
    applet.

Revision History:

--*/


#ifndef _INTL_H_
#define _INTL_H_



//
//  Include Files.
//

#include <windows.h>
#include <prsht.h>
#include <prshtp.h>
#include <shellapi.h>
#include <setupapi.h>
#include <winnls.h>
#include "intlid.h"
#include "util.h"
#include <shlwapi.h>


//
//  Enumeration
//
enum LANGCOLLECTION{
    BASIC_COLLECTION,
    COMPLEX_COLLECTION,
    CJK_COLLECTION,
};

//
//  Constant Declarations.
//

#define RMI_PRIMARY          (0x1)     // this should win in event of conflict

#define ARRAYSIZE(a)         (sizeof(a) / sizeof(a[0]))

#define US_LOCALE                (MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
#define LANG_SPANISH_TRADITIONAL (MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH))
#define LANG_SPANISH_INTL        (MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_MODERN))
#define LCID_SPANISH_TRADITIONAL (MAKELCID(LANG_SPANISH_TRADITIONAL, SORT_DEFAULT))
#define LCID_SPANISH_INTL        (MAKELCID(LANG_SPANISH_INTL, SORT_DEFAULT))

#define ML_ORIG_INSTALLED    0x0001
#define ML_PERMANENT         0x0002
#define ML_INSTALL           0x0004
#define ML_REMOVE            0x0008
#define ML_DEFAULT           0x0010
#define ML_DISABLE           0x0020

#define ML_STATIC            (ML_PERMANENT | ML_DEFAULT | ML_DISABLE)


//
//  Used in string and other array declarations.
//
#define cInt_Str             10        // length of the array of int strings
#define SIZE_64              64        // frequently used buffer size
#define SIZE_128             128       // frequently used buffer size
#define SIZE_300             300       // frequently used buffer size
#define MAX_SAMPLE_SIZE      100       // limit on Sample text for display


//
//  For the indicator on the tray.
//
#define IDM_NEWSHELL         249


//
//  Character constants.
//
#define CHAR_SML_D           TEXT('d')
#define CHAR_CAP_M           TEXT('M')
#define CHAR_SML_Y           TEXT('y')
#define CHAR_SML_G           TEXT('g')

#define CHAR_SML_H           TEXT('h')
#define CHAR_CAP_H           TEXT('H')
#define CHAR_SML_M           TEXT('m')
#define CHAR_SML_S           TEXT('s')
#define CHAR_SML_T           TEXT('t')

#define CHAR_NULL            TEXT('\0')
#define CHAR_QUOTE           TEXT('\'')
#define CHAR_SPACE           TEXT(' ')
#define CHAR_COMMA           TEXT(',')
#define CHAR_SEMICOLON       TEXT(';')
#define CHAR_COLON           TEXT(':')
#define CHAR_STAR            TEXT('*')
#define CHAR_HYPHEN          TEXT('-')
#define CHAR_DECIMAL         TEXT('.')
#define CHAR_INTL_CURRENCY   TEXT('')
#define CHAR_GRAVE           TEXT('`')

#define CHAR_ZERO            TEXT('0')
#define CHAR_NINE            TEXT('9')


//
//  Setup command line switch values.
//
#define SETUP_SWITCH_NONE    0x0000
#define SETUP_SWITCH_R       0x0001
#define SETUP_SWITCH_I       0x0002
#define SETUP_SWITCH_S       0x0004


//
//  Flags to assist in updating property sheet pages once the regional locale
//  setting has changed.  As pages are updated, their process flag value is
//  deleted from the Verified_Regional_Chg variable.
//
#define INTL_ALL_CHG         0x00ff    // change affects all pages
#define INTL_CHG             0x001f    // change affects customize pages

#define Process_Num          0x0001    // number page not yet updated
#define Process_Curr         0x0002    // currency page not yet updated
#define Process_Time         0x0004    // time page not yet updated
#define Process_Date         0x0008    // date page not yet updated
#define Process_Sorting      0x0010    // sorting page not yet updated

#define Process_Regional     0x0020    // regional options page not yet updated
#define Process_Advanced     0x0040    // advanced page not yet updated
#define Process_Languages    0x0080    // languages page not yet updated


//
//  Each of these change flags will be used to update the appropriate property
//  sheet pages change word when their associated combobox notifies the
//  property sheet of a change.  The change values are used to determine which
//  locale settings must be updated.
//

//
//  Region Change.
//
#define RC_EverChg           0x0001
#define RC_UserRegion        0x0002
#define RC_UserLocale        0x0004

//
//  Advanced Change
//
#define AD_EverChg           0x0001
#define AD_SystemLocale      0x0002
#define AD_CodePages         0x0004
#define AD_DefaultUser       0x0008

//
//  Number Change.
//
#define NC_EverChg           0x0001
#define NC_DSymbol           0x0002
#define NC_NSign             0x0004
#define NC_SList             0x0008
#define NC_SThousand         0x0010
#define NC_IDigits           0x0020
#define NC_DGroup            0x0040
#define NC_LZero             0x0080
#define NC_NegFmt            0x0100
#define NC_Measure           0x0200
#define NC_NativeDigits      0x0400
#define NC_DigitSubst        0x0800

//
//  Currency Change.
//
#define CC_EverChg           0x0001
#define CC_SCurrency         0x0002
#define CC_CurrSymPos        0x0004
#define CC_NegCurrFmt        0x0008
#define CC_SMonDec           0x0010
#define CC_ICurrDigits       0x0020
#define CC_SMonThousand      0x0040
#define CC_DMonGroup         0x0080

//
//  Time Change.
//
#define TC_EverChg           0x0001
#define TC_1159              0x0002
#define TC_2359              0x0004
#define TC_STime             0x0008
#define TC_TimeFmt           0x0010
#define TC_AllChg            0x001F
#define TC_FullTime          0x0031

//
//  Date Change.
//
#define DC_EverChg           0x0001
#define DC_ShortFmt          0x0002
#define DC_LongFmt           0x0004
#define DC_SDate             0x0008
#define DC_Calendar          0x0010
#define DC_Arabic_Calendar   0x0020
#define DC_TwoDigitYearMax   0x0040

//
//  Sorting Change.
//
#define SC_EverChg           0x0001
#define SC_Sorting           0x0002

//
//  Language Change
//
#define LG_EverChg           0x0001
#define LG_UILanguage        0x0002
#define LG_Change            0x0004
#define LG_Complex           0x0008
#define LG_CJK               0x0010


//
//  Global Variables.
//  Data that is shared betweeen the property sheets.
//

extern BOOL g_bCDROM;               // if setup from a CD-ROM

extern BOOL  g_bAdmin_Privileges;   // Admin privileges
extern DWORD g_dwLastSorting;       // index of last sorting setting in combo box
extern DWORD g_dwCurSorting;        // index of current sorting setting in combo box
extern BOOL  g_bCustomize;          // in customize mode or second level tabs
extern DWORD g_dwCustChange;        // change made at the second level
extern BOOL  g_bDefaultUser;        // in default user settings
extern BOOL  g_bShowSortingTab;     // show the sorting tab or not
extern BOOL  g_bInstallComplex;     // Complex scripts language groups installation requested
extern BOOL  g_bInstallCJK;         // CJK language groups installation requested

extern TCHAR aInt_Str[cInt_Str][3]; // cInt_Str # of elements of int strings
extern TCHAR szSample_Number[];     // used for currency and number samples
extern TCHAR szNegSample_Number[];  // used for currency and number samples
extern TCHAR szTimeChars[];         // valid time characters
extern TCHAR szTCaseSwap[];         // invalid time chars to change case => valid
extern TCHAR szTLetters[];          // time NLS chars
extern TCHAR szSDateChars[];        // valid short date characters
extern TCHAR szSDCaseSwap[];        // invalid SDate chars to change case => valid
extern TCHAR szSDLetters[];         // short date NLS chars
extern TCHAR szLDateChars[];        // valid long date characters
extern TCHAR szLDCaseSwap[];        // invalid LDate chars to change case => valid
extern TCHAR szLDLetters[];         // long date NLS chars
extern TCHAR szStyleH[];            // date and time style H equivalent
extern TCHAR szStyleh[];            // date and time style h equivalent
extern TCHAR szStyleM[];            // date and time style M equivalent
extern TCHAR szStylem[];            // date and time style m equivalent
extern TCHAR szStyles[];            // date and time style s equivalent
extern TCHAR szStylet[];            // date and time style t equivalent
extern TCHAR szStyled[];            // date and time style d equivalent
extern TCHAR szStyley[];            // date and time style y equivalent
extern TCHAR szLocaleGetError[];    // shared locale info get error
extern TCHAR szIntl[];              // intl string

extern TCHAR szInvalidSDate[];      // invalid chars for date separator
extern TCHAR szInvalidSTime[];      // invalid chars for time separator

extern HINSTANCE hInstance;         // library instance
extern int Verified_Regional_Chg;   // used to determine when to verify
                                    //  regional changes in all prop sheet pgs
extern int RegionalChgState;        // used to determine when a page have changed
extern BOOL Styles_Localized;       // indicate whether or not style must be
                                    //  translated between NLS and local formats
extern LCID UserLocaleID;           // user locale
extern LCID SysLocaleID;            // system locale
extern LCID RegUserLocaleID;        // user locale stored in the registry
extern LCID RegSysLocaleID;         // system locale stored in the registry
extern BOOL bShowRtL;               // indicate if RTL date samples should be shown
extern BOOL bShowArabic;            // indicate if the other Arabic specific stuff should be shown
extern BOOL bHebrewUI;              // indicate if the UI language is Hebrew
extern BOOL bLPKInstalled;          // if LPK is installed
extern TCHAR szSetupSourcePath[];   // buffer to hold setup source string
extern LPTSTR pSetupSourcePath;     // pointer to setup source string buffer
extern TCHAR szSetupSourcePathWithArchitecture[]; // buffer to hold setup source string with architecture-specific extension.
extern LPTSTR pSetupSourcePathWithArchitecture;   // pointer to setup source string buffer with architecture-specific extension.


//
//  Global Variables.
//
static TCHAR szLayoutPath[]    = TEXT("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts");
static TCHAR szKbdPreloadKey[] = TEXT("Keyboard Layout\\Preload");
static TCHAR szKbdSubstKey[]   = TEXT("Keyboard Layout\\Substitutes");
static TCHAR szKbdToggleKey[]  = TEXT("Keyboard Layout\\Toggle");
static TCHAR szKbdPreloadKey_DefUser[] = TEXT(".DEFAULT\\Keyboard Layout\\Preload");
static TCHAR szKbdSubstKey_DefUser[]   = TEXT(".DEFAULT\\Keyboard Layout\\Substitutes");
static TCHAR szKbdToggleKey_DefUser[]  = TEXT(".DEFAULT\\Keyboard Layout\\Toggle");
static TCHAR szInternat[]      = TEXT("internat.exe");
static char  szInternatA[]     = "internat.exe";


extern int g_bSetupCase;    // See Intl_IsSetupMode for info on possible values
extern BOOL g_bLog;
extern BOOL g_bProgressBarDisplay;
extern BOOL g_bDisableSetupDialog;
extern BOOL g_bSettingsChanged;
extern BOOL g_bUnttendMode;
extern BOOL g_bMatchUIFont;


extern const TCHAR c_szInstalledLocales[];
extern const TCHAR c_szLanguageGroups[];
extern const TCHAR c_szLIPInstalled[];
extern const TCHAR c_szMUILanguages[];
extern const TCHAR c_szFontSubstitute[];
extern const TCHAR c_szGreFontInitialize[];
extern const TCHAR c_szSetupKey[];
extern const TCHAR c_szCPanelIntl[];
extern const TCHAR c_szCPanelIntl_DefUser[];
extern const TCHAR c_szCtfmon[];
extern const TCHAR c_szCtfmon_DefUser[];
extern const TCHAR c_szCPanelDesktop[];
extern const TCHAR c_szCPanelDesktop_DefUser[];
extern const TCHAR c_szKbdLayouts[];
extern const TCHAR c_szKbdLayouts_DefUser[];
extern const TCHAR c_szInputMethod[];
extern const TCHAR c_szInputMethod_DefUser[];
extern const TCHAR c_szInputTips[];
extern const TCHAR c_szInputTips_DefUser[];
extern const TCHAR c_szMUIPolicyKeyPath[];
extern const TCHAR c_szMUIValue[];
extern const TCHAR c_szIntlRun[];
extern const TCHAR c_szSysocmgr[];

extern TCHAR szIntlInf[];
extern TCHAR szHelpFile[];
extern TCHAR szFontSubstitute[];
extern TCHAR szLocaleListPrefix[];
extern TCHAR szLGBasicInstall[];
extern TCHAR szLGComplexInstall[];
extern TCHAR szLGComplexRemove[];
extern TCHAR szLGExtInstall[];
extern TCHAR szLGExtRemove[];
extern TCHAR szCPInstallPrefix[];
extern TCHAR szCPRemovePrefix[];
extern TCHAR szKbdLayoutIds[];
extern TCHAR szInputLibrary[];       // Name of the library that contain the text input dlg

extern TCHAR szUIFontSubstitute[];
extern TCHAR szSetupInProgress[];
extern TCHAR szMiniSetupInProgress[];
extern TCHAR szSetupUpgrade[];
extern TCHAR szMultiUILanguageId[];
extern TCHAR szMUILangPending[];
extern TCHAR szCtfmonValue[];

extern TCHAR szRegionalSettings[];
extern TCHAR szLanguageGroup[];
extern TCHAR szLanguage[];
extern TCHAR szSystemLocale[];
extern TCHAR szUserLocale[];
extern TCHAR szInputLocale[];
extern TCHAR szMUILanguage[];
extern TCHAR szUserLocale_DefUser[];
extern TCHAR szInputLocale_DefUser[];
extern TCHAR szMUILanguage_DefUSer[];

extern HINF g_hIntlInf;

extern LPLANGUAGEGROUP pLanguageGroups;
extern LPCODEPAGE pCodePages;

extern int g_NumAltSorts;
extern HANDLE hAltSorts;
extern LPDWORD pAltSorts;

extern HINSTANCE hInputDLL;
extern BOOL (*pfnInstallInputLayout)(LCID, DWORD, BOOL, HKL, BOOL, BOOL);
extern BOOL (*pfnUninstallInputLayout)(LCID, DWORD, BOOL);

//
//  Language group of UI languages.
//
extern UILANGUAGEGROUP UILangGroup;




//
//  Function Prototypes.
//

//
//  Callback functions for each of the propety sheet pages.
//
INT_PTR CALLBACK
GeneralDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
InputLocaleDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
LanguageDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
AdvancedDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
NumberDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
CurrencyDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
TimeDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
DateDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
SortingDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

//
//  In regdlg.c.
//
void
Region_UpdateShortDate(VOID);

void
Region_DoUnattendModeSetup(
    LPCTSTR pUnattendFile);

//
//  In intl.c.
//
BOOL
IsRtLLocale(
    LCID iLCID);

//
//  Restore functions.
//
void
Date_RestoreValues();

void
Currency_RestoreValues();

void
Time_RestoreValues();

void
Number_RestoreValues();

void
Sorting_RestoreValues();


#endif //_INTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\intl\maxvals.h ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    maxvals.h

Abstract:

    This module contains the maximum value string constants for the
    SetLocaleInfo api.

Revision History:

--*/



//
//  SetLocaleInfo string constants.
//

#define MAX_SLIST                 3    // max wide chars in sList
#define MAX_IMEASURE              1    // max wide chars in iMeasure
#define MAX_SDECIMAL              3    // max wide chars in sDecimal
#define MAX_STHOUSAND             3    // max wide chars in sThousand
#define MAX_SGROUPING             3    // max wide chars in sGrouping
#define MAX_IDIGITS               1    // max wide chars in iDigits
#define MAX_IDIGITSUBSTITUTION    2    // max wide chars in iDigitsSubstitution
#define MAX_ILZERO                1    // max wide chars in iLZero
#define MAX_INEGNUMBER            1    // max wide chars in iNegNumber
#define MAX_SCURRENCY             5    // max wide chars in sCurrency
#define MAX_SMONDECSEP            3    // max wide chars in sMonDecimalSep
#define MAX_SMONTHOUSEP           3    // max wide chars in sMonThousandSep
#define MAX_SMONGROUPING          3    // max wide chars in sMonGrouping
#define MAX_ICURRDIGITS           2    // max wide chars in iCurrDigits
#define MAX_ICURRENCY             1    // max wide chars in iCurrency
#define MAX_INEGCURR              2    // max wide chars in iNegCurr
#define MAX_SPOSSIGN              4    // max wide chars in sPositiveSign
#define MAX_SNEGSIGN              4    // max wide chars in sNegativeSign
#define MAX_STIMEFORMAT          79    // max wide chars in sTimeFormat
#define MAX_STIME                 3    // max wide chars in sTime
#define MAX_ITIME                 1    // max wide chars in iTime
#define MAX_S1159                12    // max wide chars in s1159
#define MAX_S2359                12    // max wide chars in s2359
#define MAX_SSHORTDATE           79    // max wide chars in sShortDate
#define MAX_SDATE                 3    // max wide chars in sDate
#define MAX_SLONGDATE            79    // max wide chars in sLongDate
#define MAX_ICALTYPE              1    // max wide chars in iCalendarType
#define MAX_IFIRSTDAY             1    // max wide chars in iFirstDayOfWeek
#define MAX_IFIRSTWEEK            1    // max wide chars in iFirstWeekOfYear
#define MAX_FORMAT               80    // max wide chars in date & time styles
#define MAX_YEAR                  4    // max wide chars in year
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\intl\numdlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    numdlg.c

Abstract:

    This module implements the number property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include "intl.h"
#include <windowsx.h>
#include <tchar.h>
#include "intlhlp.h"
#include "maxvals.h"

#define STRSAFE_LIB
#include <strsafe.h>


//
//  Constant Declarations.
//

#define MAX_DIGIT_SUBST           2
#define CHAR_MAX_DIGIT_SUBST      TEXT('2')

#define EUROPEAN_DIGITS           TEXT("0123456789")
#define LPK_EUROPEAN_DIGITS       TEXT("\x206f\x0030\x0031\x0032\x0033\x0034\x0035\x0036\x0037\x0038\x0039")

#define LANGUAGE_GROUPS_KEY       TEXT("System\\CurrentControlSet\\Control\\Nls\\Language Groups")



//
//  Global Variables.
//

static TCHAR sz_iNegNumber[MAX_INEGNUMBER + 1];
static TCHAR sz_iMeasure[MAX_IMEASURE + 1];
static TCHAR sz_NumShape[MAX_IDIGITSUBSTITUTION + 1];
static TCHAR sz_sDecimal[MAX_SDECIMAL + 1];
static TCHAR sz_sGrouping[MAX_SGROUPING + 1];
static TCHAR sz_sList[MAX_SLIST + 1];
static TCHAR sz_sNativeDigits[MAX_FORMAT + 1];
static TCHAR sz_sNegativeSign[MAX_SNEGSIGN + 1];
static TCHAR sz_sPositiveSign[MAX_SPOSSIGN + 1];
static TCHAR sz_sThousand[MAX_STHOUSAND + 1];
static TCHAR sz_iDigits[MAX_IDIGITS + 1];
static TCHAR sz_iLZero[MAX_ILZERO + 1];

//
//  Native Digits tables.
//
#define MAX_LANG_GROUPS    16
#define MAX_DIGITS_PER_LG   2
static const int c_szDigitsPerLangGroup[MAX_LANG_GROUPS][MAX_DIGITS_PER_LG] =
{
    0,  0,    // 0  = (invalid)
    0,  0,    // 1  = Western Europe (added by code, see Number_SetValues(..))
    0,  0,    // 2  = Central Europe
    0,  0,    // 3  = Baltic
    0,  0,    // 4  = Greek
    0,  0,    // 5  = Cyrillic
    0,  0,    // 6  = Turkish
    0,  0,    // 7  = Japanese
    0,  0,    // 8  = Korean
    0,  0,    // 9  = Traditional Chinese
    0,  0,    // 10 = Simplified Chinese
    12, 0,    // 11 = Thai
    0,  0,    // 12 = Hebrew
    1,  2,    // 13 = Arabic
    0,  0,    // 14 = Vietnamese
    3,  8     // 15 = Indian (NT5 supports only Devenagari and Tamil (i.e. fonts and kbd))
};

static const LPTSTR c_szNativeDigits[15] =
{
    TEXT("0123456789"),                                                    // European
    TEXT("\x0660\x0661\x0662\x0663\x0664\x0665\x0666\x0667\x0668\x0669"),  // Arabic-Indic
    TEXT("\x06f0\x06f1\x06f2\x06f3\x06f4\x06f5\x06f6\x06f7\x06f8\x06f9"),  // Extended Arabic-Indic
    TEXT("\x0966\x0967\x0968\x0969\x096a\x096b\x096c\x096d\x096e\x096f"),  // Devanagari
    TEXT("\x09e6\x09e7\x09e8\x09e9\x09ea\x09eb\x09ec\x09ed\x09ee\x09ef"),  // Bengali
    TEXT("\x0a66\x0a67\x0a68\x0a69\x0a6a\x0a6b\x0a6c\x0a6d\x0a6e\x0a6f"),  // Gurmukhi
    TEXT("\x0ae6\x0ae7\x0ae8\x0ae9\x0aea\x0aeb\x0aec\x0aed\x0aee\x0aef"),  // Gujarati
    TEXT("\x0b66\x0b67\x0b68\x0b69\x0b6a\x0b6b\x0b6c\x0b6d\x0b6e\x0b6f"),  // Oriya
    TEXT("\x0030\x0be7\x0be8\x0be9\x0bea\x0beb\x0bec\x0bed\x0bee\x0bef"),  // Tamil
    TEXT("\x0c66\x0c67\x0c68\x0c69\x0c6a\x0c6b\x0c6c\x0c6d\x0c6e\x0c6f"),  // Telugu
    TEXT("\x0ce6\x0ce7\x0ce8\x0ce9\x0cea\x0ceb\x0cec\x0ced\x0cee\x0cef"),  // Kannada
    TEXT("\x0d66\x0d67\x0d68\x0d69\x0d6a\x0d6b\x0d6c\x0d6d\x0d6e\x0d6f"),  // Malayalam
    TEXT("\x0e50\x0e51\x0e52\x0e53\x0e54\x0e55\x0e56\x0e57\x0e58\x0e59"),  // Thai
    TEXT("\x0ed0\x0ed1\x0ed2\x0ed3\x0ed4\x0ed5\x0ed6\x0ed7\x0ed8\x0ed9"),  // Lao
    TEXT("\x0f20\x0f21\x0f22\x0f23\x0f24\x0f25\x0f26\x0f27\x0f28\x0f29")   // Tibetan
};



//
//  Context Help Ids.
//

static int aNumberHelpIds[] =
{
    IDC_SAMPLELBL3,          IDH_COMM_GROUPBOX,
    IDC_SAMPLELBL1,          IDH_INTL_NUM_POSVALUE,
    IDC_SAMPLE1,             IDH_INTL_NUM_POSVALUE,
    IDC_SAMPLELBL2,          IDH_INTL_NUM_NEGVALUE,
    IDC_SAMPLE2,             IDH_INTL_NUM_NEGVALUE,

    IDC_SAMPLELBL1A,         IDH_INTL_NUM_POSVALUE_ARABIC,
    IDC_SAMPLE1A,            IDH_INTL_NUM_POSVALUE_ARABIC,
    IDC_SAMPLELBL2A,         IDH_INTL_NUM_NEGVALUE_ARABIC,
    IDC_SAMPLE2A,            IDH_INTL_NUM_NEGVALUE_ARABIC,

    IDC_DECIMAL_SYMBOL,      IDH_INTL_NUM_DECSYMBOL,
    IDC_NUM_DECIMAL_DIGITS,  IDH_INTL_NUM_DIGITSAFTRDEC,
    IDC_DIGIT_GROUP_SYMBOL,  IDH_INTL_NUM_DIGITGRPSYMBOL,
    IDC_NUM_DIGITS_GROUP,    IDH_INTL_NUM_DIGITSINGRP,
    IDC_NEG_SIGN,            IDH_INTL_NUM_NEGSIGNSYMBOL,
    IDC_NEG_NUM_FORMAT,      IDH_INTL_NUM_NEGNUMFORMAT,
    IDC_SEPARATOR,           IDH_INTL_NUM_LISTSEPARATOR,
    IDC_DISPLAY_LEAD_0,      IDH_INTL_NUM_DISPLEADZEROS,
    IDC_MEASURE_SYS,         IDH_INTL_NUM_MEASUREMNTSYS,
    IDC_NATIVE_DIGITS_TEXT,  IDH_INTL_NUM_NATIVE_DIGITS,
    IDC_NATIVE_DIGITS,       IDH_INTL_NUM_NATIVE_DIGITS,
    IDC_DIGIT_SUBST_TEXT,    IDH_INTL_NUM_DIGIT_SUBST,
    IDC_DIGIT_SUBST,         IDH_INTL_NUM_DIGIT_SUBST,

    0, 0
};





////////////////////////////////////////////////////////////////////////////
//
//  Number_IsEuropeanDigits
//
////////////////////////////////////////////////////////////////////////////

BOOL Number_IsEuropeanDigits(
    TCHAR *pNum)
{
    int Ctr;
    int Length = lstrlen(pNum);

    for (Ctr = 0; Ctr < Length; Ctr++)
    {
        if (!((pNum[Ctr] >= TEXT('0')) && (pNum[Ctr] <= TEXT('9'))))
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_GetDigitSubstitution
//
////////////////////////////////////////////////////////////////////////////

int Number_GetDigitSubstitution()
{
    TCHAR szBuf[10];
    int cch;

    //
    //  Get the digit substitution.
    //
    if ((cch = GetLocaleInfo(UserLocaleID, LOCALE_IDIGITSUBSTITUTION, szBuf, 10)) &&
        (cch == 2) &&
        ((szBuf[0] >= CHAR_ZERO) && (szBuf[0] <= CHAR_MAX_DIGIT_SUBST)))
    {
        return (szBuf[0] - CHAR_ZERO);
    }

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_DisplaySample
//
//  Update the Number sample.  Format the number based on the user's
//  current locale settings.  Display either a positive value or a
//  negative value based on the Positive/Negative radio buttons.
//
////////////////////////////////////////////////////////////////////////////

void Number_DisplaySample(
    HWND hDlg)
{
    TCHAR szBuf[MAX_SAMPLE_SIZE];
    int nCharCount;

    //
    //  Show or hide the Arabic info based on the current user locale id.
    //
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLELBL1A), bShowArabic ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLE1A), bShowArabic ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLELBL2A), bShowArabic ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_SAMPLE2A), bShowArabic ? SW_SHOW : SW_HIDE);

    //
    //  Get the string representing the number format for the positive sample
    //  number and, if the the value is valid, display it.  Perform the same
    //  operations for the negative sample.
    //
    nCharCount = GetNumberFormat( UserLocaleID,
                                  0,
                                  szSample_Number,
                                  NULL,
                                  szBuf,
                                  MAX_SAMPLE_SIZE );
    if (nCharCount)
    {
        SetDlgItemText(hDlg, IDC_SAMPLE1, szBuf);
        if (bShowArabic)
        {
            SetDlgItemText(hDlg, IDC_SAMPLE1A, szBuf);
            SetDlgItemRTL(hDlg, IDC_SAMPLE1A);
        }
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }

    nCharCount = GetNumberFormat( UserLocaleID,
                                  0,
                                  szNegSample_Number,
                                  NULL,
                                  szBuf,
                                  MAX_SAMPLE_SIZE );
    if (nCharCount)
    {
        SetDlgItemText(hDlg, IDC_SAMPLE2, szBuf);
        if (bShowArabic)
        {
            SetDlgItemText(hDlg, IDC_SAMPLE2A, szBuf);
            SetDlgItemRTL(hDlg, IDC_SAMPLE2A);
        }
    }
    else
    {
        MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_SaveValues
//
//  Save values in the case that we need to restore them.
//
////////////////////////////////////////////////////////////////////////////

void Number_SaveValues()
{
    //
    //  Save registry values.
    //
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_INEGNUMBER,
                        sz_iNegNumber,
                        MAX_INEGNUMBER + 1 ))
    {
        //_tcscpy(sz_iNegNumber, TEXT("1"));
        if(FAILED(StringCchCopy(sz_iNegNumber, MAX_INEGNUMBER+1, TEXT("1"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_IMEASURE,
                        sz_iMeasure,
                        MAX_IMEASURE + 1 ))
    {
        //_tcscpy(sz_iMeasure, TEXT("1"));
        if(FAILED(StringCchCopy(sz_iMeasure, MAX_IMEASURE+1, TEXT("1"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_IDIGITSUBSTITUTION,
                        sz_NumShape,
                        MAX_IDIGITSUBSTITUTION + 1 ))
    {
        //_tcscpy(sz_NumShape, TEXT("1"));
        if(FAILED(StringCchCopy(sz_NumShape, MAX_IDIGITSUBSTITUTION+1, TEXT("1"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SDECIMAL,
                        sz_sDecimal,
                        MAX_SDECIMAL + 1 ))
    {
        //_tcscpy(sz_sDecimal, TEXT("."));
        if(FAILED(StringCchCopy(sz_sDecimal, MAX_SDECIMAL+1, TEXT("."))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SGROUPING,
                        sz_sGrouping,
                        MAX_SGROUPING + 1 ))
    {
        //_tcscpy(sz_sGrouping, TEXT("3;0"));
        if(FAILED(StringCchCopy(sz_sGrouping, MAX_SGROUPING+1, TEXT("3;0"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SLIST,
                        sz_sList,
                        MAX_SLIST + 1 ))
    {
        //_tcscpy(sz_sList, TEXT(","));
        if(FAILED(StringCchCopy(sz_sList, MAX_SLIST+1, TEXT(","))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SNATIVEDIGITS,
                        sz_sNativeDigits,
                        MAX_FORMAT + 1 ))
    {
        //_tcscpy(sz_sNativeDigits, TEXT("0123456789"));
        if(FAILED(StringCchCopy(sz_sNativeDigits, MAX_FORMAT+1, TEXT("0123456789"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SNEGATIVESIGN,
                        sz_sNegativeSign,
                        MAX_SNEGSIGN + 1 ))
    {
        //_tcscpy(sz_sNegativeSign, TEXT("-"));
        if(FAILED(StringCchCopy(sz_sNegativeSign, MAX_SNEGSIGN+1, TEXT("-"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_SPOSITIVESIGN,
                        sz_sPositiveSign,
                        MAX_SPOSSIGN + 1 ))
    {
        //_tcscpy(sz_sPositiveSign, TEXT(""));
        if(FAILED(StringCchCopy(sz_sPositiveSign, MAX_SPOSSIGN+1, TEXT(""))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_STHOUSAND,
                        sz_sThousand,
                        MAX_STHOUSAND + 1 ))
    {
        //_tcscpy(sz_sThousand, TEXT(","));
        if(FAILED(StringCchCopy(sz_sThousand, MAX_STHOUSAND+1, TEXT(","))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_IDIGITS,
                        sz_iDigits,
                        MAX_IDIGITS + 1 ))
    {
        //_tcscpy(sz_iDigits, TEXT("2"));
        if(FAILED(StringCchCopy(sz_iDigits, MAX_IDIGITS+1, TEXT("2"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
    if (!GetLocaleInfo( UserLocaleID,
                        LOCALE_ILZERO,
                        sz_iLZero,
                        MAX_ILZERO + 1 ))
    {
        //_tcscpy(sz_iLZero, TEXT("2"));
        if(FAILED(StringCchCopy(sz_iLZero, MAX_ILZERO+1, TEXT("2"))))
        {
            // This should be impossible, but we need to avoid PREfast complaints.
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
// Number_RestoreValues
//
////////////////////////////////////////////////////////////////////////////

void Number_RestoreValues()
{
    if (g_dwCustChange & Process_Num)
    {
        SetLocaleInfo(UserLocaleID, LOCALE_INEGNUMBER,         sz_iNegNumber);
        SetLocaleInfo(UserLocaleID, LOCALE_IMEASURE,           sz_iMeasure);
        SetLocaleInfo(UserLocaleID, LOCALE_IDIGITSUBSTITUTION, sz_NumShape);
        SetLocaleInfo(UserLocaleID, LOCALE_SDECIMAL,           sz_sDecimal);
        SetLocaleInfo(UserLocaleID, LOCALE_SGROUPING,          sz_sGrouping);
        SetLocaleInfo(UserLocaleID, LOCALE_SLIST,              sz_sList);
        SetLocaleInfo(UserLocaleID, LOCALE_SNATIVEDIGITS,      sz_sNativeDigits);
        SetLocaleInfo(UserLocaleID, LOCALE_SNEGATIVESIGN,      sz_sNegativeSign);
        SetLocaleInfo(UserLocaleID, LOCALE_SPOSITIVESIGN,      sz_sPositiveSign);
        SetLocaleInfo(UserLocaleID, LOCALE_STHOUSAND,          sz_sThousand);
        SetLocaleInfo(UserLocaleID, LOCALE_IDIGITS,            sz_iDigits);
        SetLocaleInfo(UserLocaleID, LOCALE_ILZERO,             sz_iLZero);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  Number_ClearValues
//
//  Reset each of the list boxes in the number property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Number_ClearValues(
    HWND hDlg)
{
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DECIMAL_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NEG_SIGN));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_SEPARATOR));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DIGIT_GROUP_SYMBOL));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NUM_DECIMAL_DIGITS));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NUM_DIGITS_GROUP));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DISPLAY_LEAD_0));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NEG_NUM_FORMAT));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_MEASURE_SYS));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_NATIVE_DIGITS));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DIGIT_SUBST));
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_SetValues
//
//  Initialize all of the controls in the number property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Number_SetValues(
    HWND hDlg)
{
    HWND hCtrl1, hCtrl2;
    HKEY hKey;
    int Index, Ctr1, Ctr2;
    DWORD cbData;
    TCHAR szBuf[SIZE_128];
    const nMax_Array_Fill = (cInt_Str >= 10 ? 10 : cInt_Str);
    NUMBERFMT nfmt;
    TCHAR szThousandSep[SIZE_128];
    TCHAR szEmpty[]  = TEXT("");
    TCHAR szSample[] = TEXT("123456789");
    BOOL bShow;

    //
    //  ----------------------------------------------------------------------
    //  Initialize the dropdown box for the current locale setting for:
    //      Decimal Symbol
    //      Positive Sign
    //      Negative Sign
    //      List Separator
    //      Grouping Symbol
    //  ----------------------------------------------------------------------
    //
    DropDown_Use_Locale_Values(hDlg, LOCALE_SDECIMAL, IDC_DECIMAL_SYMBOL);
    DropDown_Use_Locale_Values(hDlg, LOCALE_SNEGATIVESIGN, IDC_NEG_SIGN);
    DropDown_Use_Locale_Values(hDlg, LOCALE_SLIST, IDC_SEPARATOR);
    DropDown_Use_Locale_Values(hDlg, LOCALE_STHOUSAND, IDC_DIGIT_GROUP_SYMBOL);

    //
    //  ----------------------------------------------------------------------
    //  Fill in the Number of Digits after Decimal Symbol drop down list
    //  with the values of 0 through 10.  Get the user locale value and
    //  make it the current selection.  If GetLocaleInfo fails, simply
    //  select the first item in the list.
    //  ----------------------------------------------------------------------
    //
    hCtrl1 = GetDlgItem(hDlg, IDC_NUM_DECIMAL_DIGITS);
    hCtrl2 = GetDlgItem(hDlg, IDC_NUM_DIGITS_GROUP);
    for (Index = 0; Index < nMax_Array_Fill; Index++)
    {
        ComboBox_InsertString(hCtrl1, -1, aInt_Str[Index]);
    }

    if (GetLocaleInfo(UserLocaleID, LOCALE_IDIGITS, szBuf, SIZE_128))
    {
        ComboBox_SelectString(hCtrl1, -1, szBuf);
    }
    else
    {
        ComboBox_SetCurSel(hCtrl1, 0);
    }

    //
    //  ----------------------------------------------------------------------
    //  Fill in the Number of Digits in "Thousands" Grouping's drop down
    //  list with the appropriate options.  Get the user locale value and
    //  make it the current selection.  If GetLocaleInfo fails, simply
    //  select the first item in the list.
    //  ----------------------------------------------------------------------
    //
    nfmt.NumDigits = 0;                // no decimal in sample string
    nfmt.LeadingZero = 0;              // no decimal in sample string
    nfmt.lpDecimalSep = szEmpty;       // no decimal in sample string
    nfmt.NegativeOrder = 0;            // not a negative value
    nfmt.lpThousandSep = szThousandSep;
    GetLocaleInfo(UserLocaleID, LOCALE_STHOUSAND, szThousandSep, SIZE_128);

    nfmt.Grouping = 0;
    GetNumberFormat(UserLocaleID, 0, szSample, &nfmt, szBuf, SIZE_128);
    ComboBox_InsertString(hCtrl2, -1, szBuf);

    nfmt.Grouping = 3;
    GetNumberFormat(UserLocaleID, 0, szSample, &nfmt, szBuf, SIZE_128);
    ComboBox_InsertString(hCtrl2, -1, szBuf);

    nfmt.Grouping = 32;
    GetNumberFormat(UserLocaleID, 0, szSample, &nfmt, szBuf, SIZE_128);
    ComboBox_InsertString(hCtrl2, -1, szBuf);

    if (GetLocaleInfo(UserLocaleID, LOCALE_SGROUPING, szBuf, SIZE_128) &&
        (szBuf[0]))
    {
        //
        //  Since only the values 0, 3;0, and 3;2;0 are allowed, simply
        //  ignore the ";#"s for subsequent groupings.
        //
        Index = 0;
        if (szBuf[0] == TEXT('3'))
        {
            if ((szBuf[1] == CHAR_SEMICOLON) && (szBuf[2] == TEXT('2')))
            {
                Index = 2;
            }
            else
            {
                Index = 1;
            }
        }
        else
        {
            //
            //  We used to allow the user to set #;0, where # is a value from
            //  0 - 9.  If it's 0, then fall through so that Index is 0.
            //
            if ((szBuf[0] > CHAR_ZERO) && (szBuf[0] <= CHAR_NINE) &&
                ((szBuf[1] == 0) || (lstrcmp(szBuf + 1, TEXT(";0")) == 0)))
            {
                nfmt.Grouping = szBuf[0] - CHAR_ZERO;
                if (GetNumberFormat(UserLocaleID, 0, szSample, &nfmt, szBuf, SIZE_128))
                {
                    Index = ComboBox_InsertString(hCtrl2, -1, szBuf);
                    if (Index >= 0)
                    {
                        ComboBox_SetItemData( hCtrl2,
                                              Index,
                                              (LPARAM)((DWORD)nfmt.Grouping) );
                    }
                    else
                    {
                        Index = 0;
                    }
                }
            }
        }
        ComboBox_SetCurSel(hCtrl2, Index);
    }
    else
    {
        ComboBox_SetCurSel(hCtrl2, 0);
    }

    //
    //  ----------------------------------------------------------------------
    //  Initialize and Lock function.  If it succeeds, call enum function to
    //  enumerate all possible values for the list box via a call to EnumProc.
    //  EnumProc will call Set_List_Values for each of the string values it
    //  receives.  When the enumeration of values is complete, call
    //  Set_List_Values to clear the dialog item specific data and to clear
    //  the lock on the function.  Perform this set of operations for:
    //  Display Leading Zeros, Negative Number Format, and Measurement Systems.
    //  ----------------------------------------------------------------------
    //
    if (Set_List_Values(hDlg, IDC_DISPLAY_LEAD_0, 0))
    {
        EnumLeadingZeros(EnumProcEx, UserLocaleID, 0);
        Set_List_Values(0, IDC_DISPLAY_LEAD_0, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_ILZERO, szBuf, SIZE_128))
        {
            ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_DISPLAY_LEAD_0),
                                Intl_StrToLong(szBuf) );
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }
    if (Set_List_Values(hDlg, IDC_NEG_NUM_FORMAT, 0))
    {
        EnumNegNumFmt(EnumProcEx, UserLocaleID, 0);
        Set_List_Values(0, IDC_NEG_NUM_FORMAT, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_INEGNUMBER, szBuf, SIZE_128))
        {
            ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_NEG_NUM_FORMAT),
                                Intl_StrToLong(szBuf) );
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }
    if (Set_List_Values(hDlg, IDC_MEASURE_SYS, 0))
    {
        EnumMeasureSystem(EnumProc, UserLocaleID, 0);
        Set_List_Values(0, IDC_MEASURE_SYS, 0);
        if (GetLocaleInfo(UserLocaleID, LOCALE_IMEASURE, szBuf, SIZE_128))
        {
            ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_MEASURE_SYS),
                                Intl_StrToLong(szBuf) );
        }
        else
        {
            MessageBox(hDlg, szLocaleGetError, NULL, MB_OK | MB_ICONINFORMATION);
        }
    }

    //
    //  ----------------------------------------------------------------------
    //  Fill in the "Native Digits" dropdown and set the current selection.
    //  Only show this combo box if there is more than one entry in the list.
    //  ----------------------------------------------------------------------
    //
    hCtrl1 = GetDlgItem(hDlg, IDC_NATIVE_DIGITS);
    ComboBox_AddString( hCtrl1,
                        bLPKInstalled
                          ? LPK_EUROPEAN_DIGITS
                          : EUROPEAN_DIGITS );
    ComboBox_SetCurSel(hCtrl1, 0);

    //
    //  Go through the language groups to see which ones have extra native
    //  digits options.
    //
    //  Entry 0 in c_szNativeDigits is the European option.  If any entries
    //  in c_szDigitsPerLangGroup are 0 (European), then ignore them as the
    //  European option is always enabled.
    //
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      LANGUAGE_GROUPS_KEY,
                      0L,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        for (Ctr1 = 1; Ctr1 < MAX_LANG_GROUPS; Ctr1++)
        {
            //
            //  This assumes that if the first entry of
            //  c_szDigitsPerLangGroup is 0, then all other entries are 0.
            //
            if (c_szDigitsPerLangGroup[Ctr1][0] != 0)
            {
                //
                //  See if the language group is installed.
                //
                cbData = 0;
                //wsprintf(szBuf, TEXT("%x"), Ctr1);
                if(SUCCEEDED(StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%x"), Ctr1)))
                {
                    RegQueryValueEx(hKey, szBuf, NULL, NULL, NULL, &cbData);
                    if (cbData > sizeof(TCHAR))
                    {
                        //
                        //  Installed, so add the native digit options to
                        //  the combo box.
                        //
                        for (Ctr2 = 0; Ctr2 < MAX_DIGITS_PER_LG; Ctr2++)
                        {
                            if ((Index = c_szDigitsPerLangGroup[Ctr1][Ctr2]) != 0)
                            {
                                if (ComboBox_FindStringExact(
                                                hCtrl1,
                                                -1,
                                                c_szNativeDigits[Index] ) == CB_ERR)
                                {
                                    ComboBox_AddString( hCtrl1,
                                                        c_szNativeDigits[Index] );
                                }
                            }
                        }
                    }
                }
            }
        }
        RegCloseKey(hKey);
    }

    //
    //  Add the current user's Native Digits option if it's not already
    //  in the combo box.
    //
    if (GetLocaleInfo( UserLocaleID,
                       LOCALE_SNATIVEDIGITS,
                       szBuf,
                       SIZE_128 ) &&
        (!Number_IsEuropeanDigits(szBuf)))
    {
        if ((Index = ComboBox_FindStringExact(hCtrl1, -1, szBuf)) == CB_ERR)
        {
            Index = ComboBox_AddString(hCtrl1, szBuf);
        }
        if (Index != CB_ERR)
        {
            ComboBox_SetCurSel(hCtrl1, Index);
        }
    }

    //
    //  Add the default Native Digits option for the user's chosen locale
    //  if it's not already in the combo box.
    //
    if (GetLocaleInfo( UserLocaleID,
                       LOCALE_SNATIVEDIGITS | LOCALE_NOUSEROVERRIDE,
                       szBuf,
                       SIZE_128 ) &&
        (!Number_IsEuropeanDigits(szBuf)))
    {
        if (ComboBox_FindStringExact(hCtrl1, -1, szBuf) == CB_ERR)
        {
            ComboBox_AddString(hCtrl1, szBuf);
        }
    }

    //
    //  Disable the control if there is only 1 entry in the list.
    //
    bShow = ComboBox_GetCount(hCtrl1) > 1;
    EnableWindow(GetDlgItem(hDlg, IDC_NATIVE_DIGITS_TEXT), bShow);
    EnableWindow(GetDlgItem(hDlg, IDC_NATIVE_DIGITS), bShow);
    ShowWindow(GetDlgItem(hDlg, IDC_NATIVE_DIGITS_TEXT), bShow ? SW_SHOW : SW_HIDE);
    ShowWindow(GetDlgItem(hDlg, IDC_NATIVE_DIGITS), bShow ? SW_SHOW : SW_HIDE);

    //
    //  ----------------------------------------------------------------------
    //  Fill in the "Digit Substitution" dropdown and set the current
    //  selection.  Only show this combo box if a language pack is installed.
    //  ----------------------------------------------------------------------
    //
    hCtrl1 = GetDlgItem(hDlg, IDC_DIGIT_SUBST);
    for (Index = 0; Index <= MAX_DIGIT_SUBST; Index++)
    {
        LoadString(hInstance, IDS_DIGIT_SUBST_CONTEXT + Index, szBuf, SIZE_128);
        ComboBox_InsertString(hCtrl1, Index, szBuf);
    }

    ComboBox_SetCurSel( hCtrl1,
                        Number_GetDigitSubstitution() );

    EnableWindow(GetDlgItem(hDlg, IDC_DIGIT_SUBST_TEXT), bLPKInstalled);
    EnableWindow(hCtrl1, bLPKInstalled);
    ShowWindow(GetDlgItem(hDlg, IDC_DIGIT_SUBST_TEXT), bLPKInstalled ? SW_SHOW : SW_HIDE);
    ShowWindow(hCtrl1, bLPKInstalled ? SW_SHOW : SW_HIDE);

    //
    //  ----------------------------------------------------------------------
    //  Display the current sample that represents all of the locale settings.
    //  ----------------------------------------------------------------------
    //
    Number_DisplaySample(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_ApplySettings
//
//  For every control that has changed (that affects the Locale settings),
//  call Set_Locale_Values to update the user locale information.
//  Notify the parent of changes and reset the change flag stored in the
//  property sheet page structure appropriately.  Redisplay the number
//  sample if bRedisplay is TRUE.
//
////////////////////////////////////////////////////////////////////////////

BOOL Number_ApplySettings(
    HWND hDlg,
    BOOL bRedisplay)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;

    if (Changes & NC_DSymbol)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SDECIMAL,
                                IDC_DECIMAL_SYMBOL,
                                TEXT("sDecimal"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_NSign)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SNEGATIVESIGN,
                                IDC_NEG_SIGN,
                                0,
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_SList)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SLIST,
                                IDC_SEPARATOR,
                                TEXT("sList"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_SThousand)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_STHOUSAND,
                                IDC_DIGIT_GROUP_SYMBOL,
                                TEXT("sThousand"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_IDigits)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_IDIGITS,
                                IDC_NUM_DECIMAL_DIGITS,
                                TEXT("iDigits"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_DGroup)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SGROUPING,
                                IDC_NUM_DIGITS_GROUP,
                                0,
                                TRUE,
                                0,
                                TEXT(";0"),
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_LZero)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_ILZERO,
                                IDC_DISPLAY_LEAD_0,
                                TEXT("iLzero"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_NegFmt)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_INEGNUMBER,
                                IDC_NEG_NUM_FORMAT,
                                0,
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_Measure)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_IMEASURE,
                                IDC_MEASURE_SYS,
                                TEXT("iMeasure"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_NativeDigits)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_SNATIVEDIGITS,
                                IDC_NATIVE_DIGITS,
                                TEXT("sNativeDigits"),
                                FALSE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }
    if (Changes & NC_DigitSubst)
    {
        if (!Set_Locale_Values( hDlg,
                                LOCALE_IDIGITSUBSTITUTION,
                                IDC_DIGIT_SUBST,
                                TEXT("NumShape"),
                                TRUE,
                                0,
                                0,
                                NULL ))
        {
            return (FALSE);
        }
    }

    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    lpPropSheet->lParam = NC_EverChg;

    //
    //  Display the current sample that represents all of the locale settings.
    //
    if (bRedisplay)
    {
        Number_ClearValues(hDlg);
        Number_SetValues(hDlg);
    }

    //
    //  Changes made in the second level.
    //
    if (Changes)
    {
        g_dwCustChange |= Process_Num;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Number_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= NC_EverChg)
    {
        return (TRUE);
    }

    //
    //  If the decimal symbol has changed, ensure that there are no digits
    //  contained in the new symbol.
    //
    if (Changes & NC_DSymbol &&
        Item_Has_Digits(hDlg, IDC_DECIMAL_SYMBOL, FALSE))
    {
        No_Numerals_Error(hDlg, IDC_DECIMAL_SYMBOL, IDS_LOCALE_DECIMAL_SYM);
        return (FALSE);
    }

    //
    //  If the negative sign symbol has changed, ensure that there are no
    //  digits contained in the new symbol.
    //
    if (Changes & NC_NSign &&
        Item_Has_Digits(hDlg, IDC_NEG_SIGN, TRUE))
    {
        No_Numerals_Error(hDlg, IDC_NEG_SIGN, IDS_LOCALE_NEG_SIGN);
        return (FALSE);
    }

    //
    //  If the thousands grouping symbol has changed, ensure that there
    //  are no digits contained in the new symbol.
    //
    if (Changes & NC_SThousand &&
        Item_Has_Digits(hDlg, IDC_DIGIT_GROUP_SYMBOL, FALSE))
    {
        No_Numerals_Error(hDlg, IDC_DIGIT_GROUP_SYMBOL, IDS_LOCALE_GROUP_SYM);
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Number_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Number_SetValues with the property
//  sheet handle to initialize all of the property sheet controls.
//  Constrain the size of certain ComboBox text sizes.
//
////////////////////////////////////////////////////////////////////////////

void Number_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    //
    //  The lParam holds a pointer to the property sheet page, save it for
    //  later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    Number_SetValues(hDlg);

    ComboBox_LimitText(GetDlgItem(hDlg, IDC_NEG_SIGN),           MAX_SNEGSIGN);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_DECIMAL_SYMBOL),     MAX_SDECIMAL);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_DIGIT_GROUP_SYMBOL), MAX_STHOUSAND);
    ComboBox_LimitText(GetDlgItem(hDlg, IDC_SEPARATOR),          MAX_SLIST);
}


////////////////////////////////////////////////////////////////////////////
//
//  NumberDlgProc
//
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK NumberDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    NMHDR *lpnm;
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch (message)
    {
        case ( WM_NOTIFY ) :
        {
            lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Num)
                    {
                        Verified_Regional_Chg &= ~Process_Num;
                        Number_ClearValues(hDlg);
                        Number_SetValues(hDlg);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                   DWLP_MSGRESULT,
                                   !Number_ValidatePPS( hDlg,
                                                        lpPropSheet->lParam ) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Number_ApplySettings(hDlg, TRUE))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                        //
                        //  Zero out the NC_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                       DWLP_MSGRESULT,
                                       PSNRET_INVALID_NOCHANGEPAGE );
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            Number_InitPropSheet(hDlg, lParam);
            Number_SaveValues();
            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aNumberHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aNumberHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_DECIMAL_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= NC_DSymbol;
                    }
                    break;
                }
                case ( IDC_NEG_SIGN ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= NC_NSign;
                    }
                    break;
                }
                case ( IDC_SEPARATOR ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= NC_SList;
                    }
                    break;
                }
                case ( IDC_DIGIT_GROUP_SYMBOL ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE ||
                        HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        lpPropSheet->lParam |= NC_SThousand;
                    }
                    break;
                }
                case ( IDC_NUM_DECIMAL_DIGITS ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_IDigits;
                    }
                    break;
                }
                case ( IDC_NUM_DIGITS_GROUP ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_DGroup;
                    }
                    break;
                }
                case ( IDC_DISPLAY_LEAD_0 ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_LZero;
                    }
                    break;
                }
                case ( IDC_NEG_NUM_FORMAT ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_NegFmt;
                    }
                    break;
                }
                case ( IDC_MEASURE_SYS ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_Measure;
                    }
                    break;
                }
                case ( IDC_NATIVE_DIGITS ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_NativeDigits;
                    }
                    break;
                }
                case ( IDC_DIGIT_SUBST ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        lpPropSheet->lParam |= NC_DigitSubst;
                    }
                    break;
                }
            }

            //
            //  Turn on ApplyNow button.
            //
            if (lpPropSheet->lParam > NC_EverChg)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }

            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\intl\langdlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    langdlg.c

Abstract:

    This module implements the languages property sheet for the Regional
    Options applet.

Revision History:

--*/



//
//  Include Files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "intl.h"
#include "intlhlp.h"
#include <windowsx.h>
#include "winnlsp.h"

#define STRSAFE_LIB
#include <strsafe.h>


//
//  Context Help Ids.
//

static int aLanguagesHelpIds[] =
{
    IDC_GROUPBOX1,            IDH_INTL_LANG_CHANGE,
    IDC_LANGUAGE_LIST_TEXT,   IDH_INTL_LANG_CHANGE,
    IDC_LANGUAGE_CHANGE,      IDH_INTL_LANG_CHANGE,

    IDC_GROUPBOX2,            IDH_INTL_LANG_INSTALL,
    IDC_LANGUAGE_SUPPL_TEXT,  IDH_INTL_LANG_INSTALL,
    IDC_LANGUAGE_COMPLEX,     IDH_INTL_LANG_INSTALL,
    IDC_LANGUAGE_CJK,         IDH_INTL_LANG_INSTALL,

    IDC_UI_LANGUAGE_TEXT,     IDH_INTL_LANG_UI_LANGUAGE,
    IDC_UI_LANGUAGE,          IDH_INTL_LANG_UI_LANGUAGE,

    0, 0
};

//
//  Global Variable.
//
BOOL bComplexInitState;
BOOL bCJKInitState;


//
//  Function prototypes.
//

void
Language_SetValues(
    HWND hDlg);


////////////////////////////////////////////////////////////////////////////
//
//  Language_InstallLanguageCollectionProc
//
//  This is the dialog proc for the Copy status Dlg.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK Language_InstallLanguageCollectionProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            break;
        }
        case (WM_DESTROY) :
        {
            EndDialog(hwnd, 0);
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_GetUILanguagePolicy
//
//  Checks if a policy is installed for the current user's MUI language.
//  The function assumes this is an MUI system.
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_GetUILanguagePolicy()
{
    HKEY hKey;
    BYTE buf[MAX_PATH];
    DWORD dwType, dwResultLen = sizeof(buf);
    BOOL bRet = FALSE;
    DWORD Num;


    //
    //  Try to open the MUI Language policy key.
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     c_szMUIPolicyKeyPath,
                     0L,
                     KEY_READ,
                     &hKey) == ERROR_SUCCESS)
    {
        if ((RegQueryValueEx(hKey,
                             c_szMUIValue,
                             NULL,
                             &dwType,
                             &buf[0],
                             &dwResultLen) == ERROR_SUCCESS) &&
            (dwType == REG_SZ) &&
            (dwResultLen > 2))
        {
            bRet = TRUE;
        }
        RegCloseKey(hKey);
    }

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_UpdateUILanguageCombo
//
////////////////////////////////////////////////////////////////////////////

void Language_UpdateUILanguageCombo(
    HWND hDlg)
{
    HWND hUILangText = GetDlgItem(hDlg, IDC_UI_LANGUAGE_TEXT);
    HWND hUILang = GetDlgItem(hDlg, IDC_UI_LANGUAGE);
    HKEY hKey;
    TCHAR szValue[MAX_PATH];
    TCHAR szData[MAX_PATH];
    DWORD dwIndex, cchValue, cbData;
    DWORD UILang;
    DWORD dwType;
    LANGID DefaultUILang;
    LONG rc;
    DWORD dwLangIdx = 0;

    //
    //  Reset the contents of the combo box.
    //
    ComboBox_ResetContent(hUILang);

    //
    //  See if this combo box should be enabled by getting the default
    //  UI language and opening the
    //  HKLM\System\CurrentControlSet\Control\Nls\MUILanguages key.
    //
    if (!(DefaultUILang = GetUserDefaultUILanguage()) ||
        (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       c_szMUILanguages,
                       0,
                       KEY_READ,
                       &hKey ) != ERROR_SUCCESS))
    {
        //
        //  No MUILanguages.  Disable and hide the UI language combo box.
        //
        EnableWindow(hUILangText, FALSE);
        EnableWindow(hUILang, FALSE);
        ShowWindow(hUILangText, SW_HIDE);
        ShowWindow(hUILang, SW_HIDE);
        return;
    }

    //
    //  Enumerate the values in the MUILanguages key.
    //
    dwIndex = 0;
    cchValue = sizeof(szValue) / sizeof(TCHAR);
    szValue[0] = TEXT('\0');
    cbData = sizeof(szData);
    szData[0] = TEXT('\0');
    rc = RegEnumValue( hKey,
                       dwIndex,
                       szValue,
                       &cchValue,
                       NULL,
                       &dwType,
                       (LPBYTE)szData,
                       &cbData );

    while (rc == ERROR_SUCCESS)
    {
        //
        //  If the UI language contains data, then it is installed.
        //
        if ((szData[0] != 0) &&
            (dwType == REG_SZ) &&
            (UILang = TransNum(szValue)) &&
            (GetLocaleInfo(UILang, LOCALE_SNATIVELANGNAME, szData, MAX_PATH)) &&
            (IsValidUILanguage((LANGID)UILang)))
        {
            //
            //  Add the new UI Language option to the combo box.
            //
            dwLangIdx = ComboBox_AddString(hUILang, szData);
            ComboBox_SetItemData(hUILang, dwLangIdx, UILang);

            //
            //  Set this as the current selection if it's the default.
            //
            if (UILang == (DWORD)DefaultUILang)
            {
                ComboBox_SetCurSel(hUILang, dwLangIdx);
            }
        }

        //
        //  Get the next enum value.
        //
        dwIndex++;
        cchValue = sizeof(szValue) / sizeof(TCHAR);
        szValue[0] = TEXT('\0');
        cbData = sizeof(szData);
        szData[0] = TEXT('\0');
        rc = RegEnumValue( hKey,
                           dwIndex,
                           szValue,
                           &cchValue,
                           NULL,
                           &dwType,
                           (LPBYTE)szData,
                           &cbData );
    }

    //
    //  Close the registry key handle.
    //
    RegCloseKey(hKey);

    //
    //  Make sure there is at least one entry in the list.
    //
    if (ComboBox_GetCount(hUILang) < 1)
    {
        //
        //  No MUILanguages.  Add the default UI language option to the
        //  combo box.
        //
        if ((GetLocaleInfo(DefaultUILang, LOCALE_SNATIVELANGNAME, szData, MAX_PATH)) &&
            (ComboBox_AddString(hUILang, szData) == 0))
        {
            ComboBox_SetItemData(hUILang, 0, (DWORD)DefaultUILang);
            ComboBox_SetCurSel(hUILang, 0);
        }
    }

    //
    //  Make sure something is selected.
    //
    if (ComboBox_GetCurSel(hUILang) == CB_ERR)
    {
        ComboBox_SetCurSel(hUILang, 0);
    }

    //
    //  Enable the combo box if there is more than one entry in the list.
    //  Otherwise, disable it.
    //
    if (ComboBox_GetCount(hUILang) > 1)
    {
        if ((IsWindowEnabled(hUILang) == FALSE) ||
            (IsWindowVisible(hUILang) == FALSE))
        {
            ShowWindow(hUILangText, SW_SHOW);
            ShowWindow(hUILang, SW_SHOW);
        }

        //
        //  Check if there is a policy enforced on the user, and if
        //  so, disable the MUI controls.
        //
        if (Language_GetUILanguagePolicy())
        {
            EnableWindow(hUILangText, FALSE);
            EnableWindow(hUILang, FALSE);
        }
        else
        {
            EnableWindow(hUILangText, TRUE);
            EnableWindow(hUILang, TRUE);
        }
    }
    else
    {
        if ((IsWindowEnabled(hUILang) == TRUE) ||
            (IsWindowVisible(hUILang) == TRUE))
        {
            EnableWindow(hUILangText, FALSE);
            EnableWindow(hUILang, FALSE);
            ShowWindow(hUILangText, SW_HIDE);
            ShowWindow(hUILang, SW_HIDE);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_GetCollectionStatus
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_GetCollectionStatus(
    DWORD collection,
    WORD wStatus)
{
    LPLANGUAGEGROUP pLG = pLanguageGroups;

    while (pLG)
    {
        if (pLG->LanguageCollection == collection)
        {
            if (pLG->wStatus & wStatus)
            {
                return (TRUE);
            }
        }
        pLG = pLG->pNext;
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_SetCollectionStatus
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_SetCollectionStatus(
    DWORD collection,
    WORD wStatus,
    BOOL bOr)
{
    LPLANGUAGEGROUP pLG = pLanguageGroups;

    while (pLG)
    {
        if (pLG->LanguageCollection == collection)
        {
            if( bOr)
            {
                pLG->wStatus |= wStatus;
            }
            else
            {
                pLG->wStatus &= wStatus;
            }
        }
        pLG = pLG->pNext;
    }

    return (TRUE);
}

    
////////////////////////////////////////////////////////////////////////////
//
//  Language_InstallCollection
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_InstallCollection(
    BOOL bInstall,
    DWORD collection,
    HWND hDlg)
{
    HINF hIntlInf;
    HSPFILEQ FileQueue;
    PVOID QueueContext;
    INFCONTEXT Context;
    HCURSOR hcurSave;
    BOOL bActionSuccess = FALSE;
    DWORD dwRet;
    LPLANGUAGEGROUP pLG = pLanguageGroups;
    LCID *pLocale;
    BOOL bStopLoop = FALSE;
    LPTSTR pszInfSection = NULL;

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  Check if we remove the Language Collection.  This may affect the
    //  UI Language, User Locale, and/or System Locale setting.
    //
    if (!bInstall)
    {
        //
        //  Check if we can remove the Language group.
        //
        if (Language_GetCollectionStatus(collection, ML_PERMANENT))
        {
            return (FALSE);
        }
        
        //
        //  Inform Text Services that we are going to remove the
        //  complex script language collection.
        //
        while (pLG)
        {
            if (pLG->LanguageCollection == collection)
            {
                //
                //  Uninstall keyboards of the current user
                //
                Intl_UninstallAllKeyboardLayout(pLG->LanguageGroup, FALSE);


                //
                //  Uninstall keyboards of the default user
                //
                Intl_UninstallAllKeyboardLayout(pLG->LanguageGroup, TRUE);
            }
            pLG = pLG->pNext;
        }
        
        //
        //  If the User Locale is one the Language group asked to be removed. Change
        //  the user locale to be the system locale.
        //
        //  Walk through all language groups.
        //
        pLG = pLanguageGroups;
        while (pLG && !bStopLoop)
        {
            if (pLG->LanguageCollection == collection)
            {
                pLocale = pLG->pLocaleList;

                //
                //  Walk through the locale list, see if the User Locale is
                //  part of one of these Language Group.
                //
                while (*pLocale)
                {
                    if(PRIMARYLANGID(UserLocaleID) == PRIMARYLANGID(*pLocale))
                    {
                        //
                        //  Save the new locale information.
                        //
                        UserLocaleID = SysLocaleID;
                        bShowRtL = IsRtLLocale(UserLocaleID);
                        bHebrewUI = (PRIMARYLANGID(UserLocaleID) == LANG_HEBREW);                        
                        bShowArabic = (bShowRtL && (PRIMARYLANGID(LANGIDFROMLCID(UserLocaleID)) != LANG_HEBREW));
            
                        //
                        //  Install the new locale by adding the appropriate information
                        //  to the registry.
                        //
                        Intl_InstallUserLocale(UserLocaleID, FALSE, TRUE);
            
                        //
                        //  Update the NLS process cache.
                        //
                        NlsResetProcessLocale();
            
                        //
                        //  Reset the registry user locale value.
                        //
                        RegUserLocaleID = UserLocaleID;
                        
                        //
                        //  Need to make sure the proper keyboard layout is installed.
                        //
                        Intl_InstallKeyboardLayout(hDlg, UserLocaleID, 0, FALSE, FALSE, FALSE);
            
                        //
                        //  Force the loop the end.
                        //
                        bStopLoop = TRUE;
                        break;
                    }
                    pLocale++;
                }
            }

            pLG = pLG->pNext;
        }
    }

    //
    //  Initialize Inf stuff.
    //
    if (!Intl_InitInf(hDlg, &hIntlInf, szIntlInf, &FileQueue, &QueueContext))
    {
        SetCursor(hcurSave);
        return (FALSE);
    }

    //
    //  Determine with language collection we are dealing with
    //
    if( bInstall)
    {
        if (collection == COMPLEX_COLLECTION)
        {
            pszInfSection = szLGComplexInstall;
        }
        else if (collection == CJK_COLLECTION)
        {
            pszInfSection = szLGExtInstall;
        }
        else
        {
            return (FALSE);
        }
    }
    else
    {
        if (collection == COMPLEX_COLLECTION)
        {
            pszInfSection = szLGComplexRemove;
        }
        else if (collection == CJK_COLLECTION)
        {
            pszInfSection = szLGExtRemove;
        }
        else
        {
            return (FALSE);
        }
    }

    //
    //  Enqueue the complex script language group files so that they may be
    //  copied.  This only handles the CopyFiles entries in the inf file.
    //
    if (!SetupInstallFilesFromInfSection( hIntlInf,
                                          NULL,
                                          FileQueue,
                                          pszInfSection,
                                          pSetupSourcePath,
                                          SP_COPY_NEWER ))
    {
        //
        //  Setup failed to find the complex script language group.
        //  This shouldn't happen - the inf file is messed up.
        //
        ShowMsg( hDlg,
                 IDS_ML_COPY_FAILED,
                 0,
                 MB_OK_OOPS,
                 TEXT("Supplemental Language Support") );
    }

    //
    //  See if we need to install/remove any files.
    //
    if (SetupScanFileQueue( FileQueue,
                            SPQ_SCAN_PRUNE_COPY_QUEUE | SPQ_SCAN_FILE_VALIDITY,
                            GetParent(hDlg),
                            NULL,
                            NULL,
                            &dwRet ))
    {
        //
        //  Copy the files in the queue.
        //
        if (!SetupCommitFileQueue( GetParent(hDlg),
                                   FileQueue,
                                   Intl_MyQueueCallback,
                                   QueueContext ))
        {
            //
            //  This can happen if the user hits Cancel from within
            //  the setup dialog.
            //
            bInstall = FALSE;
            ShowMsg( hDlg,
                     IDS_ML_SETUP_FAILED,
                     0,
                     MB_OK_OOPS,
                     NULL );
        }
        else
        {
            //
            //  Call setup to install other inf info for this
            //  language group.
            //
            if (!SetupInstallFromInfSection( GetParent(hDlg),
                                             hIntlInf,
                                             pszInfSection,
                                             SPINST_ALL & ~SPINST_FILES,
                                             NULL,
                                             pSetupSourcePath,
                                             0,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL ))
            {
                //
                //  Setup failed.
                //
                //  Already copied the language group file, so no need to
                //  change the status of the language group info here.
                //
                //  This shouldn't happen - the inf file is messed up.
                //
                ShowMsg( hDlg,
                         IDS_ML_INSTALL_FAILED,
                         0,
                         MB_OK_OOPS,
                         TEXT("Supplemental Language Support") );
            }
            else
            {
                //
                //  Run any necessary apps (for IME installation).
                //
                if (bInstall)
                {
                    Intl_RunRegApps(c_szIntlRun);
                }
                bActionSuccess = TRUE;
            }
        }
    }

    //
    //  Update the status of all language groups included in the
    //  Supplemental Language support.
    //
    if (bActionSuccess)
    {
        if (bInstall)
        {
            //
            //  Mark as installed.
            //
            Language_SetCollectionStatus(collection,
            	                         ML_INSTALL,
            	                         TRUE);
            Language_SetCollectionStatus(collection,
            	                         ~(ML_DISABLE | ML_REMOVE),
            	                         FALSE);
        }
        else
        {
            //
            //  Mark as removed.
            //
            Language_SetCollectionStatus(collection,
            	                         (ML_DISABLE | ML_REMOVE),
            	                         TRUE);
            Language_SetCollectionStatus(collection,
            	                         ~ML_INSTALL,
            	                         FALSE);
        }
    }

    //
    //  Close Inf stuff.
    //
    Intl_CloseInf(hIntlInf, FileQueue, QueueContext);

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  Return the result.
    //
    return (bActionSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_InstallLanguageCollection
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_InstallLanguageCollection(
    BOOL bInstall,
    DWORD collection,
    HWND hDlg)
{
    //
    //  Check if we are in setup. If in setup we need to show up a dialog
    //  instead of using the progress bar of setup.
    //
    if( g_bSetupCase)
    {
        HWND hDialog;
        BOOL retVal;

        //
        // Create a dialog.
        //
        hDialog = CreateDialog( hInstance,
                                MAKEINTRESOURCE(DLG_SETUP_INFORMATION),
                                hDlg,
                                Language_InstallLanguageCollectionProc);
        
        //
        //  Show dialog
        //
        ShowWindow(hDialog, SW_SHOW);

        //
        //  proceed with the installation
        //
        retVal = Language_InstallCollection(bInstall, collection, hDlg);

        //
        //  Close the dialog
        //
        DestroyWindow(hDialog);
        return (retVal);
    }
    else
    {
       return Language_InstallCollection(bInstall, collection, hDlg);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_CommandChange
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_CommandChange(
    HWND hDlg)
{
    //
    //  Call Text Services input page
    //
    Intl_CallTextServices();

    //
    //  Return the result.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_ClearValues
//
//  Reset each of the list boxes in the advanced property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Language_ClearValues(
    HWND hDlg)
{
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_SetValues
//
//  Initialize all of the controls in the advanced property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Language_SetValues(
    HWND hDlg)
{
    HWND hUILang = GetDlgItem(hDlg, IDC_UI_LANGUAGE);
    TCHAR szUILang[SIZE_128];
    DWORD dwIndex;

    //
    //  Fill in the current UI Language settings in the list.
    //
    ComboBox_GetLBText( hUILang, ComboBox_GetCurSel(hUILang), szUILang );
    Language_UpdateUILanguageCombo(hDlg);
    dwIndex = ComboBox_GetCurSel(hUILang);
    if (ComboBox_SetCurSel( hUILang,
                            ComboBox_FindStringExact( hUILang,
                                                      -1,
                                                      szUILang ) ) == CB_ERR)
    {
        ComboBox_SetCurSel(hUILang, dwIndex);
    }

    //
    //  Verify if the user has administrative privileges.  If not, then
    //  disable the controls.
    //
    if (!g_bAdmin_Privileges)
    {
        //
        //  Disable the complex scripts install/remove.
        //
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE_COMPLEX), FALSE);

        //
        //  Disable the CJK install/remove.
        //
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE_CJK), FALSE);
    }

    //
    //  Verify that the collection is not marked as permanent.
    //
    if (Language_GetCollectionStatus(COMPLEX_COLLECTION, ML_PERMANENT))
    {
        //
        //  Disable the complex scripts install/remove.
        //
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE_COMPLEX), FALSE);
    }
    if (Language_GetCollectionStatus(CJK_COLLECTION, ML_PERMANENT))
    {
        //
        //  Disable the CJK install/remove.
        //
        EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE_CJK), FALSE);
    }

    //
    //  Check if we can install the CJK Language Groups.  This is only
    //  the case on a Clean install over the Network.
    //
    if (g_bSetupCase)
    {
        //
        //  Check if we have at least one file in the \Lang directory.
        //
        if (!Intl_LanguageGroupFilesExist())
        {
            //
            //  Disable the CJK install/remove.
            //
            EnableWindow(GetDlgItem(hDlg, IDC_LANGUAGE_CJK), FALSE);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_ApplySettings
//
//  If anything has changed, update the settings.  Notify the parent of
//  changes and reset the change flag stored in the property sheet page
//  structure appropriately.
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_ApplySettings(
    HWND hDlg)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPARAM Changes = lpPropSheet->lParam;
    HCURSOR hcurSave;
    BOOL bReboot = FALSE, bLogoff = FALSE;

    //
    //  See if there are any changes.
    //
    if (Changes <= LG_EverChg)
    {
        return (TRUE);
    }

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  See if there are any changes to the Complex Srcipts Languages group
    //  installation.
    //
    if (Changes & LG_Complex)
    {
        //
        //  Install/Remove Complex Scripts Language groups.
        //
        if (Language_InstallLanguageCollection(g_bInstallComplex, COMPLEX_COLLECTION, hDlg))
        {
            if (g_bInstallComplex)
            {
                //
                //  Check the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_CHECKED);
                bComplexInitState = TRUE;
            }
            else
            {
                //
                //  Uncheck the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_UNCHECKED);
                bComplexInitState = FALSE;
            }

            //
            //  Need to reboot in order for the change to take effect.
            //
            bReboot = TRUE;
        }
        else
        {
            if (g_bInstallComplex)
            {
                //
                //  UnCheck the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_UNCHECKED);
            }
            else
            {
                //
                //  Check the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_CHECKED);
            }
        }
    }

    //
    //  See if there are any changes to the CJK Languages group
    //  installation.
    //
    if (Changes & LG_CJK)
    {
        //
        //  Install/Remove CJK Language groups.
        //
        if (Language_InstallLanguageCollection(g_bInstallCJK, CJK_COLLECTION, hDlg))
        {
            if (g_bInstallCJK)
            {
                //
                //  Check the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_CHECKED);
                bCJKInitState = TRUE;
            }
            else
            {
                //
                //  Uncheck the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_UNCHECKED);
                bCJKInitState = FALSE;
            }

            //
            //  Need to reboot to the change to take effect
            //
            bReboot = TRUE;
        }
        else
        {
            if (g_bInstallCJK)
            {
                //
                //  Uncheck the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_UNCHECKED);
            }
            else
            {
                //
                //  Check the box.
                //
                CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_CHECKED);
            }
        }
    }

    //
    //  See if there are any changes to the UI Language.
    //
    if (Changes & LG_UILanguage)
    {
        DWORD dwUILang;
        LANGID UILang;
        HWND hUILang = GetDlgItem(hDlg, IDC_UI_LANGUAGE);

        //
        //  Get the current selection.
        //
        dwUILang = ComboBox_GetCurSel(hUILang);

        //
        //  See if the current selection is different from the original
        //  selection.
        //
        if (dwUILang != CB_ERR)
        {
            //
            //  Get the UI Language id for the current selection.
            //
            UILang = (LANGID)ComboBox_GetItemData(hUILang, dwUILang);

            //
            //  Set the UI Language value in the user's registry.
            //
            if (NT_SUCCESS(NtSetDefaultUILanguage(UILang)))
            {
                //  deleting the key this way makes the key invalid for this process
                //  this way the new UI doesn't get bogus cached values
                SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\MUICache"));

            }

            //
            //  Install keyboard assciated with the UI language
            //
            Intl_InstallKeyboardLayout(hDlg, MAKELCID(UILang, SORT_DEFAULT), 0, FALSE, FALSE, FALSE);

            //
            //  Set Logoff flag to give the user a chance to logoff if no other settings changes require a reboot
            //            
            
            bLogoff = TRUE;        
            
        }
    }

    //
    //  Reset the property page settings.
    //
    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    Changes = LG_EverChg;

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  See if we need to display the reboot or logoff message.
    //
    if (!g_bSetupCase)
    {
        if (bReboot)
        {
            if (RegionalChgState & AD_SystemLocale)
            {
                RegionalChgState &= ~Process_Languages;
            }
            else
            {
                if (ShowMsg( hDlg,
                             IDS_REBOOT_STRING,
                             IDS_TITLE_STRING,
                             MB_YESNO | MB_ICONQUESTION,
                             NULL ) == IDYES)
                {
                    Intl_RebootTheSystem(TRUE);
                }
            }
        }
        else
            if (bLogoff)    
            {
            
                if (RegionalChgState & AD_SystemLocale)
                {
                    RegionalChgState &= ~Process_Languages;
                }
                else
                {
                    if (ShowMsg( hDlg,
                                    IDS_CHANGE_UI_LANG_NOT_ADMIN,
                                    IDS_TITLE_STRING,
                                    MB_YESNO | MB_ICONQUESTION,
                                    NULL ) == IDYES)
                         {
                           Intl_RebootTheSystem(FALSE);
                         }
                }
            }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Language_ValidatePPS(
    HWND hDlg,
    LPARAM Changes)
{
    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= LG_EverChg)
    {
        return (TRUE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Language_InitPropSheet
//
//  The extra long value for the property sheet page is used as a set of
//  state or change flags for each of the list boxes in the property sheet.
//  Initialize this value to 0.  Call Language_SetValues with the property
//  sheet handle to initialize all of the property sheet controls.  Limit
//  the length of the text in some of the ComboBoxes.
//
////////////////////////////////////////////////////////////////////////////

void Language_InitPropSheet(
    HWND hDlg,
    LPARAM lParam)
{
    DWORD dwColor;

    //
    //  The lParam holds a pointer to the property sheet page.  Save it
    //  for later reference.
    //
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);

    //
    //  Set values.
    //
    if (pLanguageGroups == NULL)
    {
        Intl_LoadLanguageGroups(hDlg);
    }
    Language_SetValues(hDlg);

    //
    //  Determine if Complex Scripts language support is installed.
    //
    if (Language_GetCollectionStatus(COMPLEX_COLLECTION, ML_INSTALL))
    {
        //
        //  Check the box.
        //
        CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_CHECKED);
        bComplexInitState = TRUE;
    }
    else
    {
        //
        //  Uncheck the box.
        //
        CheckDlgButton(hDlg, IDC_LANGUAGE_COMPLEX, BST_UNCHECKED);
        bComplexInitState = FALSE;
    }

    //
    //  Determine if CJK language support is installed.
    //
    if (Language_GetCollectionStatus(CJK_COLLECTION, ML_INSTALL))
    {
        //
        //  Check the box.
        //
        CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_CHECKED);
        bCJKInitState = TRUE;
    }
    else
    {
        //
        //  Uncheck the box.
        //
        CheckDlgButton(hDlg, IDC_LANGUAGE_CJK, BST_UNCHECKED);
        bCJKInitState = FALSE;
    }    
}


////////////////////////////////////////////////////////////////////////////
//
//  LanguagesDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK LanguageDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));

    switch (message)
    {
        case ( WM_NOTIFY ) :
        {
            LPNMHDR lpnm = (NMHDR *)lParam;
            switch (lpnm->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Languages)
                    {
                        Verified_Regional_Chg &= ~Process_Languages;
                        Language_ClearValues(hDlg);
                        Language_SetValues(hDlg);
                        lpPropSheet->lParam = 0;
                    }
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    SetWindowLongPtr( hDlg,
                                      DWLP_MSGRESULT,
                                      !Language_ValidatePPS(hDlg, lpPropSheet->lParam) );
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    //
                    //  Apply the settings.
                    //
                    if (Language_ApplySettings(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                        //
                        //  Check if we need to do something for the
                        //  default user.
                        //
                        if (g_bDefaultUser)
                        {
                            g_bSettingsChanged = TRUE;
                            Intl_SaveDefaultUserSettings();
                        }
                        else if(2 == g_bSetupCase)
                        {
                            //
                            //  Intl_SaveDefaultUserSettings is destructive to NLS settings  
                            //  in minisetup mode; call the MUI function directly here.
                            //
                            Intl_ChangeUILangForAllUsers(Intl_GetPendingUILanguage());
                        }

                        //
                        //  Zero out the LG_EverChg bit.
                        //
                        lpPropSheet->lParam = 0;
                    }
                    else
                    {
                        SetWindowLongPtr( hDlg,
                                          DWLP_MSGRESULT,
                                          PSNRET_INVALID_NOCHANGEPAGE );
                    }

                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_INITDIALOG ) :
        {
            //
            //  Init property sheet.
            //
            Language_InitPropSheet(hDlg, lParam);
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aLanguagesHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aLanguagesHelpIds );
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_UI_LANGUAGE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        DWORD dwUILang;
                        HWND hUILang = GetDlgItem(hDlg, IDC_UI_LANGUAGE);
                        
                        //
                        //  Get the current selection.
                        //
                        dwUILang = ComboBox_GetCurSel(hUILang);
                        
                        //
                        //  Check if the user reverted the change back
                        //
                        if (dwUILang != CB_ERR)
                        {
                            if ((LANGID)ComboBox_GetItemData(hUILang, dwUILang) == Intl_GetPendingUILanguage())
                            {
                                //
                                //  Reset the LG_UILanguage change flag.
                                //
                                lpPropSheet->lParam &= ~LG_UILanguage;
                            }
                            else
                            {
                                //
                                //  Set the LG_UILanguage change flag.
                                //
                                lpPropSheet->lParam |= LG_UILanguage;
                            }
                        }
                    }
                    break;
                }
                case ( IDC_LANGUAGE_CHANGE ) :
                {
                    if (Language_CommandChange(hDlg))
                    {
                        //
                        //  Set the LG_Change change flag.
                        //
                        lpPropSheet->lParam |= LG_Change;
                    }
                    break;
                }
                case ( IDC_LANGUAGE_CJK ) :
                {
                    BOOL curState;

                    //
                    //  Verify the check box state.
                    //
                    if (IsDlgButtonChecked(hDlg, IDC_LANGUAGE_CJK))
                    {
#ifdef i386
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_CJK_INST,
                                 IDS_SUP_LANG_SUP_INST_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
#endif
#ifdef IA64
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_CJK_INST64,
                                 IDS_SUP_LANG_SUP_INST_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
#endif
                        curState = TRUE;
                    }
                    else
                    {
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_CJK_REM,
                                 IDS_SUP_LANG_SUP_REM_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
                        curState = FALSE;
                    }

                    //
                    //  Set the LG_CJK change flag.
                    //
                    if (curState != bCJKInitState)
                    {
                        lpPropSheet->lParam |= LG_CJK;
                        g_bInstallCJK = curState;
                        RegionalChgState |= Process_Languages;
                    }
                    else
                    {
                        lpPropSheet->lParam &= ~LG_CJK;
                        RegionalChgState &= ~Process_Languages;
                    }

                    //
                    //  Enable/Disable the avability of Collection dependant locale
                    //
                    if (curState)
                    {
                        Language_SetCollectionStatus(CJK_COLLECTION,
                        	                         ML_INSTALL,
                        	                         TRUE);
                        Language_SetCollectionStatus(CJK_COLLECTION,
                        	                         ~(ML_DISABLE | ML_REMOVE),
                        	                         FALSE);
                    }
                    else
                    {
                        Language_SetCollectionStatus(CJK_COLLECTION,
                        	                         (ML_DISABLE | ML_REMOVE),
                        	                         TRUE);
                        Language_SetCollectionStatus(CJK_COLLECTION,
                        	                         ~ML_INSTALL,
                        	                         FALSE);
                    }

                    //
                    //  Register that we changed the Complex Script and/or CJK
                    //  installation.  This will affect settings in other pages.  All
                    //  other changes to settings on this page do not affect other pages.
                    //
                    Verified_Regional_Chg |= (Process_Regional | Process_Advanced);
                    
                    break;
                }
                case ( IDC_LANGUAGE_COMPLEX ) :
                {
                    BOOL curState;

                    //
                    //  Verify the check box state.
                    //
                    if (IsDlgButtonChecked(hDlg, IDC_LANGUAGE_COMPLEX))
                    {
#ifdef i386
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_COMPLEX_INST,
                                 IDS_SUP_LANG_SUP_INST_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
#endif
#ifdef IA64
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_COMPLEX_INST64,
                                 IDS_SUP_LANG_SUP_INST_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
#endif
                        curState = TRUE;
                    }
                    else
                    {
                        ShowMsg( hDlg,
                                 IDS_SUP_LANG_SUP_COMPLEX_REM,
                                 IDS_SUP_LANG_SUP_REM_TITLE,
                                 MB_OK_OOPS,
                                 NULL );
                        curState = FALSE;
                    }

                    //
                    //  Set the LG_Complex change flag.
                    //
                    if (curState != bComplexInitState)
                    {
                        lpPropSheet->lParam |= LG_Complex;
                        g_bInstallComplex = curState;
                        RegionalChgState |= Process_Languages;
                    }
                    else
                    {
                        lpPropSheet->lParam &= ~LG_Complex;
                        RegionalChgState &= ~Process_Languages;
                    }
                    
                    //
                    //  Enable/Disable the avability of Collection dependant locale
                    //
                    if (curState)
                    {
                        Language_SetCollectionStatus(COMPLEX_COLLECTION,
                        	                         ML_INSTALL,
                        	                         TRUE);
                        Language_SetCollectionStatus(COMPLEX_COLLECTION,
                        	                         ~(ML_DISABLE | ML_REMOVE),
                        	                         FALSE);
                    }
                    else
                    {
                        Language_SetCollectionStatus(COMPLEX_COLLECTION,
                        	                         (ML_DISABLE | ML_REMOVE),
                        	                         TRUE);
                        Language_SetCollectionStatus(COMPLEX_COLLECTION,
                        	                         ~ML_INSTALL,
                        	                         FALSE);
                    }
                    
                    //
                    //  Register that we changed the Complex Script and/or CJK
                    //  installation.  This will affect settings in other pages.  All
                    //  other changes to settings on this page do not affect other pages.
                    //
                    Verified_Regional_Chg |= (Process_Regional | Process_Advanced);
                    
                    break;
                }
            }

            //
            //  Turn on ApplyNow button.
            //
            if (lpPropSheet->lParam > LG_EverChg)
            {
                PropSheet_Changed(GetParent(hDlg), hDlg);
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\cpls\intl\regdlg.c ===
/*++

Copyright (c) 1994-2000,  Microsoft Corporation  All rights reserved.

Module Name:

    regdlg.c

Abstract:

    This module implements the general property sheet for the Regional
    Options applet.

Revision History:


--*/



//
//  Include Files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "intl.h"
#include "winnlsp.h"
#include <windowsx.h>
#include <regstr.h>
#include <tchar.h>
#include <stdlib.h>
#include <setupapi.h>
#include <syssetup.h>
#include <winuserp.h>
#include <userenv.h>
#include "intlhlp.h"
#include "maxvals.h"
#include "util.h"

#define STRSAFE_LIB
#include <strsafe.h>


//
//  Constant Declarations.
//

#define MAX_CUSTOM_PAGES 5          // limit on number of second level pages

//
//  TEMPO
//
static TCHAR szLayoutFile[]    = TEXT("layout file");


//
//  Global Variables.
//
DWORD g_savedLocaleId;


//
//  Context Help Ids.
//

static int aRegionHelpIds[] =
{
    IDC_GROUPBOX1,        IDH_COMM_GROUPBOX,
    IDC_USER_LOCALE_TEXT, IDH_INTL_GEN_CULTURE,
    IDC_USER_LOCALE,      IDH_INTL_GEN_CULTURE,
    IDC_USER_REGION_TEXT, IDH_INTL_GEN_REGION,
    IDC_USER_REGION,      IDH_INTL_GEN_REGION,
    IDC_CUSTOMIZE,        IDH_INTL_GEN_CUSTOMIZE,
    IDC_SAMPLE_TEXT,      IDH_INTL_GEN_SAMPLE,
    IDC_TEXT1,            IDH_INTL_GEN_SAMPLE,
    IDC_TEXT2,            IDH_INTL_GEN_SAMPLE,
    IDC_TEXT3,            IDH_INTL_GEN_SAMPLE,
    IDC_TEXT4,            IDH_INTL_GEN_SAMPLE,
    IDC_TEXT5,            IDH_INTL_GEN_SAMPLE,
    IDC_TEXT6,            IDH_INTL_GEN_SAMPLE,
    IDC_NUMBER_SAMPLE,    IDH_INTL_GEN_SAMPLE,
    IDC_CURRENCY_SAMPLE,  IDH_INTL_GEN_SAMPLE,
    IDC_TIME_SAMPLE,      IDH_INTL_GEN_SAMPLE,
    IDC_SHRTDATE_SAMPLE,  IDH_INTL_GEN_SAMPLE,
    IDC_LONGDATE_SAMPLE,  IDH_INTL_GEN_SAMPLE,

    0, 0
};




//
//  Function Prototypes.
//

void
Region_ShowSettings(
    HWND hDlg,
    LCID lcid);

int
Region_CommandCustomize(
    HWND hDlg,
    LPREGDLGDATA pDlgData);


////////////////////////////////////////////////////////////////////////////
//
//  Region_EnumAlternateSorts
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_EnumAlternateSorts()
{
    LPLANGUAGEGROUP pLG;
    UINT ctr;

    //
    //  Initialize the globals for the alternate sort locales.
    //
    if (!pAltSorts)
    {
        if (!(hAltSorts = GlobalAlloc(GHND, MAX_PATH * sizeof(DWORD))))
        {
            return (FALSE);
        }
        pAltSorts = GlobalLock(hAltSorts);
    }

    //
    //  Reset the global counter so that we don't get duplicates each time
    //  this gets called.  We need to update the list each time in case any
    //  language groups get added or removed.
    //
    g_NumAltSorts = 0;

    //
    //  Go through the language groups to see which ones are installed.
    //  Save the alternate sorts for these language groups.
    //
    pLG = pLanguageGroups;
    while (pLG)
    {
        //
        //  If the language group is originally installed and not marked for
        //  removal OR is marked to be installed, then add the locales for
        //  this language group to the System and User combo boxes.
        //
        if (pLG->wStatus & ML_INSTALL)
        {
            for (ctr = 0; ctr < pLG->NumAltSorts; ctr++)
            {
                //
                //  Save the locale id.
                //
                if (g_NumAltSorts >= MAX_PATH)
                {
                    return (TRUE);
                }
                pAltSorts[g_NumAltSorts] = (pLG->pAltSortList)[ctr];
                g_NumAltSorts++;
            }
        }
        pLG = pLG->pNext;
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_EnableSortingPanel
//
////////////////////////////////////////////////////////////////////////////

void Region_EnableSortingPanel(
    HWND hDlg)
{
    LCID LocaleID;
    LANGID LangID;
    int ctr;
    int sortCount = 0;

    //
    //  Get the language id from the locale id.
    //
    LangID = LANGIDFROMLCID( UserLocaleID );

    //
    //  Special case Spanish (Spain) - list International sort first.
    //
    if ((LangID == LANG_SPANISH_TRADITIONAL) || (LangID == LANG_SPANISH_INTL))
    {
        g_bShowSortingTab = TRUE;
        return;
    }

    //
    //  Fill in the drop down if necessary.
    //
    for (ctr = 0; ctr < g_NumAltSorts; ctr++)
    {
        LocaleID = pAltSorts[ctr];
        if (LANGIDFROMLCID(LocaleID) == LangID)
        {
            sortCount++;
        }
    }

    //
    //  Enable the combo box if there is more than one entry in the list.
    //  Otherwise, disable it.
    //
    if (sortCount >= 1)
    {
        g_bShowSortingTab = TRUE;
    }
    else
    {
        g_bShowSortingTab = FALSE;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_SetRegionListValues
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_SetRegionListValues(
    GEOID GeoId,
    HWND handle)
{
    static HWND hUserRegion = NULL;
    DWORD dwIndex;
    WCHAR szBuf[SIZE_300];

    if (!GeoId)
    {
        hUserRegion = handle;
    }
    else if (hUserRegion)
    {
        if (GetGeoInfo(GeoId, GEO_FRIENDLYNAME, szBuf, SIZE_300, 0))
        {
            dwIndex = ComboBox_AddString(hUserRegion, szBuf);
            if (dwIndex != CB_ERR)
            {
                ComboBox_SetItemData(hUserRegion, dwIndex, GeoId);
            }
        }
    }
    else
    {
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_EnumProc
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_EnumProc(
    GEOID GeoId)
{
    return (Region_SetRegionListValues(GeoId, NULL));
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_EnumRegions
//
////////////////////////////////////////////////////////////////////////////

void Region_EnumRegions(
    HWND hUserRegion)
{
    //
    //  Fill in the UI.
    //
    Region_SetRegionListValues(0, hUserRegion);
    EnumSystemGeoID(GEOCLASS_NATION, 0, Region_EnumProc);
    Region_SetRegionListValues(0, NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_SaveValues
//
//  Save values in the case that we need to restore them.
//
////////////////////////////////////////////////////////////////////////////

void Region_SaveValues()
{
    //
    //  Save locale values.
    //
    g_savedLocaleId = RegUserLocaleID;
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_ApplyValues
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_ApplyValues(
    HWND hDlg,
    LPREGDLGDATA pDlgData)
{
    DWORD dwLocale;
    LCID NewLocale;
    HCURSOR hcurSave;
    HWND hUserLocale = GetDlgItem(hDlg, IDC_USER_LOCALE);

    //
    //  See if there are any changes.
    //
    if (pDlgData->Changes <= RC_EverChg)
    {
        return (TRUE);
    }

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  See if there are any changes to the user locale.
    //
    if (pDlgData->Changes & RC_UserLocale)
    {
        //
        //  Get the current selections.
        //
        dwLocale = ComboBox_GetCurSel(hUserLocale);

        //
        //  See if the current selections are different from the original
        //  selections.
        //
        if ((dwLocale != CB_ERR) && (dwLocale != pDlgData->dwCurUserLocale))
        {
            //
            //  Get the locale id for the current selection.
            //
            NewLocale = (LCID)ComboBox_GetItemData(hUserLocale, dwLocale);

            //
            //  Set the current locale values in the pDlgData structure.
            //
            pDlgData->dwCurUserLocale = dwLocale;

            //
            //  Save the new locale information.
            //
            UserLocaleID = NewLocale;
            bShowRtL = IsRtLLocale(UserLocaleID);
            bHebrewUI = (PRIMARYLANGID(UserLocaleID) == LANG_HEBREW);
            bShowArabic = (bShowRtL && (PRIMARYLANGID(LANGIDFROMLCID(UserLocaleID)) != LANG_HEBREW));

            //
            //  Install the new locale by adding the appropriate information
            //  to the registry.
            //
            Intl_InstallUserLocale( NewLocale, FALSE, TRUE);

            //
            //  Update the NLS process cache.
            //
            NlsResetProcessLocale();

            //
            //  Reset the registry user locale value.
            //
            RegUserLocaleID = UserLocaleID;
        }
    }

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_RestoreValues
//
////////////////////////////////////////////////////////////////////////////

void Region_RestoreValues()
{
    //
    //  See if the current selections are different from the original
    //  selections.
    //
    if (UserLocaleID != g_savedLocaleId)
    {
        //
        //  Install the new locale by adding the appropriate information
        //  to the registry.
        //
        Intl_InstallUserLocale(g_savedLocaleId, FALSE, TRUE);

        //
        //  Update the NLS process cache.
        //
        NlsResetProcessLocale();

        //
        //  Reset the registry user locale value.
        //
        UserLocaleID = g_savedLocaleId;
        RegUserLocaleID = g_savedLocaleId;

        //
        //  Need to make sure the proper keyboard layout is installed.
        //
        Intl_InstallKeyboardLayout(NULL, g_savedLocaleId, 0, FALSE, FALSE, FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_ClearValues
//
//  Reset each of the list boxes in the region property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Region_ClearValues(
    HWND hDlg)
{
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_USER_LOCALE));
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_USER_REGION));
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_SetValues
//
//  Initialize all of the controls in the region property sheet page.
//
////////////////////////////////////////////////////////////////////////////

void Region_SetValues(
    HWND hDlg,
    LPREGDLGDATA pDlgData,
    BOOL fInit)
{
    TCHAR szUserBuf[SIZE_128];
    GEOID geoID = GEOID_NOT_AVAILABLE;
    TCHAR szDefaultUserBuf[SIZE_128];
    TCHAR szLastUserBuf[SIZE_128];
    TCHAR szBuf[SIZE_128];
    DWORD dwIndex;
    HWND hUserLocale = GetDlgItem(hDlg, IDC_USER_LOCALE);
    HWND hUserRegion = GetDlgItem(hDlg, IDC_USER_REGION );
    DWORD dwItemCount;

    //
    //  Get the strings to search for in the combo boxes in order to set
    //  the current selections.
    //
    if (fInit)
    {
        //
        //  It's init time, so get the local user's default settings.
        //
        if ((UserLocaleID == LCID_SPANISH_TRADITIONAL) ||
            (UserLocaleID == LCID_SPANISH_INTL))
        {
            LoadString(hInstance, IDS_SPANISH_NAME, szUserBuf, SIZE_128);
        }
        else
        {
            GetLocaleInfo(UserLocaleID, LOCALE_SLANGUAGE, szUserBuf, SIZE_128);
        }

        //
        //  It's init time, so get the region user default settings.
        //
        geoID = GetUserGeoID(GEOCLASS_NATION);
    }
    else
    {
        //
        //  It's not init time, so get the settings from the combo boxes.
        //
        ComboBox_GetLBText( hUserLocale,
                            ComboBox_GetCurSel(hUserLocale),
                            szUserBuf );
        geoID = (GEOID)ComboBox_GetItemData( hUserRegion,
                                             ComboBox_GetCurSel(hUserRegion));

        if (pDlgData)
        {
            ComboBox_GetLBText( hUserLocale,
                                pDlgData->dwCurUserLocale,
                                szDefaultUserBuf );
            ComboBox_GetLBText( hUserLocale,
                                pDlgData->dwLastUserLocale,
                                szLastUserBuf );
        }
    }

    //
    //  Reset the combo boxes.
    //
    Region_ClearValues(hDlg);

    //
    //  Get the list of locales and fill in the user locale combo box.
    //
    Intl_EnumLocales(hDlg, hUserLocale, FALSE);

    //
    //  Select the current user locale id in the list.
    //  Special case Spanish.
    //
    dwIndex = ComboBox_FindStringExact(hUserLocale, -1, szUserBuf);
    if (dwIndex == CB_ERR)
    {
        szBuf[0] = 0;
        GetLocaleInfo(SysLocaleID, LOCALE_SLANGUAGE, szBuf, SIZE_128);
        dwIndex = ComboBox_FindStringExact(hUserLocale, -1, szBuf);
        if (dwIndex == CB_ERR)
        {
            GetLocaleInfo(US_LOCALE, LOCALE_SLANGUAGE, szBuf, SIZE_128);
            dwIndex = ComboBox_FindStringExact(hUserLocale, -1, szBuf);
            if (dwIndex == CB_ERR)
            {
                dwIndex = 0;
            }
        }
        if (!fInit && pDlgData)
        {
            pDlgData->Changes |= RC_UserLocale;
        }
    }
    ComboBox_SetCurSel(hUserLocale, dwIndex);

    //
    //  Get the list of regions and fill in the region combo box.
    //
    Region_EnumRegions(hUserRegion);

    //
    //  Select the current user region in the list.
    //
    dwItemCount = (DWORD)ComboBox_GetCount(hUserRegion);
    dwIndex = 0;
    while(dwIndex < dwItemCount)
    {
        if (ComboBox_GetItemData(hUserRegion,dwIndex) == geoID)
        {
            ComboBox_SetCurSel(hUserRegion, dwIndex);
            break;
        }
        dwIndex++;
    }

    //
    //  If it's fail, try with User Locale.
    //
    if(dwIndex >= dwItemCount)
    {
        //
        //  Get the GEOID associated with the User Locale.
        //
        szBuf[0] = 0;
        GetLocaleInfo(UserLocaleID, LOCALE_IGEOID | LOCALE_RETURN_NUMBER, szBuf, SIZE_128);
        geoID = *((LPDWORD)szBuf);

        //
        //  Search for it...
        //
        dwIndex = 0;
        while(dwIndex < dwItemCount)
        {
            if (ComboBox_GetItemData(hUserRegion,dwIndex) == geoID)
            {
                //
                //  Note:
                //  Mark this as being changed so that the region will be set
                //  when the user hits apply.  This avoids the problem of having
                //  the region change every time the user closes and reopens the
                //  applet after changing the user locale.
                //
                if (pDlgData)
                {
                    pDlgData->Changes |= RC_UserRegion;
                }
                ComboBox_SetCurSel(hUserRegion, dwIndex);
                break;
            }
            dwIndex++;
        }
    }

    //
    //  If it's fail, try with System Locale.
    //
    if(dwIndex >= dwItemCount)
    {
        //
        //  Get the GEOID associated with the User Locale.
        //
        szBuf[0] = 0;
        GetLocaleInfo(SysLocaleID, LOCALE_IGEOID | LOCALE_RETURN_NUMBER, szBuf, SIZE_128);
        geoID = *((LPDWORD)szBuf);

        //
        //  Search for it...
        //
        dwIndex = 0;
        while(dwIndex < dwItemCount)
        {
            if (ComboBox_GetItemData(hUserRegion,dwIndex) == geoID)
            {
                //
                //  Note:
                //  Mark this as being changed so that the region will be set
                //  when the user hits apply.  This avoids the problem of having
                //  the region change every time the user closes and reopens the
                //  applet after changing the user locale.
                //
                if (pDlgData)
                {
                    pDlgData->Changes |= RC_UserRegion;
                }
                ComboBox_SetCurSel(hUserRegion, dwIndex);
                break;
            }
            dwIndex++;
        }
    }

    //
    //  If it's fail, try with US Locale.
    //
    if(dwIndex >= dwItemCount)
    {
        //
        //  Get the GEOID associated with the User Locale.
        //
        szBuf[0] = 0;
        GetLocaleInfo(US_LOCALE, LOCALE_IGEOID | LOCALE_RETURN_NUMBER, szBuf, SIZE_128);
        geoID = *((LPDWORD)szBuf);

        //
        //  Search for it...
        //
        dwIndex = 0;
        while(dwIndex >= dwItemCount)
        {
            if (ComboBox_GetItemData(hUserRegion,dwIndex) == geoID)
            {
                //
                //  Note:
                //  Mark this as being changed so that the region will be set
                //  when the user hits apply.  This avoids the problem of having
                //  the region change every time the user closes and reopens the
                //  applet after changing the user locale.
                //
                if (pDlgData)
                {
                    pDlgData->Changes |= RC_UserRegion;
                }
                ComboBox_SetCurSel(hUserRegion, dwIndex);
                break;
            }
            dwIndex++;
        }
    }

    //
    //  If it's fail, set to the first item.
    //
    if(dwIndex >= dwItemCount)
    {
        //
        //  Note:
        //  Mark this as being changed so that the region will be set
        //  when the user hits apply.  This avoids the problem of having
        //  the region change every time the user closes and reopens the
        //  applet after changing the user locale.
        //
        if (pDlgData)
        {
            pDlgData->Changes |= RC_UserRegion;
        }
        ComboBox_SetCurSel(hUserRegion, 0);
    }

    //
    //  Store the initial locale state in the pDlgData structure.
    //
    if (pDlgData)
    {
        //
        //  Set the current user locale and the last user locale.
        //
        if (fInit)
        {
            pDlgData->dwCurUserLocale = ComboBox_GetCurSel(hUserLocale);
            pDlgData->dwLastUserLocale = pDlgData->dwCurUserLocale;
        }
        else
        {
            pDlgData->dwCurUserLocale =  ComboBox_FindStringExact(hUserLocale, -1, szDefaultUserBuf);
            pDlgData->dwLastUserLocale = ComboBox_FindStringExact(hUserLocale, -1, szLastUserBuf);
        }

        //
        //  Set the current region selection.
        //
        //  Note:  The current region is only set if there is actually
        //         a region set in the registry.  Otherwise, if the
        //         selection is based off of the user locale, then we
        //         don't set this so that it will get set when the user
        //         hits Apply.  See above note.
        //
        if (pDlgData->Changes & RC_UserRegion)
        {
            pDlgData->dwCurUserRegion = CB_ERR;
        }
        else
        {
            pDlgData->dwCurUserRegion = ComboBox_GetCurSel(hUserRegion);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_RevertChanges
//
//  If the user has changed something at the second level, call
//  Set_Locale_Values to restore the user locale information.
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_RevertChanges()
{
    HCURSOR hcurSave;

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor( LoadCursor(NULL, IDC_WAIT) );

    //
    //  Revert any changes.
    //
    if (g_dwCustChange)
    {
        DWORD dwRecipients;

        //
        //  Revert changes.
        //
        Date_RestoreValues();
        Currency_RestoreValues();
        Time_RestoreValues();
        Number_RestoreValues();
        Sorting_RestoreValues();
    }

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_ApplySettings
//
//  If the Locale has changed, call Set_Locale_Values to update the
//  user locale information.   Notify the parent of changes and reset the
//  change flag stored in the property sheet page structure appropriately.
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_ApplySettings(
    HWND hDlg,
    LPREGDLGDATA pDlgData)
{
    DWORD dwLocale, dwRegion;
    LCID NewLocale;
    GEOID CurGeoID;
    HCURSOR hcurSave;
    HWND hUserLocale = GetDlgItem(hDlg, IDC_USER_LOCALE);
    HWND hUserRegion = GetDlgItem(hDlg, IDC_USER_REGION);
    DWORD dwRecipients;
    LPLANGUAGEGROUP pLG;
    BOOL bState, fUserCancel = FALSE;
    LVITEM lvItem;
    int iIndex=0, cCount=0;
    BOOL bBroadcast = FALSE;

    //
    //  See if there are any changes.
    //
    if ((pDlgData->Changes <= RC_EverChg) && (g_dwCustChange == 0L))
    {
        return (TRUE);
    }

    //
    //  Check if the second level has changed.
    //
    if (g_dwCustChange)
    {
        bBroadcast = TRUE;
    }

    //
    //  Put up the hour glass.
    //
    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  See if there are any changes to the user locale.
    //
    if (pDlgData->Changes & RC_UserLocale)
    {
        //
        //  Need to make sure the proper keyboard layout is installed.
        //
        Intl_InstallKeyboardLayout(hDlg, UserLocaleID, 0, FALSE, FALSE, FALSE);

        //
        //  We need to broadcast the change
        //
        bBroadcast = TRUE;
    }

    //
    //  See if there are any changes to the user region.
    //
    if (pDlgData->Changes & RC_UserRegion)
    {
        //
        //  Get the current selection.
        //
        dwRegion = (GEOID)ComboBox_GetCurSel(hUserRegion);

        //
        //  See if the current selection is different from the original
        //  selection.
        //
        if ((dwRegion != CB_ERR) && ((dwRegion != pDlgData->dwCurUserRegion)))
        {
            //
            //  Get the Region for the current selection.
            //
            CurGeoID = (GEOID)ComboBox_GetItemData(hUserRegion, dwRegion);

            //
            //  Set the current Region value in the pDlgData structure.
            //
            pDlgData->dwCurUserRegion = dwRegion;

            //
            //  Set the Region value in the user's registry.
            //
            SetUserGeoID(CurGeoID);
        }
    }

    //
    //  Broadcast the message that the international settings in the
    //  registry have changed.
    //
    if (bBroadcast)
    {
        dwRecipients = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
        BroadcastSystemMessage( BSF_FORCEIFHUNG | BSF_IGNORECURRENTTASK |
                                  BSF_NOHANG | BSF_NOTIMEOUTIFNOTHUNG,
                                &dwRecipients,
                                WM_WININICHANGE,
                                0,
                                (LPARAM)szIntl );
    }

    //
    //  Reset the property page settings.
    //
    PropSheet_UnChanged(GetParent(hDlg), hDlg);
    pDlgData->Changes = RC_EverChg;

    //
    //  Turn off the hour glass.
    //
    SetCursor(hcurSave);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_ValidatePPS
//
//  Validate each of the combo boxes whose values are constrained.
//  If any of the input fails, notify the user and then return FALSE
//  to indicate validation failure.
//
//  Also, if the user locale has changed, then register the change so
//  that all other property pages will be updated with the new locale
//  settings.
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_ValidatePPS(
    HWND hDlg,
    LPREGDLGDATA pDlgData)
{
    LPARAM Changes = pDlgData->Changes;

    //
    //  If nothing has changed, return TRUE immediately.
    //
    if (Changes <= RC_EverChg)
    {
        return (TRUE);
    }

    //
    //  See if the user locale has changed.
    //
    if (Changes & RC_UserLocale)
    {
        HWND hUserLocale = GetDlgItem(hDlg, IDC_USER_LOCALE);
        DWORD dwLocale = ComboBox_GetCurSel(hUserLocale);
        LCID NewLocale;

        //
        //  See if the current selections are different from the original
        //  selections.
        //
        if ((dwLocale != CB_ERR) && (dwLocale != pDlgData->dwLastUserLocale))
        {
            //
            //  Get the locale id for the current selection.
            //
            NewLocale = (LCID)ComboBox_GetItemData(hUserLocale, dwLocale);

            //
            //  Set the current locale values in the pDlgData structure.
            //
            pDlgData->dwLastUserLocale = dwLocale;

            //
            //  Set the UserLocaleID value.
            //
            UserLocaleID = NewLocale;
            bShowRtL    = IsRtLLocale(UserLocaleID);
            bHebrewUI = (PRIMARYLANGID(UserLocaleID) == LANG_HEBREW);
            bShowArabic = (bShowRtL && (PRIMARYLANGID(LANGIDFROMLCID(UserLocaleID)) != LANG_HEBREW));
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_InitPropSheet
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_InitPropSheet(
    HWND hDlg,
    LPPROPSHEETPAGE psp)
{
    LPREGDLGDATA pDlgData = (LPREGDLGDATA)LocalAlloc(LPTR, sizeof(REGDLGDATA));

    //
    //  Make sure we have a REGDLGDATA buffer.
    //
    if (pDlgData == NULL)
    {
        return (FALSE);
    }

    //
    //  See if we're in setup mode.
    //
    if (g_bSetupCase)
    {
        //
        //  Use the registry system locale value for the setup case.
        //
        SysLocaleID = RegSysLocaleID;

        //
        //  Use the registry user locale value for the setup case.
        //
        UserLocaleID = RegUserLocaleID;
        bShowRtL = IsRtLLocale(UserLocaleID);
        bHebrewUI = (PRIMARYLANGID(UserLocaleID) == LANG_HEBREW);
        bShowArabic = (bShowRtL && (PRIMARYLANGID(LANGIDFROMLCID(UserLocaleID)) != LANG_HEBREW));
    }

    //
    //  Save the data.
    //
    psp->lParam = (LPARAM)pDlgData;
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)psp);

    //
    //  Load the information into the dialog.
    //
    if (pLanguageGroups == NULL)
    {
        Intl_LoadLanguageGroups(hDlg);
    }
    Region_SetValues(hDlg, pDlgData, TRUE);
    Region_ShowSettings(hDlg, UserLocaleID);

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_FreeGlobalInfo
//
//  Processing for a WM_DESTROY message.
//
////////////////////////////////////////////////////////////////////////////

void Region_FreeGlobalInfo()
{
    LPLANGUAGEGROUP pPreLG, pCurLG;
    HANDLE hAlloc;

    //
    //  Remove Language Group info.
    //
    pCurLG = pLanguageGroups;
    pLanguageGroups = NULL;

    while (pCurLG)
    {
        pPreLG = pCurLG;
        pCurLG = pPreLG->pNext;
        hAlloc = pPreLG->hLanguageGroup;
        GlobalUnlock(hAlloc);
        GlobalFree(hAlloc);
    }

    //
    //  Remove Alternate Sorts info.
    //
    g_NumAltSorts = 0;
    pAltSorts = NULL;
    GlobalUnlock(hAltSorts);
    GlobalFree(hAltSorts);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_CommandCustomize
//
////////////////////////////////////////////////////////////////////////////

int Region_CommandCustomize(
    HWND hDlg,
    LPREGDLGDATA pDlgData)
{
    int rc = 0;
    HPROPSHEETPAGE rPages[MAX_CUSTOM_PAGES];
    PROPSHEETHEADER psh;
    LPARAM lParam = 0;

    //
    //  Start at the first page.
    //
    psh.nStartPage = 0;

    //
    //  Set up the property sheet information.
    //
    psh.dwSize = sizeof(psh);
    psh.dwFlags = 0;
    psh.hwndParent = hDlg;
    psh.hInstance = hInstance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_NAME_CUSTOM);
    psh.nPages = 0;
    psh.phpage = rPages;

    //
    //  Add the appropriate property pages.
    //
    Intl_AddPage(&psh, DLG_NUMBER, NumberDlgProc, lParam, MAX_CUSTOM_PAGES);
    Intl_AddPage(&psh, DLG_CURRENCY, CurrencyDlgProc, lParam, MAX_CUSTOM_PAGES);
    Intl_AddPage(&psh, DLG_TIME, TimeDlgProc, lParam, MAX_CUSTOM_PAGES);
    Intl_AddPage(&psh, DLG_DATE, DateDlgProc, lParam, MAX_CUSTOM_PAGES);
    if (g_bShowSortingTab)
    {
        Intl_AddPage(&psh, DLG_SORTING, SortingDlgProc, lParam, MAX_CUSTOM_PAGES);
    }

    //
    //  Make the property sheet.
    //
    PropertySheet(&psh);

    //
    //  Return the result.
    //
    return (rc);
}

////////////////////////////////////////////////////////////////////////////
//
//  Region_ShowSettings
//
////////////////////////////////////////////////////////////////////////////

void Region_ShowSettings(
    HWND hDlg,
    LCID lcid)
{
    WCHAR szBuf[MAX_SAMPLE_SIZE];

    //
    //  Show Number Sample.
    //
    if (GetNumberFormat(lcid, 0, szSample_Number, NULL, szBuf, MAX_SAMPLE_SIZE))
    {
        SetDlgItemText(hDlg, IDC_NUMBER_SAMPLE, szBuf);
    }
    else
    {
        SetDlgItemText(hDlg, IDC_NUMBER_SAMPLE, L"");
    }

    //
    //  Show Currency Sample.
    //
    if (GetCurrencyFormat(lcid, 0, szSample_Number, NULL, szBuf, MAX_SAMPLE_SIZE))
    {
        SetDlgItemText(hDlg, IDC_CURRENCY_SAMPLE, szBuf);
    }
    else
    {
        SetDlgItemText(hDlg, IDC_CURRENCY_SAMPLE, L"");
    }

    //
    //  Show Time Sample.
    //
    if (GetTimeFormat(lcid, 0, NULL, NULL, szBuf, MAX_SAMPLE_SIZE))
    {
        SetDlgItemText(hDlg, IDC_TIME_SAMPLE, szBuf);
    }
    else
    {
        SetDlgItemText(hDlg, IDC_TIME_SAMPLE, L"");
    }

    //
    //  Show Short Date Sample.
    //
    if (bShowArabic)
    {
        if (GetDateFormat( lcid,
                           DATE_RTLREADING | DATE_SHORTDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_SHRTDATE_SAMPLE, szBuf);
        }
        else
        {
            SetDlgItemText(hDlg, IDC_SHRTDATE_SAMPLE, L"");
        }
    }
    else
    {
        // If user locale is not Arabic, make sure that the controls for date samples are:
        //  * LTR reading orders for non-Hebrew locales
        //  * RTL reading orders for Hebrew locales.
        SetControlReadingOrder(bHebrewUI, GetDlgItem(hDlg, IDC_SHRTDATE_SAMPLE));
        if (GetDateFormat( lcid,
                          (bShowRtL ? DATE_LTRREADING : 0) | DATE_SHORTDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_SHRTDATE_SAMPLE, szBuf);
        }
        else
        {
            SetDlgItemText(hDlg, IDC_SHRTDATE_SAMPLE, L"");
        }
    }

    //
    //  Show Long Date Sample.
    //
    if (bShowArabic)
    {
        if (GetDateFormat( lcid,
                           DATE_RTLREADING | DATE_LONGDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_LONGDATE_SAMPLE, szBuf);
        }
        else
        {
            SetDlgItemText(hDlg, IDC_LONGDATE_SAMPLE, L"");
        }
    }
    else
    {
        // If user locale is not Arabic, make sure that the control for date samples are:
        //  * LTR reading orders for non-Hebrew locales
        //  * RTL reading orders for Hebrew locales.
        SetControlReadingOrder(bHebrewUI, GetDlgItem(hDlg, IDC_LONGDATE_SAMPLE));
        if (GetDateFormat( lcid,
                           (bHebrewUI ? DATE_RTLREADING :
                             (bShowRtL ? DATE_LTRREADING : 0)) | DATE_LONGDATE,
                           NULL,
                           NULL,
                           szBuf,
                           MAX_SAMPLE_SIZE ))
        {
            SetDlgItemText(hDlg, IDC_LONGDATE_SAMPLE, szBuf);
        }
        else
        {
            SetDlgItemText(hDlg, IDC_LONGDATE_SAMPLE, L"");
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GeneralDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK GeneralDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE)(GetWindowLongPtr(hDlg, DWLP_USER));
    LPREGDLGDATA pDlgData = lpPropSheet ? (LPREGDLGDATA)lpPropSheet->lParam : NULL;

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            if (!Region_InitPropSheet( hDlg, (LPPROPSHEETPAGE)lParam))
            {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
            Region_SaveValues();
            break;
        }
        case ( WM_DESTROY ) :
        {
            Region_FreeGlobalInfo();
            if (pDlgData)
            {
                lpPropSheet->lParam = 0;
                LocalFree((HANDLE)pDlgData);
            }
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     szHelpFile,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aRegionHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     szHelpFile,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aRegionHelpIds );
            break;
        }
        case ( WM_NOTIFY ) :
        {
            LPNMHDR psn = (NMHDR *)lParam;
            switch (psn->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    //
                    //  If there has been a change in the regional Locale
                    //  setting, clear all of the current info in the
                    //  property sheet, get the new values, and update the
                    //  appropriate registry values.
                    //
                    if (Verified_Regional_Chg & Process_Regional)
                    {
                        Verified_Regional_Chg &= ~Process_Regional;
                        Region_SetValues(hDlg, pDlgData, FALSE);
                        Region_ShowSettings(hDlg, UserLocaleID);
                    }
                    break;
                }
                case ( PSN_RESET ) :
                {
                    //
                    // Revert any changes made
                    //
                    if (g_bCustomize)
                    {
                        Region_RevertChanges();
                        g_bCustomize = FALSE;
                    }
                    Region_RestoreValues();
                    break;
                }
                case ( PSN_KILLACTIVE ) :
                {
                    //
                    //  Validate the entries on the property page.
                    //
                    if (pDlgData)
                    {
                        SetWindowLongPtr( hDlg,
                                          DWLP_MSGRESULT,
                                          !Region_ValidatePPS(hDlg, pDlgData) );
                    }
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    if (pDlgData)
                    {
                        //
                        //  Apply the settings.
                        //
                        if (Region_ApplySettings(hDlg, pDlgData))
                        {
                            SetWindowLongPtr( hDlg,
                                              DWLP_MSGRESULT,
                                              PSNRET_NOERROR );
                            //
                            //  Check if we need to do something for the
                            //  default user.
                            //
                            if (g_bDefaultUser)
                            {
                                g_bSettingsChanged = TRUE;
                                Intl_SaveDefaultUserSettings();
                            }
                            else if(2 == g_bSetupCase)
                            {
                                //
                                //  Intl_SaveDefaultUserSettings is destructive to NLS settings  
                                //  in minisetup mode; call the MUI function directly here.
                                //
                                Intl_ChangeUILangForAllUsers(Intl_GetPendingUILanguage());
                            }

                            //
                            //  Zero out the RC_EverChg bit.
                            //
                            pDlgData->Changes = 0;

                            //
                            //  Save the new user locale.
                            //
                            Region_SaveValues();

                            //
                            //  Update settings.
                            //
                            Region_ShowSettings(hDlg, UserLocaleID);
                        }
                        else
                        {
                            SetWindowLongPtr( hDlg,
                                              DWLP_MSGRESULT,
                                              PSNRET_INVALID_NOCHANGEPAGE );
                        }
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }

            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDC_USER_LOCALE ) :
                {
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        if (pDlgData)
                        {
                            //
                            //  User locale has changed.
                            //
                            pDlgData->Changes |= RC_UserLocale;

                            //
                            //  Apply second level changes.
                            //
                            Region_ApplyValues(hDlg, pDlgData);

                            //
                            //  Update settings.
                            //
                            Region_ShowSettings(hDlg, UserLocaleID);
                        }
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                    break;
                }
                case ( IDC_USER_REGION ) :
                {
                    //
                    //  See if it's a selection change.
                    //
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        if (pDlgData)
                        {
                            pDlgData->Changes |= RC_UserRegion;
                        }
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                    break;
                }
                case ( IDC_CUSTOMIZE ) :
                {
                    //
                    //  Show second level tabs.
                    //
                    g_bCustomize = TRUE;
                    Region_EnumAlternateSorts();
                    Region_EnableSortingPanel(hDlg);
                    Region_CommandCustomize(hDlg, pDlgData);

                    //
                    //  Update Settings.
                    //
                    if (g_dwCustChange)
                    {
                        Region_ShowSettings(hDlg, UserLocaleID);
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }

                    break;
                }
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_InstallSystemLocale
//
////////////////////////////////////////////////////////////////////////////

BOOL Region_InstallSystemLocale(
    LCID Locale)
{
    //
    //  Make sure the locale is valid and then call setup to install the
    //  requested locale.
    //
    if (IsValidLocale(Locale, LCID_INSTALLED))
    {
        if (!SetupChangeLocaleEx( HWND_DESKTOP,
                                  LOWORD(Locale),
                                  pSetupSourcePath,
                                  SP_INSTALL_FILES_QUIETLY,
                                  NULL,
                                  0 ))
        {
            //
            //  Check if we need to proceed with the Font Substitution
            //
            if (Intl_IsUIFontSubstitute() &&
                ((LANGID)LANGIDFROMLCID(Locale) == Intl_GetDotDefaultUILanguage()))
            {
                Intl_ApplyFontSubstitute(Locale);
            }

            //
            //  Log system locale change.
            //
            Intl_LogSimpleMessage(IDS_LOG_SYS_LOCALE_CHG, NULL);

            //
            //  Update current SysLocale, so we can use it later.
            //
            SysLocaleID = LOWORD(Locale);

            //
            //  Return success.
            //
            return (TRUE);
        }
        else
        {
            //
            //  This can happen if the user hits Cancel from
            //  within the setup dialog.
            //
            Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
        }
    }
    else
    {
        //
        //  Log invalid locale info.
        //
        Intl_LogSimpleMessage(IDS_LOG_INVALID_LOCALE, NULL);
    }

    //
    //  Return failure.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Region_UpdateShortDate
//
//  Updates the user's short date setting to contain a 4-digit year.
//  The setting is only updated if it is the same as the default setting
//  for the current locale (except for the 2-digit vs. 4-digit year).
//
////////////////////////////////////////////////////////////////////////////

void Region_UpdateShortDate()
{
    TCHAR szBufCur[SIZE_64];
    TCHAR szBufDef[SIZE_64];
    LPTSTR pCur, pDef;
    BOOL bChange = FALSE;

    //
    //  Get the current short date format setting and the default short date
    //  format setting.
    //
    if ((GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_SSHORTDATE,
                        szBufCur,
                        SIZE_64 )) &&
        (GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_SSHORTDATE | LOCALE_NOUSEROVERRIDE,
                        szBufDef,
                        SIZE_64 )))
    {
        //
        //  See if the current setting and the default setting only differ
        //  in a 2-digit year ("yy") vs. a 4-digit year ("yyyy").
        //
        //  Note: For this, we want an Exact match, so we don't need to
        //        use CompareString to compare the formats.
        //
        pCur = szBufCur;
        pDef = szBufDef;
        while ((*pCur) && (*pCur == *pDef))
        {
            //
            //  See if it's a 'y'.
            //
            if (*pCur == CHAR_SML_Y)
            {
                if (((*(pCur + 1)) == CHAR_SML_Y) &&
                    ((*(pDef + 1)) == CHAR_SML_Y) &&
                    ((*(pDef + 2)) == CHAR_SML_Y) &&
                    ((*(pDef + 3)) == CHAR_SML_Y))
                {
                    bChange = TRUE;
                    pCur += 1;
                    pDef += 3;
                }
            }
            pCur++;
            pDef++;
        }

        //
        //  Set the default short date format as the user's setting.
        //
        if (bChange && (*pCur == *pDef))
        {
            SetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, szBufDef);
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  Region_DoUnattendModeSetup
//
//  NOTE: The unattend mode file contains strings rather than integer
//        values, so we must get the string field and then convert it
//        to the appropriate integer format.  The Setup APIs won't just
//        do the right thing, so we have to roll our own.
//
////////////////////////////////////////////////////////////////////////////

void Region_DoUnattendModeSetup(
    LPCTSTR pUnattendFile)
{
    HINF hFile, hIntlInf;
    HSPFILEQ FileQueue;
    PVOID QueueContext;
    INFCONTEXT Context;
    DWORD dwNum, dwCtr, dwLocale, dwLayout;
    UINT LanguageGroup, Language, SystemLocale, UserLocale;
    UINT UserLocale_DefUser = 0;
    LANGID MUILanguage, MUILanguage_DefUser;
    TCHAR szBuffer[MAX_PATH];
    DWORD dwLocaleACP = 0UL;
    BOOL bWinntUpgrade;
    BOOL bFound = FALSE;
    BOOL bFound_DefUser = FALSE;
    BOOL bLangGroup = FALSE;
    TCHAR szLCID[25];
    BOOL bInstallBasic = FALSE;
    BOOL bInstallComplex = FALSE;
    BOOL bInstallExt = FALSE;

    //
    //  Log the unattended file content.
    //
    if (g_bSetupCase)
    {
        TCHAR szPath[MAX_PATH * 2] = {0};

        //
        //  We are in setup mode.  No need to log the unattended mode file
        //  because the file is located in the system directory and named
        //  $winnt$.inf.
        //
        GetSystemDirectory(szPath, MAX_PATH);
        //_tcscat(szPath, TEXT("\\$winnt$.inf"));
        if(SUCCEEDED(StringCchCopy(szPath, ARRAYSIZE(szPath), TEXT("\\$winnt$.inf"))))
        {
            Intl_LogSimpleMessage(IDS_LOG_UNAT_LOCATED, szPath);
        }
    }
    else
    {
        Intl_LogUnattendFile(pUnattendFile);
    }

    //
    //  Open the unattend mode file.
    //
    hFile = SetupOpenInfFile(pUnattendFile, NULL, INF_STYLE_OLDNT, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        Intl_LogFormatMessage(IDS_LOG_FILE_ERROR);
        return;
    }

    //
    //  Check if we're doing an upgrade or fresh install.
    //
    bWinntUpgrade = Intl_IsWinntUpgrade();

    //
    //  Install the Basic Collection upfront when we are in setup.
    //
    if (g_bSetupCase)
    {
        //
        //  Open the intl.inf file.
        //
        if (!Intl_InitInf(0, &hIntlInf, szIntlInf, &FileQueue, &QueueContext))
        {
            SetupCloseInfFile(hFile);
            return;
        }

        if (!SetupInstallFilesFromInfSection( hIntlInf,
                                              NULL,
                                              FileQueue,
                                              szLGBasicInstall,
                                              pSetupSourcePath,
                                              SP_COPY_NEWER ))
        {
            Intl_LogFormatMessage(IDS_LOG_SETUP_ERROR);
            goto Region_UnattendModeExit;
        }
        else
        {
            //
            //  See if we need to install any files.
            //
            if ((SetupScanFileQueue( FileQueue,
                                     SPQ_SCAN_PRUNE_COPY_QUEUE |
                                       SPQ_SCAN_FILE_VALIDITY,
                                     HWND_DESKTOP,
                                     NULL,
                                     NULL,
                                     &dwCtr )) && (dwCtr != 1))
            {
                //
                //  Copy the files in the queue.
                //
                if (!SetupCommitFileQueue( NULL,
                                           FileQueue,
                                           Intl_MyQueueCallback,
                                           QueueContext ))
                {
                    //
                    //  This can happen if the user hits Cancel from
                    //  within the setup dialog.
                    //
                    Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                    goto Region_UnattendModeExit;
                }
            }

            //
            //  Call setup to install other inf info for the various
            //  language groups.
            //
            if (!SetupInstallFromInfSection( NULL,
                                             hIntlInf,
                                             szLGBasicInstall,
                                             SPINST_ALL & ~SPINST_FILES,
                                             NULL,
                                             pSetupSourcePath,
                                             0,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL ))
            {
                //
                //  This can happen if the user hits Cancel from
                //  within the setup dialog.
                //
                Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                goto Region_UnattendModeExit;
            }
        }

        //
        //  Close the inf file.
        //
        Intl_CloseInf(hIntlInf, FileQueue, QueueContext);
    }

    //
    //  Open the intl.inf file.
    //
    if (!Intl_InitInf(0, &hIntlInf, szIntlInf, &FileQueue, &QueueContext))
    {
        SetupCloseInfFile(hFile);
        return;
    }

    //
    //  Install all requested Language Groups.
    //
    if ((SetupFindFirstLine( hFile,
                             szRegionalSettings,
                             szLanguageGroup,
                             &Context )) &&
        (dwNum = SetupGetFieldCount(&Context)))
    {
        bLangGroup = TRUE;

        //
        //  Check for admin privilege.
        //
        if (g_bAdmin_Privileges)
        {
            for (dwCtr = 1; dwCtr <= dwNum; dwCtr++)
            {
                if (SetupGetStringField(&Context, dwCtr, szBuffer, MAX_PATH, NULL))
                {
                    //
                    //  Log language group info.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_LANG_GROUP, szBuffer);

                    //
                    //  Get the Language Group as an integer.
                    //
                    LanguageGroup = Intl_StrToLong(szBuffer);

                    //
                    //  See which language collections need to be installed.
                    //
                    if ((LanguageGroup == LGRPID_JAPANESE) ||
                        (LanguageGroup == LGRPID_KOREAN) ||
                        (LanguageGroup == LGRPID_TRADITIONAL_CHINESE) ||
                        (LanguageGroup == LGRPID_SIMPLIFIED_CHINESE))
                    {
                        bInstallExt = TRUE;
                    }
                    else if ((LanguageGroup == LGRPID_ARABIC) ||
                             (LanguageGroup == LGRPID_ARMENIAN) ||
                             (LanguageGroup == LGRPID_GEORGIAN) ||
                             (LanguageGroup == LGRPID_HEBREW) ||
                             (LanguageGroup == LGRPID_INDIC) ||
                             (LanguageGroup == LGRPID_VIETNAMESE) ||
                             (LanguageGroup == LGRPID_THAI))
                    {
                        bInstallComplex = TRUE;
                    }
                    else
                    {
                        bInstallBasic = TRUE;
                    }
                }
            }

            //
            //  Enqueue the appropriate language group files so that they
            //  may be copied.  This only handles the CopyFiles entries in
            //  the inf file.
            //

            //
            //  CJK Collection.
            //
            if (bInstallExt)
            {
                if (!SetupInstallFilesFromInfSection( hIntlInf,
                                                      NULL,
                                                      FileQueue,
                                                      szLGExtInstall,
                                                      pSetupSourcePath,
                                                      SP_COPY_NEWER ))
                {
                    bInstallExt = FALSE;
                    Intl_LogFormatMessage(IDS_LOG_SETUP_ERROR);
                    goto Region_UnattendModeExit;
                }
            }

            //
            //  Complex Scripts Collection.
            //
            if (bInstallComplex)
            {
                if (!SetupInstallFilesFromInfSection( hIntlInf,
                                                      NULL,
                                                      FileQueue,
                                                      szLGComplexInstall,
                                                      pSetupSourcePath,
                                                      SP_COPY_NEWER ))
                {
                    bInstallComplex = FALSE;
                    Intl_LogFormatMessage(IDS_LOG_SETUP_ERROR);
                    goto Region_UnattendModeExit;
                }
            }

            //
            //  Basic Collection.
            //
            //  Only install the Basic Collection if we're not in setup
            //  mode.  If we're in setup mode, this was already done above.
            //
            if (bInstallBasic && (!g_bSetupCase))
            {
                if (!SetupInstallFilesFromInfSection( hIntlInf,
                                                      NULL,
                                                      FileQueue,
                                                      szLGBasicInstall,
                                                      pSetupSourcePath,
                                                      SP_COPY_NEWER ))
                {
                    bInstallBasic = FALSE;
                    Intl_LogFormatMessage(IDS_LOG_SETUP_ERROR);
                    goto Region_UnattendModeExit;
                }
            }

            //
            //  See if we need to install any files.
            //
            if ((SetupScanFileQueue( FileQueue,
                                     SPQ_SCAN_PRUNE_COPY_QUEUE |
                                       SPQ_SCAN_FILE_VALIDITY,
                                     HWND_DESKTOP,
                                     NULL,
                                     NULL,
                                     &dwCtr )) && (dwCtr != 1))
            {
                //
                //  Copy the files in the queue.
                //
                if (!SetupCommitFileQueue( NULL,
                                           FileQueue,
                                           Intl_MyQueueCallback,
                                           QueueContext ))
                {
                    //
                    //  This can happen if the user hits Cancel from
                    //  within the setup dialog.
                    //
                    Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                    goto Region_UnattendModeExit;
                }
            }

            //
            //  Call setup to install other inf info for the various
            //  language groups.
            //
            if (bInstallExt)
            {
                if (!SetupInstallFromInfSection( NULL,
                                                 hIntlInf,
                                                 szLGExtInstall,
                                                 SPINST_ALL & ~SPINST_FILES,
                                                 NULL,
                                                 pSetupSourcePath,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL ))
                {
                    //
                    //  This can happen if the user hits Cancel from
                    //  within the setup dialog.
                    //
                    Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                    goto Region_UnattendModeExit;
                }
            }

            if (bInstallComplex)
            {
                if (!SetupInstallFromInfSection( NULL,
                                                 hIntlInf,
                                                 szLGComplexInstall,
                                                 SPINST_ALL & ~SPINST_FILES,
                                                 NULL,
                                                 pSetupSourcePath,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL ))
                {
                    //
                    //  This can happen if the user hits Cancel from
                    //  within the setup dialog.
                    //
                    Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                    goto Region_UnattendModeExit;
                }
            }

            if (bInstallBasic && (!g_bSetupCase))
            {
                if (!SetupInstallFromInfSection( NULL,
                                                 hIntlInf,
                                                 szLGBasicInstall,
                                                 SPINST_ALL & ~SPINST_FILES,
                                                 NULL,
                                                 pSetupSourcePath,
                                                 0,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL ))
                {
                    //
                    //  This can happen if the user hits Cancel from
                    //  within the setup dialog.
                    //
                    Intl_LogFormatMessage(IDS_LOG_EXT_LANG_CANCEL);
                    goto Region_UnattendModeExit;
                }
            }
            
            //
            //  Run any necessary apps (for IME installation).
            //
            if (bInstallBasic || bInstallComplex || bInstallExt)
            {
                Intl_RunRegApps(c_szIntlRun);
            }
        }
        else
        {
            //
            //  Log that the unattend mode setup was blocked since they
            //  do not have admin privileges.
            //
            Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
        }
    }

    //
    //  Install the requested Language/Region information.  If a
    //  Language/Region was not specified, then install the requested
    //  System Locale, User Locale, and Input Locales.
    //
    if ((SetupFindFirstLine( hFile,
                             szRegionalSettings,
                             szLanguage,
                             &Context )) &&
        (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
    {
        //
        //  Log language info.
        //
        Intl_LogSimpleMessage(IDS_LOG_LANG, szBuffer);

        //
        //  Get the Language as an integer.
        //
        Language = TransNum(szBuffer);

        //
        //  Block the invariant locale.
        //
        if (Language != LANG_INVARIANT)
        {
            //
            //  Check for admin privilege.
            //
            if (g_bAdmin_Privileges)
            {
                //
                //  Install the Language as the System Locale and the User Locale,
                //  and then install all layouts associated with the Language.
                //
                if (GetLocaleInfo( MAKELCID(Language, SORT_DEFAULT),
                                   LOCALE_IDEFAULTANSICODEPAGE |
                                     LOCALE_NOUSEROVERRIDE |
                                     LOCALE_RETURN_NUMBER,
                                   (PTSTR) &dwLocaleACP,
                                   sizeof(dwLocaleACP) / sizeof(TCHAR) ))
                {
                    //
                    //  Don't set the system locale if the locale doesn't have
                    //  an ACP.
                    //
                    if (dwLocaleACP)
                    {
                        if (Region_InstallSystemLocale(MAKELCID(Language, SORT_DEFAULT)))
                        {
                            bFound = TRUE;
                        }
                    }
                    else
                    {
                        //
                        //  Unicode locale blocked.
                        //
                        Intl_LogSimpleMessage(IDS_LOG_UNI_BLOCK, NULL);
                    }
                    
                    //
                    //  If we are in setup, try to set the Current User GEOID.
                    //
                    if( g_bSetupCase)
                    {
                        BOOL bSetGeoId = FALSE;
                        
                        //
                        //  If it's a clean install, then always set the GEOID. If 
                        //  it's a upgrade install set the GEOID only if no value
                        //  already set.
                        //
                        if (!bWinntUpgrade)
                        {
                            bSetGeoId = TRUE;
                        }
                        else if (GetUserGeoID(GEOCLASS_NATION) != GEOID_NOT_AVAILABLE)
                        {
                            bSetGeoId = TRUE;
                        }

                        if (bSetGeoId)
                        {
                            TCHAR szBufferGeo[MAX_PATH];

                            //
                            //  Retreive the Geo Identifier from the NLS info
                            //
                            if(GetLocaleInfo(MAKELCID(Language, SORT_DEFAULT),
                            	             LOCALE_IGEOID | LOCALE_RETURN_NUMBER,
                            	             szBufferGeo,
                            	             MAX_PATH))
                            {
                                //
                                //  Set The GeoId
                                //
                                SetUserGeoID(*((LPDWORD)szBufferGeo));
                            }
                        }
                    }
                }
                else
                {
                    Intl_LogFormatMessage(IDS_LOG_LOCALE_ACP_FAIL);
                }
            }
            else
            {
                //
                //  Log that the unattend mode setup was blocked since they
                //  do not have admin privileges.
                //
                Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
            }

            //
            //  If we're doing an upgrade, then don't touch per-user settings.
            //
            if (!bWinntUpgrade)
            {
                //
                //  Install the requested User Locale.
                //
                if (Intl_InstallUserLocale(MAKELCID(Language, SORT_DEFAULT), FALSE, TRUE))
                {
                    bFound = TRUE;
                }

                //
                //  Install Keyboard layout
                //
                Intl_InstallAllKeyboardLayout((LANGID)Language);
            }
        }
        else
        {
            //
            //  Log invariant locale blocked.
            //
            Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
        }
    }

    //
    //  Make sure there was a valid Language setting.  If not, then look
    //  for the individual keywords.
    //
    if (!bFound)
    {
        //
        //  Init the locale variables.
        //
        SystemLocale = 0;
        UserLocale = 0;

        //
        //  Log : no valid language setting found.
        //
        Intl_LogSimpleMessage(IDS_LOG_NO_VALID_FOUND, NULL);

        //
        //  Install the requested System Locale.
        //
        if ((SetupFindFirstLine( hFile,
                                 szRegionalSettings,
                                 szSystemLocale,
                                 &Context )) &&
            (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
        {
            SystemLocale = TransNum(szBuffer);

            //
            //  Check for admin privilege.
            //
            if (g_bAdmin_Privileges)
            {
                //
                //  Log system locale info.
                //
                Intl_LogSimpleMessage(IDS_LOG_SYS_LOCALE, szBuffer);

                //
                //  Block the invariant locale.
                //
                if (SystemLocale != LOCALE_INVARIANT)
                {
                    dwLocaleACP = 0UL;
                    if (GetLocaleInfo( SystemLocale,
                                       LOCALE_IDEFAULTANSICODEPAGE |
                                         LOCALE_NOUSEROVERRIDE |
                                         LOCALE_RETURN_NUMBER,
                                       (PTSTR) &dwLocaleACP,
                                       sizeof(dwLocaleACP) / sizeof(TCHAR) ))
                    {
                        //
                        //  Don't set the system locale if the locale doesn't
                        //  have an ACP.
                        //
                        if (dwLocaleACP)
                        {
                            if (Region_InstallSystemLocale(SystemLocale))
                            {
                                bFound = TRUE;
                            }
                        }
                        else
                        {
                            //
                            //  Unicode locale blocked.
                            //
                            Intl_LogSimpleMessage(IDS_LOG_UNI_BLOCK, NULL);
                        }
                    }
                    else
                    {
                        Intl_LogFormatMessage(IDS_LOG_LOCALE_ACP_FAIL);
                    }
                }
                else
                {
                    //
                    //  Log invariant locale blocked.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
                }
            }
            else
            {
                //
                //  Log that the unattend mode setup was blocked since they
                //  do not have admin privileges.
                //
                Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
            }
        }

        //
        //  Install the requested User Locale.
        //
        if ((SetupFindFirstLine( hFile,
                                 szRegionalSettings,
                                 szUserLocale,
                                 &Context )) &&
            (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
        {
            UserLocale = TransNum(szBuffer);

            //
            //  Log User locale info.
            //
            Intl_LogSimpleMessage(IDS_LOG_USER_LOCALE, szBuffer);

            //
            //  Block the invariant locale.
            //
            if (UserLocale != LOCALE_INVARIANT)
            {
                if ((!bWinntUpgrade) &&
                    (Intl_InstallUserLocale(UserLocale, FALSE, TRUE)))
                {
                    bFound = TRUE;
                }
            }
            else
            {
                //
                //  Log invariant locale blocked.
                //
                Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
            }
        }

        //
        //  Install the requested Input Locales.
        //
        if (SetupFindFirstLine( hFile,
                                szRegionalSettings,
                                szInputLocale,
                                &Context ))
        {
            //
            //  Log Default User - Input Locale info.
            //
            Intl_LogSimpleMessage(IDS_LOG_INPUT, NULL);

            //
            //  Install the keyboard layout list.
            //
            if (Intl_InstallKeyboardLayoutList(&Context, 1, FALSE))
            {
                bFound = TRUE;
            }
        }
        else
        {
            //
            //  No input locales are specified, so install the default
            //  input locale for the system locale and/or user locale if
            //  they were specified.
            //
            if (SystemLocale != 0)
            {
                //
                //  Log system locale info.
                //
                Intl_LogSimpleMessage(IDS_LOG_SYS_DEF_LAYOUT, NULL);

                //
                //  Install the keyboard layout.
                //
                Intl_InstallKeyboardLayout(NULL, SystemLocale, 0, FALSE, FALSE, TRUE);
            }
            if ((UserLocale != 0) && (UserLocale != SystemLocale))
            {
                //
                //  Log user locale info.
                //
                Intl_LogSimpleMessage(IDS_LOG_USER_DEF_LAYOUT, NULL);

                //
                //  Install the keyboard layout.
                //
                Intl_InstallKeyboardLayout(NULL, UserLocale, 0, FALSE, FALSE, FALSE);
            }
        }

        //
        //  Install the requested MUI Language.
        //
        if ((SetupFindFirstLine( hFile,
                                 szRegionalSettings,
                                 szMUILanguage,
                                 &Context )) &&
            (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
        {
            MUILanguage = (LANGID)TransNum(szBuffer);

            //
            //  Log MUI Language info.
            //
            Intl_LogSimpleMessage(IDS_LOG_MUI_LANG, szBuffer);

            //
            //  Check UI language validity.
            //
            if (IsValidUILanguage(MUILanguage))
            {
                //
                //  Block the invariant locale.
                //
                if (MUILanguage != LANG_INVARIANT)
                {
                    if ((!bWinntUpgrade) &&
                        NT_SUCCESS(NtSetDefaultUILanguage(MUILanguage)))
                    {
                        //  deleting the key this way makes the key invalid for this process
                        //  this way the new UI doesn't get bogus cached values
                        SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\MUICache"));

                        //
                        //  Install the default keyboard.
                        //
                        if (Intl_InstallKeyboardLayout( NULL,
                                                        MAKELCID(MUILanguage, SORT_DEFAULT),
                                                        0,
                                                        FALSE,
                                                        FALSE,
                                                        FALSE ))
                        {
                            bFound = TRUE;
                        }
                    }
                }
                else
                {
                    //
                    //  Log invariant locale blocked.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
                }
            }
            else
            {
                //
                //  Log invalid UI language blocked.
                //
                Intl_LogSimpleMessage(IDS_LOG_UI_BLOCK, NULL);
            }
        }
    }


    //
    //  Install the requested User Locale for the Default User.
    //
    if ((SetupFindFirstLine( hFile,
                             szRegionalSettings,
                             szUserLocale_DefUser,
                             &Context )) &&
        (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
    {
        UserLocale_DefUser = TransNum(szBuffer);

        //
        //  Log default user - user locale info.
        //
        Intl_LogSimpleMessage(IDS_LOG_USER_LOCALE_DEF, szBuffer);

        //
        //  Block users that do not have administrative privilege.
        //
        if (g_bAdmin_Privileges)
        {
            //
            //  Block the invariant locale.
            //
            if (UserLocale_DefUser != LOCALE_INVARIANT)
            {
                if (Intl_InstallUserLocale(UserLocale_DefUser, TRUE, TRUE))
                {
                    if (Intl_InstallKeyboardLayout(NULL, UserLocale_DefUser, 0, FALSE, TRUE, FALSE))
                    {
                        Intl_SaveDefaultUserInputSettings();
                        bFound_DefUser = TRUE;
                    }
                }
            }
            else
            {
                //
                //  Log invariant locale blocked.
                //
                Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
            }
        }
        else
        {
            //
            //  Log that the unattend mode setup was blocked since they
            //  do not have admin privileges.
            //
            Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
        }
    }

    //
    //  Install the requested Input Locales for the Default User.
    //
    if (SetupFindFirstLine( hFile,
                            szRegionalSettings,
                            szInputLocale_DefUser,
                            &Context ))
    {
        //
        //  Log Default User - Input Locale info.
        //
        Intl_LogSimpleMessage(IDS_LOG_INPUT_DEF, NULL);

        //
        //  Block users that do not have administrative privilege.
        //
        if (g_bAdmin_Privileges)
        {
            if (Intl_InstallKeyboardLayoutList(&Context, 1, TRUE))
            {
                Intl_SaveDefaultUserInputSettings();
                bFound_DefUser = TRUE;
            }
        }
        else
        {
            //
            //  Log that the unattend mode setup was blocked since they
            //  do not have admin privileges.
            //
            Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
        }
    }

    //
    //  Install the requested MUI Language for the Default User.
    //
    if ((SetupFindFirstLine( hFile,
                             szRegionalSettings,
                             szMUILanguage_DefUSer,
                             &Context )) &&
        (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
    {
        MUILanguage_DefUser = (LANGID)TransNum(szBuffer);

        //
        //  Log Default User - MUI Language info.
        //
        Intl_LogSimpleMessage(IDS_LOG_MUI_LANG_DEF, szBuffer);

        //
        //  Check UI language validity.
        //
        if (IsValidUILanguage(MUILanguage_DefUser))
        {
            //
            //  Block users that do not have administrative privilege.
            //
            if (g_bAdmin_Privileges)
            {
                //
                //  Block the invariant locale.
                //
                if (MUILanguage_DefUser != LANG_INVARIANT)
                {
                    if (Intl_ChangeUILangForAllUsers(MUILanguage_DefUser))
                    {
                        Intl_SaveDefaultUserInputSettings();
                        bFound_DefUser = TRUE;
                    }
                }
                else
                {
                    //
                    //  Log invariant locale blocked.
                    //
                    Intl_LogSimpleMessage(IDS_LOG_INV_BLOCK, NULL);
                }
            }
            else
            {
                //
                //  Log that the unattend mode setup was blocked since they
                //  do not have admin privileges.
                //
                Intl_LogSimpleMessage(IDS_LOG_NO_ADMIN, NULL);
            }
        }
        else
        {
            //
            //  Log invalid UI language blocked.
            //
            Intl_LogSimpleMessage(IDS_LOG_UI_BLOCK, NULL);
        }
    }

    //
    //  If we still didn't find anything, then load the default locale for
    //  the installation.  It will be the equivalent of:
    //      LanguageGroup = "x"
    //      Language = "y"
    //  where x is the language group for the default locale and y is the
    //  default locale.
    //
    if (!bFound && !bLangGroup && !bFound_DefUser)
    {
        //
        //  Get the default locale.
        //
        if ((SetupFindFirstLine( hIntlInf,
                                 L"DefaultValues",
                                 L"Locale",
                                 &Context )) &&
            (SetupGetStringField(&Context, 1, szBuffer, MAX_PATH, NULL)))
        {
            //
            //  Get the Language as an integer.
            //
            Language = TransNum(szBuffer);

            //
            //  Install the Language Group needed for this Language.
            //
            if ((SetupFindFirstLine( hIntlInf,
                                     L"Locales",
                                     szBuffer,
                                     &Context )) &&
                (SetupGetStringField(&Context, 3, szBuffer, MAX_PATH, NULL)))
            {
                //
                //  Get the Language Group as an integer.
                //
                bInstallBasic = FALSE;
                bInstallExt = FALSE;
                LanguageGroup = Intl_StrToLong(szBuffer);

                //
                //  Enqueue the language group files so that they may be
                //  copied.  This only handles the CopyFiles entries in the
                //  inf file.
                //
                if ((LanguageGroup == LGRPID_JAPANESE) ||
                    (LanguageGroup == LGRPID_KOREAN) ||
                    (LanguageGroup == LGRPID_TRADITIONAL_CHINESE) ||
                    (LanguageGroup == LGRPID_SIMPLIFIED_CHINESE))
                {
                   