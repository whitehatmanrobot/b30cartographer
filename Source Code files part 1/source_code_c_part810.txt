ize of the image
            // to have it work in the getimage call back
            m_FileSize = dwNewImageSize;
        }
        m_dwImageSize = dwNewImageSize;
        m_FileOffset = 0;
    }
    return 0;
}


DWORD
CResInfo::UpdateImage( LONG dwSize, HINSTANCE hInst, LPCSTR lpszType )
{
    // We have to generate a list of info and give it back to the RW

    if (!dwSize) dwSize = m_dwImageSize*4+sizeof(RESITEM);
    if (!dwSize) dwSize = 10000;
    if (dwSize>UINT_MAX) dwSize = UINT_MAX-1024;
    TRACE1("CResInfo::UpdateImage\tNewSize: %ld\n", (LONG)dwSize);
    BYTE far * lpBuf = new BYTE[dwSize];
    if (!lpBuf) return ERROR_NEW_FAILED;
    BYTE far * lpBufStart = lpBuf;
    BYTE far * lpStrBuf = lpBuf+sizeof(RESITEM);
    LPRESITEM lpResItem = (LPRESITEM)lpBuf;
    DWORD dwBufSize = dwSize;
    CItemInfo* pItemInfo;
    DWORD dwUpdLang = m_Language;
    BOOL fUpdLang = TRUE;

    int istrlen;
    LONG lBufSize = 0;
    for(INT_PTR c=0, UpperBound=m_ItemArray.GetUpperBound(); c<=UpperBound; c++) {

        pItemInfo = (CItemInfo*) m_ItemArray.GetAt(c);
        if (!pItemInfo)
            return ERROR_IO_RESINFO_NULL;

        if(fUpdLang)
        {
            dwUpdLang = pItemInfo->GetLanguage();
            if(dwUpdLang==0xffffffff)
            {
                dwUpdLang = m_Language;
            }
            else
                fUpdLang = FALSE;
        }

		lBufSize = (LONG)dwSize;
        if (dwSize>=sizeofDWord) {
            lpResItem->dwSize = sizeof(RESITEM);    // Size
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofWord) {
            lpResItem->wX = pItemInfo->GetX(); // Coordinate
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;
        if (dwSize>=sizeofWord) {
            lpResItem->wY = pItemInfo->GetY();
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;

        if (dwSize>=sizeofWord) {
            lpResItem->wcX = pItemInfo->GetcX(); // Position
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;
        if (dwSize>=sizeofWord) {
            lpResItem->wcY = pItemInfo->GetcY();
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwCheckSum = pItemInfo->GetCheckSum();   // Checksum
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwStyle = pItemInfo->GetStyle(); // Style
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwExtStyle = pItemInfo->GetExtStyle();   // ExtendedStyle
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwFlags = pItemInfo->GetFlags();         // Flags
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwItemID = pItemInfo->GetTabPosId();     // PosId
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwResID = m_ResId;                            // ResourceID
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;
        if (dwSize>=sizeofDWord) {
            lpResItem->dwTypeID = m_TypeId;                           // Type ID
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;
        if (dwSize>=sizeofDWord) {
            lpResItem->dwLanguage = pItemInfo->GetLanguage();   // Language ID
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofDWord) {
            lpResItem->dwCodePage = pItemInfo->GetCodePage();   // CodePage
            dwSize -= sizeofDWord;
        } else dwSize -= sizeofDWord;

        if (dwSize>=sizeofWord) {
            lpResItem->wClassName = pItemInfo->GetClassNameID();// ClassName
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;
        if (dwSize>=sizeofWord) {
            lpResItem->wPointSize = pItemInfo->GetPointSize();  // CodePage
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;

        if (dwSize>=sizeofWord) {
            lpResItem->wWeight = pItemInfo->GetWeight();  // Weight
            dwSize -= sizeofWord;
        } else dwSize -= sizeofWord;

        if (dwSize>=sizeofByte) {
            lpResItem->bItalic = pItemInfo->GetItalic();  // Italic
            dwSize -= sizeofByte;
        } else dwSize -= sizeofByte;

        if (dwSize>=sizeofByte) {
            lpResItem->bCharSet = pItemInfo->GetCharSet();  // CharSet
            dwSize -= sizeofByte;
        } else dwSize -= sizeofByte;

        if (dwSize>=sizeofDWordPtr) {
            lpResItem->lpszClassName = LPNULL;
            dwSize -= sizeofDWordPtr;
        } else dwSize -= sizeofDWordPtr;
        if (dwSize>=sizeofDWordPtr) {
            lpResItem->lpszFaceName = LPNULL;
            dwSize -= sizeofDWordPtr;
        } else dwSize -= sizeofDWordPtr;
        if (dwSize>=sizeofDWordPtr) {
            lpResItem->lpszCaption = LPNULL;
            dwSize -= sizeofDWordPtr;
        } else dwSize -= sizeofDWordPtr;
        if (dwSize>=sizeofDWordPtr) {
            lpResItem->lpszResID = LPNULL;
            dwSize -= sizeofDWordPtr;
        } else dwSize -= sizeofDWordPtr;
        if (dwSize>=sizeofDWordPtr) {
            lpResItem->lpszTypeID = LPNULL;
            dwSize -= sizeofDWordPtr;
        } else dwSize -= sizeofDWordPtr;

        // Copy the strings
        istrlen = (pItemInfo->GetClassName()).GetLength()+1;
        if (dwSize>=istrlen) {
            lpResItem->lpszClassName = strcpy((char*)lpStrBuf, pItemInfo->GetClassName());
            lpStrBuf += istrlen;
            dwSize -= istrlen;
            lpResItem->dwSize += istrlen;
        } else dwSize -= istrlen;

        istrlen = (pItemInfo->GetFaceName()).GetLength()+1;
        if (dwSize>=istrlen) {
            lpResItem->lpszFaceName = strcpy((char*)lpStrBuf, pItemInfo->GetFaceName());
            lpStrBuf += istrlen;
            dwSize -= istrlen;
            lpResItem->dwSize += istrlen;
        } else dwSize -= istrlen;

        istrlen = (pItemInfo->GetCaption()).GetLength()+1;
        if (dwSize>=istrlen) {
            lpResItem->lpszCaption = strcpy((char*)lpStrBuf, pItemInfo->GetCaption());
            lpStrBuf += istrlen;
            dwSize -= istrlen;
            lpResItem->dwSize += istrlen;
        } else dwSize -= istrlen;

        istrlen = m_ResName.GetLength()+1;
        if (dwSize>=istrlen) {
            lpResItem->lpszResID = strcpy((char*)lpStrBuf, m_ResName);
            lpStrBuf += istrlen;
            dwSize -= istrlen;
            lpResItem->dwSize += istrlen;
        } else dwSize -= istrlen;

        istrlen = m_TypeName.GetLength()+1;
        if (dwSize>=istrlen) {
            lpResItem->lpszTypeID = strcpy((char*)lpStrBuf, m_TypeName);
            lpStrBuf += istrlen;
            dwSize -= istrlen;
            lpResItem->dwSize += istrlen;
        } else dwSize -= istrlen;

        // Check if we are alligned
        BYTE bPad = Allign(lBufSize-(LONG)dwSize);
    	if((LONG)dwSize>=bPad) {
            	lpResItem->dwSize += bPad;
            	dwSize -= bPad;
            	while(bPad) {
                		*lpStrBuf = 0x00;
                		lpStrBuf += 1;
                		bPad--;
            	}
    	}
	else dwSize -= bPad;

        // move to the next item
        lpResItem = (LPRESITEM) lpStrBuf;
        lpStrBuf  += sizeof(RESITEM);

    }

    if (dwSize<0){
        delete []lpBufStart;
        return dwBufSize-dwSize;
    }
    else dwSize = dwBufSize-dwSize;

    // Give all back to the RW and wait
    UINT (FAR PASCAL * lpfnGenerateImage)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*);
    UINT (FAR PASCAL * lpfnGenerateImageEx)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*, LPCSTR);

    //
    // Trye to get the pointer to the extended version of the function...
    //
    lpfnGenerateImageEx = (UINT (FAR PASCAL *)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*, LPCSTR))
                                GetProcAddress( hInst, "RWUpdateImageEx" );

    if (lpfnGenerateImageEx==NULL) {
        //
        // get the old update image function since the RW doesn't support RC data
        //
        lpfnGenerateImage = (UINT (FAR PASCAL *)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*))
                                GetProcAddress( hInst, "RWUpdateImage" );

        if (lpfnGenerateImage==NULL)
           return ERROR_DLL_PROC_ADDRESS;
    }

    DWORD dwNewImageSize = m_dwImageSize*3+sizeof(RESITEM);
    if(!dwNewImageSize)
        dwNewImageSize = 10000;
    if (dwNewImageSize>UINT_MAX)
        dwNewImageSize = UINT_MAX-1024;
    DWORD dwOriginalImageSize = dwNewImageSize;
    BYTE far * lpNewImage = new BYTE[dwNewImageSize];
    if (!lpNewImage) {
        delete []lpBufStart;
        return ERROR_NEW_FAILED;
    }

#ifndef _DEBUG
    // set the memory to 0
    memset( lpNewImage, 0, (size_t)dwNewImageSize );
#endif

    UINT uiError;
    if(lpfnGenerateImageEx)
    {

        uiError = (*lpfnGenerateImageEx)( (LPCSTR)lpszType,
                                            (LPVOID)lpBufStart,
                                            (DWORD) dwSize,
                                            (LPVOID)m_lpImageBuf,
                                            (DWORD) m_dwImageSize,
                                            (LPVOID)lpNewImage,
                                            (DWORD*)&dwNewImageSize,
                                            (LPCSTR)m_pFileModule->GetRDFName()
                                            );
    }
    else
    {
        uiError = (*lpfnGenerateImage)( (LPCSTR)lpszType,
                                            (LPVOID)lpBufStart,
                                            (DWORD) dwSize,
                                            (LPVOID)m_lpImageBuf,
                                            (DWORD) m_dwImageSize,
                                            (LPVOID)lpNewImage,
                                            (DWORD*)&dwNewImageSize
                                            );
    }

    if (dwNewImageSize>dwOriginalImageSize) {
        delete []lpNewImage;
        TRACE1("CResInfo::UpdateImage\tNewSize: %ld\n", (LONG)dwNewImageSize);
        if (dwNewImageSize>UINT_MAX)
            dwNewImageSize = UINT_MAX-1024;
        lpNewImage = new BYTE[dwNewImageSize];
        if (!lpNewImage) {
            delete []lpBufStart;
            return ERROR_NEW_FAILED;
        }

#ifndef _DEBUG
        // set the memory to 0
        memset( lpNewImage, 0, (size_t)dwNewImageSize );
#endif

        if(lpfnGenerateImageEx)
        {

            uiError = (*lpfnGenerateImageEx)( (LPCSTR)lpszType,
                                                (LPVOID)lpBufStart,
                                                (DWORD) dwSize,
                                                (LPVOID)m_lpImageBuf,
                                                (DWORD) m_dwImageSize,
                                                (LPVOID)lpNewImage,
                                                (DWORD*)&dwNewImageSize,
                                                (LPCSTR)m_pFileModule->GetRDFName()
                                                );
        }
        else
        {
            uiError = (*lpfnGenerateImage)( (LPCSTR)lpszType,
                                                (LPVOID)lpBufStart,
                                                (DWORD) dwSize,
                                                (LPVOID)m_lpImageBuf,
                                                (DWORD) m_dwImageSize,
                                                (LPVOID)lpNewImage,
                                                (DWORD*)&dwNewImageSize
                                                );
        }


    }


    if ((dwNewImageSize) && (!uiError)) {
        m_ImageUpdated = 1;
        FreeImage();
        if(!m_lpImageBuf) {
			if(AllocImage(dwNewImageSize))
                return ERROR_NEW_FAILED;
            memcpy(m_lpImageBuf, lpNewImage, (UINT)dwNewImageSize);
            // check if the size of the image is 0
            if(!m_FileOffset) {
                // Chances are that this is a conversion.
                // set the file size to the size of the image
                // to have it work in the getimage call back
                m_FileSize = dwNewImageSize;
            }
            m_dwImageSize = dwNewImageSize;
            dwNewImageSize = 0;
            m_Language = MAKELONG(HIWORD(m_Language),LOWORD(dwUpdLang));
        }
    }

    delete []lpNewImage;
    delete []lpBufStart;

    return dwNewImageSize;
}

UINT
CResInfo::GetData(  LPCSTR lpszFilename, HINSTANCE hInst,
                    DWORD dwItem, LPVOID lpbuffer, UINT uiBufSize )
{
    // We assume the buffer is pointing to a _ResItem Struct

    // [ALESSANM 25-06-93] - mod 1
    LPRESITEM lpResItem = (LPRESITEM) lpbuffer;

    UINT uiPos = HIWORD(dwItem);

    if (!m_ItemArray.GetSize()) {
        // We have to load the array again. What if the image has been modified?
        // Check the fileoffset to see if it is 0.
        if (!m_lpImageBuf) {
            // Load the resource.image
            DWORD dwReadSize = LoadImage( lpszFilename, hInst );

            if (dwReadSize!=m_dwImageSize)
                return 0;
        }

        // We have now to pass the Buffer back to the RW to Parse the info
        if (!(ParseImage( hInst )) )
            return 0;
    }

    if (uiPos>(UINT)m_ItemArray.GetSize())
        // Wrong pointer to the item
        return 0;

    CItemInfo* pItemInfo = (CItemInfo*)m_ItemArray.GetAt( uiPos-1 );

    if (!pItemInfo)
        return 0;

    // Check if the Id match
    if (pItemInfo->GetId()!=LOWORD(dwItem))
        return 0;

    // fill the structure with the info we have
    UINT uiSize = 0;

    // calc the size and check if the buffer is too small
    // Strings Field in the CItemInfo
    uiSize =  (pItemInfo->GetCaption()).GetLength()+1;
    uiSize +=  (pItemInfo->GetFaceName()).GetLength()+1;
    uiSize +=  (pItemInfo->GetClassName()).GetLength()+1;
    // Strings field in the CResItem
    uiSize += (m_ResName).GetLength()+1;
    uiSize += (m_TypeName).GetLength()+1;
    // Fixed field in the ResItem Structure
    uiSize += sizeof(RESITEM);

    // Check if the user buffer is too small
    if (uiBufSize<uiSize)
        return uiSize;

    // Get the pointer to the end of the structure (begin of the buffer)
    char far * lpStrBuf = (char far *)lpbuffer+sizeof(RESITEM);

    // Size of the structure
    lpResItem->dwSize = uiSize;

    // Copy the items in the buffer
    // Start from the fixed field
    // Coordinate
    lpResItem->wX = pItemInfo->GetX();
    lpResItem->wY = pItemInfo->GetY();
    lpResItem->wcX = pItemInfo->GetcX();
    lpResItem->wcY = pItemInfo->GetcY();

    // Checksum and Style
    lpResItem->dwCheckSum = pItemInfo->GetCheckSum();
    lpResItem->dwStyle = pItemInfo->GetStyle();
    lpResItem->dwExtStyle = pItemInfo->GetExtStyle();
    lpResItem->dwFlags = pItemInfo->GetFlags();

    // ID
    // This is needed for the update by terms.
    // We have to have unique ID
	if((m_TypeId==4) &&(pItemInfo->GetFlags() & MF_POPUP)) {
        // Check if we have an id. otherwise is the old ID format
        lpResItem->dwItemID = pItemInfo->GetPosId();

        if(!lpResItem->dwItemID)
		    lpResItem->dwItemID = pItemInfo->GetTabPosId();
    } else {
        // Fixed bug No: 165
        if(pItemInfo->GetId() != -1)
            lpResItem->dwItemID = pItemInfo->GetPosId();
        else lpResItem->dwItemID = pItemInfo->GetTabPosId();
    }

    lpResItem->dwResID = m_ResId;
    lpResItem->dwTypeID = m_TypeId;
    lpResItem->dwLanguage = LOWORD(m_Language);

    // Code page, Class and Font
    lpResItem->dwCodePage = pItemInfo->GetCodePage();
    lpResItem->wClassName = pItemInfo->GetClassNameID();
    lpResItem->wPointSize = pItemInfo->GetPointSize();
    lpResItem->wWeight = pItemInfo->GetWeight();
    lpResItem->bItalic = pItemInfo->GetItalic();
    lpResItem->bCharSet = pItemInfo->GetCharSet();

    // Let's start copy the string

    lpResItem->lpszClassName = strcpy( lpStrBuf, pItemInfo->GetClassName() );
    lpStrBuf += strlen(lpResItem->lpszClassName)+1;

    lpResItem->lpszFaceName = strcpy( lpStrBuf, pItemInfo->GetFaceName() );
    lpStrBuf += strlen(lpResItem->lpszFaceName)+1;

    lpResItem->lpszCaption = strcpy( lpStrBuf, pItemInfo->GetCaption() );
    lpStrBuf += strlen(lpResItem->lpszCaption)+1;

    lpResItem->lpszResID = strcpy( lpStrBuf, m_ResName );
    lpStrBuf += strlen(lpResItem->lpszResID)+1;

    lpResItem->lpszTypeID = strcpy( lpStrBuf, m_TypeName );
    lpStrBuf += strlen(lpResItem->lpszTypeID)+1;

    return uiSize;
}

UINT
CResInfo::UpdateData(  LPCSTR lpszFilename, HINSTANCE hInst,
                       DWORD dwItem, LPVOID lpbuffer, UINT uiBufSize )
{
    UINT uiError = ERROR_NO_ERROR;
    UINT uiPos = HIWORD(dwItem);
    TRACE1("UpdateData:\tdwItem:%lx\t", dwItem);
    // we have to see if the array has been loaded before
    if (!m_ItemArray.GetSize()) {
        // We have to load the array again
        if (!m_lpImageBuf) {
            // Load the resource.image
            DWORD dwReadSize = LoadImage( lpszFilename, hInst );

            if (dwReadSize!=m_dwImageSize)
                return ERROR_RW_LOADIMAGE;
        }

        // We have now to pass the Buffer back to the RW to Parse the info
        if (!(ParseImage( hInst )) )
            return ERROR_RW_PARSEIMAGE;
    }

    if (uiPos>(UINT)m_ItemArray.GetSize())
        // Wrong pointer to the item
        return ERROR_IO_INVALIDITEM;

    CItemInfo* pItemInfo = (CItemInfo*)m_ItemArray.GetAt( uiPos-1 );

    if (!pItemInfo)
        return ERROR_IO_INVALIDITEM;

    TRACE2("m_dwPosId:%lx\tm_wTabPos:%lx\n", pItemInfo->GetPosId(), pItemInfo->GetTabPosId());
    // Check if the Id match
    if (lpbuffer)
        if (pItemInfo->GetPosId()!=((LPRESITEM)lpbuffer)->dwItemID)
        {
            // we have some files with ID = 0, check for that
            if (pItemInfo->GetTabPosId()!=((LPRESITEM)lpbuffer)->dwItemID)
                return ERROR_IO_INVALIDID;
        }

    if ((uiError = pItemInfo->UpdateData( (LPRESITEM)lpbuffer )) )
        return uiError;

    // We have to mark the resource has updated
    m_FileOffset = 0L;
    m_ImageUpdated = 0;
    return uiError;
}

DWORD
CResInfo::ParseImage( HINSTANCE hInst )
{
    //
    // Check if the new RCData handling is supported
    //

    UINT (FAR PASCAL  * lpfnParseImageEx)(LPCSTR, LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPCSTR);
    UINT (FAR PASCAL  * lpfnParseImage)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD);

    // Get the pointer to the function to extract the resources
    lpfnParseImageEx = (UINT (FAR PASCAL *)(LPCSTR, LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPCSTR))
                        GetProcAddress( hInst, "RWParseImageEx" );
    if (lpfnParseImageEx==NULL) {
        //
        // This is and old RW get the old entry point
        //
        lpfnParseImage = (UINT (FAR PASCAL *)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD))
                            GetProcAddress( hInst, "RWParseImage" );
        if (lpfnParseImage==NULL) {
            return (DWORD)ERROR_DLL_PROC_ADDRESS;
        }
    }

    BYTE far * lpBuf;
    DWORD dwSize = m_dwImageSize*8+sizeof(RESITEM);

    if ((dwSize>UINT_MAX) || (dwSize==0))
        dwSize = 30000;

    TRACE1("CResInfo::ParseImage\tNewSize: %ld\n", (LONG)dwSize);
    lpBuf = new BYTE[dwSize];
    if (!lpBuf)
        return 0;

    LPSTR   lpszType = LPNULL;
    if (m_TypeName=="" && m_TypeId)
    	lpszType = (LPSTR)((WORD)m_TypeId);
	else
		lpszType = (LPSTR)(m_TypeName.GetBuffer(0));

    LPSTR   lpszResId = LPNULL;
    if (m_ResName=="" && m_ResId)
    	lpszResId = (LPSTR)((WORD)m_ResId);
	else
		lpszResId = (LPSTR)(m_ResName.GetBuffer(0));

    LONG dwRead = 0;

    if(lpfnParseImageEx)
    {
        dwRead = (*lpfnParseImageEx)((LPCSTR)lpszType,
                                     (LPCSTR)lpszResId,
                                     (LPVOID)m_lpImageBuf,
                                     (DWORD)m_dwImageSize,
                                     (LPVOID)lpBuf,
                                     (DWORD)dwSize,
                                     (LPCSTR)m_pFileModule->GetRDFName());
    } else
    {
        dwRead = (*lpfnParseImage)((LPCSTR)lpszType,
                                     (LPVOID)m_lpImageBuf,
                                     (DWORD)m_dwImageSize,
                                     (LPVOID)lpBuf,
                                     (DWORD)dwSize);
    }

    if (dwRead>(LONG)dwSize) {
        // We have to allocate a bigger buffer
        delete []lpBuf;
        TRACE1("CResInfo::ParseImage\tNewSize: %ld\n", (LONG)dwRead);
    	lpBuf = (BYTE far *) new BYTE[dwRead];

        if (!lpBuf)
            return 0;

        dwSize = dwRead;
        // try to read again
        if(lpfnParseImageEx)
        {
            dwRead = (*lpfnParseImageEx)((LPCSTR)lpszType,
                                         (LPCSTR)lpszResId,
                                         (LPVOID)m_lpImageBuf,
                                         (DWORD)m_dwImageSize,
                                         (LPVOID)lpBuf,
                                         (DWORD)dwSize,
                                         (LPCSTR)m_pFileModule->GetRDFName());
        } else
        {
            dwRead = (*lpfnParseImage)((LPCSTR)lpszType,
                                         (LPVOID)m_lpImageBuf,
                                         (DWORD)m_dwImageSize,
                                         (LPVOID)lpBuf,
                                         (DWORD)dwSize);
        }

        if (dwRead>(LONG)dwSize) {
            // Abort
            delete []lpBuf;
            return 0;
        }
    }


    // Parse the buffer we have got and fill the array with the information
    // The buffer we are expecting is a series of ResItem structure
    FreeItemArray();

    // We want to parse all the stucture in the buffer
    LPRESITEM   lpResItem = (LPRESITEM) lpBuf;
    BYTE far * lpBufStart = lpBuf;
    WORD wTabPos = 0;
    WORD wPos = 0;
	//m_ItemArray.SetSize(10,5);
    while ( (dwRead>0) && ((LONG)lpResItem->dwSize!=-1) ) {
        //TRACE1("Caption: %Fs\n", lpResItem->lpszCaption);
        wTabPos++;
        if ( !(
             ((int)lpResItem->wX==-1) &&
             ((int)lpResItem->wY==-1) &&
             ((int)lpResItem->wcX==-1) &&
             ((int)lpResItem->wcY==-1) &&
             ((LONG)lpResItem->dwItemID==-1) &&
             //(LOWORD(dwPosId)==0) &&
             ((LONG)lpResItem->dwStyle==-1) &&
             ((LONG)lpResItem->dwExtStyle==-1) &&
             ((LONG)lpResItem->dwFlags==-1) &&
             (strlen((LPSTR)lpResItem->lpszCaption)==0)
             )
            ) {

            TRACE2("\tItems-> x: %d\ty: %d\t", lpResItem->wX, lpResItem->wY );
            TRACE2("cx: %d\tcy: %d\t", lpResItem->wcX, lpResItem->wcY );
            TRACE1("Id: %lu\t", lpResItem->dwItemID);
            TRACE2("Style: %ld\tExtStyle: %ld\n", lpResItem->dwStyle, lpResItem->dwExtStyle);
            if (lpResItem->lpszCaption) {
                UINT len = strlen((LPSTR)lpResItem->lpszCaption);
                TRACE2("Len: %d\tText: %s\n", len,
                                          (len<256 ? lpResItem->lpszCaption : ""));
            }
            TRACE2("dwRead: %lu\tdwSize: %lu\n", dwRead, lpResItem->dwSize);

            //lpResItem->dwItemID = MAKELONG(LOWORD(lpResItem->dwItemID), ++wPos);

			m_ItemArray.Add( new CItemInfo( lpResItem, wTabPos ));
        }

        // Next Item
        lpBuf += lpResItem->dwSize;
        dwRead -= lpResItem->dwSize;
        lpResItem = (LPRESITEM) lpBuf;

    }

	delete []lpBufStart;


    return (DWORD)m_ItemArray.GetSize();
}

UINT
CResInfo::CopyImage( CResInfo* pResInfo )
{
	// Will copy the image from this object to the pResInfo object
	// We need this to hack the image transformation
	// When we will have time we will do the thing right
	// Allocate memory for the new image
	if(!m_dwImageSize)
		return 0;
	if(pResInfo->AllocImage(m_dwImageSize))
        return ERROR_NEW_FAILED;

    // Copy the data
    memcpy( pResInfo->m_lpImageBuf, m_lpImageBuf, (size_t)m_dwImageSize );

	// set the file size so the GetImage will not complain
	pResInfo->SetFileSize(m_FileSize);

	return 0;
}

UINT
CResInfo::Copy( CResInfo* pResInfo, CString szFileName, HINSTANCE hInst )
{
    CItemInfo* pItemInfo;
    INT_PTR u = m_ItemArray.GetUpperBound();
    if (u==-1) {
        if ( (!m_lpImageBuf) && (m_FileOffset)) {
            DWORD dwReadSize = LoadImage( szFileName, hInst );
            if (dwReadSize!=m_dwImageSize)
                return ERROR_RW_LOADIMAGE;
        }
        if (!(ParseImage( hInst )) )
            return ERROR_RW_PARSEIMAGE;
        u = m_ItemArray.GetUpperBound();
    }

    // This is a bad hack and doesn't fit at all in the design of the module.
    // We have to copy the image between ResInfo object to be able to
    // Pass on the raw data. Since in the RESITEM structure there isn't a
    // pointer to a raw data buffer we cannot pass the data for the Cursor, bitmaps...
    // What we will do is hard code the type id of this image and if the resource
    // is one of this we will copy the raw data and perform an UpdateImage in the RES16
    // module. If it is a standard item then we procede as usual calling the GenerateImage
    // in the RES16 Module.
    // The right thing to do should be to have a pointer to the raw data in the RESITEM
    // structure so when the item is a pure data item we can still pass the data on.
    // To do this we have to change the RESITEM structure and this will mean go in each RW
    // and make sure that all the place in which we fill the RESITEM get modified.

    switch(m_TypeId) {
    	// Copy only the Bitmaps, Cursors and Icons usualy have no localizable strings
    	/*
    	case 1:
    		// copy the image
    		CopyImage( pResInfo );
    	break;
    	*/
    	case 2:
    		// copy the image
    		CopyImage( pResInfo );
    	break;
    	/*
    	case 3:
    		// copy the image
    		CopyImage( pResInfo );
    	break;
    	*/
    	default:
    		// do nothing
    	break;
    }
	//m_ItemArray.SetSize(u,10);
    for( int c=0; c<=u ; c++) {
        pItemInfo = (CItemInfo*) m_ItemArray.GetAt(c);
        if(!pItemInfo)
            return  ERROR_IO_INVALIDITEM;
        pResInfo->AddItem( *pItemInfo );
    }

    // We have to mark the resource has updated
    pResInfo->SetFileOffset(0L);
    pResInfo->SetImageUpdated(0);

    return ERROR_NO_ERROR;
}

int
CResInfo::AddItem( CItemInfo ItemInfo )
{
    return (int)m_ItemArray.Add( new CItemInfo( ItemInfo ));
}

DWORD
CResInfo::EnumItem( LPCSTR lpszFilename, HINSTANCE hInst, DWORD dwPrevItem )
{
    if (dwPrevItem) {
        if (m_ItemPos==0) return LPNULL;
        if (m_ItemPos==m_ItemArray.GetSize()) {
            m_ItemPos = 0;
            return LPNULL;
        }
    } else {
        // It is the first time or the user want to restart

        // Load the resource.image
        DWORD dwReadSize = LoadImage( lpszFilename, hInst );

        if (dwReadSize!=m_FileSize) {
            return 0L;
        }

        // We have now to pass the Buffer back to the RW to Parse the info
        if (!(ParseImage( hInst )) )
            return 0L;

        m_ItemPos = 0;
    }

    CItemInfo* pItemInfo = (CItemInfo*)m_ItemArray.GetAt( m_ItemPos++ );
    while( (
             (pItemInfo->GetX()==0) &&
             (pItemInfo->GetY()==0) &&
             (pItemInfo->GetcX()==0) &&
             (pItemInfo->GetcY()==0) &&
             (pItemInfo->GetId()==0) &&
             (pItemInfo->GetStyle()==0) &&
             (pItemInfo->GetExtStyle()==0) &&
             ((pItemInfo->GetCaption()).IsEmpty())
             )
            ) {
        if(m_ItemArray.GetUpperBound()>=m_ItemPos)
            pItemInfo = (CItemInfo*)m_ItemArray.GetAt( m_ItemPos++ );
        else return 0L;

    }


    if (!pItemInfo) return 0L;

    return pItemInfo->GetTabPosId();
}

////////////////////////////////////////////////////////////////////////////
// CItemInfo

CItemInfo::CItemInfo(   WORD x, WORD y,
                WORD cx, WORD cy,
                DWORD dwPosId, WORD wPos,
                DWORD dwStyle, DWORD dwExtStyle,
                CString szText )
{
    m_wX = x;
    m_wY = y;

    m_wCX = cx;
    m_wCY = cy;

    m_dwPosId = dwPosId;
    m_wTabPos = wPos;

    m_dwStyle = dwStyle;
    m_dwExtStyle = dwExtStyle;

    m_szCaption = szText;
}

CItemInfo::CItemInfo( LPRESITEM lpResItem, WORD wTabPos )
{
    m_wX = lpResItem->wX;
    m_wY = lpResItem->wY;

    m_wCX = lpResItem->wcX;
    m_wCY = lpResItem->wcY;

    m_dwCheckSum = lpResItem->dwCheckSum;
    m_dwStyle = lpResItem->dwStyle;
    m_dwExtStyle = lpResItem->dwExtStyle;
    m_dwFlags = lpResItem->dwFlags;
    m_dwPosId = lpResItem->dwItemID;
    m_wTabPos = wTabPos;

    m_dwCodePage = lpResItem->dwCodePage;
    m_dwLanguage = lpResItem->dwLanguage;
    m_wClassName = lpResItem->wClassName;
    m_wPointSize = lpResItem->wPointSize;
    m_wWeight = lpResItem->wWeight;
    m_bItalic   = lpResItem->bItalic;
    m_bCharSet   = lpResItem->bCharSet;

    m_szClassName = lpResItem->lpszClassName;
    m_szFaceName = lpResItem->lpszFaceName;
    m_szCaption = lpResItem->lpszCaption;
}

UINT
CItemInfo::UpdateData( LPVOID lpbuffer, UINT uiBufSize )
{
    UINT uiError = ERROR_NO_ERROR;
    //
    // This is old and was used at the very beginning. Never used now.
    //
    return uiError;

}

UINT
CItemInfo::UpdateData( LPRESITEM lpResItem )
{
    if (lpResItem){
        m_wX = lpResItem->wX;
        m_wY = lpResItem->wY;

        m_wCX = lpResItem->wcX;
        m_wCY = lpResItem->wcY;

        m_dwCheckSum = lpResItem->dwCheckSum;
        m_dwStyle = lpResItem->dwStyle;
        m_dwExtStyle = lpResItem->dwExtStyle;
        m_dwFlags = lpResItem->dwFlags;

        SetId(LOWORD(lpResItem->dwItemID)); //m_dwPosId = lpResItem->dwItemId;
        //m_wTabPos = wTabPos;

        m_dwCodePage = lpResItem->dwCodePage;
        m_dwLanguage = lpResItem->dwLanguage;
        m_wClassName = lpResItem->wClassName;
        m_wPointSize = lpResItem->wPointSize;
        m_wWeight = lpResItem->wWeight;
        m_bItalic   = lpResItem->bItalic;
        m_bCharSet   = lpResItem->bCharSet;

        m_szClassName = lpResItem->lpszClassName;
        m_szFaceName = lpResItem->lpszFaceName;
        m_szCaption = lpResItem->lpszCaption;
    }
    return 0;
}


void
CItemInfo::SetPos( WORD wPos )
{
    WORD wId = LOWORD(m_dwPosId);

    m_dwPosId = 0;
    m_dwPosId = wPos;
    m_dwPosId = (m_dwPosId << 16);

    if (wId>0)
        m_dwPosId += wId;
    else m_dwPosId -= wId;
}

void
CItemInfo::SetId( WORD wId )
{
    WORD wPos = HIWORD(m_dwPosId);

    m_dwPosId = 0;
    m_dwPosId = wPos;
    m_dwPosId = (m_dwPosId << 16);

    if (wId>0)
        m_dwPosId += wId;
    else m_dwPosId -= wId;
}

DWORD
CItemInfo::GetTabPosId()
{
    DWORD dwTabPosId = 0;
    WORD wId = LOWORD(m_dwPosId);

    dwTabPosId = m_wTabPos;
    dwTabPosId = (dwTabPosId << 16);

    if (wId>0)
        dwTabPosId += wId;
    else dwTabPosId -= wId;
    return dwTabPosId;
}

CItemInfo::CItemInfo( const CItemInfo &iteminfo )
{
    m_wX = iteminfo.m_wX;
    m_wY = iteminfo.m_wY;

    m_wCX = iteminfo.m_wCX;
    m_wCY = iteminfo.m_wCY;

    m_dwCheckSum = iteminfo.m_dwCheckSum;
    m_dwStyle = iteminfo.m_dwStyle;
    m_dwExtStyle = iteminfo.m_dwExtStyle;
    m_dwFlags = iteminfo.m_dwFlags;

    m_dwPosId = iteminfo.m_dwPosId;
    m_wTabPos = iteminfo.m_wTabPos;

    m_dwCodePage = iteminfo.m_dwCodePage;
    m_dwLanguage = iteminfo.m_dwLanguage;
    m_wClassName = iteminfo.m_wClassName;
    m_wPointSize = iteminfo.m_wPointSize;
    m_wWeight = iteminfo.m_wWeight;
    m_bItalic   = iteminfo.m_bItalic;
    m_bCharSet   = iteminfo.m_bCharSet;

    m_szClassName = iteminfo.m_szClassName;
    m_szFaceName = iteminfo.m_szFaceName;
    m_szCaption = iteminfo.m_szCaption;
}

static BYTE Allign(LONG bLen)
{
   BYTE bPad =(BYTE)PadPtr(bLen);
   return bPad;
}

static UINT CopyFile( const char * pszfilein, const char * pszfileout )
{
    CFile filein;
    CFile fileout;

    if (!filein.Open(pszfilein, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return ERROR_FILE_OPEN;

    if (!fileout.Open(pszfileout, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
        return ERROR_FILE_CREATE;

    LONG lLeft = filein.GetLength();
    WORD wRead = 0;
    DWORD dwOffset = 0;
    BYTE far * pBuf = (BYTE far *) new BYTE[32739];

    if(!pBuf)
        return ERROR_NEW_FAILED;

    while(lLeft>0){
        wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
        if (wRead!= filein.Read( pBuf, wRead))
            return ERROR_FILE_READ;
        fileout.Write( pBuf, wRead );
        lLeft -= wRead;
        dwOffset += wRead;
    }

    delete []pBuf;
    return ERROR_NO_ERROR;
}


void CheckError(LPCSTR szStr)
{
TRY
{
    DWORD dwErr = GetLastError();
    char szBuf[256];
    wsprintf( szBuf, "%s return: %d\n", szStr, dwErr);
    TRACE(szBuf);
}
CATCH( CException, e )
{
    TRACE("There is an Exception!\n");
}
END_CATCH
}


////////////////////////////////////////////////////////////////////////////
// RDF File support code

HANDLE
OpenModule(
	LPCSTR   lpszSrcfilename,       // File name of the executable to use as source file
	LPCSTR   lpszfiletype,			// Type of the executable file if known
	LPCSTR   lpszRDFfile,
    DWORD    dwFlags )
{
    TRACE2("IODLL.DLL: RSOpenModule: %s %s\n", lpszSrcfilename, lpszfiletype);
    UINT uiError = ERROR_NO_ERROR;
    INT_PTR uiHandle = 0 ;

    // Before we do anything we have to check if the file exist
    CFileStatus status;
    if(!CFile::GetStatus( lpszSrcfilename, status ))
    	return UlongToHandle(ERROR_FILE_OPEN);

    // Check if the user already knows the type of the executable
    CString szSrcFileType;
    if (!lpszfiletype) {
        if(uiError = RSFileType( lpszSrcfilename, szSrcFileType.GetBuffer(100) ))
            return UlongToHandle(uiError);
        szSrcFileType.ReleaseBuffer(-1);
    } else szSrcFileType = lpszfiletype;

    gModuleTable.Add(new CFileModule( lpszSrcfilename,
                                      lpszRDFfile,
                                      gDllTable.GetPosFromTable(szSrcFileType),
                                      dwFlags ));

    // Get the position in the array.
    uiHandle = gModuleTable.GetSize();

    // Read the informations on the type in the file.
    CFileModule* pFileModule = (CFileModule*)gModuleTable.GetAt(uiHandle-1);

    if (!pFileModule)
        return UlongToHandle(ERROR_IO_INVALIDMODULE);

    if (pFileModule->LoadDll()==NULL)
        return UlongToHandle(ERROR_DLL_LOAD);

    HINSTANCE hInst = pFileModule->GetHInstance();
    UINT (FAR PASCAL * lpfnReadResInfo)(LPCSTR, LPVOID, UINT*);
    // Get the pointer to the function to extract the resources
    lpfnReadResInfo = (UINT (FAR PASCAL *)(LPCSTR, LPVOID, UINT*))
                        GetProcAddress( hInst, "RWReadTypeInfo" );
    if (lpfnReadResInfo==NULL) {
        return UlongToHandle(ERROR_DLL_PROC_ADDRESS);
    }

    UINT uiSize = 50000;
    BYTE far * pBuf = new BYTE[uiSize];

    if (!pBuf)
        return UlongToHandle(ERROR_NEW_FAILED);

    uiError = (*lpfnReadResInfo)((LPCSTR)pFileModule->GetName(),
                                 (LPVOID)pBuf,
                                 (UINT*) &uiSize);

    // Check if the buffer was big enough
    if (uiSize>50000) {
        // The buffer was too small reallocate
        UINT uiNewSize = uiSize;
        delete [] pBuf;
        pBuf = new BYTE[uiSize];
        if (!pBuf)
            return UlongToHandle(ERROR_NEW_FAILED);
        uiError = (*lpfnReadResInfo)((LPCSTR)pFileModule->GetName(),
                                 (LPVOID)pBuf,
                                 (UINT*) &uiSize);
        if (uiSize!=uiNewSize)
            return UlongToHandle(ERROR_NEW_FAILED);

    }

    if (uiError!=ERROR_NO_ERROR) {
        delete pBuf;
        pFileModule->CleanUp();
        return UlongToHandle(uiError);
    }

    // We have a buffer with all the information the DLL was able to get.
    // Fill the array in the CFileModule class

    BYTE* pBufPos = pBuf;
    BYTE* pBufStart = pBuf;

    WORD wTypeId;
    WORD wNameId;

    CString szTypeId;
    CString szNameId;

    DWORD dwlang;
    DWORD dwfileOffset;
    DWORD dwsize;

    pFileModule->SetResBufSize( uiSize );
    while(uiSize) {
        wTypeId = *((WORD*)pBuf);
        pBuf += sizeofWord;

        szTypeId = (char*)pBuf;
        pBuf += strlen((char*)pBuf)+1;
        pBuf += Allign((LONG)(pBuf-pBufPos));

        wNameId = *((WORD*)pBuf);
        pBuf += sizeofWord;

        szNameId = (char*)pBuf;
        pBuf += strlen((char*)pBuf)+1;
        pBuf += Allign((LONG)(pBuf-pBufPos));

        dwlang = *((DWORD*)pBuf);
        pBuf += sizeofDWord;

        dwsize = *((DWORD*)pBuf);
        pBuf += sizeofDWord;

        dwfileOffset = *((DWORD*)pBuf);
        pBuf += sizeofDWord;

        uiSize -= (UINT)(pBuf-pBufPos);
        pBufPos = pBuf;


        TRACE1("TypeId: %d\t", wTypeId);
        TRACE1("TypeName: %s\t", szTypeId);
        TRACE1("NameId: %d\t", wNameId);
        TRACE1("NameName: %s\t", szNameId);
        TRACE1("ResLang: %lu\t", dwlang);
        TRACE1("ResSize: %lu\t", dwsize);
        TRACE1("FileOffset: %lX\n", dwfileOffset);

        //TRACE1("uiError: %u\n", uiSize);
       	pFileModule->AddResInfo( wTypeId,
                              szTypeId,
                              wNameId,
                              szNameId,
                              dwlang,
                              dwsize,
                              dwfileOffset );
    }

    delete pBufStart;
    return (HANDLE)(uiHandle+FIRSTVALIDVALUE);
}

////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation

////////////////////////////////////////////////////////////////////////////
// Library init
////////////////////////////////////////////////////////////////////////////
// This function should be used verbatim.  Any initialization or termination
// requirements should be handled in InitPackage() and ExitPackage().
//
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory
		// here, use the TRACE or ASSERT macros or call MessageBox
		AfxInitExtensionModule(extensionDLL, hInstance);
		g_iDllLoaded = 0;
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxWinTerm();
	}

	if (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)
		return 0;		// CRT term	Failed

	return 1;   // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rsrc\afxres.h ===
// afxres.h

#include <windows.h>
#undef _WIN32
#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rsrc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\delcert\delcert.cpp ===
////    DelCert - Delete all certificates in Win32 image
//





/////   delCert Command line
//
//c     delCert Executable
//
//p     Executable: Win32 binary to update
//








#pragma warning( disable : 4786 )       // map creates some ridiculously long debug identifiers


#include "stdio.h"
#include "windows.h"
#include "imagehlp.h"
#include "time.h"

#define DBG 1


void __cdecl DebugMsg(char *fmt, ...) {

    va_list vargs;

    va_start(vargs, fmt);
    vfprintf(stderr, fmt, vargs);
}

BOOL g_fError = FALSE;


#define warn DebugMsg

#define MUST(a,b) {HRESULT hr; hr = (a); if (hr!= S_OK) {if (!g_fError) DebugMsg b; g_fError = TRUE; return E_FAIL;};}
#define SHOULD(a,b) {HRESULT hr; hr = (a); if (hr!= S_OK) {DebugMsg b; g_fWarn = TRUE; return S_FALSE;};}


#if DBG

    #pragma message("Checked build")

    #define OK(a) {HRESULT hr; hr = (a); if (hr!= S_OK) {DebugMsg("%s(%d): error RSRC999 : HRESULT not S_OK: "#a"\n", __FILE__, __LINE__); return hr;};}
    #define ASSERT(a) {if (!(a)) {DebugMsg("%s(%d): error RSRC999 : Assertion failed: "#a"\n", __FILE__, __LINE__); return E_UNEXPECTED;};}

#else

    #pragma message ("Free build")

    #define OK(a) {HRESULT hr; hr = (a); if (hr != S_OK) return hr;}
    #define ASSERT(a)  {if (!(a)) {return E_UNEXPECTED;};}

#endif




////    Mapped files
//
//      File mapping is used to read executable and token files.
//
//      File mapping is also used to update in place checksum information
//      in executable and symbol files.


class MappedFile {

    HANDLE  m_hFileMapping;
    BOOL    fRW;             // True when writeable
    char    m_szFileName[MAX_PATH];

public:

    BYTE   *m_pStart;
    BYTE   *m_pLimit;

    MappedFile() {m_hFileMapping = NULL;}

    HRESULT Open(const char *pcFileName, BOOL fWrite) {

        HANDLE hFile;

        strcpy(m_szFileName, pcFileName);

        hFile = CreateFileA(
                           pcFileName,
                           GENERIC_READ     | (fWrite ? GENERIC_WRITE : 0),
                           FILE_SHARE_READ  | (fWrite ? FILE_SHARE_WRITE | FILE_SHARE_DELETE : 0 ),
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        ASSERT(hFile != INVALID_HANDLE_VALUE);

        m_hFileMapping = CreateFileMapping(
                                          hFile,
                                          NULL,
                                          fWrite ? PAGE_READWRITE : PAGE_WRITECOPY,
                                          0,0, NULL);

        ASSERT(m_hFileMapping != NULL);

        m_pStart = (BYTE*) MapViewOfFile(
                                        m_hFileMapping,
                                        fWrite ? FILE_MAP_WRITE : FILE_MAP_READ,
                                        0,0, 0);

        ASSERT(m_pStart != NULL);

        m_pLimit = m_pStart + GetFileSize(hFile, NULL);
        CloseHandle(hFile);

        fRW = fWrite;
        return S_OK;
    }




    DWORD CalcChecksum() {

        DWORD dwHeaderSum;
        DWORD dwCheckSum;

        if (CheckSumMappedFile((void*)m_pStart, (DWORD)(m_pLimit-m_pStart), &dwHeaderSum, &dwCheckSum) == NULL) {
            return 0;
        } else {
            return dwCheckSum;
        }
    }




    HRESULT Close() {
        if (m_pStart) {
            UnmapViewOfFile(m_pStart);
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
            m_pStart = NULL;
        }
        return S_OK;
    }
};









class Win32Executable : public MappedFile {

    IMAGE_NT_HEADERS      *m_pNtHeader;
    IMAGE_SECTION_HEADER  *m_pSections;

public:

    DWORD GetChecksum()      const {return m_pNtHeader->OptionalHeader.CheckSum;}
    void  SetChecksum(DWORD dwChecksum) {m_pNtHeader->OptionalHeader.CheckSum=dwChecksum;}

    void  SetCertificateRVA (DWORD rva)
    {
        m_pNtHeader->OptionalHeader
        .DataDirectory[IMAGE_DIRECTORY_ENTRY_SECURITY]
        .VirtualAddress
        = rva;
    }

    HRESULT Open(const char *pcFileName, BOOL fWrite) {

        int i;

        OK(MappedFile::Open(pcFileName, fWrite));


        MUST((    *(WORD*)m_pStart == IMAGE_DOS_SIGNATURE
                  &&  *(WORD*)(m_pStart+0x18) >= 0x40)    // WinVer >= 4
             ? S_OK : E_FAIL,
             ("RSRC : error RSRC501: %s is not an executable file\n", pcFileName));

        m_pNtHeader = (IMAGE_NT_HEADERS*)(m_pStart + *(WORD*)(m_pStart+0x3c));

        MUST((m_pNtHeader->Signature == IMAGE_NT_SIGNATURE)
             ? S_OK : E_FAIL,
             ("RSRC : error RSRC502: %s is not a Win32 executable file\n", pcFileName));

        m_pSections     = (IMAGE_SECTION_HEADER*)(m_pNtHeader+1);

        return S_OK;
    }
};













void DeleteCertificates(
                       const char *fileName
                       )
{

    HANDLE fileHandle = CreateFile(
                                  fileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  0,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  NULL
                                  );

    if (fileHandle == INVALID_HANDLE_VALUE) {
        warn("Could not access %s\n", fileName);
        return;
    }

    DWORD certificateCount;
    DWORD *certificateIndices;

    if (!ImageEnumerateCertificates(
                                   fileHandle,
                                   CERT_SECTION_TYPE_ANY,
                                   &certificateCount,
                                   NULL,
                                   0
                                   )) {
        warn("Could not enumerate certificates in %s.\n", fileName);
        CloseHandle(fileHandle);
        return;
    }

    if (certificateCount == 0) {
        warn("No certificates found in %s.\n", fileName);
        CloseHandle(fileHandle);
        return;
    }


    certificateIndices = new DWORD[certificateCount];

    if (certificateIndices == NULL) {
        CloseHandle(fileHandle);
        warn("Couldn't allocate buffer for %d certificate indices for %s.\n", certificateCount, fileName);
        return;
    }

    ImageEnumerateCertificates(
                              fileHandle,
                              CERT_SECTION_TYPE_ANY,
                              &certificateCount,
                              certificateIndices,
                              certificateCount
                              );

    if (certificateCount == 0) {
        warn("Couldn't get certificate indices for %s.\n", fileName);
        CloseHandle(fileHandle);
        return;
    }


    for (DWORD i=0; i<certificateCount; i++) {
        if (!ImageRemoveCertificate(fileHandle, certificateIndices[i])) {
            warn("Could not remove certificate index %d from %s\n", certificateIndices[i], fileName);
            CloseHandle(fileHandle);
            return;
        }
    }


    warn("All %d certificate(s) removed from %s.\n", certificateCount, fileName);
    CloseHandle(fileHandle);


    // Now clear the rva of any security certificates

    Win32Executable w32x;

    if (w32x.Open(fileName, TRUE) != S_OK) {
        warn("Could not map %s to update security certificate RVA\n", fileName);
        return;
    }

    w32x.SetCertificateRVA(0);
    w32x.SetChecksum(w32x.CalcChecksum());

    w32x.Close();

    warn("Certificate section virtual address zeroed in %s section index.\n", fileName);
}


////    Parameter parsing
//
//


char g_cSwitch = '-';   // Switch character is recorded the first time one is seen


void SkipWhitespace(char** p, char* pE) {
    while ((*p<pE) && ((**p==' ')||(**p==9))) (*p)++;
}


void ParseToken(char** p, char* pE, char* s, int l) {

    // Parse up to whitespace into string s
    // Guarantee zero terminator and modify no more than l chars
    // Return with p beyond whitespace


    if (*p < pE  &&  **p == '\"') {

        // Quoted parameter

        (*p)++;  // Skip over leading quote

        while (l>0  &&  *p<pE  &&  **p!='\"') {
            *s=**p;  s++;  (*p)++;  l--;
        }

        // Skip any part of token that didn't fit s

        while (*p<pE  &&  **p!='\"') { // Skip up to terminating quote
            (*p)++;
        }

        if (*p<pE) { // Skip over terminating quote
            (*p)++;
        }

    } else {

        // Unquoted parameter


        while ((l>0) && (*p<pE) && (**p>' ')) {
            *s=**p;  s++;  (*p)++;
            l--;
        }

        // Skip any part of token that didn't fit into s
        while ((*p<pE) && (**p>' ')) (*p)++;
    }


    if (l>0)
        *s++ = 0;
    else
        *(s-1) = 0;

    SkipWhitespace(p, pE);
}


void ParseName(char** p, char* pE, char* s, int l) {

    // Uses ParseToken to parse a name such as a filename.
    // If the name starts with '/' or '-' it is assumed to be
    // an option rather than a filename and ParseName returns
    // a zero length string.

    if (*p<pE  &&  **p==g_cSwitch) {

        // This is an option and should not be treated as a name argument

        s[0] = 0;

    } else {

        ParseToken(p, pE, s, l);
    }
}





void DisplayUsage() {
    fprintf(stdout, "Usage: delCert executable\n");
}


DWORD g_dwOptions = 0;
#define OPTHELP 1


HRESULT ProcessParameters() {

    char   *p;      // Current command line character
    char   *pE;     // End of command line
    char   *pcStop;

    char    token        [MAX_PATH];
    char    szExecutable [MAX_PATH];

    int     i,j;
    int     cFiles    = 0;

    BOOL    fArgError = FALSE;

    p  = GetCommandLine();
    pE = p+strlen((char *)p);


    // Skip command name
    ParseToken(&p, pE, token, sizeof(token));

    while (p<pE) {
        ParseToken(&p, pE, token, sizeof(token));

        if (    token[0] == '-'
                ||  token[0] == '/') {

            // Process command option(s)

            i = 1;
            g_cSwitch = token[0];       // Argument may start with the other switch character
            CharLower((char*)token);
            while (token[i]) {
                switch (token[i]) {
                    case '?':
                    case 'h': g_dwOptions |= OPTHELP;      break;

                    default:
                        fprintf(stderr, "Unrecognised argument '%c'.\n", token[i]);
                        fArgError = TRUE;
                        break;
                }
                i++;
            }

        } else {

            // Process filename

            switch (cFiles) {
                case 0:  strcpy(szExecutable, token); break;
            }
            cFiles++;
        }
    }


    if (    fArgError
            ||  g_dwOptions & OPTHELP) {

        DisplayUsage();
        return S_OK;

    } else if (cFiles != 1) {

        DisplayUsage();
        return E_INVALIDARG;

    } else {

        // We have valid parameters

        DeleteCertificates(szExecutable);
        return S_OK;
    }
}






int _cdecl main(void) {

    if (SUCCEEDED(ProcessParameters())) {

        return 0;       // No problems

    } else {

        return 2;       // Error(s)

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\common\helper.cpp ===
//////////////////////////////////////////////
//
// This file has the helper function used in the win32 r/w
// I copied them in this file to share them with the res32 r/w
//
#include <afxwin.h>
#include "..\common\helper.h"

//=============================================================================
// Get functions
//

UINT
GetPascalStringW( BYTE  * * lplpBuf, LPSTR lpszText, WORD wMaxLen, LONG* pdwSize )
{
    // Get the length of the string
    WORD wstrlen = 0;
    WORD wMBLen = 0;
    GetWord( lplpBuf, &wstrlen, pdwSize );

    if ((wstrlen+1)>wMaxLen) {
        *pdwSize -= wstrlen*2;
        *lplpBuf += wstrlen*2;
    } else {
        if (wstrlen) {
	        WCHAR* lpwszStr = new WCHAR[wstrlen+1];
	        if (!lpwszStr) *pdwSize =0;
	        else {
	        	memcpy(lpwszStr, *lplpBuf, (wstrlen*2));
	        	*(lpwszStr+wstrlen) = 0;
	        	wMBLen = (WORD)_WCSTOMBS( lpszText, (WCHAR*)lpwszStr, wMaxLen);
	        	delete lpwszStr;
	        }
        }
        *(lpszText+wMBLen) = 0;
        *lplpBuf += wstrlen*2;
        *pdwSize -= wstrlen*2;
    }
    return(wstrlen+1);
}

UINT
GetPascalStringA( BYTE  * * lplpBuf, LPSTR lpszText, BYTE bMaxLen, LONG* pdwSize )
{
    // Get the length of the string
    BYTE bstrlen = 0;

    GetByte( lplpBuf, &bstrlen, pdwSize );

    if ((bstrlen+1)>bMaxLen) {
        *pdwSize -= bstrlen;
        *lplpBuf += bstrlen;
    } else {
        if (bstrlen)
	        memcpy(lpszText, *lplpBuf, bstrlen);

        *(lpszText+bstrlen) = 0;
        *lplpBuf += bstrlen;
        *pdwSize -= bstrlen;
    }
    return(bstrlen+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\common\helper.h ===
//=============================================================================
// These are headers for common rw functions
//=============================================================================

//=============================================================================
// Global definitions

#define MAXSTR 8192

#define Pad4(x) ((((x+3)>>2)<<2)-x)
#define Pad16(x) ((((x+15)>>4)<<4)-x)

extern  UINT g_cp/* = CP_ACP*/; // Default to CP_ACP

//=============================================================================
// Functions prototypes

UINT _MBSTOWCS( WCHAR * pwszOut, CHAR * pszIn, UINT nLength);
UINT _WCSTOMBS( CHAR * pszOut, WCHAR * wszIn, UINT nLength);
UINT _WCSLEN( WCHAR * pwszIn );


UINT GetStringW( BYTE * * lplpBuf, LPSTR lpszText, LONG* pdwSize, WORD cLen );
UINT GetStringA( BYTE * * lplpBuf, LPSTR lpszText, LONG* pdwSize );
UINT GetPascalStringW( BYTE * * lplpBuf, LPSTR lpszText, WORD wMaxLen, LONG* pdwSize );
UINT GetPascalStringA( BYTE * * lplpBuf, LPSTR lpszText, BYTE bMaxLen, LONG* pdwSize );
UINT GetNameOrOrd( BYTE * * lplpBuf, WORD* wOrd, LPSTR lpszText, LONG* pdwSize );
UINT GetNameOrOrdU( PUCHAR pRes, ULONG ulId, LPWSTR lpwszStrId, DWORD* pdwId );

BYTE GetDWord( BYTE * * lplpBuf, DWORD* dwValue, LONG* pdwSize );
BYTE GetWord( BYTE * * lplpBuf, WORD* wValue, LONG* pdwSize );
BYTE GetByte( BYTE * * lplpBuf, BYTE* bValue, LONG* pdwSize );


UINT PutStringA( BYTE * * lplpBuf, LPSTR lpszText, LONG* pdwSize );
UINT PutStringW( BYTE * * lplpBuf, LPSTR lpszText, LONG* pdwSize );
UINT PutNameOrOrd( BYTE * * lplpBuf, WORD wOrd, LPSTR lpszText, LONG* pdwSize );
UINT PutPascalStringW( BYTE * * lplpBuf, LPSTR lpszText, WORD wLen, LONG* pdwSize );

BYTE PutDWord( BYTE * * lplpBuf, DWORD dwValue, LONG* pdwSize );
BYTE PutWord( BYTE * * lplpBuf, WORD wValue, LONG* pdwSize );
BYTE PutByte( BYTE * * lplpBuf, BYTE bValue, LONG* pdwSize );

UINT SkipByte( BYTE far * far * lplpBuf, UINT uiSkip, LONG* pdwRead );

LONG ReadFile(CFile*, UCHAR *, LONG);
UINT CopyFile( CFile* filein, CFile* fileout );

LONG Allign( BYTE * * lplpBuf, LONG* plBufSize, LONG lSize );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rsrc\rsrc.cpp ===
////    RSRC - Win32 command line resource manager
//
//      Copyright (c) 1996-9, Microsoft Corporation. All rights reserved.
//
//      David C Brown  [dbrown]  29th October 1998.





/////   RSRC Command line
//
//c     RSRC Executable [-l LocLang] [-u UnlocLang] [-i Types] [-q]
//c          [   [-t|-d] TextOutput [-c UnlocExecutable]
//c            | [-a|-r] text-input [-s symbols] [-v]    ]
//
//p     Executable: Win32 binary to analyse (default), to generate tokens (-t)
//          or dump (-d) from, or containing resources to be replaced (-r)
//          or appended to (-a).
//
//p     -l LocLang: Restrict processing to the specified localized language. LangId
//          should be specified as a full hex NLS Language id, for example use
//          '-l 409' for US English. Required for replace (-r) operation.
//
//p     -u UnlocLang: Specifies unlocalized language, defaults to 409 (US English).
//
//p     -i Types: Restrict processing to listed types. Each type is indicated by a letter
//          as below:
//
//t         Letter | Type      |    Letter | Type             |   Letter | Type
//t         ------ | ----      |    ------ | ----             |   ------ | ----
//t            c   | Cursors   |      g    | Message tables   |      n   | INFs
//t            b   | Bitmaps   |      v    | Version info     |      h   | HTML
//t            i   | Icons     |      a    | Accelerators     |      x   | Binary data
//t            m   | Menus     |      f    | Font directories |          |
//t            d   | Dialogs   |      t    | Fonts            |      o   | All others
//t            s   | Strings   |      r    | RCDATA           |      a   | All (default)
//
//
//p     -q: Quiet. By default Rsrc displays summary statistics of types and languages
//          of resources processed. -q suppresses all output except warning and error messages.
//
//p     -t TextOutput: Generate tokens in checkin format.
//
//p     -d TextOutput: Dump resources in Hex & ASCII format.
//
//p     -c UnlocExecutable: Compare with unlocalized (English) resources - localised
//          resources in executable are compared with English resources in
//          UnlocExecutable. When the localised resource is bit for bit identical
//          with the English resource RSRC writes a one line unloc
//          token instead of the full resource. Valid only with tokenise (-t)
//          option.
//
//p     -a TextInput: Append resources from text input file. Every resource in the
//          text file is added to the executable. Resources already in the executable
//          are not removed. When a resource from the token file has the same type, id
//          and language as one in the executable, the executable resource is replaced
//          by the token resource.
//
//p     -r TextInput: Replace English resources in executable by localised resources
//          from text file. Requires -l parameter to specify localisation language.
//          When a resource from the token file has the same type and id as one in the
//          executable, and the executable resource is US English (409) and the localised
//          resource is in the language specified on the -l parameter, the US English
//          resource is removed.
//
//p     -s Symbols: Symbol file (.dbg format). When RSRC updates the header checksum
//          in executable, it will also do so in the named symbol file. Valid only
//          with the replace (-r) and append (-a) options.
//
//
//      Miscellaneous options
//
//p     -v: Update file and product version. By default any file and product version
//          in the token file is ignored during update/append, the file and product
//          versions from the original unlocalised resources are retained.
//






/////   Definitions
//
//p     Resource key: The combination of resource type, resource id and
//          resource language. The resource key uniquely identifies the
//          resource. A Win32 executable can contain any combination of
//          languages, ids and types so long as no two resources have the
//          same type, key and language.
//
//p     Resource type: A numeric or string value. Some numeric values are
//          predefined, for example menus and dialogs, but apps can and
//          do use any value they choose.
//
//p     Resource id: A numeric or string value. Used by an application to
//          identify the resource when calling FindResource, LoadString etc.
//
//p     Resource language: An NLS LANGID, i.e. a combination of primary and
//          sub-language, such as 0409 (US English).
//
//p     Unloc token: A line in the token file specifying a localised resource
//          key followed by '=lang,cksum' where lang is the unlocalised
//          language (usually 0409) and cksum is the checksum of the unlocalised
//          resource. Used when the only difference between the localised and
//          unlocalised resource is the language in the resource key.





/////   Use during localisation checkin process
//
//c     RSRC LocalisedExecutable -c UnlocExecutable -t Tokens -l LocLang [-u UnlocLang]
//
//      Extracts localized tokens for the specified langauge.
//
//      Where a resource in the localised executable is bit for bit identical
//      to a resource in the unlocalized executable, the resource content is not
//      written to the token file. In its place RSRC writes an unloc token
//      giving the checksum of the resource and specifying the target language.
//
//      Warnings are generated if the localised executable contains resources
//      in languages other than that specified by the -l parameter.
//
//      Unlocalised resources for comparison are looked up in the unlocalised
//      executable in the language specified on the -u parameter, default 409
//      (US ENglish).






/////   Use during the build to update a single language executable
//
//c     RSRC Executable [-u UnlocLang] -r Tokens -l LocLang -s SymbolFile
//
//      Each localised resource in the token file is added to the executable.
//
//      Each corresponding unlocalized resource is removed from the executable.
//
//      For each unloc token the unlocalized resource is found in the executable
//      and its language is updated to the target localized language recorded
//      in the unloc token.
//
//      Tokens of other than the specified localised language are not
//      processed, but generate warnings.
//
//      Warnings are generated for any resources not appearing in both the
//      executable and token files.
//
//      Warnings are also generated for resources of other than the unlocalised
//      language found in the original executable, and resources of other than
//      the localised language in the token file.
//
//      The unlocalised language defaults to 409 (US English).




/////   Use during the build to add resources to a multi-language executable
//
//c     RSRC Executable [-u UnlocLang] -a Tokens [-l Language] -s SymbolFile
//
//      Localised resources from the token file are added to the executable.
//
//      For each unloc token the unlocalised resource is found in the executable
//      and copied for the localised language recorded in the unloc token.
//
//      If '-l Languge' is specified, only tokens of that language are added.
//      When used with the append (-a) option, '-l Language' applies only to
//      the token file: pre-existing resources in the executable are not affected.
//
//      If a resource from the token file matches a resource already in the
//      executable in type, name and language, the executable resource
//      is replaced.
//
//      Warnings are generated if any token in the executable is replaced, or
//      if the unlocalised resource corresponding to an unloc token is missing
//      or has a checksum which differs from the unlocalised resource that was
//      passed on the '-u' parameter when the toke file was created.
//
//      If the '-l Language' option is used, warnings are generated for any
//      resources of other languages found in the token file.





/////   Token format - resource key and header
//
//      A resource may be represented by one or more lines. When
//      a resource is spread over more than one line, all lines except the
//      first are indented by three spaces.
//
//      The first line of every resource starts with the resource key as follows:
//
//      type,id,language;
//
//      This is followed by the codepage recorded in the resource directory.
//      Note that the codepage is not part of the resource key, and is not
//      maintained consistently by all software. In particular:
//
//      o RC writes the codepage as zero
//      o The NT UpdateResource API writes the codepage as 1252
//      o Locstudio writes a codepage that corresponds to the resource language
//
//      Winnt.h documents the codepage as follows:
//
//      "Each resource data entry ... contains ... a CodePage that should be
//      used when decoding code point values within the resource data.
//      Typically for new applications the code page would be the unicode
//      code page.'
//
//      In practise I have never seen the codepage value set to Unicode (1200).
//
//      If the '-c' (unlocalised comparison) parameter was provided on the
//      rsrc command, and there was an unlocalised resource with the same type
//      and id, the language and checksum of that unlocalised resource are
//      appended.
//
//      Finally, the resource data is represented in one of the forms below,
//      or as 'unloc' if the resource data exactly matches the unlocalised resource
//      found in the file passed by 'c'.
//
//
//      There are thus three possible token key/header formats as follows:
//
//c     type,id,language;codepage;resource-data
//
//      Resource recorded in full, either no '-c' parameter specified, or
//      resource does not exist in unlocalised file.
//
//
//c     type,id,language;codepage,unlocalised-checksum,language;resource-data
//
//      Resource recorded in full, '-c' parameter was specified, and localised
//      resource image differed from unlocalised resource image.
//
//
//c     type,id,language;codepage,unlocalised-checksum,language;'Unloc'
//
//      Resource recorded in full, '-c' parameter was specified, and localised
//      resource image was identical to unlocalised resource image.








/////   Token samples - default hex format
//
//
//      For most resource types, RSRC generates resources
//      as a string of hex digits.
//
//      For example, the following represents an accelerator resource.
//
//c     0009,0002,0409;00000000;Hex;00000020:030074008e00000003002e00840000000b0044008400000087002e0084000000
//
//      o Type 0x0009 (Accelerator)
//      o Id   0x0002
//      o Language 0x0409 (LANG_ENGLISH, SUBLANG_US)
//      o Codepage 0 (implies resource was probably generated by RC)
//      o Length in bytes 0x0020
//
//      The resource is short, so its hex representation follows the length.
//
//
//      A larger binary resource is represented on multiple lines as follows:
//
//c     000a,4000,0409;00000000;Hex;0000016a
//c        00000000:0000640100004c0000000114020000000000c000000000000046830000003508000050130852c8e0bd0170493f38ace1bd016044d085c9e0bd01003000000000000001000000000000000000000000000000590014001f0fe04fd020ea3a6910a2d808002b30309d190023563a5c000000000000000000000000000000000065
//c        00000080:7c15003100000000003025a49e308857696e6e74000015003100000000002f25d3863508466f6e747300000000490000001c000000010000001c0000003900000000000000480000001d0000000300000063de7d98100000005f535445504853544550485f00563a5c57494e4e545c466f6e7473000010000000050000a02400
//c        00000100:00004200000060000000030000a05800000000000000737465706800000000000000000000004255867d3048d211b5d8d085029b1cfa4119c94a9f4dd211871f0000000000004255867d3048d211b5d8d085029b1cfa4119c94a9f4dd211871f00000000000000000000
//
//      o Type 0x000a (RCDATA)
//      o Id   0x4000
//      o Language 0x0409 (LANG_ENGLISH, SUBLANG_US)
//      o Codepage 0
//      o Length in bytes 0x016a
//
//      The hex representation is split onto multiple lines each of 128 bytes.






/////   Warnings and errors
//
//
//
//
//
//      o warning RSRC100: Localised resource has no corresponding unlocalised resource in %s
//      o warning RSRC110: Unlocalised resource from token file appended to executable
//      o warning RSRC111: Unlocalised resource from token file replaced unlocalised resource in executable
//      o warning RSRC112: Localised resource from token file replaced localised resource already present in executable
//      o warning RSRC113: Localised resource from token file appended to executable - there was no matching unlocalised resource
//
//      o warning RSRC120: Token file resource does not match specified language - ignored
//      o warning RSRC121: Token file resource is not a requested resource type - ignored
//      o warning RSRC122: executable unlocalised resource checksum does not match checksum recorded in token file for resource %s
//      o warning RSRC124: missing executable unlocalised resource for %s
//      o warning RSRC125: executable contains no unlocalised resource corresponding to resource %s
//
//      o warning RSRC160: Symbol file does not match exectable
//      o warning RSRC161: Symbol file not processed
//      o warning RSRC162: Could not reopen executable %s to update checksum
//      o warning RSRC163: Failed to write updated symbol checksum
//
//      o warning RSRC170: No localizable resources in %s
//      o warning RSRC171: could not close executable
//
//
//      o error   RSRC230: 'Unloc' token is missing unlocalised resource information for %s
//      o error   RSRC231: Failed to apply unloc token
//      o error   RSRC232: Failed to apply token
//
//      o error   RSRC300: Hex digit expected
//      o error   RSRC301: Hex value too large
//      o error   RSRC302: Unexpected end of file
//      o error   RSRC303: \'%s\' expected
//      o error   RSRC304: newline expected
//      o error   RSRC310: Unrecognised resource type for resource %s
//
//      o error   RSRC400: -t (tokenise) option excludes -d, -a, -r, and -s
//      o error   RSRC401: -d (dump) option excludes -t, -u, -a, -r, and -s
//      o error   RSRC402: -a (append) option excludes -t, -d, -u, and -r
//      o error   RSRC403: -r (replace) option excludes -t, -d, -u, and -a
//      o error   RSRC404: -r (replace) option requires -l (LangId)
//      o error   RSRC405: Analysis excludes -s
//
//      o error   RSRC420: Update failed.
//      o error   RSRC421: Token extraction failed.
//      o error   RSRC422: Analysis failed.
//
//      o error   RSRC500: Corrupt executable - resource appears more than once
//      o error   RSRC501: %s is not an executable file
//      o error   RSRC502: %s is not a Win32 executable file
//      o error   RSRC503: No resources in %s
//
//      o error   RSRC510: Cannot open executable file %s
//      o error   RSRC511: cannot find resource directory in %s
//      o error   RSRC512: Cannot create resource token file %s
//      o error   RSRC513: Cannot open unlocalised executable file %s
//      o error   RSRC514: cannot find resource directory in unlocalised executable %s
//      o error   RSRC515: cannot write delta token file %s
//      o error   RSRC516: cannot write stand alone token file %s
//
//      o error   RSRC520: Cannot open resource token file %s
//      o error   RSRC521: UTF8 BOM missing from token file
//
//      o error   RSRC530: Cannot read executable resources from %s
//      o error   RSRC531: Failed reading update tokens
//
//      o error   RSRC600: BeginUpdateResource failed on %s
//      o error   RSRC601: UpdateResourceW failed on %s
//      o error   RSRC602: EndUpdateResourceW failed on %s










////    From Adina
//
//      Here is my follow up on 2.
//
//      Abstract:
//      The build team needs the new tool eventually run with build.exe, i.e.
//      we need build.exe recognize the errors, warnings, and simple output
//      messages from rsrc.exe and write them to build.err, build.wrn and
//      build.log files respectively.
//
//      Solution:
//      All we need is RSRC complain to the general rule for the MS tools.
//      That is (\\orville\razzle\src\sdktools\build\buildexe.c):
//             {toolname} : {number}: {text}
//
//          where:
//
//              toolname    If possible, the container and specific module that has
//                          the error.  For instance, the compiler uses
//                          filename(linenum), the linker uses library(objname), etc.
//                          If unable to provide a container, use the tool name.
//              number      A number, prefixed with some tool identifier (C for
//                          compiler, LNK for linker, LIB for librarian, N for nmake,
//                          etc).
//              test        The descriptive text of the message/error.
//
//              Accepted String formats are:
//              container(module): error/warning NUM ...
//              container(module) : error/warning NUM ...
//              container (module): error/warning NUM ...
//              container (module) : error/warning NUM ...
//
//      Ex. of RSRC error:
//
//      RSRC : error RSRC2001: unable to open file d:\nt\binaries\jpn\ntdll.dll
//
//      Ex. of RSRC warning:
//
//      RSRC : warning RSRC5000: unable to find symbol file
//      d:\nt\binaries\jpn\retail\dll\ntdll.dbg
//
//      Be aware that the error number after "error/warning" is NOT optional.
//      As the format above says, you can also display any information you
//      consider useful (for example the name of the binary being processed,
//      or the line number in the token file that caused the error/warning)
//      immediately after the name of the tool: RSRC(<info>).
//
//      I confirm that RSRC_OK=0, RSRC_WRN=1, RSRC_ERR=2 are fine with us as
//      return values. Also, it does not make any difference if you write the
//      output to stderr ot stdout, but I would suggest to write the tool's
//      usage and all the warning and error message lines to stderr, and any
//      other text to stdout (based on other ms tools we're using, like
//      rebase.exe, binplace.exe, etc).
//
//      I can make the changes to build.exe so that it recognizes RSRC.
//
//      Please let me know if you have any questions.
//
//      Thank you
//      Adina




///     Following meeting Joerg. here are my action items:
//
//      Meet with Joerg, Uwe, Majd, Hideki, Adina to plan usage in bidi NT5
//      build process and consider use for odd jobs in other languages.
//
//      P1. Implement option to skip updating file and product version, and
//          to omit these from token file.
//      P1. Implement separate error code for detecting unhandled binary
//          format (such as win16).
//
//      P2. Add CRC to each resource to detect SLM or editor corruption.
//          (Delete CRC in token file always accepted to allow hand modification).
//      P2. Option to disable header comment in token file
//
//      P3. Interpret MSGTBL, ACCELERATOR and RCDATA - RCDATA as string
//          depending on option.
//
//      Thanks -- Dave.




////    From Joerg
//
//      Howdy,
//      I'm playing with rsrc and ran into problems with ParseToken(): if rsrc
//      is located in a directory with spaces (e.g. Program Files),
//      the function fails to skip the command name, since it's quoted and
//      ParseToken stops at the first blank within the quotes.
//      I also had trouble compiling it (so I can step thru and see what it's
//      doing) under VC5 because there is no default constructor
//      for the class "LangId", so I just added a dummy constructor.
//
//      Jrg




////    Following meeting planning bidi build, Wednesday 2nd Dec.
//
//      Checksum protection against user changes to tok file
//      Include length in warning comparison
//      Will need alpha build
//      Default file name - add .rsrc
//      Don't extract file or product version
//      => If version resource updated use file and product version from
//         US at write time
//      Diagnose version only resources
//      Diagnose not win32
//      Warning for no translations on tokenisation
//      Warning no no translations on update, and don't touch executable
//      Ability to -r any unlocalised language




////    Resultant priorities (8th Dec):
//
//     1.  Use unlocalised file/product version if updating version resource
//     2.  Analyse mode diagnoses no localisable resources and unhandled binary formats
//      3.  Warn when no translations, don't touch executable if updating
//     4.  Support -r from any language to any language
//      5.  Allocate error numbers, clarify error messages
//
//      6.  Include length in unloc token
//     7.  Handle quoted installation directory and default filenames
//      8.  Add checksum protection against corruption of token file
//      9.  Option to interpret RCDATA as Unicode string (for kernel)
//      10. Interpret MSGTBL and ACCELERATOR
//      11. Support Win16 binaries
//      12. ? Option to disable token file header






#pragma warning( disable : 4786 )       // map creates some ridiculously long debug identifiers


#include "stdio.h"
#include "windows.h"
#include "imagehlp.h"
#include "time.h"
#include <map>

using namespace std ;
using namespace std::rel_ops ;



#define DBG 1


////    OK and ASSERT macros
//
//      All functions return an HRESULT.
//      All function calls are wrapped in 'OK()'.
//      OK checks for a failed HRESULT and if so returns that HRESULT directly.
//      Thus all errors propagate back up the call chain.
//
//      MUST issues a message if an HRESULT is not S_OK and returns E_FAIL
//      back up the call chain.


void __cdecl DebugMsg(char *fmt, ...) {

    va_list vargs;

    va_start(vargs, fmt);
    vfprintf(stderr, fmt, vargs);
}



#define MUST(a,b) {HRESULT hr; hr = (a); if (hr!= S_OK) {if (!g_fError) DebugMsg b; g_fError = TRUE; return E_FAIL;};}
#define SHOULD(a,b) {HRESULT hr; hr = (a); if (hr!= S_OK) {DebugMsg b; g_fWarn = TRUE; return S_FALSE;};}


#if DBG

    #pragma message("Checked build")

    #define OK(a) {HRESULT hr; hr = (a); if (hr!= S_OK) {DebugMsg("%s(%d): error RSRC999 : HRESULT not S_OK: "#a"\n", __FILE__, __LINE__); return hr;};}
    #define ASSERT(a) {if (!(a)) {DebugMsg("%s(%d): error RSRC999 : Assertion failed: "#a"\n", __FILE__, __LINE__); return E_UNEXPECTED;};}

#else

    #pragma message ("Free build")

    #define OK(a) {HRESULT hr; hr = (a); if (hr != S_OK) return hr;}
    #define ASSERT(a)  {if (!(a)) {return E_UNEXPECTED;};}

#endif


const int MAXPATH = 128;
const char HexDigit[] = "0123456789abcdef";
const BYTE bZeroPad[] = { 0, 0, 0, 0};

const int MAXHEXLINELEN=128;




const int OPTHELP     = 0x00000001;
const int OPTQUIET    = 0x00000002;
const int OPTEXTRACT  = 0x00000004;
const int OPTUNLOC    = 0x00000008;
const int OPTHEXDUMP  = 0x00000010;
const int OPTAPPEND   = 0x00000020;
const int OPTREPLACE  = 0x00000040;
const int OPTSYMBOLS  = 0x00000080;
const int OPTVERSION  = 0x00000100;


const int PROCESSCUR  = 0x00000001;
const int PROCESSBMP  = 0x00000002;
const int PROCESSICO  = 0x00000004;
const int PROCESSMNU  = 0x00000008;
const int PROCESSDLG  = 0x00000010;
const int PROCESSSTR  = 0x00000020;
const int PROCESSFDR  = 0x00000040;
const int PROCESSFNT  = 0x00000080;
const int PROCESSACC  = 0x00000100;
const int PROCESSRCD  = 0x00000200;
const int PROCESSMSG  = 0x00000400;
const int PROCESSVER  = 0x00000800;
const int PROCESSBIN  = 0x00001000;
const int PROCESSINF  = 0x00002000;
const int PROCESSOTH  = 0x00004000;


const int PROCESSALL  = 0xFFFFFFFF;




DWORD  g_dwOptions     = 0;
DWORD  g_dwProcess     = 0;
LANGID g_LangId        = 0xffff;
BOOL   g_fWarn         = FALSE;
BOOL   g_fError        = FALSE;
LANGID g_liUnlocalized = 0x0409;        // Standard unlocalized language

int    g_cResourcesIgnored    = 0;
int    g_cResourcesUpdated    = 0;      // Simple replacement
int    g_cResourcesTranslated = 0;      // Changed from unloc language to loc language
int    g_cResourcesAppended   = 0;      // Added without affecting existing resources
int    g_cResourcesExtracted  = 0;      // Extracted to token file

char   g_szTypes      [MAXPATH];
char   g_szExecutable [MAXPATH];        // Name of executable being analysed, tokenised or updated
char   g_szResources  [MAXPATH];        // Name of resource token file
char   g_szUnloc      [MAXPATH];        // Name of unlocalized executable for comparison




int HexCharVal(char c) {
    switch (c) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            return c - '0';
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
            return c - 'a' + 10;
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
            return c - 'A' + 10;
    }
    return -1;  // Not a hex value
}





////    Scanner
//
//      A structure for scanning through a block of memory


class Scanner {

protected:

    const BYTE  *m_pStart;
    const BYTE  *m_pRead;
    const BYTE  *m_pLimit;


public:

    Scanner() {m_pStart = NULL; m_pRead = NULL; m_pLimit = NULL;}
    Scanner(const BYTE *pb, DWORD dwLen) {m_pStart = pb; m_pRead = pb; m_pLimit = pb+dwLen;}
    ~Scanner() {m_pStart = NULL; m_pRead = NULL; m_pLimit=NULL;}


    const BYTE* GetRead()  {return m_pRead;}
    const BYTE* GetLimit() {return m_pLimit;}



    HRESULT Advance(UINT cBytes) {
        ASSERT(m_pStart != NULL);
        ASSERT(m_pRead+cBytes <= m_pLimit);
        m_pRead += cBytes;
        return S_OK;
    }

    HRESULT Align(const BYTE *pb, int iAlignment) {
        // Advance until read position is a multiple of iAlignment
        // past pb. iAlignment MUST be a power of 2.
        // Does not advance past limit.


        // Ensure iAlignment is a power of 2
        // This seems like a good test, though I'm not sure I could prove it!
        ASSERT((iAlignment | iAlignment-1) == iAlignment*2 - 1);


        if (m_pRead - pb & iAlignment - 1) {

            m_pRead += (iAlignment - (m_pRead - pb & iAlignment - 1));

            if (m_pRead > m_pLimit) {
                m_pRead = m_pLimit;
            }
        }
        return S_OK;
    }

    HRESULT SetRead(const BYTE *pb) {
        ASSERT(m_pRead != NULL);
        ASSERT(pb >= m_pStart);
        ASSERT(pb <  m_pLimit);
        m_pRead = pb;
        return S_OK;
    }
};






class TextScanner : public Scanner {

protected:

    const BYTE  *m_pLine;           // Start of current line
    int          m_iLine;           // Current line
    char         m_szTextPos[40];

public:

    TextScanner() {m_pLine = NULL; m_iLine = 0; Scanner();}

    virtual char *GetTextPos() {
        sprintf(m_szTextPos,  "%d:%d", m_iLine, m_pRead-m_pLine+1);
        return m_szTextPos;
    }


    ////    ReadString
    //
    //      Translates UTF8 to Unicode
    //      Removes '\' escapes as necessary
    //      Always returns a new zero terminated string

    HRESULT ReadString(WCHAR **ppwcString, int *piLen) {

        char   *pc;
        WCHAR  *pwc;
        int     iLen;


        ASSERT(*((char*)m_pRead) == '\"');
        OK(Advance(1));

        pc   = (char*)m_pRead;
        iLen = 0;


        // Count the number of unicode codepoints represented by the string

        while (    *pc != '\"'
                   &&  pc < (char*)m_pLimit) {

            while (    pc < (char*)m_pLimit
                       &&  *pc != '\\'
                       &&  *pc != '\"'       ) {

                if (*pc < 128) {
                    pc++;
                } else {
                    ASSERT(*pc >= 0xC0);    // 80-BF reserved for trailing bytes
                    if (*pc < 0xE0) {
                        pc+=2;
                    } else if (*pc < 0xF0) {
                        pc+=3;
                    } else {
                        iLen++; // Additional Unicode codepoint required for surrogate
                        pc+=4;
                    }
                    ASSERT(pc <= (char*)m_pLimit);
                }
                iLen++;
            }

            if (*pc == '\\') {
                pc++;
                if (pc < (char*)m_pLimit) {
                    pc++;
                    iLen++;
                }
            }
        }


        // Create a Unicode copy of the string

        *ppwcString = new WCHAR[iLen+1];

        ASSERT(*ppwcString != NULL);

        pwc = *ppwcString;

        while (*((char*)m_pRead) != '\"') {

            while (    *((char*)m_pRead) != '\\'
                       &&  *((char*)m_pRead) != '\"') {

                if (*m_pRead < 0x80) {
                    *pwc++ = *(char*)m_pRead;
                    m_pRead++;
                } else {
                    if (*m_pRead < 0xE0) {
                        *pwc++ =    (WCHAR)(*m_pRead     & 0x1F) << 6
                                    |  (WCHAR)(*(m_pRead+1) & 0x3F);
                        m_pRead+=2;
                    } else if (*m_pRead < 0xF0) {
                        *pwc++ =    (WCHAR)(*m_pRead     & 0x0F) << 12
                                    |  (WCHAR)(*(m_pRead+1) & 0x3F) << 6
                                    |  (WCHAR)(*(m_pRead+2) & 0x3F);
                        m_pRead+=3;
                    } else {
                        *pwc++ =     0xd800
                                     |   ((   (WCHAR)(*m_pRead     & 0x07 << 2)
                                              |  (WCHAR)(*(m_pRead+1) & 0x30 >> 4)) - 1) << 6
                                     |  (WCHAR)(*(m_pRead+1) & 0x0F) << 2
                                     |  (WCHAR)(*(m_pRead+2) & 0x30) >> 4;
                        *pwc++ =     0xdc00
                                     |  (WCHAR)(*(m_pRead+2) & 0x0f) << 6
                                     |  (WCHAR)(*(m_pRead+3) & 0x3f);
                        m_pRead+=4;
                    }
                }
            }

            if (*(char*)m_pRead == '\\') {
                m_pRead++;
                if (m_pRead < m_pLimit) {
                    switch (*(char*)m_pRead) {
                        case 'r':  *pwc++ = '\r';   break;
                        case 'n':  *pwc++ = '\n';   break;
                        case 't':  *pwc++ = '\t';   break;
                        case 'z':  *pwc++ = 0;      break;
                        case 'L':  *pwc++ = 0x2028; break; // Line separator
                        case 'P':  *pwc++ = 0x2029; break; // Paragraph separator
                        default:   *pwc++ = *(char*)m_pRead;
                    }
                    m_pRead++;
                }
            }
        }

        *pwc = 0;       // Add zero terminator
        m_pRead ++;
        *piLen = pwc - *ppwcString;


        ASSERT(m_pRead <= m_pLimit);
        return S_OK;
    }



    ////    ReadHex
    //
    //      Reads all characters up to he first non-hex digit and returns
    //      the value represented by the sequence as a DWORD


    HRESULT ReadHex(DWORD *pdwVal) {
        *pdwVal = 0;

        MUST(HexCharVal(*(char*)m_pRead) >= 0
             ? S_OK : E_FAIL,
             ("%s: error RSRC300: Hex digit expected\n", GetTextPos()));

        while (    HexCharVal(*(char*)m_pRead) >= 0
                   &&  m_pRead < m_pLimit) {

            MUST(*pdwVal < 0x10000000
                 ? S_OK : E_FAIL,
                 ("%s: error RSRC301: Hex value too large\n", GetTextPos()));


            *pdwVal = *pdwVal << 4 | HexCharVal(*(char*)m_pRead);
            OK(Advance(1));
        }
        return S_OK;
    }


    ////    ReadHexByte - Read exactly 2 hex digits

    HRESULT ReadHexByte(BYTE *pb) {
        int n1,n2; // The two nibbles.
        n1 = HexCharVal(*(char*)m_pRead);
        n2 = HexCharVal(*(char*)(m_pRead+1));

        MUST(    n1 >= 0
                 &&  n2 >= 0
                 ? S_OK : E_FAIL,
                 ("%s: error RSRC300: Hex digit expected\n", GetTextPos()));

        *pb = (n1 << 4) + n2;

        MUST(Advance(2),
             ("%s: error RSRC302: Unexpected end of file\n", GetTextPos()));
        return S_OK;
    }



    HRESULT Expect(const char *pc) {
        while (    *pc
                   &&  m_pRead+1 <= m_pLimit) {

            MUST(*(char*)m_pRead == *pc
                 ? S_OK : E_FAIL,
                 ("%s: error RSRC303: \'%s\' expected\n", GetTextPos(), pc));
            m_pRead++;
            pc++;
        }

        MUST(*pc == 0
             ? S_OK : E_FAIL,
             ("%s: error RSRC303: \'%s\' expected\n", GetTextPos(), pc));

        return S_OK;
    }



    ////    SkipLn
    //
    //      Skip to beginning of next non empty, non comment line.


    HRESULT SkipLn() {

        ASSERT(m_pRead != NULL);

        while (m_pRead < m_pLimit) {

            if (*(char*)m_pRead == '\r') {

                m_pRead++;

                if (m_pRead < m_pLimit  &&  *(char*)m_pRead == '\n') {

                    m_pRead++;
                    m_pLine = m_pRead;
                    m_iLine++;

                    if (    m_pRead < m_pLimit
                            &&  *(char*)m_pRead != '#'
                            &&  *(char*)m_pRead != '\r') {

                        break;
                    }
                }

            } else {

                m_pRead++;
            }
        }

        return S_OK;
    }



    ////    ExpectLn
    //
    //      Expect end of line, preceeded by any whitespace
    //
    //      Also skips trailing comments and whole line comments
    //
    //      Any parameter is passed to Expect to vb found at the beginning of the new line


    HRESULT ExpectLn(const char *pc) {

        ASSERT(m_pRead != NULL);

        while (    m_pRead < m_pLimit
                   &&  (    *(char*)m_pRead == ' '
                            ||  *(char*)m_pRead == '\t')) {

            m_pRead++;
        }


        if (    m_pRead < m_pLimit
                &&  (    *(char*)m_pRead == '\r'
                         ||  *(char*)m_pRead == '#')) {

            // Condition satisfied, skip to first non comment line

            SkipLn();

        } else {

            MUST(E_FAIL,("%s: error RSRC304: newline expected\n", GetTextPos()));
        }


        if (pc) {
            return Expect(pc);
        }

        return S_OK;
    }
};






////    Mapped files
//
//      File mapping is used to read executable and token files.
//
//      File mapping is also used to update in place checksum information
//      in executable and symbol files.


class MappedFile : public TextScanner {

    HANDLE  m_hFileMapping;
    BOOL    fRW;             // True when writeable
    char    m_szFileName[MAXPATH];
    char    m_szTextPos[MAXPATH+40];

public:

    MappedFile() {m_hFileMapping = NULL; TextScanner();}


    const BYTE* GetFile()  {return m_pStart;}
    virtual char *GetTextPos() {
        sprintf(m_szTextPos,  "%s(%s)", m_szFileName, TextScanner::GetTextPos());
        return m_szTextPos;
    }


    HRESULT Open(const char *pcFileName, BOOL fWrite) {

        HANDLE hFile;

        m_pStart  = NULL;
        m_pRead   = NULL;
        m_pLimit  = NULL;

        strcpy(m_szFileName, pcFileName);

        hFile = CreateFileA(
                           pcFileName,
                           GENERIC_READ     | (fWrite ? GENERIC_WRITE : 0),
                           FILE_SHARE_READ  | (fWrite ? FILE_SHARE_WRITE | FILE_SHARE_DELETE : 0 ),
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        ASSERT(hFile != INVALID_HANDLE_VALUE);

        m_hFileMapping = CreateFileMapping(
                                          hFile,
                                          NULL,
                                          fWrite ? PAGE_READWRITE : PAGE_WRITECOPY,
                                          0,0, NULL);

        ASSERT(m_hFileMapping != NULL);

        m_pStart = (BYTE*) MapViewOfFile(
                                        m_hFileMapping,
                                        fWrite ? FILE_MAP_WRITE : FILE_MAP_READ,
                                        0,0, 0);

        ASSERT(m_pStart != NULL);

        m_pRead  = m_pStart;
        m_pLine  = m_pStart;
        m_pLimit = m_pStart + GetFileSize(hFile, NULL);
        m_iLine  = 1;
        CloseHandle(hFile);

        fRW = fWrite;
        return S_OK;
    }




    DWORD CalcChecksum() {

        DWORD dwHeaderSum;
        DWORD dwCheckSum;

        if (CheckSumMappedFile((void*)m_pStart, m_pLimit-m_pStart, &dwHeaderSum, &dwCheckSum) == NULL) {
            return 0;
        } else {
            return dwCheckSum;
        }
    }




    HRESULT Close() {
        if (m_pStart) {
            UnmapViewOfFile(m_pStart);
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
            m_pStart = NULL;
        }
        return S_OK;
    }
};






////    NewFile - services for writing a new text otr binary file
//
//


class NewFile {

    HANDLE     hFile;
    DWORD      cbWrite;         // Bytes written
    BYTE       buf[4096];       // Performance buffer
    int        iBufUsed;

public:

    NewFile() {iBufUsed = 0;}

    int   GetWrite() {return cbWrite;}


    HRESULT OpenWrite(char *pcFileName) {

        cbWrite = 0;        // Bytes written

        hFile = CreateFileA(
                           pcFileName,
                           GENERIC_READ | GENERIC_WRITE,
                           0,          // Not shared
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        ASSERT(hFile != INVALID_HANDLE_VALUE);

        return S_OK;
    }




    HRESULT WriteBytes(const BYTE *pb, DWORD dwLen) {

        DWORD dwWritten;

        if (iBufUsed + dwLen <= sizeof(buf)) {

            memcpy(buf+iBufUsed, pb, dwLen);
            iBufUsed += dwLen;

        } else {

            ASSERT(hFile != NULL);

            if (iBufUsed > 0) {
                ASSERT(WriteFile(hFile, buf, iBufUsed, &dwWritten, NULL));
                ASSERT(dwWritten == iBufUsed);
                iBufUsed = 0;
            }

            if (dwLen <= sizeof(buf)) {

                memcpy(buf, pb, dwLen);
                iBufUsed = dwLen;

            } else {

                ASSERT(WriteFile(hFile, pb, dwLen, &dwWritten, NULL));
                ASSERT(dwWritten == dwLen);
            }
        }

        cbWrite += dwLen;

        return S_OK;
    }



    HRESULT WriteS(const char *pc) {
        return WriteBytes((BYTE*)pc, strlen(pc));
    }



    ////    WriteString
    //
    //      Translates Unicode to UTF8
    //      Adds '\' escapes as necessary


    HRESULT WriteString(const WCHAR *pwc, int iLen) {

        BYTE          buf[3];
        const WCHAR  *pwcLimit;

        pwcLimit = pwc + iLen;
        OK(WriteBytes((BYTE*)"\"", 1));
        while (pwc < pwcLimit) {
            switch (*pwc) {
                case 0:       OK(WriteS("\\z"));  break;
                case '\r':    OK(WriteS("\\r"));  break;
                case '\n':    OK(WriteS("\\n"));  break;
                case '\t':    OK(WriteS("\\t"));  break;
                case 0x2028:  OK(WriteS("\\L"));  break;  // Line separator
                case 0x2029:  OK(WriteS("\\P"));  break;  // Paragraph separator
                case '\"':    OK(WriteS("\\\"")); break;
                case '\\':    OK(WriteS("\\\\")); break;
                default:
                    if (*pwc < 128) {
                        OK(WriteBytes((BYTE*)pwc, 1));
                    } else if (*pwc < 0x7FF) {
                        buf[0] = 0xC0 | *pwc >> 6;
                        buf[1] = 0x80 | *pwc & 0x3F;
                        OK(WriteBytes(buf, 2));
                    } else {
                        // Note - should code surrogates properly, this doesn't
                        buf[0] = 0xE0 | *pwc>>12 & 0x0F;
                        buf[1] = 0x80 | *pwc>>6  & 0x3F;
                        buf[2] = 0x80 | *pwc     & 0x3F;
                        OK(WriteBytes(buf, 3));
                    }
            }
            pwc++;
        }
        OK(WriteBytes((BYTE*)"\"", 1));
        return S_OK;
    }



    ////    WriteHex
    //
    //      Writes the given value in the given number of digits.
    //
    //      If cDigits is zero, uses as many as necessary.



    HRESULT WriteHex(DWORD dw, int cDigits) {
        int    i;
        char   cBuf[8];

        i = 7;

        while (dw  &&  i >= 0) {
            cBuf[i] = HexDigit[dw & 0xf];
            dw >>= 4;
            i--;
        }

        if (cDigits != 0) {
            while (i >= (8-cDigits)) {
                cBuf[i] = '0';
                i--;
            }
        }

        OK(WriteBytes((BYTE*)(cBuf+i+1), 7-i));

        return S_OK;
    }



    ////    WriteHexBuffer
    //
    //      Writes a buffer of up to 256 bytes as a continuous stream of hex digits



    HRESULT WriteHexBuffer(const BYTE *pb, DWORD dwLength) {
        DWORD  i;
        char   cBuf[512];

        ASSERT(hFile);
        ASSERT(dwLength <= 256);

        for (i=0; i<dwLength; i++) {
            cBuf[2*i]   = HexDigit[*pb >> 4 & 0xf];
            cBuf[2*i+1] = HexDigit[*pb & 0xf];
            pb++;
        }

        OK(WriteBytes((BYTE*)cBuf, 2*dwLength));
        cbWrite += 2*dwLength;

        return S_OK;
    }



    ////    WriteLn
    //
    //      Write end of line mark (CR,LF)

    HRESULT WriteLn() {
        return WriteS("\r\n");
    }


    HRESULT Close() {
        DWORD dwWritten;
        if (hFile) {
            if (iBufUsed > 0) {
                ASSERT(WriteFile(hFile, buf, iBufUsed, &dwWritten, NULL));
                ASSERT(dwWritten == iBufUsed);
            }
            CloseHandle(hFile);
            hFile = NULL;
        }
        return S_OK;
    }
};






////    Resource structures
//
//      Each resource structure has an internal representation for the
//      resource that may be read and written to/from both text and
//      executable files.
//
//      The ReadTok and WriteTok functions handle formatting and parsing
//      of the token file.
//
//      The ReadBin function unpacks a resource from a memory mapped
//      executable into the internal representation.
//
//      The cbBin function returns the unpadded length required for the
//      item in executable (packed) format.
//
//      The CopyBin function packs the internal representation into a
//      target buffer.


class Resource {
public:
    virtual HRESULT ReadTok  (TextScanner &mfText)                    = 0;
    virtual HRESULT ReadBin  (Scanner     &mfBin, DWORD dwLen)        = 0;

    virtual HRESULT WriteTok (NewFile     &nfText)              const = 0;
    virtual size_t  cbBin    ()                                 const = 0;
    virtual HRESULT CopyBin  (BYTE       **ppb)                 const = 0;

    // For statistics

    virtual int     GetItems ()                                 const = 0;
    virtual int     GetWords ()                                 const = 0;
};






////    ResourceBYTE
//
//      BYTE value represented in hex digits.


class ResourceBYTE {


public:

    BYTE b;

    HRESULT ReadBin(Scanner *pmf) {
        b = *((BYTE*)(pmf->GetRead()));
        OK(pmf->Advance(sizeof(BYTE)));
        return S_OK;
    }

    size_t cbBin() const {
        return 1;
    }

    HRESULT CopyBin(BYTE **ppb) const {
        **ppb = b;
        (*ppb)++;
        return S_OK;
    }

    HRESULT ReadTok(TextScanner *pmf) {
        DWORD dw;
        OK(pmf->ReadHex(&dw));
        ASSERT(dw < 0x100);
        b = (BYTE)dw;
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf) const {
        OK(pmf->WriteHex(b, 2));
        return S_OK;
    }
};






////    ResoureWORD
//
//      WORD value represented in hex digits.


class ResourceWORD {

public:

    WORD  w;

    HRESULT ReadBin(Scanner *pmf) {
        w = *((WORD*)(pmf->GetRead()));
        OK(pmf->Advance(sizeof(WORD)));
        return S_OK;
    }

    size_t cbBin() const {
        return sizeof(WORD);
    }

    HRESULT CopyBin(BYTE **ppb) const {
        *(WORD*)*ppb = w;
        *ppb += sizeof(WORD);
        return S_OK;
    }

    HRESULT ReadTok(TextScanner *pmf) {
        DWORD dw;
        OK(pmf->ReadHex(&dw));
        ASSERT(dw < 0x10000);
        w = (WORD)dw;
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf)  const {
        OK(pmf->WriteHex(w, 4));
        return S_OK;
    }
};






////    ResourceDWORD
//
//      DWORD value represented in hex digits.


class ResourceDWORD {

public:

    DWORD dw;

    HRESULT ReadBin(Scanner *pmf) {
        dw = *((DWORD*)(pmf->GetRead()));
        OK(pmf->Advance(sizeof(DWORD)));
        return S_OK;
    }

    size_t cbBin() const {
        return sizeof(DWORD);
    }

    HRESULT CopyBin(BYTE **ppb) const {
        *(DWORD*)*ppb = dw;
        *ppb += sizeof(DWORD);
        return S_OK;
    }

    HRESULT ReadTok(TextScanner *pmf) {
        OK(pmf->ReadHex(&dw));
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf) const {
        OK(pmf->WriteHex(dw, 8));
        return S_OK;
    }
};






////    ResourceString
//
//      String displayed with quotes. May be zero terminated or length
//      word.


const WCHAR wcZero = 0;

class ResourceString {

    WCHAR *pwcString;
    WORD   iLen;

    void rsFree() {
        if (pwcString)
            delete [] pwcString;
        pwcString = NULL;
        iLen = 0;
    }

public:

    ResourceString() {pwcString = NULL; iLen = 0;}
    ~ResourceString() {rsFree();}

    ResourceString& operator= (const ResourceString &rs) {
        iLen      = rs.iLen;
        pwcString = new WCHAR[iLen+1];
        memcpy(pwcString, rs.pwcString, 2*(iLen+1));
        return *this;
    }

    ResourceString(const ResourceString &rs) {
        *this = rs;
    }


    const WCHAR *GetString() const {return pwcString;}
    const int    GetLength() const {return iLen;};
    void         SetEmpty ()       {iLen = 0;  pwcString = NULL;}

    HRESULT ReadBinL(Scanner *pmf) {
        rsFree();

        iLen = *((WORD*)(pmf->GetRead()));
        OK(pmf->Advance(sizeof(WORD)));

        pwcString = new WCHAR[iLen+1];
        ASSERT(pwcString != NULL);
        memcpy(pwcString, (WCHAR*)pmf->GetRead(), 2*iLen);
        pwcString[iLen] = 0;

        OK(pmf->Advance(iLen * sizeof(WCHAR)));
        return S_OK;
    }

    size_t cbBinL() const {
        return iLen * sizeof(WCHAR) + sizeof(WORD);
    }

    HRESULT CopyBinL(BYTE **ppb) const {
        *(WORD*)*ppb = iLen;
        *ppb += sizeof(WORD);
        memcpy(*ppb, pwcString, sizeof(WCHAR)*iLen);
        *ppb += sizeof(WCHAR)*iLen;
        return S_OK;
    }


    // Zero terminated

    HRESULT ReadBinZ(Scanner *pmf) {

        const WCHAR* pwc;
        rsFree();

        pwc = (WCHAR*)pmf->GetRead();
        while (*(WCHAR*)pmf->GetRead() != 0) {
            OK(pmf->Advance(2));
        }

        iLen = (WCHAR*)pmf->GetRead() - pwc;
        OK(pmf->Advance(2));


        pwcString = new WCHAR[iLen+1];
        ASSERT(pwcString != NULL);
        memcpy(pwcString, pwc, 2*(iLen+1));

        return S_OK;
    }

    size_t cbBinZ() const {
        return (iLen+1) * sizeof(WCHAR);
    }


    // Known length (dwLen excludes zero terminator)

    HRESULT ReadBin(Scanner *pmf, DWORD dwLen) {

        rsFree();
        iLen = dwLen;

        pwcString = new WCHAR[dwLen+1];
        ASSERT(pwcString != NULL);
        memcpy(pwcString, pmf->GetRead(), 2*dwLen);
        pwcString[dwLen] = 0;
        OK(pmf->Advance(2*dwLen));

        return S_OK;
    }

    size_t cbBin() const {
        return iLen * sizeof(WCHAR);
    }

    HRESULT CopyBinZ(BYTE **ppb) const {
        memcpy(*ppb, pwcString, sizeof(WCHAR)*iLen);
        *ppb += sizeof(WCHAR)*iLen;
        *(WCHAR*)*ppb = 0;
        *ppb += sizeof(WCHAR);
        return S_OK;
    }

    HRESULT ReadTok(TextScanner *pmf) {
        int l;
        rsFree();
        OK(pmf->ReadString(&pwcString, &l));
        ASSERT(l < 0x10000  &&  l >= 0);
        iLen = (WORD) l;
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf) const {
        OK(pmf->WriteString(pwcString, iLen));
        return S_OK;
    }

    int GetWords() const {

        int i;
        int wc;

        i  = 0;
        wc = 0;

        while (i<iLen) {

            while (    i < iLen
                       &&  pwcString[i] <= ' ') {
                i++;
            }

            if (i<iLen) {
                wc++;
            }

            while (    i < iLen
                       &&  pwcString[i] > ' ') {
                i++;
            }
        }

        return wc;
    }
};






////    ResourceVariant
//
//      A widely used alternative of either a Unicode string or a WORD value.


class ResourceVariant {

    ResourceString  *prs;
    ResourceWORD     rw;
    BOOL             fString;

    void rvFree() {
        if (fString && prs)
            delete prs;
        prs = NULL;
        fString=FALSE;
    }

public:

    ResourceVariant() {fString=FALSE; prs=NULL;}
    ~ResourceVariant() {rvFree();}

    // Copy and assignment constructors required as this is used as the key in an STL map

    ResourceVariant& operator= (const ResourceVariant &rv) {
        fString = rv.fString;
        if (fString) {
            prs = new ResourceString(*rv.prs);
        } else {
            prs = NULL;
            rw = rv.rw;
        }
        return *this;
    }

    ResourceVariant(const ResourceVariant &rv) {
        *this = rv;
    }


    void fprint(FILE *fh) const {
        if (fString) {
            fprintf(fh, "%S", prs->GetString());
        } else {
            fprintf(fh, "%x", rw.w);
        }
    }


    const BOOL   GetfString() const {return fString;}
    const WORD   GetW()       const {return rw.w;}
    void         SetW(WORD w)       {if (fString) {delete prs; fString = FALSE;}rw.w = w;}
    const WCHAR *GetString()  const {return prs->GetString();}
    const int    GetLength()  const {return prs->GetLength();}
    const int    GetWords()   const {return fString ? prs->GetWords() : 0;}


    HRESULT ReadBinFFFFZ(Scanner *pmf) {
        rvFree();
        fString = *(WORD*)pmf->GetRead() != 0xffff;
        if (fString) {
            prs = new ResourceString;
            OK(prs->ReadBinZ(pmf));
        } else {
            OK(pmf->Advance(sizeof(WORD)));
            OK(rw.ReadBin(pmf));
        }
        return S_OK;
    }

    size_t cbBinFFFFZ() const {
        return fString ? prs->cbBinZ() : rw.cbBin() + sizeof(WORD);
    }

    HRESULT CopyBinFFFFZ(BYTE **ppb) const {
        if (fString) {
            return prs->CopyBinZ(ppb);
        } else {
            *(WORD*)*ppb = 0xFFFF;  // Mark as value
            (*ppb) += sizeof(WORD);
            return rw.CopyBin(ppb);
        }
    }

    HRESULT ReadBinFFFFL(Scanner *pmf) {
        rvFree();
        fString = *(WORD*)pmf->GetRead() != 0xffff;
        if (fString) {
            prs = new ResourceString;
            OK(prs->ReadBinL(pmf));
        } else {
            OK(pmf->Advance(sizeof(WORD)));
            OK(rw.ReadBin(pmf));
        }
        return S_OK;
    }

    size_t cbBinFFFFL() const {
        return fString ? prs->cbBinL() : rw.cbBin() + sizeof(WORD);
    }

    HRESULT CopyBinFFFFL(BYTE **ppb) const {
        if (fString) {
            return prs->CopyBinL(ppb);
        } else {
            *(WORD*)*ppb = 0xFFFF;  // Mark as value
            (*ppb) += sizeof(WORD);
            return rw.CopyBin(ppb);
        }
    }

    HRESULT ReadTok(TextScanner *pmf) {
        rvFree();
        fString = *(char*)pmf->GetRead() == '\"';
        if (fString) {
            prs = new ResourceString;
            OK(prs->ReadTok(pmf));
        } else {
            OK(rw.ReadTok(pmf));
        }
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf) const {
        if (fString) {
            OK(prs->WriteTok(pmf));
        } else {
            OK(rw.WriteTok(pmf));
        }
        return S_OK;
    }

    HRESULT ReadWin32ResDirEntry(
                                Scanner                        *pmf,
                                const BYTE                     *pRsrc,
                                IMAGE_RESOURCE_DIRECTORY_ENTRY *pirde) {

        rvFree();
        fString = pirde->NameIsString;

        if (fString) {
            prs = new ResourceString;
            OK(pmf->SetRead(pRsrc + pirde->NameOffset));
            OK(prs->ReadBinL(pmf));
        } else {
            OK(pmf->SetRead((BYTE*)&pirde->Id));
            OK(rw.ReadBin(pmf));
        }
        return S_OK;
    }

    bool operator< (const ResourceVariant &rv) const {

        int l,c;

        if (fString != rv.GetfString()) {

            return !fString;            // Numerics before strings

        } else if (!fString) {

            return rw.w < rv.GetW();

        } else {

            l = prs->GetLength();
            if (l > rv.GetLength()) {
                l = rv.GetLength();
            }

            c = wcsncmp(prs->GetString(), rv.GetString(), l);

            if (c==0) {
                return prs->GetLength() < rv.GetLength();
            } else {
                return c < 0;
            }
        }

        return FALSE;   // Equal at all depths
    }
};






////    ResourceKey
//
//      The resource key is the unique identifier of a resource, containing
//      a resource type, a programmer defined unique id for the resource, and
//      a language identifier.


class ResourceKey {

public:

    int              iDepth;
    ResourceVariant *prvId[3];

    ResourceKey() {iDepth=0;}

    ResourceKey& operator= (const ResourceKey &rk) {
        int i;
        iDepth = rk.iDepth;
        for (i=0; i<iDepth; i++) {
            prvId[i] = new ResourceVariant(*rk.prvId[i]);
        }
        return *this;
    }

    ResourceKey(const ResourceKey& rk) {
        *this = rk;
    }

    void fprint(FILE *fh) const {

        prvId[0]->fprint(fh);
        fprintf(fh, ",");
        prvId[1]->fprint(fh);
        fprintf(fh, ",");
        prvId[2]->fprint(fh);
    }


    LPCWSTR GetResName(int i) const {
        if (i >= iDepth) {
            return (LPCWSTR) 0;
        }
        if (prvId[i]->GetfString()) {
            return prvId[i]->GetString();
        } else {
            return (LPCWSTR)prvId[i]->GetW();
        }
    }


    HRESULT SetLanguage(WORD lid) {

        ASSERT(iDepth == 3);
        ASSERT(prvId[2]->GetfString() == FALSE);
        prvId[2]->SetW(lid);

        return S_OK;
    }


    HRESULT ReadTok(TextScanner *pmf) {
        prvId[0] = new ResourceVariant;
        ASSERT(prvId[0] != NULL);
        OK(prvId[0]->ReadTok(pmf));
        iDepth = 1;
        while (*(char*)pmf->GetRead() == ',') {
            OK(pmf->Advance(1));
            prvId[iDepth] = new ResourceVariant;
            ASSERT(prvId[iDepth] != NULL);
            OK(prvId[iDepth]->ReadTok(pmf));
            iDepth++;
        }
        return S_OK;
    }

    HRESULT WriteTok(NewFile *pmf) const {
        int i;
        OK(prvId[0]->WriteTok(pmf));
        for (i=1; i<iDepth; i++) {
            OK(pmf->WriteS(","));
            OK(prvId[i]->WriteTok(pmf));
        }
        return S_OK;
    }

    bool operator< (const ResourceKey &rk) const {
        int i,l,c;

        if (iDepth != rk.iDepth) {
            return iDepth < rk.iDepth;   // Lower depths come first
        } else {
            for (i=0; i<iDepth; i++) {
                if (prvId[i]->GetfString() != rk.prvId[i]->GetfString()) {
                    return prvId[i]->GetfString() ? true : false;   // Strings come before values
                } else {
                    if (prvId[i]->GetfString()) {
                        // Compare strings
                        l = prvId[i]->GetLength();
                        if (l > rk.prvId[i]->GetLength()) {
                            l = rk.prvId[i]->GetLength();
                        }
                        c = wcsncmp(prvId[i]->GetString(), rk.prvId[i]->GetString(), l);
                        if (c == 0) {
                            if (prvId[i]->GetLength() != rk.prvId[i]->GetLength()) {
                                return prvId[i]->GetLength() < rk.prvId[i]->GetLength();
                            }
                        } else {
                            return c < 0;
                        }
                    } else {
                        // Compare numeric values
                        if (prvId[i]->GetW() != rk.prvId[i]->GetW()) {
                            return prvId[i]->GetW() < rk.prvId[i]->GetW();
                        }
                    }

                }
            }
            return FALSE;   // Equal at all depths
        }
    }
};






////    ResourceBinary
//
//      Arbitrary binary resource
//
//      Formatted as lines of hex digits


class ResourceBinary : public Resource {

protected:  // Accessed by ResourceHexDump

    BYTE    *pb;
    DWORD    dwLength;

    void rbFree() {if (pb) {delete[] pb; pb=NULL;}dwLength = 0;}

public:

    ResourceBinary() {pb = NULL; dwLength = 0;}
    ~ResourceBinary() {rbFree();}

    DWORD GetLength() const {return dwLength;}

    HRESULT ReadTok(TextScanner &mfText) {
        DWORD  i;
        DWORD  dwOffset;
        DWORD  dwCheckOffset;

        rbFree();

        OK(mfText.Expect("Hex;"));
        OK(mfText.ReadHex(&dwLength));

        pb = new BYTE[dwLength];
        ASSERT(pb != NULL);

        if (dwLength <= MAXHEXLINELEN) {

            // Hex follows on same line

            OK(mfText.Expect(":"));
            for (i=0; i<dwLength; i++) {
                OK(mfText.ReadHexByte(pb+i));
            }

        } else {

            // Hex follows on subsequent lines

            dwOffset = 0;
            while (dwLength - dwOffset > MAXHEXLINELEN) {
                OK(mfText.ExpectLn("   "));
                OK(mfText.ReadHex(&dwCheckOffset));
                ASSERT(dwOffset == dwCheckOffset);
                OK(mfText.Expect(":"));
                for (i=0; i<MAXHEXLINELEN; i++) {
                    OK(mfText.ReadHexByte(pb+dwOffset+i));
                }
                dwOffset += MAXHEXLINELEN;
            }

            OK(mfText.ExpectLn("   "));
            OK(mfText.ReadHex(&dwCheckOffset));
            ASSERT(dwOffset == dwCheckOffset);
            OK(mfText.Expect(":"));
            for (i=0; i<dwLength - dwOffset; i++) {
                OK(mfText.ReadHexByte(pb+dwOffset+i));
            }
        }

        return S_OK;
    }

    HRESULT ReadBin(Scanner &mfText, DWORD dwLen) {
        rbFree();
        dwLength = dwLen;
        pb = new BYTE[dwLength];
        memcpy(pb, mfText.GetRead(), dwLength);
        OK(mfText.Advance(dwLen));
        return S_OK;
    }

    HRESULT WriteTok(NewFile &nfText) const {

        DWORD dwOffset;


        // Write binary resource in lines of up to 256 bytes

        OK(nfText.WriteS("Hex;"));
        OK(nfText.WriteHex(dwLength, 8));


        if (dwLength <= MAXHEXLINELEN) {

            // Write <= MAXHEXLINELEN bytes on same line

            OK(nfText.WriteS(":"));
            OK(nfText.WriteHexBuffer(pb, dwLength));

        } else {

            // write MAXHEXLINELEN bytes per line on subsequent lines

            dwOffset = 0;
            while (dwLength - dwOffset > MAXHEXLINELEN) {
                OK(nfText.WriteS("\r\n   "));
                OK(nfText.WriteHex(dwOffset, 8));
                OK(nfText.WriteS(":"));
                OK(nfText.WriteHexBuffer(pb+dwOffset, MAXHEXLINELEN));
                dwOffset += MAXHEXLINELEN;
            }

            // Write remaining bytes, if any

            OK(nfText.WriteS("\r\n   "));
            OK(nfText.WriteHex(dwOffset, 8));
            OK(nfText.WriteS(":"));
            OK(nfText.WriteHexBuffer(pb+dwOffset, dwLength - dwOffset));
        }

        return S_OK;
    }


    size_t cbBin() const {
        return dwLength;
    }

    HRESULT CopyBin(BYTE **ppb) const {
        if (dwLength > 0) {
            memcpy(*ppb, pb, dwLength);
            *ppb += dwLength;
        }
        return S_OK;
    }

    int GetItems() const {
        return 0;
    }

    int GetWords() const {
        return 0;
    }


    BOOL CompareBin(const BYTE *pbComp, DWORD dwLen) const {

        if (dwLength != dwLen) return FALSE;
        if (dwLength == 0)     return TRUE;
        if (pb ==pbComp)       return true;

        return !memcmp(pb, pbComp, dwLength);
    }

};




////    ResourceHexDump
//
//      Special version of ResourceBinary for generating a hex dump analysis


class ResourceHexDump : public ResourceBinary {

public:
    HRESULT WriteTok(NewFile &nfText) const {
        DWORD i,j;
        ResourceDWORD rdw;

        OK(nfText.WriteS("Hexdump,"));
        OK(nfText.WriteHex(dwLength, 8));
        OK(nfText.WriteS(":"));
        for (i=0; i<dwLength; i++) {
            if (i % 4 == 0) {
                OK(nfText.WriteS(" "));
            }
            if (i % 8 == 0) {
                OK(nfText.WriteS(" "));
            }
            if (i % 16 == 0) {
                if (i>0) {
                    // Append ASCII interpretation
                    for (j=i-16; j<i; j++) {
                        if (pb[j] > 31) {
                            OK(nfText.WriteBytes(pb+j, 1));
                        } else {
                            OK(nfText.WriteS("."));
                        }
                    }
                }
                OK(nfText.WriteS("\r\n   "));
                rdw.dw = i;   OK(rdw.WriteTok(&nfText));
                OK(nfText.WriteS(": "));
            }
            OK(nfText.WriteHex(pb[i], 2));
            OK(nfText.WriteS(" "));
        }

        // Append ANSI interpretation to last line

        if (dwLength % 16 > 0) {
            for (i = dwLength % 16 ; i < 16; i++) {
                if (i % 4 == 0) {
                    OK(nfText.WriteS(" "));
                }
                if (i % 8 == 0) {
                    OK(nfText.WriteS(" "));
                }
                OK(nfText.WriteS("   "));
            }
        }
        OK(nfText.WriteS("  "));

        for (j=dwLength-1 & 0xfffffff0; j<dwLength; j++) {
            if (pb[j] > 31) {
                OK(nfText.WriteBytes(pb+j, 1));
            } else {
                OK(nfText.WriteS("."));
            }
        }

        OK(nfText.WriteLn());
        return S_OK;
    }
};






////    Menu32
//
//


class MenuItem32 {

    ResourceDWORD   rdwType;
    ResourceDWORD   rdwState;
    ResourceDWORD   rdwId;       // Extended ID
    ResourceWORD    rwId;        // Non-extended ID
    ResourceWORD    rwFlags;
    ResourceDWORD   rdwHelpId;
    ResourceString  rsCaption;

    BOOL            fExtended;

public:

    void SetExtended(BOOL f)        {fExtended = f;}
    int  GetWords()          const  {return rsCaption.GetWords();}

    virtual HRESULT ReadTok(TextScanner &mfText) {

        if (!fExtended) {
            OK(rwFlags.ReadTok(&mfText));  OK(mfText.Expect(","));
            if (!(rwFlags.w & MF_POPUP)) {
                OK(rwId   .ReadTok(&mfText));  OK(mfText.Expect(","));
            }
        } else {
            OK(rdwType  .ReadTok(&mfText));  OK(mfText.Expect(","));
            OK(rdwState .ReadTok(&mfText));  OK(mfText.Expect(","));
            OK(rdwId    .ReadTok(&mfText));  OK(mfText.Expect(","));
            OK(rwFlags  .ReadTok(&mfText));  OK(mfText.Expect(","));
            if (rwFlags.w & 1) {
                OK(rdwHelpId.ReadTok(&mfText));  OK(mfText.Expect(","));
            }
        }

        OK(rsCaption.ReadTok(&mfText));

        return S_OK;
    }



    virtual HRESULT ReadBin(Scanner &mfBin) {

        const BYTE *pb;       // For tracking

        pb = mfBin.GetRead();

        if (!fExtended) {
            OK(rwFlags.ReadBin(&mfBin));
            if (!(rwFlags.w & MF_POPUP)) {
                OK(rwId   .ReadBin(&mfBin));
            }
        } else {
            OK(rdwType .ReadBin(&mfBin));
            OK(rdwState.ReadBin(&mfBin));
            OK(rdwId   .ReadBin(&mfBin));
            OK(rwFlags .ReadBin(&mfBin));
        }

        OK(rsCaption.ReadBinZ(&mfBin));

        if (fExtended  &&  rwFlags.w & 1) {

            OK(mfBin.Align(pb, 4));

            OK(rdwHelpId.ReadBin(&mfBin));
        }

        return S_OK;
    }



    virtual HRESULT WriteTok(NewFile &nfText) const {

        if (!fExtended) {
            OK(rwFlags.WriteTok(&nfText));  OK(nfText.WriteS(","));
            if (!(rwFlags.w & MF_POPUP)) {
                OK(rwId   .WriteTok(&nfText));  OK(nfText.WriteS(","));
            }
        } else {
            OK(rdwType  .WriteTok(&nfText));  OK(nfText.WriteS(","));
            OK(rdwState .WriteTok(&nfText));  OK(nfText.WriteS(","));
            OK(rdwId    .WriteTok(&nfText));  OK(nfText.WriteS(","));
            OK(rwFlags  .WriteTok(&nfText));  OK(nfText.WriteS(","));
            if (rwFlags.w & 1) {
                OK(rdwHelpId.WriteTok(&nfText));  OK(nfText.WriteS(","));
            }
        }

        OK(rsCaption.WriteTok(&nfText));

        return S_OK;
    }


    virtual size_t cbBin() const {

        size_t  cb;

        if (!fExtended) {

            cb =   rwFlags.cbBin()
                   + rsCaption.cbBinZ();

            if (!(rwFlags.w & MF_POPUP)) {
                cb += rwId.cbBin();
            }

        } else {

            cb =   rdwType.cbBin()
                   + rdwState.cbBin()
                   + rdwId.cbBin()
                   + rwFlags.cbBin()
                   + rsCaption.cbBinZ();

            if (rwFlags.w & 1) {

                cb = cb + 3 & ~3;
                cb += rdwHelpId.cbBin();
            }
        }

        return cb;
    }



    virtual HRESULT CopyBin  (BYTE **ppb) const {

        const BYTE * pb;

        pb = *ppb;

        if (!fExtended) {
            OK(rwFlags.CopyBin(ppb));
            if (!(rwFlags.w & MF_POPUP)) {
                OK(rwId   .CopyBin(ppb));
            }
        } else {
            OK(rdwType .CopyBin(ppb));
            OK(rdwState.CopyBin(ppb));
            OK(rdwId   .CopyBin(ppb));
            OK(rwFlags .CopyBin(ppb));
        }

        OK(rsCaption.CopyBinZ(ppb));

        if (fExtended  &&  rwFlags.w & 1) {

            while (*ppb - pb & 3) {
                **ppb = 0;
                (*ppb)++;
            }

            OK(rdwHelpId.CopyBin(ppb));
        }

        return S_OK;
    }

};






class Menu32 : public Resource {

    ResourceWORD    rwVer;
    ResourceWORD    rwHdrSize;
    ResourceBinary  rbHeader;
    MenuItem32     *pMnuItm;
    DWORD           cItems;
    BOOL            fExtended;


public:
    virtual HRESULT ReadTok(TextScanner &mfText) {

        DWORD i, iItem;

        OK(mfText.Expect("Mnu32"));
        fExtended = *(char*)mfText.GetRead() == 'X';
        if (fExtended) {
            OK(mfText.Expect("X;"));
        } else {
            OK(mfText.Expect("N;"));
        }

        OK(rwVer    .ReadTok(&mfText));    OK(mfText.Expect(","));
        OK(rwHdrSize.ReadTok(&mfText));    OK(mfText.Expect(","));
        if (fExtended  &&  rwHdrSize.w > 0) {
            OK(rbHeader.ReadTok(mfText));  OK(mfText.Expect(","));
        }
        OK(mfText.ReadHex(&cItems));       OK(mfText.Expect(":"));

        pMnuItm = new MenuItem32 [cItems];
        ASSERT(pMnuItm != NULL);

        for (i=0; i<cItems; i++) {

            OK(mfText.ExpectLn("   "));   OK(mfText.ReadHex(&iItem));
            ASSERT(i == iItem);
            pMnuItm[i].SetExtended(fExtended);
            OK(mfText.Expect(";"));       OK(pMnuItm[i].ReadTok(mfText));
        }

        return S_OK;
    }



    virtual HRESULT ReadBin(Scanner &mfBin, DWORD dwLen) {

        const BYTE *pb;       // For tracking
        MenuItem32  mi;       // For counting menu items
        const BYTE *pbFirstItem;
        int         i;

        cItems = 0;
        pb = mfBin.GetRead();

        OK(rwVer    .ReadBin(&mfBin));
        OK(rwHdrSize.ReadBin(&mfBin));

        ASSERT(rwVer.w == 0  ||  rwVer.w == 1);
        fExtended = rwVer.w;

        if (fExtended  &&  rwHdrSize.w > 0) {
            rbHeader.ReadBin(mfBin, rwHdrSize.w);
        }


        ASSERT(mfBin.GetRead() - pb < dwLen);


        // Count menu items

        if (fExtended) {
            OK(mfBin.Align(pb, 4));
        }

        pbFirstItem = mfBin.GetRead();
        mi.SetExtended(fExtended);
        while (mfBin.GetRead() - pb < dwLen) {

            OK(mi.ReadBin(mfBin));
            cItems++;

            if (fExtended) {
                OK(mfBin.Align(pb, 4));
            }
        }

        pMnuItm = new MenuItem32 [cItems];
        ASSERT(pMnuItm != NULL);


        // Record the menus

        OK(mfBin.SetRead(pbFirstItem));
        for (i=0; i<cItems; i++) {

            if (fExtended) {
                OK(mfBin.Align(pb, 4));
            }

            pMnuItm[i].SetExtended(fExtended);
            OK(pMnuItm[i].ReadBin(mfBin));
        }


        ASSERT(mfBin.GetRead() - pb <= dwLen);

        return S_OK;
    }



    virtual HRESULT WriteTok(NewFile &nfText) const {

        DWORD i;

        OK(nfText.WriteS(fExtended ? "Mnu32X;": "Mnu32N;"));

        OK(rwVer    .WriteTok(&nfText));     OK(nfText.WriteS(","));
        OK(rwHdrSize.WriteTok(&nfText));     OK(nfText.WriteS(","));
        if (fExtended  &&  rwHdrSize.w > 0) {
            OK(rbHeader.WriteTok(nfText));   OK(nfText.WriteS(","));
        }
        OK(nfText.WriteHex(cItems,4));       OK(nfText.WriteS(":"));

        for (i=0; i<cItems; i++) {

            OK(nfText.WriteS("\r\n   "));
            OK(nfText.WriteHex(i, 4));
            OK(nfText.WriteS(";"));
            OK(pMnuItm[i].WriteTok(nfText));
        }

        return S_OK;
    }


    virtual size_t cbBin() const {
        int     i;
        size_t  cb;

        cb =    rwVer.cbBin()
                +  rwHdrSize.cbBin();

        if (fExtended  &&  rwHdrSize.w > 0) {
            cb += rbHeader.cbBin();
        }

        for (i=0; i<cItems; i++) {

            if (fExtended) {
                cb = cb + 3 & ~3;
            }

            cb += pMnuItm[i].cbBin();
        }

        return cb;
    }



    virtual HRESULT CopyBin  (BYTE **ppb) const {

        const BYTE *pb;       // For tracking
        int         i;

        pb = *ppb;

        OK(rwVer    .CopyBin(ppb));
        OK(rwHdrSize.CopyBin(ppb));

        if (fExtended  &&  rwHdrSize.w > 0) {
            rbHeader.CopyBin(ppb);
        }


        for (i=0; i<cItems; i++) {

            if (fExtended) {
                while (*ppb - pb & 3) {
                    **ppb = 0;
                    (*ppb)++;
                }
            }

            OK(pMnuItm[i].CopyBin(ppb));
        }

        return S_OK;
    }

    int GetItems() const {
        return cItems;
    }

    int GetWords() const {
        int i;
        int wc;

        wc = 0;
        for (i=0; i<cItems; i++) {
            wc += pMnuItm[i].GetWords();
        }

        return wc;
    }
};






////    String32
//
//      Strings are represented as a sequence of WCHARS, each string
//      preceeded by its length. Each resource contains 16 strings.


class String32 : public Resource {

    ResourceString rs[16];
    DWORD          cStrings;
    DWORD          cNonEmpty;

public:
    virtual HRESULT ReadTok(TextScanner &mfText) {

        DWORD i, iString, cLoaded;

        OK(mfText.Expect("Str;"));
        OK(mfText.ReadHex(&cStrings));
        OK(mfText.Expect(","));
        OK(mfText.ReadHex(&cNonEmpty));
        OK(mfText.Expect(":"));

        ASSERT(cStrings == 16);
        ASSERT(cNonEmpty <= cStrings);

        i=0;
        cLoaded = 0;
        while (cLoaded < cNonEmpty) {

            OK(mfText.ExpectLn("   "));
            OK(mfText.ReadHex(&iString));
            OK(mfText.Expect(":"));
            ASSERT(iString >= i);
            ASSERT(iString < cStrings);
            while (i<iString) {
                rs[i].SetEmpty();
                i++;
            }
            OK(rs[i].ReadTok(&mfText));
            i++;
            cLoaded++;
        }

        while (i<cStrings) {
            rs[i].SetEmpty();
            i++;
        }

        return S_OK;
    }



    virtual HRESULT ReadBin(Scanner &mfBin, DWORD dwLen) {

        const BYTE *pb;       // For tracking

        cStrings  = 0;
        cNonEmpty = 0;
        pb = mfBin.GetRead();

        while (    cStrings < 16
                   &&  mfBin.GetRead() - pb < dwLen) {

            rs[cStrings].ReadBinL(&mfBin);
            if (rs[cStrings].GetLength() > 0) {
                cNonEmpty++;
            }
            cStrings++;
        }

        ASSERT(mfBin.GetRead() - pb <= dwLen);
        ASSERT(cStrings == 16);

        return S_OK;
    }



    virtual HRESULT WriteTok(NewFile &nfText) const {

        int i;

        ASSERT(cStrings <= 16);

        OK(nfText.WriteS("Str;"));
        OK(nfText.WriteHex(cStrings, 2));
        OK(nfText.WriteS(","));
        OK(nfText.WriteHex(cNonEmpty, 2));
        OK(nfText.WriteS(":"));


        for (i=0; i<cStrings; i++) {
            if (rs[i].GetLength() > 0) {
                OK(nfText.WriteS("\r\n   "));
                OK(nfText.WriteHex(i, 1));
                OK(nfText.WriteS(":"));
                OK(rs[i].WriteTok(&nfText));
            }
        }

        return S_OK;
    }


    virtual size_t cbBin() const {
        int     i;
        size_t  cb;

        cb = 0;

        for (i=0; i<cStrings; i++) {
            cb += rs[i].cbBinL();
        }

        return cb;
    }



    virtual HRESULT CopyBin  (BYTE **ppb) const {
        int i;

        for (i=0; i<cStrings; i++) {
            OK(rs[i].CopyBinL(ppb));
        }

        return S_OK;
    }


    int GetItems() const {
        return cNonEmpty;
    }

    int GetWords() const {

        int i, wc;

        wc = 0;
        for (i=0; i<cStrings; i++) {
            wc += rs[i].GetWords();
        }

        return wc;
    }
};






class DialogHeader32 {

    BOOL             fExtended;

    ResourceDWORD    rdwStyle;
    ResourceDWORD    rdwSignature;
    ResourceDWORD    rdwHelpId;
    ResourceDWORD    rdwExStyle;
    ResourceWORD     rwcDit;        // Count of dialog items
    ResourceWORD     rwX;
    ResourceWORD     rwY;
    ResourceWORD     rwCx;
    ResourceWORD     rwCy;
    ResourceVariant  rvMenu;
    ResourceVariant  rvClass;
    ResourceVariant  rvTitle;
    ResourceWORD     rwPointSize;
    ResourceWORD     rwWeight;
    ResourceBYTE     rbItalic;
    ResourceBYTE     rbCharSet;
    ResourceString   rsFaceName;

public:

    WORD GetItemCount()  const  {return rwcDit.w;}
    BOOL GetExtended()   const  {return fExtended;}
    int  GetWords()      const  {return rvTitle.GetWords();}

    HRESULT ReadTok(TextScanner *pmf) {

        OK(rwcDit      .ReadTok(pmf));  OK(pmf->Expect(","));

        OK(rdwStyle    .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rdwExStyle  .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rdwSignature.ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rdwHelpId   .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwX         .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwY         .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwCx        .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwCy        .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rvMenu      .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rvClass     .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rvTitle     .ReadTok(pmf));
        if (rdwStyle.dw & DS_SETFONT) {
            OK(pmf->Expect(","));
            OK(rwPointSize.ReadTok(pmf));  OK(pmf->Expect(","));
            OK(rwWeight   .ReadTok(pmf));  OK(pmf->Expect(","));
            OK(rbItalic   .ReadTok(pmf));  OK(pmf->Expect(","));
            OK(rbCharSet  .ReadTok(pmf));  OK(pmf->Expect(","));
            OK(rsFaceName .ReadTok(pmf));
        }

        fExtended = rdwSignature.dw != 0;

        return S_OK;
    }



    HRESULT ReadBin(Scanner *pmf) {

        OK(rdwSignature.ReadBin(pmf));

        fExtended = HIWORD(rdwSignature.dw) == 0xFFFF;
        if (!fExtended) {

            rdwStyle.dw = rdwSignature.dw;
            OK(rdwExStyle.ReadBin(pmf));
            rdwSignature.dw = 0;
            rdwHelpId.dw    = 0;

        } else {

            // Extended dialog adds signature and HelpID
            OK(rdwHelpId.ReadBin(pmf));
            OK(rdwExStyle.ReadBin(pmf));
            OK(rdwStyle.ReadBin(pmf));
        }


        OK(rwcDit    .ReadBin(pmf));
        OK(rwX       .ReadBin(pmf));
        OK(rwY       .ReadBin(pmf));
        OK(rwCx      .ReadBin(pmf));
        OK(rwCy      .ReadBin(pmf));
        OK(rvMenu    .ReadBinFFFFZ(pmf));
        OK(rvClass   .ReadBinFFFFZ(pmf));
        OK(rvTitle   .ReadBinFFFFZ(pmf));
        if (rdwStyle.dw & DS_SETFONT) {
            OK(rwPointSize.ReadBin(pmf));
            if (!fExtended) {
                rwWeight.w  = 0;
                rbItalic.b  = 0;
                rbCharSet.b = 0;
            } else {
                OK(rwWeight   .ReadBin(pmf));
                OK(rbItalic   .ReadBin(pmf));
                OK(rbCharSet  .ReadBin(pmf));
            }
            OK(rsFaceName .ReadBinZ(pmf));
        }


        return S_OK;
    }



    size_t cbBin() const {
        size_t cb;
        cb =  rdwStyle     .cbBin()         // Basics for all dialogs
              + rdwExStyle   .cbBin()
              + rwcDit       .cbBin()
              + rwX          .cbBin()
              + rwY          .cbBin()
              + rwCx         .cbBin()
              + rwCy         .cbBin()
              + rvMenu       .cbBinFFFFZ()
              + rvClass      .cbBinFFFFZ()
              + rvTitle      .cbBinFFFFZ();

        if (rdwStyle.dw & DS_SETFONT) {     // Facname additions
            cb +=   rwPointSize  .cbBin()
                    + rsFaceName   .cbBinZ();
        }

        if (fExtended) {                    // Extended dialog addtions
            cb +=   rdwSignature .cbBin()
                    + rdwHelpId    .cbBin();

            if (rdwStyle.dw & DS_SETFONT) {
                cb += rwWeight     .cbBin()
                      + rbItalic     .cbBin()
                      + rbCharSet    .cbBin();
            }
        }

        return cb;
    }



    HRESULT CopyBin(BYTE **ppb) const {

        BYTE *pbOriginal;

        pbOriginal = *ppb;

        if (!fExtended) {

            OK(rdwStyle  .CopyBin(ppb));
            OK(rdwExStyle.CopyBin(ppb));

        } else {

            OK(rdwSignature.CopyBin(ppb));
            OK(rdwHelpId   .CopyBin(ppb));
            OK(rdwExStyle  .CopyBin(ppb));
            OK(rdwStyle    .CopyBin(ppb));
        }
        OK(rwcDit    .CopyBin(ppb));
        OK(rwX       .CopyBin(ppb));
        OK(rwY       .CopyBin(ppb));
        OK(rwCx      .CopyBin(ppb));
        OK(rwCy      .CopyBin(ppb));
        OK(rvMenu    .CopyBinFFFFZ(ppb));
        OK(rvClass   .CopyBinFFFFZ(ppb));
        OK(rvTitle   .CopyBinFFFFZ(ppb));
        if (rdwStyle.dw & DS_SETFONT) {
            OK(rwPointSize.CopyBin(ppb));
            if (fExtended) {
                OK(rwWeight .CopyBin(ppb));
                OK(rbItalic .CopyBin(ppb));
                OK(rbCharSet.CopyBin(ppb));
            }
            OK(rsFaceName .CopyBinZ(ppb));
        }

        return S_OK;
    }



    HRESULT WriteTok(NewFile *pmf) const {

        OK(rwcDit      .WriteTok(pmf));  OK(pmf->WriteS(","));

        OK(rdwStyle    .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rdwExStyle  .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rdwSignature.WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rdwHelpId   .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwX         .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwY         .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwCx        .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwCy        .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rvMenu      .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rvClass     .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rvTitle     .WriteTok(pmf));
        if (rdwStyle.dw & DS_SETFONT) {
            OK(pmf->WriteS(","));
            OK(rwPointSize.WriteTok(pmf));  OK(pmf->WriteS(","));
            OK(rwWeight   .WriteTok(pmf));  OK(pmf->WriteS(","));
            OK(rbItalic   .WriteTok(pmf));  OK(pmf->WriteS(","));
            OK(rbCharSet  .WriteTok(pmf));  OK(pmf->WriteS(","));
            OK(rsFaceName .WriteTok(pmf));
        }
        return S_OK;
    }
};





class DialogItem32 {

    BOOL             fExtended;

    ResourceDWORD    rdwStyle;
    ResourceDWORD    rdwHelpId;
    ResourceDWORD    rdwExStyle;
    ResourceWORD     rwX;
    ResourceWORD     rwY;
    ResourceWORD     rwCx;
    ResourceWORD     rwCy;
    ResourceWORD     rwId;      // Normal
    ResourceDWORD    rdwId;     // Extended
    ResourceVariant  rvClass;
    ResourceVariant  rvTitle;

    ResourceWORD     rwcbRawData;   // Raw data size (extended only)
    ResourceBinary   rbRawData;

    ResourceWORD     rwDummy;       // Replaces raw data on normal dialogs

public:

    void SetExtended(BOOL f)         {fExtended = f;}
    int  GetWords()           const  {return rvTitle.GetWords();}

    HRESULT ReadTok(TextScanner *pmf) {

        if (fExtended) {
            OK(rdwId.ReadTok(pmf));     OK(pmf->Expect(","));
        } else {
            OK(rwId.ReadTok(pmf));      OK(pmf->Expect(","));
        }

        OK(rdwStyle    .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rdwExStyle  .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rdwHelpId   .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwX         .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwY         .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwCx        .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rwCy        .ReadTok(pmf));  OK(pmf->Expect(","));

        OK(rvClass     .ReadTok(pmf));  OK(pmf->Expect(","));
        OK(rvTitle     .ReadTok(pmf));  OK(pmf->Expect(","));

        if (fExtended) {

            OK(rbRawData.ReadTok(*pmf));
            ASSERT(rbRawData.GetLength() < 0x10000);
            rwcbRawData.w = (WORD)rbRawData.GetLength();

        } else {

            OK(rwDummy.ReadTok(pmf));
        }

        return S_OK;
    }



    HRESULT ReadBin(Scanner *pmf) {

        if (!fExtended) {

            OK(rdwStyle.ReadBin(pmf));
            OK(rdwExStyle.ReadBin(pmf));
            rdwHelpId.dw    = 0;

        } else {

            OK(rdwHelpId.ReadBin(pmf));
            OK(rdwExStyle.ReadBin(pmf));
            OK(rdwStyle.ReadBin(pmf));
        }


        OK(rwX .ReadBin(pmf));
        OK(rwY .ReadBin(pmf));
        OK(rwCx.ReadBin(pmf));
        OK(rwCy.ReadBin(pmf));

        if (fExtended) {
            OK(rdwId.ReadBin(pmf));
        } else {
            OK(rwId.ReadBin(pmf));
        }

        OK(rvClass.ReadBinFFFFZ(pmf));
        OK(rvTitle.ReadBinFFFFZ(pmf));

        if (fExtended) {

            OK(rwcbRawData.ReadBin(pmf));
            OK(rbRawData.ReadBin(*pmf, rwcbRawData.w));

        } else {

            OK(rwDummy.ReadBin(pmf));
        }

        return S_OK;
    }



    size_t cbBin() const {
        size_t cb;

        cb =  rdwStyle   .cbBin()
              + rdwExStyle .cbBin()
              + rwX        .cbBin()
              + rwY        .cbBin()
              + rwCx       .cbBin()
              + rwCy       .cbBin()
              + rvClass    .cbBinFFFFZ()
              + rvTitle    .cbBinFFFFZ();

        if (!fExtended) {
            cb += rwId    .cbBin()
                  + rwDummy .cbBin();
        } else {
            cb += rdwId       .cbBin()
                  + rdwHelpId   .cbBin()
                  + rbRawData   .cbBin()
                  + rwcbRawData .cbBin();
        }
        return cb;
    }



    HRESULT CopyBin(BYTE **ppb) const {

        BYTE   *pbOriginal;

        pbOriginal = *ppb;

        if (!fExtended) {

            OK(rdwStyle.CopyBin(ppb));
            OK(rdwExStyle.CopyBin(ppb));

        } else {

            OK(rdwHelpId.CopyBin(ppb));
            OK(rdwExStyle.CopyBin(ppb));
            OK(rdwStyle.CopyBin(ppb));
        }


        OK(rwX .CopyBin(ppb));
        OK(rwY .CopyBin(ppb));
        OK(rwCx.CopyBin(ppb));
        OK(rwCy.CopyBin(ppb));

        if (fExtended) {
            OK(rdwId.CopyBin(ppb));
        } else {
            OK(rwId.CopyBin(ppb));
        }

        OK(rvClass.CopyBinFFFFZ(ppb));
        OK(rvTitle.CopyBinFFFFZ(ppb));

        if (fExtended) {

            OK(rwcbRawData.CopyBin(ppb));
            OK(rbRawData.CopyBin(ppb));

        } else {

            OK(rwDummy.CopyBin(ppb));
        }

        return S_OK;
    }



    HRESULT WriteTok(NewFile *pmf) const {

        if (fExtended) {
            OK(rdwId.WriteTok(pmf));     OK(pmf->WriteS(","));
        } else {
            OK(rwId.WriteTok(pmf));      OK(pmf->WriteS(","));
        }

        OK(rdwStyle    .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rdwExStyle  .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rdwHelpId   .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwX         .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwY         .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwCx        .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rwCy        .WriteTok(pmf));  OK(pmf->WriteS(","));

        OK(rvClass     .WriteTok(pmf));  OK(pmf->WriteS(","));
        OK(rvTitle     .WriteTok(pmf));  OK(pmf->WriteS(","));

        if (fExtended) {

            OK(rbRawData.WriteTok(*pmf));

        } else {

            OK(rwDummy.WriteTok(pmf));
        }

        return S_OK;
    }
};







////    Dialog32
//
//


class Dialog32 : public Resource {


    DialogHeader32    DlgHdr;   // Header
    DialogItem32     *pDlgItm;  // Array of items

    BOOL fExtended;
    int  cItems;

public:

    Dialog32() {pDlgItm = NULL;};

    virtual HRESULT ReadTok(TextScanner &mfText) {

        DWORD i, dwSeq;

        OK(mfText.Expect("Dlg32"));
        fExtended = *(char*)mfText.GetRead() == 'X';
        if (fExtended) {
            OK(mfText.Expect("X;"));
        } else {
            OK(mfText.Expect("N;"));
        }

        OK(DlgHdr.ReadTok(&mfText));
        ASSERT(fExtended == DlgHdr.GetExtended());

        cItems = DlgHdr.GetItemCount();

        pDlgItm = new DialogItem32 [cItems];
        ASSERT(pDlgItm != NULL);


        for (i=0; i<cItems; i++) {

            OK(mfText.ExpectLn("   "));
            OK(mfText.ReadHex(&dwSeq));
            ASSERT(dwSeq == i+1);
            OK(mfText.Expect(";"));

            pDlgItm[i].SetExtended(fExtended);
            OK(pDlgItm[i].ReadTok(&mfText));
        }

        return S_OK;
    }



    virtual HRESULT WriteTok(NewFile &nfText) const {

        DWORD i;

        OK(nfText.WriteS(fExtended ? "Dlg32X;": "Dlg32N;"));

        OK(DlgHdr.WriteTok(&nfText));

        for (i=0; i<cItems; i++) {

            OK(nfText.WriteS("\r\n   "));
            OK(nfText.WriteHex(i+1, 4));
            OK(nfText.WriteS(";"));
            OK(pDlgItm[i].WriteTok(&nfText));
        }

        return S_OK;
    }



    virtual HRESULT ReadBin(Scanner &mfBinary, DWORD dwLen) {

        const BYTE *pb;      // File pointer for tracking alignment
        int         i;

        pb = mfBinary.GetRead();

        OK(DlgHdr.ReadBin(&mfBinary));
        fExtended = DlgHdr.GetExtended();
        cItems    = DlgHdr.GetItemCount();

        pDlgItm = new DialogItem32 [cItems];
        ASSERT(pDlgItm != NULL);


        // Read items

        for (i=0; i<cItems; i++) {

            OK(mfBinary.Align(pb, 4));   // Advance over any alignment padding

            pDlgItm[i].SetExtended(fExtended);
            OK(pDlgItm[i].ReadBin(&mfBinary));

            ASSERT(mfBinary.GetRead() - pb <= dwLen);
        }

        return S_OK;
    }



    virtual size_t cbBin() const {

        size_t cb;
        int    i;

        cb = DlgHdr.cbBin();

        for (i=0; i<cItems; i++) {

            cb = cb + 3 & ~3;   // alignment padding

            cb += pDlgItm[i].cbBin();
        }

        return cb;
    }



    virtual HRESULT CopyBin (BYTE **ppb) const {

        BYTE *pb;   // Pointer for tracking alignment
        int   i;

        pb = *ppb;

        DlgHdr.CopyBin(ppb);

        for (i=0; i<cItems; i++) {

            // Insert alignment padding

            while (*ppb - pb & 3) {
                **ppb = 0;
                (*ppb)++;
            }

            pDlgItm[i].CopyBin(ppb);
        }

        return S_OK;
    }

    int GetItems() const {
        return cItems;
    }

    int GetWords() const {

        int i, wc;

        wc = DlgHdr.GetWords();
        for (i=0; i<cItems; i++) {
            wc += pDlgItm[i].GetWords();
        }
        return wc;
    }
};





////    VersionInfo
//
//      The documentation in the Win32 SDK doesn't clearly capture the
//      usage of block headers, or the nesting of blocks in the Version resource.
//
//      Each block has the following format
//
//      wLength         Total length including key, value and subblocks
//      wValueLength    Length of value in bytes or characters according to bText
//      bText           Whether value is in bytes or zero terminated WCHARs
//      szKey           Zero terminated WCHAR key, padded with zeros to next DWORD boundary
//      Value           Size determined by bText and wValueLength, padded to DWORD boundary
//      Sub-blocks      Remaining space (if any, up to wLength) is an array of sub blocks


class VersionInfo : public Resource {

    struct VersionBlock {
        VersionBlock   *pNext;          // Next block at this level
        VersionBlock   *pSub;           // First contained subblock
        int             iDepth;         // Starts at zero
        DWORD           cSub;           // Number of contained subblocks
        BOOL            bValue;         // Set if a vlue is present
        ResourceWORD    rwbText;
        ResourceString  rsKey;
        ResourceString  rsValue;        // Value when a string
        ResourceBinary  rbValue;        // Value when bytes
    };


    VersionBlock *pvb;                  // First root level block
    DWORD         cBlocks;              // Number of root level blocks



    HRESULT ReadBinVersionBlocks(
                                Scanner         &mfBinary,
                                DWORD            dwLength,    // Length of binary to read
                                VersionBlock   **ppvb,
                                int              iDepth,
                                DWORD           *cSub) {

        const BYTE      *pbBlock;
        const BYTE      *pbResource;
        ResourceWORD     rwLength;
        WORD             wValueLength;


        pbResource = mfBinary.GetRead();
        (*cSub) = 0;
        while (mfBinary.GetRead() < pbResource + dwLength) {

            // Read one version block

            pbBlock = mfBinary.GetRead();
            OK(rwLength.ReadBin(&mfBinary));

            ASSERT(pbBlock + rwLength.w <= mfBinary.GetLimit());

            //OK((*ppvb)->rwValueLength.ReadBin(&mfBinary));

            wValueLength = *(WORD*)mfBinary.GetRead();
            OK(mfBinary.Advance(2));

            if (rwLength.w > 0) {

                // Block is not empty

                *ppvb           = new VersionBlock;
                ASSERT(*ppvb != NULL);

                (*ppvb)->pNext  = NULL;
                (*ppvb)->pSub   = NULL;
                (*ppvb)->iDepth = iDepth;

                OK((*ppvb)->rwbText.ReadBin(&mfBinary));
                OK((*ppvb)->rsKey.ReadBinZ(&mfBinary));
                OK(mfBinary.Align(pbResource, 4));

                (*ppvb)->bValue = wValueLength > 0;

                if ((*ppvb)->bValue) {

                    if ((*ppvb)->rwbText.w == 0) {

                        // Binary value

                        OK((*ppvb)->rbValue.ReadBin(mfBinary, wValueLength));

                    } else {

                        // WCHAR string.

                        // Some writers include a zero terminator, some don't.
                        // Some incode zero codepoints  inside the string
                        // Some writers get the length right, some dont.
                        // msvcrt20.dll text lengths are too long.

                        // Choose a length that is min(ValueLength, length remaining),
                        // and then drop any trailing zeros.

                        // Clip ValueLength to length remaining

                        ASSERT(mfBinary.GetRead() < pbBlock + rwLength.w);

                        if (wValueLength > (pbBlock + rwLength.w - mfBinary.GetRead()) / 2) {
                            wValueLength = (pbBlock + rwLength.w - mfBinary.GetRead()) / 2;
                        }

                        // Clip trailing zeros

                        while (    wValueLength > 0
                                   &&  ((WCHAR*)mfBinary.GetRead())[wValueLength-1] == 0) {
                            wValueLength--;
                        }

                        // Extract whatever remains

                        OK((*ppvb)->rsValue.ReadBin(&mfBinary, wValueLength));

                        // Check that there's nothing being lost between the end of
                        // the string and the end of the block.

                        // Note that we assume here that blocks containing text values
                        // cannot have variety of messes that value text is stored in
                        // in exisiting executables.

                        while (mfBinary.GetRead() < pbBlock + rwLength.w) {

                            ASSERT(*(WCHAR*)mfBinary.GetRead() == 0);
                            OK(mfBinary.Advance(2));
                        }
                    }
                    OK(mfBinary.Align(pbResource, 4));
                }

                if (mfBinary.GetRead() - pbBlock < rwLength.w) {

                    ASSERT(mfBinary.GetLimit() > mfBinary.GetRead());

                    // Read subblocks

                    OK(ReadBinVersionBlocks(
                                           mfBinary,
                                           rwLength.w - (mfBinary.GetRead() - pbBlock),
                                           &((*ppvb)->pSub),
                                           iDepth + 1,
                                           &(*ppvb)->cSub));
                }

                if (mfBinary.GetRead() < pbResource + dwLength) {

                    // Prepare to read more blocks at this level

                    ppvb = &((*ppvb)->pNext);
                }
            }

            (*cSub)++;
        }

        return S_OK;
    }


    HRESULT WriteTokVersionBlocks(
                                 NewFile          &nfText,
                                 VersionBlock     *pvb)     const {

        while (pvb) {

            OK(nfText.WriteS("\r\n   "));
            OK(nfText.WriteHex(pvb->iDepth, 2));
            OK(nfText.WriteS(","));
            OK(pvb->rsKey.WriteTok(&nfText));

            if (pvb->bValue) {

                OK(nfText.WriteS("="));

                if (pvb->rwbText.w == 0) {

                    OK(pvb->rbValue.WriteTok(nfText));  // Binary value

                } else {

                    OK(pvb->rsValue.WriteTok(&nfText));  // String value

                }

            }

            if (pvb->pSub) {
                OK(nfText.WriteS(";"));
                OK(nfText.WriteHex(pvb->cSub,4));
                OK(WriteTokVersionBlocks(nfText, pvb->pSub));
            }

            pvb = pvb->pNext;
        }

        return S_OK;
    }

    HRESULT ReadTokVersionBlocks(
                                TextScanner    &mfText,
                                VersionBlock  **ppvb,
                                int             iDepth,
                                DWORD          *pcBlocks) {

        int             i;
        DWORD           dwRecordedDepth;


        OK(mfText.ReadHex(pcBlocks));

        for (i=0; i<*pcBlocks; i++) {
            *ppvb = new VersionBlock;
            ASSERT(*ppvb != NULL);

            (*ppvb)->pNext  = NULL;
            (*ppvb)->pSub   = NULL;
            (*ppvb)->iDepth = iDepth;
            (*ppvb)->cSub   = 0;

            OK(mfText.ExpectLn("   "));
            OK(mfText.ReadHex(&dwRecordedDepth));
            ASSERT(dwRecordedDepth == iDepth);
            OK(mfText.Expect(","));
            OK((*ppvb)->rsKey.ReadTok(&mfText));

            if (*(char*)mfText.GetRead() != '=') {

                // No value

                (*ppvb)->rwbText.w = 1;
                (*ppvb)->bValue = FALSE;

            } else {

                OK(mfText.Expect("="));
                (*ppvb)->bValue = TRUE;


                if (*(char*)mfText.GetRead() == '\"') {

                    // String value

                    (*ppvb)->rwbText.w = 1;
                    OK((*ppvb)->rsValue.ReadTok(&mfText));

                } else {

                    // Binary value

                    (*ppvb)->rwbText.w = 0;
                    OK((*ppvb)->rbValue.ReadTok(mfText));
                }
            }

            if (*(char*)mfText.GetRead() == ';') {

                // Process subkeys

                OK(mfText.Expect(";"));
                OK(ReadTokVersionBlocks(
                                       mfText,
                                       &(*ppvb)->pSub,
                                       iDepth+1,
                                       &(*ppvb)->cSub));
            }

            // Prepare to add another block

            ppvb = &(*ppvb)->pNext;
        }

        return S_OK;
    }


    size_t cbBinVersionBlocks(const VersionBlock *pvb)  const {

        size_t cb;

        cb = 6;    // Header
        cb += pvb->rsKey.cbBinZ();

        cb = cb+3 & ~3;     // DWORD align

        if (pvb->bValue) {

            if (pvb->rwbText.w) {

                cb += pvb->rsValue.cbBinZ();

            } else {

                cb += pvb->rbValue.cbBin();
            }

            cb = cb + 3 & ~3;   // DWORD align
        }

        if (pvb->pSub != NULL) {

            pvb = pvb->pSub;
            while (pvb) {
                cb += cbBinVersionBlocks(pvb);
                pvb = pvb->pNext;
            }
        }

        return cb;
    }


    HRESULT CopyBinVersionBlocks(
                                BYTE               **ppb,
                                const VersionBlock  *pvb)       const {

        const BYTE      *pbResource;
        size_t           cb;

        pbResource = *ppb;


        while (pvb != NULL) {

            cb = cbBinVersionBlocks(pvb);
            ASSERT(cb < 0x1000);

            *((WORD*)(*ppb)) = (WORD)cb;
            (*ppb) += 2;

            // Generate value length

            if (pvb->bValue) {
                if (pvb->rwbText.w) {
                    *((WORD*)(*ppb)) = pvb->rsValue.GetLength()+1;
                } else {
                    *((WORD*)(*ppb)) = pvb->rbValue.GetLength();
                }
            } else {
                *((WORD*)(*ppb)) = 0;
            }
            (*ppb) += 2;

            OK(pvb->rwbText.CopyBin(ppb));
            OK(pvb->rsKey.CopyBinZ(ppb));

            while (*ppb - pbResource & 3) {
                **ppb = 0;
                (*ppb)++;
            }

            if (pvb->bValue) {

                if (pvb->rwbText.w) {
                    OK(pvb->rsValue.CopyBinZ(ppb));
                } else {
                    OK(pvb->rbValue.CopyBin(ppb));
                }

                while (*ppb - pbResource & 3) {
                    **ppb = 0;
                    (*ppb)++;
                }
            }

            if (pvb->pSub) {
                OK(CopyBinVersionBlocks(ppb, pvb->pSub));
            }

            pvb = pvb->pNext;
        }


        return S_OK;
    }


    int GetItemsVersionBlocks(const VersionBlock *pvb) const {

        int iItems = 0;

        while (pvb != NULL) {

            if (    pvb->bValue
                    &&  pvb->rwbText.w != 0) {

                iItems++;
            }

            iItems += GetItemsVersionBlocks(pvb->pSub);

            pvb = pvb->pNext;
        }

        return iItems;
    }


    int GetWordsVersionBlocks(const VersionBlock *pvb) const {

        int iWords = 0;

        while (pvb != NULL) {

            if (    pvb->bValue
                    &&  pvb->rwbText.w != 0) {

                iWords += pvb->rsValue.GetWords();
            }

            iWords += GetWordsVersionBlocks(pvb->pSub);

            pvb = pvb->pNext;
        }

        return iWords;
    }


public:

    virtual HRESULT ReadTok(TextScanner &mfText) {
        OK(mfText.Expect("Ver;"));
        return ReadTokVersionBlocks(mfText, &pvb, 0, &cBlocks);
    }



    virtual HRESULT WriteTok(NewFile &nfText) const {
        OK(nfText.WriteS("Ver;"));
        OK(nfText.WriteHex(cBlocks,4));
        return WriteTokVersionBlocks(nfText, pvb);
    }



    virtual HRESULT ReadBin(Scanner &mfBinary, DWORD dwLen) {
        return ReadBinVersionBlocks(mfBinary, dwLen, &pvb, 0, &cBlocks);
    }



    virtual size_t cbBin() const {

        const VersionBlock  *pvbTop;
        size_t               cb;

        cb     = 0;
        pvbTop = pvb;

        while (pvbTop) {
            cb     += cbBinVersionBlocks(pvbTop);
            pvbTop  = pvbTop->pNext;
        }
        return cb;
    }



    virtual HRESULT CopyBin (BYTE **ppb) const {
        return CopyBinVersionBlocks(ppb, pvb);
    }

    int GetItems() const {
        return GetItemsVersionBlocks(pvb);
    }

    int GetWords() const {
        return GetWordsVersionBlocks(pvb);
    }


    VersionBlock *FindStringFileInfo(WCHAR* pwcStr) const {
        VersionBlock *pvbRider;

        if (    pvb
                &&  pvb->pSub
                &&  pvb->pSub->pSub
                &&  pvb->pSub->pSub->pSub) {

            pvbRider = pvb->pSub->pSub->pSub;
            while (    pvbRider
                       &&  wcscmp(pvbRider->rsKey.GetString(), pwcStr) != 0) {
                pvbRider = pvbRider->pNext;
            }
            return pvbRider;
        } else {
            return NULL;
        }
    }


    ResourceString* GetStringFileInfo(WCHAR *pwcStr) {

        VersionBlock *pvbStringFileInfo;

        pvbStringFileInfo = FindStringFileInfo(pwcStr);

        if (pvbStringFileInfo) {
            return &pvbStringFileInfo->rsValue;
        } else {
            return NULL;
        }
    }


    void SetStringFileInfo(WCHAR *pwcStr, ResourceString *prs) {

        VersionBlock *pvbStringFileInfo;

        pvbStringFileInfo = FindStringFileInfo(pwcStr);

        if (pvbStringFileInfo) {
            pvbStringFileInfo->rsValue = *prs;
        }
    }

    ResourceBinary* GetBinaryInfo() const {
        if (pvb) {
            return &pvb->rbValue;
        }
        return NULL;
    }

    void SetBinaryInfo(const ResourceBinary *prb) {
        if (pvb) {
            pvb->rbValue = *prb;
        }
    }
};






////    Statistic collection
//
//


struct ResourceStats {
    int  cResources;    // Number of resources with this resource type
    int  cItems;        // Number of items with this resource type
    int  cWords;        // Number of words in strings in this resource type
    int  cBytes;        // Number of bytes used by resources of this type
};

typedef map < ResourceVariant, ResourceStats, less<ResourceVariant> > MappedResourceStats;

MappedResourceStats  ResourceStatsMap;



////    Define our own LangId class so that primary languages sort together.
//
//


class LangId {

public:
    DWORD dwLang;

    LangId(DWORD dwL) {dwLang = dwL;};

    bool operator< (LangId li) const {

        if (PRIMARYLANGID(dwLang) != PRIMARYLANGID(li.dwLang)) {

            return PRIMARYLANGID(dwLang) < PRIMARYLANGID(li.dwLang) ? true : false;

        } else {

            return SUBLANGID(dwLang) < SUBLANGID(li.dwLang) ? true : false;
        }
    }
};


typedef map < LangId, ResourceStats, less<LangId> > MappedLanguageStats;

MappedLanguageStats LanguageStatsMap;






////    UpdateStats
//
//


const ResourceStats ZeroStats = {0};


HRESULT UpdateStats(
                   const ResourceKey  &rk,
                   int                 cItems,
                   int                 cWords,
                   int                 cBytes) {


    if (ResourceStatsMap.count(*rk.prvId[0]) == 0) {
        ResourceStatsMap[*rk.prvId[0]] = ZeroStats;
    }

    if (LanguageStatsMap.count(rk.prvId[2]->GetW()) == 0) {
        LanguageStatsMap[rk.prvId[2]->GetW()] = ZeroStats;
    }

    ResourceStatsMap[*rk.prvId[0]].cResources += 1;
    ResourceStatsMap[*rk.prvId[0]].cItems     += cItems;
    ResourceStatsMap[*rk.prvId[0]].cWords     += cWords;
    ResourceStatsMap[*rk.prvId[0]].cBytes     += cBytes;

    LanguageStatsMap[rk.prvId[2]->GetW()].cResources += 1;
    LanguageStatsMap[rk.prvId[2]->GetW()].cItems     += cItems;
    LanguageStatsMap[rk.prvId[2]->GetW()].cWords     += cWords;
    LanguageStatsMap[rk.prvId[2]->GetW()].cBytes     += cBytes;

    return S_OK;
}










////    IsResourceWanted
//
//      Returns whether a given resource key was requested on the command line


BOOL IsResourceWanted(const ResourceKey &rk) {


    if (rk.prvId[0]->GetfString()) {

        return g_dwProcess & PROCESSOTH;

    } else {

        switch (rk.prvId[0]->GetW()) {

            case 1:    return g_dwProcess & PROCESSCUR;
            case 2:    return g_dwProcess & PROCESSBMP;
            case 3:    return g_dwProcess & PROCESSICO;
            case 4:    return g_dwProcess & PROCESSMNU;
            case 5:    return g_dwProcess & PROCESSDLG;
            case 6:    return g_dwProcess & PROCESSSTR;
            case 7:    return g_dwProcess & PROCESSFDR;
            case 8:    return g_dwProcess & PROCESSFNT;
            case 9:    return g_dwProcess & PROCESSACC;
            case 10:   return g_dwProcess & PROCESSRCD;
            case 11:   return g_dwProcess & PROCESSMSG;
            case 16:   return g_dwProcess & PROCESSVER;
            case 240:
            case 1024:
            case 23:
            case 2110: return g_dwProcess & PROCESSBIN;
            case 2200: return g_dwProcess & PROCESSINF;
            default:   return g_dwProcess & PROCESSOTH;
        }
    }

    return FALSE;
}






////    NewResource
//
//      Returns a pointer to a newly allocated subclass of Resource
//      suitable for the given resource type.


Resource *NewResource(const ResourceVariant &rv) {

    if (rv.GetfString()) {

        return new ResourceBinary;

    } else {

        switch (rv.GetW()) {

            case 1:    return new ResourceBinary;
            case 2:    return new ResourceBinary;
            case 3:    return new ResourceBinary;
            case 4:    return new Menu32;
            case 5:    return new Dialog32;
            case 6:    return new String32;
            case 7:    return new ResourceBinary;
            case 8:    return new ResourceBinary;
            case 9:    return new ResourceBinary;
            case 10:   return new ResourceBinary;
            case 11:   return new ResourceBinary;
            case 16:   return new VersionInfo;
            case 240:
            case 1024:
            case 23:
            case 2110: return new ResourceBinary;
            case 2200: return new ResourceBinary;

            default:   return new ResourceBinary;
        }
    }
}






////    Rsrc internal resource directory
//
//      Rsrc stores resources in an STL 'map' structure.




class ResourceValue {

public:

    const BYTE  *pb;           // Pointer into mapped file
    DWORD        cb;           // Count of bytes in the value
    Resource    *pResource;
    DWORD        dwCodePage;   // Codepage from Win32 resource index - not very useful!

    ResourceValue() {pb = NULL; pResource = NULL; cb=0; dwCodePage=0;}

/*
    ~ResourceValue() {}; // Don't destroy content on destruction

    ResourceValue& operator= (const ResourceValue &rv) {
        pb = rv.pb;
        cb = rv.cb;
        pResource = rv.pResource;
        dwCodePage = rv.dwCodePage;
        return *this;
    }

    ResourceValue(const ResourceValue &rv) {
        *this = rv;
    }
*/


    ////    CreateImage
    //
    //      Convert interpreted resource to binary image.
    //      Used to prepare resources read from tokens for
    //      comparison and update.

    HRESULT CreateImage() {

        BYTE *pbBuf;

        ASSERT(pb        == NULL);
        ASSERT(pResource != NULL);

        cb    = pResource->cbBin();
        pbBuf = new BYTE [cb];
        ASSERT(pbBuf != NULL);

        pb = pbBuf;
        OK(pResource->CopyBin(&pbBuf));

        ASSERT(pbBuf - pb == cb);  // This may be too strong? It has not failed yet!
        ASSERT(pbBuf - pb <= cb);  // This must be true - otherwise we wrote past the end of the buffer

        return S_OK;
    }






    ////    InterpretImage
    //
    //      Convert binary image to interpreted resource.
    //      Used to prepare resources read from executable for
    //      writing as tokens.

    HRESULT InterpretImage(const ResourceKey &rk) {

        ASSERT(pb        != NULL);
        ASSERT(pResource == NULL);

        ASSERT(rk.iDepth == 3);
        ASSERT(!rk.prvId[2]->GetfString());


        if (g_dwOptions & OPTHEXDUMP) {

            pResource = new ResourceHexDump;

        } else {

            // This is a resource extraction to tokens so interpret content

            pResource = NewResource(*rk.prvId[0]);
        }

        ASSERT(pResource != NULL);

        OK(pResource->ReadBin(Scanner(pb, cb), cb));

        pb = NULL;
        cb = 0;

        return S_OK;
    }





    ////    Checksum
    //
    //      Returns DWORD checksum of binary content of resource

    DWORD Checksum() {

        DWORD   dw;
        DWORD  *pdw;
        int     i,l;

        ASSERT(pb != NULL);

        l   = cb >> 2;          // Length in whole DWORDS
        pdw = (DWORD*)pb;
        dw  = 0;

        for (i=0; i<l; i++) {

            dw ^= pdw[i];
        }

        l = cb - (l << 2);      // Remaining length in bytes

        if (l>2) dw ^= pb[cb-3] << 16;
        if (l>1) dw ^= pb[cb-2] << 8;
        if (l>0) dw ^= pb[cb-1];

        return dw;
    }
};






class ResourceMap : public map < ResourceKey, ResourceValue*, less<ResourceKey> > {


public:

    ////    AddResource
    //
    //


    HRESULT AddResource(ResourceKey &rk, const BYTE *pb, DWORD cb, DWORD dwCodePage) {

        ResourceValue *prv;


        // Build a resource structure

        prv = new ResourceValue;

        prv->pb         = pb;
        prv->cb         = cb;
        prv->dwCodePage = dwCodePage;
        prv->pResource  = NULL;


        // Process add options

        if (IsResourceWanted(rk)) {

            // Insert resource details into STL map

            if (this->count(rk) != 0) {

                fprintf(stderr, "%s(", g_szExecutable);
                rk.fprint(stderr);
                fprintf(stderr, "): error RSRC500: Corrupt executable - resource appears more than once\n");
                g_fError = TRUE;
                return E_FAIL;
            }

            (*this)[rk] = prv;

        } else {

            g_cResourcesIgnored++;
        }

        return S_OK;
    }




    ////    CopyResources
    //
    //      Takes a copy so the original mapped file can be closed


    HRESULT CopyResources() {

        iterator   rmi;
        BYTE      *pb;

        for (rmi = begin(); rmi != end(); rmi++) {

            pb = new BYTE[rmi->second->cb];
            ASSERT(pb != NULL);

            memcpy(pb, rmi->second->pb, rmi->second->cb);

            rmi->second->pb = pb;
        }

        return S_OK;
    }




    ////    WriteTokens
    //
    //      Writes the content of the map as a token file.
    //
    //      If an unlocalised map is provided, bit for bit identical
    //      resources are written as a reference to the unlocalised
    //      version language, rather than in full.


    HRESULT WriteTokens(NewFile &nfText, ResourceMap *prmUnlocalised) {

        iterator     rmi;
        iterator     rmiUnlocalised;
        ResourceKey  rkUnlocalised;

        for (rmi = begin(); rmi != end(); rmi++) {

            g_cResourcesExtracted++;

            // Write resource key and codepage

            OK(rmi->first.WriteTok(&nfText));
            OK(nfText.WriteS(";"));
            OK(nfText.WriteHex(rmi->second->dwCodePage, 8));


            if (prmUnlocalised) {

                // Add unlocalised checksum and language

                rkUnlocalised = rmi->first;
                rkUnlocalised.SetLanguage(g_liUnlocalized);
                rmiUnlocalised = prmUnlocalised->find(rkUnlocalised);

                if (rmiUnlocalised == prmUnlocalised->end()) {

                    fprintf(stderr, "%s(", g_szResources);
                    rmi->first.fprint(stderr);
                    fprintf(stderr, "): warning RSRC100: Localised resource has no corresponding unlocalised resource in %s\n", g_szUnloc);
                    g_fWarn = TRUE;

                } else {

                    // Put out details of the unlocalised resource

                    OK(nfText.WriteS(","));
                    OK(nfText.WriteHex(rmiUnlocalised->second->Checksum(), 8));
                    OK(nfText.WriteS(","));
                    OK(nfText.WriteHex(g_liUnlocalized, 4));
                }
            }

            OK(nfText.WriteS(";"));


            // Check whether resource needs to be written in full

            if (    prmUnlocalised
                    &&  rmiUnlocalised != prmUnlocalised->end()
                    &&  rmiUnlocalised->second->cb == rmi->second->cb
                    &&  memcmp(rmi->second->pb, rmiUnlocalised->second->pb, rmi->second->cb) == 0) {

                // Bit for bit match with unlocalised executable

                OK(nfText.WriteS("Unloc"));

            } else {

                // Doesn't match - write it in full

                OK(rmi->second->InterpretImage(rmi->first));
                OK(rmi->second->pResource->WriteTok(nfText));
            }

            OK(nfText.WriteLn());
        }

        return S_OK;
    }




    ////    UpdateWin32Executable
    //
    //


    HRESULT UpdateWin32Executable(char *pExecutable) {

        iterator   rmi;
        HANDLE     hUpdate;


        hUpdate = BeginUpdateResourceA(pExecutable, TRUE);  // Will replace all resources
        MUST(hUpdate != NULL ? S_OK : E_FAIL,
             ("RSRC : error RSRC600: BeginUpdateResource failed on %s\n", pExecutable));


        for (rmi = begin(); rmi != end(); rmi++) {

            ASSERT(rmi->first.iDepth == 3);
            ASSERT(!rmi->first.prvId[2]->GetfString());


            // Create binary image of resource if necessary

            if (rmi->second->pb == NULL) {
                OK(rmi->second->CreateImage());
            }


            // Use NT resource API to update resource binary image in executable

            if (!UpdateResourceW(
                                hUpdate,
                                rmi->first.GetResName(0),
                                rmi->first.GetResName(1),
                                rmi->first.prvId[2]->GetW(),
                                (void*)rmi->second->pb,
                                rmi->second->cb)) {

                EndUpdateResourceW(hUpdate, TRUE);  // Discard all requested updates
                g_fError = TRUE;
                fprintf(stderr, "RSRC : error RSRC601: UpdateResourceW failed on %s\n", pExecutable);
                return HRESULT_FROM_WIN32(GetLastError());
            }
        }

        if (!EndUpdateResourceW(hUpdate, FALSE)) { // Apply all requested updates

            fprintf(stderr, "RSRC : error RSRC602: EndUpdateResourceW failed on %s\n", pExecutable);
            g_fError = TRUE;
            return HRESULT_FROM_WIN32(GetLastError());
        }

        return S_OK;
    }
};






class SymbolFile {

    MappedFile                   *m_pmfSymbolFile;
    IMAGE_SEPARATE_DEBUG_HEADER  *m_pDebugHeader;

public:

    DWORD GetChecksum()       const {return m_pDebugHeader->CheckSum;}
    DWORD GetTimeDateStamp()  const {return m_pDebugHeader->TimeDateStamp;}
    DWORD GetImageBase()      const {return m_pDebugHeader->ImageBase;}
    DWORD GetSizeOfImage()    const {return m_pDebugHeader->SizeOfImage;}

    void  SetChecksum      (DWORD dwChecksum)      {m_pDebugHeader->CheckSum      = dwChecksum;}
    void  SetTimeDateStamp (DWORD dwTimeDateStamp) {m_pDebugHeader->TimeDateStamp = dwTimeDateStamp;}
    void  SetImageBase     (DWORD dwImageBase)     {m_pDebugHeader->ImageBase     = dwImageBase;}
    void  SetSizeOfImage   (DWORD dwSizeOfImage)   {m_pDebugHeader->SizeOfImage   = dwSizeOfImage;}

    HRESULT Open(MappedFile *pmfSymbolFile) {

        m_pmfSymbolFile = pmfSymbolFile;
        m_pDebugHeader  = (IMAGE_SEPARATE_DEBUG_HEADER*) pmfSymbolFile->GetFile();

        ASSERT(m_pDebugHeader->Signature == IMAGE_SEPARATE_DEBUG_SIGNATURE);

        return S_OK;
    }

};





class Win32Executable : public MappedFile {

    IMAGE_NT_HEADERS      *m_pNtHeader;
    IMAGE_SECTION_HEADER  *m_pSections;
    int                    m_iSectionRsrc;
    int                    m_iSectionRsrc1;

    // For scanning

    ResourceKey            m_rk;                // Current resource key


    HRESULT MapDirectory(
                        ResourceMap  &rm,
                        const BYTE   *pbRsrc,       // Resource block
                        int           dwOffset,     // Directory offset relative to m_pbRsrc
                        int           iLevel) {     // Directory level being scanned


        IMAGE_RESOURCE_DIRECTORY        *pird;
        IMAGE_RESOURCE_DIRECTORY_ENTRY  *pEntries;
        IMAGE_RESOURCE_DATA_ENTRY       *pirde;
        const BYTE                      *pb;
        int                              i;

        pird     = (IMAGE_RESOURCE_DIRECTORY*)       (pbRsrc+dwOffset);
        pEntries = (IMAGE_RESOURCE_DIRECTORY_ENTRY*) (pird+1);

        for (i=0; i<pird->NumberOfNamedEntries + pird->NumberOfIdEntries; i++) {

            // Read the ID from the directory

            ASSERT(iLevel<3);
            m_rk.iDepth = iLevel+1;

            m_rk.prvId[iLevel] = new ResourceVariant;
            ASSERT(m_rk.prvId[iLevel] != NULL);
            OK(m_rk.prvId[iLevel]->ReadWin32ResDirEntry(this, pbRsrc, pEntries+i));

            if (pEntries[i].DataIsDirectory) {

                // This is a directory node. Recurse to scan that directory.

                OK(MapDirectory(rm, pbRsrc, pEntries[i].OffsetToDirectory, iLevel+1));

            } else {

                // We've reached a leaf node, establish the data address and
                // add the resource to the map.

                pirde = (IMAGE_RESOURCE_DATA_ENTRY*) (pbRsrc + pEntries[i].OffsetToData);

                // Note that even when the resource data is in .rsrc1, the
                // directory entry is usually in .rsrc.

                if (pirde->OffsetToData <   m_pSections[m_iSectionRsrc].VirtualAddress
                    + m_pSections[m_iSectionRsrc].SizeOfRawData) {

                    // Data is in section .rsrc

                    ASSERT(pirde->OffsetToData >= m_pSections[m_iSectionRsrc].VirtualAddress);

                    pb =    GetFile()
                            +  m_pSections[m_iSectionRsrc].PointerToRawData
                            +  pirde->OffsetToData
                            -  m_pSections[m_iSectionRsrc].VirtualAddress;

                } else {

                    //  Data is in section .rsrc1

                    ASSERT(pirde->OffsetToData >=  m_pSections[m_iSectionRsrc1].VirtualAddress);
                    ASSERT(pirde->OffsetToData <   m_pSections[m_iSectionRsrc1].VirtualAddress
                           + m_pSections[m_iSectionRsrc1].SizeOfRawData);

                    pb =    GetFile()
                            +  m_pSections[m_iSectionRsrc1].PointerToRawData
                            +  pirde->OffsetToData
                            -  m_pSections[m_iSectionRsrc1].VirtualAddress;
                }


                OK(rm.AddResource(m_rk, pb, pirde->Size, pirde->CodePage));
            }
        }
        return S_OK;
    }



public:

    DWORD GetChecksum()      const {return m_pNtHeader->OptionalHeader.CheckSum;}
    DWORD GetTimeDateStamp() const {return m_pNtHeader->FileHeader.TimeDateStamp;}
    DWORD GetImageBase()     const {return m_pNtHeader->OptionalHeader.ImageBase;}
    DWORD GetSizeOfImage()   const {return m_pNtHeader->OptionalHeader.SizeOfImage;}
    BOOL  Is64BitImage()     const {return m_pNtHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC;}

    void  SetChecksum(DWORD dwChecksum) {m_pNtHeader->OptionalHeader.CheckSum=dwChecksum;}




    HRESULT Open(const char *pcFileName, BOOL fWrite) {

        int i;

        OK(MappedFile::Open(pcFileName, fWrite));


        MUST((    *(WORD*)m_pStart == IMAGE_DOS_SIGNATURE
                  &&  *(WORD*)(m_pStart+0x18) >= 0x40)    // WinVer >= 4
             ? S_OK : E_FAIL,
             ("RSRC : error RSRC501: %s is not an executable file\n", pcFileName));

        m_pNtHeader = (IMAGE_NT_HEADERS*)(m_pStart + *(WORD*)(m_pStart+0x3c));

        MUST((m_pNtHeader->Signature == IMAGE_NT_SIGNATURE)
             ? S_OK : E_FAIL,
             ("RSRC : error RSRC502: %s is not a Win32 executable file\n", pcFileName));

        if (Is64BitImage()) {
            m_pSections     = (IMAGE_SECTION_HEADER*)( (BYTE *) (m_pNtHeader+1) +
                                (IMAGE_SIZEOF_NT_OPTIONAL64_HEADER - IMAGE_SIZEOF_NT_OPTIONAL32_HEADER));
        } else {
            m_pSections     = (IMAGE_SECTION_HEADER*)(m_pNtHeader+1);
        }
        
        m_iSectionRsrc  = -1;
        m_iSectionRsrc1 = -1;

        // Locate the one or two resource sections

        for (i=0; i<m_pNtHeader->FileHeader.NumberOfSections; i++) {

            if (strcmp((char*)m_pSections[i].Name, ".rsrc") == 0) {

                m_iSectionRsrc        = i;

            } else if (strcmp((char*)m_pSections[i].Name, ".rsrc") == 0) {

                m_iSectionRsrc1        = i;
            }
        }

        MUST(m_iSectionRsrc >= 0
             ? S_OK : E_FAIL,
             ("RSRC : error RSRC503: No resources in %s\n", pcFileName));
        ASSERT(m_iSectionRsrc > -1);   // Check for presence of resources

        return S_OK;
    }





    ////    MapResourceDirectory
    //
    //      Extract the resource directory into an STL map.


    HRESULT MapResourceDirectory(ResourceMap &rm) {

        OK(MapDirectory(
                       rm,
                       m_pStart + m_pSections[m_iSectionRsrc].PointerToRawData,
                       0, 0));

        if (m_iSectionRsrc1 >= 0) {
            OK(MapDirectory(
                           rm,
                           m_pStart + m_pSections[m_iSectionRsrc1].PointerToRawData,
                           0, 0));
        }

        return S_OK;
    }
};






////    High level operation
//
//      Controlling routines for the various modes of operation



ResourceMap  rmExecutable;      // Read and/or update
ResourceMap  rmUnlocalised;     // '-u' option - unlocalised resources for comparison






////    ApplyResource
//
//      Applies a given key and value to the executable resource map.
//
//      Tokens are merged with those already loaded from the executable
//      according to the update mode (append or replace).


HRESULT ApplyResource(ResourceKey &rk, ResourceValue *prv) {

    ResourceKey            rkUnloc;
    VersionInfo           *pviLoc;
    VersionInfo           *pviUnloc;
    ResourceMap::iterator  rmiUnloc;


    // Establish equivalent unlocalised key

    rkUnloc = rk;
    rkUnloc.SetLanguage(g_liUnlocalized);


    // First ensure that we keep the unlocalised version info, if we can

    if (    !(g_dwOptions & OPTVERSION)
            &&  !rk.prvId[0]->GetfString()
            &&  rk.prvId[0]->GetW() == 16          // VersionInfo
            &&  (rmiUnloc=rmExecutable.find(rkUnloc)) != NULL
            &&  rmiUnloc != rmExecutable.end()) {

        // Special case - keep unlocalised file and product versions

        if (rmiUnloc->second->pResource == NULL) {
            rmiUnloc->second->InterpretImage(rmiUnloc->first);
        }

        pviLoc   = static_cast<VersionInfo*>(prv->pResource);
        pviUnloc = static_cast<VersionInfo*>(rmiUnloc->second->pResource);
        if (pviLoc && pviUnloc) {
            pviLoc->SetStringFileInfo(L"FileVersion",    pviUnloc->GetStringFileInfo(L"FileVersion"));
            pviLoc->SetStringFileInfo(L"ProductVersion", pviUnloc->GetStringFileInfo(L"ProductVersion"));
            pviLoc->SetBinaryInfo(pviUnloc->GetBinaryInfo());
        }
    }




    if (rk.prvId[2]->GetW() == g_liUnlocalized) {

        // New token is not localized

        fprintf(stderr, "%s(", g_szResources);
        rk.fprint(stderr);

        if (rmExecutable.count(rk) == 0) {

            fprintf(stderr, "): warning RSRC110: Unlocalised resource from token file appended to executable\n");
            g_fWarn = TRUE;
            g_cResourcesAppended++;

        } else {

            fprintf(stderr, "): warning RSRC111: Unlocalised resource from token file replaced unlocalised resource in executable\n");
            g_fWarn = TRUE;
            g_cResourcesUpdated++;
        }

    } else if (rmExecutable.count(rk) > 0) {

        // New token already exists in executable

        fprintf(stderr, "%s(", g_szResources);
        rk.fprint(stderr);
        fprintf(stderr, "): warning RSRC112: Localised resource from token file replaced localised resource already present in executable\n");
        g_fWarn = TRUE;
        g_cResourcesUpdated++;

    } else if (g_dwOptions & OPTREPLACE) {

        // Replace operation
        //
        // Replace unlocalised resource with localised translation

        if (rmExecutable.count(rkUnloc) == 0) {

            fprintf(stderr, "%s(", g_szResources);
            rk.fprint(stderr);
            fprintf(stderr, "): warning RSRC113: Localised resource from token file appended to executable - there was no matching unlocalised resource\n");
            g_fWarn = TRUE;
            g_cResourcesAppended++;

        } else {

            // Normal operation: remove unlocalised resource from executable

            rmExecutable.erase(rkUnloc);

            g_cResourcesTranslated++;
        }

    } else {

        // Append operation

        g_cResourcesAppended++;
    }


    rmExecutable[rk] = prv;

    return S_OK;
}






////    ReadTokens
//
//      Scans the token file.
//
//      Selected resources are passed to ApplyResource


HRESULT ReadTokens(TextScanner &mfText) {

    ResourceKey             rk;
    ResourceValue          *prv;
    ResourceKey             rkUnlocalised;
    DWORD                   dwCodePage;
    DWORD                   dwUnlocChecksum;
    ResourceMap::iterator   rmiUnlocalised;
    DWORD                   liUnlocalised;   // Unlocalised language referenced by token


    while (mfText.GetRead() < mfText.GetLimit()) {

        OK(rk.ReadTok(&mfText));    // Read resource key
        OK(mfText.Expect(";"));


        if (    (    g_LangId != 0xffff
                     &&  rk.prvId[2]->GetW() != g_LangId)
                ||  !IsResourceWanted(rk)) {


            // Ignore this token


            g_cResourcesIgnored++;

            fprintf(stderr, "%s(", g_szResources);
            rk.fprint(stderr);

            if (g_LangId != 0xffff  &&  rk.prvId[2]->GetW() != g_LangId) {

                fprintf(stderr, "): warning RSRC120: Token file resource does not match specified language - ignored\n");
                g_fWarn = TRUE;

            } else {

                fprintf(stderr, "): warning RSRC121: Token file resource is not a requested resource type - ignored\n");
                g_fWarn = TRUE;
            }

            // Skip unwanted resource

            OK(mfText.SkipLn());
            while (*(char*)mfText.GetRead() == ' ') {
                OK(mfText.SkipLn());
            }


        } else {

            rmiUnlocalised = NULL;

            OK(mfText.ReadHex(&dwCodePage));

            if (*(char*)mfText.GetRead() == ',') {

                // There is unlocalised resource information available

                OK(mfText.Expect(","));
                OK(mfText.ReadHex(&dwUnlocChecksum));
                OK(mfText.Expect(","));
                OK(mfText.ReadHex(&liUnlocalised));

                // Check whether the unlocalised resource still exists in the
                // current executable, and has the same checksum,


                rkUnlocalised = rk;
                rkUnlocalised.SetLanguage(liUnlocalised);
                rmiUnlocalised = rmExecutable.find(rkUnlocalised);

                if (   rmiUnlocalised != rmExecutable.end()
                       && dwUnlocChecksum != rmiUnlocalised->second->Checksum()) {

                    fprintf(stderr, "%s: warning RSRC122: executable unlocalised resource checksum does not match checksum recorded in token file for resource ", mfText.GetTextPos());
                    rk.fprint(stderr);
                    fprintf(stderr, "\n");
                    g_fWarn = TRUE;
                }
            }

            OK(mfText.Expect(";"));

            if (*(char*)mfText.GetRead() == 'U') {

                // No resource content provided in token file
                // Use unlocalised resource from executable

                if (rmiUnlocalised == NULL) {

                    fprintf(stderr, "%s: error RSRC230: 'Unloc' token is missing unlocalised resource information for ", mfText.GetTextPos());
                    rk.fprint(stderr);
                    fprintf(stderr, "\n");
                    g_fError = TRUE;
                    return E_FAIL;
                }

                OK(mfText.Expect("Unloc"));
                OK(mfText.ExpectLn(""));

                if (rmiUnlocalised == rmExecutable.end()) {

                    fprintf(stderr, "%s: warning RSRC124: missing executable unlocalised resource for ", mfText.GetTextPos());
                    rk.fprint(stderr);
                    fprintf(stderr, " - localisation skipped\n");
                    g_fWarn = TRUE;

                } else {

                    MUST(ApplyResource(rk, rmiUnlocalised->second), ("%s: error RSRC231: Failed to apply unloc token\n", mfText.GetTextPos()));
                }

            } else {

                // Resource content is provided in token file

                if (rmiUnlocalised == rmExecutable.end()) {

                    fprintf(stderr, "%s: warning RSRC125: executable contains no unlocalised resource corresponding to resource ", mfText.GetTextPos());
                    rk.fprint(stderr);
                    fprintf(stderr, "\n");
                    g_fWarn = TRUE;
                }


                prv = new ResourceValue;
                ASSERT(prv != NULL);

                prv->dwCodePage = dwCodePage;
                prv->pb         = NULL;
                prv->cb         = 0;


                switch (*(char*)mfText.GetRead()) {

                    case 'H':  prv->pResource = new ResourceBinary;   break;
                    case 'D':  prv->pResource = new Dialog32;         break;
                    case 'M':  prv->pResource = new Menu32;           break;
                    case 'S':  prv->pResource = new String32;         break;
                    case 'V':  prv->pResource = new VersionInfo;      break;

                    default:
                        fprintf(stderr, "%s: error RSRC310: Unrecognised resource type for resource ", mfText.GetTextPos());
                        rk.fprint(stderr);
                        fprintf(stderr, "\n");
                        g_fError = TRUE;
                        return E_FAIL;
                }

                ASSERT(prv->pResource != NULL);

                // Parse selected resource

                OK(prv->pResource->ReadTok(mfText));
                OK(mfText.ExpectLn(NULL));

                // Save parsed resource in STL map

                MUST(ApplyResource(rk, prv), ("%s: error RSRC232: Failed to apply token\n", mfText.GetTextPos()));
            }
        }
    }

    return S_OK;
}








////    Stats
//
//


HRESULT Analyse(char *pExecutable) {

    Win32Executable                 w32x;
    NewFile                         nfText;
    ResourceMap::iterator           rmi;
    MappedResourceStats::iterator   mrsi;
    MappedLanguageStats::iterator   mlsi;
    char                            key[100];
    int                             i;
    const WCHAR                    *pwc;
    BOOL                            fLocalizable;


    MUST(w32x.Open(pExecutable, FALSE),
         ("RSRC : error RSRC510: Cannot open executable file %s\n", pExecutable));

    MUST(w32x.MapResourceDirectory(rmExecutable),
         ("RSRC : error RSRC511: cannot find resource directory in %s\n, pExecutable"));


    // Scan through the resources updating the stats

    fLocalizable = FALSE;

    for (rmi = rmExecutable.begin(); rmi != rmExecutable.end(); rmi++) {

        if (    rmi->first.prvId[0]->GetfString()
                ||  rmi->first.prvId[0]->GetW() != 16) {
            fLocalizable = TRUE;
        }

        OK(rmi->second->InterpretImage(rmi->first));

        UpdateStats(rmi->first,
                    rmi->second->pResource->GetItems(),
                    rmi->second->pResource->GetWords(),
                    rmi->second->pResource->cbBin());
    }


    if (!(g_dwOptions & OPTQUIET)) {
        fprintf(stdout, "\n   Resource type Count  Items  Words    Bytes\n");
        fprintf(stdout,   "   ------------ ------ ------ ------ --------\n");

        for (mrsi = ResourceStatsMap.begin(); mrsi != ResourceStatsMap.end(); mrsi++) {

            if (mrsi->first.GetfString()) {

                key[0] = '\"';
                i=0;
                pwc = mrsi->first.GetString();
                while (i < min(10, mrsi->first.GetLength())) {

                    key[i+1] = (char) pwc[i];
                    i++;
                }

                key[i+1] = '\"';
                key[i+2] = 0;

                fprintf(stdout, "   %-12.12s ", key);

            } else {

                switch (mrsi->first.GetW()) {
                    case 1:  fprintf(stdout, "   1  (Cursor)  "); break;
                    case 2:  fprintf(stdout, "   2  (Bitmap)  "); break;
                    case 3:  fprintf(stdout, "   3  (Icon)    "); break;
                    case 4:  fprintf(stdout, "   4  (Menu)    "); break;
                    case 5:  fprintf(stdout, "   5  (Dialog)  "); break;
                    case 6:  fprintf(stdout, "   6  (String)  "); break;
                    case 7:  fprintf(stdout, "   7  (Fnt dir) "); break;
                    case 8:  fprintf(stdout, "   8  (Font)    "); break;
                    case 9:  fprintf(stdout, "   9  (Accel)   "); break;
                    case 10: fprintf(stdout, "   a  (RCDATA)  "); break;
                    case 11: fprintf(stdout, "   b  (Msgtbl)  "); break;
                    case 16: fprintf(stdout, "   10 (Version) "); break;
                    default: fprintf(stdout, "   %-12x ", mrsi->first.GetW());
                }
            }

            fprintf(stdout, "%6d ",  mrsi->second.cResources);

            if (mrsi->second.cItems > 0) {
                fprintf(stdout, "%6d ",  mrsi->second.cItems);
            } else {
                fprintf(stdout, "       ");
            }
            if (mrsi->second.cWords > 0) {
                fprintf(stdout, "%6d ",  mrsi->second.cWords);
            } else {
                fprintf(stdout, "       ");
            }
            fprintf(stdout, "%8d\n",  mrsi->second.cBytes);
        }


        fprintf(stdout, "\n   Language  Resources  Items  Words    Bytes\n");
        fprintf(stdout,   "   --------  --------- ------ ------ --------\n");

        for (mlsi = LanguageStatsMap.begin(); mlsi != LanguageStatsMap.end(); mlsi++) {

            fprintf(stdout, "   %8x  %9d ",
                    mlsi->first, mlsi->second.cResources);

            if (mlsi->second.cItems > 0) {
                fprintf(stdout, "%6d ",  mlsi->second.cItems);
            } else {
                fprintf(stdout, "       ");
            }

            if (mlsi->second.cWords > 0) {
                fprintf(stdout, "%6d ",  mlsi->second.cWords);
            } else {
                fprintf(stdout, "       ");
            }

            fprintf(stdout, "%8d\n",  mlsi->second.cBytes);
        }

        fprintf(stdout, "\n");
    }


    if (!fLocalizable) {
        fprintf(stderr, "RSRC : warning RSRC170: No localizable resources in %s\n", pExecutable);
        g_fWarn = TRUE;
    }


    SHOULD(w32x.Close(), ("RSRC : warning RSRC171: could not close executable\n"));

    return S_OK;
}






HRESULT ExtractResources(char *pExecutable, char *pResources) {

    Win32Executable    w32x;
    Win32Executable    w32xUnloc;
    NewFile            nfText;
    char               str[100];
    DWORD              dw;


    MUST(w32x.Open(g_szExecutable, FALSE),
         ("RSRC : error RSRC510: Cannot open executable file %s\n", g_szExecutable));

    MUST(nfText.OpenWrite(g_szResources),
         ("RSRC : error RSRC512: Cannot create resource token file %s\n", g_szResources));

    // Write header

    if (!(g_dwOptions & OPTHEXDUMP)) {
        OK(nfText.WriteS("\xef\xbb\xbf\r\n"));    // UTF-8 mark for notepad, richedit etc.
    }
    OK(nfText.WriteS("###     "));
    OK(nfText.WriteS(g_szResources));
    OK(nfText.WriteS("\r\n#\r\n#       Extracted:  "));
    GetDateFormatA(
                  MAKELCID(LANG_ENGLISH, SORT_DEFAULT),
                  0, NULL,
                  "yyyy/MM/dd ",
                  str, sizeof(str));
    OK(nfText.WriteS(str));
    GetTimeFormatA(
                  MAKELCID(LANG_ENGLISH, SORT_DEFAULT),
                  0, NULL,
                  "HH:mm:ss\'\r\n#       By:         \'",
                  str, sizeof(str));
    OK(nfText.WriteS(str));
    dw = sizeof(str);
    GetComputerNameA(str, &dw);
    OK(nfText.WriteS(str));
    OK(nfText.WriteS("\r\n#       Executable: "));
    OK(nfText.WriteS(g_szExecutable));

    if (g_LangId != 0xffff) {
        OK(nfText.WriteS("\r\n#       Language:   "));
        OK(nfText.WriteHex(g_LangId, 3));
    }

    if (g_dwProcess != PROCESSALL) {
        OK(nfText.WriteS("\r\n#       Res types:  "));
        OK(nfText.WriteS(g_szTypes));
    }

    OK(nfText.WriteS("\r\n\r\n"));


    MUST(w32x.MapResourceDirectory(rmExecutable),
         ("RSRC : error RSRC511: cannot find resource directory in %s\n, g_szExecutable"));


    if (g_dwOptions & OPTUNLOC) {

        // Write tokens that differ from specified unlocalised executable

        MUST(w32xUnloc.Open(g_szUnloc, FALSE),
             ("RSRC : error RSRC513: Cannot open unlocalised executable file %s\n", g_szUnloc));

        MUST(w32xUnloc.MapResourceDirectory(rmUnlocalised),
             ("RSRC : error RSRC514: cannot find resource directory in unlocalised executable %s\n, g_szUnloc"));

        MUST(rmExecutable.WriteTokens(nfText, &rmUnlocalised),
             ("RSRC : error RSRC515: cannot write delta token file %s\n, g_szResources"));

        w32xUnloc.Close();

    } else {

        MUST(rmExecutable.WriteTokens(nfText, NULL),
             ("RSRC : error RSRC516: cannot write stand alone token file %s\n, g_szResources"));
    }


    if (!(g_dwOptions & OPTQUIET)) {
        fprintf(stdout, "\n%d resource(s) %s.\n", g_cResourcesExtracted, g_dwOptions & OPTHEXDUMP ? "dumped" : "tokenized");

        if (g_cResourcesIgnored) {
            fprintf(stdout, "%d resource(s) ignored.\n", g_cResourcesIgnored);
        }
    }

    OK(w32x.Close());
    OK(nfText.Close());

    return S_OK;
}






////    UpdateResources
//
//      Update resources in executable with tokens from given text
//
//      Processing
//
//      1. Existing resources are loaded into the map as ResourceBinaries.
//      2. Resources are merged in from the token file according to
//         command line selected processing options
//      3. The NT UpdateResource API set is used to replace all the resources
//         in the executable with the merged resources in the map.


HRESULT UpdateResources(char *pExecutable, char *pResources, char* pSymbols) {

    Win32Executable  w32x;
    SymbolFile       symf;
    MappedFile       mfText;
    MappedFile       mfSymbols;
    DWORD            dwCheckSum;

    MUST(w32x.Open(pExecutable, FALSE),
         ("RSRC : error RSRC510: Cannot open executable file %s\n", pExecutable));

    MUST(mfText.Open(pResources, FALSE),
         ("RSRC : error RSRC520: Cannot open resource token file %s\n", pResources));

    MUST(mfText.Expect("\xef\xbb\xbf"),
         ("RSRC : error RSRC521: UTF8 BOM missing from token file\n"));      // UTF-8 mark for notepad, richedit etc.

    OK(mfText.ExpectLn(""));                // Skip over header comments

    if (g_dwOptions & OPTSYMBOLS) {
        if (    SUCCEEDED(mfSymbols.Open(pSymbols, TRUE))
                &&  SUCCEEDED(symf.Open(&mfSymbols))) {

            if (    symf.GetChecksum()  != w32x.GetChecksum()
                    ||  symf.GetImageBase() != w32x.GetImageBase()) {

                time_t tsTime = symf.GetTimeDateStamp();
                time_t teTime = w32x.GetTimeDateStamp();
                char   ssTime[30]; strcpy(ssTime, ctime(&tsTime)); ssTime[19] = 0;
                char   seTime[30]; strcpy(seTime, ctime(&teTime)); seTime[19] = 0;

                fprintf(stderr, "\n   Symbol mismatch:       Executable        Symbol file\n");
                fprintf(stderr,   "      ImageBase:            %8x           %8x\n", w32x.GetImageBase(), symf.GetImageBase());
                fprintf(stderr,   "      Checksum:             %8x           %8x\n", w32x.GetChecksum(), symf.GetChecksum());
                fprintf(stderr,   "      Timestamp:     %-15.15s    %-15.15s\n\n", ssTime+4, seTime+4);

                fprintf(stderr, "RSRC : warning RSRC160: Symbol file does not match exectable\n");
                g_fWarn = TRUE;
            }

        } else {

            fprintf(stderr, "RSRC : warning RSRC161: Symbol file not processed\n");
            g_fWarn = TRUE;
            g_dwOptions &= ~OPTSYMBOLS;
        }

    }

    // Load existing resources

    MUST(w32x.MapResourceDirectory(rmExecutable),
         ("RSRC : error RSRC530: Cannot read executable resources from %s\n", pExecutable));

    OK(rmExecutable.CopyResources()); // Take local copy before closing the mapped file

    OK(w32x.Close());


    // Merge in resources from token file

    MUST(ReadTokens(mfText), ("RSRC : error RSRC531: Failed reading update tokens\n"));

    OK(rmExecutable.UpdateWin32Executable(pExecutable));



    // Update was succesful, Recalculate checksum

    SHOULD(w32x.Open(pExecutable, TRUE),
           ("RSRC : warning RSRC162: Could not reopen executable %s to update checksum\n", pExecutable));

    dwCheckSum = w32x.CalcChecksum();

    w32x.SetChecksum(dwCheckSum);

    if (g_dwOptions & OPTSYMBOLS) {
        symf.SetChecksum(dwCheckSum);
        symf.SetTimeDateStamp(w32x.GetTimeDateStamp());
        symf.SetSizeOfImage(w32x.GetSizeOfImage());
        SHOULD(mfSymbols.Close(), ("RSRC : warning RSRC163: Failed to write updated symbol checksum\n"));
    }

    w32x.Close();


    if (!(g_dwOptions & OPTQUIET)) {

        fprintf(stdout, "\n");

        if (g_cResourcesTranslated) {
            fprintf(stdout, "%d resource(s) translated.\n", g_cResourcesTranslated);
        }

        if (g_cResourcesAppended) {
            fprintf(stdout, "%d resource(s) appended.\n", g_cResourcesAppended);
        }

        if (g_cResourcesUpdated) {
            fprintf(stdout, "%d resource(s) updated.\n", g_cResourcesUpdated);
        }

        if (g_cResourcesIgnored) {
            fprintf(stdout, "%d resource(s) ignored.\n", g_cResourcesIgnored);
        }
    }

    mfText.Close();

    return S_OK;
}





////    Parameter parsing
//
//


char g_cSwitch = '-';   // Switch character is recorded the first time one is seen


void SkipWhitespace(char** p, char* pE) {
    while ((*p<pE) && ((**p==' ')||(**p==9))) (*p)++;
}


void ParseToken(char** p, char* pE, char* s, int l) {

    // Parse up to whitespace into string s
    // Guarantee zero terminator and modify no more than l chars
    // Return with p beyond whitespace


    if (*p < pE  &&  **p == '\"') {

        // Quoted parameter

        (*p)++;  // Skip over leading quote

        while (l>0  &&  *p<pE  &&  **p!='\"') {
            *s=**p;  s++;  (*p)++;  l--;
        }

        // Skip any part of token that didn't fit s

        while (*p<pE  &&  **p!='\"') { // Skip up to terminating quote
            (*p)++;
        }

        if (*p<pE) { // Skip over terminating quote
            (*p)++;
        }

    } else {

        // Unquoted parameter


        while ((l>0) && (*p<pE) && (**p>' ')) {
            *s=**p;  s++;  (*p)++;
            l--;
        }

        // Skip any part of token that didn't fit into s
        while ((*p<pE) && (**p>' ')) (*p)++;
    }


    if (l>0)
        *s++ = 0;
    else
        *(s-1) = 0;

    SkipWhitespace(p, pE);
}


void ParseName(char** p, char* pE, char* s, int l) {

    // Uses ParseToken to parse a name such as a filename.
    // If the name starts with '/' or '-' it is assumed to be
    // an option rather than a filename and ParseName returns
    // a zero length string.

    if (*p<pE  &&  **p==g_cSwitch) {

        // This is an option and should not be treated as a name argument

        s[0] = 0;

    } else {

        ParseToken(p, pE, s, l);
    }
}





void DisplayUsage() {
    fprintf(stdout, "Usage: rsrc -h\n");
    fprintf(stdout, "   or: rsrc  executable [-l LangId] [-i include-opts] [-q]\n");
    fprintf(stdout, "             [   [-t|-d] [text-output] [-c unloc]\n");
    fprintf(stdout, "               | [-a|-r] [text-input]  [-s symbols] ]\n");
}

void DisplayArgs() {
    fprintf(stdout, "\nArguments\n\n");
    fprintf(stdout, "   -h         Help\n");
    fprintf(stdout, "   -q         Quiet (default is to show resource stats)\n");
    fprintf(stdout, "   -t tokens  Write resources in checkin format to token file\n");
    fprintf(stdout, "   -c unloc   Unlocalised executable for comparison\n");
    fprintf(stdout, "   -d tokens  Write resources in hex dump format to token file\n");
    fprintf(stdout, "   -a tokens  Append resources from token file to executable (multi-language update)\n");
    fprintf(stdout, "   -r tokens  Replace executable resources from token file (single language update)\n");
    fprintf(stdout, "   -s symbol  Symbol file whose checksum is to track the executable checksum\n");
    fprintf(stdout, "   -l lang    Restrict processing to language specified in hex\n");
    fprintf(stdout, "   -u unlocl  Unlocalised langauge, default 409\n");
    fprintf(stdout, "   -i opts    Include only resource types specified:\n\n");
    fprintf(stdout, "                 c - Cursors               t - Fonts\n");
    fprintf(stdout, "                 b - Bitmaps               a - Accelerators\n");
    fprintf(stdout, "                 i - Icons                 r - RCDATAs\n");
    fprintf(stdout, "                 m - Menus                 g - Message tables\n");
    fprintf(stdout, "                 d - Dialogs               v - Versions info\n");
    fprintf(stdout, "                 s - Strings               x - Binary data\n");
    fprintf(stdout, "                 f - Font directories      n - INFs\n");
    fprintf(stdout, "                 o - all others            a - All (default)\n\n");
    fprintf(stdout, "   Examples\n\n");
    fprintf(stdout, "       rsrc notepad.exe               - Show resource stats for notepad.exe\n");
    fprintf(stdout, "       rsrc notepad.exe -t            - Extract tokens to notepad.exe.rsrc\n");
    fprintf(stdout, "       rsrc notepad.exe -r -l 401     - Translate from US using Arabic tokens in notepad.exe.rsrc\n");
    fprintf(stdout, "       rsrc notepad.exe -d dmp -i im  - Hexdump of Icons and Menus to dmp\n\n");
}





HRESULT ProcessParameters() {

    char   *p;      // Current command line character
    char   *pE;     // End of command line
    char   *pcStop;

    char    token      [MAXPATH];
    char    arg        [MAXPATH];
    char    symbols    [MAXPATH] = "";

    int     i,j;
    int     cFiles;
    DWORD   cRes;
    BOOL    fArgError;

    p  = GetCommandLine();
    pE = p+strlen((char *)p);


    g_dwOptions  = 0;
    g_dwProcess  = 0;
    cFiles       = 0;
    fArgError    = FALSE;
    g_szResources[0] = 0;


    // Skip command name
    ParseToken(&p, pE, token, sizeof(token));

    while (p<pE) {
        ParseToken(&p, pE, token, sizeof(token));

        if (    token[0] == '-'
                ||  token[0] == '/') {

            // Process command option(s)

            i = 1;
            g_cSwitch = token[0];       // Argument may start with the other switch character
            CharLower((char*)token);
            while (token[i]) {
                switch (token[i]) {
                    case '?':
                    case 'h': g_dwOptions |= OPTHELP;      break;
                    case 'v': g_dwOptions |= OPTVERSION;   break;
                    case 'q': g_dwOptions |= OPTQUIET;     break;

                    case 't': g_dwOptions |= OPTEXTRACT;   ParseName(&p, pE, g_szResources, sizeof(g_szResources));  break;
                    case 'c': g_dwOptions |= OPTUNLOC;     ParseName(&p, pE, g_szUnloc,     sizeof(g_szUnloc));      break;
                    case 'd': g_dwOptions |= OPTHEXDUMP;   ParseName(&p, pE, g_szResources, sizeof(g_szResources));  break;
                    case 'a': g_dwOptions |= OPTAPPEND;    ParseName(&p, pE, g_szResources, sizeof(g_szResources));  break;
                    case 'r': g_dwOptions |= OPTREPLACE;   ParseName(&p, pE, g_szResources, sizeof(g_szResources));  break;
                    case 's': g_dwOptions |= OPTSYMBOLS;   ParseName(&p, pE, symbols,       sizeof(g_szResources));  break;

                    case 'l':
                        ParseToken(&p, pE, arg, sizeof(arg));
                        g_LangId = strtol(arg, &pcStop, 16);
                        if (*pcStop != 0) {
                            fprintf(stderr, "Localized language id contains invalid hex digit '%c'.\n", *pcStop);
                            fArgError = TRUE;
                        }
                        break;

                    case 'u':
                        ParseToken(&p, pE, arg, sizeof(arg));
                        g_liUnlocalized = strtol(arg, &pcStop, 16);
                        if (*pcStop != 0) {
                            fprintf(stderr, "Unlocalized language id contains invalid hex digit '%c'.\n", *pcStop);
                            fArgError = TRUE;
                        }
                        break;

                    case 'i':
                        ParseToken(&p, pE, g_szTypes, sizeof(g_szTypes));
                        g_dwProcess = 0;
                        j = 0;
                        while (g_szTypes[j]) {
                            switch (g_szTypes[j]) {
                                case 'c': g_dwProcess |= PROCESSCUR;  break;
                                case 'b': g_dwProcess |= PROCESSBMP;  break;
                                case 'i': g_dwProcess |= PROCESSICO;  break;
                                case 'm': g_dwProcess |= PROCESSMNU;  break;
                                case 'd': g_dwProcess |= PROCESSDLG;  break;
                                case 's': g_dwProcess |= PROCESSSTR;  break;
                                case 'f': g_dwProcess |= PROCESSFDR;  break;
                                case 't': g_dwProcess |= PROCESSFNT;  break;
                                case 'a': g_dwProcess |= PROCESSACC;  break;
                                case 'r': g_dwProcess |= PROCESSRCD;  break;
                                case 'g': g_dwProcess |= PROCESSMSG;  break;
                                case 'v': g_dwProcess |= PROCESSVER;  break;
                                case 'x': g_dwProcess |= PROCESSBIN;  break;
                                case 'n': g_dwProcess |= PROCESSINF;  break;
                                case 'o': g_dwProcess |= PROCESSOTH;  break;
                                case 'A': g_dwProcess |= PROCESSALL;  break;
                                default:
                                    fprintf(stderr, "Unrecognised resource type '%c'.\n", g_szTypes[j]);
                                    fArgError = TRUE;
                            }
                            j++;
                        }
                        break;

                    default:
                        fprintf(stderr, "Unrecognised argument '%c'.\n", token[i]);
                        fArgError = TRUE;
                        break;
                }
                i++;
            }

        } else {

            // Process filename

            switch (cFiles) {
                case 0:  strcpy(g_szExecutable, token); break;
            }
            cFiles++;
        }
    }


    if (g_dwOptions & OPTHELP) {

        fprintf(stderr, "\nRsrc - Manage Win32 executable resources.\n\n");
        DisplayUsage();
        DisplayArgs();
        return S_OK;

    }



    // Validate option combinations

    if (g_dwOptions & OPTEXTRACT) {

        if (g_dwOptions & (OPTHEXDUMP | OPTAPPEND | OPTREPLACE | OPTSYMBOLS)) {

            fprintf(stderr, "RSRC : error RSRC400: -t (tokenise) option excludes -d, -a, -r, and -s\n");
            fArgError = TRUE;
        }

    } else if (g_dwOptions & OPTHEXDUMP) {

        if (g_dwOptions & (OPTEXTRACT | OPTUNLOC | OPTAPPEND | OPTREPLACE | OPTSYMBOLS)) {

            fprintf(stderr, "RSRC : error RSRC401: -d (dump) option excludes -t, -u, -a, -r, and -s\n");
            fArgError = TRUE;
        }

    } else if (g_dwOptions & OPTAPPEND) {

        if (g_dwOptions & (OPTEXTRACT | OPTHEXDUMP | OPTUNLOC | OPTREPLACE)) {

            fprintf(stderr, "RSRC : error RSRC402: -a (append) option excludes -t, -d, -u, and -r\n");
            fArgError = TRUE;
        }

    } else if (g_dwOptions & OPTREPLACE) {

        if (g_dwOptions & (OPTEXTRACT | OPTHEXDUMP | OPTUNLOC | OPTAPPEND)) {

            fprintf(stderr, "RSRC : error RSRC403: -r (replace) option excludes -t, -d, -u, and -a\n");
            fArgError = TRUE;
        }

        if (g_LangId == 0xFFFF) {

            fprintf(stderr, "RSRC : error RSRC404: -r (replace) option requires -l (LangId)\n");
            fArgError = TRUE;
        }

    } else {

        if (g_dwOptions & (OPTSYMBOLS)) {

            fprintf(stderr, "RSRC : error RSRC405: Analysis excludes -s\n");
            fArgError = TRUE;
        }


    }



    if (fArgError) {

        DisplayUsage();
        DisplayArgs();
        return E_INVALIDARG;

    } else if (cFiles != 1) {

        fprintf(stderr, "\nRsrc : error RSRC406: must specify at least an executable file name.\n\n");
        DisplayUsage();
        return E_INVALIDARG;

    } else {

        // We have valid parameters

        if (g_dwProcess == 0) {
            g_dwProcess = PROCESSALL;
        }

        if (!(g_dwOptions & OPTQUIET)) {
            fprintf(stdout, "\nRsrc - Manage executable resources.\n\n");
            fprintf(stdout, "   Executable file: %s\n", g_szExecutable);

            if (g_szResources[0]) {
                fprintf(stdout, "   Resource file:   %s\n", g_szResources);
            }

            if (symbols[0]) {
                fprintf(stdout, "   Symbol file:     %s\n", symbols);
            }

            if (g_LangId != 0xffff) {
                char szLang[50] = "";
                char szCountry[50] = "";
                GetLocaleInfoA(g_LangId, LOCALE_SENGLANGUAGE, szLang, sizeof(szLang));
                GetLocaleInfoA(g_LangId, LOCALE_SENGCOUNTRY,  szCountry, sizeof(szCountry));
                fprintf(stdout, "   Language:        %x (%s - %s)\n", g_LangId, szLang, szCountry);
            }

            if (g_dwProcess != PROCESSALL) {
                fprintf(stdout, "   Include only:    %s\n", g_szTypes);
            }
        }

        cRes = 0;


        // Handle default token file name

        if (g_szResources[0] == 0) {
            strcpy(g_szResources, g_szExecutable);
            strcat(g_szResources, ".rsrc");
        }


        if (g_dwOptions & (OPTAPPEND | OPTREPLACE)) {

            // Update an executable from tokens

            MUST(UpdateResources(g_szExecutable, g_szResources, symbols), ("RSRC : error RSRC420: Update failed.\n"));

        } else if (g_dwOptions & (OPTEXTRACT | OPTHEXDUMP)) {

            // Generate tokens from an executable

            MUST(ExtractResources(g_szExecutable, g_szResources), ("RSRC : error RSRC421: Token extraction failed.\n"));

        } else {

            // Analyse an executable

            MUST(Analyse(g_szExecutable), ("RSRC : error RSRC422: Analysis failed.\n"));

        }

        return S_OK;
    }
}






int _cdecl main(void) {

    if (SUCCEEDED(ProcessParameters())) {

        if (!g_fWarn) {

            return 0;       // No problems

        } else {

            return 1;       // Warning(s) but no error(s)
        }

    } else {

        return 2;           // Error(s)

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\common\m68k.h ===
//=====================================================================
//
//	Definition for the standard Mac formats
//
//=====================================================================

#define LPNULL 0L

#define MAXLEVELS 					3			// Max number of level in the PE header tree

#define IMAGE_FILE_MACHINE_M68K		0x0268		// Identify the M68K machine signature
#define appleMark                   20

#define CODEPAGE					(DWORD)-1L	// Will assume ansi char set [might be wrong]

#define	MENU_TYPE					4			// Map MENU to menu (4)
#define	DLOG_TYPE					5			// Map DLOG to dialog (5)
#define DITL_TYPE                   17          // Map DITL to 17 since 17 is unused we avoid ID conflicts with DLOG
#define STR_TYPE					6			// Map STR to string table (6)
#define MSG_TYPE					11			// Map STR# and TEXT to message table (11)
#define WIND_TYPE                   18          // Map WIND to 18, unknown type, treated like a STR

#define COORDINATE_FACTOR			0.50		// factor of reduction from mac to windows

#define _APPLE_MARK_                "_APPLE_MARK_"

//=====================================================================
//	Conversion utility 
//=====================================================================

#define MACLONG(x)	BYTE x[4]
#define MACWORD(x)	BYTE x[2]

BYTE * WordToMacWord(WORD w);
BYTE * LongToMacLong(LONG l);
BYTE * LongToMacOffset(LONG l);
BYTE * WinValToMacVal(WORD w);

LONG __inline MacLongToLong(BYTE * p)
{								
    LONG l = 0;						
    BYTE *pl = (BYTE *) &l;		
								
    p += 3;						
    *pl++ = *p--;				
    *pl++ = *p--;				
    *pl++ = *p--;				
    *pl = *p;					
								
    return l;					
}								

LONG __inline MacOffsetToLong(BYTE * p)
{								
    LONG l = 0;						
    BYTE *pl = (BYTE *) &l;		
								
    p += 2;						
    
	*pl++ = *p--;				
	*pl++ = *p--;				
    *pl = *p;					
								
    return l;
}								

WORD __inline MacWordToWord(BYTE * p)
{								
    WORD w = 0;						
    BYTE *pw = (BYTE *) &w;		
								
    p += 1;						
    *pw++ = *p--;				
    *pw = *p;					
								
    return w;
}								

WORD __inline MacValToWinVal(BYTE * p)
{
	return (WORD)(MacWordToWord(p)*COORDINATE_FACTOR);
}

DWORD __inline MemCopy( LPVOID lpTgt, LPVOID lpSrc, DWORD dwSize, DWORD dwMaxTgt)
{
    if(!dwSize)      // If the user is asking us to copy 0 then 
        return 1;   // do nothing but return 1 so the return test will be succesfull

    if(dwMaxTgt>=dwSize) {
        memcpy(lpTgt, lpSrc, dwSize);
        lpTgt = (BYTE*)lpTgt+dwSize;
        return dwSize;
    }
    return 0;
}


typedef BYTE * * LPLPBYTE;

typedef struct tagMacResHeader
{
    MACLONG(mulOffsetToResData);
	MACLONG(mulOffsetToResMap);
	MACLONG(mulSizeOfResData);
	MACLONG(mulSizeOfResMap);
} MACRESHEADER, *PMACRESHEADER;

typedef struct tagMacResMap
{
    BYTE	reserved[16+4+2];
	MACWORD(mwResFileAttribute);
	MACWORD(mwOffsetToTypeList);
	MACWORD(mwOffsetToNameList);
} MACRESMAP, *PMACRESMAP;

typedef struct tagMacResTypeList
{
    BYTE	szResName[4];
	MACWORD(mwNumOfThisType);
	MACWORD(mwOffsetToRefList);
} MACRESTYPELIST, *PMACRESTYPELIST;

typedef struct tagMacResRefList
{
    MACWORD(mwResID);
	MACWORD(mwOffsetToResName);
	BYTE	bResAttribute;
	BYTE	bOffsetToResData[3];
	MACLONG(reserved);
} MACRESREFLIST, *PMACRESREFLIST;


typedef struct tagMacToWindowsMap
{
    WORD	wType;
	char 	szTypeName[5];
	WORD	wResID;
	char 	szResName[256];
	DWORD	dwOffsetToData;
	DWORD	dwSizeOfData;
} MACTOWINDOWSMAP, *PMACTOWINDOWSMAP;

typedef struct tagUpdResList
{
    WORD *  pTypeId;
    BYTE *  pTypeName;
    WORD *  pResId;
    BYTE *  pResName;
    DWORD * pLang;
    DWORD * pSize;
    struct tagUpdResList* pNext;
} UPDATEDRESLIST, *PUPDATEDRESLIST;

//=============================================================================
//=============================================================================
//
// Dialog structures
//
//=============================================================================
//=============================================================================

typedef struct tagMacWDLG
{
	MACLONG(dwStyle);
	MACLONG(dwExtStyle);
	MACWORD(wNumOfElem);
	MACWORD(wX);
	MACWORD(wY);
	MACWORD(wcX);
	MACWORD(wcY);
	// more
} MACWDLG, *PMACWDLG;

typedef struct tagMacWDLGI
{
	MACLONG(dwStyle);
	MACLONG(dwExtStyle);
	MACWORD(wX);
	MACWORD(wY);
	MACWORD(wcX);
	MACWORD(wcY);
	MACWORD(wID);
	// more
} MACWDLGI, *PMACWDLGI;

typedef struct tagMacDLOG
{
	MACWORD(wTop);
	MACWORD(wLeft);
	MACWORD(wBottom);
	MACWORD(wRight);
	MACWORD(wProcID);
	BYTE bVisibile;
	BYTE ignored1;
	BYTE bGoAway;
	BYTE ignored2;
	MACLONG(lRefCon);
	MACWORD(wRefIdOfDITL);
	BYTE bLenOfTitle;
	//BYTE Title[];
} MACDLOG, *PMACDLOG;

typedef struct tagMacALRT
{
	MACWORD(wTop);
	MACWORD(wLeft);
	MACWORD(wBottom);
	MACWORD(wRight);
	MACWORD(wRefIdOfDITL);
	MACLONG(lStage);
} MACALRT, *PMACALRT;

typedef struct tagMacDIT
{
	MACLONG(lPointer);
	MACWORD(wTop);
	MACWORD(wLeft);
	MACWORD(wBottom);
	MACWORD(wRight);
	BYTE bType;
	BYTE bSizeOfDataType;
} MACDIT, *PMACDIT;

typedef struct tagMacWIND
{
    MACWORD(wTop);
	MACWORD(wLeft);
	MACWORD(wBottom);
	MACWORD(wRight);
	MACWORD(wProcId);
    BYTE bVisibile;
	BYTE ignored1;
	BYTE bGoAway;
	BYTE ignored2;
	MACLONG(lRefCon);
    BYTE bLenOfTitle;
	//BYTE Title[];
} MACWIND, *PMACWIND;

//=============================================================================
//=============================================================================
//
// Menu structures
//
//=============================================================================
//=============================================================================

typedef struct tagMacMenu
{
	MACWORD(wId);
	MACWORD(wWidth);
	MACWORD(wHeigth);
	MACWORD(wDefProcId);
    MACWORD(wReserved);     // must be 0
    MACLONG(lEnableFlags);
	BYTE bSizeOfTitle;
} MACMENU, *PMACMENU;

typedef struct tagMacMenuItem
{
    //BYTE bSizeOfText;
    // text
	BYTE   bIconId;
    BYTE   bKeyCodeId;
    BYTE   bKeyCodeMark;
    BYTE   bCharStyle;
} MACMENUITEM, *PMACMENUITEM;

//=============================================================================
//=============================================================================
//
// PE Header parsing functions
//
//=============================================================================
//=============================================================================

UINT FindMacResourceSection( CFile*, BYTE **, PIMAGE_SECTION_HEADER*, int *);
UINT ParseResourceFile( BYTE * pResFile, PIMAGE_SECTION_HEADER, BYTE **, LONG *, int );
BOOL IsMacResFile ( CFile * pFile );

//=============================================================================
//=============================================================================
//
// Parsing functions
//
//=============================================================================
//=============================================================================

UINT ParseSTR( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseTEXT( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseSTRNUM( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

UINT ParseDLOG( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseALRT( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseWDLG( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseWIND( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

UINT ParseWMNU( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseMENU( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
UINT ParseMBAR( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

//=============================================================================
// Used by ParseDLOG and ParseALRT to find the DITL
DWORD FindMacResource( LPSTR pfilename, LPSTR lpType, LPSTR pName );
DWORD FindResourceInResFile( BYTE * pResFile, PIMAGE_SECTION_HEADER pResSection, LPSTR pResType, LPSTR pResName);

UINT ParseDITL( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

//=============================================================================
//=============================================================================
//
// Updating functions
//
//=============================================================================
//=============================================================================
UINT UpdateMENU( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);

UINT UpdateSTR( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);
UINT UpdateSTRNUM( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);

UINT UpdateDLOG( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);
UINT UpdateALRT( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);
UINT UpdateDITL( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);
UINT UpdateWDLG( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);
UINT UpdateWIND( LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD *);

//=============================================================================
//=============================================================================
//
// General helper functions
//
//=============================================================================
//=============================================================================

WORD GetMacWString( WORD **, char *, int );
WORD PutMacWString( WORD *, char *, int );
PUPDATEDRESLIST IsResUpdated( BYTE*, MACRESREFLIST, PUPDATEDRESLIST);
PUPDATEDRESLIST UpdatedResList( LPVOID, UINT );

//=============================================================================
//=============================================================================
//
// Mac to ANSI and back conversion
//
//=============================================================================
//=============================================================================

LPCSTR MacCpToAnsiCp(LPCSTR str);
LPCSTR AnsiCpToMacCp(LPCSTR str);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\common\m68k.cpp ===
//=============================================================================
//	Mac Reader/Writer functions
//
//	Alessandro Muti - August 25 1994
//=============================================================================

#include <afxwin.h>
#include <limits.h>
#include <iodll.h>
#include "helper.h"
#include "m68k.h"
#include "..\mac\mac.h"

#define MAX_STR 1024

static char szTextBuf[MAX_STR];
static WORD szWTextBuf[MAX_STR];

//=============================================================================
//=============================================================================
//
// PE Header parsing functions
//
//=============================================================================
//=============================================================================

//=============================================================================
// FindMacResourceSection
//
// Will walk the section header searching for ";;resxxx" resource name.
// If pResName is NULL then will return the first section otherwise will
// return the first section matching after the pResName.
// If there are no more resource section will return FALSE.
//=============================================================================

UINT FindMacResourceSection( CFile* pfile, BYTE * * pRes, PIMAGE_SECTION_HEADER * ppSectTbl, int * piNumOfSect )
{
    UINT uiError = ERROR_NO_ERROR;
	LONG lRead = 0;
	PIMAGE_SECTION_HEADER pResSect = NULL;

    // Check all the sections for the ";;resXXX"
    USHORT us =0;
    for (PIMAGE_SECTION_HEADER pSect = *ppSectTbl;
         *piNumOfSect; (*piNumOfSect)-- )     {
        if ( !strncmp((char*)pSect->Name, ";;res", 5) ) {
			// we have a matching
			TRACE("\tFindMacResourceSection: Name: %s\tSize: %d\n", pSect->Name, pSect->SizeOfRawData);
			pResSect = pSect;
			*ppSectTbl = pSect;
			break;
        }
        pSect++;
    }

    if (!pResSect) {
        return ERROR_RW_NO_RESOURCES;
    }

    BYTE * pResources = (BYTE *) malloc((pResSect)->SizeOfRawData);

    if (pResources==LPNULL) {
        return ERROR_NEW_FAILED;
    }

    // We read the data for the first section
    pfile->Seek( (LONG)(pResSect)->PointerToRawData, CFile::begin);
    lRead = ReadFile(pfile, pResources, (LONG)(pResSect)->SizeOfRawData);

    if (lRead!=(LONG)(pResSect)->SizeOfRawData) {
        free(pResources);
        return ERROR_FILE_READ;
    }

    // We want to copy the pointer to the resources
    *pRes = (BYTE*)pResources;
    return 0;
}

//=============================================================================
// ParseResourceFile
//
// pResFile is pointing to the resource file data.
// We will read the resource header to find the resource data and the resource
// map address.
// We will walk the resource map and find the offset to the data for each type
//=============================================================================

UINT ParseResourceFile( BYTE * pResFile, PIMAGE_SECTION_HEADER pResSection, BYTE ** ppBuf, LONG * pBufSize, int iFileNameLen)
{
	MACTOWINDOWSMAP MacToWindows;
	PMACRESHEADER pResHeader = (PMACRESHEADER)pResFile;

	// Move at the beginning of the Resource Map
	PMACRESMAP pResMap = (PMACRESMAP)(pResFile+MacLongToLong(pResHeader->mulOffsetToResMap));

	//Read all the Type in this resource
	WORD wItems = MacWordToWord((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToTypeList))+1;
	BYTE * pStartResTypeList = ((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToTypeList));
	BYTE * pStartNameList = ((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToNameList));
	PMACRESTYPELIST pResTypeList = (PMACRESTYPELIST)(pStartResTypeList+sizeof(WORD));
	
	while(wItems--){
		memcpy(&MacToWindows.szTypeName[0], pResTypeList->szResName, 4);
		MacToWindows.szTypeName[4] = '\0';

		WORD wResItems = MacWordToWord(pResTypeList->mwNumOfThisType)+1;
		TRACE("\t\tType: %s\t Num: %d\n", MacToWindows.szTypeName, wResItems);
		
		// Check if is has a valid Windows Mapping
		MacToWindows.wType = MapToWindowsRes(MacToWindows.szTypeName);

		// For all the items
		PMACRESREFLIST pResRefList = (PMACRESREFLIST)(pStartResTypeList+MacWordToWord(pResTypeList->mwOffsetToRefList));
		while(wResItems && MacToWindows.wType)
		{
			if(MacWordToWord(pResRefList->mwOffsetToResName)==0xFFFF) {
				MacToWindows.wResID = MacWordToWord(pResRefList->mwResID);
				MacToWindows.szResName[0] = '\0';
				TRACE("\t\t\tResId: %d",MacToWindows.wResID);
			}
			else {
				// It is a named resource
				BYTE * pName = pStartNameList+MacWordToWord(pResRefList->mwOffsetToResName);
				memcpy( &MacToWindows.szResName[0], pName+1, *pName );
				MacToWindows.szResName[*pName] = '\0';
                //if(!strcmp("DITL", MacToWindows.szTypeName))
                    MacToWindows.wResID = MacWordToWord(pResRefList->mwResID);
                //else MacToWindows.wResID = 0;
				TRACE("\t\t\tResName: %s (%d)",MacToWindows.szResName, MacWordToWord(pResRefList->mwResID) );
			}

			// Get the offset to the data (relative to the beginning of the section)
			MacToWindows.dwOffsetToData = MacLongToLong(pResHeader->mulOffsetToResData)+MacOffsetToLong(pResRefList->bOffsetToResData);
			
			BYTE * pData = (pResFile + MacToWindows.dwOffsetToData);
			MacToWindows.dwSizeOfData = MacLongToLong(pData);
			
			// add the space for the file name
			MacToWindows.dwSizeOfData += iFileNameLen;

			//Fix up offet to data relative to the beginning of the file
			MacToWindows.dwOffsetToData += pResSection->PointerToRawData+sizeof(DWORD);
			TRACE("\tSize: %d\tOffset: %X\n", MacToWindows.dwSizeOfData, MacToWindows.dwOffsetToData);

			// Write the info in the IODLL buffer
			WriteResInfo(
                 ppBuf, pBufSize,
                 MacToWindows.wType, MacToWindows.szTypeName, 5,
                 MacToWindows.wResID, MacToWindows.szResName, 255,
                 0l,
                 MacToWindows.dwSizeOfData, MacToWindows.dwOffsetToData );

			wResItems--;
			pResRefList++;
		}
		
		// Read next type
		pResTypeList++;
	}

	return 0;
}

//=============================================================================
//	FindResource
//
//	Will find the resource of the specified type and ID in the file.
//	Return a pointer to the resource data. Will need to be freed by the caller
//=============================================================================

DWORD FindMacResource( CFile * pfile, LPSTR pType, LPSTR pName )
{
	DWORD dwOffset = 0;
	////////////////////////////////////
	// Check if it is  a valid mac file
	// Is a Mac Resource file ...
	if(IsMacResFile( pfile )) {
		// load the file in memory
		BYTE * pResources = (BYTE*)malloc(pfile->GetLength());
		if(!pResources) {
			return 0;
		}
		
		pfile->Seek(0, CFile::begin);
		pfile->ReadHuge(pResources, pfile->GetLength());

		IMAGE_SECTION_HEADER Sect;
		memset(&Sect, 0, sizeof(IMAGE_SECTION_HEADER));
		
		dwOffset = FindResourceInResFile(pResources, &Sect, pType, pName);
		free(pResources);

		return dwOffset;
	}
	// or is a PE Mac File ...
	// Read the Windows Header
	WORD w;
	pfile->Seek(0, CFile::begin);
    pfile->Read((WORD*)&w, sizeof(WORD));
    if (w!=IMAGE_DOS_SIGNATURE) return 0;

    pfile->Seek( 0x18, CFile::begin );
    pfile->Read((WORD*)&w, sizeof(WORD));
    if (w<0x0040) {
    	// this is not a Windows Executable
        return 0;
    }

    // get offset to new header
    pfile->Seek( 0x3c, CFile::begin );
    pfile->Read((WORD*)&w, sizeof(WORD));

    // read windows new header
    static IMAGE_NT_HEADERS NTHdr;
    pfile->Seek( w, CFile::begin );
    pfile->Read(&NTHdr, sizeof(IMAGE_NT_HEADERS));

    // Check if the magic word is the right one
    if (!((NTHdr.Signature==IMAGE_NT_SIGNATURE) &&
    	  (NTHdr.FileHeader.Machine==IMAGE_FILE_MACHINE_M68K)))
              return 0;

    // Read the section table
    UINT uisize = sizeof(IMAGE_SECTION_HEADER) * NTHdr.FileHeader.NumberOfSections;
	PIMAGE_SECTION_HEADER pSectTbl = new IMAGE_SECTION_HEADER[NTHdr.FileHeader.NumberOfSections];

    if (pSectTbl==LPNULL)
    	return 0;

    // Clean the memory we allocated
    memset( (PVOID)pSectTbl, 0, uisize);

    LONG lRead = pfile->Read(pSectTbl, uisize);

    if (lRead!=(LONG)uisize) {
        delete []pSectTbl;
        return LPNULL;
    }
	
    BYTE * pResources = LPNULL;	
	int iNumOfSect = NTHdr.FileHeader.NumberOfSections;
	PIMAGE_SECTION_HEADER pStartSectTbl = pSectTbl;
	
	// Search all the resource section in the file
	while(!FindMacResourceSection( pfile, &pResources, &pSectTbl, &iNumOfSect))
	{
		if(dwOffset = FindResourceInResFile(pResources, pSectTbl++, pType, pName)) {
			delete []pStartSectTbl;
			return dwOffset;
		}
		iNumOfSect--;
		free(pResources);
	}

	delete []pStartSectTbl;
	
    return 0;
}

//=============================================================================
// FindResourceInResFile
//
// pResFile is pointing to the resource file data.
// We will read the resource header to find the resource data and the resource
// map address.
// We will walk the resource map and find the offset to the data for the res
// we are searching for.
//=============================================================================

DWORD FindResourceInResFile( BYTE * pResFile, PIMAGE_SECTION_HEADER pResSection, LPSTR pResType, LPSTR pResName)
{
	MACTOWINDOWSMAP MacToWindows;
	PMACRESHEADER pResHeader = (PMACRESHEADER)pResFile;

	// Move at the beginning of the Resource Map
	PMACRESMAP pResMap = (PMACRESMAP)(pResFile+MacLongToLong(pResHeader->mulOffsetToResMap));

	//Read all the Type in this resource
	WORD wItems = MacWordToWord((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToTypeList))+1;
	BYTE * pStartResTypeList = ((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToTypeList));
	BYTE * pStartNameList = ((BYTE*)pResMap+MacWordToWord(pResMap->mwOffsetToNameList));
	PMACRESTYPELIST pResTypeList = (PMACRESTYPELIST)(pStartResTypeList+sizeof(WORD));
	
	while(wItems--){
		memcpy(&MacToWindows.szTypeName[0], pResTypeList->szResName, 4);
		MacToWindows.szTypeName[4] = '\0';

		if(!strcmp(MacToWindows.szTypeName, pResType)) {

			WORD wResItems = MacWordToWord(pResTypeList->mwNumOfThisType)+1;

			// For all the items
			PMACRESREFLIST pResRefList = (PMACRESREFLIST)(pStartResTypeList+MacWordToWord(pResTypeList->mwOffsetToRefList));
			while(wResItems)
			{
				if(!HIWORD(pResName)) {
					if(MacWordToWord(pResRefList->mwResID)==LOWORD(pResName))
						return MacLongToLong(pResHeader->mulOffsetToResData)+
								MacOffsetToLong(pResRefList->bOffsetToResData)+
								pResSection->PointerToRawData;
				}
				else {
					// It is a named resource
					if(HIWORD(pResName)) {
						BYTE * pName = pStartNameList+MacWordToWord(pResRefList->mwOffsetToResName);
						memcpy( &MacToWindows.szResName[0], pName+1, *pName );
						MacToWindows.szResName[*pName] = '\0';
						if(!strcmp(MacToWindows.szResName,pResName))
							return MacLongToLong(pResHeader->mulOffsetToResData)+
								MacOffsetToLong(pResRefList->bOffsetToResData)+
								pResSection->PointerToRawData;
					}
				}

				wResItems--;
				pResRefList++;
			}
		
		}
		// Read next type
		pResTypeList++;
	}


	return 0;
}

//=========================================================================
// Determine heuristicaly whether it is a MAC resource file.
// Resource file has a well-defined format, so this should be reliable.
//=========================================================================

BOOL IsMacResFile ( CFile * pFile )
{
    LONG flen, dataoff, mapoff, datalen, maplen;
	BYTE Buf[4];
	BYTE * pBuf = &Buf[0];

    //  From IM I-128:
    //
    //  Resource file structure:
    //
    //  256 bytes Resource Header (and other info):
    //      4 bytes - Offset from beginning of resource file to resource data
    //      4 bytes - Offset from beginning of resource file to resource map
    //      4 bytes - Length of resource data
    //      4 bytes - Length of resource map
    //  Resource Data
    //  Resource Map

    flen  = pFile->GetLength();
    if (flen < 256) {
        return FALSE;
    }

    pFile->Seek(0, CFile::begin);
	pFile->Read(pBuf, 4);

    dataoff = MacLongToLong(pBuf);
    if (dataoff != 256) {
        return FALSE;
    }
	
	pFile->Read(pBuf, 4);
    mapoff = MacLongToLong(pBuf);
	pFile->Read(pBuf, 4);
    datalen = MacLongToLong(pBuf);
	pFile->Read(pBuf, 4);
    maplen = MacLongToLong(pBuf);

    if (mapoff != datalen + 256) {
        return FALSE;
    }

    if (flen != datalen + maplen + 256) {
        return FALSE;
    }

    return TRUE;
}

//=============================================================================
//=============================================================================
//
// Parsing functions
//
//=============================================================================
//=============================================================================

//=============================================================================
//	ParseWMNU
//
//	
//=============================================================================
UINT ParseWMNU( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	return 0;
}

//=============================================================================
//	ParseMENU
//
//	
//=============================================================================
UINT ParseMENU( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
    PMACMENU pMenu = (PMACMENU)lpImageBuf;
    LPRESITEM pResItem = (LPRESITEM)lpBuffer;

    // fill in the first resitem
    WORD wResItemSize = sizeof(RESITEM)+pMenu->bSizeOfTitle+1;
    // check if is the apple menu
    if(pMenu->bSizeOfTitle==1 && *((BYTE*)&pMenu->bSizeOfTitle+1)==appleMark)
        wResItemSize += strlen(_APPLE_MARK_);

    DWORD dwResItemsSize = wResItemSize;
	if(wResItemSize<=dwSize) {
		memset(pResItem, 0, wResItemSize);
		
		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), (char*)pMenu+sizeof(MACMENU), pMenu->bSizeOfTitle+1);
        *(pResItem->lpszCaption+pMenu->bSizeOfTitle) = '\0';

        // check if is the apple menu
        if(pMenu->bSizeOfTitle==1 && *((BYTE*)&pMenu->bSizeOfTitle+1)==appleMark)
            strcpy(pResItem->lpszCaption, _APPLE_MARK_);
		
        pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(pResItem->lpszCaption), strlen(pResItem->lpszCaption));
		//pResItem->dwStyle = MacLongToLong(pWdlg->dwStyle);    make up a style
		pResItem->dwTypeID = MENU_TYPE;
		pResItem->dwItemID = 0x0000ffff;
		pResItem->dwCodePage = CODEPAGE;
        pResItem->dwFlags = MF_POPUP | MF_END;
        pResItem->dwSize = wResItemSize;
		dwSize -= wResItemSize;
		
		pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
	}

    // parse the items in the menu
    BYTE* pMenuText = (BYTE*)pMenu+sizeof(MACMENU)+pMenu->bSizeOfTitle;
    PMACMENUITEM pMenuItem = (PMACMENUITEM)(pMenuText+*pMenuText+1);
    WORD wItem = 1;
    while((BYTE)*pMenuText)
    {
        wResItemSize = sizeof(RESITEM)+*pMenuText+1;
        if(pMenuItem->bKeyCodeId)
            wResItemSize += 3;
        dwResItemsSize += wResItemSize;
    	if(wResItemSize<=dwSize) {
    		memset(pResItem, 0, wResItemSize);
		
    		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), (char*)pMenuText+sizeof(BYTE), *pMenuText);
            *(pResItem->lpszCaption+*pMenuText) = '\0';

            if(*pResItem->lpszCaption=='-')
            {
                *pResItem->lpszCaption = '\0';
                pResItem->dwFlags = 0;
                pResItem->dwItemID = 0;
            }
            else {
                pResItem->dwItemID = wItem++;
                if(pMenuItem->bKeyCodeMark)
                    pResItem->dwFlags |= MF_CHECKED;
                if(pMenuItem->bKeyCodeId) {
                    strcat(pResItem->lpszCaption, "\t&");
                    strncat(pResItem->lpszCaption, (LPCSTR)&pMenuItem->bKeyCodeId, 1 );
                }
            }

            pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(pResItem->lpszCaption), strlen(pResItem->lpszCaption));
            pResItem->dwTypeID = MENU_TYPE;
    		pResItem->dwCodePage = CODEPAGE;
            pResItem->dwSize = wResItemSize;
    		dwSize -= wResItemSize;
		
    		pMenuText = (BYTE*)pMenuText+sizeof(MACMENUITEM)+*pMenuText+1;
            pMenuItem = (PMACMENUITEM)(pMenuText+*pMenuText+1);
            if(!(BYTE)*pMenuText)
                pResItem->dwFlags |= MF_END;
            pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
    	}

    }

	return dwResItemsSize;
}

//=============================================================================
//	ParseMBAR
//
//	
//=============================================================================
UINT ParseMBAR( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	return 0;
}

//=============================================================================
//	ParseSTR
//
//	The STR resource is a plain Pascal string
//=============================================================================
UINT ParseSTR( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	WORD wLen = (WORD)GetPascalStringA( (BYTE**)&lpImageBuf, &szTextBuf[0], (MAX_STR>255?255:MAX_STR), (LONG*)&dwImageSize);
	WORD wResItemSize = sizeof(RESITEM)+wLen;
	if(wResItemSize<=dwSize) {
		LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	
		// Fill the Res Item structure
		memset(pResItem, 0, wResItemSize);

		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(szTextBuf), wLen);
		pResItem->dwSize = wResItemSize;
		pResItem->dwTypeID = STR_TYPE;
		pResItem->dwItemID = 1;
		pResItem->dwCodePage = CODEPAGE;
	}
	return wResItemSize;
}

//=============================================================================
//	ParseSTRNUM
//
//	The STR# is an array of Pascal string
//=============================================================================
UINT ParseSTRNUM( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	UINT uiResItemsSize = 0;
	DWORD dwBufferSize = dwSize;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	WORD wItems = MacWordToWord((BYTE*)lpImageBuf);
	BYTE * pImage = (BYTE*)((BYTE*)lpImageBuf+sizeof(WORD));

	WORD wResItemSize = 0;
	int iCount = 0;

	while(iCount++<wItems)
	{
		BYTE bLen = *((BYTE*)pImage)+1;
		wResItemSize = (WORD)ParseSTR( pImage, bLen, pResItem, dwBufferSize );

		pImage = pImage+bLen;
		uiResItemsSize += wResItemSize;
		if(dwBufferSize>=wResItemSize) {
			dwBufferSize -= wResItemSize;
			pResItem->dwItemID = iCount;
			pResItem->dwTypeID = MSG_TYPE;
			pResItem = (LPRESITEM)((BYTE*)lpBuffer+uiResItemsSize);
		}
		else dwBufferSize = 0;
	}
	return uiResItemsSize;
}

//=============================================================================
//	ParseTEXT
//
//	The TEXT resource is a plain Pascal string
//=============================================================================
UINT ParseTEXT( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	DWORD dwLen = MacLongToLong((BYTE*)lpImageBuf);
	DWORD dwResItemSize = sizeof(RESITEM)+dwLen;
	if(dwResItemSize<=dwSize) {
		LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	
		// Fill the Res Item structure
		memset(pResItem, 0, dwResItemSize);

		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp((char*)lpImageBuf+sizeof(DWORD)), dwLen);
		pResItem->dwSize = dwResItemSize;
		pResItem->dwTypeID = STR_TYPE;
		pResItem->dwItemID = 1;
		pResItem->dwCodePage = CODEPAGE;
	}
	return dwResItemSize;
}

//=============================================================================
//	ParseWDLG
//
//	
//=============================================================================
UINT ParseWDLG( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	// Get the file name
	char * pFileName = (char*)lpImageBuf;
	lpImageBuf = ((BYTE*)lpImageBuf+strlen(pFileName)+1);
	dwImageSize -= strlen(pFileName)+1;

	DWORD dwResItemsSize = 0;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	PMACWDLG pWdlg = (PMACWDLG)lpImageBuf;

	WORD * pWStr = (WORD*)((BYTE*)pWdlg+sizeof(MACWDLG));

	// Check if we have a menu name
	if(*pWStr!=0xffff) {
		// Just skip the string
		while(*pWStr)
			pWStr++;
	}
	else pWStr = pWStr+1;

	// check if we have a class name
	if(*pWStr!=0xffff) {
		// Just skip the string
		while(*pWStr)
			pWStr++;
	}
	else pWStr = pWStr+1;

	// get the caption
	WORD wLen = GetMacWString( &pWStr, &szTextBuf[0], MAX_STR );
	TRACE("\t\t\tWDLG: Caption: %s\n", szTextBuf);
	
	// fill the dialog frame informations
	WORD wResItemSize = sizeof(RESITEM)+wLen+1;
    dwResItemsSize += wResItemSize;
	if(wResItemSize<=dwSize) {
		memset(pResItem, 0, wResItemSize);
		
		// convert the coordinate
		pResItem->wX = MacWordToWord(pWdlg->wX);
		pResItem->wY = MacWordToWord(pWdlg->wY);
		pResItem->wcX = MacWordToWord(pWdlg->wcX);
		pResItem->wcY = MacWordToWord(pWdlg->wcY);
		
		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(szTextBuf), wLen+1);
		
		pResItem->dwStyle = MacLongToLong(pWdlg->dwStyle);
		pResItem->dwExtStyle = MacLongToLong(pWdlg->dwExtStyle);
		pResItem->dwSize = wResItemSize;
		pResItem->dwTypeID = DLOG_TYPE;
		pResItem->dwItemID = 0;
		pResItem->dwCodePage = CODEPAGE;
		dwSize -= wResItemSize;
		
		pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
	}
	
	if(MacLongToLong(pWdlg->dwStyle) & DS_SETFONT) {
		pWStr = pWStr+1;
		GetMacWString( &pWStr, &szTextBuf[0], MAX_STR );
	}
	
	// check the alignment
	pWStr=(WORD*)((BYTE*)pWStr+Pad4((BYTE)((DWORD_PTR)pWStr-(DWORD_PTR)pWdlg)));
		
	// for all the item in the dialog ...
	WORD wItems = MacWordToWord(pWdlg->wNumOfElem);
	WORD wCount = 0;
	WORD wClassID = 0;
	char szClassName[128] = "";
	PMACWDLGI pItem = (PMACWDLGI)pWStr;
	while(wCount<wItems)
	{
		wLen = 0;
		// check if we have a class name
		pWStr = (WORD*)((BYTE*)pItem+sizeof(MACWDLGI));
		if(*pWStr==0xFFFF) {
			wClassID = MacWordToWord((BYTE*)++pWStr);
			szClassName[0] = 0;
			pWStr++;
		}
		else
			wLen += GetMacWString( &pWStr, &szClassName[0], 128 )+1;
		
		// get the caption
		wLen += GetMacWString( &pWStr, &szTextBuf[0], MAX_STR )+1;
		TRACE("\t\t\t\tWDLGI: Caption: %s\n", szTextBuf);

		// Skip the extra stuff
		if(*pWStr) {
			pWStr = (WORD*)((BYTE*)pWStr+*pWStr);
		}
		pWStr = pWStr+1;

		// check the alignment
		pWStr=(WORD*)((BYTE*)pWStr+Pad4((BYTE)((DWORD_PTR)pWStr-(DWORD_PTR)pItem)));
	
		// Fill the ResItem Buffer
		wResItemSize = sizeof(RESITEM)+wLen;
		dwResItemsSize += wResItemSize;
		if(wResItemSize<=dwSize) {
			memset(pResItem, 0, wResItemSize);
			
			// convert the coordinate
			pResItem->wX = MacWordToWord(pItem->wX);
			pResItem->wY = MacWordToWord(pItem->wY);
			pResItem->wcX = MacWordToWord(pItem->wcX);
			pResItem->wcY = MacWordToWord(pItem->wcY);

			pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(szTextBuf), strlen(szTextBuf)+1);
			if(*szClassName)
				pResItem->lpszClassName = (char*)memcpy((BYTE*)pResItem->lpszCaption+strlen(szTextBuf)+1,
					szClassName, strlen(szClassName)+1);	
			
			pResItem->wClassName = wClassID;
			pResItem->dwSize = wResItemSize;
			pResItem->dwTypeID = DLOG_TYPE;
			pResItem->dwItemID = MacWordToWord(pItem->wID);
			pResItem->dwCodePage = CODEPAGE;
			pResItem->dwStyle = MacLongToLong(pItem->dwStyle);
			pResItem->dwExtStyle = MacLongToLong(pItem->dwExtStyle);

			dwSize -= wResItemSize;
			pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
		}

		pItem = (PMACWDLGI)(BYTE*)pWStr;
		wCount++;
	}


	return dwResItemsSize;
}

//=============================================================================
//	ParseDLOG
//
//	
//=============================================================================
UINT ParseDLOG( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	// Get the file name
	char * pFileName = (char*)lpImageBuf;
	lpImageBuf = ((BYTE*)lpImageBuf+strlen(pFileName)+1);
	dwImageSize -= strlen(pFileName)+1;

	DWORD dwResItemsSize = 0;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	PMACDLOG pDlog = (PMACDLOG)lpImageBuf;
	
	// fill the dialog frame informations
	WORD wResItemSize = sizeof(RESITEM)+pDlog->bLenOfTitle+1;
    dwResItemsSize += wResItemSize;
	if(wResItemSize<=dwSize) {
		memset(pResItem, 0, wResItemSize);
		
		// convert the coordinate
		pResItem->wX = MacValToWinVal(pDlog->wLeft);
		pResItem->wY = MacValToWinVal(pDlog->wTop);
		pResItem->wcX = MacValToWinVal(pDlog->wRight) - pResItem->wX;
		pResItem->wcY = MacValToWinVal(pDlog->wBottom) - pResItem->wY;

		// Make up a Style for the dialog
		pResItem->dwStyle = DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION;

		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp((char*)pDlog+sizeof(MACDLOG)), pDlog->bLenOfTitle);
		*(pResItem->lpszCaption+pDlog->bLenOfTitle) = 0;
		pResItem->dwSize = wResItemSize;
		pResItem->dwTypeID = DLOG_TYPE;
		pResItem->dwItemID = 0;
		pResItem->dwCodePage = CODEPAGE;
		dwSize -= wResItemSize;
		pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
	}

	// Find the DITL for this Dialog
	LPSTR pResName = (LPSTR)MacWordToWord(pDlog->wRefIdOfDITL);

	CFile file;
	// Open the file and try to read the information on the resource in it.
    if (!file.Open(pFileName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return LPNULL;
	
	DWORD dwOffsetToDITL = FindMacResource(&file, "DITL", pResName );
	TRACE("\t\t\tParseDLOG:\tItemList %d at offset: %X\n", MacWordToWord(pDlog->wRefIdOfDITL), dwOffsetToDITL );
	if(dwOffsetToDITL) {
		BYTE szSize[4];
		file.Seek(dwOffsetToDITL, CFile::begin);
		file.Read(szSize, 4);
		// Parse the Item List
		LONG lSize = MacLongToLong(szSize);

 		BYTE * pData = (BYTE*)malloc(lSize);
		if(!pData)
			return 0;
		file.Read(pData, lSize);

		dwResItemsSize += ParseDITL( pData, lSize, pResItem, dwSize );

		free(pData);
	}
	
	file.Close();
	return dwResItemsSize;
}

//=============================================================================
//	ParseALRT
//
//	
//=============================================================================
UINT ParseALRT( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	// Get the file name
	char * pFileName = (char*)lpImageBuf;
	lpImageBuf = ((BYTE*)lpImageBuf+strlen(pFileName)+1);
	dwImageSize -= strlen(pFileName)+1;

	DWORD dwResItemsSize = 0;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	PMACALRT pAlrt = (PMACALRT)lpImageBuf;
	
	// fill the dialog frame informations
	WORD wResItemSize = sizeof(RESITEM);
    dwResItemsSize += wResItemSize;
	if(wResItemSize<=dwSize) {
		memset(pResItem, 0, wResItemSize);
		
		// convert the coordinate
		pResItem->wX = MacValToWinVal(pAlrt->wLeft);
		pResItem->wY = MacValToWinVal(pAlrt->wTop);
		pResItem->wcX = MacValToWinVal(pAlrt->wRight) - pResItem->wX;
		pResItem->wcY = MacValToWinVal(pAlrt->wBottom) - pResItem->wY;

		// Make up a Style for the dialog
		pResItem->dwStyle = DS_MODALFRAME | WS_POPUP | WS_VISIBLE;

		pResItem->lpszCaption = LPNULL;	// ALRT don't have a title
		pResItem->dwSize = wResItemSize;
		pResItem->dwTypeID = DLOG_TYPE;
		pResItem->dwItemID = 0;
		pResItem->dwCodePage = CODEPAGE;
		dwSize -= wResItemSize;
		pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
	}

	// Find the DITL for this Dialog
	LPSTR pResName = (LPSTR)MacWordToWord(pAlrt->wRefIdOfDITL);

	CFile file;
	// Open the file and try to read the information on the resource in it.
    if (!file.Open(pFileName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return LPNULL;
	
	DWORD dwOffsetToDITL = FindMacResource(&file, "DITL", pResName );
	TRACE("\t\t\tParseALRT:\tItemList %d at offset: %X\n", MacWordToWord(pAlrt->wRefIdOfDITL), dwOffsetToDITL );
	if(dwOffsetToDITL) {
		BYTE szSize[4];
		file.Seek(dwOffsetToDITL, CFile::begin);
		file.Read(szSize, 4);
		// Parse the Item List
		LONG lSize = MacLongToLong(szSize);

 		BYTE * pData = (BYTE*)malloc(lSize);
		if(!pData)
			return 0;
		file.Read(pData, lSize);

		dwResItemsSize += ParseDITL( pData, lSize, pResItem, dwSize );

		free(pData);
	}
	file.Close();
	return dwResItemsSize;
}

//=============================================================================
//	ParseWIND
//  WIND is the frame window. I simulate this as a dialog itself, even if all
//	the other components will be inside this one.
//=============================================================================
UINT ParseWIND( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	// Get the file name
	char * pFileName = (char*)lpImageBuf;
	lpImageBuf = ((BYTE*)lpImageBuf+strlen(pFileName)+1);
	dwImageSize -= strlen(pFileName)+1;

	DWORD dwResItemsSize = 0;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	PMACWIND pWind = (PMACWIND)lpImageBuf;
	
	// fill the dialog frame informations
	WORD wResItemSize = sizeof(RESITEM)+pWind->bLenOfTitle+1;
    dwResItemsSize += wResItemSize;
	if(wResItemSize<=dwSize) {
		memset(pResItem, 0, wResItemSize);
		
		// convert the coordinate
		pResItem->wX = MacValToWinVal(pWind->wLeft);
		pResItem->wY = MacValToWinVal(pWind->wTop);
		pResItem->wcX = MacValToWinVal(pWind->wRight) - pResItem->wX;
		pResItem->wcY = MacValToWinVal(pWind->wBottom) - pResItem->wY;

		// Make up a Style for the dialog
		pResItem->dwStyle = DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION;

		pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp((char*)pWind+sizeof(MACWIND)), pWind->bLenOfTitle);
		*(pResItem->lpszCaption+pWind->bLenOfTitle) = 0;
		pResItem->dwSize = wResItemSize;
		pResItem->dwTypeID = STR_TYPE;  // even if is marked as a WIND_TYPE, mark it a s STR here.
		pResItem->dwItemID = 0;
		pResItem->dwCodePage = CODEPAGE;
		dwSize -= wResItemSize;
		pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
	}

	return dwResItemsSize;
}

//=============================================================================
//	ParseDITL
//
//	
//=============================================================================
UINT ParseDITL( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize )
{
	BYTE bDataLen = 0;
	LPRESITEM pResItem = (LPRESITEM)lpBuffer;
	WORD wItems = MacWordToWord(((BYTE*)lpImageBuf))+1;
	WORD wCount = 1;
	PMACDIT pDitem = (PMACDIT)((BYTE*)lpImageBuf+sizeof(WORD));
	BYTE * pData = (BYTE*)pDitem+sizeof(MACDIT);
	dwImageSize -= sizeof(WORD);
	WORD wResItemSize = 0;
	DWORD dwResItemsSize = 0;

	while(wItems--)
	{
		if((bDataLen = pDitem->bSizeOfDataType) % 2)
			bDataLen++;

		switch((pDitem->bType | 128) - 128)
		{
			case 4:		//button
			case 5: 	//checkbox
			case 6: 	//radio button
			case 8: 	//static text
			case 16: 	//edit text
				memcpy(szTextBuf, pData, pDitem->bSizeOfDataType);
				szTextBuf[pDitem->bSizeOfDataType] = 0;
				wResItemSize = sizeof(RESITEM)+pDitem->bSizeOfDataType+1;
			break;
			case 32: 	//icon
			case 64: 	//quick draw
			default:
				szTextBuf[0] = 0;
				wResItemSize = sizeof(RESITEM)+1;
			break;
		}

		// Fill the ResItem Buffer
		dwResItemsSize += wResItemSize;
		if(wResItemSize<=dwSize) {
			memset(pResItem, 0, wResItemSize);
			
			pResItem->dwStyle = WS_CHILD | WS_VISIBLE;

			// set the correct flag
			switch((pDitem->bType | 128) - 128)
			{
				case 0: 	//user defined
					pResItem->wClassName = 0x82;
					pResItem->dwStyle |= SS_GRAYRECT;
				break;
				case 4:		//button
					pResItem->wClassName = 0x80;
				break;
				case 5: 	//checkbox
					pResItem->wClassName = 0x80;
					pResItem->dwStyle |= BS_AUTOCHECKBOX;
				break;
				case 6: 	//radio button
					pResItem->wClassName = 0x80;
					pResItem->dwStyle |= BS_AUTORADIOBUTTON;
				break;
				case 8: 	//static text
					pResItem->wClassName = 0x82;
				break;
				case 16: 	//edit text
					pResItem->wClassName = 0x81;
					pResItem->dwStyle |= ES_AUTOHSCROLL | WS_BORDER;
				break;
				case 32: 	//icon
					pResItem->wClassName = 0x82;
					pResItem->dwStyle |= SS_ICON;
				break;
				case 64: 	//picture
					pResItem->wClassName = 0x82;
					pResItem->dwStyle |= SS_BLACKRECT;
				break;
				default:
				break;
			}
				
			// convert the coordinate
			pResItem->wX = MacValToWinVal(pDitem->wLeft);
			pResItem->wY = MacValToWinVal(pDitem->wTop);
			pResItem->wcX = MacValToWinVal(pDitem->wRight) - pResItem->wX;
			pResItem->wcY = MacValToWinVal(pDitem->wBottom) - pResItem->wY;

			pResItem->lpszCaption = (char*)memcpy((BYTE*)pResItem+sizeof(RESITEM), MacCpToAnsiCp(szTextBuf), strlen(szTextBuf)+1);
			pResItem->dwSize = wResItemSize;
			pResItem->dwTypeID = DLOG_TYPE;
			pResItem->dwItemID = wCount++;
			pResItem->dwCodePage = CODEPAGE;
			dwSize -= wResItemSize;

			pResItem = (LPRESITEM)((BYTE*)lpBuffer+dwResItemsSize);
		}

		
		TRACE("\t\t\tDITL: #%d Type: %d (%d)\tLen: %d\tStr: %s\n", wCount-1,pDitem->bType, ((pDitem->bType | 128) - 128), pDitem->bSizeOfDataType, szTextBuf);

		dwImageSize -= sizeof(MACDIT)+bDataLen;
		pDitem = (PMACDIT)((BYTE*)pDitem+sizeof(MACDIT)+bDataLen);
		pData = (BYTE*)pDitem+sizeof(MACDIT);
	}

	return dwResItemsSize;
}


//=============================================================================
//=============================================================================
//
// Updating functions
//
//=============================================================================
//=============================================================================

//=============================================================================
//	UpdateMENU
//
//=============================================================================
UINT UpdateMENU( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    PMACMENU pMenu = (PMACMENU)((BYTE*)lpOldImage+wLen);
    BYTE* pMenuText = (BYTE*)pMenu+sizeof(MACMENU)+pMenu->bSizeOfTitle;
    LPRESITEM pResItem = (LPRESITEM)lpNewBuf;

    // check if is the apple menu
    if(pMenu->bSizeOfTitle==1 && *((BYTE*)&pMenu->bSizeOfTitle+1)==appleMark)
    {
        // write the MENU image
        if(!MemCopy( lpNewImage, pMenu, sizeof(MACMENU)+pMenu->bSizeOfTitle, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= sizeof(MACMENU)+pMenu->bSizeOfTitle;
            lpNewImage = (BYTE*)lpNewImage + sizeof(MACMENU)+pMenu->bSizeOfTitle;
        }
        lNewSize += sizeof(MACMENU)+pMenu->bSizeOfTitle;
    }
    else {

        // update caption size
        wLen = strlen(AnsiCpToMacCp(pResItem->lpszCaption));
        pMenu->bSizeOfTitle = LOBYTE(wLen);

        // write the MENU image
        if(!MemCopy( lpNewImage, pMenu, sizeof(MACMENU), dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= sizeof(MACMENU);
            lpNewImage = (BYTE*)lpNewImage + sizeof(MACMENU);
        }
        lNewSize += sizeof(MACMENU);

        // ... string ...
        if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pResItem->lpszCaption), wLen, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
        lNewSize += wLen;
    }

    // and now update the menu items
    PMACMENUITEM pMenuItem = (PMACMENUITEM)(pMenuText+*pMenuText+1);
    pResItem = (LPRESITEM)((BYTE*)pResItem+pResItem->dwSize);
    while((BYTE)*pMenuText)
    {
        // update caption size
        wLen = strlen(AnsiCpToMacCp(pResItem->lpszCaption));

        // check if is a separator
        if(*pMenuText==1 && *(pMenuText+1)=='-') {
            wLen = 1;
            *pResItem->lpszCaption = '-';
        }

        // check if the menu has an Hotkey
        if(pMenuItem->bKeyCodeId) {
            pMenuItem->bKeyCodeId = *(pResItem->lpszCaption+wLen-1);
            *(pResItem->lpszCaption+wLen-3)='\0';
            wLen -=3;
        }

        // ... size of the string ...
        if(!MemCopy( lpNewImage, &wLen, sizeof(BYTE), dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= sizeof(BYTE);
            lpNewImage = (BYTE*)lpNewImage + sizeof(BYTE);
        }
        lNewSize += sizeof(BYTE);

        // ... string ...
        if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pResItem->lpszCaption), wLen, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
        lNewSize += wLen;

        // write the MENU ITEM image
        if(!MemCopy( lpNewImage, pMenuItem, sizeof(MACMENUITEM), dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= sizeof(MACMENUITEM);
            lpNewImage = (BYTE*)lpNewImage + sizeof(MACMENUITEM);
        }
        lNewSize += sizeof(MACMENUITEM);


		pMenuText = (BYTE*)pMenuText+sizeof(MACMENUITEM)+*pMenuText+1;
        pMenuItem = (PMACMENUITEM)(pMenuText+*pMenuText+1);
        pResItem = (LPRESITEM)((BYTE*)pResItem+pResItem->dwSize);
    }


    // add the null at the end of the menu
    wLen = 0;

    // ... menu termination ...
    if(!MemCopy( lpNewImage, &wLen, sizeof(BYTE), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(BYTE);
        lpNewImage = (BYTE*)lpNewImage + sizeof(BYTE);
    }
    lNewSize += sizeof(BYTE);

    *pdwNewImageSize = lNewSize;

    return 0;
}

//=============================================================================
//	UpdateSTR
//
//  Plain old Pascal string
//=============================================================================
UINT UpdateSTR( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    // Update the string
    PRESITEM pItem = (PRESITEM)lpNewBuf;
    wLen = strlen(AnsiCpToMacCp(pItem->lpszCaption));
    // ... size ...
    if(!MemCopy( lpNewImage, &wLen, sizeof(BYTE), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(BYTE);
        lpNewImage = (BYTE*)lpNewImage + sizeof(BYTE);
    }
    // ... string ...
    if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pItem->lpszCaption), wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }

    lNewSize += wLen+sizeof(BYTE);

    *pdwNewImageSize = lNewSize;

    return 0;
}

//=============================================================================
//	UpdateSTRNUM
//
//  Array of pascal strings.
//=============================================================================
UINT UpdateSTRNUM( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    LONG lItemsBuf = dwNewSize;
    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;


    // save space for the number of strings
    WORD wItems = 0;
    BYTE * pNumOfItems = LPNULL;
    if(!MemCopy( lpNewImage, &wItems, sizeof(WORD), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(WORD);
        pNumOfItems = (BYTE*)lpNewImage;
        lpNewImage = (BYTE*)lpNewImage + sizeof(WORD);
    }
    lNewSize += sizeof(WORD);

    PRESITEM pItem = (PRESITEM)lpNewBuf;
    while(lItemsBuf)
    {
        wItems++;

        // Update the string
        wLen = strlen(AnsiCpToMacCp(pItem->lpszCaption));
        // ... size ...
        if(!MemCopy( lpNewImage, &wLen, sizeof(BYTE), dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= sizeof(BYTE);
            lpNewImage = (BYTE*)lpNewImage + sizeof(BYTE);
        }
        // ... string ...
        if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pItem->lpszCaption), wLen, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }

        lNewSize += wLen+sizeof(BYTE);
        lItemsBuf -= pItem->dwSize;
        pItem = (PRESITEM)((BYTE*)pItem+pItem->dwSize);

    }

    // fix up number of items
    if(pNumOfItems)
        memcpy(pNumOfItems, WordToMacWord(wItems), sizeof(WORD));

    *pdwNewImageSize = lNewSize;

    return 0;
}

UINT UpdateWDLG( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
	DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    DWORD dwItemsSize = dwNewSize;
    char * pFileName = (char*)lpOldImage;

    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

	// Update the DLOG first....
    PMACWDLG pWdlg = (PMACWDLG)((BYTE*)lpOldImage+wLen);
    LPRESITEM pResItem = (LPRESITEM)lpNewBuf;

    // Update coordinates
    memcpy(pWdlg->wY,WinValToMacVal(pResItem->wY), sizeof(WORD));
    memcpy(pWdlg->wX,WinValToMacVal(pResItem->wX), sizeof(WORD));
    memcpy(pWdlg->wcY,WinValToMacVal(pResItem->wcY), sizeof(WORD));
    memcpy(pWdlg->wcX,WinValToMacVal(pResItem->wcX), sizeof(WORD));

    // write the DLOG image
    if(!MemCopy( lpNewImage, pWdlg, sizeof(MACWDLG), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(MACWDLG);
        lpNewImage = (BYTE*)lpNewImage + sizeof(MACWDLG);
    }
    lNewSize += sizeof(MACWDLG);

    WORD * pWStr = (WORD*)((BYTE*)pWdlg+sizeof(MACWDLG));
    wLen = 0;
    // ...copy the menu name
    if(*pWStr!=0xffff) {
        wLen = 1;
        WORD * pWOld = pWStr;
        while(*(pWStr++))
            wLen++;

        wLen = wLen*sizeof(WORD);

        if(wLen>=dwNewImageSize)
        {
            memcpy(lpNewImage, pWOld, wLen);
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
    } else {
        wLen = sizeof(WORD)*2;
        if(wLen>=dwNewImageSize)
        {
            memcpy(lpNewImage, pWStr, wLen);
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
            pWStr+=wLen;
        }
    }

    // ...copy the class name
    if(*pWStr!=0xffff) {
        wLen = 1;
        WORD * pWOld = pWStr;
        while(*(pWStr++))
            wLen++;

        wLen = wLen*sizeof(WORD);

        if(wLen>=dwNewImageSize)
        {
            memcpy(lpNewImage, pWOld, wLen);
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
    } else {
        wLen = sizeof(WORD)*2;
        if(wLen>=dwNewImageSize)
        {
            memcpy(lpNewImage, pWStr, wLen);
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
            pWStr+=wLen;
        }
    }

    // convert the string back to "Mac WCHAR".
    wLen = PutMacWString(&szWTextBuf[0], (char*)AnsiCpToMacCp(pResItem->lpszCaption), MAX_STR);

    // ... string ...
    if(!MemCopy( lpNewImage, &szWTextBuf[0], wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    // ... skip the caption from the old image ...
    wLen = GetMacWString( &pWStr, &szTextBuf[0], MAX_STR );

    // ... copy the fonts info
    if(MacLongToLong(pWdlg->dwStyle) & DS_SETFONT) {
        wLen = sizeof(WORD);
        if(!MemCopy( lpNewImage, pWStr, wLen, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
        lNewSize += wLen;

        pWStr = pWStr+1;

		GetMacWString( &pWStr, &szTextBuf[0], MAX_STR );
        wLen = PutMacWString(&szWTextBuf[0],  &szTextBuf[0], MAX_STR);

        // ... string ...
        if(!MemCopy( lpNewImage, &szWTextBuf[0], wLen, dwNewImageSize)) {
            dwNewImageSize = 0;
        } else {
            dwNewImageSize -= wLen;
            lpNewImage = (BYTE*)lpNewImage + wLen;
        }
        lNewSize += wLen;
	}
	
	// check the alignment
	pWStr=(WORD*)((BYTE*)pWStr+Pad4((BYTE)((DWORD_PTR)pWStr-(DWORD_PTR)pWdlg)));

    *pdwNewImageSize = lNewSize;



	return 0;
}


//=============================================================================
//	UpdateDLOG
//
//  We will have to update the DITL as well as the DLOG
//  The Mac Dialog have an ID of a DITL for each dialog. In the DITL there
//  are the info on the Items in the dialog. The DLOG hold only the size of
//  the frame and the title of the dialog
//
//=============================================================================
UINT UpdateDLOG( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    DWORD dwItemsSize = dwNewSize;
    char * pFileName = (char*)lpOldImage;

    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    // Update the DLOG first....
    PMACDLOG pDlog = (PMACDLOG)((BYTE*)lpOldImage+wLen);
    LPRESITEM pResItem = (LPRESITEM)lpNewBuf;

    // Update coordinates
    memcpy(pDlog->wTop,WinValToMacVal(pResItem->wY), sizeof(WORD));
    memcpy(pDlog->wLeft,WinValToMacVal(pResItem->wX), sizeof(WORD));
    memcpy(pDlog->wBottom,WinValToMacVal(pResItem->wY+pResItem->wcY), sizeof(WORD));
    memcpy(pDlog->wRight,WinValToMacVal(pResItem->wX+pResItem->wcX), sizeof(WORD));

    // update caption size
    wLen = strlen(AnsiCpToMacCp(pResItem->lpszCaption));
    pDlog->bLenOfTitle = LOBYTE(wLen);

    // write the DLOG image
    if(!MemCopy( lpNewImage, pDlog, sizeof(MACDLOG), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(MACDLOG);
        lpNewImage = (BYTE*)lpNewImage + sizeof(MACDLOG);
    }
    lNewSize += sizeof(MACDLOG);

    // ... string ...
    if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pResItem->lpszCaption), wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    *pdwNewImageSize = lNewSize;

    // and now update the DITL
    dwItemsSize -= pResItem->dwSize;
    pResItem = (LPRESITEM)((BYTE*)pResItem+pResItem->dwSize);

    if(!InitIODLLLink())
        return ERROR_DLL_LOAD;

    // Find the DITL for this Dialog
	LPSTR pResName = (LPSTR)MacWordToWord(pDlog->wRefIdOfDITL);

    // Get the image from the iodll
    HANDLE hResFile = (*g_lpfnHandleFromName)(pFileName);
    DWORD dwImageSize = (*g_lpfnGetImage)(  hResFile, (LPSTR)DITL_TYPE, pResName, 0, NULL, 0);

    if(dwImageSize)
    {
        BYTE * pOldData = (BYTE*)malloc(dwImageSize);
		if(!pOldData)
			return 0;

        DWORD dwNewSize = dwImageSize*2;
        BYTE * pNewData = (BYTE*)malloc(dwNewSize);
		if(!pNewData)
			return 0;

		(*g_lpfnGetImage)(  hResFile, (LPSTR)DITL_TYPE, pResName, 0, pOldData, dwImageSize);

		UpdateDITL( pResItem, dwItemsSize, pOldData, dwImageSize, pNewData, &dwNewSize );

		// Update the data in the IODLL
        (*g_lpfnUpdateResImage)(hResFile, (LPSTR)DITL_TYPE, pResName, 0, -1, pNewData, dwNewSize);

        free(pOldData);
        free(pNewData);
    }

    return 0;
}

//=============================================================================
//	UpdateALRT
//
//=============================================================================
UINT UpdateALRT( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    DWORD dwItemsSize = dwNewSize;
    char * pFileName = (char*)lpOldImage;

    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    // Update the ALRT first....
    PMACALRT pAlrt = (PMACALRT)((BYTE*)lpOldImage+wLen);
    LPRESITEM pResItem = (LPRESITEM)lpNewBuf;

    // Update coordinates
    memcpy(pAlrt->wTop,WinValToMacVal(pResItem->wY), sizeof(WORD));
    memcpy(pAlrt->wLeft,WinValToMacVal(pResItem->wX), sizeof(WORD));
    memcpy(pAlrt->wBottom,WinValToMacVal(pResItem->wY+pResItem->wcY), sizeof(WORD));
    memcpy(pAlrt->wRight,WinValToMacVal(pResItem->wX+pResItem->wcX), sizeof(WORD));

    // write the ALRT image
    if(!MemCopy( lpNewImage, pAlrt, sizeof(MACALRT), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(MACALRT);
        lpNewImage = (BYTE*)lpNewImage + sizeof(MACALRT);
    }
    lNewSize += sizeof(MACALRT);

    *pdwNewImageSize = lNewSize;

    // and now update the DITL
    dwItemsSize -= pResItem->dwSize;
    pResItem = (LPRESITEM)((BYTE*)pResItem+pResItem->dwSize);

    if(!InitIODLLLink())
        return ERROR_DLL_LOAD;

    // Find the DITL for this Dialog
	LPSTR pResName = (LPSTR)MacWordToWord(pAlrt->wRefIdOfDITL);

    // Get the image from the iodll
    HANDLE hResFile = (*g_lpfnHandleFromName)(pFileName);
    DWORD dwImageSize = (*g_lpfnGetImage)(  hResFile, (LPSTR)DITL_TYPE, pResName, 0, NULL, 0);

    if(dwImageSize)
    {
        BYTE * pOldData = (BYTE*)malloc(dwImageSize);
		if(!pOldData)
			return 0;

        DWORD dwNewSize = dwImageSize*2;
        BYTE * pNewData = (BYTE*)malloc(dwNewSize);
		if(!pNewData)
			return 0;

		(*g_lpfnGetImage)(  hResFile, (LPSTR)DITL_TYPE, pResName, 0, pOldData, dwImageSize);

		UpdateDITL( pResItem, dwItemsSize, pOldData, dwImageSize, pNewData, &dwNewSize );

		// Update the data in the IODLL
        (*g_lpfnUpdateResImage)(hResFile, (LPSTR)DITL_TYPE, pResName, 0, -1, pNewData, dwNewSize);

        free(pOldData);
        free(pNewData);
    }

    return 0;
}

//=============================================================================
//	UpdateWIND
//
//
//=============================================================================
UINT UpdateWIND( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    DWORD dwNewImageSize = *pdwNewImageSize;
    LONG lNewSize = 0;
    DWORD dwItemsSize = dwNewSize;
    char * pFileName = (char*)lpOldImage;

    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    PMACWIND pWind = (PMACWIND)((BYTE*)lpOldImage+wLen);
    LPRESITEM pResItem = (LPRESITEM)lpNewBuf;

    // Update coordinates
    memcpy(pWind->wTop,WinValToMacVal(pResItem->wY), sizeof(WORD));
    memcpy(pWind->wLeft,WinValToMacVal(pResItem->wX), sizeof(WORD));
    memcpy(pWind->wBottom,WinValToMacVal(pResItem->wY+pResItem->wcY), sizeof(WORD));
    memcpy(pWind->wRight,WinValToMacVal(pResItem->wX+pResItem->wcX), sizeof(WORD));

    // update caption size
    wLen = strlen(AnsiCpToMacCp(pResItem->lpszCaption));
    pWind->bLenOfTitle = LOBYTE(wLen);

    // write the DLOG image
    if(!MemCopy( lpNewImage, pWind, sizeof(MACWIND), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(MACWIND);
        lpNewImage = (BYTE*)lpNewImage + sizeof(MACWIND);
    }
    lNewSize += sizeof(MACWIND);

    // ... string ...
    if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pResItem->lpszCaption), wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    *pdwNewImageSize = lNewSize;

    return 0;
}

//=============================================================================
//	UpdateDITL
//
//
//=============================================================================
UINT UpdateDITL( LPVOID lpNewBuf, DWORD dwNewSize,
    LPVOID lpOldImage, DWORD dwOldImageSize, LPVOID lpNewImage, DWORD * pdwNewImageSize )
{
    LONG lNewSize = 0;
    LONG lItemsBuf = dwNewSize;
    DWORD dwNewImageSize = *pdwNewImageSize;
    BYTE bDataLen = 0;

    // Copy the name to the new image
    WORD wLen = strlen((char*)lpOldImage)+1;
    if(!MemCopy( lpNewImage, lpOldImage, wLen, dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= wLen;
        lpNewImage = (BYTE*)lpNewImage + wLen;
    }
    lNewSize += wLen;

    // save space for the number of items
    WORD wItems = 0;
    BYTE * pNumOfItems = LPNULL;
    if(!MemCopy( lpNewImage, &wItems, sizeof(WORD), dwNewImageSize)) {
        dwNewImageSize = 0;
    } else {
        dwNewImageSize -= sizeof(WORD);
        pNumOfItems = (BYTE*)lpNewImage;
        lpNewImage = (BYTE*)lpNewImage + sizeof(WORD);
    }
    lNewSize += sizeof(WORD);

    PRESITEM pResItem = (PRESITEM)lpNewBuf;
    PMACDIT pDitem = (PMACDIT)((BYTE*)lpOldImage+wLen+sizeof(WORD));
    while(lItemsBuf)
    {
        wItems++;

        if((bDataLen = pDitem->bSizeOfDataType) % 2)
			bDataLen++;

        // Update coordinates
        memcpy(pDitem->wTop,WinValToMacVal(pResItem->wY), sizeof(WORD));
        memcpy(pDitem->wLeft,WinValToMacVal(pResItem->wX), sizeof(WORD));
        memcpy(pDitem->wBottom,WinValToMacVal(pResItem->wY+pResItem->wcY), sizeof(WORD));
        memcpy(pDitem->wRight,WinValToMacVal(pResItem->wX+pResItem->wcX), sizeof(WORD));

        switch((pDitem->bType | 128) - 128)
		{
			case 4:		//button
			case 5: 	//checkbox
			case 6: 	//radio button
			case 8: 	//static text
			case 16: 	//edit text
				// update caption size
                wLen = strlen(AnsiCpToMacCp(pResItem->lpszCaption));
                pDitem->bSizeOfDataType = LOBYTE(wLen);

                // write the DIT image
                if(!MemCopy( lpNewImage, pDitem, sizeof(MACDIT), dwNewImageSize)) {
                    dwNewImageSize = 0;
                } else {
                    dwNewImageSize -= sizeof(MACDIT);
                    lpNewImage = (BYTE*)lpNewImage + sizeof(MACDIT);
                }
                lNewSize += sizeof(MACDIT);

                // ... string ...
                if(!MemCopy( lpNewImage, (void*)AnsiCpToMacCp(pResItem->lpszCaption), wLen, dwNewImageSize)) {
                    dwNewImageSize = 0;
                } else {
                    dwNewImageSize -= wLen;
                    lpNewImage = (BYTE*)lpNewImage + wLen;
                }
                lNewSize += wLen;

                if(pDitem->bSizeOfDataType % 2) {
                    BYTE b = 0;
			        if(!MemCopy( lpNewImage, &b, 1, dwNewImageSize)) {
                        dwNewImageSize = 0;
                    } else {
                        dwNewImageSize -= wLen;
                        lpNewImage = (BYTE*)lpNewImage + 1;
                    }
                    lNewSize += 1;
                }
			break;
			case 32: 	//icon
			case 64: 	//quick draw
			default:
                wLen = sizeof(MACDIT)+pDitem->bSizeOfDataType;
                if(!MemCopy( lpNewImage, pDitem, wLen, dwNewImageSize)) {
                    dwNewImageSize = 0;
                } else {
                    dwNewImageSize -= wLen;
                    lpNewImage = (BYTE*)lpNewImage + wLen ;
                }
                lNewSize += wLen;

                if(pDitem->bSizeOfDataType % 2) {
                    BYTE b = 0;
			        if(!MemCopy( lpNewImage, &b, 1, dwNewImageSize)) {
                        dwNewImageSize = 0;
                    } else {
                        dwNewImageSize -= wLen;
                        lpNewImage = (BYTE*)lpNewImage + 1;
                    }
                    lNewSize += 1;
                }
			break;
		}

        lItemsBuf -= pResItem->dwSize;
        pResItem = (PRESITEM)((BYTE*)pResItem+pResItem->dwSize);
        pDitem = (PMACDIT)((BYTE*)pDitem+sizeof(MACDIT)+bDataLen);

    }

    // fix up number of items
    if(pNumOfItems)
        memcpy(pNumOfItems, WordToMacWord(wItems-1), sizeof(WORD));

    *pdwNewImageSize = lNewSize;
    return 0;
}

//=============================================================================
//=============================================================================
//
// General helper functions
//
//=============================================================================
//=============================================================================

WORD GetMacWString( WORD ** pWStr, char * pStr, int iMaxLen)
{
	WORD wLen = 0;
	while(**pWStr && wLen<iMaxLen)
	{
		if(LOBYTE(**pWStr)) {
			// This is a DBCS String
			TRACE("WARNING ******** WARNING ******** WARNING ******** WARNING ********\n");
			TRACE("DBCS string in the MAC file not supported yet\n");
			TRACE("WARNING ******** WARNING ******** WARNING ******** WARNING ********\n");
			return 0;	// This is a DBCS String
		}

		*pStr++ = HIBYTE(*(*pWStr)++);
		wLen ++;
	}
	*pStr = HIBYTE(*(*pWStr)++);
	return wLen;
}

WORD PutMacWString( WORD * pWStr, char * pStr, int iMaxLen)
{
	WORD wLen = 0;
	while(*pStr && wLen<iMaxLen)
	{
		*(pWStr++) = *(pStr++);
		wLen ++;
	}
	*(pWStr++) = *(pStr++);
	return wLen;
}

static BYTE b[4];       // used as a buffer for the conversion utils

BYTE * WordToMacWord(WORD w)
{
    BYTE *pw = (BYTE *) &w;		
    BYTE *p = (BYTE *) &b[0];
								
    pw += 1;						
    *p++ = *pw--;				
    *p = *pw;					
								
    return &b[0];
}								

BYTE * LongToMacLong(LONG l)
{
    BYTE *pl = (BYTE *) &l;		
    BYTE *p = (BYTE *) &b[0];
								
    pl += 3;						
    *p++ = *pl--;				
    *p++ = *pl--;				
    *p++ = *pl--;				
    *p = *pl;					
								
    return &b[0];
}								

BYTE * LongToMacOffset(LONG l)
{
    BYTE *pl = (BYTE *) &l;		
    BYTE *p = (BYTE *) &b[0];
								
    pl += 2;						
    *p++ = *pl--;				
    *p++ = *pl--;				
    *p = *pl;					
								
    return &b[0];
}								

BYTE * WinValToMacVal(WORD w)
{
	return WordToMacWord((WORD)(w / COORDINATE_FACTOR));
}

//=============================================================================
// Created a list of updated resource. This list will be used in the
// IsResUpdated funtion to detect if the resource has been updated.

PUPDATEDRESLIST UpdatedResList( LPVOID lpBuf, UINT uiSize )
{
    if(!uiSize)
        return LPNULL;

    BYTE * pUpd = (BYTE*)lpBuf;
    PUPDATEDRESLIST pListHead = (PUPDATEDRESLIST)malloc(uiSize*3);   // this should be enough in all cases
    if(!pListHead)
        return LPNULL;
    memset(pListHead, 0, uiSize*3);

    PUPDATEDRESLIST pList = pListHead;
    BYTE bPad = 0;
    WORD wSize = 0;
    while(uiSize>0) {
        pList->pTypeId = (WORD*)pUpd;
        pList->pTypeName = (BYTE*)pList->pTypeId+sizeof(WORD);
        // check the allignement
        bPad = strlen((LPSTR)pList->pTypeName)+1+sizeof(WORD);
        bPad += Pad4(bPad);
        wSize = bPad;
        pList->pResId = (WORD*)((BYTE*)pUpd+bPad);
        pList->pResName = (BYTE*)pList->pResId+sizeof(WORD);
        bPad = strlen((LPSTR)pList->pResName)+1+sizeof(WORD);
        bPad += Pad4(bPad);
        wSize += bPad;
        pList->pLang = (DWORD*)((BYTE*)pList->pResId+bPad);
        pList->pSize = (DWORD*)((BYTE*)pList->pLang+sizeof(DWORD));
        pList->pNext = (PUPDATEDRESLIST)pList+1;
        wSize += sizeof(DWORD)*2;
        pUpd = pUpd+wSize;
        uiSize -= wSize;
        if(!uiSize)
            pList->pNext = LPNULL;
        else
            pList++;
    }

    return pListHead;
}

PUPDATEDRESLIST IsResUpdated( BYTE* pTypeName, MACRESREFLIST reflist, PUPDATEDRESLIST pList)
{
    if(!pList)
        return LPNULL;

    PUPDATEDRESLIST pLast = pList;
    while(pList)
    {
        if(!strcmp((LPSTR)pList->pTypeName, (LPSTR)pTypeName)) {
            if(MacWordToWord(reflist.mwResID)==*pList->pResId) {
                pLast->pNext = pList->pNext;
                return pList;
            }
        }
        pLast = pList;
        pList = pList->pNext;
    }

    return LPNULL;
}

//=============================================================================
//=============================================================================
//
// Mac to ANSI and back conversion
//
//=============================================================================
//=============================================================================

#define MAXWSTR 8192
static WCHAR szwstr[MAXWSTR];
static CHAR szstr[MAXWSTR];

LPCSTR MacCpToAnsiCp(LPCSTR str)
{
    WORD wLen = strlen(str);
    LPWSTR pwstr = &szwstr[0];
    LPSTR pstr = &szstr[0];

    if(wLen==0)
    //if(1)
        return str;

    if(wLen>MAXWSTR)
    {
        TRACE("MacCpToAnsiCp. String too long. Buffer need to be increased!");
        return NULL;
    }

    // Convert the mac string in to an ANSI wchar
    if(!MultiByteToWideChar(CP_MACCP, MB_PRECOMPOSED | MB_USEGLYPHCHARS, str, wLen, pwstr, MAXWSTR))
    {
        TRACE("MacCpToAnsiCp. MultiByteToWideChar(...) failed.");
        return NULL;
    }
    *(pwstr+wLen) = 0x0000;

    // Convert the WideChar string in to an ANSI CP
    if(!WideCharToMultiByte(CP_ACP, 0, pwstr, MAXWSTR, pstr, MAXWSTR, NULL, NULL))
    {
        TRACE("MacCpToAnsiCp. WideCharToMultiByte(...) failed.");
        return NULL;
    }

    return pstr;
}

LPCSTR AnsiCpToMacCp(LPCSTR str)
{
    WORD wLen = strlen(str);
    LPWSTR pwstr = &szwstr[0];
    LPSTR pstr = &szstr[0];

    if(wLen==0)
        return str;

    if(wLen>MAXWSTR)
    {
        TRACE("AnsiCpToMacCp. String too long. Buffer need to be increased!");
        return NULL;
    }

    // Convert the ANSI string in to a Mac wchar
    if(!MultiByteToWideChar(CP_ACP, 0, str, wLen, pwstr, MAXWSTR))
    {
        TRACE("AnsiCpToMacCp. MultiByteToWideChar(...) failed.");
        return NULL;
    }

    *(pwstr+wLen) = 0x0000;

    // Convert the WideChar string in to an ANSI CP
    if(!WideCharToMultiByte(CP_MACCP, 0, pwstr, MAXWSTR, pstr, MAXWSTR, NULL, NULL))
    {
        TRACE("AnsiCpToMacCp. WideCharToMultiByte(...) failed.");
        return NULL;
    }

    return pstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\inf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\common\rwdll.h ===
//+---------------------------------------------------------------------------
//
//  File:               rwdll.h
//
//  Contents:   Declarations for the reader/writer DLL
//
//  Classes:    none
//
//  History:    31-May-93   alessanm    created
//
//----------------------------------------------------------------------------
#ifndef _RWDLL_H_
#define _RWDLL_H_

//////////////////////////////////////////////////////////////////////////////
// Type declaration, common to all the module in the Reader/Writer
//////////////////////////////////////////////////////////////////////////////
#include <iodll.h>

#define DllExport

//[registration]                                    
extern "C"
DllExport
BOOL
APIENTRY
RWGetTypeString(
	LPSTR lpszTypeName);

extern "C"
DllExport
BOOL
APIENTRY 
RWValidateFileType(
	LPCSTR pszFileName);
	
extern "C"
DllExport
UINT
APIENTRY 
RWReadTypeInfo(
	LPCSTR  lpszFilename,
	LPVOID  lpBuffer,
	UINT*   puiSize
	);      

//[Reading / writing file]
extern "C"
DllExport
DWORD
APIENTRY 
RWGetImage(
	LPCSTR  lpszFilename,
	DWORD   dwImageOffset,
	LPVOID  lpBuffer,
	DWORD   dwSize
	);

extern"C"
DllExport
UINT  
APIENTRY 
RWWriteFile(
	LPCSTR  lpszSrcFilename,
	LPCSTR  lpszTgtFilename,
	HANDLE  hResFileModule,
	LPVOID  lpBuffer,
	UINT    uiSize,
	HINSTANCE   hDllInst,
    LPCSTR  lpszSymbolPath
	);
	
// [Parsing]
extern "C"
DllExport
UINT
APIENTRY 
RWParseImage(
	LPCSTR  lpszType,
	LPVOID  lpImageBuf,
	DWORD   dwImageSize,
	LPVOID  lpBuffer,
	DWORD   dwSize
	);

extern "C"
DllExport
UINT
APIENTRY 
RWParseImageEx(
	LPCSTR  lpszType,
    LPCSTR  lpszResId,
	LPVOID  lpImageBuf,
	DWORD   dwImageSize,
	LPVOID  lpBuffer,
	DWORD   dwSize,
    LPCSTR  lpRCFilename
	);


extern "C"
DllExport
UINT
APIENTRY 
RWUpdateImage(
	LPCSTR  lpszType,
	LPVOID  lpNewBuf,
	DWORD   dwNewSize,
	LPVOID  lpOldImage,
	DWORD   dwOldImageSize,
	LPVOID  lpNewImage,
	DWORD*  pdwNewImageSize
	);

extern "C"
DllExport
UINT
APIENTRY 
RWUpdateImageEx(
	LPCSTR  lpszType,
	LPVOID  lpNewBuf,
	DWORD   dwNewSize,
	LPVOID  lpOldImage,
	DWORD   dwOldImageSize,
	LPVOID  lpNewImage,
	DWORD*  pdwNewImageSize,
    LPCSTR  lpRCFilename
	);

#endif   // _RWDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\common\rw32hlpr.h ===
/////////////////////////////////////////////////////////////////////////////
// Helper Function Declarations for res32/win32 r/w
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define Pad4(x) ((((x+3)>>2)<<2)-x)
#define PadPtr(x) ((((x+(sizeof(PVOID)-1))/sizeof(PVOID))*sizeof(PVOID))-x)
#define Pad16(x) ((((x+15)>>4)<<4)-x)

#define MAXSTR 8192
#define LPNULL 0L
#define MAXLEVELS 3
#define MFR_POPUP (MF_POPUP > 1)    // Chicago file specific 
/////////////////////////////////////////////////////////////////////////////
// General type Declarations
typedef unsigned char UCHAR;

typedef UCHAR * PUCHAR;

typedef BYTE far * far * LPLPBYTE;

typedef struct tagResSectData
{
    ULONG ulOffsetToResources;      //        File offset to the .rsrc
    ULONG ulVirtualAddress;         //... Virtual address of section .rsrc
    ULONG ulSizeOfResources;        //... Size of resources in section .rsrc
    ULONG ulOffsetToResources1;     //        File offset to the .rsrc1
    ULONG ulVirtualAddress1;        //... Virtual address of section .rsrc1
    ULONG ulSizeOfResources1;       //... Size of resources in section .rsrc1
} RESSECTDATA, *PRESSECTDATA;

typedef struct ver_block {
    WORD wBlockLen;
    WORD wValueLen;
    WORD wType;
    WORD wHead;
    BYTE far * pValue;
    char szKey[100];
    char szValue[256];
} VER_BLOCK;

VOID InitGlobals();

UINT GetNameOrOrdU( PUCHAR pRes,
            ULONG ulId,
            LPWSTR lpwszStrId,
            DWORD* pdwId );

 UINT GetStringW( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize, WORD cLen );
 UINT GetStringA( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize );
 UINT GetPascalString( BYTE far * far* lplpBuf,
                             LPSTR lpszText,
                             WORD wMaxLen,
                             LONG* pdwSize );
 UINT GetMsgStr( BYTE far * far* lplpBuf,
                       LPSTR lpszText,
                       WORD wMaxLen,
                       WORD* pwLen,
                       WORD* pwFlags,
                       LONG* pdwSize );
 UINT PutMsgStr( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wFlags, LONG* pdwSize );

 // Simulate the  WideChar to multibyte
 extern  UINT g_cp/* = CP_ACP*/; // Default to CP_ACP
 extern  BOOL g_bAppend/* = FALSE*/; //Default to FALSE
 extern  BOOL g_bUpdOtherResLang; /* = FALSE*/; //Default to FALSE
 extern  char g_char[2]/* = FALSE*/; //Default to FALSE
 UINT _MBSTOWCS( WCHAR * pwszOut, CHAR * pszIn, UINT nLength);
 UINT _WCSTOMBS( CHAR * pszOut, WCHAR * wszIn, UINT nLength);
 UINT _WCSLEN( WCHAR * pwszIn );

 BYTE PutDWord( BYTE far * far* lplpBuf, DWORD dwValue, LONG* pdwSize );
 BYTE PutDWordPrt( BYTE far * far* lplpBuf, DWORD_PTR dwValue, LONG* pdwSize );
 BYTE PutWord( BYTE far * far* lplpBuf, WORD wValue, LONG* pdwSize );
 BYTE PutByte( BYTE far * far* lplpBuf, BYTE bValue, LONG* pdwSize );
 UINT PutStringA( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize );
 UINT PutStringW( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize );
 UINT PutNameOrOrd( BYTE far * far* lplpBuf, WORD wOrd, LPSTR lpszText, LONG* pdwSize );
 UINT PutCaptionOrOrd( BYTE far * far* lplpBuf, WORD wOrd, LPSTR lpszText, LONG* pdwSize,
							 WORD wClass, DWORD dwStyle );
 UINT PutClassName( BYTE far * far* lplpBuf, WORD bClass, LPSTR lpszText, LONG* pdwSize );
 UINT PutPascalStringW( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wLen, LONG* pdwSize );
 UINT SkipByte( BYTE far * far * lplpBuf, UINT uiSkip, LONG* pdwRead );
 BYTE GetDWord( BYTE far * far* lplpBuf, DWORD* dwValue, LONG* pdwSize );
 BYTE GetWord( BYTE far * far* lplpBuf, WORD* wValue, LONG* pdwSize );
 BYTE GetByte( BYTE far * far* lplpBuf, BYTE* bValue, LONG* pdwSize );
 UINT GetNameOrOrd( BYTE far * far* lplpBuf, WORD* wOrd, LPSTR lpszText, LONG* pdwSize );
 UINT GetCaptionOrOrd( BYTE far * far* lplpBuf, WORD* wOrd, LPSTR lpszText, LONG* pdwSize,
							 WORD wClass, DWORD dwStyle );
 UINT GetClassName( BYTE far * far* lplpBuf, WORD* bClass, LPSTR lpszText, LONG* pdwSize );
 UINT GetVSBlock( BYTE far * far* lplpBuf, LONG* pdwSize, VER_BLOCK* pBlock );
 UINT PutVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK verBlock,
                        LPSTR lpStr, BYTE far * far * lplpBlockSize, WORD wPad);
 UINT ParseMenu( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
 UINT ParseString( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
 UINT ParseDialog( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize );
 UINT ParseMsgTbl( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize );
 UINT ParseAccel( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
 UINT ParseVerst( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

// These functions will take the image as is and will return just one item
// In this way the IODLL will assume there are items in the immage and will
// procede with the normal function.

 UINT ParseEmbeddedFile( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

 UINT UpdateMenu( LPVOID lpNewBuf, LONG dwNewSize,
                        LPVOID lpOldImage, LONG dwOldImageSize,
                        LPVOID lpNewImage, DWORD* pdwNewImageSize );

 UINT UpdateMsgTbl( LPVOID lpNewBuf, LONG dwNewSize,
                        LPVOID lpOldImage, LONG dwOldImageSize,
                        LPVOID lpNewImage, DWORD* pdwNewImageSize );

 UINT UpdateAccel( LPVOID lpNewBuf, LONG dwNewSize,
                         LPVOID lpOldImage, LONG dwOldImageSize,
                         LPVOID lpNewImage, DWORD* pdwNewImageSize );

 UINT UpdateDialog( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpOldI, LONG dwOldImageSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize );

 UINT UpdateString( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpOldI, LONG dwOldImageSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize );

 UINT UpdateVerst( LPVOID lpNewBuf, LONG dwNewSize,
                         LPVOID lpOldI, LONG dwOldImageSize,
                         LPVOID lpNewI, DWORD* pdwNewImageSize );

 UINT GenerateMenu( LPVOID lpNewBuf, LONG dwNewSize,  
						  LPVOID lpNewI, DWORD* pdwNewImageSize );
 UINT GenerateDialog( LPVOID lpNewBuf, LONG dwNewSize,  
						  LPVOID lpNewI, DWORD* pdwNewImageSize );
 UINT GenerateString( LPVOID lpNewBuf, LONG dwNewSize,  
						  LPVOID lpNewI, DWORD* pdwNewImageSize );
 UINT GenerateAccel( LPVOID lpNewBuf, LONG dwNewSize,  
						  LPVOID lpNewI, DWORD* pdwNewImageSize );


 UINT CopyFile( CFile* filein, CFile* fileout );
 DWORD FixCheckSum( LPCSTR ImageName);

 DWORD GenerateTransField( WORD wLang, BOOL bMode );
 void GenerateTransField( WORD wLang, VER_BLOCK * pVer );

 LONG Allign( LPLPBYTE lplpBuf, LONG* plBufSize, LONG lSize );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\inf\inf.h ===
/******************************************************\
 This file implement the class that will parse an inf
 file.
\******************************************************/
#ifndef _INF_H_
#define _INF_H_

#include <stdafx.h>

#define SEEK_LOC    4

class CInfLine;

class CInfFile
{
public:
    // Constructors and Destructors
    CInfFile();
    CInfFile( LPCTSTR strFileName );
    ~CInfFile();

    // Strings Functions
    BOOL ReadString(CString & str, BOOL bLastFilePos = TRUE);
    BOOL ReadSectionString(CString & str, BOOL bRecursive = FALSE);
    BOOL ReadSectionString(CInfLine & str);

    BOOL ReadSection(CString & str);        // Generic Section
    BOOL ReadTextSection(CString & str);    // Localizable Section

    CString GetLanguage()
        { return m_strLang; }

    // File Functions
    LONG Seek( LONG lOff, UINT nFrom );
    LONG SeekToBegin()
        { return Seek(0, SEEK_SET);  }
    LONG SeekToEnd()
        { return Seek(0, SEEK_END);  }
    LONG SeekToLocalize()
        { return Seek(0, SEEK_LOC);  }

    LONG GetLastFilePos()
        { return (LONG)(m_pfileLastPos-m_pfileStart); }

    BOOL Open( LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError = NULL );

    // Buffer access
    const BYTE * GetBuffer(LONG lPos = 0);


private:
    BYTE *  m_pfileStart;
    BYTE *  m_pfilePos;
    BYTE *  m_pfileLocalize;
    BYTE *  m_pfileLastPos;
    LONG    m_lBufSize;
    CFile   m_file;

    CString m_strLang;
};

class CInfLine
{
friend class CInfFile;
public:
    CInfLine();
    CInfLine( LPCSTR lpstr );

    // String functions
    LPCSTR GetText()
        { return m_strText; }
    LPCSTR GetTag()
        { return m_strTag; }
    LPCSTR GetData()
        { return m_strData; }

    void ChangeText(LPCSTR str);

    BOOL IsMultiLine()
        { return m_bMultipleLine; }

    LONG GetTextLength()
        { return m_strText.GetLength(); }
    LONG GetTagLength()
        { return m_strTag.GetLength(); }
    LONG GetDataLength()
        { return m_strData.GetLength(); }


    // copy operator
    CInfLine& operator=(const CInfLine& infstringSrc);
    CInfLine& operator=(LPCTSTR lpsz);

private:
    CString m_strData;
    CString m_strTag;
    CString m_strText;
    BOOL    m_bMultipleLine;

    void SetTag();
    void SetText();
    CString Clean(LPCSTR lpstr);
};

#endif //_INF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\inf\inf.cpp ===
/******************************************************\
 This file implement the class that will parse an inf
 file.
\******************************************************/
#include "inf.h"

#define MAX_INF_STR 8192*2
#define LanguageSection "[LanguagesSupported]"
#define LanguageSection1 "[LanguageID]"

// Constructors and Destructors
CInfFile::CInfFile()
{
    m_lBufSize = -1;
    m_pfileStart = NULL;
    m_pfilePos = NULL;
    m_pfileLastPos = NULL;
    m_pfileLocalize = NULL;
    m_strLang = "0000000000";
}

CInfFile::CInfFile(LPCTSTR strFileName )
{
    CFileException fe;
    Open(strFileName, CFile::modeRead | CFile::shareDenyWrite, &fe);
}

CInfFile::~CInfFile()
{
    if(m_pfileStart)
    {
        m_file.Close();
        delete m_pfileStart;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////
// String functions

BOOL CInfFile::ReadString(CString & str, BOOL bLastFilePos)
{
    if(m_pfilePos==NULL)
        return FALSE;

    // search for the next /n in the file
    BYTE * pEnd = (BYTE*)memchr(m_pfilePos, '\n', (size_t)(m_lBufSize-(m_pfilePos-m_pfileStart)));

    if(!pEnd)
        return FALSE;

    if(bLastFilePos)
        m_pfileLastPos = m_pfilePos;

    int istrSize = (int)((pEnd-m_pfilePos) > MAX_INF_STR ? MAX_INF_STR : (pEnd-m_pfilePos));

    LPSTR pStr = (LPSTR)str.GetBuffer(istrSize);

    memcpy(pStr, m_pfilePos, istrSize-1);

    if(*(pEnd-1)=='\r')
        *(pStr+istrSize-1) = '\0';
    else
        *(pStr+istrSize) = '\0';

    m_pfilePos = pEnd+1;
    str.ReleaseBuffer();
    return TRUE;
}

BOOL CInfFile::ReadSectionString(CString & str, BOOL bRecursive)
{
    CString strNext;
    BYTE * pPos = m_pfilePos;

    while(ReadString(strNext, !bRecursive))
    {
        if(!strNext.IsEmpty())
        {
            if(!bRecursive)
                str = "";

            // Check for a section
            if(strNext.Find('[')!=-1 && strNext.Find(']')!=-1)
                break;

            // remove spaces at the end of the string...
            strNext.TrimRight();

            //
            // Check for multiple line. Assume only last char can be a +
            //
            if(strNext.GetAt(strNext.GetLength()-1)=='+')
            {
                //
                // Remove the +
                //
                if(!str.IsEmpty())
                {
                    strNext.TrimLeft();
                    //strNext = strNext.Mid(1);
                }

                str += strNext.Left(strNext.GetLength()-1);

                ReadSectionString(str, TRUE);
            }
            else
            {
                if(!str.IsEmpty())
                {
                    strNext.TrimLeft();
                }
                str += strNext;
            }

            //
            // Make sure the " are balanced with
            //
            int iPos;
            while((iPos = str.Find("\"\""))!=-1)
            {
                str = str.Left(iPos) + str.Mid(iPos+2);
            }

            return TRUE;
        }
    }

    m_pfilePos = pPos;
    return FALSE;
}

BOOL CInfFile::ReadSectionString(CInfLine & str)
{
    CString strLine;
    if( !ReadSectionString(strLine) )
        return FALSE;

    str = strLine;

    return TRUE;
}

BOOL CInfFile::ReadTextSection(CString & str)
{
    CString strSection;
    while(ReadSection(strSection))
    {
        if(strSection.Find(m_strLang)!=-1)
        {
            str = strSection;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL CInfFile::ReadSection(CString & str)
{
    if(m_pfilePos==NULL)
        return 0;

    BYTE * pOpen;
    BYTE * pClose;
    BYTE * pEnd;
    BOOL bFound = FALSE;
    while(!bFound)
    {
        // search for the next [ in the file
        if((pOpen = (BYTE*)memchr(m_pfilePos, '[', (size_t)(m_lBufSize-(m_pfilePos-m_pfileStart))))==NULL)
            return 0;

        if((pClose = (BYTE*)memchr(pOpen, ']', (size_t)(m_lBufSize-(pOpen-m_pfileStart))))==NULL)
            return 0;

        if((pEnd = (BYTE*)memchr(pOpen, '\n', (size_t)(m_lBufSize-(pOpen-m_pfileStart))))==NULL)
            return 0;

        // pClose must be before pEnd
        if((pClose>pEnd) || (*(pOpen-1)!='\n') || (*(pClose+1)!='\r'))
            m_pfilePos = pEnd+1;
        else bFound = TRUE;
    }

    int istrSize = (int)((pEnd-pOpen) > MAX_INF_STR ? MAX_INF_STR : (pEnd-pOpen));

    LPSTR pStr = (LPSTR)str.GetBuffer(istrSize);

    memcpy(pStr, pOpen, istrSize-1);

    if(*(pEnd-1)=='\r')
        *(pStr+istrSize-1) = '\0';
    else
        *(pStr+istrSize) = '\0';

    m_pfilePos = pEnd+1;
    str.ReleaseBuffer();

    return 1;
}

//////////////////////////////////////////////////////////////////////////////////////////
// File functions

LONG CInfFile::Seek( LONG lOff, UINT nFrom )
{
    switch(nFrom)
    {
        case SEEK_SET:
            if(lOff<=m_lBufSize)
                m_pfilePos = m_pfileStart+lOff;
            else return -1;
        break;
        case SEEK_CUR:
            if(lOff<=m_lBufSize-(m_pfilePos-m_pfileStart))
                m_pfilePos = m_pfilePos+lOff;
            else return -1;
        break;
        case SEEK_END:
            if(lOff<=m_lBufSize)
                m_pfilePos = m_pfileStart+(m_lBufSize-lOff);
            else return -1;
        break;
        case SEEK_LOC:
            if(m_pfileLocalize)
                m_pfilePos = m_pfileLocalize;
            else return -1;
        break;
        default:
        break;
    }

    return ((LONG)(m_pfilePos-m_pfileStart));
}

BOOL CInfFile::Open( LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError )
{
    CFileException fe;
    if(!pError)
        pError = &fe;
    if(!m_file.Open(lpszFileName, nOpenFlags, pError))
    {
        AfxThrowFileException(pError->m_cause, pError->m_lOsError);
        return FALSE;
    }

    m_lBufSize = m_file.GetLength()+1;
    m_pfileStart = new BYTE[m_lBufSize];

    if(m_pfileStart==NULL)
    {
        AfxThrowMemoryException();
        return FALSE;
    }

    m_pfileLastPos = m_pfilePos = m_pfileStart;

    m_file.Read(m_pfileStart, m_lBufSize );
    *(m_pfilePos+m_lBufSize) = '\0';

    // find the localization section
    /*************************************************************************************\
     I'm assuming there are no other \0 in the buffer other than the one I've just placed.
     This is a fair assumption since this is a text file and not a binary file.
     I can then use strstr to get to the first occurrence, if any of the localization
     string section and place my current position buffer there.
    \*************************************************************************************/
    m_pfileLocalize = m_pfilePos = (BYTE*)strstr((LPSTR)m_pfileStart, LanguageSection);

    //
    // Check if we have the other language ID tag
    //
    if(!m_pfileLocalize)
        m_pfileLocalize = m_pfilePos = (BYTE*)strstr((LPSTR)m_pfileStart, LanguageSection1);


    // Get the language
    if(m_pfileLocalize)
    {
        BYTE * pStr = ((BYTE*)memchr(m_pfileLocalize, '\n', (size_t)(m_lBufSize-(m_pfileLocalize-m_pfileStart)))+1);
        BYTE * pEnd = ((BYTE*)memchr(pStr, '\n', (size_t)(m_lBufSize-(pStr-m_pfileStart)))-1);

        TRACE("CInfFile::Open =====> pStr = 0X%X, pEnd = 0X%X\n", pStr, pEnd);

        m_strLang = "";

        while( pStr<pEnd )
        {
            TRACE("CInfFile::Open =====> pStr = %c, 0X%X\n", *pStr, pStr);

            if( isalpha(*pStr++) )
                m_strLang += *(pStr-1);
        }
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////////////////
// Buffer functions

const BYTE * CInfFile::GetBuffer(LONG lPos /* = 0 */)
{
    if(lPos>m_lBufSize || lPos<0)
        return NULL;

    return( (const BYTE *)(m_pfileStart+lPos) );
}

/******************************************************************************************\
 CInfLine
 This class will parse the line and separate tag and text
\******************************************************************************************/

CInfLine::CInfLine()
{
    m_strData = "";
    m_strTag  = "";
    m_strText = "";
    m_bMultipleLine = FALSE;
}

CInfLine::CInfLine( LPCSTR lpStr )
{
    m_bMultipleLine = FALSE;
    m_strData = lpStr;
    SetTag();
    SetText();
}

void CInfLine::SetTag()
{
    m_strTag = "";
    // find the = in m_strData
    int iPos = m_strData.Find('=');
    if(iPos==-1)
        return;

    m_strTag = Clean(m_strData.Left( iPos ));
    m_strTag.TrimRight();
    m_strTag.TrimLeft();

}

void CInfLine::SetText()
{
    m_strText = "";
    // find the = in m_strData
    int iPos = m_strData.Find('=');
    if(iPos==-1)
        return;

    m_strText = Clean(m_strData.Right( m_strData.GetLength()-iPos-1 ));
	m_strText = m_strData.Right( m_strData.GetLength()-iPos-1 );
}

void CInfLine::ChangeText(LPCSTR str)
{
    m_strText = str;

    // find the = in m_strData
    int iPos = m_strData.Find('=');
    if(iPos==-1)
        return;

    m_strData = m_strData.Left( iPos+1 );
    m_strData += m_strText;
}

//////////////////////////////////////////////////////////////////////////////////////////
// copy operators

CInfLine& CInfLine::operator=(const CInfLine& infstringSrc)
{
	m_strData = infstringSrc.m_strData;
    m_strTag  = infstringSrc.m_strTag;
    m_strText = infstringSrc.m_strText;
    m_bMultipleLine = infstringSrc.m_bMultipleLine;
	return *this;
}

CInfLine& CInfLine::operator=(LPCTSTR lpsz)
{
    m_bMultipleLine = FALSE;
    m_strData = lpsz;
    SetTag();
    SetText();
    return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// support functions

CString CInfLine::Clean(LPCSTR lpstr)
{
    CString str = lpstr;

    int iPos = str.Find('"');
    if(iPos!=-1)
    {
        str = str.Right( str.GetLength()-iPos-1 );
        iPos = str.ReverseFind('"');
        if(iPos!=-1)
        {
            str = str.Left( iPos );
        }
    }

    return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\common\rw32hlpr.cpp ===
//////////////////////////////////////////////
//
// This file has the helper function used in the win32 r/w
// I copied them in this file to share them with the res32 r/w
//
#include <afxwin.h>
#include ".\rwdll.h"
#include ".\rw32hlpr.h"

/////////////////////////////////////////////////////////////////////////////
// Global variables
BYTE sizeofByte = sizeof(BYTE);
BYTE sizeofWord = sizeof(WORD);
BYTE sizeofDWord = sizeof(DWORD);
BYTE sizeofDWordPtr = sizeof(DWORD_PTR);

char szCaption[MAXSTR];
char szUpdCaption[MAXSTR];
WCHAR wszUpdCaption[MAXSTR];
CWordArray wIDArray;

#define DIALOGEX_VERION 1

/////////////////////////////////////////////////////////////////////////////
// Global settings, like code page and append options
UINT g_cp = CP_ACP;     // Default to CP_ACP
BOOL g_bAppend = FALSE; // Default to FALSE
BOOL g_bUpdOtherResLang = TRUE; // Default to FALSE
char g_char[] = " ";    // Default char for WideChartoMultiByte

VOID InitGlobals()
{
    // Make sure we are using the right code page and global settings
    // Get the pointer to the function
    HINSTANCE hDllInst = LoadLibrary("iodll.dll");
    if (hDllInst)
    {
        UINT (FAR PASCAL * lpfnGetSettings)(LPSETTINGS);
        // Get the pointer to the function to get the settings
        lpfnGetSettings = (UINT (FAR PASCAL *)(LPSETTINGS))
                     GetProcAddress( hDllInst, "RSGetGlobals" );
        if (lpfnGetSettings!=NULL) {
            SETTINGS settings;
            (*lpfnGetSettings)(&settings);

            g_cp      = settings.cp;
            g_bAppend = settings.bAppend;
            strcpy( g_char, settings.szDefChar );
        }
        FreeLibrary(hDllInst);
    }
}

#define _A_RLT_NULL_ "_RLT32_NULL_"
WCHAR _W_RLT_NULL_[] = L"_RLT32_NULL_";
int   _NULL_TAG_LEN_ = wcslen(_W_RLT_NULL_);
////////////////////////////////////////////////////////////////////////////
// Helper Function Implementation
UINT GetNameOrOrdU( PUCHAR pRes,
            ULONG ulId,
            LPWSTR lpwszStrId,
            DWORD* pdwId )
{

    if (ulId & IMAGE_RESOURCE_NAME_IS_STRING) {
        PIMAGE_RESOURCE_DIR_STRING_U pStrU = (PIMAGE_RESOURCE_DIR_STRING_U)((BYTE *)pRes
            + (ulId & (~IMAGE_RESOURCE_NAME_IS_STRING)));

        for (USHORT usCount=0; usCount < pStrU->Length ; usCount++) {
            *(lpwszStrId++) = LOBYTE(pStrU->NameString[usCount]);
        }
        *(lpwszStrId++) = 0x0000;
        *pdwId = 0;
    } else {
        *lpwszStrId = 0x0000;
        *pdwId = ulId;
    }

    return ERROR_NO_ERROR;
}

UINT _MBSTOWCS( WCHAR * pwszOut, CHAR * pszIn, UINT nLength)
{
    //
    // Check if we have a pointer to the function
    //

    int rc = MultiByteToWideChar(
        g_cp,           // UINT CodePage,
        0,              // DWORD dwFlags,
        pszIn,          // LPCSTR lpMultiByteStr,
        -1,             // int cchMultiByte,
        pwszOut,        // unsigned int far * lpWideCharStr,           // LPWSTR
        nLength );      // int cchWideChar

    return rc;
}

UINT _WCSTOMBS( CHAR* pszOut, WCHAR* pwszIn, UINT nLength)
{
    BOOL Bool = FALSE;

    int rc = WideCharToMultiByte(
        g_cp,           // UINT CodePage,
        0,              // DWORD dwFlags,
        pwszIn,         // const unsigned int far * lpWideCharStr,     // LPCWSTR
        -1,             // int cchWideChar,
        pszOut,         // LPSTR lpMultiByteStr,
        nLength,        // int cchMultiByte,
        g_char,        // LPCSTR lpDefaultChar,
        &Bool);         // BOOL far * lpUsedDefaultChar);              // LPBOOL

    return  rc;
}

UINT _WCSLEN( WCHAR * pwszIn )
{
    UINT n = 0;

    while( *(pwszIn+n)!=0x0000 ) n++;
    return( n + 1 );
}


BYTE
PutByte( BYTE far * far* lplpBuf, BYTE bValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofByte){
        memcpy(*lplpBuf, &bValue, sizeofByte);
        *lplpBuf += sizeofByte;
        *pdwSize -= sizeofByte;
    } else *pdwSize = -1;
    return sizeofByte;
}


UINT
PutNameOrOrd( BYTE far * far* lplpBuf,  WORD wOrd, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if (wOrd) {
        uiSize += PutWord(lplpBuf, 0xFFFF, pdwSize);
        uiSize += PutWord(lplpBuf, wOrd, pdwSize);
    } else {
        uiSize += PutStringW(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


UINT
PutCaptionOrOrd( BYTE far * far* lplpBuf,  WORD wOrd, LPSTR lpszText, LONG* pdwSize,
	WORD wClass, DWORD dwStyle )
{
    UINT uiSize = 0;

    // If this is an ICON then can just be an ID
    // Fix bug in the RC compiler
    /*
    if( (wClass==0x0082) && ((dwStyle & 0xF)==SS_ICON) ) {
    	if (wOrd) {
	    	uiSize += PutWord(lplpBuf, 0xFFFF, pdwSize);
	        uiSize += PutWord(lplpBuf, wOrd, pdwSize);
	        return uiSize;
    	} else {
    		// put nothing
    		return 0;
    	}
    }
    */
    if (wOrd) {
        uiSize += PutWord(lplpBuf, 0xFFFF, pdwSize);
        uiSize += PutWord(lplpBuf, wOrd, pdwSize);
    } else {
        uiSize += PutStringW(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


UINT
PutStringA( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize )
{
    int iSize = strlen(lpszText)+1;
    if (*pdwSize>=iSize){
        memcpy(*lplpBuf, lpszText, iSize);
        *lplpBuf += iSize;
        *pdwSize -= iSize;
    } else *pdwSize = -1;
    return iSize;
}


UINT
PutStringW( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize )
{
    int iSize = strlen(lpszText)+1;
    if (*pdwSize>=(iSize*2)){
        WCHAR* lpwszStr = new WCHAR[(iSize*2)];
        if (!lpwszStr) *pdwSize =0;
        else {
            SetLastError(0);
            iSize = _MBSTOWCS( lpwszStr, lpszText, iSize*2 );
            // Check for error
            if(GetLastError())
                return ERROR_DLL_LOAD;
            memcpy(*lplpBuf, lpwszStr, (iSize*2));
            *lplpBuf += (iSize*2);
            *pdwSize -= (iSize*2);
            delete lpwszStr;
        }
    } else *pdwSize = -1;
    return (iSize*2);
}



BYTE
PutWord( BYTE far * far* lplpBuf, WORD wValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofWord){
        memcpy(*lplpBuf, &wValue, sizeofWord);
        *lplpBuf += sizeofWord;
        *pdwSize -= sizeofWord;
    } else *pdwSize = -1;
    return sizeofWord;
}


BYTE
PutDWord( BYTE far * far* lplpBuf, DWORD dwValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofDWord){
        memcpy(*lplpBuf, &dwValue, sizeofDWord);
        *lplpBuf += sizeofDWord;
        *pdwSize -= sizeofDWord;
    } else *pdwSize = -1;
    return sizeofDWord;
}

BYTE
PutDWordPtr( BYTE far * far* lplpBuf, DWORD_PTR dwValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofDWordPtr){
        memcpy(*lplpBuf, &dwValue, sizeofDWordPtr);
        *lplpBuf += sizeofDWordPtr;
        *pdwSize -= sizeofDWordPtr;
    } else *pdwSize = -1;
    return sizeofDWordPtr;
}

 DWORD CalcID( WORD wId, BOOL bFlag )
{
    // We want to calculate the ID Relative to the WORD wId
    // If we have any other ID with the same value then we return
    // the incremental number + the value.
    // If no other Item have been found then the incremental number will be 0.
    // If bFlag = TRUE then the id get added to the present list.
    // If bFlag = FALSE then the list is reseted and the function return

    // Clean the array if needed
    if(!bFlag) {
        wIDArray.RemoveAll();
		wIDArray.SetSize(30, 1);
        return 0;
    }

    // Add the value to the array
    wIDArray.Add(wId);

    // Walk the array to get the number of duplicated ID
    int c = -1; // will be 0 based
    for(INT_PTR i=wIDArray.GetUpperBound(); i>=0 ; i-- ) {
        if (wIDArray.GetAt(i)==wId)
            c++;
    }
    TRACE3("CalcID: ID: %d\tPos: %d\tFinal: %u\n", wId, c, MAKELONG( wId, c ));


    return MAKELONG( wId, c );
}


UINT
ParseAccel( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;

    typedef struct accelerator {
        WORD fFlags;
        WORD wAscii;
        WORD wId;
        WORD padding;
    } ACCEL, *PACCEL;

    PACCEL pAcc = (PACCEL)lpImage;

    // Reset the IDArray
    CalcID(0, FALSE);
    // get the number of entry in the table
    for( int cNumEntry =(int)(dwImageSize/sizeof(ACCEL)), c=1; c<=cNumEntry ; c++)
    {
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a menu
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)pAcc->wAscii, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)pAcc->fFlags, &dwBufSize);
        //Put the MenuId
        dwOverAllSize += PutDWord( &lpBuf, CalcID(pAcc->wId, TRUE), &dwBufSize);


        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);

        // Put the size of the resource
        if (dwBufSize>=0) {
            lDummy = 8;
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        }

        // Move to the next position
        if (dwBufSize>0)
            lpItem = lpBuf;
        pAcc++;
    }

    return (UINT)(dwOverAllSize);
}

UINT GenerateAccel( LPVOID lpNewBuf, LONG dwNewSize,
                    LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    BYTE * lpNewImage = (BYTE *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE * lpBuf = (BYTE *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    typedef struct accelerator {
        WORD fFlags;
        WORD wAscii;
        WORD wId;
        WORD padding;
    } ACCEL, *PACCEL;

    ACCEL acc;
    BYTE bAccSize = sizeof(ACCEL);

    LONG  dwOverAllSize = 0l;

    while(dwNewSize>0) {
        if (dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            acc.wId = LOWORD(lpResItem->dwItemID);
            acc.fFlags = (WORD)lpResItem->dwFlags;
            acc.wAscii = (WORD)lpResItem->dwStyle;
            acc.padding = 0;
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if (dwNewSize<=0) {
            // Last Item in the accel table, mark it
            acc.fFlags = acc.fFlags | 0x80;
        }
        TRACE3("Accel: wID: %hd\t wAscii: %hd\t wFlag: %hd\n", acc.wId, acc.wAscii, acc.fFlags);

        if(bAccSize<=dwNewImageSize)
        {
            memcpy(lpNewImage, &acc, bAccSize);
            dwNewImageSize -= bAccSize;
            lpNewImage = lpNewImage+bAccSize;
            dwOverAllSize += bAccSize;
        }
        else dwOverAllSize += bAccSize;

    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad16((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


UINT
UpdateAccel( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;
    TRACE("Update Accelerators:\n");
    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    WORD wDummy;
    //Old Items
    WORD fFlags = 0;
    WORD wEvent = 0;
    WORD wId = 0;
    WORD wPos = 0;

    // Updated items
    WORD fUpdFlags = 0;
    WORD wUpdEvent = 0;
    WORD wUpdId = 0;
    WORD wUpdPos = 0;

    LONG  dwOverAllSize = 0l;


    while(dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        GetWord( &lpOldImage, &fFlags, &dwOldImageSize );
        GetWord( &lpOldImage, &wEvent, &dwOldImageSize );
        GetWord( &lpOldImage, &wId, &dwOldImageSize );
        GetWord( &lpOldImage, &wDummy, &dwOldImageSize );
        TRACE3("Old: fFlags: %d\t wEvent: %d\t wId: %d\n",fFlags, wEvent, wId);
        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdId = LOWORD(lpResItem->dwItemID);
            wUpdPos = HIWORD(lpResItem->dwItemID);
            fUpdFlags = (WORD)lpResItem->dwFlags;
            wUpdEvent = (WORD)lpResItem->dwStyle;
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }


        if ((wUpdId==wId)) {
            fFlags = fUpdFlags;
            wEvent = wUpdEvent;
            wUpdPos = 0;
        }

        TRACE3("New: fFlags: %d\t wEvent: %d\t wId: %d\n",fFlags, wEvent, wId);
        dwOverAllSize += PutWord( &lpNewImage, fFlags, &dwNewImageSize);
        dwOverAllSize += PutWord( &lpNewImage, wEvent, &dwNewImageSize);
        dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize);
        dwOverAllSize += PutWord( &lpNewImage, 0, &dwNewImageSize);
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad4((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}



UINT
ParseMenu( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;
    BOOL bExt = FALSE;
    WORD wlen = 0;

    // Menu Template
    WORD wMenuVer = 0;
    WORD wHdrSize = 0;

    // get the menu header
    GetWord( &lpImage, &wMenuVer, &dwImageSize );
	GetWord( &lpImage, &wHdrSize, &dwImageSize );
	
	// Check if is one of the new extended resource
	if(wMenuVer == 1) {
		bExt = TRUE;
		SkipByte( &lpImage, wHdrSize, &dwImageSize );
	}
		
    // Menu Items
    WORD fItemFlags = 0;
    WORD wMenuId = 0;

    // Extended Menu Items
    DWORD dwType = 0L;
    DWORD dwState = 0L;
    DWORD dwID = 0L;
    DWORD dwHelpID = 0;

    while(dwImageSize>0) {
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a menu
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (WORD)-1, &dwBufSize);

        if(bExt) {
        	GetDWord( &lpImage, &dwType, &dwImageSize );
        	GetDWord( &lpImage, &dwState, &dwImageSize );
        	GetDWord( &lpImage, &dwID, &dwImageSize );
        	// Let's get the Menu flags
	        GetWord( &lpImage, &fItemFlags, &dwImageSize );
	
	        // Check if it is a MFR_POPUP 0x0001
	        if (fItemFlags & MFR_POPUP) {
                // convert to the standard value
	        	fItemFlags &= ~(WORD)MFR_POPUP;
	        	fItemFlags |= MF_POPUP;
	        }
	
	        //Put the Flag
	        dwOverAllSize += PutDWord( &lpBuf, (DWORD)fItemFlags, &dwBufSize);
	        //Put the MenuId
	        dwOverAllSize += PutDWord( &lpBuf, dwID, &dwBufSize);
        } else {
	        // Let's get the Menu flags
	        GetWord( &lpImage, &fItemFlags, &dwImageSize );
	        if ( !(fItemFlags & MF_POPUP) )
	            // Get the menu Id
	            GetWord( &lpImage, &wMenuId, &dwImageSize );
	        else wMenuId = (WORD)-1;

	        //Put the Flag
	        dwOverAllSize += PutDWord( &lpBuf, (DWORD)fItemFlags, &dwBufSize);
	        //Put the MenuId
	        dwOverAllSize += PutDWord( &lpBuf, (DWORD)wMenuId, &dwBufSize);
        }

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, (DWORD_PTR)(lpItem+uiOffset), &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);

        // Get the text
        // calculate were the string is going to be
        // Will be the fixed header+the pointer
        wlen = (WORD)GetStringW( &lpImage, &szCaption[0], &dwImageSize, MAXSTR );

		dwOverAllSize += PutStringA( &lpBuf, &szCaption[0], &dwBufSize);
		
		if(bExt) {
			// Do we need padding
			BYTE bPad = (BYTE)Pad4((WORD)(wlen+sizeofWord));
			SkipByte( &lpImage, bPad, &dwImageSize );
			
			if ( (fItemFlags & MF_POPUP) )
	            // Get the Help Id
	            GetDWord( &lpImage, &dwHelpID, &dwImageSize );
		}

        // Put the size of the resource
        uiOffset += strlen(szCaption)+1;
        // Check if we are alligned
        lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += lDummy;
        uiOffset += lDummy;
        lDummy = 4;
        if(dwBufSize>=0)
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        /*
        if (dwBufSize>=0) {
            uiOffset += strlen((LPSTR)(lpItem+uiOffset))+1;
            // Check if we are alligned
            lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
            dwOverAllSize += lDummy;
            uiOffset += lDummy;
            lDummy = 8;
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        }
        */

        // Move to the next position
        lpItem = lpBuf;
        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
	        if (bPad==dwImageSize) {
					BYTE far * lpBuf = lpImage;
					while (bPad){
						if(*lpBuf++!=0x00)
							break;
						bPad--;
					}
					if (bPad==0)
						dwImageSize = -1;
		    }
		}
    }
    return (UINT)(dwOverAllSize);
}


UINT
UpdateMenu( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    // Menu Items
    WORD fItemFlags;
    WORD wMenuId;
    WORD wPos = 0;

    // Updated items
    WORD wUpdPos = 0;
    WORD fUpdItemFlags;
    WORD wUpdMenuId;

	// Extended Menu Items
    DWORD dwType = 0L;
    DWORD dwState = 0L;
    DWORD dwID = 0L;
    DWORD dwHelpID = 0;

    LONG dwOverAllSize = 0l;
    WORD wlen = 0;
    BOOL bExt = FALSE;
    BYTE bPad = 0;

    // Menu Template
    WORD wMenuVer = 0;
    WORD wHdrSize = 0;

    // get the menu header
    GetWord( &lpOldImage, &wMenuVer, &dwOldImageSize );
	GetWord( &lpOldImage, &wHdrSize, &dwOldImageSize );
	
	// Check if is one of the new extended resource
	if(wMenuVer == 1) {
		bExt = TRUE;
		// Put the header informations
		dwOverAllSize += PutWord( &lpNewImage, wMenuVer, &dwNewImageSize);
		dwOverAllSize += PutWord( &lpNewImage, wHdrSize, &dwNewImageSize);
		
		if(wHdrSize) {
			while(wHdrSize) {
				dwOldImageSize -= PutByte( &lpNewImage, *((BYTE*)lpOldImage), &dwNewImageSize);
			    lpOldImage += sizeofByte;
			    dwOverAllSize += sizeofByte;
				wHdrSize--;
			}
		}
	}
	else {
		// Put the header informations
		dwOverAllSize += PutWord( &lpNewImage, wMenuVer, &dwNewImageSize);
		dwOverAllSize += PutWord( &lpNewImage, wHdrSize, &dwNewImageSize);
	}
	
    while(dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        // Get the menu flag
        if(bExt) {
        	GetDWord( &lpOldImage, &dwType, &dwOldImageSize );
        	GetDWord( &lpOldImage, &dwState, &dwOldImageSize );
        	GetDWord( &lpOldImage, &dwID, &dwOldImageSize );
        	wMenuId = LOWORD(dwID);	// we need to do this since we had no idea the ID could be DWORD
        	// Let's get the Menu flags
	        GetWord( &lpOldImage, &fItemFlags, &dwOldImageSize );
	        // Get the text
        	wlen = (WORD)GetStringW( &lpOldImage, &szCaption[0], &dwOldImageSize, MAXSTR );
        	
	        // Do we need padding
			bPad = (BYTE)Pad4((WORD)(wlen+sizeofWord));
			SkipByte( &lpOldImage, bPad, &dwOldImageSize );
			
			if ( (fItemFlags & MFR_POPUP) )
	            // Get the Help Id
	            GetDWord( &lpOldImage, &dwHelpID, &dwOldImageSize );
        } else {
	        // Let's get the Menu flags
	        GetWord( &lpOldImage, &fItemFlags, &dwOldImageSize );
	        if ( !(fItemFlags & MF_POPUP) )
	            // Get the menu Id
	            GetWord( &lpOldImage, &wMenuId, &dwOldImageSize );
	        else wMenuId = (WORD)-1;
	
        	// Get the text
        	GetStringW( &lpOldImage, &szCaption[0], &dwOldImageSize, MAXSTR );
        }

        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdPos = HIWORD(lpResItem->dwItemID);
            wUpdMenuId = LOWORD(lpResItem->dwItemID);
            fUpdItemFlags = (WORD)lpResItem->dwFlags;
            strcpy( szUpdCaption, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if ((wPos==wUpdPos) && (wUpdMenuId==wMenuId)) {
        	if ((fItemFlags & MFR_POPUP) && bExt) {
	        	fUpdItemFlags &= ~MF_POPUP;
	        	fUpdItemFlags |= MFR_POPUP;
	        }
	        	
            // check if it is not the last item in the menu
	        if(fItemFlags & MF_END)
	                fItemFlags = fUpdItemFlags | (WORD)MF_END;
	        else fItemFlags = fUpdItemFlags;
	
	        // check it is not a separator
            if((fItemFlags==0) && (wMenuId==0) && !(*szCaption))
                strcpy(szCaption, "");
            else strcpy(szCaption, szUpdCaption);
            wUpdPos = 0;
        }
        if(bExt) {
        	dwOverAllSize += PutDWord( &lpNewImage, dwType, &dwNewImageSize);
        	dwOverAllSize += PutDWord( &lpNewImage, dwState, &dwNewImageSize);
        	dwOverAllSize += PutDWord( &lpNewImage, dwID, &dwNewImageSize);
        	
        	dwOverAllSize += PutWord( &lpNewImage, fItemFlags, &dwNewImageSize);
        	wlen = (WORD)PutStringW( &lpNewImage, &szCaption[0], &dwNewImageSize);
        	dwOverAllSize += wlen;
        	
        	// Do we need padding
			bPad = (BYTE)Pad4((WORD)(wlen+sizeofWord));
			while(bPad) {
				dwOverAllSize += PutByte( &lpNewImage, 0, &dwNewImageSize);
				bPad--;
			}
			
			if ( (fItemFlags & MFR_POPUP) )
	            // write the Help Id
	            dwOverAllSize += PutDWord( &lpNewImage, dwHelpID, &dwNewImageSize);
        }
        else {
	        dwOverAllSize += PutWord( &lpNewImage, fItemFlags, &dwNewImageSize);
	
	        if ( !(fItemFlags & MF_POPUP) ) {
	            dwOverAllSize += PutWord( &lpNewImage, wMenuId, &dwNewImageSize);
	        }
	
	        // Write the text in UNICODE
	        dwOverAllSize += PutStringW( &lpNewImage, &szCaption[0], &dwNewImageSize);
        }

        if (dwOldImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwOriginalOldSize-dwOldImageSize));
	        if (bPad==dwOldImageSize) {
				BYTE far * lpBuf = lpOldImage;
				while (bPad){
					if(*lpBuf++!=0x00)
						break;
					bPad--;
				}
				if (bPad==0)
					dwOldImageSize = -1;
			}
		}
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad16((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }
    return uiError;
}


UINT
ParseString( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    // Should be almost impossible for a String to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;

    LONG dwRead = 0L;

    BYTE bIdCount = 0;

    while( (dwImageSize>0) && (bIdCount<16)  ) {
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a string
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the StringId
        dwOverAllSize += PutDWord( &lpBuf, bIdCount++, &dwBufSize);

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ClassName
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // FaceName
        dwOverAllSize += PutDWordPtr( &lpBuf, (DWORD_PTR)(lpItem+uiOffset), &dwBufSize);   // Caption
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ResItem
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // TypeItem

        // Get the text
        GetPascalString( &lpImage, &szCaption[0], MAXSTR, &dwImageSize );
        dwOverAllSize += PutStringA( &lpBuf, &szCaption[0], &dwBufSize);

        // Put the size of the resource
        uiOffset += strlen(szCaption)+1;
        // Check if we are alligned
        lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += lDummy;
        uiOffset += lDummy;
        lDummy = 4;
        if(dwBufSize>=0)
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);

        /*
        if ((LONG)(dwSize-dwOverAllSize)>=0) {
            uiOffset += strlen(szCaption)+1;
            // Check if we are alligned
            lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
            dwOverAllSize += lDummy;
            uiOffset += lDummy;
            lDummy = 8;
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        }
        */

        // Move to the next position
        lpItem = lpBuf;

        // Check if we are at the end and this is just padding
        if (dwImageSize<=16 && (bIdCount==16)) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            if (bPad==dwImageSize) {
				BYTE far * lpBuf = lpImage;
				while (bPad){
					if(*lpBuf++!=0x00)
						break;
					bPad--;
				}
				if (bPad==0)
					dwImageSize = -1;
			}
		}
    }
    return (UINT)(dwOverAllSize);
}



UINT
UpdateString( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    WORD wLen;
    WORD wPos = 0;

    // Updated info
    WORD wUpdPos = 0;

    DWORD dwOriginalOldSize = dwOldImageSize;
    LONG dwOverAllSize = 0l;

    while(dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        GetPascalString( &lpOldImage, &szCaption[0], MAXSTR, &dwOldImageSize );

        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdPos = HIWORD(lpResItem->dwItemID);
            strcpy( szUpdCaption, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if ((wPos==wUpdPos)) {
            strcpy(szCaption, szUpdCaption);
            wUpdPos = 0;
        }

        wLen = strlen(szCaption);

        // Write the text
        dwOverAllSize += PutPascalStringW( &lpNewImage, &szCaption[0], wLen, &dwNewImageSize );

    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad4((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


UINT
UpdateMsgTbl( LPVOID lpNewBuf, LONG dwNewSize,
              LPVOID lpOldI, LONG dwOldImageSize,
              LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    BYTE far * lpStartImage = (BYTE far *) lpNewI;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    WORD wPos = 0;

    // Updated info
    WORD wUpdPos = 0;
    WORD wUpdId = 0;

    DWORD dwOriginalOldSize = dwOldImageSize;
    LONG dwOverAllSize = 0l;

    ULONG ulNumofBlock = 0;

    ULONG ulLowId =  0l;
    ULONG ulHighId = 0l;
    ULONG ulOffsetToEntry = 0l;

    USHORT usLength = 0l;
    USHORT usFlags = 0l;

    // we have to calculate the position of the first Entry block in the immage
    // Get number of blocks in the old image
    GetDWord( &lpOldImage, &ulNumofBlock, &dwOldImageSize );

    BYTE far * lpEntryBlock = lpNewImage+(ulNumofBlock*sizeof(ULONG)*3+sizeof(ULONG));

    // Write the number of block in the new image
    dwOverAllSize = PutDWord( &lpNewImage, ulNumofBlock, &dwNewImageSize );
    wPos = 1;
    for( ULONG c = 0; c<ulNumofBlock ; c++) {
        // Get ID of the block
        GetDWord( &lpOldImage, &ulLowId, &dwOldImageSize );
        GetDWord( &lpOldImage, &ulHighId, &dwOldImageSize );

        // Write the Id of the block
        dwOverAllSize += PutDWord( &lpNewImage, ulLowId, &dwNewImageSize );
        dwOverAllSize += PutDWord( &lpNewImage, ulHighId, &dwNewImageSize );

        // Get the offset to the data in the old image
        GetDWord( &lpOldImage, &ulOffsetToEntry, &dwOldImageSize );

        // Write the offset to the data in the new Image
        dwOverAllSize += PutDWord( &lpNewImage, (DWORD)(lpEntryBlock-lpStartImage), &dwNewImageSize );

        BYTE far * lpData = (BYTE far *)lpOldI;
        lpData += ulOffsetToEntry;
        while( ulHighId>=ulLowId ) {

            GetMsgStr( &lpData,
                       &szCaption[0],
                       MAXSTR,
                       &usLength,
                       &usFlags,
                       &dwOldImageSize );


            if ( dwNewSize ) {
                lpResItem = (LPRESITEM) lpBuf;

                wUpdId = LOWORD(lpResItem->dwItemID);
                strcpy( szUpdCaption, lpResItem->lpszCaption );
                lpBuf += lpResItem->dwSize;
                dwNewSize -= lpResItem->dwSize;
            }

            // Check if the item has been updated
            if (wUpdId==wPos++) {
                strcpy(szCaption, szUpdCaption);
            }

            dwOverAllSize += PutMsgStr( &lpEntryBlock,
                                        &szCaption[0],
                                        usFlags,
                                        &dwNewImageSize );

            ulLowId++;
        }
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad4((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}



UINT
ParseDialog( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    LPRESITEM lpResItem = (LPRESITEM)lpBuffer;
    UINT uiOffset = 0;

    char far * lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

    LONG dwOverAllSize = 0L;

    WORD wIdCount = 0;
    BOOL bExt = FALSE;		// Extended dialog flag

    // Dialog Elements
    WORD wDlgVer = 0;
    WORD wSign	= 0;
    DWORD dwHelpID = 0L;
    DWORD dwStyle = 0L;
    DWORD dwExtStyle = 0L;
    WORD wNumOfElem = 0;
    WORD wX = 0;
    WORD wY = 0;
    WORD wcX = 0;
    WORD wcY = 0;
    WORD wId = 0;
    DWORD dwId = 0L;
    char szMenuName[128];
    WORD wMenuName;
    char szClassName[128];
    WORD wClassName;
    WORD wOrd = 0;
    WORD wPointSize = 0;
    WORD wWeight = -1;
    BYTE bItalic = -1;
    BYTE bCharSet = DEFAULT_CHARSET;
    char szFaceName[128];
    WORD wRawData = 0;
    WORD wDataSize = 0;
    szCaption[0] = '\0';


    // read the dialog header
    wDataSize = GetDWord( &lpImage, &dwStyle, &dwImageSize );

    // Check for extended dialog style
    if(HIWORD(dwStyle)==0xFFFF)	{
    	bExt = TRUE;
    	wDlgVer = HIWORD(dwStyle);
    	wSign = LOWORD(dwStyle);
		wDataSize += GetDWord( &lpImage, &dwHelpID, &dwImageSize );
	}
    wDataSize += GetDWord( &lpImage, &dwExtStyle, &dwImageSize );
    if(bExt)
    	wDataSize += GetDWord( &lpImage, &dwStyle, &dwImageSize );
    wDataSize += GetWord( &lpImage, &wNumOfElem, &dwImageSize );
    wDataSize += GetWord( &lpImage, &wX, &dwImageSize );
    wDataSize += GetWord( &lpImage, &wY, &dwImageSize );
    wDataSize += GetWord( &lpImage, &wcX, &dwImageSize );
    wDataSize += GetWord( &lpImage, &wcY, &dwImageSize );
    wDataSize += (WORD)GetNameOrOrd( &lpImage, &wMenuName, &szMenuName[0], &dwImageSize );
    wDataSize += (WORD)GetClassName( &lpImage, &wClassName, &szClassName[0], &dwImageSize );
    wDataSize += (WORD)GetCaptionOrOrd( &lpImage, &wOrd, &szCaption[0], &dwImageSize, wClassName, dwStyle );
    if( dwStyle & DS_SETFONT ) {
        wDataSize += GetWord( &lpImage, &wPointSize, &dwImageSize );
        if(bExt) {
        	wDataSize += GetWord( &lpImage, &wWeight, &dwImageSize );
        	wDataSize += GetByte( &lpImage, &bItalic, &dwImageSize );
        	wDataSize += GetByte( &lpImage, &bCharSet, &dwImageSize );
        }
        wDataSize += (WORD)GetStringW( &lpImage, &szFaceName[0], &dwImageSize, 128 );
    }


    // calculate the padding
    BYTE bPad = (BYTE)Pad4((WORD)wDataSize);
    if (bPad)
        SkipByte( &lpImage, bPad, &dwImageSize );

    TRACE("WIN32.DLL ParseDialog\t");
    if(bExt)
    	TRACE("Extended style Dialog - Chicago win32 dialog format\n");
    else TRACE("Standart style Dialog - NT win32 dialog format\n");
    if (bExt){
    	TRACE1("DlgVer: %d\t", wDlgVer);
    	TRACE1("Signature: %d\t", wSign);
    	TRACE1("HelpID: %lu\n", dwHelpID);
    }
    TRACE1("NumElem: %d\t", wNumOfElem);
    TRACE1("X %d\t", wX);
    TRACE1("Y: %d\t", wY);
    TRACE1("CX: %d\t", wcX);
    TRACE1("CY: %d\t", wcY);
    TRACE1("Id: %d\t", wId);
    TRACE1("Style: %lu\t", dwStyle);
    TRACE1("ExtStyle: %lu\n", dwExtStyle);
    TRACE1("Caption: %s\n", szCaption);
    TRACE2("ClassName: %s\tClassId: %d\n", szClassName, wClassName );
    TRACE2("MenuName: %s\tMenuId: %d\n", szMenuName, wMenuName );
    TRACE2("FontName: %s\tPoint: %d\n", szFaceName, wPointSize );
#ifdef _DEBUG
    if(bExt)
    	TRACE2("Weight: %d\tItalic: %d\n", wWeight, bItalic );
#endif

    // Fixed field
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

    dwOverAllSize += PutWord( &lpBuf, wX, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wY, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wcX, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wcY, &dwBufSize);

    // we don't have checksum
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, dwStyle, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, dwExtStyle, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    //Put the Id 0 for the main dialog
    dwOverAllSize += PutDWord( &lpBuf, wIdCount++, &dwBufSize);

    // we don't have the resID, and the Type Id
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the language
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the codepage
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    dwOverAllSize += PutWord( &lpBuf, wClassName, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wPointSize, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wWeight, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, bItalic, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, bCharSet, &dwBufSize);

    // Let's put null were we don't have the strings
    uiOffset = sizeof(RESITEM);
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ClassName
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // FaceName
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // Caption
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ResItem
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // TypeItem

    lpResItem->lpszClassName = strcpy( lpStrBuf, szClassName );
    lpStrBuf += strlen(lpResItem->lpszClassName)+1;

    lpResItem->lpszFaceName = strcpy( lpStrBuf, szFaceName );
    lpStrBuf += strlen(lpResItem->lpszFaceName)+1;

    lpResItem->lpszCaption = strcpy( lpStrBuf, szCaption );
    lpStrBuf += strlen(lpResItem->lpszCaption)+1;

    // Put the size of the resource
    if (dwBufSize>0) {
        uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
        uiOffset += strlen((LPSTR)(lpResItem->lpszFaceName))+1;
        uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
    }

    // Check if we are alligned
    uiOffset += Allign( (LPLPBYTE)&lpStrBuf, &dwBufSize, (LONG)uiOffset);

    dwOverAllSize += uiOffset-sizeof(RESITEM);
    lpResItem->dwSize = (DWORD)uiOffset;

    // Move to the next position
    lpResItem = (LPRESITEM) lpStrBuf;
    lpBuf = (BYTE far *)lpStrBuf;
    lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

    while( (dwImageSize>0) && (wNumOfElem>0) ) {
        // Read the Controls
        if(bExt) {
        	wDataSize = GetDWord( &lpImage, &dwHelpID, &dwImageSize );
        	wDataSize += GetDWord( &lpImage, &dwExtStyle, &dwImageSize );
        	wDataSize += GetDWord( &lpImage, &dwStyle, &dwImageSize );
        }
        else {
	        wDataSize = GetDWord( &lpImage, &dwStyle, &dwImageSize );
	        wDataSize += GetDWord( &lpImage, &dwExtStyle, &dwImageSize );
	    }
	    wDataSize += GetWord( &lpImage, &wX, &dwImageSize );
        wDataSize += GetWord( &lpImage, &wY, &dwImageSize );
        wDataSize += GetWord( &lpImage, &wcX, &dwImageSize );
        wDataSize += GetWord( &lpImage, &wcY, &dwImageSize );
        if(bExt) {
        	wDataSize += GetDWord( &lpImage, &dwId, &dwImageSize );
        	wId = LOWORD(dwId);
        }
        else wDataSize += GetWord( &lpImage, &wId, &dwImageSize );
        wDataSize += (WORD)GetClassName( &lpImage, &wClassName, &szClassName[0], &dwImageSize );
        wDataSize += (WORD)GetCaptionOrOrd( &lpImage, &wOrd, &szCaption[0], &dwImageSize, wClassName, dwStyle );
        if (bExt) {
        	wDataSize += GetWord( &lpImage, &wRawData, &dwImageSize );
        	wDataSize += (WORD)SkipByte( &lpImage, wRawData, &dwImageSize );
        } else
        	wDataSize += (WORD)SkipByte( &lpImage, 2, &dwImageSize );

        // Calculate padding
        bPad = (BYTE)Pad4((WORD)wDataSize);
        if (bPad)
            SkipByte( &lpImage, bPad, &dwImageSize );

        wNumOfElem--;

        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        dwOverAllSize += PutWord( &lpBuf, wX, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wY, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wcX, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wcY, &dwBufSize);

        // we don't have checksum and extended style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, dwStyle, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, dwExtStyle, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Id
        dwOverAllSize += PutDWord( &lpBuf, wId, &dwBufSize);

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        dwOverAllSize += PutWord( &lpBuf, wClassName, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wPointSize, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wWeight, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, bItalic, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, bCharSet, &dwBufSize);

        // Let's put null were we don't have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ClassName
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // FaceName
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // Caption
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ResItem
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // TypeItem

        lpResItem->lpszClassName = strcpy( lpStrBuf, szClassName );
        lpStrBuf += strlen(lpResItem->lpszClassName)+1;

        lpResItem->lpszFaceName = strcpy( lpStrBuf, szFaceName );
        lpStrBuf += strlen(lpResItem->lpszFaceName)+1;

        lpResItem->lpszCaption = strcpy( lpStrBuf, szCaption );
        lpStrBuf += strlen(lpResItem->lpszCaption)+1;

        // Put the size of the resource
        if (dwBufSize>0) {
            uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszFaceName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
        }

        // Check if we are alligned
        uiOffset += Allign( (LPLPBYTE)&lpStrBuf, &dwBufSize, (LONG)uiOffset);

        dwOverAllSize += uiOffset-sizeof(RESITEM);
        lpResItem->dwSize = (DWORD)uiOffset;

        // Move to the next position
        lpResItem = (LPRESITEM) lpStrBuf;
        lpBuf = (BYTE far *)lpStrBuf;
        lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

        TRACE1("\tControl: X: %d\t", wX);
        TRACE1("Y: %d\t", wY);
        TRACE1("CX: %d\t", wcX);
        TRACE1("CY: %d\t", wcY);
        if (bExt) TRACE1("Id: %lu\t", dwId);
        else TRACE1("Id: %d\t", wId);
        TRACE1("Style: %lu\t", dwStyle);
        TRACE1("ExtStyle: %lu\n", dwExtStyle);
        TRACE1("HelpID: %lu\t", dwHelpID);
        TRACE1("RawData: %d\n", wRawData);
        TRACE1("Caption: %s\n", szCaption);

        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            if (bPad==dwImageSize) {
				BYTE far * lpBuf = lpImage;
				while (bPad){
					if(*lpBuf++!=0x00)
						break;
					bPad--;
				}
				if (bPad==0)
					dwImageSize = -1;
			}
        }
    }

    return (UINT)(dwOverAllSize);
}



UINT
UpdateDialog( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    LONG dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    LONG dwOverAllSize = 0L;

    //WORD    wIdCount = 0;
    BOOL bExt = FALSE;		// Extended dialog flag
    BOOL bUpdExt = FALSE;	// Updated DIALOGEX flag

    // Updated elements
    WORD wUpdX = 0;
    WORD wUpdY = 0;
    WORD wUpdcX = 0;
    WORD wUpdcY = 0;
    DWORD dwUpdStyle = 0l;
    DWORD dwUpdExtStyle = 0L;
    DWORD dwPosId = 0l;
     char szUpdFaceName[128];
    WORD wUpdPointSize = 0;
    BYTE bUpdCharSet = DEFAULT_CHARSET;
    WORD wUpdPos = 0;

    // Dialog Elements
    WORD	wDlgVer = 0;
    WORD	wSign	= 0;
    DWORD	dwHelpID = 0L;
    DWORD	dwID = 0L;
    DWORD   dwStyle = 0L;
    DWORD   dwExtStyle = 0L;
    WORD    wNumOfElem = 0;
    WORD    wX = 0;
    WORD    wY = 0;
    WORD    wcX = 0;
    WORD    wcY = 0;
    WORD    wId = 0;
     char     szMenuName[128];
    WORD    wMenuName;
     char     szClassName[128];
    WORD    wClassName;
    WORD    wPointSize = 0;
    WORD	wWeight = FW_NORMAL;
    BYTE    bItalic = 0;
    BYTE    bCharSet = DEFAULT_CHARSET;
     char    szFaceName[128];
    WORD	wRawData = 0;
    BYTE *	lpRawData = NULL;
    WORD    wDataSize = 0;

    WORD    wPos = 1;
    WORD    wOrd = 0;

    // read the dialog header
    wDataSize = GetDWord( &lpOldImage, &dwStyle, &dwOriginalOldSize );

    // Check for extended dialog style
    if(HIWORD(dwStyle)==0xFFFF)	{
    	bExt = TRUE;
    	wDlgVer = HIWORD(dwStyle);
    	wSign = LOWORD(dwStyle);
		wDataSize += GetDWord( &lpOldImage, &dwHelpID, &dwOriginalOldSize );
	}
    wDataSize += GetDWord( &lpOldImage, &dwExtStyle, &dwOriginalOldSize );
    if(bExt)
    	wDataSize += GetDWord( &lpOldImage, &dwStyle, &dwOriginalOldSize );
    wDataSize += GetWord( &lpOldImage, &wNumOfElem, &dwOriginalOldSize );
    wDataSize += GetWord( &lpOldImage, &wX, &dwOriginalOldSize );
    wDataSize += GetWord( &lpOldImage, &wY, &dwOriginalOldSize );
    wDataSize += GetWord( &lpOldImage, &wcX, &dwOriginalOldSize );
    wDataSize += GetWord( &lpOldImage, &wcY, &dwOriginalOldSize );
    wDataSize += (WORD)GetNameOrOrd( &lpOldImage, &wMenuName, &szMenuName[0], &dwOriginalOldSize );
    wDataSize += (WORD)GetClassName( &lpOldImage, &wClassName, &szClassName[0], &dwOriginalOldSize );
    wDataSize += (WORD)GetCaptionOrOrd( &lpOldImage , &wOrd, &szCaption[0], &dwOriginalOldSize, wClassName, dwStyle  );
    if( dwStyle & DS_SETFONT ) {
        wDataSize += GetWord( &lpOldImage, &wPointSize, &dwOriginalOldSize );
        if(bExt) {
        	wDataSize += GetWord( &lpOldImage, &wWeight, &dwOriginalOldSize );
        	wDataSize += GetByte( &lpOldImage, &bItalic, &dwOriginalOldSize );
        	wDataSize += GetByte( &lpOldImage, &bCharSet, &dwOriginalOldSize );
        }
        wDataSize += (WORD)GetStringW( &lpOldImage, &szFaceName[0], &dwOriginalOldSize, 128 );
    }

    // calculate the padding
    BYTE bPad = (BYTE)Pad4((WORD)wDataSize);
    if (bPad)
        SkipByte( &lpOldImage, bPad, &dwOriginalOldSize );

    TRACE("WIN32.DLL UpdateDialog\n");
    if(bExt)
    	TRACE("Extended style Dialog - Chicago win32 dialog format\n");
    else TRACE("Standart style Dialog - NT win32 dialog format\n");
    if (bExt){
    	TRACE1("DlgVer: %d\t", wDlgVer);
    	TRACE1("Signature: %d\t", wSign);
    	TRACE1("HelpID: %lu\n", dwHelpID);
    }

    TRACE1("NumElem: %d\t", wNumOfElem);
    TRACE1("X %d\t", wX);
    TRACE1("Y: %d\t", wY);
    TRACE1("CX: %d\t", wcX);
    TRACE1("CY: %d\t", wcY);
    TRACE1("Id: %d\t", wId);
    TRACE1("Style: %lu\t", dwStyle);
    TRACE1("ExtStyle: %lu\n", dwExtStyle);
    TRACE1("Caption: %s\n", szCaption);
    TRACE2("ClassName: %s\tClassId: %d\n", szClassName, wClassName );
    TRACE2("MenuName: %s\tMenuId: %d\n", szMenuName, wMenuName );
    TRACE2("FontName: %s\tPoint: %d\n", szFaceName, wPointSize );
#ifdef _DEBUG
    if(bExt)
    	TRACE2("Weight: %d\tItalic: %d\n", wWeight, bItalic );
#endif

    // Get the infrmation from the updated resource
    if ((!wUpdPos) && dwNewSize ) {
        lpResItem = (LPRESITEM) lpBuf;
        wUpdX = lpResItem->wX;
        wUpdY = lpResItem->wY;
        wUpdcX = lpResItem->wcX;
        wUpdcY = lpResItem->wcY;
        wUpdPointSize = lpResItem->wPointSize;
        bUpdCharSet = lpResItem->bCharSet;
        dwUpdStyle = lpResItem->dwStyle;
        dwUpdExtStyle = lpResItem->dwExtStyle;
        dwPosId = lpResItem->dwItemID;
        strcpy( szUpdCaption, lpResItem->lpszCaption );
        strcpy( szUpdFaceName, lpResItem->lpszFaceName );
        lpBuf += lpResItem->dwSize;
        dwNewSize -= lpResItem->dwSize;
    }

    // check if we have to update the header
    if ((HIWORD(dwPosId)==wPos) && (LOWORD(dwPosId)==wId)) {
        wX = wUpdX;
        wY = wUpdY;
        wcX = wUpdcX;
        wcY = wUpdcY;
        wPointSize = wUpdPointSize;
        bCharSet = bUpdCharSet;
        dwStyle = dwUpdStyle;
        dwExtStyle = dwUpdExtStyle;
        strcpy(szCaption, szUpdCaption);
        strcpy(szFaceName, szUpdFaceName);
    }

    // User changed DIALOG to DIALOGEX by adding charset information.
    if (!bExt && bCharSet != DEFAULT_CHARSET){
        bUpdExt = TRUE;
        wSign = DIALOGEX_VERION;
        wDlgVer = 0xFFFF;
        dwHelpID = 0;
        wWeight = FW_NORMAL;
        bItalic = 0;
    }
    DWORD dwPadCalc = dwOverAllSize;
    // Write the header informations
    if(bExt || bUpdExt) {
    	dwOverAllSize += PutWord( &lpNewImage, wSign, &dwNewImageSize );
    	dwOverAllSize += PutWord( &lpNewImage, wDlgVer, &dwNewImageSize );
    	dwOverAllSize += PutDWord( &lpNewImage, dwHelpID, &dwNewImageSize );
        dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );
	    dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
    }
    else {
	    dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
	    dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );
	}
    dwOverAllSize += PutWord( &lpNewImage, wNumOfElem, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
    dwOverAllSize += PutNameOrOrd( &lpNewImage, wMenuName, &szMenuName[0], &dwNewImageSize );
    dwOverAllSize += PutClassName( &lpNewImage, wClassName, &szClassName[0], &dwNewImageSize );
    dwOverAllSize += PutCaptionOrOrd( &lpNewImage, wOrd, &szCaption[0], &dwNewImageSize,
    	wClassName, dwStyle );
    if( dwStyle & DS_SETFONT ) {
    	dwOverAllSize += PutWord( &lpNewImage, wPointSize, &dwNewImageSize );
    	if(bExt || bUpdExt) {
    		dwOverAllSize += PutWord( &lpNewImage, wWeight, &dwNewImageSize );
    		dwOverAllSize += PutByte( &lpNewImage, bItalic, &dwNewImageSize );
    		dwOverAllSize += PutByte( &lpNewImage, bCharSet, &dwNewImageSize );
    	}
        dwOverAllSize += PutStringW( &lpNewImage, &szFaceName[0], &dwNewImageSize );
    }

    // Check if padding is needed
    bPad = (BYTE)Pad4((WORD)(dwOverAllSize-dwPadCalc));
    if (bPad) {
        if( (bPad)<=dwNewImageSize )
            memset( lpNewImage, 0x00, bPad );
        dwNewImageSize -= (bPad);
        dwOverAllSize += (bPad);
        lpNewImage += (bPad);
    }

    while( (dwOriginalOldSize>0) && (wNumOfElem>0) ) {
        wPos++;
        // Get the info for the control
        // Read the Controls
        if(bExt) {
        	wDataSize = GetDWord( &lpOldImage, &dwHelpID, &dwOriginalOldSize );
        	wDataSize += GetDWord( &lpOldImage, &dwExtStyle, &dwOriginalOldSize );
        	wDataSize += GetDWord( &lpOldImage, &dwStyle, &dwOriginalOldSize );
        }
        else {
	        wDataSize = GetDWord( &lpOldImage, &dwStyle, &dwOriginalOldSize );
	        wDataSize += GetDWord( &lpOldImage, &dwExtStyle, &dwOriginalOldSize );
	    }
	    wDataSize += GetWord( &lpOldImage, &wX, &dwOriginalOldSize );
        wDataSize += GetWord( &lpOldImage, &wY, &dwOriginalOldSize );
        wDataSize += GetWord( &lpOldImage, &wcX, &dwOriginalOldSize );
        wDataSize += GetWord( &lpOldImage, &wcY, &dwOriginalOldSize );
        if(bExt) {
        	wDataSize += GetDWord( &lpOldImage, &dwID, &dwOriginalOldSize );
        	wId = LOWORD(dwID);
        } else {
            wDataSize += GetWord( &lpOldImage, &wId, &dwOriginalOldSize );
        }

        wDataSize += (WORD)GetClassName( &lpOldImage, &wClassName, &szClassName[0], &dwOriginalOldSize );
        wDataSize += (WORD)GetCaptionOrOrd( &lpOldImage, &wOrd, &szCaption[0], &dwOriginalOldSize, wClassName, dwStyle );
        if (bExt) {
        	wDataSize += GetWord( &lpOldImage, &wRawData, &dwOriginalOldSize );
        	if(wRawData) {
        		lpRawData = (BYTE*)lpOldImage;
        		wDataSize += (WORD)SkipByte( &lpOldImage, wRawData, &dwOriginalOldSize );
        	} else lpRawData = NULL;
        } else
        	wDataSize += (WORD)SkipByte( &lpOldImage, 2, &dwOriginalOldSize );

        // Calculate padding
        bPad = (BYTE)Pad4((WORD)wDataSize);
        if (bPad)
            SkipByte( &lpOldImage, bPad, &dwOriginalOldSize );

        wNumOfElem--;

        if ((!wUpdPos) && dwNewSize ) {
        TRACE1("\t\tUpdateDialog:\tdwNewSize=%ld\n",(LONG)dwNewSize);
            TRACE1("\t\t\t\tlpszCaption=%Fs\n",lpResItem->lpszCaption);
            lpResItem = (LPRESITEM) lpBuf;
            wUpdX = lpResItem->wX;
            wUpdY = lpResItem->wY;
            wUpdcX = lpResItem->wcX;
            wUpdcY = lpResItem->wcY;
            dwUpdStyle = lpResItem->dwStyle;
            dwUpdExtStyle = lpResItem->dwExtStyle;
            dwPosId = lpResItem->dwItemID;
            strcpy( szUpdCaption, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }
        // check if we have to update the header
        if ((HIWORD(dwPosId)==wPos) && (LOWORD(dwPosId)==wId)) {
            wX = wUpdX;
            wY = wUpdY;
            wcX = wUpdcX;
            wcY = wUpdcY;
            dwStyle = dwUpdStyle;
            dwExtStyle = dwUpdExtStyle;
            strcpy(szCaption, szUpdCaption);
        }

        dwPadCalc = dwOverAllSize;
        //write the control
        if(bExt || bUpdExt) {
        	dwOverAllSize += PutDWord( &lpNewImage, dwHelpID, &dwNewImageSize );
        	dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );
        	dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
        }
        else {
        	dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
        	dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );
        }
        dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
        if (bUpdExt){
            dwID = MAKELONG(wId, 0);
        }
        if(bExt || bUpdExt)
        	 dwOverAllSize += PutDWord( &lpNewImage, dwID, &dwNewImageSize );
        else dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize );
        dwOverAllSize += PutClassName( &lpNewImage, wClassName, &szClassName[0], &dwNewImageSize );
        dwOverAllSize += PutCaptionOrOrd( &lpNewImage, wOrd, &szCaption[0], &dwNewImageSize,
        	wClassName, dwStyle );
        if (bExt) {
        	dwOverAllSize += PutWord( &lpNewImage, wRawData, &dwNewImageSize );
        	while(wRawData) {
        		dwOverAllSize += PutByte( &lpNewImage, *((BYTE*)lpRawData++), &dwNewImageSize );
        		wRawData--;
        	}
        } else
        	dwOverAllSize += PutWord( &lpNewImage, 0, &dwNewImageSize );

        // Check if padding is needed
        bPad = (BYTE)Pad4((WORD)(dwOverAllSize-dwPadCalc));
        if (bPad) {
            if( (bPad)<=dwNewImageSize )
                memset( lpNewImage, 0x00, bPad );
            dwNewImageSize -= (bPad);
            dwOverAllSize += (bPad);
            lpNewImage += (bPad);
        }
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad4((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }


    return uiError;
}


UINT
ParseMsgTbl( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    LONG dwOverAllSize = 0L;

    // Should be almost impossible for a Message table to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwRead = 0L;

    ULONG ulNumofBlock = 0l;

    ULONG ulLowId =  0l;
    ULONG ulHighId = 0l;
    ULONG ulOffsetToEntry = 0l;

    USHORT usLength = 0l;
    USHORT usFlags = 0l;

    WORD wPos = 0;
    // Get number of blocks
    GetDWord( &lpImage, &ulNumofBlock, &dwImageSize );
    wPos = 1;
    for( ULONG c = 0; c<ulNumofBlock ; c++) {
        // Get ID of the block
        GetDWord( &lpImage, &ulLowId, &dwImageSize );
        GetDWord( &lpImage, &ulHighId, &dwImageSize );

        // Get the offset to the data
        GetDWord( &lpImage, &ulOffsetToEntry, &dwImageSize );

        BYTE far * lpData = (BYTE far *)lpImageBuf;
        lpData += ulOffsetToEntry;
        while( ulHighId>=ulLowId ) {

            GetMsgStr( &lpData,
                          &szCaption[0],
                          MAXSTR,
                          &usLength,
                          &usFlags,
                          &dwImageSize );
            // Fixed field
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
            // We don't have the size and pos in a string
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

            // we don't have checksum and style
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            //Put the lowStringId
            //dwOverAllSize += PutDWord( &lpBuf, MAKELONG(ulLowId++, wPos++), &dwBufSize);

            ulLowId++;
            dwOverAllSize += PutDWord( &lpBuf, MAKELONG(wPos, wPos), &dwBufSize);
            wPos++;


            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            // we don't have the language
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            // Put the flags: if 1 = ANSI if 0 = ASCII(OEM)
            dwOverAllSize += PutDWord( &lpBuf, usFlags , &dwBufSize);

            // we don't have the font name
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
            dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

            // Let's put null were we don;t have the strings
            uiOffset = sizeof(RESITEM);
            dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ClassName
            dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // FaceName
            dwOverAllSize += PutDWordPtr( &lpBuf, (DWORD_PTR)(lpItem+uiOffset), &dwBufSize);   // Caption
            dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // ResItem
            dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);  // TypeItem

            dwOverAllSize += PutStringA( &lpBuf, &szCaption[0], &dwBufSize);

            // Put the size of the resource
            if ((LONG)(dwSize-dwOverAllSize)>=0) {
                uiOffset += strlen((LPSTR)(lpItem+uiOffset))+1;
                // Check if we are alligned
            	lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
            	dwOverAllSize += lDummy;
            	uiOffset += lDummy;
            	lDummy = 8;
                PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
            }

            // Move to the next position
            lpItem = lpBuf;

            // Check if we are at the end and this is just padding
            if (dwImageSize<=16) {
                BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
    	        if (bPad==dwImageSize) {
    				BYTE far * lpBuf = lpImage;
    				while (bPad){
    					if(*lpBuf++!=0x00)
    						break;
    					bPad--;
    				}
    				if (bPad==0)
    					dwImageSize = -1;
    			}
    		}
        }
    }

    return (UINT)(dwOverAllSize);
}


UINT
ParseVerst( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;

    LPRESITEM lpResItem = (LPRESITEM)lpBuffer;
    char far * lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

    LONG dwOverAllSize = 0L;

     VER_BLOCK VSBlock;
    WORD wPad = 0;
    WORD wPos = 0;

    while(dwImageSize>0) {

        GetVSBlock( &lpImage, &dwImageSize, &VSBlock );

        TRACE1("Key: %s\t", VSBlock.szKey);
        TRACE1("Value: %s\n", VSBlock.szValue);
        TRACE3("Len: %d\tSkip: %d\tType: %d\n", VSBlock.wBlockLen, VSBlock.wValueLen, VSBlock.wType );
        // check if this is the translation block
        if (!strcmp(VSBlock.szKey, "Translation" )){
            // This is the translation block let the localizer have it for now
            DWORD dwCodeLang = 0;
            LONG lDummy = 4;
            GetDWord( &VSBlock.pValue, &dwCodeLang, &lDummy);

            // Put the value in the string value
            wsprintf( &VSBlock.szValue[0], "%#08lX", dwCodeLang );
        }

        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in an accelerator
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        // we will need to calculate the correct ID for mike
        //Put the Id
        dwOverAllSize += PutDWord( &lpBuf, wPos++, &dwBufSize);


        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);

        lpResItem->lpszClassName = strcpy( lpStrBuf, VSBlock.szKey );
        lpStrBuf += strlen(lpResItem->lpszClassName)+1;

        lpResItem->lpszCaption = strcpy( lpStrBuf, VSBlock.szValue );
        lpStrBuf += strlen(lpResItem->lpszCaption)+1;


        // Put the size of the resource
        if (dwBufSize>0) {
            uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
        }

        // Check if we are alligned
        uiOffset += Allign( (LPLPBYTE)&lpStrBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += uiOffset-sizeof(RESITEM);
        lpResItem->dwSize = (DWORD)uiOffset;


        // Move to the next position
        lpResItem = (LPRESITEM) lpStrBuf;
        lpBuf = (BYTE far *)lpStrBuf;
        lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));
    }

    return (UINT)(dwOverAllSize);
}

 UINT GetVSBlock( BYTE far * far* lplpBuf, LONG* pdwSize, VER_BLOCK* pBlock )
{
    WORD wPad = 0;
    int  iToRead = 0;
    WORD wLen = 0;
    WORD wHead = 0;

    if(*lplpBuf==NULL)
        return 0;

    pBlock->pValue = *lplpBuf;
    wHead = GetWord( lplpBuf, &pBlock->wBlockLen, pdwSize );
    wHead += GetWord( lplpBuf, &pBlock->wValueLen, pdwSize );
    wHead += GetWord( lplpBuf, &pBlock->wType, pdwSize );

    // Get the Key name
    wHead += (WORD)GetStringW( lplpBuf, &pBlock->szKey[0], pdwSize, 100 );
    if(Pad4(wHead))
        wPad += (WORD)SkipByte( lplpBuf, 2, pdwSize );

    iToRead = pBlock->wValueLen;
    pBlock->wHead = wHead;

    // Check if we are going over the image len
    if (iToRead>*pdwSize) {
        // There is an error
        wPad += (WORD)SkipByte( lplpBuf, (UINT)*pdwSize, pdwSize );
        return wHead+wPad;
    }

    // Save the pointer to the Value field
    pBlock->pValue = (pBlock->pValue+wHead+wPad);

    if(pBlock->wType && iToRead){
        iToRead -= wPad>>1;
        // Get the string
        if (iToRead>MAXSTR) {
            *pdwSize -= iToRead*sizeofWord;
            *lplpBuf += iToRead*sizeofWord;
        } else {
                int n = 0;
                int iBytesRead = 0;
                if ((iToRead*sizeofWord)+wHead+wPad>pBlock->wBlockLen)
                    // Need to fix this up. Bug in the RC compiler?
                    iToRead -= ((iToRead*sizeofWord)+wHead+wPad - pBlock->wBlockLen)>>1;
                iBytesRead = GetStringW(lplpBuf, &pBlock->szValue[0], pdwSize, 256);
                //
                //  Some old version stamp has a NULL char in between
                //  Microsoft Corp. and the year of copyright.  GetString
                //  will return the number of byte read up to the NULL char.
                //  We need to skip the rest.
                //
                if (iBytesRead < iToRead*sizeofWord)
                {
                    iBytesRead += SkipByte(lplpBuf,
                                           iToRead*sizeofWord-iBytesRead,
                                           pdwSize);
                }
                iToRead = iBytesRead;
        }
    } else {
        SkipByte( lplpBuf, iToRead, pdwSize );
        *pBlock->szValue = '\0';
    }

    if (*pdwSize)
    {
        WORD far * lpw = (WORD far *)*lplpBuf;
        while((WORD)*(lpw)==0x0000)
        {
            wPad += (WORD)SkipByte( (BYTE far * far *)&lpw, 2, pdwSize );
            if ((*pdwSize)<=0)
            {
                break;
            }
        }
        *lplpBuf = (BYTE far *)lpw;
    }

    return (wHead+iToRead+wPad);
}

 UINT
PutVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK ver,
            LPSTR lpStr, BYTE far * far * lplpBlockSize, WORD* pwTrash)

{
    // We have to write the info in the VER_BLOCK in the new image
    // We want to remember were the block size field is so we can update it later

    WORD wHead = 0;
    WORD wValue = 0;
    WORD wPad = Pad4(ver.wHead);
    *pwTrash = 0;

    // Get the pointer to the header of the block
    BYTE far * pHead = ver.pValue-ver.wHead-wPad;
    BYTE far * lpNewImage = *lplpImage;
    // Copy the header of the block to the new image
    wHead = ver.wHead;
    if (*pdwSize>=(int)ver.wHead) {
        memcpy( *lplpImage, pHead, ver.wHead );
        *pdwSize -= ver.wHead;
        lpNewImage += ver.wHead;
    }

    // Check if padding is needed
    if ((wPad) && (*pdwSize>=(int)wPad)) {
        memset( *lplpImage+ver.wHead, 0, wPad );
        *pdwSize -= wPad;
        lpNewImage += wPad;
    }

    // Store the pointer to the block size WORD
    BYTE far * pBlockSize = *lplpImage;

    // Check if the value is a string or a BYTE array
    if(ver.wType) {
        // it is a string, copy the updated item
        // Check if we had a string in this field
        if(ver.wValueLen) {
            BYTE far * lpImageStr = *lplpImage+wHead+wPad;
            wValue = (WORD)PutStringW(&lpImageStr, lpStr, pdwSize);
            lpNewImage += wValue;

            // Check if padding is needed
            if ((Pad4(wValue)) && (*pdwSize>=(int)Pad4(wValue))) {
                memset( *lplpImage+ver.wHead+wValue+wPad, 0, Pad4(wValue) );
                *pdwSize -= Pad4(wValue);
                lpNewImage += Pad4(wValue);
            }

            WORD wPad1 = Pad4(wValue);
            WORD wFixUp = wValue/sizeofWord;
            *pwTrash = Pad4(ver.wValueLen);
            wValue += wPad1;
            // Fix to the strange behaviour of the ver.dll
            if((wPad1) && (wPad1>=*pwTrash)) {
                wValue -= *pwTrash;
            } else *pwTrash = 0;
            // Fix up the Value len field. We will put the len of the value without padding
            // The len will be in char so since the string is unicode will be twice the size
            memcpy( pBlockSize+2, &wFixUp, 2);
        }
    } else {
        // it is an array, just copy it in the new image buffer
        wValue = ver.wValueLen;
        if (*pdwSize>=(int)ver.wValueLen) {
            memcpy(*lplpImage+wHead+wPad, ver.pValue, ver.wValueLen);
            *pdwSize -= ver.wValueLen;
            lpNewImage += ver.wValueLen;
        }

        // Check if padding is needed
        if ((Pad4(ver.wValueLen)) && (*pdwSize>=(int)Pad4(ver.wValueLen))) {
            memset( *lplpImage+ver.wHead+ver.wValueLen+wPad, 0, Pad4(ver.wValueLen) );
            *pdwSize -= Pad4(ver.wValueLen);
            lpNewImage += Pad4(ver.wValueLen);
        }
        wPad += Pad4(ver.wValueLen);
    }

    *lplpBlockSize = pBlockSize;
    *lplpImage = lpNewImage;
    return wPad+wValue+wHead;
}


/*
 * Will return the matching LPRESITEM
 */
 LPRESITEM
GetItem( BYTE far * lpBuf, LONG dwNewSize, LPSTR lpStr )
{
    LPRESITEM lpResItem = (LPRESITEM) lpBuf;

    while(strcmp(lpResItem->lpszClassName, lpStr)) {
        lpBuf += lpResItem->dwSize;
        dwNewSize -= lpResItem->dwSize;
        if (dwNewSize<=0)
            return LPNULL;
        lpResItem = (LPRESITEM) lpBuf;
    }
    return lpResItem;
}


UINT
UpdateVerst( LPVOID lpNewBuf, LONG dwNewSize,
             LPVOID lpOldI, LONG dwOldImageSize,
             LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    /*
     * This Function is a big mess. It is like this because the RC compiler generate
     * some inconsistent code so we have to do a lot of hacking to get the VS working
     * In future, if ever ver.dll and the RC compiler will be fixed will be possible
     * fix some of the bad thing we have to do to get the updated VS as consistent as
     * possible with the old one
     */

    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    WORD wPos = 0;

    // Updated info
    WORD wUpdPos = 0;
    char szCaption[300];
    char szUpdCaption[300];
    char szUpdKey[100];

    DWORD dwOriginalOldSize = dwOldImageSize;
    LONG dwOverAllSize = 0l;

    WORD wPad = 0;

    // Pointer to the block size to fix up later
    BYTE far * lpVerBlockSize = LPNULL;
    BYTE far * lpSFIBlockSize = LPNULL;
    BYTE far * lpTrnBlockSize = LPNULL;
    BYTE far * lpStrBlockSize = LPNULL;
    BYTE far * lpTrnBlockName = LPNULL;
    BYTE far * lpDummy = LPNULL;

    LONG dwDummySize;

    WORD wVerBlockSize = 0;
    WORD wSFIBlockSize = 0;
    WORD wTrnBlockSize = 0;
    WORD wStrBlockSize = 0;
    WORD wTrash = 0;        // we need this to fix a bug in the RC compiler
    WORD wDefaultLang = 0x0409;

    // StringFileInfo
    VER_BLOCK SFI;   // StringFileInfo
    LONG lSFILen = 0;

    // Translation blocks
    VER_BLOCK Trn;
    LONG lTrnLen = 0;
    BOOL bHasTranslation=(NULL != GetItem( lpBuf, dwNewSize, "Translation"));
    BOOL bTrnBlockFilled=FALSE;

    VER_BLOCK Str;   // Strings

    // we read first of all the information from the VS_VERSION_INFO block
    VER_BLOCK VS_INFO; // VS_VERSION_INFO

    int iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &VS_INFO );

    // Write the block in the new image
    wVerBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, VS_INFO,
                                &VS_INFO.szValue[0], &lpVerBlockSize, &wTrash );

    dwOverAllSize = wVerBlockSize+wTrash;

    LONG lVS_INFOLen = VS_INFO.wBlockLen - iHeadLen;

    while(dwOldImageSize>0) {
        //Get the StringFileInfo
        iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &SFI );

        // Check if this is the StringFileInfo field
        if (!strcmp(SFI.szKey, "StringFileInfo")) {
            bTrnBlockFilled=TRUE;
            // Read all the translation blocks
            lSFILen = SFI.wBlockLen-iHeadLen;
            // Write the block in the new image
            wSFIBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, SFI,
                                         &SFI.szValue[0], &lpSFIBlockSize, &wTrash );
            dwOverAllSize += wSFIBlockSize+wTrash;

            while(lSFILen>0) {
                // Read the Translation block
                iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &Trn );
                // Calculate the right key name
                if ((lpResItem = GetItem( lpBuf, dwNewSize, Trn.szKey)) && bHasTranslation)  {
                	// We default to UNICODE for the 32 bit files
                    WORD wLang;
                    if(lpResItem)
                    {
                        if (lpResItem->dwLanguage != 0xffffffff)
                        {
                            wLang = LOWORD(lpResItem->dwLanguage);
                        }
                        else
                        {
                            wLang = wDefaultLang;
                        }
                    }
                    GenerateTransField( wLang, &Trn );

                    // Save the position for later Fixup
                    lpTrnBlockName = lpNewImage;
                }
                // Write the block in the new image
                wTrnBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, Trn,
                                             &Trn.szValue[0], &lpTrnBlockSize, &wTrash );
                dwOverAllSize += wTrnBlockSize+wTrash;
                lTrnLen = Trn.wBlockLen-iHeadLen;
                while(lTrnLen>0) {
                    // Read the Strings in the block
                    iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &Str );
                    lTrnLen -= iHeadLen;
                    TRACE2("Key: %s\tValue: %s\n", Str.szKey, Str.szValue );
                    TRACE3("Len: %d\tValLen: %d\tType: %d\n", Str.wBlockLen, Str.wValueLen, Str.wType );

                    strcpy(szCaption, Str.szValue);
                    // Check if this Item has been updated
                    if ((lpResItem = GetItem( lpBuf, dwNewSize, Str.szKey)))  {
                        strcpy( szUpdCaption, lpResItem->lpszCaption );
                        strcpy( szUpdKey, lpResItem->lpszClassName );
                    }
                    if (!strcmp( szUpdKey, Str.szKey)) {
                        strcpy( szCaption, szUpdCaption );
                        wUpdPos = 0;
                    }

                    // Write the block in the new image
                    wStrBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, Str,
                                                 szCaption, &lpStrBlockSize, &wTrash );
                    dwOverAllSize += wStrBlockSize+wTrash;

                    // Fix up the size of the block
                    if (dwNewImageSize>=0)
                        memcpy( lpStrBlockSize, &wStrBlockSize, 2);

                    wTrnBlockSize += wStrBlockSize + wTrash;
                }
                lSFILen -= Trn.wBlockLen;
                // Fix up the size of the block
                if (dwNewImageSize>=0)
                    memcpy( lpTrnBlockSize, &wTrnBlockSize, 2);

                wSFIBlockSize += wTrnBlockSize;
            }
            lVS_INFOLen -= SFI.wBlockLen;
            // Fix up the size of the block
            if (dwNewImageSize>=0)
                memcpy( lpSFIBlockSize, &wSFIBlockSize, 2);
            wVerBlockSize += wSFIBlockSize;

        } else {
            // this is another block skip it all
            lVS_INFOLen -= SFI.wValueLen+iHeadLen;


            // Check if this block is the translation field
            if (!strcmp(SFI.szKey, "Translation")) {
                // it is calculate the right value to place in the value field
                // We calculate automatically the value to have the correct
                // localized language in the translation field
                //wVerBlockSize += PutTranslation( &lpNewImage, &dwNewImageSize, SFI );
                // check if this is the translation block
                // This is the translation block let the localizer have it for now

                //
                // We do generate the Tranlsation filed from the language
                // We will have to update the block name as well
                //

                DWORD dwCodeLang = 0;
                if ((lpResItem = GetItem( lpBuf, dwNewSize, SFI.szKey)))
                {
                    WORD wLang = 0x0409;
                    if(lpResItem)
                        wLang = (LOWORD(lpResItem->dwLanguage)!=0xffff ? LOWORD(lpResItem->dwLanguage) : 0x0409);
                    dwCodeLang = GenerateTransField(wLang, FALSE);

                    if (bTrnBlockFilled)
                    {
                        // fix up the block name
                        GenerateTransField( wLang, &Trn );

                        // Write the block in the new image
                        dwDummySize = dwNewImageSize;
                        PutVSBlock( &lpTrnBlockName, &dwDummySize, Trn,
                                             &Trn.szValue[0], &lpDummy, &wTrash );

                        // Fix up the block size
                        memcpy( lpTrnBlockSize, &wTrnBlockSize, 2);
                    }
                    else
                    {
                        wDefaultLang = LOWORD(dwCodeLang);
                    }
                } else {
                    // Place the original value here
                    dwCodeLang =(DWORD)*(SFI.pValue);
                }
                LONG lDummy = 4;
                SFI.pValue -= PutDWord( &SFI.pValue, dwCodeLang, &lDummy );
            }

            // Write the block in the new image
            wVerBlockSize += (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, SFI,
                                         &SFI.szValue[0], &lpDummy, &wTrash );
            if (dwNewImageSize>=0)
                memcpy( lpVerBlockSize, &wVerBlockSize, 2);

            dwOverAllSize = wVerBlockSize+wTrash;
        }
    }

    // fix up the block size
    if (dwNewImageSize>=0)
        memcpy( lpVerBlockSize, &wVerBlockSize, 2);

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        BYTE bPad = (BYTE)Pad16((DWORD)(dwOverAllSize));
        dwOverAllSize += bPad;
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if(*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}

UINT GetStringU( PWCHAR pwStr, LPSTR pszStr )
{
    PWCHAR pwStart = pwStr;
    while (*pwStr!=0x0000) {
        *(pszStr++) = LOBYTE(*(pwStr++));
    }
    *(pszStr++) = LOBYTE(*(pwStr++));
    return (UINT)(pwStr-pwStart);
}


UINT
SkipByte( BYTE far * far * lplpBuf, UINT uiSkip, LONG* pdwSize )
{
    if(*pdwSize>=(int)uiSkip) {
        *lplpBuf += uiSkip;;
        *pdwSize -= uiSkip;
    }
    return uiSkip;
}


BYTE
GetDWord( BYTE far * far* lplpBuf, DWORD* dwValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofDWord){
        memcpy( dwValue, *lplpBuf, sizeofDWord);
        *lplpBuf += sizeofDWord;
        *pdwSize -= sizeofDWord;
    } else *dwValue = 0;
    return sizeofDWord;
}


BYTE
GetWord( BYTE far * far* lplpBuf, WORD* wValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofWord){
        memcpy( wValue, *lplpBuf, sizeofWord);
        *lplpBuf += sizeofWord;
        *pdwSize -= sizeofWord;
    } else *wValue = 0;
    return sizeofWord;
}


BYTE
GetByte( BYTE far * far* lplpBuf, BYTE* bValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofByte){
        memcpy(bValue, *lplpBuf, sizeofByte);
        *lplpBuf += sizeofByte;
        *pdwSize -= sizeofByte;
    } else *bValue = 0;
    return sizeofByte;
}


UINT
GetStringW( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize, WORD cLen )
{
    if(*lplpBuf==NULL)
        return 0;

    int cch = _WCSLEN((WCHAR*)*lplpBuf);
    if (*pdwSize>=cch){
    _WCSTOMBS( lpszText, (WCHAR*)*lplpBuf, cLen );
    *lplpBuf += (cch*sizeofWord);
        *pdwSize -= (cch*sizeofWord);
    } else *lplpBuf = '\0';
    return(cch*2);
}


UINT
GetStringA( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize )
{
    if(*lplpBuf==NULL)
        return 0;

    int iSize = strlen((char*)*lplpBuf)+1;
    if (*pdwSize>=iSize){
        memcpy( lpszText, *lplpBuf, iSize);
        *lplpBuf += iSize;
        *pdwSize -= iSize;
    } else *lplpBuf = '\0';
    return iSize;
}


UINT
GetPascalString( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wMaxLen, LONG* pdwSize )
{
    // Get the length of the string
    WORD wstrlen = 0;
    WORD wMBLen = 0;
    GetWord( lplpBuf, &wstrlen, pdwSize );

    if ((wstrlen+1)>wMaxLen) {
        *pdwSize -= wstrlen*2;
        *lplpBuf += wstrlen*2;
    } else {
        if (wstrlen) {
	        WCHAR* lpwszStr = new WCHAR[wstrlen+1];
	        if (!lpwszStr)
	            *pdwSize =-1;
	        else {
	        	memcpy(lpwszStr, *lplpBuf, (wstrlen*2));
	        	*(lpwszStr+wstrlen) = 0;
	        	
                if(lstrlenW(lpwszStr) < wstrlen)
                {
                    // We have at least one \0 in the string.
                    // This is done to convert \0 in the string in to \\0
                    // First pass check how many \0 we have
                    int c = wstrlen;
                    int czero = 0;
                    while(c)
                    {
                        c--;
                        if((WORD)*(lpwszStr+c)==0)
                        {
                            czero++;
                        }
                    }

                    // Now that we have the size reallocate the buffer
                    delete lpwszStr;
                    if ((wstrlen+czero*_NULL_TAG_LEN_+1)>wMaxLen) {
                        *pdwSize -= wstrlen*2;
                        *lplpBuf += wstrlen*2;
                    }
                    else {
                        WCHAR* lpwszStr = new WCHAR[wstrlen+czero*_NULL_TAG_LEN_+1];
                        if (!lpwszStr)
	                        *pdwSize =-1;
	                    else {
                            int clen = 0;
                            c = 0;
                            WCHAR* lpwStr = (WCHAR*)*lplpBuf;
                            WCHAR* lpwStrW = lpwszStr;
                            while(c<wstrlen)
                            {
                                if((WORD)*(lpwStr+c)==0)
                                {
                                    memcpy(lpwStrW, _W_RLT_NULL_, (_NULL_TAG_LEN_*2));
                                    lpwStrW += _NULL_TAG_LEN_;
                                    clen += _NULL_TAG_LEN_-1;
                                }
                                else
                                    *lpwStrW++ = *(lpwStr+c);

                                clen++;
                                c++;
                            }

                            *(lpwszStr+clen) = 0;
                            wMBLen = (WORD)_WCSTOMBS( lpszText, (WCHAR*)lpwszStr, wMaxLen);
                            delete lpwszStr;
                        }
                    }
                }
                else
                {
	            	wMBLen = (WORD)_WCSTOMBS( lpszText, (WCHAR*)lpwszStr, wMaxLen);
                    delete lpwszStr;
                }

	        }
        }
        *(lpszText+wMBLen) = 0;
        *lplpBuf += wstrlen*2;
        *pdwSize -= wstrlen*2;
    }
    return(wstrlen+1);
}


UINT
PutMsgStr( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wFlags, LONG* pdwSize )
{
    // Put the length of the entry
    UINT uiLen = strlen(lpszText)+1;

    //for unicode string;
    WCHAR* lpwszStr = new WCHAR[uiLen*2];

    if(wFlags && uiLen)
         uiLen = _MBSTOWCS(lpwszStr, lpszText, uiLen*sizeofWord)*sizeofWord;

    UINT uiPad = Pad4(uiLen);
    UINT uiWrite = PutWord(lplpBuf, (WORD) uiLen+4+uiPad, pdwSize);

    // Write the flag
    uiWrite += PutWord(lplpBuf, wFlags, pdwSize);

    // Write the string
    if (*pdwSize>=(int) uiLen)
        if (uiLen){
            if (wFlags)
                memcpy(*lplpBuf, lpwszStr, uiLen);
            else
                memcpy(*lplpBuf, lpszText, uiLen);

            *lplpBuf += uiLen;
            *pdwSize -= uiLen;
            uiWrite += uiLen;
        }
     else
        *pdwSize = -1;

    // Padding
    while(uiPad) {
        uiWrite += PutByte(lplpBuf, 0, pdwSize);
        uiPad--;
    }

    delete lpwszStr;
    return uiWrite;
}


UINT
GetMsgStr( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wMaxLen, WORD* pwLen, WORD* pwFlags, LONG* pdwSize )
{

    // Get the length of the entry
    UINT uiRead = GetWord( lplpBuf, pwLen, pdwSize );

    // Get the flag
    uiRead += GetWord( lplpBuf, pwFlags, pdwSize );

    if (!*pwLen)
        return 0;

    // If flags=1 then the string is a unicode str else is ASCII
    // Bug #354 We cannot assume the string is NULL terminated.
    // There is no specification if the string is a NULL terminated string but since
    // the doc say that the format is similar to the stringtable then
    // we have to assume the string is not NULL terminated

    WORD wstrlen = *pwLen-4; // Get the len of the entry and subtract 4 (len + flag)
    WORD wMBLen = 0;
    if ((wstrlen+1)>wMaxLen) {
    } else {
        if (wstrlen && *pwFlags) {
            wMBLen = (WORD)_WCSTOMBS( lpszText, (WCHAR*)*lplpBuf, wMaxLen );
        } else memcpy( lpszText, (char*)*lplpBuf, wstrlen );

        *(lpszText+(wstrlen)) = 0;
        TRACE1("Caption: %Fs\n", (wstrlen<256 ? lpszText : "\n"));
    }
    *lplpBuf += *pwLen-uiRead;
    *pdwSize -= *pwLen-uiRead;

    return(wstrlen);
}



UINT
GetNameOrOrd( BYTE far * far* lplpBuf,  WORD* wOrd, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if(*lplpBuf==NULL)
        return 0;

    *wOrd = (WORD)(((**lplpBuf)<<8)+(*(*lplpBuf+1)));
    if((*wOrd)==0xFFFF) {
        // This is an Ordinal
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        *lpszText = '\0';
    } else {
        uiSize += GetStringW( lplpBuf, lpszText, pdwSize, 128 );
        *wOrd = 0;
    }
    return uiSize;
}


UINT
GetCaptionOrOrd( BYTE far * far* lplpBuf,  WORD* wOrd, LPSTR lpszText, LONG* pdwSize,
	WORD wClass, DWORD dwStyle )
{
    UINT uiSize = 0;

    if(*lplpBuf==NULL)
        return 0;

    *wOrd = (WORD)(((**lplpBuf)<<8)+(*(*lplpBuf+1)));
    if((*wOrd)==0xFFFF) {
        // This is an Ordinal
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        *lpszText = '\0';
    } else {
        uiSize += GetStringW( lplpBuf, lpszText, pdwSize, MAXSTR );
        *wOrd = 0;
    }
    return uiSize;
}


UINT
GetClassName( BYTE far * far* lplpBuf,  WORD* wClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if(*lplpBuf==NULL)
        return 0;

    *wClass = (WORD)(((**lplpBuf)<<8)+(*(*lplpBuf+1)));
    if( *wClass==0xFFFF ) {
        // This is an Ordinal
        uiSize += GetWord( lplpBuf, wClass, pdwSize );
        uiSize += GetWord( lplpBuf, wClass, pdwSize );
        *lpszText = '\0';
    } else {
        uiSize += GetStringW( lplpBuf, lpszText, pdwSize, 128 );
        *wClass = 0;
    }
    return uiSize;
}

 LONG ReadFile(CFile* pFile, UCHAR * pBuf, LONG lRead)
{
    LONG lLeft = lRead;
    WORD wRead = 0;
    DWORD dwOffset = 0;

    while(lLeft>0){
        wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
        if (wRead!=_lread( (HFILE)pFile->m_hFile, (UCHAR *)pBuf+dwOffset, wRead))
            return 0l;
        lLeft -= wRead;
        dwOffset += wRead;
    }
    return dwOffset;

}

 UINT CopyFile( CFile* pfilein, CFile* pfileout )
{
    LONG lLeft = pfilein->GetLength();
    WORD wRead = 0;
    DWORD dwOffset = 0;
    BYTE far * pBuf = (BYTE far *) new BYTE[32739];

    if(!pBuf)
        return ERROR_NEW_FAILED;

    while(lLeft>0){
        wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
        if (wRead!= pfilein->Read( pBuf, wRead))
            return ERROR_FILE_READ;
        pfileout->Write( pBuf, wRead );
        lLeft -= wRead;
        dwOffset += wRead;
    }

    delete []pBuf;
    return ERROR_NO_ERROR;
}

 UINT GetRes(
                 BYTE far * far* lplpBuffer,
                 UINT* puiBufSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwLang, DWORD* dwSize, DWORD* dwFileOffset )
{
    UINT uiSize = 0l;
	LONG lSize = *puiBufSize;

    uiSize = GetWord( lplpBuffer, wTypeId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszTypeId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, Pad4(uiSize), (LONG*)&lSize );

    uiSize += GetWord( lplpBuffer, wNameId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszNameId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, Pad4(uiSize), (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwLang, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwSize, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwFileOffset, (LONG*)&lSize );

	*puiBufSize = lSize;
    return uiSize;
}

 UINT GetUpdatedRes(
                 BYTE far * far* lplpBuffer,
                 UINT* puiBufSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwLang, DWORD* dwSize )
{
    UINT uiSize = 0l;
	LONG lSize = *puiBufSize;

    uiSize = GetWord( lplpBuffer, wTypeId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszTypeId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, Pad4(uiSize), (LONG*)&lSize );

    uiSize += GetWord( lplpBuffer, wNameId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszNameId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, Pad4(uiSize), (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwLang, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwSize, (LONG*)&lSize );

	*puiBufSize = lSize;

    return 0;
}


UINT
PutClassName( BYTE far * far* lplpBuf,  WORD wClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if( (wClass==0x0080) ||
        (wClass==0x0081) ||
        (wClass==0x0082) ||
        (wClass==0x0083) ||
        (wClass==0x0084) ||
        (wClass==0x0085)
        ) {
        // This is an Ordinal
        uiSize += PutWord(lplpBuf, 0xFFFF, pdwSize);
        uiSize += PutWord(lplpBuf, wClass, pdwSize);
    } else {
        uiSize += PutStringW(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


UINT
PutPascalStringW( BYTE far * far* lplpBuf, LPSTR lpszText, WORD wLen, LONG* pdwSize )
{
	UINT uiSize = 0;
    WCHAR * pWStrBuf = (WCHAR*)&wszUpdCaption;
  	// calculate the necessary lenght
	WORD wWCLen = (WORD)_MBSTOWCS( pWStrBuf, lpszText, 0 );
	
    if(wWCLen>MAXSTR)
    {
        // Allocate a new buffer
        pWStrBuf = new WCHAR[wWCLen+1];
    }

    WCHAR * pWStr = pWStrBuf;

    // convert the string for good
    wLen = _MBSTOWCS( pWStr, lpszText, wWCLen )-1;

    WCHAR * wlpRltNull = pWStr;
    WCHAR * wlpStrEnd = pWStr+wLen;

    // First of all check for _RLT32_NULL_ tag
    while((wlpRltNull = wcsstr(wlpRltNull, _W_RLT_NULL_)) && (wlpStrEnd>=wlpRltNull))
    {
        // remove the null tag and place \0
        *wlpRltNull++ = 0x0000;
        wlpRltNull = (WCHAR*)memmove(wlpRltNull, wlpRltNull+_NULL_TAG_LEN_-1, (short)(wlpStrEnd-(wlpRltNull+_NULL_TAG_LEN_-1))*2 );
        wlpStrEnd -= (_NULL_TAG_LEN_-1);
    }

    wLen = (WORD)(wlpStrEnd-pWStr);

	// We will use the buffer provided by the szUpdCaption string to calculate
	// the necessary lenght
	//wWCLen = _MBSTOWCS( (WCHAR*)&szUpdCaption, lpszText, 0 ) - 1;
	//if (wWCLen>1)
	//	wLen = wWCLen;
	uiSize = PutWord( lplpBuf, wLen, pdwSize );
	
    if (*pdwSize>=(int)(wLen*2)){
        if(wLen) {
        	//wLen = _MBSTOWCS( (WCHAR*)*lplpBuf, lpszText, wWCLen );
            memcpy(*lplpBuf, pWStr, wLen*2);
        }
        *lplpBuf += wLen*2;
        *pdwSize -= wLen*2;
    } else *pdwSize = -1;

    if(pWStrBuf!=(WCHAR*)&wszUpdCaption)
        delete pWStrBuf;

    return uiSize+(wWCLen*2);
}

 void GenerateTransField( WORD wLang, VER_BLOCK * pVer )
{
    // Get the DWORD value
    DWORD dwValue = GenerateTransField( wLang, TRUE );
    char buf[9];


    // Put the value in the string value
    wsprintf( &buf[0], "%08lX", dwValue );

    TRACE3("\t\tGenerateTransField: Old: %s\tNew : %s\t dwValue: %lX\n", pVer->szKey, buf, dwValue );
    // Just check if we are in the right place. Should never have problem
    if(strlen(pVer->szKey)==8) {
        // We have to change the header in the image, not just the szKey field
        // Get the pointer to he begin of the field
        WORD wPad = Pad4(pVer->wHead);
        LONG cbDummy =18;
        BYTE far * pHead = pVer->pValue-pVer->wHead-wPad;
        pHead += 6; // Move at the begin of the string
        PutStringW(&pHead, buf, &cbDummy);
    }
}

 DWORD GenerateTransField(WORD wLang, BOOL bMode)
{
    // we have to generate a table to connect
    // the language with the correct code page

    WORD wCP = 1200;        // Unicode

    if (bMode)
    	return MAKELONG( wCP, wLang );
    else return MAKELONG( wLang, wCP );
}

 LONG Allign( LPLPBYTE lplpBuf, LONG* plBufSize, LONG lSize )
{
   LONG lRet = 0;
   BYTE bPad =(BYTE)PadPtr(lSize);
   lRet = bPad;
   if (bPad && *plBufSize>=bPad) {
      while(bPad && *plBufSize)  {
         **lplpBuf = 0x00;
         *lplpBuf += 1;
         *plBufSize -= 1;
         bPad--;
      }
   }
   return lRet;
}

UINT
ParseEmbeddedFile( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
	// we will return just one item so the iodll will handle this resource as
	// something valid. We will not bother doing anything else. The only thing
	// we are interesed is the raw data in the immage, but if we don't return at
	// least one item IODLL will consider the resource empty.
	BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;
    LONG dwOverAllSize = 0;

	TRACE1("ParseEmbeddedFile: dwISize=%ld\n", dwISize);

	dwOverAllSize += PutDWord( &lpBuf, sizeof(RESITEM), &dwBufSize);

    // We have the size and pos in a cursor but we are not interested now
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

    // we don't have checksum and style
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    //Put the Flag
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // The ID will be just 1
    dwOverAllSize += PutDWord( &lpBuf, 1, &dwBufSize);

    // we don't have the resID, and the Type Id
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the language
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the codepage or the font name
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

    // Let's put null were we don;t have the strings
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWordPtr( &lpBuf, 0, &dwBufSize);

    // we just return. This is enough for IODLL
    return (UINT)(dwOverAllSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\mac\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\inf\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include "..\common\rwdll.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\inf\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	rwinf.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\inf\rwinf.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       rwinf.cpp
//
//  Contents:   Implementation for the Windows NT 3.51 inf Read/Write module
//
//  Classes:
//
//  History:    13-Mar-95   alessanm    created
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <afxdllx.h>
#include "inf.h"
#include "..\common\helper.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define RWTAG "INF"

#define INF_TYPE        11
#define MAX_INF_TEXT_LINE    55
#define Pad4(x) ((((x+3)>>2)<<2)-x)

typedef struct tagUpdResList
{
    WORD *  pTypeId;
    BYTE *  pTypeName;
    WORD *  pResId;
    BYTE *  pResName;
    DWORD * pLang;
    DWORD * pSize;
    struct tagUpdResList* pNext;
} UPDATEDRESLIST, *PUPDATEDRESLIST;

class CLoadedFile : public CObject
{
public:
    CLoadedFile(LPCSTR lpfilename);

    CInfFile m_infFile;
    CString  m_strFileName;
};

CLoadedFile::CLoadedFile(LPCSTR lpfilename)
{
    TRY
    {
        m_infFile.Open(lpfilename, CFile::modeRead | CFile::shareDenyNone);
    }
    CATCH(CFileException, pfe)
    {
        AfxThrowFileException(pfe->m_cause, pfe->m_lOsError);
    }
    END_CATCH

    m_strFileName = lpfilename;
}


/////////////////////////////////////////////////////////////////////////////
// Function Declarations

LONG
WriteResInfo(
    BYTE** lplpBuffer, LONG* plBufSize,
    WORD wTypeId, LPCSTR lpszTypeId, BYTE bMaxTypeLen,
    WORD wNameId, LPCSTR lpszNameId, BYTE bMaxNameLen,
    DWORD dwLang,
    DWORD dwSize, DWORD dwFileOffset );

CInfFile * LoadFile(LPCSTR lpfilename);

PUPDATEDRESLIST CreateUpdateResList(BYTE * lpBuffer, UINT uiBufSize);
PUPDATEDRESLIST FindId(LPCSTR pstrId, PUPDATEDRESLIST pList);

/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

CObArray g_LoadedFile;

//[registration]
extern "C"
BOOL    FAR PASCAL RWGetTypeString(LPSTR lpszTypeName)
{
    strcpy( lpszTypeName, RWTAG );
    return FALSE;
}

extern "C"
BOOL    FAR PASCAL RWValidateFileType(LPCSTR lpszFilename)
{
    TRACE("RWINF.DLL: RWValidateFileType()\n");

    // Check file exstension and try to open it
    if(strstr(lpszFilename, ".INF")!=NULL || strstr(lpszFilename, ".inf")!=NULL)
        return TRUE;

    return FALSE;
}

extern "C"
DllExport
UINT
APIENTRY
RWReadTypeInfo(
    LPCSTR lpszFilename,
    LPVOID lpBuffer,
    UINT* puiSize
    )
{
    TRACE("RWINF.DLL: RWReadTypeInfo()\n");
    UINT uiError = ERROR_NO_ERROR;

    if (!RWValidateFileType(lpszFilename))
        return ERROR_RW_INVALID_FILE;
    //
    // Open the file
    //
    CInfFile * pinfFile;
    TRY
    {
        pinfFile = LoadFile(lpszFilename);
    }
    CATCH(CFileException, pfe)
    {
        return pfe->m_cause + IODLL_LAST_ERROR;
    }
    END_CATCH

    //
    // Read the data and fill the iodll buffer
    //
    // Get to the beginning of the localization section
    //
    if(!pinfFile->SeekToLocalize())
        return ERROR_RW_NO_RESOURCES;

    CString strSection;
    CString strLine;
    CString strTag;
    CInfLine infLine;

    BYTE ** pBuf = (BYTE**)&lpBuffer;
    LONG lBufSize = 0;

    while(pinfFile->ReadTextSection(strSection))
    {
        while(pinfFile->ReadSectionString(infLine))
        {
            strTag = strSection + '.' + infLine.GetTag();
            lBufSize += WriteResInfo(
                 pBuf, (LONG*)puiSize,
                 INF_TYPE, "", 0,
                 0, strTag, 255,
                 0l,
                 infLine.GetTextLength()+1, pinfFile->GetLastFilePos() );
        }
    }

    *puiSize = lBufSize;

    return uiError;
}

extern "C"
DllExport
DWORD
APIENTRY
RWGetImage(
    LPCSTR  lpszFilename,
    DWORD   dwImageOffset,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
    UINT uiError = ERROR_NO_ERROR;

    //
    // Open the file
    //
    CInfFile * pinfFile;
    TRY
    {
        pinfFile = LoadFile(lpszFilename);

    }
    CATCH(CFileException, pfe)
    {
        return pfe->m_cause + IODLL_LAST_ERROR;
    }
    END_CATCH

    //
    // Seek to the string to retrieve and read it
    //
    CInfLine infLine;

    pinfFile->Seek( dwImageOffset, SEEK_SET );
    pinfFile->ReadSectionString(infLine);

    //
    // Fill the buffer with the string
    //
    if(infLine.GetTextLength()+1<=(LONG)dwSize)
    {
        memcpy(lpBuffer, infLine.GetText(), infLine.GetTextLength()+1);
        uiError = infLine.GetTextLength()+1;
    }
    else
        uiError = 0;

    return (DWORD)uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWParseImage(
    LPCSTR  lpszType,
    LPVOID  lpImageBuf,
    DWORD   dwImageSize,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
    UINT uiSizeOfDataStruct = strlen((LPCSTR)lpImageBuf)+sizeof(RESITEM);

    if(uiSizeOfDataStruct<=dwSize)
    {
        //
        // We have to fill the RESITEM Struct
        //
        LPRESITEM pResItem = (LPRESITEM)lpBuffer;
        memset(pResItem, '\0', uiSizeOfDataStruct);

        pResItem->dwSize = uiSizeOfDataStruct;
        pResItem->lpszCaption = (LPSTR)memcpy( ((BYTE*)pResItem)+sizeof(RESITEM), lpImageBuf, dwImageSize);        // Caption
    }

    return uiSizeOfDataStruct;
}

extern"C"
DllExport
UINT
APIENTRY
RWWriteFile(
    LPCSTR          lpszSrcFilename,
    LPCSTR          lpszTgtFilename,
    HANDLE          hResFileModule,
    LPVOID          lpBuffer,
    UINT            uiSize,
    HINSTANCE       hDllInst,
    LPCSTR          lpszSymbolPath
    )
{
    UINT uiError = ERROR_NO_ERROR;

    // Get the handle to the IODLL
    hDllInst = LoadLibrary("iodll.dll");
    if (!hDllInst)
        return ERROR_DLL_LOAD;

    DWORD (FAR PASCAL * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
    // Get the pointer to the function to extract the resources image
    lpfnGetImage = (DWORD (FAR PASCAL *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
                        GetProcAddress( hDllInst, "RSGetResImage" );
    if (lpfnGetImage==NULL) {
        FreeLibrary(hDllInst);
        return ERROR_DLL_LOAD;
    }

    //
    // Get the handle to the source file
    //
    CInfFile * psrcinfFile;
    TRY
    {
        psrcinfFile = LoadFile(lpszSrcFilename);

    }
    CATCH(CFileException, pfe)
    {
        return pfe->m_cause + IODLL_LAST_ERROR;
    }
    END_CATCH

    //
    // Create the target file
    //
    CFile tgtFile;
    CFileException fe;
    if(!tgtFile.Open(lpszTgtFilename, CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyNone, &fe))
    {
        return fe.m_cause + IODLL_LAST_ERROR;
    }

    //
    // Copy the part of the file that is not localizable
    //
    LONG lLocalize = psrcinfFile->SeekToLocalize();
    const BYTE * pStart = psrcinfFile->GetBuffer();

    if(lLocalize==-1)
    {
        // the file has no localizable info  in it just copy it
        lLocalize = psrcinfFile->SeekToEnd();
    }

    TRY
    {
        tgtFile.Write(pStart, lLocalize);
    }
    CATCH(CFileException, pfe)
    {
        return pfe->m_cause + IODLL_LAST_ERROR;
    }
    END_CATCH

    //
    // Create the list of updated resources
    //
    PUPDATEDRESLIST pResList = CreateUpdateResList((BYTE*)lpBuffer, uiSize);

    //
    // What we have now is a part that is mized. Part of it has localizable
    // information and part has none.
    // We will read each section and decide if is a localizable section or not.
    // If it is we will update it otherwise just copy it
    //
    CString strSection, str;
    CString strLang = psrcinfFile->GetLanguage();
    LONG lEndPos, lStartPos;
    CInfLine infLine;

    while(psrcinfFile->ReadSection(strSection))
    {
        TRY
        {
            tgtFile.Write(strSection, strSection.GetLength());
            tgtFile.Write("\r\n", 2);
        }
        CATCH(CFileException, pfe)
        {
            return pfe->m_cause + IODLL_LAST_ERROR;
        }
        END_CATCH

        if(strSection.Find(strLang)==-1)
        {
            //
            // This is not a localizable section
            //
            lStartPos = psrcinfFile->Seek(0, SEEK_CUR);

            //
            // Read the next section untill we find a localizable section
            //
            while(psrcinfFile->ReadSection(strSection))
            {
                if(strSection.Find(strLang)!=-1)
                    break;
            }

            //
            // Where are we now?
            //

            lEndPos = psrcinfFile->Seek(0, SEEK_CUR) - strSection.GetLength()-2;

            //
            // Make sure we are not at the end of the file
            //
            if(lEndPos<=lStartPos)
            {
                // we have no more section so copy all is left
                lEndPos = psrcinfFile->Seek(0, SEEK_END) - 1;
            }

            //
            // copy the full block
            //

            pStart = psrcinfFile->GetBuffer(lStartPos);
            TRY
            {
                tgtFile.Write(pStart, lEndPos-lStartPos);
            }
            CATCH(CFileException, pfe)
            {
                return pfe->m_cause + IODLL_LAST_ERROR;
            }
            END_CATCH

            psrcinfFile->Seek(lEndPos, SEEK_SET);
        }
        else
        {
            //
            // This is a localizable section
            // Read all the strings and see if they have been updated
            //
            CString strId;
            PUPDATEDRESLIST pListItem;
            BYTE * pByte;

            lEndPos = psrcinfFile->Seek(0, SEEK_CUR);

            while(psrcinfFile->ReadSectionString(str))
            {
                str += "\r\n";

                infLine = str;

                //
                // Check if we need to update this string
                //
                strId = strSection + "." + infLine.GetTag();

                if(pListItem = FindId(strId, pResList))
                {
                    // allocate the buffer to hold the resource data
                    pByte = new BYTE[*pListItem->pSize];
                    if(!pByte){
                        uiError = ERROR_NEW_FAILED;
                        goto exit;
                    }

                    // get the data from the iodll
                    LPSTR	lpType = NULL;
        			LPSTR	lpRes = NULL;
        			if (*pListItem->pTypeId) {
        				lpType = (LPSTR)((WORD)*pListItem->pTypeId);
        			} else {
        				lpType = (LPSTR)pListItem->pTypeName;
        			}
        			if (*pListItem->pResId) {
        				lpRes = (LPSTR)((WORD)*pListItem->pResId);
        			} else {
        				lpRes = (LPSTR)pListItem->pResName;
        			}

        			DWORD dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
        											lpType,
        											lpRes,
        											*pListItem->pLang,
        											pByte,
        											*pListItem->pSize
        						   					);

                    if(dwImageBufSize!=*pListItem->pSize)
                    {
                        // something is wrong...
                        delete []pByte;
                    }
                    else {

                        infLine.ChangeText((LPCSTR)pByte);

                        //
                        // Now we have the updated image...
                        //

                        //
                        // Check how long is the Data and split it in to lines
                        //
                        if(infLine.GetTextLength()>MAX_INF_TEXT_LINE)
                        {
                            //
                            // First write the tag
                            //
                            str = infLine.GetData();
                            int iSpaceLen = str.Find('=')+1;
                            int iTagLen = 0;

                            TRY
                            {
                                tgtFile.Write(str, iSpaceLen);
                            }
                            CATCH(CFileException, pfe)
                            {
                                return pfe->m_cause + IODLL_LAST_ERROR;
                            }
                            END_CATCH

                            //
                            // Now write the rest
                            //
                            int iExtra, iMaxStr;
                            CString strLine;
                            CString strSpace( ' ', iSpaceLen+1 );
                            BOOL bFirstLine = TRUE;

                            strSpace += '\"';
                            str = infLine.GetText();
                            str.TrimLeft();

                            while(str.GetLength()>MAX_INF_TEXT_LINE)
                            {
                                iMaxStr = str.GetLength();

                                strLine = str.Left(MAX_INF_TEXT_LINE);

                                //
                                // Check if we are in the middle of a word
                                //
                                iExtra = 0;
                                while((iMaxStr>MAX_INF_TEXT_LINE+iExtra) && str.GetAt(MAX_INF_TEXT_LINE+iExtra)!=' ')
                                {
                                    strLine += str.GetAt(MAX_INF_TEXT_LINE+iExtra++);
                                }

                                //
                                // Make sure the spaces are the last thing
                                //
                                while((iMaxStr>MAX_INF_TEXT_LINE+iExtra) && str.GetAt(MAX_INF_TEXT_LINE+iExtra)==' ')
                                {
                                    strLine += str.GetAt(MAX_INF_TEXT_LINE+iExtra++);
                                }

                                str = str.Mid(MAX_INF_TEXT_LINE+iExtra);
                                if(str.IsEmpty())
                                {
                                    //
                                    // This string is all done write it as is, we can't break it
                                    //
                                    strLine += "\r\n";
                                }
                                else strLine += "\"+\r\n";

                                if(bFirstLine)
                                {
                                    strLine = " " + strLine;
                                    bFirstLine = FALSE;

                                } else
                                {
                                    strLine = strSpace + strLine;
                                }

                                TRY
                                {
                                    tgtFile.Write(strLine, strLine.GetLength());
                                }
                                CATCH(CFileException, pfe)
                                {
                                    return pfe->m_cause + IODLL_LAST_ERROR;
                                }
                                END_CATCH

                                //str = str.Mid(MAX_INF_TEXT_LINE+iExtra);
                            }

                            if(bFirstLine)
                            {
                                strLine = " " + str;
                            } else
                            {
                                if(!str.IsEmpty())
                                    strLine = strSpace + str;
                                else strLine = "";
                            }

                            if(!strLine.IsEmpty())
                            {
                                TRY
                                {
                                    tgtFile.Write(strLine, strLine.GetLength());
                                    tgtFile.Write("\r\n", 2);
                                }
                                CATCH(CFileException, pfe)
                                {
                                    return pfe->m_cause + IODLL_LAST_ERROR;
                                }
                                END_CATCH
                            }
                        }
                        else
                        {
                            TRY
                            {
                                tgtFile.Write(infLine.GetData(), infLine.GetDataLength());
                                tgtFile.Write("\r\n", 2);
                            }
                            CATCH(CFileException, pfe)
                            {
                                return pfe->m_cause + IODLL_LAST_ERROR;
                            }
                            END_CATCH
                        }

                        delete []pByte;
                    }
                }
                else
                {
                    TRY
                    {
                        tgtFile.Write(infLine.GetData(), infLine.GetDataLength());
                    }
                    CATCH(CFileException, pfe)
                    {
                        return pfe->m_cause + IODLL_LAST_ERROR;
                    }
                    END_CATCH
                }

                lEndPos = psrcinfFile->Seek(0, SEEK_CUR);
            }
        }
    }

exit:
    tgtFile.Close();

    if(pResList)
        delete []pResList;

    return uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWUpdateImage(
    LPCSTR  lpszType,
    LPVOID  lpNewBuf,
    DWORD   dwNewSize,
    LPVOID  lpOldImage,
    DWORD   dwOldImageSize,
    LPVOID  lpNewImage,
    DWORD*  pdwNewImageSize
    )
{
    UINT uiError = ERROR_NO_ERROR;

    //
    // Get the new string
    //
    LPCSTR lpNewStr = (LPCSTR)(((LPRESITEM)lpNewBuf)->lpszCaption);

    //
    // Copy the string in the new image buffer
    //

    int iLen = strlen(lpNewStr)+1;
    if(iLen<=(LONG)*pdwNewImageSize)
    {
        memcpy(lpNewImage, lpNewStr, iLen);
    }

    *pdwNewImageSize = iLen;

    return uiError;
}

///////////////////////////////////////////////////////////////////////////
// Functions implementation

//=============================================================================
//  WriteResInfo
//
//  Fill the buffer to pass back to the iodll
//=============================================================================

LONG WriteResInfo(
    BYTE** lplpBuffer, LONG* plBufSize,
    WORD wTypeId, LPCSTR lpszTypeId, BYTE bMaxTypeLen,
    WORD wNameId, LPCSTR lpszNameId, BYTE bMaxNameLen,
    DWORD dwLang,
    DWORD dwSize, DWORD dwFileOffset )
{
    LONG lSize = 0;
    lSize = PutWord( lplpBuffer, wTypeId, plBufSize );
    lSize += PutStringA( lplpBuffer, (LPSTR)lpszTypeId, plBufSize );   // Note: PutStringA should get LPCSTR and not LPSTR
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutWord( lplpBuffer, wNameId, plBufSize );
    lSize += PutStringA( lplpBuffer, (LPSTR)lpszNameId, plBufSize );
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutDWord( lplpBuffer, dwLang, plBufSize );
    lSize += PutDWord( lplpBuffer, dwSize, plBufSize );
    lSize += PutDWord( lplpBuffer, dwFileOffset, plBufSize );

    return (LONG)lSize;
}

CInfFile * LoadFile(LPCSTR lpfilename)
{
    // Check if we have loaded the file before
    int c = (int)g_LoadedFile.GetSize();
    CLoadedFile * pLoaded;
    while(c)
    {
        pLoaded = (CLoadedFile*)g_LoadedFile.GetAt(--c);
        if(pLoaded->m_strFileName==lpfilename)
            return &pLoaded->m_infFile;
    }

    // The file need to be added to the list
    pLoaded = new CLoadedFile(lpfilename);

    g_LoadedFile.Add((CObject*)pLoaded);

    return &pLoaded->m_infFile;
}


PUPDATEDRESLIST CreateUpdateResList(BYTE * lpBuffer, UINT uiBufSize)
{
    //
    // Walk the buffer and count how many resources we have
    //
    int iResCount = 0;
    int iBufSize = uiBufSize;
    int iResSize = 0;
    BYTE * pBuf = lpBuffer;
    while(iBufSize>0)
    {
        iResSize = 2;
        iResSize += strlen((LPSTR)(pBuf+iResSize))+1;
        iResSize += Pad4(iResSize);

        iResSize += 2;
        iResSize += strlen((LPSTR)(pBuf+iResSize))+1;
        iResSize += Pad4(iResSize);

        iResSize += 4*2;

        if(iResSize<=iBufSize)
        {
            iBufSize -= iResSize;
            pBuf = pBuf + iResSize;
            iResCount++;
        }
    }

    //
    // Allocate the buffer that will hold the list
    //
    if(!iResCount)
        return NULL;

    pBuf = lpBuffer;
    iBufSize = uiBufSize;

    PUPDATEDRESLIST pListHead = new UPDATEDRESLIST[iResCount];

    if(pListHead==NULL)
        AfxThrowMemoryException();

    memset(pListHead, 0, sizeof(UPDATEDRESLIST)*iResCount);

    PUPDATEDRESLIST pList = pListHead;
    BYTE bPad = 0;
    WORD wSize = 0;
    while(iBufSize>0) {
        pList->pTypeId = (WORD*)pBuf;
        pList->pTypeName = (BYTE*)pList->pTypeId+sizeof(WORD);
        // check the allignement
        bPad = strlen((LPSTR)pList->pTypeName)+1+sizeof(WORD);
        bPad += Pad4(bPad);
        wSize = bPad;
        pList->pResId = (WORD*)((BYTE*)pBuf+bPad);
        pList->pResName = (BYTE*)pList->pResId+sizeof(WORD);
        bPad = strlen((LPSTR)pList->pResName)+1+sizeof(WORD);
        bPad += Pad4(bPad);
        wSize += bPad;
        pList->pLang = (DWORD*)((BYTE*)pList->pResId+bPad);
        pList->pSize = (DWORD*)((BYTE*)pList->pLang+sizeof(DWORD));
        pList->pNext = (PUPDATEDRESLIST)pList+1;
        wSize += sizeof(DWORD)*2;
        pBuf = pBuf+wSize;
        iBufSize -= wSize;
        if(!iBufSize)
            pList->pNext = NULL;
        else
            pList++;
    }

    return pListHead;
}

PUPDATEDRESLIST FindId(LPCSTR pstrId, PUPDATEDRESLIST pList)
{
    //
    // Note that this function assumes that the type is always right
    // since it is a inf file this is a fair assumption.
    // It could be optimized.
    //
    if(!pList)
        return NULL;

    PUPDATEDRESLIST pLast = pList;
    while(pList)
    {
        if(!strcmp((LPSTR)pList->pResName, pstrId)) {
                return pList;
        }
        pList = pList->pNext;
    }

    return NULL;
}

////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Library init
static AFX_EXTENSION_MODULE rwinfDLL = { NULL, NULL };

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE0("RWINF.DLL Initializing!\n");

        AfxInitExtensionModule(rwinfDLL, hInstance);

        new CDynLinkLibrary(rwinfDLL);

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE0("RWINF.DLL Terminating!\n");

        // free all the loaded files
        int c = (int)g_LoadedFile.GetSize();
        CLoadedFile * pLoaded;
        while(c)
        {
            pLoaded = (CLoadedFile*)g_LoadedFile.GetAt(--c);
            delete pLoaded;
        }
    }
    return 1;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\rcdata\kernel32\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// kernel32.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\res32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\mac\mac.h ===
/////////////////////////////////////////////////////////////////////////////
// Function Declarations

//=============================================================================
// Header parsing functions
//=============================================================================

WORD MapToWindowsRes( char * pResName );

LONG WriteResInfo(
                 BYTE** lplpBuffer, LONG* plBufSize,
                 WORD wTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
                 WORD wNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
                 DWORD dwLang,
                 DWORD dwSize, DWORD dwFileOffset );

BOOL InitIODLLLink();
//=============================================================================
// IODLL call back functions and HINSTANCE
//=============================================================================

extern HINSTANCE g_IODLLInst;
extern DWORD (PASCAL * g_lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
extern DWORD (PASCAL * g_lpfnUpdateResImage)(HANDLE,	LPSTR, LPSTR, DWORD, DWORD, LPVOID, DWORD);
extern HANDLE (PASCAL * g_lpfnHandleFromName)(LPCSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\rcdata\kernel32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by krnl32.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\mac\mac.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       mac.cpp
//
//  Contents:   Implementation for the Macintosh Read/Write module
//
//  History:    23-Aug-94   alessanm    created
//
//----------------------------------------------------------------------------

#include <afxwin.h>
#include <limits.h>
#include <malloc.h>
#include "..\common\rwdll.h"
#include "..\common\m68k.h"
#include "..\common\helper.h"
#include "mac.h"


/////////////////////////////////////////////////////////////////////////////
// Initialization of MFC Extension DLL

#include "afxdllx.h"    // standard MFC Extension DLL routines

static AFX_EXTENSION_MODULE NEAR extensionDLL = { NULL, NULL };

/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define RWTAG "MAC"

static ULONG gType;
static ULONG gLng;
static ULONG gResId;
static WCHAR gwszResId[256];

HINSTANCE g_IODLLInst = 0;
DWORD (PASCAL * g_lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
DWORD (PASCAL * g_lpfnUpdateResImage)(HANDLE,	LPSTR, LPSTR, DWORD, DWORD, LPVOID, DWORD);
HANDLE (PASCAL * g_lpfnHandleFromName)(LPCSTR);


/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

//[registration]
extern "C"
BOOL    FAR PASCAL RWGetTypeString(LPSTR lpszTypeName)
{
    strcpy( lpszTypeName, RWTAG );
    return FALSE;
}

//=============================================================================
//
//	To validate a mac res binary file we will walk the resource header and see
//  if it matches with what we have.
//
//=============================================================================

extern "C"
BOOL    FAR PASCAL RWValidateFileType   (LPCSTR lpszFilename)
{
    BOOL bRet = FALSE;
    TRACE("MAC.DLL: RWValidateFileType()\n");

    CFile file;

    // we Open the file to see if it is a file we can handle
    if (!file.Open( lpszFilename, CFile::typeBinary | CFile::modeRead | CFile::shareDenyNone ))
        return bRet;

	// Check if this is a MAC Resource file ...
	if(IsMacResFile( &file ))
		bRet = TRUE;

    file.Close();
    return bRet;
}

//=============================================================================
//
//  We will walk the resource header, walk the resource map and then normalize
//  the Mac it to Windows id and pass this info to the RW.
//
//=============================================================================

extern "C"
DllExport
UINT
APIENTRY
RWReadTypeInfo(
    LPCSTR lpszFilename,
    LPVOID lpBuffer,
    UINT* puiSize

    )
{
	TRACE("MAC.DLL: RWReadTypeInfo()\n");
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    UINT uiBufSize = *puiSize;
    CFile file;
	int iFileNameLen = strlen(lpszFilename)+1;

    if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return ERROR_FILE_OPEN;

    UINT uiBufStartSize = uiBufSize;

	////////////////////////////////////
	// Check if it is  a valid mac file

	// Is a Mac Resource file ...
	if(IsMacResFile( &file )) {
		// load the file in memory
        // NOTE: WIN16 This might be to expensive in memory allocation
        // on a 16 bit platform
		BYTE * pResources = (BYTE*)malloc(file.GetLength());
		if(!pResources) {
			file.Close();
			return ERROR_NEW_FAILED;
		}
		
		file.Seek(0, CFile::begin);
		file.ReadHuge(pResources, file.GetLength());

		IMAGE_SECTION_HEADER Sect;
		memset(&Sect, 0, sizeof(IMAGE_SECTION_HEADER));
		
		ParseResourceFile(pResources, &Sect, (BYTE**)&lpBuffer, (LONG*)puiSize, iFileNameLen);
		free(pResources);

		*puiSize = uiBufSize - *puiSize;
		file.Close();
	   	return uiError;
	}

    file.Close();
    return uiError;
}

/////////////////////////////////////////////////////////////////////////////
// We will prepend to the image the file name. This will be usefull later on
// to retrive the dialog item list
/////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport
DWORD
APIENTRY
RWGetImage(
    LPCSTR  lpszFilename,
    DWORD   dwImageOffset,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
	UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
	int iNameLen = strlen(lpszFilename)+1;
    DWORD dwBufSize = dwSize - iNameLen;
    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile file;

    // Open the file and try to read the information on the resource in it.
    if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return (DWORD)ERROR_FILE_OPEN;

    if ( dwImageOffset!=(DWORD)file.Seek( dwImageOffset, CFile::begin) )
        return (DWORD)ERROR_FILE_INVALID_OFFSET;

	// copy the file name at the beginning of the buffer
	memcpy((BYTE*)lpBuf, lpszFilename, iNameLen);
	lpBuf = ((BYTE*)lpBuf+iNameLen);

    if (dwBufSize>UINT_MAX) {
        // we have to read the image in different steps
        return (DWORD)0L;
    } else uiError = file.Read( lpBuf, (UINT)dwBufSize)+iNameLen;
    file.Close();

    return (DWORD)uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWParseImage(
    LPCSTR  lpszType,
    LPVOID  lpImageBuf,
    DWORD   dwImageSize,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE * lpBuf = (BYTE *)lpBuffer;
    DWORD dwBufSize = dwSize;

	
	// Remove the filename...
	if( !strcmp(lpszType, "MENU")  	||
	    !strcmp(lpszType, "STR ")  	||
		!strcmp(lpszType, "STR#")	||
		!strcmp(lpszType, "TEXT")
		) {
		int iFileNameLen = strlen((LPSTR)lpImageBuf)+1;
		lpImageBuf = ((BYTE*)lpImageBuf+iFileNameLen);
		dwImageSize -= iFileNameLen;
	}

    //===============================================================
	// Menus
	if( !strcmp(lpszType, "MENU") )
		return ParseMENU( lpImageBuf, dwImageSize, lpBuffer, dwSize );

	//===============================================================
	// Dialogs
	if( !strcmp(lpszType, "WDLG") )
		return ParseWDLG( lpImageBuf, dwImageSize, lpBuffer, dwSize );

	if( !strcmp(lpszType, "DLOG") )
		return ParseDLOG( lpImageBuf, dwImageSize, lpBuffer, dwSize );

	if( !strcmp(lpszType, "ALRT") )
		return ParseALRT( lpImageBuf, dwImageSize, lpBuffer, dwSize );

    //===============================================================
	// Strings
	if( !strcmp(lpszType, "STR ") )
		return ParseSTR( lpImageBuf, dwImageSize, lpBuffer, dwSize );

	if( !strcmp(lpszType, "STR#") )
		return ParseSTRNUM( lpImageBuf, dwImageSize, lpBuffer, dwSize );

	if( !strcmp(lpszType, "TEXT") )
		return ParseTEXT( lpImageBuf, dwImageSize, lpBuffer, dwSize );

    if( !strcmp(lpszType, "WIND") )
		return ParseWIND( lpImageBuf, dwImageSize, lpBuffer, dwSize );
	
    return uiError;
}

extern"C"
DllExport
UINT
APIENTRY
RWWriteFile(
    LPCSTR          lpszSrcFilename,
    LPCSTR          lpszTgtFilename,
    HANDLE          hResFileModule,
    LPVOID          lpBuffer,
    UINT            uiSize,
    HINSTANCE       hDllInst,
    LPCSTR          lpszSymbolPath
    )
{
    TRACE("RWMAC.DLL: Source: %s\t Target: %s\n", lpszSrcFilename, lpszTgtFilename);
    UINT uiError = ERROR_NO_ERROR;
    PUPDATEDRESLIST pUpdList = LPNULL;

    // Get the handle to the IODLL
    if(InitIODLLLink())
  	    hDllInst = g_IODLLInst;
    else return ERROR_DLL_LOAD;

	CFile fileIn;
    CFile fileOut;

    if (!fileIn.Open(lpszSrcFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return (DWORD)ERROR_FILE_OPEN;

    if (!fileOut.Open(lpszTgtFilename, CFile::modeWrite | CFile::typeBinary))
        return (DWORD)ERROR_FILE_OPEN;

    MACRESHEADER fileHeader;
    // Read the header of the file...
    fileIn.Read(&fileHeader, sizeof(MACRESHEADER));

    // allocate a buffer to hold the new resource map
    // The buffer will be as big as the other one since there is no
    // need, for now, to support the adding of resource
    LONG lMapSize = MacLongToLong(fileHeader.mulSizeOfResMap);
    BYTE * pNewMap = (BYTE*)malloc(lMapSize);

    if(!pNewMap) {
        uiError = ERROR_NEW_FAILED;
        goto exit;
    }
{ // This is for the goto. Check error:C2362

    PUPDATEDRESLIST pListItem = LPNULL;
    // Create the list of update resource
    pUpdList = UpdatedResList( lpBuffer, uiSize );

    // set the map buffer to 0 ...
    memset(pNewMap, 0, lMapSize);

    ////////////////////////////////////////////////////////////////////////////////
    // Read each resource from the resource map and check if the resource has been
    // updated. If it has been updated, get the new resource image. Otherwise use
    // the original resource data.
    // Write the resource data in the Tgt file and write the info on the offset etc.
    // in the pNewMap buffer so, when all the resources have been read and written
    // the only thing left is to fix up some sizes and to write the buffer to disk.
    ////////////////////////////////////////////////////////////////////////////////

    // Write the resource header in the Tgt file
    fileOut.Write(&fileHeader, sizeof(MACRESHEADER));

    BYTE * pByte = (BYTE*)malloc(256);
    if(!pByte) {
        uiError = ERROR_NEW_FAILED;
        goto exit;
    }

    // Copy the Reserved and user data
    fileIn.Read(pByte, 240);
    fileOut.Write(pByte, 240);
    free(pByte);

    // store the position of the beginning of the res data
    DWORD dwBeginOfResData = fileOut.GetPosition();

    MACRESMAP resMap;
    // Read the resource map ...
    fileIn.Seek(MacLongToLong(fileHeader.mulOffsetToResMap), CFile::begin);
    fileIn.Read(&resMap, sizeof(MACRESMAP));

    BYTE * pTypeList = pNewMap+28;
    BYTE * pTypeInfo = pTypeList+2;
    BYTE * pRefList = LPNULL;
    BYTE * pNameList = LPNULL;
    BYTE * pName = LPNULL;

    DWORD dwOffsetToTypeList = fileIn.GetPosition();
    WORD wType;
    fileIn.Read(&wType, sizeof(WORD));
    memcpy( pNewMap+sizeof(MACRESMAP), &wType, sizeof(WORD));   // number of types - 1
    wType = MacWordToWord((BYTE*)&wType)+1;

    MACRESTYPELIST TypeList;
    MACRESREFLIST RefList;
    WORD wOffsetToRefList = wType*sizeof(MACRESTYPELIST)+sizeof(WORD);
    DWORD dwOffsetToLastTypeInfo = 0;
    DWORD dwOffsetToLastRefList = 0;
    DWORD dwOffsetToNameList = MacLongToLong(fileHeader.mulOffsetToResMap)+MacWordToWord(resMap.mwOffsetToNameList);
    DWORD dwSizeOfData = 0;

    while(wType) {
        // Read the type info ...
        fileIn.Read(&TypeList, sizeof(MACRESTYPELIST));
        dwOffsetToLastTypeInfo = fileIn.GetPosition();

        // ... and update the newmap buffer
        memcpy( pTypeInfo, &TypeList, sizeof(MACRESTYPELIST));
        // Fix up the offset to the ref list
        memcpy(((PMACRESTYPELIST)pTypeInfo)->mwOffsetToRefList, WordToMacWord(wOffsetToRefList), sizeof(WORD));
        pRefList = pTypeList+wOffsetToRefList;
        pTypeInfo = pTypeInfo+sizeof(MACRESTYPELIST);

        // go to the refence list ...
        fileIn.Seek(dwOffsetToTypeList+MacWordToWord(TypeList.mwOffsetToRefList), CFile::begin);

        WORD wItems = MacWordToWord(TypeList.mwNumOfThisType)+1;
        while(wItems){
            // and read the reference list for this type
            fileIn.Read( &RefList, sizeof(MACRESREFLIST));
            dwOffsetToLastRefList = fileIn.GetPosition();

            // is this a named resource ...
            if(MacWordToWord(RefList.mwOffsetToResName)!=0xffff) {
                // read the string
                fileIn.Seek(dwOffsetToNameList+MacWordToWord(RefList.mwOffsetToResName), CFile::begin);
                BYTE bLen = 0;
                fileIn.Read(&bLen, 1);
                if(!pNameList) {
                    pName = pNameList = (BYTE*)malloc(1024);
                    if(!pNameList) {
                        uiError = ERROR_NEW_FAILED;
                        goto exit;
                    }
                }
                // check the free space we have
                if((1024-((pName-pNameList)%1024))<=bLen+1){
                    BYTE * pNew = (BYTE*)realloc(pNameList, _msize(pNameList)+1024);
                    if(!pNew) {
                        uiError = ERROR_NEW_FAILED;
                        goto exit;
                    }
                    pName = pNew+(pName-pNameList);
                    pNameList = pNew;
                }

                // Update the pointer to the string
                memcpy(RefList.mwOffsetToResName, WordToMacWord((WORD)(pName-pNameList)), 2);

                memcpy(pName++, &bLen, 1);
                // we have room for the string
                fileIn.Read(pName, bLen);

                pName = pName+bLen;
            }

            // check if this item has been updated
            if(pListItem = IsResUpdated(&TypeList.szResName[0], RefList, pUpdList)) {
                // Save the offset to the resource
                DWORD dwOffsetToData = fileOut.GetPosition();
                DWORD dwSize = *pListItem->pSize;

                // allocate the buffer to hold the resource data
                pByte = (BYTE*)malloc(dwSize);
                if(!pByte){
                    uiError = ERROR_NEW_FAILED;
                    goto exit;
                }

                // get the data from the iodll
                LPSTR	lpType = LPNULL;
    			LPSTR	lpRes = LPNULL;
    			if (*pListItem->pTypeId) {
    				lpType = (LPSTR)((WORD)*pListItem->pTypeId);
    			} else {
    				lpType = (LPSTR)pListItem->pTypeName;
    			}
    			if (*pListItem->pResId) {
    				lpRes = (LPSTR)((WORD)*pListItem->pResId);
    			} else {
    				lpRes = (LPSTR)pListItem->pResName;
    			}

    			DWORD dwImageBufSize = (*g_lpfnGetImage)(  hResFileModule,
    											lpType,
    											lpRes,
    											*pListItem->pLang,
    											pByte,
    											*pListItem->pSize
    						   					);

                // Remove the file name from the image
                int iFileNameLen = strlen((LPSTR)pByte)+1;
                dwSize -= iFileNameLen;

                // write the size of the data block
                fileOut.Write(LongToMacLong(dwSize), sizeof(DWORD));
                dwSizeOfData += dwSize+sizeof(DWORD);

    			fileOut.Write((pByte+iFileNameLen), dwSize);

                free(pByte);

                // fix up the offset to the resource in the ref list
                memcpy(RefList.bOffsetToResData, LongToMacOffset(dwOffsetToData-dwBeginOfResData), 3);
            }
            else {
                // Get the data from the Src file
                // get to the data
                fileIn.Seek(MacLongToLong(fileHeader.mulOffsetToResData)+
                    MacOffsetToLong(RefList.bOffsetToResData), CFile::begin);

                // read the size of the data block
                DWORD dwSize = 0;
                fileIn.Read(&dwSize, sizeof(DWORD));

                // Save the offset to the resource
                DWORD dwOffsetToData = fileOut.GetPosition();

                // write the size of the data block
                fileOut.Write(&dwSize, sizeof(DWORD));
                dwSizeOfData += sizeof(DWORD);

                // allocate the buffer to hold the resource data
                dwSizeOfData += dwSize = MacLongToLong((BYTE*)&dwSize);
                pByte = (BYTE*)malloc(dwSize);
                if(!pByte){
                    uiError = ERROR_NEW_FAILED;
                    goto exit;
                }

                // copy the data
                fileIn.Read(pByte, dwSize);
                fileOut.Write(pByte, dwSize);

                free(pByte);

                // fix up the offset to the resource in the ref list
                memcpy(RefList.bOffsetToResData, LongToMacOffset(dwOffsetToData-dwBeginOfResData), 3);

            }

            // return in the right place
            fileIn.Seek(dwOffsetToLastRefList, CFile::begin);

            // copy this data in the new map buffer
            memcpy(pRefList, &RefList, sizeof(MACRESREFLIST));
            wOffsetToRefList+=sizeof(MACRESREFLIST);

            // move to the new ref list
            pRefList = pTypeList+wOffsetToRefList;
            wItems--;
        }

        fileIn.Seek(dwOffsetToLastTypeInfo, CFile::begin);
        wType--;
    }

    // copy the resource map header info
    memcpy( pNewMap, &resMap, sizeof(MACRESMAP));

    // copy the name list at the end of the res map
    dwOffsetToNameList = 0;
    if(pNameList) {
        dwOffsetToNameList = (DWORD)(pRefList-pNewMap);
        // copy the name list
        memcpy(pRefList, pNameList, (size_t)(pName-pNameList));
        free(pNameList);
    }

    // write the resource map
    DWORD dwOffsetToResMap = fileOut.GetPosition();
    fileOut.Write(pNewMap, lMapSize);

    // We need to fix up the file header ...
    fileOut.Seek(4, CFile::begin);
    fileOut.Write(LongToMacLong(dwOffsetToResMap), sizeof(DWORD));
    fileOut.Write(LongToMacLong(dwSizeOfData), sizeof(DWORD));

    // ... and the resource map header
    fileOut.Seek(dwOffsetToResMap+4, CFile::begin);
    fileOut.Write(LongToMacLong(dwOffsetToResMap), sizeof(DWORD));
    fileOut.Write(LongToMacLong(dwSizeOfData), sizeof(DWORD));

    fileOut.Seek(dwOffsetToResMap+26, CFile::begin);
    fileOut.Write(WordToMacWord(LOWORD(dwOffsetToNameList)), sizeof(WORD));


}
exit:
    fileIn.Close();
    fileOut.Close();
    if(pNewMap)
        free(pNewMap);
    if(pUpdList)
        free(pUpdList);

    return (UINT)uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWUpdateImage(
    LPCSTR  lpszType,
    LPVOID  lpNewBuf,
    DWORD   dwNewSize,
    LPVOID  lpOldImage,
    DWORD   dwOldImageSize,
    LPVOID  lpNewImage,
    DWORD*  pdwNewImageSize
    )
{
    UINT uiError = ERROR_RW_NOTREADY;

    //===============================================================
	// Since all the Type are named in the mac at this stage we need to
    // know the original name of the Type and not the Windows type.
    // Use the typeID stored in the new ites buffer
    LPSTR lpRealType = ((PRESITEM)lpNewBuf)->lpszTypeID;

    if(!HIWORD(lpRealType))     // something is wrong if this is not valid
        return uiError;

    //===============================================================
	// Menus
	if( !strcmp(lpRealType, "MENU") )
		return UpdateMENU( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );

    //===============================================================
	// Strings
	if( !strcmp(lpRealType, "STR ") )
		return UpdateSTR( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );

    if( !strcmp(lpRealType, "STR#") )
		return UpdateSTRNUM( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );

	if( !strcmp(lpRealType, "WIND") )
		return UpdateWIND( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );

    //===============================================================
	// Dialogs
	if( !strcmp(lpRealType, "DLOG") )
		return UpdateDLOG( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );
    if( !strcmp(lpRealType, "ALRT") )
		return UpdateALRT( lpNewBuf, dwNewSize, lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize );

	*pdwNewImageSize = 0L;
	return uiError;
}

///////////////////////////////////////////////////////////////////////////
// Functions implementation

//=============================================================================
//	MapToWindowsRes
//
//	Map a Mac resource name to a Windows resource
//=============================================================================
WORD MapToWindowsRes( char * pResName )
{
	if( !strcmp(pResName, "PICT") ||
		!strcmp(pResName, "WBMP"))
		return 2;
	
	if( !strcmp(pResName, "MENU") ||
		!strcmp(pResName, "WMNU"))
		return 4;

	if( !strcmp(pResName, "DLOG") ||
		!strcmp(pResName, "ALRT") ||
        !strcmp(pResName, "WDLG"))
		return 5;

	if( !strcmp(pResName, "STR "))
		return STR_TYPE;

	if( !strcmp(pResName, "STR#") ||
		!strcmp(pResName, "TEXT"))
		return MSG_TYPE;

	if( !strcmp(pResName, "vers") ||
		!strcmp(pResName, "VERS"))
		return 16;

    // For the Item list return 17. This means nothing to windows and will
    // give us the flexibility to update the DITL list from the RW, without user
    // input.
    if( !strcmp(pResName, "DITL"))
		return DITL_TYPE;

	// For the Frame Window Caption mark it as type 18
	if( !strcmp(pResName, "WIND"))
		return WIND_TYPE;

	return 0;
}

//=============================================================================
//	WriteResInfo
//
//	Fill the buffer to pass back to the iodll
//=============================================================================

LONG WriteResInfo(
                 BYTE** lplpBuffer, LONG* plBufSize,
                 WORD wTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
                 WORD wNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
                 DWORD dwLang,
                 DWORD dwSize, DWORD dwFileOffset )
{
    LONG lSize = 0;
    lSize = PutWord( lplpBuffer, wTypeId, plBufSize );
    lSize += PutStringA( lplpBuffer, lpszTypeId, plBufSize );
	 // Check if it is alligned
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutWord( lplpBuffer, wNameId, plBufSize );
    lSize += PutStringA( lplpBuffer, lpszNameId, plBufSize );
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutDWord( lplpBuffer, dwLang, plBufSize );

    lSize += PutDWord( lplpBuffer, dwSize, plBufSize );

    lSize += PutDWord( lplpBuffer, dwFileOffset, plBufSize );

    return (LONG)lSize;
}

BOOL InitIODLLLink()
{
    if(!g_IODLLInst)
    {
        // Init the link with the iodll
        g_IODLLInst = LoadLibrary("iodll.dll");
        if(!g_IODLLInst)
            return FALSE;

        if((g_lpfnGetImage = (DWORD (PASCAL *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
						    GetProcAddress( g_IODLLInst, "RSGetResImage" ))==NULL)
	        return FALSE;

        if((g_lpfnHandleFromName = (HANDLE (PASCAL *)(LPCSTR))
						    GetProcAddress( g_IODLLInst, "RSHandleFromName" ))==NULL)
	        return FALSE;

        if((g_lpfnUpdateResImage = (DWORD (PASCAL *)(HANDLE, LPSTR, LPSTR, DWORD, DWORD, LPVOID, DWORD))
						    GetProcAddress( g_IODLLInst, "RSUpdateResImage" ))==NULL)
	        return FALSE;

	
    }
    else {
        if(g_lpfnGetImage==NULL || g_lpfnHandleFromName==NULL)
            return FALSE;
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation

////////////////////////////////////////////////////////////////////////////
// Library init

////////////////////////////////////////////////////////////////////////////
// This function should be used verbatim.  Any initialization or termination
// requirements should be handled in InitPackage() and ExitPackage().
//
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory
		// here, use the TRACE or ASSERT macros or call MessageBox
		AfxInitExtensionModule(extensionDLL, hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxWinTerm();

        // remove the link with iodll
        if(g_IODLLInst)
            FreeLibrary(g_IODLLInst);

	}

	if (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)
		return 0;		// CRT term	Failed

	return 1;   // ok
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\win16\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\rcdata\kernel32\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include "..\..\common\rwdll.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\res32\res32.cpp ===
//+---------------------------------------------------------------------------
//
//  File:	res32.cpp
//
//  Contents:	Implementation for the Resource 32 Read/Write module
//
//  Classes:    one
//
//  History:	31-May-93   alessanm    created
//----------------------------------------------------------------------------

#include <afxwin.h>

#include "..\common\rwdll.h"
#include "..\common\rw32hlpr.h"

#include <limits.h>

/////////////////////////////////////////////////////////////////////////////
// Initialization of MFC Extension DLL

static AFX_EXTENSION_MODULE NEAR extensionDLL = { NULL, NULL };

/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define RWTAG "RES32"

/////////////////////////////////////////////////////////////////////////////
// Function Declarations

static UINT GetResInfo(
				 CFile*,
				 WORD* wTypeId, LPSTR lplpszTypeId, BYTE bMaxTypeLen,
				 WORD* wNameId, LPSTR lplpszNameId, BYTE bMaxNameLen,
				 DWORD* pdwDataVersion,
				 WORD* pwFlags, WORD* pwLang,
				 DWORD* pdwVersion, DWORD* pdwCharact,
				 DWORD* dwSize, DWORD* dwFileOffset, DWORD );

static UINT WriteHeader(
				 CFile* pFile,
				 DWORD dwSize,
				 WORD wTypeId, LPSTR lpszwTypeId,
				 WORD wNameId, LPSTR lpszwNameId,
				 DWORD dwDataVersion,
				 WORD wFlags, WORD wLang,
				 DWORD dwVersion, DWORD dwCharact );

static UINT WriteImage(
				 CFile*,
				 LPVOID lpImage, DWORD dwSize );

static UINT GetUpdatedRes(
				 LPVOID far * lplpBuffer,
				 LONG* lSize,
				 WORD* wTypeId, LPSTR lplpszTypeId,
				 WORD* wNameId, LPSTR lplpszNameId,
				 DWORD* dwlang, DWORD* dwSize );

static UINT GenerateFile(
				LPCSTR		lpszTgtFilename,
				HANDLE		hResFileModule,
				LPVOID		lpBuffer,
				UINT		uiSize,
				HINSTANCE   hDllInst );

static UINT GetNameOrOrdFile( CFile* pfile, WORD* pwId, LPSTR lpszId, BYTE bMaxStrLen );


/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

//[registration]
extern "C"
BOOL	FAR PASCAL RWGetTypeString(LPSTR lpszTypeName)
{
	strcpy( lpszTypeName, RWTAG );
	return FALSE;
}

extern "C"
BOOL	FAR PASCAL RWValidateFileType	(LPCSTR lpszFilename)
{
	UINT uiError = ERROR_NO_ERROR;
	CFile file;

	// Open the file and try to read the information on the resource in it.
	if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
		return FALSE;

	WORD wTypeId;
	static char szTypeId[128];

	WORD wNameId;
	static char szNameId[128];
	WORD wDummy;
	DWORD dwDummy;
	WORD wLang;
	DWORD dwSize;
	DWORD dwFileOffset;

	DWORD filelen = file.GetLength();

	// File begins with a null resource entry. Check for signature.
	{  DWORD datasize, headsize;

	   // Filelen to at least 32 bytes, the size of a resource entry with
	   // datasize = 0...  Note: A file consisting of just a null header is accepted.
	   if (filelen < 32) {
	       file.Close();
	       return FALSE;
	       }

	   // datasize to be 0 (although >0 everywhere else)
	   file.Read(&datasize, 4);
	   if (datasize != 0) {
	       file.Close();
	       return FALSE;
	       }

	   // headsize to be 32 (although >=32 everywhere else)
	   file.Read(&headsize, 4);
	   if (headsize != 32) {
	       file.Close();
	       return FALSE;
	       }

	   // Other tests possible here

	   // Skip to end of first (null) resource entry
	   file.Seek(headsize, CFile::begin);
	   }

	// See that rest of file contains recognizable resource entries
	while(filelen - file.GetPosition()>0) {
		if (!GetResInfo( &file,
					  &wTypeId, &szTypeId[0], 128,
					  &wNameId, &szNameId[0], 128,
					  &dwDummy,
					  &wDummy, &wLang,
					  &dwDummy, &dwDummy,
					  &dwSize, &dwFileOffset, filelen) ) {
			// This is not a valid resource file
			file.Close();
			return FALSE;
		}
	}

	file.Close();
	return TRUE;
}


extern "C"
UINT
APIENTRY
RWReadTypeInfo(
	LPCSTR lpszFilename,
	LPVOID lpBuffer,
	UINT* puiSize

	)
{
	UINT uiError = ERROR_NO_ERROR;
	BYTE far * lpBuf = (BYTE far *)lpBuffer;
	LONG lBufSize = (LONG)*puiSize;
	// we can consider the use of a CMemFile so we get the same speed as memory access.
	CFile file;

	if (!RWValidateFileType(lpszFilename))
		return ERROR_RW_INVALID_FILE;
	
    // Make sure we are using the right code page and global settings
    // Get the pointer to the function
	HINSTANCE hDllInst = LoadLibrary("iodll.dll");
    if (hDllInst)
    {
        UINT (FAR PASCAL * lpfnGetSettings)(LPSETTINGS);
        // Get the pointer to the function to get the settings
        lpfnGetSettings = (UINT (FAR PASCAL *)(LPSETTINGS))
                            GetProcAddress( hDllInst, "RSGetGlobals" );
        if (lpfnGetSettings!=NULL) {
            SETTINGS settings;
	        (*lpfnGetSettings)(&settings);

    	    g_cp      = settings.cp;
            g_bAppend = settings.bAppend;
            g_bUpdOtherResLang = settings.bUpdOtherResLang;
            strcpy( g_char, settings.szDefChar );
		}

        FreeLibrary(hDllInst);
    }

    // Open the file and try to read the information on the resource in it.
	if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
		return ERROR_FILE_OPEN;

	// we try to read as much information as we can
	// Because this is a res file we can read all the information we need.

	WORD wTypeId;
	static char szTypeId[128];

	WORD wNameId;
	static char szNameId[128];
	WORD wDummy;
	DWORD dwDummy;
	WORD wLang;
	DWORD dwSize;
	DWORD dwFileOffset;

	UINT uiOverAllSize = 0;

	// The first resource should be: Null. Skipp it
	file.Seek( 32, CFile::begin);
	DWORD filelen =	file.GetLength();
	while(filelen-file.GetPosition()>0) {
		GetResInfo( &file,
					  &wTypeId, &szTypeId[0], 128,
					  &wNameId, &szNameId[0], 128,
					  &dwDummy,
					  &wDummy, &wLang,
					  &dwDummy, &dwDummy,
					  &dwSize, &dwFileOffset, filelen);

		uiOverAllSize += PutWord( &lpBuf, wTypeId, &lBufSize );
		uiOverAllSize += PutStringA( &lpBuf, szTypeId, &lBufSize );
		// Check if it is alligned
 		uiOverAllSize += Allign( &lpBuf, &lBufSize , (LONG)uiOverAllSize);

		uiOverAllSize += PutWord( &lpBuf, wNameId, &lBufSize  );
		uiOverAllSize += PutStringA( &lpBuf, szNameId, &lBufSize );
		// Check if it is alligned
 		uiOverAllSize += Allign( &lpBuf, &lBufSize, (LONG)uiOverAllSize);

		uiOverAllSize += PutDWord( &lpBuf, (DWORD)wLang, &lBufSize );

		uiOverAllSize += PutDWord( &lpBuf, dwSize, &lBufSize  );

		uiOverAllSize += PutDWord( &lpBuf, dwFileOffset, &lBufSize );
	}

	file.Close();
	*puiSize = uiOverAllSize;
	return uiError;
}

extern "C"
DWORD
APIENTRY
RWGetImage(
	LPCSTR	lpszFilename,
	DWORD	dwImageOffset,
	LPVOID	lpBuffer,
	DWORD	dwSize
	)
{
	UINT uiError = ERROR_NO_ERROR;
	BYTE far * lpBuf = (BYTE far *)lpBuffer;
	DWORD dwBufSize = dwSize;
	// we can consider the use of a CMemFile so we get the same speed as memory access.
	CFile file;

	// Open the file and try to read the information on the resource in it.
	if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
		return (DWORD)ERROR_FILE_OPEN;

	if ( dwImageOffset!=(DWORD)file.Seek( dwImageOffset, CFile::begin) )
		return (DWORD)ERROR_FILE_INVALID_OFFSET;
	if (dwSize>UINT_MAX) {
		// we have to read the image in different steps
		return (DWORD)0L;
	} else uiError = file.Read( lpBuf, (UINT)dwSize);
	file.Close();

	return (DWORD)uiError;
}

extern "C"
UINT
APIENTRY
RWParseImage(
	LPCSTR	lpszType,
	LPVOID	lpImageBuf,
	DWORD	dwImageSize,
	LPVOID	lpBuffer,
	DWORD	dwSize
	)
{
	UINT uiError = ERROR_NO_ERROR;
	BYTE far * lpBuf = (BYTE far *)lpBuffer;
	DWORD dwBufSize = dwSize;

	// The Type we can parse are only the standard ones
	// This function should fill the lpBuffer with an array of ResItem structure
	switch ((UINT)LOWORD(lpszType)) {\
		/*
		case 1:
			uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;

		case 3:
			uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;
		*/
		case 4:
			uiError = ParseMenu( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;


		case 5:
			uiError = ParseDialog( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;

        case 6:
			uiError = ParseString( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;

        case 9:
			uiError = ParseAccel( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;
		case 11:
			uiError = ParseMsgTbl( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
		break;
        case 16:
            uiError = ParseVerst( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
		default:
		break;
	}

	return uiError;
}

extern"C"
UINT
APIENTRY
RWWriteFile(
	LPCSTR		lpszSrcFilename,
	LPCSTR		lpszTgtFilename,
	HANDLE		hResFileModule,
	LPVOID		lpBuffer,
	UINT		uiSize,
	HINSTANCE   hDllInst,
    LPCSTR      lpszSymbolPath
	)
{
	UINT uiError = ERROR_NO_ERROR;
	BYTE far * lpBuf = LPNULL;
	UINT uiBufSize = uiSize;
	// we can consider the use of a CMemFile so we get the same speed as memory access.
	CFile fileIn;
	CFile fileOut;
	BOOL  bfileIn = TRUE;

	// Open the file and try to read the information on the resource in it.
	CFileStatus status;
	if (CFile::GetStatus( lpszSrcFilename, status )) {
		// check if the size of the file is not null
		if (!status.m_size)
			CFile::Remove(lpszSrcFilename);
	}

	// Get the handle to the IODLL
  	hDllInst = LoadLibrary("iodll.dll");

	// Get the pointer to the function
	if (!hDllInst)
		return ERROR_DLL_LOAD;

	if (!fileIn.Open(lpszSrcFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone)) {
	
		uiError = GenerateFile(lpszTgtFilename,
							hResFileModule,
							lpBuffer,
							uiSize,
							hDllInst
							);

		FreeLibrary(hDllInst);
		return uiError;
	}

	if (!fileOut.Open(lpszTgtFilename, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
		return ERROR_FILE_CREATE;

	DWORD (FAR PASCAL * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
	// Get the pointer to the function to extract the resources image
	lpfnGetImage = (DWORD (FAR PASCAL *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
						GetProcAddress( hDllInst, "RSGetResImage" );
	if (lpfnGetImage==NULL) {
		FreeLibrary(hDllInst);
		return ERROR_DLL_PROC_ADDRESS;
	}

	// We read the resources from the file and then we check if the resource has been updated
	// or if we can just copy it

	WORD wTypeId;
	char szTypeId[128];

	WORD wNameId;
	char szNameId[128];

	WORD wFlags;
	WORD wLang;
	DWORD dwDataVersion;
	DWORD dwVersion;
	DWORD dwCharact;

	DWORD dwSize;
	DWORD dwFileOffset;

	WORD wUpdTypeId = 0;
	static char szUpdTypeId[128];

	WORD wUpdNameId;
	static char szUpdNameId[128];

	DWORD dwUpdLang;
	DWORD dwUpdSize;



	UINT uiBufStartSize = uiBufSize;
	DWORD dwImageBufSize;
	BYTE far * lpImageBuf;
	DWORD filelen = fileIn.GetLength();
	DWORD dwHeadSize = 0l;
	static BYTE buf[32];
	DWORD pad = 0l;

	// The first resource should be: Null. Skipp it
	fileIn.Read( &buf, 32 );
	fileOut.Write( &buf, 32 );

	while(filelen-fileIn.GetPosition()>0) {
		GetResInfo( &fileIn,
					&wTypeId, &szTypeId[0], 128,
					&wNameId, &szNameId[0], 128,
					&dwDataVersion,
					&wFlags, &wLang,
					&dwVersion, &dwCharact,
					&dwSize, &dwFileOffset, filelen
					);

		if ((!wUpdTypeId) && (uiBufSize))
			GetUpdatedRes( &lpBuffer,
					(LONG*)&uiBufSize,
					&wUpdTypeId, &szUpdTypeId[0],
					&wUpdNameId, &szUpdNameId[0],
					&dwUpdLang,
					&dwUpdSize
					);
		if ( (wUpdTypeId==wTypeId) &&
			 ( (CString)szUpdTypeId==(CString)szTypeId) &&
			 (wUpdNameId==wNameId) &&
			 ( (CString)szUpdNameId==(CString)szNameId)
			 ) {
			// The resource has been updated get the image from the IODLL
			lpImageBuf = new BYTE[dwUpdSize];
			LPSTR	lpType = LPNULL;
			LPSTR	lpRes = LPNULL;
			if (wUpdTypeId) {
				lpType = (LPSTR)((WORD)wUpdTypeId);
			} else {
				lpType = &szUpdTypeId[0];
			}
			if (wUpdNameId) {
				lpRes = (LPSTR)((WORD)wUpdNameId);
			} else {
				lpRes = &szUpdNameId[0];
			}

			dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
											lpType,
											lpRes,
											dwUpdLang,
											lpImageBuf,
											dwUpdSize
						   					);
			if (dwImageBufSize>dwUpdSize ) {
				// The buffer is too small
				delete []lpImageBuf;
				lpImageBuf = new BYTE[dwImageBufSize];
				dwUpdSize = (*lpfnGetImage)(  hResFileModule,
												lpType,
												lpRes,
												dwUpdLang,
												lpImageBuf,
												dwImageBufSize
											   );
				if ((dwUpdSize-dwImageBufSize)!=0 ) {
					delete []lpImageBuf;
					lpImageBuf = LPNULL;
				}
			}

			wUpdTypeId = 0;

		} else {

			// The fileIn is now correctly positioned at next resource. Save posit.
			DWORD dwNextResFilePos = fileIn.GetPosition();

			// The resource hasn't been updated copy the image from the file
			if(!dwSize) {
				FreeLibrary(hDllInst);
				return ERROR_NEW_FAILED;
			}
			lpImageBuf = new BYTE[dwSize];
			if(!lpImageBuf) {
				FreeLibrary(hDllInst);
				return ERROR_NEW_FAILED;
			}
			if ( dwFileOffset!=(DWORD)fileIn.Seek( dwFileOffset, CFile::begin) ) {
				delete []lpImageBuf;
				FreeLibrary(hDllInst);
				return (DWORD)ERROR_FILE_INVALID_OFFSET;
			}
			if (dwSize>UINT_MAX) {
				// we have to read the image in different steps
				delete []lpImageBuf;
				FreeLibrary(hDllInst);
				return (DWORD)ERROR_RW_IMAGE_TOO_BIG;
			} else fileIn.Read( lpImageBuf, (UINT)dwSize);
			dwImageBufSize = dwSize;

			// This moves us past any pad bytes, to start of next resource.
			fileIn.Seek(dwNextResFilePos, CFile::begin);
		}

		dwHeadSize = WriteHeader(&fileOut,
					dwImageBufSize,
					wTypeId, &szTypeId[0],
					wNameId, &szNameId[0],
					dwDataVersion,
					wFlags, wLang,
					dwVersion, dwCharact );

		WriteImage( &fileOut,
					lpImageBuf, dwImageBufSize);

		BYTE bPad = (BYTE)Pad4((DWORD)dwHeadSize+dwImageBufSize);
		if(bPad)
			fileOut.Write( &pad, bPad );

		if (lpImageBuf) delete []lpImageBuf;
	}

	fileIn.Close();
	fileOut.Close();

	FreeLibrary(hDllInst);
	return uiError;
}

extern "C"
UINT
APIENTRY
RWUpdateImage(
	LPCSTR	lpszType,
	LPVOID	lpNewBuf,
	DWORD	dwNewSize,
	LPVOID	lpOldImage,
	DWORD	dwOldImageSize,
	LPVOID	lpNewImage,
	DWORD*	pdwNewImageSize
	)
{
	UINT uiError = ERROR_NO_ERROR;

	// The Type we can parse are only the standard ones
	switch ((UINT)LOWORD(lpszType)) {

		case 4:
			if (lpOldImage)
				uiError = UpdateMenu( lpNewBuf, dwNewSize,
									  lpOldImage, dwOldImageSize,
									  lpNewImage, pdwNewImageSize );
			else uiError = GenerateMenu( lpNewBuf, dwNewSize,
									  lpNewImage, pdwNewImageSize );
		break;
		
		case 5:
			if (lpOldImage)
				uiError = UpdateDialog( lpNewBuf, dwNewSize,
								  lpOldImage, dwOldImageSize,
								  lpNewImage, pdwNewImageSize );
			else uiError = GenerateDialog( lpNewBuf, dwNewSize,
									  lpNewImage, pdwNewImageSize );
		break;
        case 6:
            if (lpOldImage)
                uiError = UpdateString( lpNewBuf, dwNewSize,
                                    lpOldImage, dwOldImageSize,
                                    lpNewImage, pdwNewImageSize );
            else uiError = GenerateString( lpNewBuf, dwNewSize,
									  lpNewImage, pdwNewImageSize );
        break;

        case 9:
            if (lpOldImage)
                uiError = UpdateAccel( lpNewBuf, dwNewSize,
                                   lpOldImage, dwOldImageSize,
                                   lpNewImage, pdwNewImageSize );
        break;

        case 11:
            if (lpOldImage)
                uiError = UpdateMsgTbl( lpNewBuf, dwNewSize,
                                  lpOldImage, dwOldImageSize,
                                  lpNewImage, pdwNewImageSize );
        break;

        case 16:
            if (lpOldImage)
                uiError = UpdateVerst( lpNewBuf, dwNewSize,
                                   lpOldImage, dwOldImageSize,
                                   lpNewImage, pdwNewImageSize );
        break;

		default:
			*pdwNewImageSize = 0L;
			uiError = ERROR_RW_NOTREADY;
		break;
	}

	return uiError;
}

///////////////////////////////////////////////////////////////////////////
// Functions implementation

static UINT GenerateFile( LPCSTR		lpszTgtFilename,
						  HANDLE		hResFileModule,
						  LPVOID		lpBuffer,
						  UINT		uiSize,
						  HINSTANCE   hDllInst
						)
{
	UINT uiError = ERROR_NO_ERROR;
	BYTE far * lpBuf = LPNULL;
	UINT uiBufSize = uiSize;
	// we can consider the use of a CMemFile so we get the same speed as memory access.
	CFile fileOut;

	if (!fileOut.Open(lpszTgtFilename, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
		return ERROR_FILE_CREATE;

	// Get the pointer to the function
	if (!hDllInst)
		return ERROR_DLL_LOAD;

	DWORD (FAR PASCAL * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
	// Get the pointer to the function to extract the resources image
	lpfnGetImage = (DWORD (FAR PASCAL *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
						GetProcAddress( hDllInst, "RSGetResImage" );
	if (lpfnGetImage==NULL) {
		return ERROR_DLL_PROC_ADDRESS;
	}


	WORD wUpdTypeId = 0;
	static char szUpdTypeId[128];

	WORD wUpdNameId;
	static char szUpdNameId[128];

	DWORD dwUpdLang;
	DWORD dwUpdSize;

	UINT uiBufStartSize = uiBufSize;
	DWORD dwImageBufSize;
	BYTE far * lpImageBuf;

	// First write the NULL resource to make it different from res16
	static BYTE bNullHeader[32] = {0,0,0,0,0x20,0,0,0,0xFF,0xFF,0,0,0xFF,0xFF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

	fileOut.Write(bNullHeader, 32);

	while(uiBufSize>0) {
		if ((!wUpdTypeId) && (uiBufSize))
			GetUpdatedRes( &lpBuffer,
					(LONG*)&uiBufSize,
					&wUpdTypeId, &szUpdTypeId[0],
					&wUpdNameId, &szUpdNameId[0],
					&dwUpdLang,
					&dwUpdSize
					);
					
		// The resource has been updated get the image from the IODLL
		if (dwUpdSize){
			lpImageBuf = new BYTE[dwUpdSize];
			LPSTR	lpType = LPNULL;
			LPSTR	lpRes = LPNULL;
			if (wUpdTypeId) {
				lpType = (LPSTR)((WORD)wUpdTypeId);
			} else {
				lpType = &szUpdTypeId[0];
			}
			if (wUpdNameId) {
				lpRes = (LPSTR)((WORD)wUpdNameId);
			} else {
				lpRes = &szUpdNameId[0];
			}
	
			dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
											lpType,
											lpRes,
											dwUpdLang,
											lpImageBuf,
											dwUpdSize
						   					);
			if (dwImageBufSize>dwUpdSize ) {
				// The buffer is too small			
				delete []lpImageBuf;
				lpImageBuf = new BYTE[dwImageBufSize];
				dwUpdSize = (*lpfnGetImage)(  hResFileModule,
												lpType,
												lpRes,
												dwUpdLang,
												lpImageBuf,
												dwImageBufSize
											   );
				if ((dwUpdSize-dwImageBufSize)!=0 ) {
					delete []lpImageBuf;
					lpImageBuf = LPNULL;
				}
			}
				
				
			WriteHeader(&fileOut,
						dwImageBufSize,
						wUpdTypeId, &szUpdTypeId[0],
						wUpdNameId, &szUpdNameId[0],
						0l, 0, 0, 0l, 0l );
			
			WriteImage( &fileOut,
						lpImageBuf, dwImageBufSize);
						
			if (lpImageBuf) delete []lpImageBuf;
			wUpdTypeId = 0;
			
		} else wUpdTypeId = 0;
		
	}
	
	fileOut.Close();
	
	return uiError;
}

static UINT GetUpdatedRes(
				 LPVOID far * lplpBuffer,
				 LONG* lSize,
				 WORD* wTypeId, LPSTR lpszTypeId,
				 WORD* wNameId, LPSTR lpszNameId,
				 DWORD* dwLang, DWORD* dwSize )
{
    BYTE** lplpBuf = (BYTE**)lplpBuffer;

    UINT uiSize = GetWord( lplpBuf, wTypeId, lSize );
    uiSize += GetStringA( lplpBuf, lpszTypeId, lSize );
    uiSize += Allign( lplpBuf, lSize, (LONG)uiSize);

    uiSize += GetWord( lplpBuf, wNameId, lSize );
    uiSize += GetStringA( lplpBuf, lpszNameId, lSize );
    uiSize += Allign( lplpBuf, lSize, (LONG)uiSize);

    uiSize += GetDWord( lplpBuf, dwLang, lSize );
    uiSize += GetDWord( lplpBuf, dwSize, lSize );

    return uiSize;
}	

static UINT
GetResInfo( CFile* pfile,
			WORD* pwTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
			WORD* pwNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
			DWORD* pdwDataVersion,
			WORD* pwFlags, WORD* pwLang,
			DWORD* pdwVersion, DWORD* pdwCharact,
		 	DWORD* pdwSize, DWORD* pdwFileOffset,
		 	DWORD dwFileSize )
{
	static UINT uiSize;
	static LONG lOfsCheck;
	static DWORD dwSkip;
	static DWORD dwHeadSize;
	//Get the data size
	pfile->Read( pdwSize, 4 );
	if (*pdwSize==0)
		// size id 0 the resource file is corrupted or is not a res file
		return FALSE;
	
	//Get the Header size
	pfile->Read( &dwHeadSize, 4 );
	if (dwHeadSize<32)
		// should never be smaller than 32
		return FALSE;
	
	// get the Type info
	uiSize = GetNameOrOrdFile( pfile, pwTypeId, lpszTypeId, bMaxTypeLen);
	if (!uiSize)
		return FALSE;
		
	// get the Name info
	uiSize = GetNameOrOrdFile( pfile, pwNameId, lpszNameId, bMaxNameLen);
    if (!uiSize)
		return FALSE;
	
	// Skip the Data Version
	pfile->Read( pdwDataVersion, 4 );
	
	// Get the Flags
	pfile->Read( pwFlags, 2 );
	
	// Get the language ID
	pfile->Read( pwLang, 2 );
		
	// Skip the version and the characteristics
	pfile->Read( pdwVersion, 4 );	
	pfile->Read( pdwCharact, 4 );
	
	*pdwFileOffset = pfile->GetPosition();
	
	// calculate if padding nedeed
	BYTE bPad = (BYTE)Pad4((DWORD)((*pdwSize)+dwHeadSize));
	if(bPad)
		pfile->Seek( bPad, CFile::current );
	
	if (*pdwFileOffset>dwFileSize)
		return FALSE;
	// check if the size is valid
	TRY {
		lOfsCheck = pfile->Seek(*pdwSize, CFile::current);
	} CATCH(CFileException, e) {
		// Check is the right exception
		return FALSE;
	} END_CATCH
	if (lOfsCheck!=(LONG)(*pdwFileOffset+*pdwSize+bPad))
			return FALSE;
			
	return TRUE;
}

static UINT WriteHeader(
				 CFile* pFile,
				 DWORD dwSize,
				 WORD wTypeId, LPSTR lpszTypeId,
				 WORD wNameId, LPSTR lpszNameId,
				 DWORD dwDataVersion,
				 WORD wFlags, WORD wLang,
				 DWORD dwVersion, DWORD dwCharact )
{
	UINT uiError = ERROR_NO_ERROR;
	static WCHAR szwName[128];
	static WORD wFF = 0xFFFF;
	DWORD dwHeadSize = 0l;
	static DWORD Pad = 0L;
	
	
	DWORD dwOffset = pFile->GetPosition();
	pFile->Write( &dwSize, 4 );
	// we will have to fix up laxter the size of the resource
	pFile->Write( &dwHeadSize, 4 );
	
	if(wTypeId) {
		// It is an ordinal
		pFile->Write( &wFF, 2 );
		pFile->Write( &wTypeId, 2 );
		dwHeadSize += 4;
	} else {
		WORD wLen = (WORD)((_MBSTOWCS( szwName, lpszTypeId, strlen(lpszTypeId)+1))*sizeof(WORD));
		pFile->Write( szwName, wLen );
		BYTE bPad = (BYTE)Pad4(wLen);
		if(bPad)
			pFile->Write( &Pad, bPad ); 	
		dwHeadSize += wLen+bPad;
	}
	
	if(wNameId) {
		// It is an ordinal
		pFile->Write( &wFF, 2 );
		pFile->Write( &wNameId, 2 );
		dwHeadSize += 4;
	} else {
		WORD wLen = (WORD)((_MBSTOWCS( szwName, lpszNameId, strlen(lpszNameId)+1))*sizeof(WORD));
		pFile->Write( szwName, wLen );
		BYTE bPad = (BYTE)Pad4(wLen);
		if(bPad)
			pFile->Write( &Pad, bPad ); 	
		dwHeadSize += wLen+bPad;
	}
	
	pFile->Write( &dwDataVersion, 4 );
	pFile->Write( &wFlags, 2 );
	pFile->Write( &wLang, 2 );
	pFile->Write( &dwVersion, 4 );
	pFile->Write( &dwCharact, 4 );
	
	dwHeadSize += 24;
	
	// write the size of the resource
	pFile->Seek( dwOffset+4, CFile::begin );
	pFile->Write( &dwHeadSize, 4 );
	pFile->Seek( dwOffset+dwHeadSize, CFile::begin );	
	return (UINT)dwHeadSize;
}				

static DWORD dwZeroPad = 0x00000000;				
static UINT WriteImage(
				 CFile* pFile,
				 LPVOID lpImage, DWORD dwSize )
{
	UINT uiError = ERROR_NO_ERROR;
	if(lpImage)
    {
		pFile->Write( lpImage, (UINT)dwSize );

        // check if we need to have the image alligned
        if(Pad4(dwSize))
            pFile->Write( &dwZeroPad, Pad4(dwSize) );
    }
	
	return uiError;
}

static UINT GetNameOrOrdFile( CFile* pfile, WORD* pwId, LPSTR lpszId, BYTE bMaxStrLen )
{
	UINT uiSize = 0;
	
	*pwId = 0;
	
	// read the first WORD to see if it is a string or an ordinal
	pfile->Read( pwId, sizeof(WORD) );	
	if(*pwId==0xFFFF) {
		// This is an Ordinal
		pfile->Read( pwId, sizeof(WORD) );	
		*lpszId = '\0';
		uiSize = 2;
	} else {
        uiSize++;
	    _WCSTOMBS( lpszId, (PWSTR)pwId, 3);
	    while((*lpszId++) && (bMaxStrLen-2)) {
	    	pfile->Read( pwId, sizeof(WORD) );	
	    	_WCSTOMBS( lpszId, (PWSTR)pwId, 3);
	        uiSize++;
	    	bMaxStrLen--;
	    }
	    if ( (!(bMaxStrLen-2)) && (*pwId) ) {
	    	// Failed
	    	return 0;
	    }
	    // Check padding
		BYTE bPad = Pad4((UINT)(uiSize*sizeof(WORD)));
		if(bPad)
			pfile->Read( pwId, sizeof(WORD) );	
	}
	
	return uiSize;
}   	

////////////////////////////////////////////////////////////////////////////////
// Helper
////////////////////////////////////////////////////////////////////////////////
static char szCaption[MAXSTR];

static UINT GenerateMenu( LPVOID lpNewBuf, LONG dwNewSize,
						  LPVOID lpNewI, DWORD* pdwNewImageSize )
{
	UINT uiError = ERROR_NO_ERROR;
	
	BYTE far * lpNewImage = (BYTE far *) lpNewI;
	LONG dwNewImageSize = *pdwNewImageSize;
	
	BYTE far * lpBuf = (BYTE far *) lpNewBuf;	
	
	LPRESITEM lpResItem = LPNULL;
	
	// We have to read the information from the lpNewBuf
	// Updated items
	WORD wUpdPos = 0;
	WORD fUpdItemFlags;
	WORD wUpdMenuId;
	char szUpdTxt[256];
	
	LONG  dwOverAllSize = 0l;
	
	// invent the menu flags
	dwOverAllSize += PutDWord( &lpNewImage, 0L, &dwNewImageSize);
	
	while(dwNewSize>0) {
		if (dwNewSize ) {
			lpResItem = (LPRESITEM) lpBuf;
			
			wUpdMenuId = LOWORD(lpResItem->dwItemID);
			fUpdItemFlags = (WORD)lpResItem->dwFlags;
			strcpy( szUpdTxt, lpResItem->lpszCaption );
			lpBuf += lpResItem->dwSize;
			dwNewSize -= lpResItem->dwSize;
		}
		
		dwOverAllSize += PutWord( &lpNewImage, fUpdItemFlags, &dwNewImageSize);
		
		if ( !(fUpdItemFlags & MF_POPUP) )
			dwOverAllSize += PutWord( &lpNewImage, wUpdMenuId, &dwNewImageSize);
		
		// Write the text
		// check if it is a separator
		if ( !(fUpdItemFlags) && !(wUpdMenuId) )
			szUpdTxt[0] = 0x00;	
		dwOverAllSize += PutStringW( &lpNewImage, &szUpdTxt[0], &dwNewImageSize);
		
	}
	
	if (dwOverAllSize>(LONG)*pdwNewImageSize) {
		// calc the padding as well
		dwOverAllSize += (BYTE)Pad16((DWORD)(dwOverAllSize));
		*pdwNewImageSize = dwOverAllSize;
		return uiError;
	}
		
	*pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;
	
	if(*pdwNewImageSize>0) {
		// calculate padding
		BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
		if (bPad>dwNewImageSize) {
			*pdwNewImageSize += bPad;
			return uiError;
		}
		memset(lpNewImage, 0x00, bPad);
		*pdwNewImageSize += bPad;
	}
	
	return uiError;
}



static
UINT
GenerateString( LPVOID lpNewBuf, LONG dwNewSize,
			LPVOID lpNewI, DWORD* pdwNewImageSize )
{
	UINT uiError = ERROR_NO_ERROR;
	
	LONG dwNewImageSize = *pdwNewImageSize;
	BYTE far * lpNewImage = (BYTE far *) lpNewI;
	
	BYTE far * lpBuf = (BYTE far *) lpNewBuf;	
	LPRESITEM lpResItem = LPNULL;
	
	// We have to read the information from the lpNewBuf
	WORD wLen;
	WORD wPos = 0;
	
	LONG dwOverAllSize = 0l;
	
	while(dwNewSize>0) {
		if ( dwNewSize ) {
			lpResItem = (LPRESITEM) lpBuf;
				 			
			strcpy( szCaption, lpResItem->lpszCaption );
			lpBuf += lpResItem->dwSize;
			dwNewSize -= lpResItem->dwSize;
		}
		
		wLen = strlen(szCaption);

        // Write the text
        dwOverAllSize += PutPascalStringW( &lpNewImage, &szCaption[0], wLen, &dwNewImageSize );
	}
	
	if (dwOverAllSize>(LONG)*pdwNewImageSize) {
		// calc the padding as well
		dwOverAllSize += (BYTE)Pad16((DWORD)(dwOverAllSize));
		*pdwNewImageSize = dwOverAllSize;
		return uiError;
	}
	
	*pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;
	
	if(*pdwNewImageSize>0) {
		// calculate padding
		BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
		if (bPad>dwNewImageSize) {
			*pdwNewImageSize += bPad;
			return uiError;
		}
		memset(lpNewImage, 0x00, bPad);
		*pdwNewImageSize += bPad;
	}
	
	return uiError;
}

static
UINT
GenerateDialog( LPVOID lpNewBuf, LONG dwNewSize,
			    LPVOID lpNewI, DWORD* pdwNewImageSize )
{
	// Should be almost impossible for a Dialog to be Huge
	UINT uiError = ERROR_NO_ERROR;
	
	BYTE far * lpNewImage = (BYTE far *) lpNewI;
	LONG dwNewImageSize = *pdwNewImageSize;
	
	BYTE far * lpBuf = (BYTE far *) lpNewBuf;	
	LPRESITEM lpResItem = LPNULL;
	
	LONG dwOverAllSize = 0L;
	
	BYTE	bIdCount = 0;
	
	// Dialog Elements
    DWORD 	dwStyle = 0L;
	DWORD 	dwExtStyle = 0L;
	WORD    wNumOfElem = 0;
	WORD	wX = 0;
	WORD	wY = 0;
	WORD	wcX = 0;
	WORD	wcY = 0;
	WORD	wId = 0;
	char	szClassName[128];
	WORD	wClassName;
	//char	szCaption[128];
	WORD	wPointSize = 0;
	char	szFaceName[128];
	WORD	wPos = 1;
	
	// Get the infrmation from the updated resource
	if ( dwNewSize ) {
		lpResItem = (LPRESITEM) lpBuf;
		wX = lpResItem->wX;
		wY = lpResItem->wY;
		wcX = lpResItem->wcX;
		wcY = lpResItem->wcY;
		wId = LOWORD(lpResItem->dwItemID);
		wPointSize = lpResItem->wPointSize;
		dwStyle = lpResItem->dwStyle;
		dwExtStyle = lpResItem->dwExtStyle;
		wClassName = lpResItem->wClassName;
		strcpy( szCaption, lpResItem->lpszCaption );
		strcpy( szClassName, lpResItem->lpszClassName );
		strcpy( szFaceName, lpResItem->lpszFaceName );
		if (*szFaceName != '\0')
		{
			dwStyle |= DS_SETFONT;
		}
		lpBuf += lpResItem->dwSize;
		dwNewSize -= lpResItem->dwSize;
	}
	
	DWORD dwPadCalc = dwOverAllSize;
	// Header info
	dwOverAllSize = PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
	dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );
	
    // Store the position of the numofelem for a later fixup
	BYTE far * lpNumOfElem = lpNewImage;
    LONG lSizeOfNum = sizeof(WORD);
	dwOverAllSize += PutWord( &lpNewImage, wNumOfElem, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
    dwOverAllSize += PutNameOrOrd( &lpNewImage, 0, "", &dwNewImageSize );
    dwOverAllSize += PutClassName( &lpNewImage, wClassName, &szClassName[0], &dwNewImageSize );
    dwOverAllSize += PutCaptionOrOrd( &lpNewImage, 0, &szCaption[0], &dwNewImageSize,
    	wClassName, dwStyle );
    if( dwStyle & DS_SETFONT ) {
    	dwOverAllSize += PutWord( &lpNewImage, wPointSize, &dwNewImageSize );
        dwOverAllSize += PutStringW( &lpNewImage, &szFaceName[0], &dwNewImageSize );
    }

    // Check if padding is needed
    BYTE bPad = (BYTE)Pad4((WORD)(dwOverAllSize-dwPadCalc));
    if (bPad) {
        if( (bPad)<=dwNewImageSize )
            memset( lpNewImage, 0x00, bPad );
        dwNewImageSize -= (bPad);
        dwOverAllSize += (bPad);
        lpNewImage += (bPad);
    }

	while( dwNewSize>0 ) {
		wNumOfElem++;
	
	    if ( dwNewSize ) {
	    	TRACE1("\t\tGenerateDialog:\tdwNewSize=%ld\n",(LONG)dwNewSize);
			TRACE1("\t\t\t\tlpszCaption=%Fs\n",lpResItem->lpszCaption);

			lpResItem = (LPRESITEM) lpBuf;
			wX = lpResItem->wX;
			wY = lpResItem->wY;
			wcX = lpResItem->wcX;
			wcY = lpResItem->wcY;
			wId = LOWORD(lpResItem->dwItemID);
			dwStyle = lpResItem->dwStyle;
			dwExtStyle = lpResItem->dwExtStyle;
			wClassName = LOBYTE(lpResItem->wClassName);
			strcpy( szCaption, lpResItem->lpszCaption );
			strcpy( szClassName, lpResItem->lpszClassName );
			lpBuf += lpResItem->dwSize;
			dwNewSize -= lpResItem->dwSize;
		}		 	
				
        dwPadCalc = dwOverAllSize;
        //write the control
       	dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
       	dwOverAllSize += PutDWord( &lpNewImage, dwExtStyle, &dwNewImageSize );

        dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize );
        dwOverAllSize += PutClassName( &lpNewImage, wClassName, &szClassName[0], &dwNewImageSize );
        dwOverAllSize += PutCaptionOrOrd( &lpNewImage, 0, &szCaption[0], &dwNewImageSize,
        	wClassName, dwStyle );
        dwOverAllSize += PutWord( &lpNewImage, 0, &dwNewImageSize );

        // Check if padding is needed
        bPad = (BYTE)Pad4((WORD)(dwOverAllSize-dwPadCalc));
        if (bPad) {
            if( (bPad)<=dwNewImageSize )
                memset( lpNewImage, 0x00, bPad );
            dwNewImageSize -= (bPad);
            dwOverAllSize += (bPad);
            lpNewImage += (bPad);
        }

	}
	
	if (dwOverAllSize>(LONG)*pdwNewImageSize) {
		// calc the padding as well
		dwOverAllSize += (BYTE)Pad16((DWORD)(dwOverAllSize));
		*pdwNewImageSize = dwOverAllSize;
		return uiError;
	}
		
	*pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;
	
	if(*pdwNewImageSize>0) {
		// calculate padding
		BYTE bPad = (BYTE)Pad16((DWORD)(*pdwNewImageSize));
		if (bPad>dwNewImageSize) {
			*pdwNewImageSize += bPad;
			return uiError;
		}
		memset(lpNewImage, 0x00, bPad);
		*pdwNewImageSize += bPad;
	}
	
	// fixup the number of items
	PutWord( &lpNumOfElem, wNumOfElem, &lSizeOfNum );
	
	return uiError;
}						

////////////////////////////////////////////////////////////////////////////
// DLL Specific helpers
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation
////////////////////////////////////////////////////////////////////////////
// Library init

////////////////////////////////////////////////////////////////////////////
// This function should be used verbatim.  Any initialization or termination
// requirements should be handled in InitPackage() and ExitPackage().
//
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory
		// here, use the TRACE or ASSERT macros or call MessageBox
		AfxInitExtensionModule(extensionDLL, hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxWinTerm();
	}

	if (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)
		return 0;		// CRT term	Failed

	return 1;   // ok
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\rcdata\kernel32\krnl32.cpp ===
// kernel32.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <afxdllx.h>
#include "..\..\common\rwdll.h"
#include "..\..\common\rw32hlpr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static AFX_EXTENSION_MODULE kernel32DLL = { NULL, NULL };

UINT ParseRCData( LPCSTR lpszResId, LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize );
UINT UpdateRCData( LPVOID lpNewBuf, LONG dwNewSize, LPVOID lpOldI, LONG dwOldImageSize, LPVOID lpNewI, DWORD* pdwNewImageSize );

extern char szCaption[MAXSTR];

/////////////////////////////////////////////////////////////////////////////
// This file implements the RCDATA handling for the file kernel32.dll

extern "C"
DllExport
UINT
APIENTRY
RWParseImageEx(
    LPCSTR  lpszType,
    LPCSTR  lpszResId,
    LPVOID  lpImageBuf,
    DWORD   dwImageSize,
    LPVOID  lpBuffer,
    DWORD   dwSize,
    LPCSTR  lpDllName
    )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE * lpBuf = (BYTE *)lpBuffer;
    DWORD dwBufSize = dwSize;

    // The Type we can parse are only the standard ones
    // This function should fill the lpBuffer with an array of ResItem structure
    switch ((UINT)LOWORD(lpszType)) {
        case 10:
            uiError = ParseRCData( lpszResId, lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
               
        default:
        break;
    }

    return uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWUpdateImageEx(
    LPCSTR  lpszType,
    LPVOID  lpNewBuf,
    DWORD   dwNewSize,
    LPVOID  lpOldImage,
    DWORD   dwOldImageSize,
    LPVOID  lpNewImage,
    DWORD*  pdwNewImageSize,
    LPCSTR  lpRCFilename
    )
{
    UINT uiError = ERROR_NO_ERROR;

    // The Type we can parse are only the standard ones
    switch ((UINT)LOWORD(lpszType)) {
        case 10:
            uiError = UpdateRCData( lpNewBuf, dwNewSize,
                                    lpOldImage, dwOldImageSize,
                                    lpNewImage, pdwNewImageSize );
        break;
        default:
            *pdwNewImageSize = 0L;
            uiError = ERROR_RW_NOTREADY;
        break;
    }

    return uiError;
}

/////////////////////////////////////////////////////////////////////////////
// Real implementation of the parsers

UINT
ParseRCData( LPCSTR lpszResId, LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    //
    // The data in the RCDATA is just a string null terminated
    //
    LPRESITEM lpResItem = (LPRESITEM)lpBuffer;
     
    //
    // Get the string from the image
    //
    GetStringW( (BYTE**)&lpImageBuf, &szCaption[0], (LONG*)&dwISize, MAXSTR );
    LONG dwOverAllSize = sizeof(RESITEM)+strlen(szCaption);

    if( (LONG)dwSize>dwOverAllSize ) 
    {
        //
        // Clear the resitem buffer
        //
        memset(lpResItem, '\0', dwSize);

        lpResItem->dwSize = dwOverAllSize;
        lpResItem->dwItemID = 1;   
        lpResItem->dwResID = LOWORD(lpszResId);

        lpResItem->dwTypeID = 11;   
        lpResItem->lpszCaption = strcpy((((char*)lpResItem)+sizeof(RESITEM)), &szCaption[0]);
    }

    return (UINT)(dwOverAllSize);
}

UINT
UpdateRCData( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    LPRESITEM lpResItem = (LPRESITEM)lpNewBuf;

    if(*pdwNewImageSize>strlen(lpResItem->lpszCaption))
    {
        // Write the text
        *pdwNewImageSize = PutStringW( (BYTE **)&lpNewI, lpResItem->lpszCaption, (LONG*)pdwNewImageSize );

    }

    return uiError;
}

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		TRACE0("RCKERNEL32.DLL Initializing!\n");

        InitGlobals();
		AfxInitExtensionModule(kernel32DLL, hInstance);

		new CDynLinkLibrary(kernel32DLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		TRACE0("RCKERNEL32.DLL Terminating!\n");
	}
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\win32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\win16\win16.cpp ===
//+---------------------------------------------------------------------------
//
//  File:   win16.cpp
//
//  Contents:   Implementation for the Windows 16 Read/Write module
//
//  Classes:    one
//
//  History:    26-July-93   alessanm    created
//
//----------------------------------------------------------------------------

#include <afxwin.h>
#include "..\common\rwdll.h"
#include "newexe.h"
#include <stdio.h>

#include <limits.h>

/////////////////////////////////////////////////////////////////////////////
// Initialization of MFC Extension DLL

#include "afxdllx.h"    // standard MFC Extension DLL routines

static AFX_EXTENSION_MODULE NEAR extensionDLL = { NULL, NULL};

/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define MODULENAME "RWWin16.dll"
#define RWTAG "WIN16"

#define LPNULL 0L
#define Pad16(x) ((((x+15)>>4)<<4)-x)
#define Pad4(x) ((((x+3)>>2)<<2)-x)

#define MAXSTR 300
#define MAXID 128
#define IMAGE_DOS_SIGNATURE                 0x5A4D      // MZ
#define IMAGE_WIN_SIGNATURE                 0x454E      // NE

#define VB					// RCDATA process for VB only - WB
#ifdef VB
static const RES_SIGNATURE = 0xA5;  // identifier for VB entry
#endif


// Code pages
#define CP_ASCII7   0       // 7-bit ASCII
#define CP_JIS      932     // Japan (Shift - JIS X-0208)
#define CP_KSC      949     // Korea (Shift - KSC 5601)
#define CP_GB5      950     // Taiwan (GB5)
#define CP_UNI      1200    // Unicode
#define CP_EE       1250    // Latin-2 (Eastern Europe)
#define CP_CYR      1251    // Cyrillic
#define CP_MULTI    1252    // Multilingual
#define CP_GREEK    1253    // Greek
#define CP_TURK     1254    // Turkish
#define CP_HEBR     1255    // Hebrew
#define CP_ARAB     1256    // Arabic

/////////////////////////////////////////////////////////////////////////////
// General type Declarations
typedef unsigned char UCHAR;

typedef UCHAR * PUCHAR;

typedef struct ver_block {
    WORD wBlockLen;
    WORD wValueLen;
    WORD wType;
    WORD wHead;
    BYTE far * pValue;
    char szKey[100];
    char szValue[300];
} VER_BLOCK;

/////////////////////////////////////////////////////////////////////////////
// Function Declarations

static UINT GetResInfo(
                      CFile*,
                      WORD* wTypeId, LPSTR lplpszTypeId, BYTE bMaxTypeLen,
                      WORD* wNameId, LPSTR lplpszNameId, BYTE bMaxNameLen,
                      WORD* pwFlags,
                      DWORD* dwSize, DWORD* dwFileOffset );

static UINT WriteHeader(
                       CFile*,
                       WORD wTypeId, LPSTR lpszTypeId,
                       WORD wNameId, LPSTR lpszNameId,
                       WORD wFlags );

static UINT WriteImage(
                      CFile*,
                      LPVOID lpImage, DWORD dwSize );

static UINT GetUpdatedRes(
                         LPVOID far * lplpBuffer,
                         UINT* uiSize,
                         WORD* wTypeId, LPSTR lplpszTypeId,
                         WORD* wNameId, LPSTR lplpszNameId,
                         DWORD* dwlang, DWORD* dwSize );

static UINT GetUpdatedItem(
                          LPVOID far * lplpBuffer,
                          LONG* dwSize,
                          WORD* wX, WORD* wY,
                          WORD* wcX, WORD* wcY,
                          DWORD* dwPosId,
                          DWORD* dwStyle, DWORD* dwExtStyle,
                          LPSTR lpszText);

static int GetVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK* pverBlock);
static int PutVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK verBlock,
                       LPSTR lpStr, BYTE far * far * lplpBlockSize, WORD* pwPad);

/////////////////////////////////////////////////////////////////////////////
// Helper Function Declarations
static UINT CopyFile( CFile* filein, CFile* fileout );
static UINT GetNameOrOrdFile( CFile* pfile, WORD* pwId, LPSTR lpszId, BYTE bMaxStrLen );
static UINT ParseMenu( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseString( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseDialog( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseCursor( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseIcon( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseBitmap( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
static UINT ParseAccel( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
#ifdef VB
static UINT ParseVBData(  LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );
#endif
static UINT ParseVerst( LPVOID lpImageBuf, DWORD dwImageSize,  LPVOID lpBuffer, DWORD dwSize );

static UINT GenerateFile( LPCSTR        lpszTgtFilename,
                          HANDLE        hResFileModule,
                          LPVOID        lpBuffer,
                          UINT      uiSize,
                          HINSTANCE   hDllInst
                        );


static UINT UpdateMenu( LPVOID lpNewBuf, LONG dwNewSize,
                        LPVOID lpOldImage, LONG dwOldImageSize,
                        LPVOID lpNewImage, DWORD* pdwNewImageSize );
static UINT GenerateMenu( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpNewImage, DWORD* pdwNewImageSize );
static UINT UpdateString( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpOldI, LONG dwOldImageSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize );
static UINT GenerateString( LPVOID lpNewBuf, LONG dwNewSize,
                            LPVOID lpNewImage, DWORD* pdwNewImageSize );

static UINT UpdateDialog( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpOldI, LONG dwOldImageSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize );
static UINT GenerateDialog( LPVOID lpNewBuf, LONG dwNewSize,
                            LPVOID lpNewImage, DWORD* pdwNewImageSize );

static UINT UpdateAccel(LPVOID lpNewBuf, LONG dwNewSize,
                        LPVOID lpOldImage, LONG dwOldImageSize,
                        LPVOID lpNewImage, DWORD* pdwNewImageSize );
#ifdef VB
static UINT UpdateVBData( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpOldI, LONG dwOldImageSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize );
#endif

static UINT UpdateVerst( LPVOID lpNewBuf, LONG dwNewSize,
                         LPVOID lpOldI, LONG dwOldImageSize,
                         LPVOID lpNewI, DWORD* pdwNewImageSize );


static BYTE SkipByte( BYTE far * far * lplpBuf, UINT uiSkip, LONG* pdwRead );

static BYTE PutDWord( BYTE far * far* lplpBuf, DWORD dwValue, LONG* pdwSize );
static BYTE PutWord( BYTE far * far* lplpBuf, WORD wValue, LONG* pdwSize );
static BYTE PutByte( BYTE far * far* lplpBuf, BYTE bValue, LONG* pdwSize );
static UINT PutString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize );
static UINT PutPascalString( BYTE far * far* lplpBuf, LPSTR lpszText, BYTE bLen, LONG* pdwSize );
static UINT PutNameOrOrd( BYTE far * far* lplpBuf, WORD wOrd, LPSTR lpszText, LONG* pdwSize );
static UINT PutCaptionOrOrd( BYTE far * far* lplpBuf, WORD wOrd, LPSTR lpszText, LONG* pdwSize,
                             BYTE bClass, DWORD dwStyle );
static UINT PutClassName( BYTE far * far* lplpBuf, BYTE bClass, LPSTR lpszText, LONG* pdwSize );
static UINT PutControlClassName( BYTE far * far* lplpBuf, BYTE bClass, LPSTR lpszText, LONG* pdwSize );

static BYTE GetDWord( BYTE far * far* lplpBuf, DWORD* dwValue, LONG* pdwSize );
static BYTE GetWord( BYTE far * far* lplpBuf, WORD* wValue, LONG* pdwSize );
static BYTE GetByte( BYTE far * far* lplpBuf, BYTE* bValue, LONG* pdwSize );
static UINT GetNameOrOrd( BYTE far * far* lplpBuf, WORD* wOrd, LPSTR lpszText, LONG* pdwSize );
static UINT GetCaptionOrOrd( BYTE far * far* lplpBuf, WORD* wOrd, LPSTR lpszText, LONG* pdwSize,
                             BYTE wClass, DWORD dwStyle );
static UINT GetString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize );
static UINT GetClassName( BYTE far * far* lplpBuf, BYTE* bClass, LPSTR lpszText, LONG* pdwSize );
static UINT GetControlClassName( BYTE far * far* lplpBuf, BYTE* bClass, LPSTR lpszText, LONG* pdwSize );
static UINT CopyText( BYTE far * far * lplpTgt, BYTE far * far * lplpSrc, LONG* pdwTgtSize, LONG* pdwSrcSize);
static int  GetVSString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize, int cMaxLen );
static LPRESITEM GetItem( BYTE far * lpBuf, LONG dwNewSize, LPSTR lpStr );
static DWORD CalcID( WORD wId, BOOL bFlag );
static DWORD GenerateTransField( WORD wLang, BOOL bReverse );
static void GenerateTransField( WORD wLang, VER_BLOCK * pVer );
static void ChangeLanguage( LPVOID, UINT );
// Allignment helpers
static LONG Allign( BYTE * * lplpBuf, LONG* plBufSize, LONG lSize );

/////////////////////////////////////////////////////////////////////////////
// Global variables
static BYTE sizeofByte = sizeof(BYTE);
static BYTE sizeofWord = sizeof(WORD);
static BYTE sizeofDWord = sizeof(DWORD);
static CWordArray wIDArray;
static DWORD    gLang = 0;
/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

//[registration]
extern "C"
BOOL    FAR PASCAL RWGetTypeString(LPSTR lpszTypeName)
{
    strcpy( lpszTypeName, RWTAG );
    return FALSE;
}

extern "C"
BOOL    FAR PASCAL RWValidateFileType   (LPCSTR lpszFilename)
{
    UINT uiError = ERROR_NO_ERROR;
    CFile file;
    WORD w;

    // we Open the file to see if it is a file we can handle
    if (!file.Open( lpszFilename, CFile::shareDenyNone | CFile::typeBinary | CFile::modeRead ))
        return FALSE;

    // Read the file signature
    file.Read((WORD*)&w, sizeof(WORD));
    if (w==IMAGE_DOS_SIGNATURE) {
        file.Seek( 0x18, CFile::begin );
        file.Read((WORD*)&w, sizeof(WORD));
        if (w<0x0040) {
            // this is not a Windows Executable
            file.Close();
            return FALSE;
        }
        // get offset to header
        file.Seek( 0x3c, CFile::begin );
        file.Read((WORD*)&w, sizeof(WORD));

        // Read header
        new_exe ne;
        file.Seek( w, CFile::begin );
        file.Read(&ne, sizeof(new_exe));
        if (NE_MAGIC(ne)==LOWORD(IMAGE_WIN_SIGNATURE)) {
            // this is a Windows Executable
            // we can handle the situation
            file.Close();
            return TRUE;
        }
    }
    file.Close();
    return FALSE;
}


extern "C"
UINT
APIENTRY
RWReadTypeInfo(
              LPCSTR lpszFilename,
              LPVOID lpBuffer,
              UINT* puiSize

              )
{
    UINT  uiError = ERROR_NO_ERROR;
    BYTE  far * lpBuf = (BYTE far *)lpBuffer;
    DWORD uiBufSize = *puiSize;

    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile file;
    WORD i;
    WORD wAlignShift;
    WORD w, wResCount;
    WORD wWinHeaderOffset, wResTableOffset;
    WORD wCurTypeOffset, wCurNameOffset;
    BYTE nCount;

    WORD wTypeId; DWORD dwTypeId;
    static char szTypeId[128];

    WORD wNameId;
    static char szNameId[128];

    WORD  wSize, wFileOffset;
    DWORD dwSize,dwFileOffset;
    WORD  wResidentOffset;
    DWORD dwVerStampOffset = 0xffffffff;
    DWORD dwVerStampSize = 0;

    UINT uiOverAllSize = 0;


    if (!RWValidateFileType(lpszFilename))
        return ERROR_RW_INVALID_FILE;

    // Open the file and try to read the information on the resource in it.
    if (!file.Open(lpszFilename, CFile::shareDenyNone | CFile::modeRead | CFile::typeBinary))
        return ERROR_FILE_OPEN;

    // we try to read as much information as we can
    // Because this is a exe file we can read all the information we need.

    file.Read((WORD*)&w, sizeof(WORD));
    if (w!=IMAGE_DOS_SIGNATURE) return ERROR_RW_INVALID_FILE;

    file.Seek( 0x18, CFile::begin );
    file.Read((WORD*)&w, sizeof(WORD));
    if (w<0x0040) {
        // this is not a Windows Executable
        file.Close();
        return ERROR_RW_INVALID_FILE;
    }

    // Get offset to Windows new header
    file.Seek( 0x3c, CFile::begin );
    file.Read((WORD*)&wWinHeaderOffset, sizeof(WORD));

    // Read and save Windows header Offset
    file.Seek( wWinHeaderOffset, CFile::begin );

    // Read header
    new_exe ne;
    file.Read(&ne, sizeof(new_exe));
    if (NE_MAGIC(ne)!=LOWORD(IMAGE_WIN_SIGNATURE)) {
        // this is not a Windows Executable
        file.Close();
        return ERROR_RW_INVALID_FILE;
    }

    // this is a Windows 16 Executable
    // we can handle the situation
    // Later we want to check for the file type

    // Location 24H inside of the Windows header has the relative offset from
    // the beginning of the Windows header to the beginning of the resource table
    file.Seek (wWinHeaderOffset+0x24, CFile::begin);
    file.Read ((WORD*)&wResTableOffset, sizeof(WORD));
    file.Read ((WORD*)&wResidentOffset, sizeof(WORD));

    // Check if there are resources
    if (wResTableOffset == wResidentOffset) {
        file.Close ();
        return ERROR_RW_NO_RESOURCES;
    }

    // Read the resurce table
    new_rsrc rsrc;
    file.Seek (wWinHeaderOffset+NE_RSRCTAB(ne), CFile::begin);
    file.Read (&rsrc, sizeof(new_rsrc));

    WORD rsrc_size = NE_RESTAB(ne)-NE_RSRCTAB(ne);

    // Read and save alignment shift count
    file.Seek (wWinHeaderOffset+wResTableOffset, CFile::begin);
    file.Read ((WORD*)&wAlignShift, sizeof(WORD));

    // Read the first type ID
    file.Read ((WORD*)&wTypeId, sizeof(WORD));

    // Save the Offset of the current TypeInfo record
    wCurTypeOffset = wWinHeaderOffset + wResTableOffset + 2;

    // reset the global language
    gLang = 0;

    // Process TypeInfo records while there are TypeInfo record left
    while (wTypeId) {
        // Get Name of ord
        if (!(wTypeId & 0x8000)) {
            // It is a Offset to a string
            dwTypeId = (MAKELONG(wTypeId, 0)); //<<wAlignShift;
            file.Seek (wWinHeaderOffset+wResTableOffset+dwTypeId, CFile::begin);
            // Get the character count for the ID string
            file.Read ((BYTE*)&nCount, sizeof(BYTE));
            // Read the ID string
            file.Read (szTypeId, nCount);
            // Put null at the end of the string
            szTypeId[nCount] = 0;

            if (0 == strlen(szTypeId))
                return ERROR_RW_INVALID_FILE;

            // Set wTypeId to zero
            wTypeId = 0;
        } else {
            // It is an ID
            // Turn off the high bit
            wTypeId = wTypeId & 0x7FFF;
            if (0 == wTypeId)
                return ERROR_RW_INVALID_FILE;

            // Set the ID string to null
            szTypeId[0] = 0;
        }

        // Restore the file read point
        file.Seek (wCurTypeOffset+2, CFile::begin);

        // Get the count for this type of resource
        file.Read ((WORD*)&wResCount, sizeof(WORD));

        // Pass the reserved DWORD
        file.Seek (4, CFile::current);

        // Save the Offset of the current NameInfo record
        wCurNameOffset = wCurTypeOffset + 8;

        // Process NameInfo records
        for (i = 0; i < wResCount; i++) {
            file.Read ((WORD*)&wFileOffset, sizeof(WORD));
            file.Read ((WORD*)&wSize, sizeof(WORD));
            // Pass the flags
            file.Seek (2, CFile::current);
            file.Read ((WORD*)&wNameId, sizeof(WORD));

            // Get name of ord
            if (!(wNameId & 0x8000)) {
                // It is a Offset to a string
                file.Seek (wWinHeaderOffset+wResTableOffset+wNameId, CFile::begin);
                // Get the character count for the string
                file.Read ((BYTE*)&nCount, sizeof(BYTE));
                // Read the string
                file.Read (szNameId, nCount);
                // Put null at the end of the string
                szNameId[nCount] = 0;
                // Set wNameId to zero
                wNameId = 0;
            } else {
                // It is an ID
                // Turn off the high bit
                wNameId = wNameId & 0x7FFF;
                if (0 == wNameId)
                    return ERROR_RW_INVALID_FILE;

                // Set the string to null
                szNameId[0] = 0;
            }

            dwSize = (MAKELONG (wSize, 0))<<wAlignShift;
//          dwSize = MAKELONG (wSize, 0);
            dwFileOffset = (MAKELONG (wFileOffset, 0))<<wAlignShift;

            // Put the data into the buffer

            uiOverAllSize += PutWord( &lpBuf, wTypeId, (LONG*)&uiBufSize );
            uiOverAllSize += PutString( &lpBuf, szTypeId, (LONG*)&uiBufSize );
            // Check if it is alligned
            uiOverAllSize += Allign( &lpBuf, (LONG*)&uiBufSize, (LONG)uiOverAllSize);

            uiOverAllSize += PutWord( &lpBuf, wNameId, (LONG*)&uiBufSize );
            uiOverAllSize += PutString( &lpBuf, szNameId, (LONG*)&uiBufSize );
            // Check if it is alligned
            uiOverAllSize += Allign( &lpBuf, (LONG*)&uiBufSize, (LONG)uiOverAllSize);

            uiOverAllSize += PutDWord( &lpBuf, gLang, (LONG*)&uiBufSize );

            uiOverAllSize += PutDWord( &lpBuf, dwSize, (LONG*)&uiBufSize );

            uiOverAllSize += PutDWord( &lpBuf, dwFileOffset, (LONG*)&uiBufSize );

            TRACE("WIN16: Type: %hd\tName: %hd\tOffset: %lX\n", wTypeId, wNameId, dwFileOffset);

            // Check if this is the Version stamp block and save the offset to it
            if (wTypeId==16) {
                dwVerStampOffset = dwFileOffset;
                dwVerStampSize = dwSize;
            }

            // Update the current NameInfo record offset
            wCurNameOffset = wCurNameOffset + 12;
            // Move file pointer to the next NameInfo record
            file.Seek (wCurNameOffset, CFile::begin);
        }

        // Update the current TypeInfo record offset
        wCurTypeOffset = wCurTypeOffset + 8 + wResCount * 12;
        // Move file pointer to the next TypeInfo record
        file.Seek (wCurTypeOffset, CFile::begin);
        // Read the next TypeId
        file.Read ((WORD*)&wTypeId, sizeof(WORD));
    }

    // Now do we have a VerStamp Offset
    if (dwVerStampOffset!=0xffffffff) {
        // Let's get the language ID and touch the buffer with the new information
        file.Seek (dwVerStampOffset, CFile::begin);


        DWORD  dwBuffSize = dwVerStampSize;
        char * pBuff = new char[dwVerStampSize+1];
        char * pTrans = pBuff;
        char * pTrans2;
        file.Read(pBuff, dwVerStampSize);

        while ( pTrans2 = (LPSTR)memchr(pTrans, 'T', dwBuffSize) ) {
            dwBuffSize -= (DWORD)(pTrans2 - pTrans);

            pTrans = pTrans2;
            if (!memcmp( pTrans, "Translation", 11)) {
                pTrans = pTrans + 12;
                gLang = (WORD)*((WORD*)pTrans);
                break;
            }

            ++pTrans;
            dwBuffSize--;
        }

        delete pBuff;

        if (gLang!=0) {
            // walk the buffer and change the language id
            ChangeLanguage(lpBuffer, uiOverAllSize);
        }
    }

    file.Close();
    *puiSize = uiOverAllSize;
    return uiError;
}

extern "C"
DWORD
APIENTRY
RWGetImage(
          LPCSTR  lpszFilename,
          DWORD   dwImageOffset,
          LPVOID  lpBuffer,
          DWORD   dwSize
          )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    DWORD dwBufSize = dwSize;
    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile file;

    // Open the file and try to read the information on the resource in it.
    if (!file.Open(lpszFilename, CFile::shareDenyNone | CFile::modeRead | CFile::typeBinary)) {
        return (DWORD)ERROR_FILE_OPEN;
    }

    if ( dwImageOffset!=(DWORD)file.Seek( dwImageOffset, CFile::begin) )
        return (DWORD)ERROR_FILE_INVALID_OFFSET;
    if (dwSize>UINT_MAX) {
        // we have to read the image in different steps
        return (DWORD)0L;
    } else uiError = file.Read( lpBuf, (UINT)dwSize);
    file.Close();

    return (DWORD)uiError;
}

extern "C"
UINT
APIENTRY
RWParseImage(
            LPCSTR  lpszType,
            LPVOID  lpImageBuf,
            DWORD   dwImageSize,
            LPVOID  lpBuffer,
            DWORD   dwSize
            )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    DWORD dwBufSize = dwSize;

    // The Type we can parse are only the standard ones
    // This function should fill the lpBuffer with an array of ResItem structure
    switch ((UINT)LOWORD(lpszType)) {
        case 1:
            uiError = ParseCursor( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 2:
            uiError = ParseBitmap( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 3:
            uiError = ParseIcon( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 4:
            uiError = ParseMenu( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 5:
            uiError = ParseDialog( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 6:
            uiError = ParseString( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        case 9:
            uiError = ParseAccel( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;
#ifdef VB
        case 10:
            uiError = ParseVBData(  lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;
#endif


        case 16:
            uiError = ParseVerst( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
            break;

        default:
            break;
    }

    return uiError;
}

extern"C"
UINT
APIENTRY
RWWriteFile(
           LPCSTR      lpszSrcFilename,
           LPCSTR      lpszTgtFilename,
           HANDLE      hResFileModule,
           LPVOID      lpBuffer,
           UINT        uiSize,
           HINSTANCE   hDllInst,
           LPCSTR      lpszSymbol
           )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = LPNULL;
    UINT uiBufSize = uiSize;
    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile fileIn;
    CFile fileOut;
    BOOL  bfileIn = TRUE;

    WORD wTypeId;  DWORD dwTypeId;
    char szTypeId[128];

    WORD wNameId;
    char szNameId[128];

    DWORD dwSize;
    DWORD dwFileOffset;

    WORD wUpdTypeId = 0;
    static char szUpdTypeId[128];

    static char szUpdNameId[128];

    UINT uiBufStartSize = uiBufSize;
    DWORD dwImageBufSize = 0L;
    BYTE far * lpImageBuf = 0L;

    WORD wWinHeaderOffset = 0;
    WORD wResTableOffset = 0;
    WORD wCurTypeOffset = 0;
    WORD wFileOffset  = 0;
    WORD wSize = 0;
    WORD wCurNameOffset = 0;
    WORD wAlignShift = 0;
    WORD wResDataOffset = 0;
    WORD wResDataBegin = 0;
    WORD wCurResDataBegin = 0;
    DWORD dwResDataBegin = 0L;
    DWORD dwCurResDataBegin = 0L;
    WORD i = 0; short j = 0L; WORD wResCount = 0L;
    BYTE nCharCount = 0;
    short delta = 0;
    WORD wFlags = 0; WORD wLoadOnCallResDataBegin = 0;
    WORD wNumOfSegments  = 0;
    WORD wSegmentTableOffset = 0;
    WORD wOffset = 0;
    WORD wLoadOnCallCodeBegin = 0;
    DWORD dwLoadOnCallCodeBegin = 0L;
    DWORD (FAR PASCAL    * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);

    // Open the file and try to read the information on the resource in it.
    CFileStatus status;
    if (CFile::GetStatus( lpszSrcFilename, status )) {
        // check if the size of the file is not null
        if (!status.m_size)
            CFile::Remove(lpszSrcFilename);
    }

    if (!fileIn.Open(lpszSrcFilename, CFile::shareDenyNone | CFile::modeRead | CFile::typeBinary))
        return GenerateFile(lpszTgtFilename,
                            hResFileModule,
                            lpBuffer,
                            uiSize,
                            hDllInst
                           );

    if (!fileOut.Open(lpszTgtFilename, CFile::shareDenyNone | CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
        return ERROR_FILE_CREATE;

    // Get the handle to the IODLL
    hDllInst = LoadLibrary("iodll.dll");

    if (!hDllInst)
        return ERROR_DLL_LOAD;

    // Get the pointer to the function to extract the resources image
    lpfnGetImage = (DWORD (FAR PASCAL   *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
                   GetProcAddress( hDllInst, "RSGetResImage" );
    if (lpfnGetImage==NULL) {
        FreeLibrary(hDllInst);
        return ERROR_DLL_PROC_ADDRESS;
    }

    // We read the resources from the file and then we check if the resource has been updated
    // or if we can just copy it

    // Get offset to Windows new header
    fileIn.Seek( 0x3c, CFile::begin );
    fileIn.Read((WORD*)&wWinHeaderOffset, sizeof(WORD));

    // Read and save resource table Offset
    fileIn.Seek( wWinHeaderOffset+0x24, CFile::begin );
    fileIn.Read ((WORD*)&wResTableOffset, sizeof(WORD));

    // Read AlignShift
    fileIn.Seek (wWinHeaderOffset+wResTableOffset, CFile::begin);
    fileIn.Read ((WORD*)&wAlignShift, sizeof(WORD));

    // Get the beginning of the resource data
    wResDataBegin = 0xffff;
    wLoadOnCallResDataBegin = 0xffff;
    fileIn.Read((WORD*)&wTypeId, sizeof(WORD));
    while (wTypeId) {
        fileIn.Read ((WORD*)&wResCount, sizeof(WORD));
        // Pass the reserved DWORD
        fileIn.Seek (4, CFile::current);

        for (i=0; i<wResCount; i++) {
            fileIn.Read ((WORD*)&wResDataOffset, sizeof(WORD));
            fileIn.Seek (2, CFile::current);
            fileIn.Read ((WORD*)&wFlags, sizeof(WORD));
            if (wResDataOffset>0) {
                if (wFlags & 0x0040)
                    wResDataBegin = (wResDataOffset < wResDataBegin) ? wResDataOffset:wResDataBegin;
                else
                    wLoadOnCallResDataBegin = (wResDataOffset < wLoadOnCallResDataBegin) ? wResDataOffset:wLoadOnCallResDataBegin;
            }
            // Get to next NameInfo record
            fileIn.Seek (6, CFile::current);
        }
        fileIn.Read ((WORD*)&wTypeId, sizeof(WORD));
    }

    // Copy data before resource data
    fileIn.SeekToBegin ();
    fileOut.SeekToBegin ();
    CopyFile (&fileIn, &fileOut);

    if (wResDataBegin != 0xffff) { // If there are PreLoad resources
        dwResDataBegin = (MAKELONG (wResDataBegin, 0))<<wAlignShift;

        // Read the first type ID
        fileIn.Seek (wWinHeaderOffset+wResTableOffset+2, CFile::begin);
        fileIn.Read ((WORD*)&wTypeId, sizeof(WORD));

        // Save the Offset of the current TypeInfo record
        wCurTypeOffset = wWinHeaderOffset + wResTableOffset + 2;

        // Save the beginning of current resource data
        dwCurResDataBegin = dwResDataBegin;

        // Loop through the TypeInfo table to write PreLoad resources
        while (wTypeId) {
            // Get Name of ord
            if (!(wTypeId & 0x8000)) {
                // It is a Offset to a string
                dwTypeId = (MAKELONG(wTypeId, 0)); //<<wAlignShift;
                fileIn.Seek (wWinHeaderOffset+wResTableOffset+dwTypeId, CFile::begin);
                // Get the character count for the ID string
                fileIn.Read ((BYTE*)&nCharCount, sizeof(BYTE));
                // Read the ID string
                fileIn.Read (szTypeId, nCharCount);
                // Put null at the end of the string
                szTypeId[nCharCount] = 0;
                // Set wTypeId to zero
                wTypeId = 0;
            } else {
                // It is an ID
                // Turn off the high bit
                wTypeId = wTypeId & 0x7FFF;
                if (0 == wTypeId)
                    return ERROR_RW_INVALID_FILE;

                // Set the ID string to null
                szTypeId[0] = 0;
            }

            // Restore the file read point
            fileIn.Seek (wCurTypeOffset+2, CFile::begin);

            // Get the count for this type of resource
            fileIn.Read ((WORD*)&wResCount, sizeof(WORD));

            // Pass the reserved DWORD
            fileIn.Seek (4, CFile::current);

            // Save the Offset of the current NameInfo record
            wCurNameOffset = wCurTypeOffset + 8;

            // Loop through NameInfo records
            for (i = 0; i < wResCount; i++) {
                // Read resource offset
                fileIn.Read ((WORD*)&wFileOffset, sizeof(WORD));
                // Read resource length
                fileIn.Read ((WORD*)&wSize, sizeof(WORD));
                // Read the flags
                fileIn.Read ((WORD*)&wFlags, sizeof(WORD));
                // Read resource ID
                fileIn.Read ((WORD*)&wNameId, sizeof(WORD));

                if (wFlags & 0x0040) {
                    // Get name of ord
                    if (!(wNameId & 0x8000)) {
                        // It is a Offset to a string
                        fileIn.Seek (wWinHeaderOffset+wResTableOffset+wNameId, CFile::begin);
                        // Get the character count for the string
                        fileIn.Read ((BYTE*)&nCharCount, sizeof(BYTE));
                        // Read the string
                        fileIn.Read (szNameId, nCharCount);
                        // Put null at the end of the string
                        szNameId[nCharCount] = 0;
                        // Set wNameId to zero
                        wNameId = 0;
                    } else {
                        // It is an ID
                        // Turn off the high bit
                        wNameId = wNameId & 0x7FFF;
                        if ( 0 == wNameId)
                            return ERROR_RW_INVALID_FILE;

                        // Set the string to null
                        szNameId[0] = 0;
                    }

                    dwSize = (MAKELONG (wSize, 0))<<wAlignShift;
                    dwFileOffset = (MAKELONG (wFileOffset, 0))<<wAlignShift;

                    // Now we got the Type and Name here and size

                    // Get the image from the IODLL
                    if (dwSize)
                        lpImageBuf = new BYTE[dwSize];
                    else lpImageBuf = LPNULL;
                    LPSTR   lpType = LPNULL;
                    LPSTR   lpRes = LPNULL;

                    if (wTypeId)
                        lpType = (LPSTR)((WORD)wTypeId);
                    else
                        lpType = &szTypeId[0];

                    if (wNameId)
                        lpRes = (LPSTR)((WORD)wNameId);
                    else
                        lpRes = &szNameId[0];

                    dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
                                                       lpType,
                                                       lpRes,
                                                       (DWORD)-1,
                                                       lpImageBuf,
                                                       dwSize
                                                    );

                    if (dwImageBufSize>dwSize ) {
                        // The buffer is too small
                        delete []lpImageBuf;
                        lpImageBuf = new BYTE[dwImageBufSize];
                        dwSize = (*lpfnGetImage)(  hResFileModule,
                                                   lpType,
                                                   lpRes,
                                                   (DWORD)-1,
                                                   lpImageBuf,
                                                   dwImageBufSize
                                                );
                        if ((dwSize-dwImageBufSize)!=0 ) {
                            delete []lpImageBuf;
                            lpImageBuf = LPNULL;
                        }
                    }

                    // Try to see if we have to set the memory to 0
                    if ((int)(dwSize-dwImageBufSize)>0)
                        memset(lpImageBuf+dwImageBufSize, 0, (size_t)(dwSize-dwImageBufSize));

                    // Write the image
                    fileOut.Seek (dwCurResDataBegin, CFile::begin);
                    WriteImage( &fileOut, lpImageBuf, dwSize);


                    // Fix the alignment for resource data
                    delta = (short)((((dwSize+(1<<wAlignShift)-1)>>wAlignShift)<<wAlignShift)-dwSize);
                    BYTE nByte = 0;

                    fileOut.Seek (dwCurResDataBegin+dwSize, CFile::begin);
                    for (j=0; j<delta; j++)
                        fileOut.Write ((BYTE*)&nByte, sizeof(BYTE));

                    dwSize = dwSize + MAKELONG(delta, 0);

                    // Fixup the resource table
                    fileOut.Seek (wCurNameOffset, CFile::begin);
                    wCurResDataBegin = LOWORD(dwCurResDataBegin>>wAlignShift);
                    fileOut.Write ((WORD*)&wCurResDataBegin, sizeof(WORD));
                    wSize = LOWORD (dwSize>>wAlignShift);
                    fileOut.Write ((WORD*)&wSize, sizeof(WORD));

                    if (lpImageBuf) delete []lpImageBuf;

                    // Update the current resource data beginning
                    dwCurResDataBegin = dwCurResDataBegin + dwSize;
                }

                // Update the current NameInfo record offset
                wCurNameOffset = wCurNameOffset + 12;
                // Move file pointer to the next NameInfo record
                fileIn.Seek (wCurNameOffset, CFile::begin);
            }

            // Update the current TypeInfo record offset
            wCurTypeOffset = wCurTypeOffset + 8 + wResCount * 12;
            // Move file pointer to the next TypeInfo record
            fileIn.Seek (wCurTypeOffset, CFile::begin);
            // Read the next TypeId
            fileIn.Read ((WORD*)&wTypeId, sizeof(WORD));
        }
    }

    // Get segment table offset
    fileIn.Seek (wWinHeaderOffset+0x001c, CFile::begin);
    fileIn.Read ((WORD*)&wNumOfSegments, sizeof(WORD));
    fileIn.Seek (wWinHeaderOffset+0x0022, CFile::begin);
    fileIn.Read ((WORD*)&wSegmentTableOffset, sizeof(WORD));

    // Find the beginning of the LoadOnCall code segments in the src exe file
    wLoadOnCallCodeBegin = 0xffff;
    for (i=0; i<wNumOfSegments; i++) {
        fileIn.Seek (wWinHeaderOffset+wSegmentTableOffset+8*i+4, CFile::begin);
        fileIn.Read ((WORD*)&wFlags, sizeof(WORD));
        if (!(wFlags & 0x0040)) {
            fileIn.Seek (wWinHeaderOffset+wSegmentTableOffset+8*i, CFile::begin);
            fileIn.Read ((WORD*)&wOffset, sizeof(WORD));

            // In the file winoa386.mod we have a LoadOnCall segment that doesn't exist.
            // We have to check for this before go on
            if (wOffset)
                wLoadOnCallCodeBegin = (wOffset < wLoadOnCallCodeBegin) ? wOffset:wLoadOnCallCodeBegin;
        }
    }

    // Calculate the delta between the new beginning and the old beginnning
    // of the LoadOnCall code segments
    if (wResDataBegin != 0xffff && wLoadOnCallCodeBegin != 0xffff) { // Both LoadOnCall code and FastLoad
        wCurResDataBegin = LOWORD(dwCurResDataBegin>>wAlignShift);
        delta =  wCurResDataBegin - wLoadOnCallCodeBegin;
    } else if (wResDataBegin != 0xffff && wLoadOnCallResDataBegin != 0xffff) { // Both LoadOnCall and FastLoad Resources
        wCurResDataBegin = LOWORD(dwCurResDataBegin>>wAlignShift);
        delta =  wCurResDataBegin - wLoadOnCallResDataBegin;
    } else if (wResDataBegin != 0xffff) { // Only FastLoad Resources
        wCurResDataBegin = LOWORD((dwCurResDataBegin-dwSize)>>wAlignShift);
        delta =  wCurResDataBegin - wResDataBegin;
    } else delta = 0;

    dwLoadOnCallCodeBegin = MAKELONG (wLoadOnCallCodeBegin, 0) << wAlignShift;

    // Change the length for preload area
    if (wResDataBegin != 0xffff) {
        fileIn.Seek (wWinHeaderOffset+0x003a, CFile::begin);
        fileIn.Read ((WORD*)&wOffset, sizeof(WORD));
        wOffset += delta;

        fileOut.Seek (wWinHeaderOffset+0x003a, CFile::begin);
        fileOut.Write ((WORD*)&wOffset, sizeof(WORD));
    }

    if (wLoadOnCallCodeBegin != 0xffff && delta) {
        // Write LoadOnCall segments
        fileIn.Seek (dwLoadOnCallCodeBegin, CFile::begin);
        fileOut.Seek (dwCurResDataBegin, CFile::begin);
        LONG lLeft;
        if (wLoadOnCallResDataBegin != 0xffff)
            lLeft = MAKELONG (wLoadOnCallResDataBegin - wLoadOnCallCodeBegin, 0) << wAlignShift;
        else
            lLeft = (fileIn.GetLength () - (MAKELONG (wLoadOnCallCodeBegin, 0))) << wAlignShift;

        WORD wRead = 0;
        BYTE far * pBuf = (BYTE far *) new BYTE[32739];

        if (!pBuf) {
            FreeLibrary(hDllInst);
            return ERROR_NEW_FAILED;
        }

        while (lLeft>0) {
            wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
            if (wRead!= fileIn.Read( pBuf, wRead)) {
                delete []pBuf;
                FreeLibrary(hDllInst);
                return ERROR_FILE_READ;
            }
            fileOut.Write( pBuf, wRead );
            lLeft -= wRead;
        }
        delete []pBuf;

        // Fixup the segment table
        for (i=0; i<wNumOfSegments; i++) {
            fileIn.Seek (wWinHeaderOffset+wSegmentTableOffset+8*i+4, CFile::begin);
            fileIn.Read ((WORD*)&wFlags, sizeof(WORD));
            if (!(wFlags & 0x0040)) {
                fileIn.Seek (wWinHeaderOffset+wSegmentTableOffset+8*i, CFile::begin);
                fileIn.Read ((WORD*)&wOffset, sizeof(WORD));
                wOffset = wOffset + delta;
                fileOut.Seek (wWinHeaderOffset+wSegmentTableOffset+8*i, CFile::begin);
                fileOut.Write ((WORD*)&wOffset, sizeof(WORD));
            }
        }
    }

    if (wLoadOnCallResDataBegin != 0xffff) {
        // Read the first type ID again
        fileIn.Seek (wWinHeaderOffset+wResTableOffset+2, CFile::begin);
        fileIn.Read ((WORD*)&wTypeId, sizeof(WORD));

        // Save the Offset of the current TypeInfo record
        wCurTypeOffset = wWinHeaderOffset + wResTableOffset + 2;

        // Calc the beginning of the LoadOnCall resources
        dwCurResDataBegin = (MAKELONG (wLoadOnCallResDataBegin + delta, 0))<<wAlignShift;

        // Loop through the TypeInfo table again to write LoadOnCall resources
        while (wTypeId) {
            // Get Name of ord
            if (!(wTypeId & 0x8000)) {
                // It is a Offset to a string
                dwTypeId = (MAKELONG(wTypeId, 0)); //<<wAlignShift;
                fileIn.Seek (wWinHeaderOffset+wResTableOffset+dwTypeId, CFile::begin);
                // Get the character count for the ID string
                fileIn.Read ((BYTE*)&nCharCount, sizeof(BYTE));
                // Read the ID string
                fileIn.Read (szTypeId, nCharCount);
                // Put null at the end of the string
                szTypeId[nCharCount] = 0;
                // Set wTypeId to zero
                wTypeId = 0;
            } else {
                // It is an ID
                // Turn off the high bit
                wTypeId = wTypeId & 0x7FFF;
                if ( 0 == wTypeId)
                    return ERROR_RW_INVALID_FILE;

                // Set the ID string to null
                szTypeId[0] = 0;
            }

            // Restore the file read point
            fileIn.Seek (wCurTypeOffset+2, CFile::begin);

            // Get the count for this type of resource
            fileIn.Read ((WORD*)&wResCount, sizeof(WORD));

            // Pass the reserved DWORD
            fileIn.Seek (4, CFile::current);

            // Save the Offset of the current NameInfo record
            wCurNameOffset = wCurTypeOffset + 8;

            // Loop through NameInfo records
            for (i = 0; i < wResCount; i++) {
                // Read resource offset
                fileIn.Read ((WORD*)&wFileOffset, sizeof(WORD));
                // Read resource length
                fileIn.Read ((WORD*)&wSize, sizeof(WORD));
                // Read the flags
                fileIn.Read ((WORD*)&wFlags, sizeof(WORD));
                // Read resource ID
                fileIn.Read ((WORD*)&wNameId, sizeof(WORD));

                if (!(wFlags & 0x0040)) {
                    // Get name of ord
                    if (!(wNameId & 0x8000)) {
                        // It is a Offset to a string
                        fileIn.Seek (wWinHeaderOffset+wResTableOffset+wNameId, CFile::begin);
                        // Get the character count for the string
                        fileIn.Read ((BYTE*)&nCharCount, sizeof(BYTE));
                        // Read the string
                        fileIn.Read (szNameId, nCharCount);
                        // Put null at the end of the string
                        szNameId[nCharCount] = 0;
                        // Set wNameId to zero
                        wNameId = 0;
                    } else {
                        // It is an ID
                        // Turn off the high bit
                        wNameId = wNameId & 0x7FFF;
                        if (0 == wNameId)
                            return ERROR_RW_INVALID_FILE;

                        // Set the string to null
                        szNameId[0] = 0;
                    }

                    dwSize = (MAKELONG (wSize, 0))<<wAlignShift;
                    dwFileOffset = (MAKELONG (wFileOffset, 0))<<wAlignShift;

                    // Now we got the Type and Name here and size

                    // Get the image from the IODLL
                    if (dwSize)
                        lpImageBuf = new BYTE[dwSize];
                    else lpImageBuf = LPNULL;
                    LPSTR   lpType = LPNULL;
                    LPSTR   lpRes = LPNULL;

                    if (wTypeId)
                        lpType = (LPSTR)((WORD)wTypeId);
                    else
                        lpType = &szTypeId[0];

                    if (wNameId)
                        lpRes = (LPSTR)((WORD)wNameId);
                    else
                        lpRes = &szNameId[0];

                    dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
                                                       lpType,
                                                       lpRes,
                                                       (DWORD)-1,
                                                       lpImageBuf,
                                                       dwSize
                                                    );

                    if (dwImageBufSize>dwSize ) {
                        // The buffer is too small
                        delete []lpImageBuf;
                        lpImageBuf = new BYTE[dwImageBufSize];
                        dwSize = (*lpfnGetImage)(  hResFileModule,
                                                   lpType,
                                                   lpRes,
                                                   (DWORD)-1,
                                                   lpImageBuf,
                                                   dwImageBufSize
                                                );
                        if ((dwSize-dwImageBufSize)!=0 ) {
                            delete []lpImageBuf;
                            lpImageBuf = LPNULL;
                        }
                    }

                    // Try to see if we have to set the memory to 0
                    if ((int)(dwSize-dwImageBufSize)>0)
                        memset(lpImageBuf+dwImageBufSize, 0, (size_t)(dwSize-dwImageBufSize));

                    // Write the image
                    fileOut.Seek (dwCurResDataBegin, CFile::begin);
                    WriteImage( &fileOut, lpImageBuf, dwSize);

                    // Fix the alignment for resource data
                    DWORD dwTmp = 1;
                    delta = (short)((((dwSize+(dwTmp<<wAlignShift)-1)>>wAlignShift)<<wAlignShift)-dwSize);
                    BYTE nByte = 0;

                    fileOut.Seek (dwCurResDataBegin+dwSize, CFile::begin);
                    for (j=0; j<delta; j++)
                        fileOut.Write ((BYTE*)&nByte, sizeof(BYTE));

                    dwSize = dwSize + MAKELONG(delta, 0);

                    // Fixup the resource table
                    fileOut.Seek (wCurNameOffset, CFile::begin);
                    wCurResDataBegin = LOWORD(dwCurResDataBegin>>wAlignShift);
                    fileOut.Write ((WORD*)&wCurResDataBegin, sizeof(WORD));
                    wSize = LOWORD (dwSize>>wAlignShift);
                    fileOut.Write ((WORD*)&wSize, sizeof(WORD));

                    if (lpImageBuf) delete []lpImageBuf;

                    // Update the current resource data beginning
                    dwCurResDataBegin = dwCurResDataBegin + dwSize;
                }

                // Update the current NameInfo record offset
                wCurNameOffset = wCurNameOffset + 12;
                // Move file pointer to the next NameInfo record
                fileIn.Seek (wCurNameOffset, CFile::begin);
            }

            // Update the current TypeInfo record offset
            wCurTypeOffset = wCurTypeOffset + 8 + wResCount * 12;
            // Move file pointer to the next TypeInfo record
            fileIn.Seek (wCurTypeOffset, CFile::begin);
            // Read the next TypeId
            fileIn.Read ((WORD*)&wTypeId, sizeof(WORD));
        }
    }

    fileIn.Close();
    fileOut.Close();
    FreeLibrary(hDllInst);

    return uiError;
}

extern "C"
UINT
APIENTRY
RWUpdateImage(
             LPCSTR  lpszType,
             LPVOID  lpNewBuf,
             DWORD   dwNewSize,
             LPVOID  lpOldImage,
             DWORD   dwOldImageSize,
             LPVOID  lpNewImage,
             DWORD*  pdwNewImageSize
             )
{
    UINT uiError = ERROR_NO_ERROR;

    // The Type we can parse are only the standard ones
    switch ((UINT)LOWORD(lpszType)) {
        case 4:
            if (lpOldImage)
                uiError = UpdateMenu( lpNewBuf, dwNewSize,
                                      lpOldImage, dwOldImageSize,
                                      lpNewImage, pdwNewImageSize );
            else uiError = GenerateMenu( lpNewBuf, dwNewSize,
                                         lpNewImage, pdwNewImageSize );
            break;
        case 5:
            if (lpOldImage)
                uiError = UpdateDialog( lpNewBuf, dwNewSize,
                                        lpOldImage, dwOldImageSize,
                                        lpNewImage, pdwNewImageSize );
            else uiError = GenerateDialog( lpNewBuf, dwNewSize,
                                           lpNewImage, pdwNewImageSize );
            break;
        case 6:
            if (lpOldImage)
                uiError = UpdateString( lpNewBuf, dwNewSize,
                                        lpOldImage, dwOldImageSize,
                                        lpNewImage, pdwNewImageSize );
            else uiError = GenerateString( lpNewBuf, dwNewSize,
                                           lpNewImage, pdwNewImageSize );
            break;
        case 9:
            if (lpOldImage)
                uiError = UpdateAccel( lpNewBuf, dwNewSize,
                                       lpOldImage, dwOldImageSize,
                                       lpNewImage, pdwNewImageSize );
            else {
                *pdwNewImageSize = 0L;
                uiError = ERROR_RW_NOTREADY;
            }
            break;
#ifdef VB
        case 10:
            if (lpOldImage)
                uiError = UpdateVBData( lpNewBuf, dwNewSize,
                                        lpOldImage, dwOldImageSize,
                                        lpNewImage, pdwNewImageSize );
            else {
                *pdwNewImageSize = 0L;
                uiError = ERROR_RW_NOTREADY;
            }
            break;
#endif

        case 16:
            if (lpOldImage)
                uiError = UpdateVerst( lpNewBuf, dwNewSize,
                                       lpOldImage, dwOldImageSize,
                                       lpNewImage, pdwNewImageSize );
            else {
                *pdwNewImageSize = 0L;
                uiError = ERROR_RW_NOTREADY;
            }
            break;
        default:
            *pdwNewImageSize = 0L;
            uiError = ERROR_RW_NOTREADY;
            break;
    }

    return uiError;
}

///////////////////////////////////////////////////////////////////////////
// Functions implementation

static UINT GenerateFile( LPCSTR        lpszTgtFilename,
                          HANDLE        hResFileModule,
                          LPVOID        lpBuffer,
                          UINT      uiSize,
                          HINSTANCE   hDllInst
                        )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = LPNULL;
    UINT uiBufSize = uiSize;
    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile fileOut;

    if (!fileOut.Open(lpszTgtFilename, CFile::shareDenyNone | CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
        return ERROR_FILE_CREATE;

    // Get the pointer to the function
    if (!hDllInst)
        return ERROR_DLL_LOAD;

    DWORD (FAR PASCAL    * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
    // Get the pointer to the function to extract the resources image
    lpfnGetImage = (DWORD (FAR PASCAL   *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
                   GetProcAddress( hDllInst, "RSGetResImage" );
    if (lpfnGetImage==NULL) {
        return ERROR_DLL_PROC_ADDRESS;
    }


    WORD wUpdTypeId = 0;
    static char szUpdTypeId[128];

    WORD wUpdNameId;
    static char szUpdNameId[128];

    DWORD dwUpdLang;
    DWORD dwUpdSize;

    UINT uiBufStartSize = uiBufSize;
    DWORD dwImageBufSize;
    BYTE far * lpImageBuf;
    while (uiBufSize>0) {
        if ((!wUpdTypeId) && (uiBufSize))
            GetUpdatedRes( &lpBuffer,
                           &uiBufSize,
                           &wUpdTypeId, &szUpdTypeId[0],
                           &wUpdNameId, &szUpdNameId[0],
                           &dwUpdLang,
                           &dwUpdSize
                         );

        // The resource has been updated get the image from the IODLL
        if (dwUpdSize) {
            lpImageBuf = new BYTE[dwUpdSize];
            LPSTR   lpType = LPNULL;
            LPSTR   lpRes = LPNULL;
            if (wUpdTypeId) {
                lpType = (LPSTR)((WORD)wUpdTypeId);
            } else {
                lpType = &szUpdTypeId[0];
            }
            if (wUpdNameId) {
                lpRes = (LPSTR)((WORD)wUpdNameId);
            } else {
                lpRes = &szUpdNameId[0];
            }

            dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
                                               lpType,
                                               lpRes,
                                               dwUpdLang,
                                               lpImageBuf,
                                               dwUpdSize
                                            );
            if (dwImageBufSize>dwUpdSize ) {
                // The buffer is too small
                delete []lpImageBuf;
                lpImageBuf = new BYTE[dwImageBufSize];
                dwUpdSize = (*lpfnGetImage)(  hResFileModule,
                                              lpType,
                                              lpRes,
                                              dwUpdLang,
                                              lpImageBuf,
                                              dwImageBufSize
                                           );
                if ((dwUpdSize-dwImageBufSize)!=0 ) {
                    delete []lpImageBuf;
                    lpImageBuf = LPNULL;
                }
            }


            WriteHeader(&fileOut,
                        wUpdTypeId, &szUpdTypeId[0],
                        wUpdNameId, &szUpdNameId[0],
                        0l);

            WriteImage( &fileOut,
                        lpImageBuf, dwImageBufSize);

            if (lpImageBuf) delete []lpImageBuf;
            wUpdTypeId = 0;

        } else wUpdTypeId = 0;

    }

    fileOut.Close();

    return uiError;
}

static UINT CopyFile( CFile* pfilein, CFile* pfileout )
{
    LONG lLeft = pfilein->GetLength();
    WORD wRead = 0;
    DWORD dwOffset = 0;
    BYTE far * pBuf = (BYTE far *) new BYTE[32739];

    if (!pBuf)
        return ERROR_NEW_FAILED;

    while (lLeft>0) {
        wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
        if (wRead!= pfilein->Read( pBuf, wRead)) {
            delete []pBuf;
            return ERROR_FILE_READ;
        }
        pfileout->Write( pBuf, wRead );
        lLeft -= wRead;
        dwOffset += wRead;
    }
    delete []pBuf;
    return ERROR_NO_ERROR;
}

static UINT GetUpdatedRes(
                         LPVOID far * lplpBuffer,
                         UINT* uiSize,
                         WORD* wTypeId, LPSTR lplpszTypeId,
                         WORD* wNameId, LPSTR lplpszNameId,
                         DWORD* dwLang, DWORD* dwSize )
{
    BYTE far * lpBuf = (BYTE far *)*lplpBuffer;

    *wTypeId = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    strcpy( lplpszTypeId, (char *)lpBuf);
    lpBuf += strlen(lplpszTypeId)+1;

    *wNameId = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    strcpy( lplpszNameId, (char *)lpBuf);
    lpBuf += strlen(lplpszNameId)+1;

    *dwLang = *((DWORD*)lpBuf);
    lpBuf += sizeofDWord;

    *dwSize = *((DWORD*)lpBuf);
    lpBuf += sizeofDWord;

    *uiSize -= (UINT)((lpBuf-(BYTE far *)*lplpBuffer));
    *lplpBuffer = (LPVOID)lpBuf;
    return 0;
}

static
UINT
GetUpdatedItem(
              LPVOID far * lplpBuffer,
              LONG* dwSize,
              WORD* wX, WORD* wY,
              WORD* wcX, WORD* wcY,
              DWORD* dwPosId,
              DWORD* dwStyle, DWORD* dwExtStyle,
              LPSTR lpszText)
{
    BYTE far * far * lplpBuf = (BYTE far * far *)lplpBuffer;
    UINT uiSize = GetWord( lplpBuf, wX, dwSize );

    uiSize += GetWord( lplpBuf, wY, dwSize );
    uiSize += GetWord( lplpBuf, wcX, dwSize );
    uiSize += GetWord( lplpBuf, wcY, dwSize );
    uiSize += GetDWord( lplpBuf, dwPosId, dwSize );
    uiSize += GetDWord( lplpBuf, dwStyle, dwSize );
    uiSize += GetDWord( lplpBuf, dwExtStyle, dwSize );
    uiSize += GetString( lplpBuf, lpszText, dwSize );

    return uiSize;

    /*
    *wX = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    *wY = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    *wcX = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    *wcY = *((WORD*)lpBuf);
    lpBuf += sizeofWord;

    *dwPosId = *((DWORD*)lpBuf);
    lpBuf += sizeofDWord;

    *dwStyle = *((DWORD*)lpBuf);
    lpBuf += sizeofDWord;

    *dwExtStyle = *((DWORD*)lpBuf);
    lpBuf += sizeofDWord;

    strcpy( lpszText, (char *)lpBuf);
    lpBuf += strlen(lpszText)+1;

    *dwSize -= (lpBuf-(BYTE far *)*lplpBuffer);
    *lplpBuffer = lpBuf;
    return 0;*/
}


static UINT
GetResInfo( CFile* pfile,
            WORD* pwTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
            WORD* pwNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
            WORD* pwFlags,
            DWORD* pdwSize, DWORD* pdwFileOffset )
{
    static UINT uiSize;
    static LONG lOfsCheck;
    // get the Type info
    uiSize = GetNameOrOrdFile( pfile, pwTypeId, lpszTypeId, bMaxTypeLen);
    if (!uiSize)
        return 0;

    // get the Name info
    uiSize = GetNameOrOrdFile( pfile, pwNameId, lpszNameId, bMaxNameLen);
    if (!uiSize)
        return 0;

    // Skip the Flag
    pfile->Read( pwFlags, 2 );

    // get the size
    pfile->Read( pdwSize, 4 );
    if (*pdwSize==0)
        // size id 0 the resource file is corrupted or is not a res file
        return 0;

    *pdwFileOffset = pfile->GetPosition();

    // check if the size is valid
    TRY {
        lOfsCheck = pfile->Seek(*pdwSize, CFile::current);
    } CATCH(CFileException, e) {
        // Check is the right exception
        return 0;
    } END_CATCH
    if (lOfsCheck!=(LONG)(*pdwFileOffset+*pdwSize))
        return 0;
    return 1;
}

static UINT WriteHeader(
                       CFile* pFile,
                       WORD wTypeId, LPSTR lpszTypeId,
                       WORD wNameId, LPSTR lpszNameId,
                       WORD wFlags )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE bFF = 0xFF;
    if (wTypeId) {
        // It is an ordinal

        pFile->Write( &bFF, 1 );
        pFile->Write( &wTypeId, 2 );
    } else {
        pFile->Write( lpszTypeId, strlen(lpszTypeId)+1 );
    }

    if (wNameId) {
        // It is an ordinal
        pFile->Write( &bFF, 1 );
        pFile->Write( &wNameId, 2 );
    } else {
        pFile->Write( lpszNameId, strlen(lpszNameId)+1 );
    }

    pFile->Write( &wFlags, 2 );

    return uiError;
}

static UINT WriteImage(
                      CFile* pFile,
                      LPVOID lpImage, DWORD dwSize )
{
    UINT uiError = ERROR_NO_ERROR;
    if (lpImage) {
//      pFile->Write( &dwSize, sizeofDWord );
        pFile->Write( lpImage, (UINT)dwSize );
    }
    return uiError;
}

////////////////////////////////////////////////////////////////////////////
// Helper Function Implementation
static UINT GetNameOrOrdFile( CFile* pfile, WORD* pwId, LPSTR lpszId, BYTE bMaxStrLen )
{
    UINT uiSize = 0;

    *pwId = 0;

    // read the first BYTE to see if it is a string or an ordinal
    pfile->Read( pwId, sizeof(BYTE) );
    if (LOBYTE(*pwId)==0xFF) {
        // This is an Ordinal
        pfile->Read( pwId, sizeofWord );
        *lpszId = '\0';
        uiSize = 2;
    } else {
        uiSize++;
        *lpszId = LOBYTE(*pwId);
        while ((*lpszId++) && (bMaxStrLen-2)) {
            pfile->Read( pwId, sizeof(BYTE) );
            *lpszId = LOBYTE(*pwId);
            uiSize++;
            bMaxStrLen--;
        }
        if ( (!(bMaxStrLen-2)) && (*pwId) ) {
            // Failed
            return 0;
        }
    }
    return uiSize;
}

static
UINT
ParseCursor( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{

    // Should be almost impossible for a Cursor to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;

    LONG dwOverAllSize = 0L;

    // Cursor Items
    WORD wWidth = 0;
    WORD wHeight = 0;
    WORD wPlanes = 0;
    WORD wBitCount = 0;
    DWORD dwBytesInRes = 0;
    WORD wImageIndex = 0;

    // Get the CURSOR DIR ENTRY
    GetWord( &lpImage, &wWidth, &dwImageSize );
    GetWord( &lpImage, &wHeight, &dwImageSize );
    GetWord( &lpImage, &wPlanes, &dwImageSize );
    GetWord( &lpImage, &wBitCount, &dwImageSize );
    GetDWord( &lpImage, &dwBytesInRes, &dwImageSize );
    GetWord( &lpImage, &wImageIndex, &dwImageSize );

    //SkipByte( &lpImage, 4, &dwImageSize );
    //BITMAPINFO
    BITMAPINFOHEADER* pBmpInfHead = (BITMAPINFOHEADER*) lpImage;
    UINT uiSize = sizeof(BITMAPINFOHEADER);
    SkipByte( &lpImage, uiSize, &dwImageSize );
    /*

    // Get the Width
    SkipByte( &lpImage, 4, &dwImageSize );


    // Menu Items
    WORD fItemFlags;
    WORD wMenuId;
    CString szCaption;

    while(dwImageSize>0) {
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a menu
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);

        // Let's get the Menu flags
        GetWord( &lpImage, &fItemFlags, &dwImageSize );

        if ( !(fItemFlags & MF_POPUP) )
            // Get the menu Id
            GetWord( &lpImage, &wMenuId, &dwImageSize );
        else wMenuId = -1;

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)fItemFlags, &dwBufSize);
        //Put the MenuId
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)wMenuId, &dwBufSize);


        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, -1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)(lpItem+uiOffset), &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        // Get the text
        // calculate were the string is going to be
        // Will be the fixed header+the pointer
        dwOverAllSize += CopyText( &lpBuf, &lpImage, &dwBufSize, &dwImageSize );

        // Put the size of the resource
        if (dwBufSize>=0) {
            uiOffset += strlen((LPSTR)(lpItem+uiOffset))+1;
            lDummy = 8;
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        }

        // Move to the next position
        lpItem = lpBuf;
        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==(dwImageSize))
                dwImageSize = -1;
        }
    }
    */

    return (UINT)(dwOverAllSize);
}

static
UINT
ParseBitmap( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    // we will return just one item so the iodll will handle this resource as
    // something valid. We will not bother doing anything else. The only thing
    // we are interesed is the raw data in the immage, but if we don't return at
    // least one item IODLL will consider the resource empty.
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;
    LONG dwOverAllSize = 0;

    TRACE1("ParseBitmap: dwISize=%ld\n", dwISize);

    dwOverAllSize += PutDWord( &lpBuf, sizeof(RESITEM), &dwBufSize);

    // We have the size and pos in a cursor but we are not interested now
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

    // we don't have checksum and style
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    //Put the Flag
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // The ID will be just 1
    dwOverAllSize += PutDWord( &lpBuf, 1, &dwBufSize);

    // we don't have the resID, and the Type Id
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the language
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the codepage or the font name
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

    // Let's put null were we don;t have the strings
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

    // we just return. This is enough for IODLL
    return (UINT)(dwOverAllSize);
}

static
UINT
ParseIcon( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{

    // Should be almost impossible for an Icon to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;

    BITMAPINFOHEADER* pBmpInfo = (BITMAPINFOHEADER*) lpImage;
    // difficult it will be bigger than UINT_MAX
    SkipByte( &lpImage, (UINT)pBmpInfo->biSize, &dwImageSize );

    RGBQUAD* pRgbQuad = (RGBQUAD*) lpImage;
    SkipByte( &lpImage, sizeof(RGBQUAD), &dwImageSize );

    // Calculate CheckSum on the image
    DWORD dwCheckSum = 0l;
    BYTE * hp = (BYTE *) lpImage;

    for ( DWORD dwLen = pBmpInfo->biSizeImage; dwLen; dwLen--)
        dwCheckSum = (dwCheckSum << 8) | *hp++;


    // Fixed field
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

    // We don't have the size and pos in a menu
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)pBmpInfo->biWidth, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)pBmpInfo->biHeight, &dwBufSize);

    // we don't have checksum and style
    dwOverAllSize += PutDWord( &lpBuf, dwCheckSum, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);


    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    // we don't have the resID, and the Type Id
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the language
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the codepage or the font name
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

    // Let's put null were we don;t have the strings
    uiOffset = sizeof(RESITEM);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);


    // Put the size of the resource
    if (dwBufSize>=0) {
        lDummy = 8;
        PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
    }


    return (UINT)(dwOverAllSize);
}

static int
GetVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK* pver)
{
    // We have to hard code the language filed because otherwise, due to some
    // inconsistent RC compiler, the Image are not following any standard.
    // We assume that all the block but the one hard-coded here are binary and
    // we just skip them
    WORD wHead = 0;
    WORD wPad = 0;
    WORD wValue = 0;
    pver->pValue = *lplpImage;

    // Read the header of the block
    wHead = GetWord( lplpImage, &pver->wBlockLen, pdwSize );
    wHead += GetWord( lplpImage, &pver->wValueLen, pdwSize );
    // The Key name is all the time a NULL terminated string
    wHead += (WORD)GetString( lplpImage, &pver->szKey[0], pdwSize );
    pver->wHead = wHead;

    // See if we have padding after the header. We can check on wHead because
    // we need an allignment on a DWORD boundary and we have 2 WORD+the string.
    wPad = SkipByte( lplpImage, Pad4(wHead), pdwSize );

    // Fix the pointer to the value
    pver->pValue = (pver->pValue+wHead+wPad);

    if ((int)pver->wValueLen>*pdwSize) {
        // There is an error
        wPad += SkipByte( lplpImage, (UINT)*pdwSize, pdwSize );
        return wHead+wPad;
    }

    // Now we check the key name and if is one of the one we accept as good
    // we read the string. Otherwise we just skip the value field
    if ( !strcmp(pver->szKey,"Comments") ||
         !strcmp(pver->szKey,"CompanyName") ||
         !strcmp(pver->szKey,"FileDescription") ||
         !strcmp(pver->szKey,"FileVersion") ||
         !strcmp(pver->szKey,"InternalName") ||
         !strcmp(pver->szKey,"LegalCopyright") ||
         !strcmp(pver->szKey,"LegalTrademarks") ||
         !strcmp(pver->szKey,"OriginalFilename") ||
         !strcmp(pver->szKey,"PrivateBuild") ||
         !strcmp(pver->szKey,"ProductName") ||
         !strcmp(pver->szKey,"ProductVersion") ||
         !strcmp(pver->szKey,"SpecialBuild") ||
         !strcmp(pver->szKey,"StringFileInfo")  // found in a Borland Version resource
       ) {
        if (!strcmp(pver->szKey,"StringFileInfo") && !pver->wValueLen) {
            pver->wType = 0;
            wValue=0;
        } else {
            // It is a standard key name read the string.
            // Set the flag to show it is a string
            pver->wType = 1;
            wValue = (WORD)GetVSString( lplpImage, &pver->szValue[0], pdwSize, pver->wValueLen );
        }

        // check if this is the LegalCopyright block.
        // If it is then there might be a null in the middle of the string
        if (!strcmp(pver->szKey,"LegalCopyright")) {
            // we just skip the rest. This need to be fixed in the RC, not here
            if ((int)(pver->wValueLen-wValue)>0)
                wValue += SkipByte( lplpImage, pver->wValueLen-wValue, pdwSize );
        }

    } else {
        // It isn't a string, or if is is not a standard key name, skip it
        pver->wType = 0;
        *pver->szValue = '\0';
        wValue = SkipByte( lplpImage, pver->wValueLen, pdwSize );
    }

    // Check the padding
    wPad += SkipByte( lplpImage, Pad4(wValue), pdwSize );

    // Even if it look what we have done should be enough we have to walk the image
    // skiping the NULL char that sometimes the comipler place there.
    // Do this only if it is not the translation field.
    // The translation field is the last so we might have some image padding
    if (strcmp(pver->szKey, "Translation")) {
        WORD wSkip = 0;
        BYTE far * lpTmp = *lplpImage;

        if (*lplpImage)
            while (!**lplpImage && *pdwSize) {
                wSkip += SkipByte(lplpImage, 1, pdwSize);
            }

        if (Pad4(wSkip)) {
            *lplpImage = lpTmp;
            *pdwSize += wSkip;
        } else wPad += wSkip;
    }

    return wHead+wValue+wPad;
}

static int
GetVSBlockOld( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK* pver)
{
    WORD wHead = 0;
    WORD wPad = 0;
    WORD wValue = 0;
    LONG lValueLen = 0;
    pver->pValue = *lplpImage;
    wHead = GetWord( lplpImage, &pver->wBlockLen, pdwSize );
    wHead += GetWord( lplpImage, &pver->wValueLen, pdwSize );
    wHead += (WORD)GetString( lplpImage, &pver->szKey[0], pdwSize );

    pver->wHead = wHead;

    wPad = SkipByte( lplpImage, Pad4(wHead), pdwSize );

    lValueLen = pver->wValueLen;
    if (lValueLen>*pdwSize) {
        // There is an error
        wPad += SkipByte( lplpImage, (UINT)*pdwSize, pdwSize );
        return wHead+wPad;
    }

    pver->wType = 0;
    pver->pValue = (pver->pValue+wHead+wPad);
    if (pver->wValueLen) {
        wValue = (WORD)GetString( lplpImage, &pver->szValue[0], &lValueLen );
        *pdwSize -= wValue;
        pver->wType = 1;
    }
    if (wValue!=pver->wValueLen) {
        // Just skip the value. It isn't a string, is a value
        if (pver->wValueLen-wValue!=1) {
            *pver->szValue = '\0';
            pver->wType = 0;
        }
        wPad += SkipByte( lplpImage, pver->wValueLen-wValue, pdwSize );
    }

    wPad += SkipByte( lplpImage, Pad4(pver->wValueLen), pdwSize );

    return wHead+wPad+wValue;
}

static int
PutVSBlock( BYTE far * far * lplpImage, LONG* pdwSize, VER_BLOCK ver,
            LPSTR lpStr, BYTE far * far * lplpBlockSize, WORD* pwTrash)

{
    // We have to write the info in the VER_BLOCK in the new image
    // We want to remember were the block size field is so we can update it later

    WORD wHead = 0;
    WORD wValue = 0;
    WORD wPad = Pad4(ver.wHead);
    *pwTrash = 0;

    // Get the pointer to the header of the block
    BYTE far * pHead = ver.pValue-ver.wHead-wPad;
    BYTE far * lpNewImage = *lplpImage;

    // Copy the header of the block to the new image
    wHead = ver.wHead;
    if (*pdwSize>=(int)ver.wHead) {
        memcpy( *lplpImage, pHead, ver.wHead );
        *pdwSize -= ver.wHead;
        lpNewImage += ver.wHead;
    } else *pdwSize = -1;

    // Check if padding is needed
    if (*pdwSize>=(int)wPad) {
        memset( *lplpImage+ver.wHead, 0, wPad );
        *pdwSize -= wPad;
        lpNewImage += wPad;
    } else *pdwSize = -1;

    // Store the pointer to the block size WORD
    BYTE far * pBlockSize = *lplpImage;

    // Check if the value is a string or a BYTE array
    if (ver.wType) {
        // it is a string, copy the updated item
        wValue = strlen(lpStr)+1;
        if (*pdwSize>=(int)wValue) {
            memcpy(*lplpImage+wHead+wPad, lpStr, wValue);
            *pdwSize -= wValue;
            lpNewImage += wValue;
        } else *pdwSize = -1;

        // Check if padding is needed
        int wPad1 = Pad4(wValue);
        if (*pdwSize>=wPad1) {
            memset( *lplpImage+ver.wHead+wValue+wPad, 0, wPad1 );
            *pdwSize -= wPad1;
            lpNewImage += wPad1;
        } else *pdwSize = -1;

        *pwTrash = Pad4(ver.wValueLen);
        wValue += (WORD)wPad1;

        // Fix to the strange behaviour of the ver.dll
        if ((wPad1) && (wPad1>=(int)*pwTrash)) {
            wValue -= *pwTrash;
        } else *pwTrash = 0;
        // Fix up the Value len field. We will put the len of the value + padding
        if (*pdwSize>=0)
            memcpy( pBlockSize+2, &wValue, 2);

    } else {
        // it is an array, just copy it in the new image buffer
        wValue = ver.wValueLen;
        if (*pdwSize>=(int)ver.wValueLen) {
            memcpy(*lplpImage+wHead+wPad, ver.pValue, ver.wValueLen);
            *pdwSize -= ver.wValueLen;
            lpNewImage += ver.wValueLen;
        } else *pdwSize = -1;

        // Check if padding is needed
        if (*pdwSize>=(int)Pad4(ver.wValueLen)) {
            memset( *lplpImage+ver.wHead+ver.wValueLen+wPad, 0, Pad4(ver.wValueLen) );
            *pdwSize -= Pad4(ver.wValueLen);
            lpNewImage += Pad4(ver.wValueLen);
        } else *pdwSize = -1;
        wPad += Pad4(ver.wValueLen);
    }

    *lplpBlockSize = pBlockSize;
    *lplpImage = lpNewImage;
    return wPad+wValue+wHead;
}

static
UINT ParseVerst( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    TRACE("ParseVersion Stamp: \n");
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LPRESITEM lpResItem = (LPRESITEM)lpBuffer;
    char far * lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));
    LONG dwOverAllSize = 0L;

    WORD wPos = 0;

    static VER_BLOCK verBlock;

    while (dwImageSize>0) {
        wPos++;
        GetVSBlock( &lpImage, &dwImageSize, &verBlock);

        // check if this is the translation block
        if (!strcmp(verBlock.szKey, "Translation" )) {
            // This is the translation block let the localizer have it for now
            DWORD dwCodeLang = 0;
            LONG lDummy = 4;
            GetDWord( &verBlock.pValue, &dwCodeLang, &lDummy);

            // Put the value in the string value
            wsprintf( &verBlock.szValue[0], "%#08lX", dwCodeLang );
        }

        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in an accelerator
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        // we will need to calculate the correct ID for mike
        //Put the Id
        dwOverAllSize += PutDWord( &lpBuf, wPos, &dwBufSize);


        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        lpResItem->lpszClassName = strcpy( lpStrBuf, verBlock.szKey );
        lpStrBuf += strlen(lpResItem->lpszClassName)+1;

        lpResItem->lpszCaption = strcpy( lpStrBuf, verBlock.szValue );
        lpStrBuf += strlen(lpResItem->lpszCaption)+1;


        // Put the size of the resource
        if (dwBufSize>0) {
            uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
        }

        // Check if we are alligned
        uiOffset += Allign( (BYTE**)&lpStrBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += uiOffset-sizeof(RESITEM);
        lpResItem->dwSize = (DWORD)uiOffset;


        // Move to the next position
        lpResItem = (LPRESITEM) lpStrBuf;
        lpBuf = (BYTE far *)lpStrBuf;
        lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==(dwImageSize))
                dwImageSize = -1;
        }
    }
    return (UINT)(dwOverAllSize);
}

static void GenerateTransField( WORD wLang, VER_BLOCK * pVer )
{
    // Get the DWORD value
    DWORD dwValue = GenerateTransField( wLang, TRUE );
    char buf[9];

    // Put the value in the string value
    wsprintf( &buf[0], "%08lX", dwValue );

    // Just check if we are in the right place. Should never have problem
    if (strlen(pVer->szKey)==8) {
        //strcpy( pVer->szKey, buf );
        // We have to change the header in the image, not just the
        // szKey field
        // Get the pointer to he begin of the filed
        WORD wPad = Pad4(pVer->wHead);
        BYTE far * pHead = pVer->pValue-pVer->wHead-wPad;
        pHead += 4; // Move at the begin of the string
        strcpy( (char*)pHead, buf );
    }
}

static DWORD GenerateTransField(WORD wLang, BOOL bReverse)
{
    // we have to generate a table to connect
    // the language with the correct code page

    WORD wCP = 0;
    DWORD dwRet = 0;
    switch (wLang) {
        // Just have a big switch to assign the codepage
        case 0x1401: wCP =  1256;   break;      //    Algeria
        case 0x1801: wCP =  1256;   break;      //    Morocco
        case 0x1C01: wCP =  1256;   break;      //    Tunisia
        case 0x2001: wCP =  1256;   break;      //    Oman
        case 0x2401: wCP =  1256;   break;      //    Yemen
        case 0x2801: wCP =  1256;   break;      //    Syria
        case 0x2C01: wCP =  1256;   break;      //    Jordan
        case 0x3001: wCP =  1256;   break;      //    Lebanon
        case 0x3401: wCP =  1256;   break;      //    Kuwait
        case 0x3801: wCP =  1256;   break;      //    U.A.E.
        case 0x3C01: wCP =  1256;   break;      //    Bahrain
        case 0x4001: wCP =  1256;   break;      //    Qatar
        case 0x0423: wCP =  1251;   break;      //    Byelorussia
        case 0x0402: wCP =  1251;   break;      //    Bulgaria
        case 0x0403: wCP =  1252;   break;      //    Catalan
        case 0x0404: wCP =  950;    break;      //    Taiwan
        case 0x0804: wCP =  936;    break;      //    PRC
        case 0x0C04: wCP =  950;    break;      //    Hong Kong
        case 0x1004: wCP =  936;    break;      //    Singapore
        case 0x0405: wCP =  1250;   break;      //    Czech
        case 0x0406: wCP =  1252;   break;      //    Danish
        case 0x0413: wCP =  1252;   break;      //    Dutch (Standard)
        case 0x0813: wCP =  1252;   break;      //    Dutch (Belgian)
        case 0x0409: wCP =  1252;   break;      //    English (American)
        case 0x0809: wCP =  1252;   break;      //    English (British)
        case 0x1009: wCP =  1252;   break;      //    English (Canadian)
        case 0x1409: wCP =  1252;   break;      //    English (New Zealand)
        case 0x0c09: wCP =  1252;   break;      //    English (Australian)
        case 0x1809: wCP =  1252;   break;      //    English (Ireland)
        case 0x0425: wCP =  1257;   break;      //    Estonia
            //case 0x0429: wCP =       Farsi
        case 0x040b: wCP =  1252;   break;      //    Finnish
        case 0x040c: wCP =  1252;   break;      //    French (Standard)
        case 0x080c: wCP =  1252;   break;      //    French (Belgian)
        case 0x100c: wCP =  1252;   break;      //    French (Swiss)
        case 0x0c0c: wCP =  1252;   break;      //    French (Canadian)
        case 0x0407: wCP =  1252;   break;      //    German (Standard)
        case 0x0807: wCP =  1252;   break;      //    German (Swiss)
        case 0x0c07: wCP =  1252;   break;      //    German (Austrian)
        case 0x0408: wCP =  1253;   break;      //    Greek
        case 0x040D: wCP =  1255;   break;      //    Israel
        case 0x040e: wCP =  1250;   break;      //    Hungarian
        case 0x040f: wCP =  1252;   break;      //    Icelandic
        case 0x0421: wCP =  1252;   break;      //    Indonesia
        case 0x0410: wCP =  1252;   break;      //    Italian (Standard)
        case 0x0810: wCP =  1252;   break;      //    Italian (Swiss)
        case 0x0411: wCP =  932;    break;      //    Japanese
        case 0x0412: wCP =  949;    break;      //    Korea
        case 0x0426: wCP =  1257;   break;      //    Latvia
        case 0x0427: wCP =  1257;   break;      //    Lithuania
        case 0x0414: wCP =  1252;   break;      //    Norwegian (Bokmal)
        case 0x0814: wCP =  1252;   break;      //    Norwegian (Nynorsk)
        case 0x0415: wCP =  1250;   break;      //    Polish
        case 0x0816: wCP =  1252;   break;      //    Portuguese (Standard)
        case 0x0416: wCP =  1252;   break;      //    Portuguese (Brazilian)
        case 0x0417: wCP =  1252;   break;      //    Rhaeto-Romanic
        case 0x0818: wCP =  1250;   break;      //    Moldavia
        case 0x0418: wCP =  1250;   break;      //    Romanian
        case 0x0419: wCP =  1251;   break;      //    Russian
        case 0x041b: wCP =  1250;   break;      //    Slovak
        case 0x0424: wCP =  1250;   break;      //    Slovenian
        case 0x042e: wCP =  1250;   break;      //    Germany
        case 0x080a: wCP =  1252;   break;      //    Spanish (Mexican)
        case 0x040a: wCP =  1252;   break;      //    Spanish (Castilian)
        case 0x0c0a: wCP =  1252;   break;      //    Spanish (Modern)
        case 0x041d: wCP =  1252;   break;      //    Swedish
        case 0x041E: wCP =  874;    break;      //    Thailand
        case 0x041f: wCP =  1254;   break;      //    Turkish
        case 0x0422: wCP =  1251;   break;      //    Ukraine
        default: wCP =  1252;       break;      //    Return standard US English CP.
    }
    if (bReverse)
        dwRet = MAKELONG( wCP, wLang );
    else dwRet = MAKELONG( wLang, wCP );
    return dwRet;
}

#ifdef VB
static
UINT
UpdateVBData( LPVOID lpNewBuf, LONG dwNewSize,
              LPVOID lpOldI, LONG dwOldImageSize,
              LPVOID lpNewI, DWORD* pdwNewImageSize )
{
// The following special format is used by VB for international messages
// The code here is mostly copied from the UpdateMenu routine
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    // Data Items
    WORD wDataId;
    char szTxt[256];
    WORD wPos = 0;

    // Updated items
    WORD wUpdPos = 0;
    WORD wUpdDataId;
    char szUpdTxt[256];

    LONG  dwOverAllSize = 0l;


    // Copy the language specifier
    dwOldImageSize -= PutDWord( &lpNewImage, *((DWORD*)lpOldImage), &dwNewImageSize);
    lpOldImage += sizeofDWord;
    dwOverAllSize += sizeofDWord;
    GetString( &lpOldImage, &szTxt[0], &dwOldImageSize );
    dwOverAllSize += PutString( &lpNewImage, &szTxt[0], &dwNewImageSize);

    // Now copy the strings
    while (dwOldImageSize>0) {
        wPos++;
        // Check for only padding remaining and exit
        if ( *(WORD *)lpOldImage != RES_SIGNATURE )
            if ( dwOldImageSize < 16 && *(BYTE *)lpOldImage == 0 )
                break;
            else
                return ERROR_RW_INVALID_FILE;
        // This copies signature and ID
        wDataId = *(WORD *)(lpOldImage + sizeof(WORD));
        dwOldImageSize -= PutDWord( &lpNewImage, *((DWORD*)lpOldImage), &dwNewImageSize);
        lpOldImage += sizeofDWord;
        dwOverAllSize += sizeofDWord;

        // Get the untranslated string
        GetString( &lpOldImage, &szTxt[0], &dwOldImageSize );

        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdPos = HIWORD(lpResItem->dwItemID);
            wUpdDataId = LOWORD(lpResItem->dwItemID);
            strcpy( szUpdTxt, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if ((wPos==wUpdPos) && (wUpdDataId==wDataId)) {
            strcpy(szTxt, szUpdTxt);
            wUpdPos = 0;
        }
        // Write the text
        dwOverAllSize += PutString( &lpNewImage, &szTxt[0], &dwNewImageSize);

        // Check for padding
        if (dwOldImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((dwOriginalOldSize-dwOldImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwOldImageSize, bPad );
            if (bPad==dwOldImageSize) {
                BYTE far * lpBuf = lpOldImage;
                while (bPad) {
                    if (*lpBuf++!=0x00)
                        break;
                    bPad--;
                }
                if (bPad==0)
                    dwOldImageSize = -1;
            }
        }

    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}
#endif


static
UINT
UpdateVerst( LPVOID lpNewBuf, LONG dwNewSize,
             LPVOID lpOldI, LONG dwOldImageSize,
             LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    /*
     * This Function is a big mess. It is like this because the RC compiler generate
     * some inconsistent code so we have to do a lot of hacking to get the VS working
     * In future, if ever ver.dll and the RC compiler will be fixed will be possible
     * fix some of the bad thing we have to do to get the updated VS as consistent as
     * possible with the old one
     */

    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    WORD wPos = 0;

    // Updated info
    WORD wUpdPos = 0;
    static char szCaption[300];
    static char szUpdCaption[300];
    static char szUpdKey[100];

    DWORD dwOriginalOldSize = dwOldImageSize;
    LONG dwOverAllSize = 0l;

    WORD wPad = 0;

    // Pointer to the block size to fix up later
    BYTE far * lpVerBlockSize = LPNULL;
    BYTE far * lpSFIBlockSize = LPNULL;
    BYTE far * lpTrnBlockSize = LPNULL;
    BYTE far * lpStrBlockSize = LPNULL;
    BYTE far * lpDummy = LPNULL;

    WORD wVerBlockSize = 0;
    WORD wSFIBlockSize = 0;
    WORD wTrnBlockSize = 0;
    WORD wStrBlockSize = 0;
    WORD wTrash = 0;        // we need this to fix a bug in the RC compiler

    // StringFileInfo
    static VER_BLOCK SFI;   // StringFileInfo
    LONG lSFILen = 0;

    // Translation blocks
    static VER_BLOCK Trn;
    LONG lTrnLen = 0;

    static VER_BLOCK Str;   // Strings

    // we read first of all the information from the VS_VERSION_INFO block
    static VER_BLOCK VS_INFO; // VS_VERSION_INFO

    int iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &VS_INFO );

    // Write the block in the new image
    wVerBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, VS_INFO, &VS_INFO.szValue[0], &lpVerBlockSize, &wTrash );

    dwOverAllSize = wVerBlockSize+wTrash;

    // we have to check the len of the full block for padding.
    // For some wild reasons the RC compiler place a wrong value there
    LONG lVS_INFOLen = VS_INFO.wBlockLen - iHeadLen - Pad4(VS_INFO.wBlockLen);

    while (dwOldImageSize>0 && lVS_INFOLen>0) {
        //Get the StringFileInfo
        iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &SFI );

        // Check if this is the StringFileInfo field
        if (!strcmp(SFI.szKey, "StringFileInfo")) {
            // Read all the translation blocks
            lSFILen = SFI.wBlockLen-iHeadLen-Pad4(SFI.wBlockLen);
            // Write the block in the new image
            wSFIBlockSize = (WORD)PutVSBlock( &lpNewImage, &dwNewImageSize, SFI, &SFI.szValue[0], &lpSFIBlockSize, &wTrash );
            dwOverAllSize += wSFIBlockSize+wTrash;

            while (lSFILen>0) {
                // Read the Translation block
                iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &Trn );

                // Calculate the right key name
                if ((lpResItem = GetItem( lpBuf, dwNewSize, Trn.szKey))) {
                    // Find the Translation ResItem
                    LPRESITEM lpTrans = GetItem( lpBuf, dwNewSize, "Translation");
                    WORD wLang = (lpTrans ? LOWORD(lpTrans->dwLanguage) : 0xFFFF);
                    GenerateTransField( wLang, &Trn );
                }

                // Write the block in the new image
                wTrnBlockSize = (WORD) PutVSBlock( &lpNewImage, &dwNewImageSize, Trn, &Trn.szValue[0], &lpTrnBlockSize, &wTrash );
                dwOverAllSize += wTrnBlockSize+wTrash;
                lTrnLen = Trn.wBlockLen-iHeadLen-Pad4(Trn.wBlockLen);
                while (lTrnLen>0) {
                    // Read the Strings in the block
                    iHeadLen = GetVSBlock( &lpOldImage, &dwOldImageSize, &Str );
                    lTrnLen -= iHeadLen;
                    TRACE2("Key: %s\tValue: %s\n", Str.szKey, Str.szValue );
                    TRACE3("Len: %hd\tValLen: %hd\tType: %hd\n", Str.wBlockLen, Str.wValueLen, Str.wType );

                    strcpy(szCaption, Str.szValue);
                    // Check if this Item has been updated
                    if ((lpResItem = GetItem( lpBuf, dwNewSize, Str.szKey))) {
                        strcpy( szUpdCaption, lpResItem->lpszCaption );
                        strcpy( szUpdKey, lpResItem->lpszClassName );
                    }
                    if (!strcmp( szUpdKey, Str.szKey)) {
                        strcpy( szCaption, szUpdCaption );
                        wUpdPos = 0;
                    }

                    // Write the block in the new image
                    wStrBlockSize = (WORD) PutVSBlock( &lpNewImage, &dwNewImageSize, Str, szCaption, &lpStrBlockSize, &wTrash );
                    dwOverAllSize += wStrBlockSize+wTrash;

                    // Fix up the size of the block
                    if (dwNewImageSize>=0)
                        memcpy( lpStrBlockSize, &wStrBlockSize, 2);

                    wTrnBlockSize += wStrBlockSize + wTrash;
                }
                lSFILen -= Trn.wBlockLen;
                // Fix up the size of the block
                if (dwNewImageSize>=0)
                    memcpy( lpTrnBlockSize, &wTrnBlockSize, 2);

                wSFIBlockSize += wTrnBlockSize;
            }
            lVS_INFOLen -= SFI.wBlockLen;
            // Fix up the size of the block
            if (dwNewImageSize>=0)
                memcpy( lpSFIBlockSize, &wSFIBlockSize, 2);
            wVerBlockSize += wSFIBlockSize;

        } else {
            // this is another block skip it all
            lVS_INFOLen -= SFI.wValueLen+iHeadLen;

            // Check if this block is the translation field
            if (!strcmp(SFI.szKey, "Translation")) {
                // it is calculate the right value to place in the value field
                // We calculate automatically the value to have the correct
                // localized language in the translation field
                //wVerBlockSize += PutTranslation( &lpNewImage, &dwNewImageSize, SFI );
                // check if this is the translation block
                // This is the translation block let the localizer have it for now
                /*
                if ((lpResItem = GetItem( lpBuf, dwNewSize, SFI.szKey)))
                    strcpy( szUpdCaption, lpResItem->lpszCaption );
                // Convert the value back in numbers
                DWORD dwCodeLang = strtol( szUpdCaption, '\0', 16);
                */

                //
                // We do generate the Tranlsation filed from the language
                // We will have to update the block name as well
                //

                DWORD dwCodeLang = 0;
                if ((lpResItem = GetItem( lpBuf, dwNewSize, SFI.szKey)))
                    dwCodeLang = GenerateTransField((WORD)LOWORD(lpResItem->dwLanguage), FALSE);

                else {
                    // Place the original value here
                    dwCodeLang =(DWORD)*(SFI.pValue);
                }
                LONG lDummy = 4;
                SFI.pValue -= PutDWord( &SFI.pValue, dwCodeLang, &lDummy );

            }

            // Write the block in the new image
            wVerBlockSize += (WORD) PutVSBlock( &lpNewImage, &dwNewImageSize, SFI, &SFI.szValue[0], &lpDummy, &wTrash );
            if (dwNewImageSize>=0)
                memcpy( lpVerBlockSize, &wVerBlockSize, 2);

            dwOverAllSize = wVerBlockSize+wTrash;

        }
    }

    // fix up the block size
    if (dwNewImageSize>=0)
        memcpy( lpVerBlockSize, &wVerBlockSize, 2);

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


static
UINT ParseAccel( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
    TRACE("ParseAccelerator: \n");
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;
    LONG dwOverAllSize = 0L;
    WORD wPos = 0;
    BYTE fFlags = 0;
    WORD wEvent = 0;
    WORD wId = 0;

    // Reset the IDArray
    CalcID(0, FALSE);
    while (dwImageSize>0) {
        wPos++;
        GetByte( &lpImage, &fFlags, &dwImageSize );
        GetWord( &lpImage, &wEvent, &dwImageSize );
        GetWord( &lpImage, &wId, &dwImageSize );
        if (fFlags & 0x80)
            dwImageSize = 0;

        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in an accelerator
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)wEvent, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)fFlags, &dwBufSize);
        // we will need to calculate the correct ID for mike
        //Put the Id
        dwOverAllSize += PutDWord( &lpBuf, CalcID(wId, TRUE), &dwBufSize);


        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        // Put the size of the resource
        if (dwBufSize>=0) {
            lDummy = 8;
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
        }

        // Move to the next position
        lpItem = lpBuf;
        /*
        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==(dwImageSize))
                dwImageSize = -1;
        }
        */
    }
    return (UINT)(dwOverAllSize);
}

#ifdef VB
static
UINT ParseVBData( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{
// The following special format is used by VB for international messages
// The code here is mostly copied from the ParseMenu routine

    // UGLY!!  The following values are taken from GLOBALS.C in TMSB.
    // I have added a couple not in use by VB in hopes not to re-build
    // when they decide to add additionals
    enum LOCALE {
        FRENCH = 0x040C,
        GERMAN = 0x0407,
        SPANISH = 0X040A,
        DANISH = 0X0406,
        ITALIAN = 0X0410,
        RUSSIAN = 0X0419,
        JAPANESE = 0X0411,
        PORTUGUESE = 0X0816,
        DUTCH = 0X0413};
//		       {3,0x041D,850,"Swedish",""},
//		       {4,0x0414,850,"Norwegian Bokml","NOB"},
//		       {5,0x0814,850,"Norwegian Nynorsk","NON"},
//		       {6,0x040B,850,"Finnish","FIN"},
//		       {7,0x0C0C,863,"French Canadian","FRC"},
//		       {9,0x0416,850,"Portuguese (Brazilian)","BPO"},
//		       {10,0x0816,850,"Portuguese (Portugal)","PPO"},
//		       {17,0x0415,850,"Polish","POL"},
//		       {18,0x040E,850,"Hungarian","HUN"},
//		       {19,0x0405,850,"Czech","CZE"},
//		       {20,0x0401,864,"Arabic","ARA"},
//		       {21,0x040D,862,"Hebrew","HBR"},
//		       {23,0x0412,934,"Korean","KOR"},
//		       {24,0x041E,938,"Thai","THA"},
//		       {25,0x0404,936,"Chinese (Traditional)","CHI (Tra)"},
//		       {26,0x0404,936,"Chinese (Simplified)","CHI (Sim)"},
    WORD wSig, wID;
    LONG dwImageSize = dwISize;
    LONG dwOverAllSize = 0L;
    LONG lDummy;
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    static char szWork[MAXSTR];
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;

    GetWord( &lpImage, &wSig, &dwImageSize);
    if ( wSig != RES_SIGNATURE )    // Not a VB resource
        return 0;
    GetWord( &lpImage, &wSig, &dwImageSize);
    if ( wSig != 0 )                // Header should have zero ID
        return 0;
    GetString( &lpImage, &szWork[0], &dwImageSize );
    LOCALE locale = (LOCALE)GetPrivateProfileInt("AUTOTRANS","Locale", 0, "ESPRESSO.INI");
    if (( lstrcmp(szWork, "VBINTLSZ_FRENCH") == 0 && locale == FRENCH) ||
        ( lstrcmp(szWork, "VBINTLSZ_GERMAN") == 0 && locale == GERMAN) ||
        ( lstrcmp(szWork, "VBINTLSZ_ITALIAN") == 0 && locale == ITALIAN) ||
        ( lstrcmp(szWork, "VBINTLSZ_JAPANESE") == 0 && locale == JAPANESE) ||
        ( lstrcmp(szWork, "VBINTLSZ_SPANISH") == 0 && locale == SPANISH) ||
        ( lstrcmp(szWork, "VBINTLSZ_DANISH") == 0 && locale == DANISH) ||
        ( lstrcmp(szWork, "VBINTLSZ_DUTCH") == 0 && locale == DUTCH) ||
        ( lstrcmp(szWork, "VBINTLSZ_PORTUGUESE") == 0 && locale == PORTUGUESE)
       ) {
        while ( dwImageSize > 0 ) {
            GetWord( &lpImage, &wSig, &dwImageSize);
            // Check for only padding remaining and exit
            if ( wSig != RES_SIGNATURE )
                if ( dwImageSize < 16 && *(BYTE *)lpImage == 0 )
                    break;
                else
                    return ERROR_RW_INVALID_FILE;
            GetWord( &lpImage, &wID, &dwImageSize); // ID
            // Fixed field
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
            // We don't have the size and pos in a string
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

            // we don't have checksum and style
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            // We'll save the string's "resource" ID as an Item ID
            dwOverAllSize += PutDWord( &lpBuf, wID, &dwBufSize);

            // Don't save a resource ID or  Type Id
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            // we don't display the language
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

            // we don't have the codepage or the font name
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
            dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
            dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

            // Let's put null were we don;t have the strings
            uiOffset = sizeof(RESITEM);
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ClassName
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // FaceName
            dwOverAllSize += PutDWord( &lpBuf, (DWORD)(DWORD_PTR)(lpItem+uiOffset), &dwBufSize);   // Caption
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ResItem
            dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // TypeItem

            // Get the text
            GetString( &lpImage, &szWork[0], &dwImageSize );    // Text string
            dwOverAllSize += PutString( & lpBuf, &szWork[0], &dwBufSize);
            // Put the size of the resource
            if (dwBufSize>=0) {
                uiOffset += strlen((LPSTR)(lpItem+uiOffset))+1;
                lDummy = 8;
                PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);
            }

            // Move to the next position
            lpItem = lpBuf;
            if (dwImageSize<=16) {
                // Check if we are at the end and this is just padding
                BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
                //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
                if (bPad==(dwImageSize))
                    dwImageSize = -1;
            }
        }
        return (UINT)(dwOverAllSize);
    }
    return 0;

}
#endif


static
UINT
UpdateAccel( LPVOID lpNewBuf, LONG dwNewSize,
             LPVOID lpOldI, LONG dwOldImageSize,
             LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    TRACE("UpdateAccel\n");

    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;


    //Old Items
    BYTE fFlags = 0;
    WORD wEvent = 0;
    WORD wId = 0;
    WORD wPos = 0;

    // Updated items
    BYTE fUpdFlags = 0;
    WORD wUpdEvent = 0;
    WORD wUpdId = 0;
    WORD wUpdPos = 0;

    LONG  dwOverAllSize = 0l;


    while (dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        GetByte( &lpOldImage, &fFlags, &dwOldImageSize );
        GetWord( &lpOldImage, &wEvent, &dwOldImageSize );
        GetWord( &lpOldImage, &wId, &dwOldImageSize );
        if (fFlags & 0x80)
            dwOldImageSize = 0;


        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdId = LOWORD(lpResItem->dwItemID);
            wUpdPos = HIWORD(lpResItem->dwItemID);
            fUpdFlags = (BYTE)lpResItem->dwFlags;
            wUpdEvent = (WORD)lpResItem->dwStyle;
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        TRACE3("Old Accel: wID: %hd\t wEvent: %hd\t wFlag: %hd\n", wId, wEvent, fFlags);
        TRACE3("New Accel: wID: %hd\t wEvent: %hd\t wFlag: %hd\n", wUpdId, wUpdEvent, fUpdFlags);


        if ((wPos==wUpdPos) && (wUpdId==wId)) {

            if (fFlags & 0x80)
                fFlags = fUpdFlags | 0x80;
            else fFlags = fUpdFlags;
            wEvent = wUpdEvent;
            wUpdPos = 0;
        }

        dwOverAllSize += PutByte( &lpNewImage, fFlags, &dwNewImageSize);
        dwOverAllSize += PutWord( &lpNewImage, wEvent, &dwNewImageSize);
        dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize);

        /*
        if (dwOldImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwOriginalOldSize-dwOldImageSize));
            if (bPad==dwOldImageSize)
                dwOldImageSize = 0;

        }
        */
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


static
UINT
ParseMenu( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{

    // Should be almost impossible for a Menu to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;

    // skip the menu header
    SkipByte( &lpImage, 4, &dwImageSize );

    // Menu Items
    WORD fItemFlags;
    WORD wMenuId;
    static char    szCaption[MAXSTR];

    int iter = 1;
    while (dwImageSize>0) {

        // Let's get the Menu flags
        GetWord( &lpImage, &fItemFlags, &dwImageSize );

        if ( !(fItemFlags & MF_POPUP) )
            // Get the menu Id
            GetWord( &lpImage, &wMenuId, &dwImageSize );
        else wMenuId = (WORD)-1;

        // Get the text
        GetString( &lpImage, &szCaption[0], &dwImageSize );

        // Check if is not a separator or padding
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a menu
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Flag
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)fItemFlags, &dwBufSize);
        //Put the MenuId
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)wMenuId, &dwBufSize);

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)(DWORD_PTR)(lpItem+uiOffset), &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        // Get the text
        // calculate were the string is going to be
        // Will be the fixed header+the pointer
        dwOverAllSize += PutString( &lpBuf, &szCaption[0], &dwBufSize);

        TRACE("Menu: Iteration %d size %d\n", iter++, dwOverAllSize);
        // Put the size of the resource
        uiOffset += strlen(szCaption)+1;
        // Check if we are alligned
        lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += lDummy;
        uiOffset += lDummy;
        lDummy = 4;
        if (dwBufSize>=0)
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);

        // Move to the next position
        lpItem = lpBuf;

        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==dwImageSize) {
                BYTE far * lpBuf = lpImage;
                while (bPad) {
                    if (*lpBuf++!=0x00)
                        break;
                    bPad--;
                }
                if (bPad==0)
                    dwImageSize = -1;
            }
        }
    }


    return (UINT)(dwOverAllSize);
}

static
UINT
UpdateMenu( LPVOID lpNewBuf, LONG dwNewSize,
            LPVOID lpOldI, LONG dwOldImageSize,
            LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    // Menu Items
    WORD fItemFlags;
    WORD wMenuId;
    char szTxt[256];
    WORD wPos = 0;

    // Updated items
    WORD wUpdPos = 0;
    WORD fUpdItemFlags;
    WORD wUpdMenuId;
    char szUpdTxt[256];

    LONG  dwOverAllSize = 0l;


    // Copy the menu flags
    dwOldImageSize -= PutDWord( &lpNewImage, *((DWORD*)lpOldImage), &dwNewImageSize);
    lpOldImage += sizeofDWord;
    dwOverAllSize += sizeofDWord;

    while (dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        // Get the menu flag
        GetWord( &lpOldImage, &fItemFlags, &dwOldImageSize );

        if ( !(fItemFlags & MF_POPUP) )
            GetWord( &lpOldImage, &wMenuId, &dwOldImageSize );
        else wMenuId = (WORD)-1;

        // Get the text
        GetString( &lpOldImage, &szTxt[0], &dwOldImageSize );

        if ((!wUpdPos) && dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdPos = HIWORD(lpResItem->dwItemID);
            wUpdMenuId = LOWORD(lpResItem->dwItemID);
            fUpdItemFlags = (WORD)lpResItem->dwFlags;
            strcpy( szUpdTxt, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if ((wPos==wUpdPos) && (wUpdMenuId==wMenuId)) {
            // check if it is not the last item in the menu
            if (fItemFlags & MF_END)
                fItemFlags = fUpdItemFlags | (WORD)MF_END;
            else fItemFlags = fUpdItemFlags;

            wMenuId = wUpdMenuId;

            // check it is not a separator
            if ((fItemFlags==0) && (wMenuId==0))
                strcpy(szTxt, "");
            else strcpy(szTxt, szUpdTxt);
            wUpdPos = 0;
        }
        dwOverAllSize += PutWord( &lpNewImage, fItemFlags, &dwNewImageSize);

        if ( !(fItemFlags & MF_POPUP) ) {
            dwOverAllSize += PutWord( &lpNewImage, wMenuId, &dwNewImageSize);
        }

        // Write the text
        dwOverAllSize += PutString( &lpNewImage, &szTxt[0], &dwNewImageSize);

        // Check for padding
        if (dwOldImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((dwOriginalOldSize-dwOldImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwOldImageSize, bPad );
            if (bPad==dwOldImageSize) {
                BYTE far * lpBuf = lpOldImage;
                while (bPad) {
                    if (*lpBuf++!=0x00)
                        break;
                    bPad--;
                }
                if (bPad==0)
                    dwOldImageSize = -1;
            }
        }

    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}

static UINT GenerateMenu( LPVOID lpNewBuf, LONG dwNewSize,
                          LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;

    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    // Updated items
    WORD wUpdPos = 0;
    WORD fUpdItemFlags;
    WORD wUpdMenuId;
    char szUpdTxt[256];

    LONG  dwOverAllSize = 0l;

    // invent the menu flags
    dwOverAllSize += PutDWord( &lpNewImage, 0L, &dwNewImageSize);

    while (dwNewSize>0) {
        if (dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            wUpdMenuId = LOWORD(lpResItem->dwItemID);
            fUpdItemFlags = (WORD)lpResItem->dwFlags;
            strcpy( szUpdTxt, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        dwOverAllSize += PutWord( &lpNewImage, fUpdItemFlags, &dwNewImageSize);

        if ( !(fUpdItemFlags & MF_POPUP) )
            dwOverAllSize += PutWord( &lpNewImage, wUpdMenuId, &dwNewImageSize);

        // Write the text
        // check if it is a separator
        if ( !(fUpdItemFlags) && !(wUpdMenuId) )
            szUpdTxt[0] = 0x00;
        dwOverAllSize += PutString( &lpNewImage, &szUpdTxt[0], &dwNewImageSize);

    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}

static
UINT
ParseString( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{

    // Should be almost impossible for a String to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    BYTE far * lpItem = (BYTE far *)lpBuffer;
    UINT uiOffset = 0;
    LONG lDummy;

    LONG dwOverAllSize = 0L;

    LONG dwRead = 0L;

    BYTE bIdCount = 0;

    while ( (dwImageSize>0) && (bIdCount<16)  ) {
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
        // We don't have the size and pos in a string
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);

        // we don't have checksum and style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the StringId
        dwOverAllSize += PutDWord( &lpBuf, bIdCount++, &dwBufSize);

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage or the font name
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ClassName
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // FaceName
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)(DWORD_PTR)(lpItem+uiOffset), &dwBufSize);   // Caption
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ResItem
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // TypeItem

        // Get the text
        BYTE bstrlen = *lpImage++;
        dwImageSize -= 1;
        TRACE1("StrLen: %hd\t", bstrlen);
        if ((bstrlen+1)>dwBufSize) {
            dwOverAllSize += bstrlen+1;
            dwImageSize -= bstrlen;
            lpImage += bstrlen;
            dwBufSize -= bstrlen+1;
            TRACE1("BufferSize: %ld\n", dwBufSize);
        } else {
            if (bstrlen)
                memcpy( (char*)lpBuf, (char*)lpImage, bstrlen );

            *(lpBuf+(bstrlen)) = 0;
            TRACE1("Caption: %Fs\n", lpBuf);
            lpImage += bstrlen;
            lpBuf += bstrlen+1;
            dwImageSize -= bstrlen;
            dwBufSize -= bstrlen+1;
            dwOverAllSize += bstrlen+1;
        }


        // Put the size of the resource
        uiOffset += bstrlen+1;
        // Check if we are alligned
        lDummy = Allign( &lpBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += lDummy;
        uiOffset += lDummy;
        lDummy = 4;
        if (dwBufSize>=0)
            PutDWord( &lpItem, (DWORD)uiOffset, &lDummy);

        // Move to the next position
        lpItem = lpBuf;
        if ((dwImageSize<=16) && (bIdCount==16)) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==dwImageSize)
                dwImageSize = -1;
        }
    }


    return (UINT)(dwOverAllSize);
}

static
UINT
UpdateString( LPVOID lpNewBuf, LONG dwNewSize,
              LPVOID lpOldI, LONG dwOldImageSize,
              LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    BYTE bLen;
    char szTxt[MAXSTR];
    WORD wPos = 0;

    // Updated info
    WORD wUpdPos = 0;
    char szUpdTxt[MAXSTR];

    DWORD dwOriginalOldSize = dwOldImageSize;
    LONG dwOverAllSize = 0l;

    while (dwOldImageSize>0) {
        wPos++;
        // Get the information from the old image
        GetByte( &lpOldImage, &bLen, &dwOldImageSize );

        // Copy the text
        if (bLen>MAXSTR) {

        } else {
            memcpy( szTxt, (char*)lpOldImage, bLen );
            lpOldImage += bLen;
            dwOldImageSize -= bLen;
            szTxt[bLen]='\0';
        }

        if ((!wUpdPos) && dwNewSize ) {
            /*
            GetUpdatedItem(
                            &lpNewBuf, &dwNewSize,
                            &wDummy, &wDummy,
                            &wDummy, &wDummy,
                            &dwPosId,
                            &dwDummy, &dwDummy,
                            &szUpdTxt[0]);

            wUpdPos = HIWORD(dwPosId);
            */
            lpResItem = (LPRESITEM) lpBuf;

            wUpdPos = HIWORD(lpResItem->dwItemID);
            strcpy( szUpdTxt, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        if ((wPos==wUpdPos)) {
            strcpy(szTxt, szUpdTxt);
            wUpdPos = 0;
        }

        bLen = strlen(szTxt);
        //dwOverAllSize += PutByte( &lpNewImage, (BYTE)bLen, &dwNewImageSize);

        // Write the text
        dwOverAllSize += PutPascalString( &lpNewImage, &szTxt[0], bLen, &dwNewImageSize );

        if ((dwOldImageSize<=16) && (wPos==16)) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwOriginalOldSize-dwOldImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==dwOldImageSize)
                dwOldImageSize = -1;
        }
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}

static
UINT
GenerateString( LPVOID lpNewBuf, LONG dwNewSize,
                LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    UINT uiError = ERROR_NO_ERROR;

    LONG dwNewImageSize = *pdwNewImageSize;
    BYTE far * lpNewImage = (BYTE far *) lpNewI;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    // We have to read the information from the lpNewBuf
    BYTE bLen;
    static char szTxt[MAXSTR];
    WORD wPos = 0;

    LONG dwOverAllSize = 0l;

    while (dwNewSize>0) {
        if ( dwNewSize ) {
            lpResItem = (LPRESITEM) lpBuf;

            strcpy( szTxt, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        bLen = strlen(szTxt);

        // Write the text
        dwOverAllSize += PutPascalString( &lpNewImage, &szTxt[0], bLen, &dwNewImageSize );
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


static
UINT
ParseDialog( LPVOID lpImageBuf, DWORD dwISize,  LPVOID lpBuffer, DWORD dwSize )
{

    // Should be almost impossible for a Dialog to be Huge
    BYTE far * lpImage = (BYTE far *)lpImageBuf;
    LONG dwImageSize = dwISize;

    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    LONG dwBufSize = dwSize;

    LPRESITEM lpResItem = (LPRESITEM)lpBuffer;
    UINT uiOffset = 0;

    char far * lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

    LONG dwOverAllSize = 0L;

    BYTE    bIdCount = 0;

    // Dialog Elements
    DWORD   dwStyle = 0L;
    BYTE    bNumOfElem = 0;
    WORD    wX = 0;
    WORD    wY = 0;
    WORD    wcX = 0;
    WORD    wcY = 0;
    WORD    wId = 0;
    static char    szMenuName[MAXID];
    WORD    wMenuName;
    static char    szClassName[MAXID];
    BYTE    bClassName, bControlClassName;
    static char    szCaption[MAXSTR];
    WORD    wOrd;
    WORD    wPointSize = 0;
    static char    szFaceName[MAXID];

    // read the dialog header
    GetDWord( &lpImage, &dwStyle, &dwImageSize );
    GetByte( &lpImage, &bNumOfElem, &dwImageSize );
    GetWord( &lpImage, &wX, &dwImageSize );
    GetWord( &lpImage, &wY, &dwImageSize );
    GetWord( &lpImage, &wcX, &dwImageSize );
    GetWord( &lpImage, &wcY, &dwImageSize );
    GetNameOrOrd( &lpImage, &wMenuName, &szMenuName[0], &dwImageSize );
    GetClassName( &lpImage, &bClassName, &szClassName[0], &dwImageSize );
    GetCaptionOrOrd( &lpImage, &wOrd, &szCaption[0], &dwImageSize,
                     bClassName, dwStyle );
    if ( dwStyle & DS_SETFONT ) {
        GetWord( &lpImage, &wPointSize, &dwImageSize );
        GetString( &lpImage, &szFaceName[0], &dwImageSize );
    }

    TRACE("Win16.DLL ParseDialog\t");
    TRACE1("NumElem: %hd\t", bNumOfElem);
    TRACE1("X %hd\t", wX);
    TRACE1("Y: %hd\t", wY);
    TRACE1("CX: %hd\t", wcX);
    TRACE1("CY: %hd\t", wcY);
    TRACE1("Id: %hd\t", wId);
    TRACE1("Style: %lu\n", dwStyle);
    TRACE1("Caption: %s\n", szCaption);
    TRACE2("ClassName: %s\tClassId: %hd\n", szClassName, bClassName );
    TRACE2("MenuName: %s\tMenuId: %hd\n", szMenuName, wMenuName );
    TRACE2("FontName: %s\tPoint: %hd\n", szFaceName, wPointSize );

    // Fixed field
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

    dwOverAllSize += PutWord( &lpBuf, wX, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wY, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wcX, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wcY, &dwBufSize);

    // we don't have checksum and extended style
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, dwStyle, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    //Put the Id 0 for the main dialog
    dwOverAllSize += PutDWord( &lpBuf, bIdCount++, &dwBufSize);

    // we don't have the resID, and the Type Id
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the language
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    // we don't have the codepage
    dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

    dwOverAllSize += PutWord( &lpBuf, bClassName, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, wPointSize, &dwBufSize);
    dwOverAllSize += PutWord( &lpBuf, (WORD)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
    dwOverAllSize += PutByte( &lpBuf, (BYTE)DEFAULT_CHARSET, &dwBufSize);

    // Let's put null were we don;t have the strings
    uiOffset = sizeof(RESITEM);
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ClassName
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // FaceName
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // Caption
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ResItem
    dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // TypeItem

    lpResItem->lpszClassName = strcpy( lpStrBuf, szClassName );
    lpStrBuf += strlen(lpResItem->lpszClassName)+1;

    lpResItem->lpszFaceName = strcpy( lpStrBuf, szFaceName );
    lpStrBuf += strlen(lpResItem->lpszFaceName)+1;

    lpResItem->lpszCaption = strcpy( lpStrBuf, szCaption );
    lpStrBuf += strlen(lpResItem->lpszCaption)+1;

    // Put the size of the resource
    if (dwBufSize>0) {
        uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
        uiOffset += strlen((LPSTR)(lpResItem->lpszFaceName))+1;
        uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
    }

    // Check if we are alligned
    uiOffset += Allign( (BYTE**)&lpStrBuf, &dwBufSize, (LONG)uiOffset);

    dwOverAllSize += uiOffset-sizeof(RESITEM);
    lpResItem->dwSize = (DWORD)uiOffset;

    // Move to the next position
    lpResItem = (LPRESITEM) lpStrBuf;
    lpBuf = (BYTE far *)lpStrBuf;
    lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

    while ( (dwImageSize>0) && (bNumOfElem>0) ) {
        // Read the COntrols
        GetWord( &lpImage, &wX, &dwImageSize );
        GetWord( &lpImage, &wY, &dwImageSize );
        GetWord( &lpImage, &wcX, &dwImageSize );
        GetWord( &lpImage, &wcY, &dwImageSize );
        GetWord( &lpImage, &wId, &dwImageSize );
        GetDWord( &lpImage, &dwStyle, &dwImageSize );
        GetControlClassName( &lpImage, &bControlClassName, &szClassName[0], &dwImageSize );
        GetCaptionOrOrd( &lpImage, &wOrd, &szCaption[0], &dwImageSize,
                         bControlClassName, dwStyle );
        SkipByte( &lpImage, 1, &dwImageSize );
        bNumOfElem--;
        // Fixed field
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);

        dwOverAllSize += PutWord( &lpBuf, wX, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wY, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wcX, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wcY, &dwBufSize);

        // we don't have checksum and extended style
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, dwStyle, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        //Put the Id
        dwOverAllSize += PutDWord( &lpBuf, wId, &dwBufSize);

        // we don't have the resID, and the Type Id
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the language
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        // we don't have the codepage
        dwOverAllSize += PutDWord( &lpBuf, (DWORD)-1, &dwBufSize);

        dwOverAllSize += PutWord( &lpBuf, bControlClassName, &dwBufSize);
        dwOverAllSize += PutWord( &lpBuf, wPointSize, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, (BYTE)-1, &dwBufSize);
        dwOverAllSize += PutByte( &lpBuf, DEFAULT_CHARSET, &dwBufSize);

        // Let's put null were we don;t have the strings
        uiOffset = sizeof(RESITEM);
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ClassName
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // FaceName
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // Caption
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // ResItem
        dwOverAllSize += PutDWord( &lpBuf, 0, &dwBufSize);  // TypeItem

        lpResItem->lpszClassName = strcpy( lpStrBuf, szClassName );
        lpStrBuf += strlen(lpResItem->lpszClassName)+1;

        lpResItem->lpszFaceName = strcpy( lpStrBuf, szFaceName );
        lpStrBuf += strlen(lpResItem->lpszFaceName)+1;

        lpResItem->lpszCaption = strcpy( lpStrBuf, szCaption );
        lpStrBuf += strlen(lpResItem->lpszCaption)+1;

        // Put the size of the resource
        if (dwBufSize>0) {
            uiOffset += strlen((LPSTR)(lpResItem->lpszClassName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszFaceName))+1;
            uiOffset += strlen((LPSTR)(lpResItem->lpszCaption))+1;
        }

        // Check if we are alligned
        uiOffset += Allign( (BYTE**)&lpStrBuf, &dwBufSize, (LONG)uiOffset);
        dwOverAllSize += uiOffset-sizeof(RESITEM);
        lpResItem->dwSize = (DWORD)uiOffset;

        // Move to the next position
        lpResItem = (LPRESITEM) lpStrBuf;
        lpBuf = (BYTE far *)lpStrBuf;
        lpStrBuf = (char far *)(lpBuf+sizeof(RESITEM));

        TRACE1("\tControl: X: %hd\t", wX);
        TRACE1("Y: %hd\t", wY);
        TRACE1("CX: %hd\t", wcX);
        TRACE1("CY: %hd\t", wcY);
        TRACE1("Id: %hd\t", wId);
        TRACE1("Style: %lu\n", dwStyle);
        TRACE1("Caption: %s\n", szCaption);

        if (dwImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwISize-dwImageSize));
            //TRACE3(" dwRead: %lu\t dwImageSize: %lu\t Pad: %hd\n", dwRead, dwImageSize, bPad );
            if (bPad==dwImageSize)
                dwImageSize = -1;
        }
    }


    return (UINT)(dwOverAllSize);
}

static
UINT
UpdateDialog( LPVOID lpNewBuf, LONG dwNewSize,
              LPVOID lpOldI, LONG dwOldImageSize,
              LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    // Should be almost impossible for a Dialog to be Huge
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpOldImage = (BYTE far *) lpOldI;
    DWORD dwOriginalOldSize = dwOldImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    LONG dwOverAllSize = 0L;

    BYTE    bIdCount = 0;

    // Dialog Elements
    DWORD   dwStyle = 0L;
    BYTE    bNumOfElem = 0;
    WORD    wX = 0;
    WORD    wY = 0;
    WORD    wcX = 0;
    WORD    wcY = 0;
    WORD    wId = 0;
    static char    szMenuName[MAXID];
    WORD    wMenuName;
    static char    szClassName[MAXID];
    BYTE    bClassName, bControlClassName;
    static char    szCaption[MAXSTR];
    WORD    wOrd = 0;
    WORD    wPointSize = 0;
    static char    szFaceName[MAXID];
    WORD    wPos = 1;

    // Updated elements
    WORD    wUpdX = 0;
    WORD    wUpdY = 0;
    WORD    wUpdcX = 0;
    WORD    wUpdcY = 0;
    DWORD   dwUpdStyle = 0l;
    DWORD   dwPosId = 0l;
    static char    szUpdCaption[MAXSTR];
    static char    szUpdFaceName[MAXID];
    WORD    wUpdPointSize = 0;
    WORD    wUpdPos = 0;

    // read the dialog header
    GetDWord( &lpOldImage, &dwStyle, &dwOldImageSize );
    GetByte( &lpOldImage, &bNumOfElem, &dwOldImageSize );
    GetWord( &lpOldImage, &wX, &dwOldImageSize );
    GetWord( &lpOldImage, &wY, &dwOldImageSize );
    GetWord( &lpOldImage, &wcX, &dwOldImageSize );
    GetWord( &lpOldImage, &wcY, &dwOldImageSize );
    GetNameOrOrd( &lpOldImage, &wMenuName, &szMenuName[0], &dwOldImageSize );
    GetClassName( &lpOldImage, &bClassName, &szClassName[0], &dwOldImageSize );
    GetCaptionOrOrd( &lpOldImage, &wOrd, &szCaption[0], &dwOldImageSize,
                     bClassName, dwStyle );
    if ( dwStyle & DS_SETFONT ) {
        GetWord( &lpOldImage, &wPointSize, &dwOldImageSize );
        GetString( &lpOldImage, &szFaceName[0], &dwOldImageSize );
    }

    // Get the infrmation from the updated resource
    if ((!wUpdPos) && dwNewSize ) {
        lpResItem = (LPRESITEM) lpBuf;
        wUpdX = lpResItem->wX;
        wUpdY = lpResItem->wY;
        wUpdcX = lpResItem->wcX;
        wUpdcY = lpResItem->wcY;
        wUpdPointSize = lpResItem->wPointSize;
        dwUpdStyle = lpResItem->dwStyle;
        dwPosId = lpResItem->dwItemID;
        strcpy( szUpdCaption, lpResItem->lpszCaption );
        strcpy( szUpdFaceName, lpResItem->lpszFaceName );
        lpBuf += lpResItem->dwSize;
        dwNewSize -= lpResItem->dwSize;
    }
    // check if we have to update the header
    if ((HIWORD(dwPosId)==wPos) && (LOWORD(dwPosId)==wId)) {
        wX = wUpdX;
        wY = wUpdY;
        wcX = wUpdcX;
        wcY = wUpdcY;
        wPointSize = wUpdPointSize;
        dwStyle = dwUpdStyle;
        strcpy(szCaption, szUpdCaption);
        strcpy(szFaceName, szUpdFaceName);
    }

    // Write the header informations
    dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
    dwOverAllSize += PutByte( &lpNewImage, bNumOfElem, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
    dwOverAllSize += PutNameOrOrd( &lpNewImage, wMenuName, &szMenuName[0], &dwNewImageSize );
    dwOverAllSize += PutClassName( &lpNewImage, bClassName, &szClassName[0], &dwNewImageSize );
    dwOverAllSize += PutCaptionOrOrd( &lpNewImage, wOrd, &szCaption[0], &dwNewImageSize,
                                      bClassName, dwStyle );
    if ( dwStyle & DS_SETFONT ) {
        dwOverAllSize += PutWord( &lpNewImage, wPointSize, &dwNewImageSize );
        dwOverAllSize += PutString( &lpNewImage, &szFaceName[0], &dwNewImageSize );
    }

    while ( (dwOldImageSize>0) && (bNumOfElem>0) ) {
        wPos++;
        // Get the info for the control
        // Read the COntrols
        GetWord( &lpOldImage, &wX, &dwOldImageSize );
        GetWord( &lpOldImage, &wY, &dwOldImageSize );
        GetWord( &lpOldImage, &wcX, &dwOldImageSize );
        GetWord( &lpOldImage, &wcY, &dwOldImageSize );
        GetWord( &lpOldImage, &wId, &dwOldImageSize );
        GetDWord( &lpOldImage, &dwStyle, &dwOldImageSize );
        GetControlClassName( &lpOldImage, &bControlClassName, &szClassName[0], &dwOldImageSize );
        GetCaptionOrOrd( &lpOldImage, &wOrd, &szCaption[0], &dwOldImageSize,
                         bControlClassName, dwStyle );
        SkipByte( &lpOldImage, 1, &dwOldImageSize );
        bNumOfElem--;

        if ((!wUpdPos) && dwNewSize ) {
            TRACE1("\t\tUpdateDialog:\tdwNewSize=%ld\n",(LONG)dwNewSize);
            TRACE1("\t\t\t\tlpszCaption=%Fs\n",lpResItem->lpszCaption);
            lpResItem = (LPRESITEM) lpBuf;
            wUpdX = lpResItem->wX;
            wUpdY = lpResItem->wY;
            wUpdcX = lpResItem->wcX;
            wUpdcY = lpResItem->wcY;
            dwUpdStyle = lpResItem->dwStyle;
            dwPosId = lpResItem->dwItemID;
            strcpy( szUpdCaption, lpResItem->lpszCaption );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        // check if we have to update the header
        if ((HIWORD(dwPosId)==wPos) && (LOWORD(dwPosId)==wId)) {
            wX = wUpdX;
            wY = wUpdY;
            wcX = wUpdcX;
            wcY = wUpdcY;
            dwStyle = dwUpdStyle;
            strcpy(szCaption, szUpdCaption);
        }

        //write the control
        dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize );
        dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
        dwOverAllSize += PutControlClassName( &lpNewImage, bControlClassName, &szClassName[0], &dwNewImageSize );
        dwOverAllSize += PutCaptionOrOrd( &lpNewImage, wOrd, &szCaption[0], &dwNewImageSize,
                                          bControlClassName, dwStyle );
        dwOverAllSize += PutByte( &lpNewImage, 0, &dwNewImageSize );

        if (dwOldImageSize<=16) {
            // Check if we are at the end and this is just padding
            BYTE bPad = (BYTE)Pad16((DWORD)(dwOriginalOldSize-dwOldImageSize));
            if (bPad==dwOldImageSize)
                dwOldImageSize = 0;
        }
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    return uiError;
}


static
UINT
GenerateDialog( LPVOID lpNewBuf, LONG dwNewSize,
                LPVOID lpNewI, DWORD* pdwNewImageSize )
{
    // Should be almost impossible for a Dialog to be Huge
    UINT uiError = ERROR_NO_ERROR;

    BYTE far * lpNewImage = (BYTE far *) lpNewI;
    LONG dwNewImageSize = *pdwNewImageSize;

    BYTE far * lpBuf = (BYTE far *) lpNewBuf;
    LPRESITEM lpResItem = LPNULL;

    LONG dwOverAllSize = 0L;

    BYTE    bIdCount = 0;

    // Dialog Elements
    DWORD   dwStyle = 0L;
    BYTE    bNumOfElem = 0;
    WORD    wX = 0;
    WORD    wY = 0;
    WORD    wcX = 0;
    WORD    wcY = 0;
    WORD    wId = 0;
    char    szClassName[128];
    BYTE    bClassName='\0', bControlClassName='\0';
    char    szCaption[128];
    WORD    wPointSize = 0;
    char    szFaceName[128];
    WORD    wPos = 1;

    // Get the infrmation from the updated resource
    if ( dwNewSize ) {
        lpResItem = (LPRESITEM) lpBuf;
        wX = lpResItem->wX;
        wY = lpResItem->wY;
        wcX = lpResItem->wcX;
        wcY = lpResItem->wcY;
        wId = LOWORD(lpResItem->dwItemID);
        wPointSize = lpResItem->wPointSize;
        dwStyle = lpResItem->dwStyle;
        bClassName = LOBYTE(lpResItem->wClassName);
        strcpy( szCaption, lpResItem->lpszCaption );
        strcpy( szClassName, lpResItem->lpszClassName );
        strcpy( szFaceName, lpResItem->lpszFaceName );
        lpBuf += lpResItem->dwSize;
        dwNewSize -= lpResItem->dwSize;
    }

    // Write the header informations
    dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );

    // Store the position of the numofelem for a later fixup
    BYTE far * lpNumOfElem = lpNewImage;
    dwOverAllSize += PutByte( &lpNewImage, bNumOfElem, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
    dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
    dwOverAllSize += PutNameOrOrd( &lpNewImage, 0, "", &dwNewImageSize );
    dwOverAllSize += PutClassName( &lpNewImage, bClassName, &szClassName[0], &dwNewImageSize );
    dwOverAllSize += PutCaptionOrOrd( &lpNewImage, 0, &szCaption[0], &dwNewImageSize,
                                      bClassName, dwStyle );
    if ( dwStyle & DS_SETFONT ) {
        dwOverAllSize += PutWord( &lpNewImage, wPointSize, &dwNewImageSize );
        dwOverAllSize += PutString( &lpNewImage, &szFaceName[0], &dwNewImageSize );
    }

    while ( dwNewSize>0 ) {
        bNumOfElem++;

        if ( dwNewSize ) {
            /*
            TRACE1("\t\tGenerateDialog:\tdwNewSize=%ld\n",(LONG)dwNewSize);
            TRACE1("\t\t\t\tlpszCaption=%Fs\n",lpResItem->lpszCaption);
            */
            lpResItem = (LPRESITEM) lpBuf;
            wX = lpResItem->wX;
            wY = lpResItem->wY;
            wcX = lpResItem->wcX;
            wcY = lpResItem->wcY;
            wId = LOWORD(lpResItem->dwItemID);
            dwStyle = lpResItem->dwStyle;
            bClassName = LOBYTE(lpResItem->wClassName);
            strcpy( szCaption, lpResItem->lpszCaption );
            strcpy( szClassName, lpResItem->lpszClassName );
            lpBuf += lpResItem->dwSize;
            dwNewSize -= lpResItem->dwSize;
        }

        //write the control
        dwOverAllSize += PutWord( &lpNewImage, wX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcX, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wcY, &dwNewImageSize );
        dwOverAllSize += PutWord( &lpNewImage, wId, &dwNewImageSize );
        dwOverAllSize += PutDWord( &lpNewImage, dwStyle, &dwNewImageSize );
        dwOverAllSize += PutControlClassName( &lpNewImage, bControlClassName, &szClassName[0], &dwNewImageSize );
        dwOverAllSize += PutCaptionOrOrd( &lpNewImage, 0, &szCaption[0], &dwNewImageSize,
                                          bControlClassName, dwStyle );
        dwOverAllSize += PutByte( &lpNewImage, 0, &dwNewImageSize );
    }

    if (dwOverAllSize>(LONG)*pdwNewImageSize) {
        // calc the padding as well
        dwOverAllSize += (BYTE)Pad4((DWORD)(dwOverAllSize));
        *pdwNewImageSize = dwOverAllSize;
        return uiError;
    }

    *pdwNewImageSize = *pdwNewImageSize-dwNewImageSize;

    if (*pdwNewImageSize>0) {
        // calculate padding
        BYTE bPad = (BYTE)Pad4((DWORD)(*pdwNewImageSize));
        if (bPad>dwNewImageSize) {
            *pdwNewImageSize += bPad;
            return uiError;
        }
        memset(lpNewImage, 0x00, bPad);
        *pdwNewImageSize += bPad;
    }

    // fixup the number of items
    PutByte( &lpNumOfElem, bNumOfElem, &dwNewImageSize );

    return uiError;
}


static
BYTE
SkipByte( BYTE far * far * lplpBuf, UINT uiSkip, LONG* pdwSize )
{
    if (*pdwSize>=(int)uiSkip) {
        *lplpBuf += uiSkip;;
        *pdwSize -= uiSkip;
    }
    return (BYTE)uiSkip;
}

static
BYTE
PutDWord( BYTE far * far* lplpBuf, DWORD dwValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofDWord && (*pdwSize != -1)) {
        memcpy(*lplpBuf, &dwValue, sizeofDWord);
        *lplpBuf += sizeofDWord;
        *pdwSize -= sizeofDWord;
    } else *pdwSize = -1;
    return sizeofDWord;
}

static
BYTE
GetDWord( BYTE far * far* lplpBuf, DWORD* dwValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofDWord) {
        memcpy( dwValue, *lplpBuf, sizeofDWord);
        *lplpBuf += sizeofDWord;
        *pdwSize -= sizeofDWord;
    }
    return sizeofDWord;
}

static
BYTE
PutWord( BYTE far * far* lplpBuf, WORD wValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofWord && (*pdwSize != -1)) {
        memcpy(*lplpBuf, &wValue, sizeofWord);
        *lplpBuf += sizeofWord;
        *pdwSize -= sizeofWord;
    } else *pdwSize = -1;
    return sizeofWord;
}

static
BYTE
GetWord( BYTE far * far* lplpBuf, WORD* wValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofWord) {
        memcpy( wValue, *lplpBuf, sizeofWord);
        *lplpBuf += sizeofWord;
        *pdwSize -= sizeofWord;
    }
    return sizeofWord;
}

static
BYTE
PutByte( BYTE far * far* lplpBuf, BYTE bValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofByte && (*pdwSize != -1)) {
        memcpy(*lplpBuf, &bValue, sizeofByte);
        *lplpBuf += sizeofByte;
        *pdwSize -= sizeofByte;
    } else *pdwSize = -1;
    return sizeofByte;
}

static
BYTE
GetByte( BYTE far * far* lplpBuf, BYTE* bValue, LONG* pdwSize )
{
    if (*pdwSize>=sizeofByte) {
        memcpy(bValue, *lplpBuf, sizeofByte);
        *lplpBuf += sizeofByte;
        *pdwSize -= sizeofByte;
    }
    return sizeofByte;
}

static
UINT
GetCaptionOrOrd( BYTE far * far* lplpBuf,  WORD* wOrd, LPSTR lpszText, LONG* pdwSize,
                 BYTE bClass, DWORD dwStyle )
{
    UINT uiSize = 0;

    // Icon might not have an ID so check first
    *wOrd = 0;
    // read the first BYTE to see if it is a string or an ordinal
    uiSize += GetByte( lplpBuf, (BYTE*)wOrd, pdwSize );
    if (LOBYTE(*wOrd)==0xFF) {
        // This is an Ordinal
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        *lpszText = '\0';
        uiSize = 3;
    } else {
        *lpszText++ = LOBYTE(*wOrd);
        if (LOBYTE(*wOrd))
            uiSize += GetString( lplpBuf, lpszText, pdwSize);
        *wOrd = 0;
    }
    return uiSize;
}

static
UINT
GetNameOrOrd( BYTE far * far* lplpBuf,  WORD* wOrd, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    *wOrd = 0;
    // read the first BYTE to see if it is a string or an ordinal
    uiSize += GetByte( lplpBuf, (BYTE*)wOrd, pdwSize );
    if (LOBYTE(*wOrd)==0xFF) {
        // This is an Ordinal
        uiSize += GetWord( lplpBuf, wOrd, pdwSize );
        *lpszText = '\0';
        uiSize = 3;
    } else {
        *lpszText++ = LOBYTE(*wOrd);
        if (LOBYTE(*wOrd))
            uiSize += GetString( lplpBuf, lpszText, pdwSize);
        *wOrd = 0;
    }
    return uiSize;
}

static
UINT
PutCaptionOrOrd( BYTE far * far* lplpBuf,  WORD wOrd, LPSTR lpszText, LONG* pdwSize,
                 BYTE bClass, DWORD dwStyle )
{
    UINT uiSize = 0;

    // If this is an ICON then can just be an ID
    if (wOrd) {
        uiSize += PutByte(lplpBuf, 0xFF, pdwSize);
        uiSize += PutWord(lplpBuf, wOrd, pdwSize);
    } else {
        uiSize += PutString(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


static
UINT
PutNameOrOrd( BYTE far * far* lplpBuf,  WORD wOrd, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if (wOrd) {
        uiSize += PutByte(lplpBuf, 0xFF, pdwSize);
        uiSize += PutWord(lplpBuf, wOrd, pdwSize);
    } else {
        uiSize += PutString(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


static
UINT
GetClassName( BYTE far * far* lplpBuf,  BYTE* bClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    *bClass = 0;
    // read the first BYTE to see if it is a string or an ordinal
    uiSize += GetByte( lplpBuf, bClass, pdwSize );

    if ( !(*bClass)) {
        // This is an Ordinal
        *lpszText = '\0';
    } else {
        *lpszText++ = *bClass;
        if (*bClass)
            uiSize += GetString( lplpBuf, lpszText, pdwSize);
        *bClass = 0;
    }
    return uiSize;
}

static
UINT
GetControlClassName( BYTE far * far* lplpBuf,  BYTE* bClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    *bClass = 0;
    // read the first BYTE to see if it is a string or an ordinal
    uiSize += GetByte( lplpBuf, bClass, pdwSize );

    if ( (*bClass) & 0x80) {
        // This is an Ordinal
        *lpszText = '\0';
    } else {
        *lpszText++ = *bClass;
        if (*bClass)
            uiSize += GetString( lplpBuf, lpszText, pdwSize);
        *bClass = 0;
    }
    return uiSize;
}

static
UINT
PutClassName( BYTE far * far* lplpBuf,  BYTE bClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if ( !(lpszText[0])) {
        // This is an Ordinal
        uiSize += PutByte(lplpBuf, bClass, pdwSize);
    } else {
        uiSize += PutString(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}

static
UINT
PutControlClassName( BYTE far * far* lplpBuf,  BYTE bClass, LPSTR lpszText, LONG* pdwSize )
{
    UINT uiSize = 0;

    if ( bClass & 0x80) {
        // This is an Ordinal
        uiSize += PutByte(lplpBuf, bClass, pdwSize);
    } else {
        uiSize += PutString(lplpBuf, lpszText, pdwSize);
    }
    return uiSize;
}


static
UINT
PutString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize )
{
    int iSize = strlen(lpszText)+1;
    if (*pdwSize>=iSize && (*pdwSize != -1)) {
        memcpy(*lplpBuf, lpszText, iSize);
        *lplpBuf += iSize;
        *pdwSize -= iSize;
    } else *pdwSize = -1;
    return iSize;
}

static
UINT
PutPascalString( BYTE far * far* lplpBuf, LPSTR lpszText, BYTE bLen, LONG* pdwSize )
{
    BYTE bSize = PutByte( lplpBuf, bLen, pdwSize );
    if (*pdwSize>=bLen && (*pdwSize != -1)) {
        memcpy(*lplpBuf, lpszText, bLen);
        *lplpBuf += bLen;
        *pdwSize -= bLen;
    } else *pdwSize = -1;
    return bSize+bLen;
}


static
UINT
GetString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize )
{
    int iSize = strlen((char*)*lplpBuf)+1;
    if (*pdwSize>=iSize) {
        memcpy( lpszText, *lplpBuf, iSize);
        *lplpBuf += iSize;
        *pdwSize -= iSize;
    } else {
        *lplpBuf = '\0';
        *lpszText = '\0';
    }
    return iSize;
}

static
int
GetVSString( BYTE far * far* lplpBuf, LPSTR lpszText, LONG* pdwSize, int cMaxLen )
{
    // We have to stop at Maxlen to avoid read too much.
    // This is to fix a bug where some string that are supposed to be NULL
    // terminated are not.
    int iSize = strlen((char*)*lplpBuf)+1;
    if (iSize>cMaxLen)
        iSize = cMaxLen;
    if (*pdwSize>=iSize) {
        memcpy( lpszText, *lplpBuf, iSize);
        *lplpBuf += iSize;
        *pdwSize -= iSize;
    } else *lplpBuf = '\0';
    *(lpszText+iSize) = '\0';
    return iSize;
}

static
UINT
CopyText( BYTE far * far * lplpTgt, BYTE far * far * lplpSrc, LONG* pdwTgtSize, LONG* pdwSrcSize)
{
    if (!*lplpSrc) return 1;
    int uiStrlen = strlen((char*)*lplpSrc)+1;
    TRACE("Len: %d\tTgtSize: %ld\tImageSize: %ld", uiStrlen, *pdwTgtSize, *pdwSrcSize);
    if (uiStrlen>*pdwTgtSize) {
        TRACE("\n");
        *pdwTgtSize = -1;
        return uiStrlen;
    } else {
        strcpy( (char*)*lplpTgt, (char*)*lplpSrc);
        TRACE1("\tCaption: %Fs\n", (char*)*lplpTgt);
        if (*pdwSrcSize>=uiStrlen) {
            *lplpSrc += uiStrlen;
            *pdwSrcSize -= uiStrlen;
        }
        *lplpTgt += uiStrlen;
        *pdwTgtSize -= uiStrlen;
        return uiStrlen;
    }
}

static LPRESITEM
GetItem( BYTE far * lpBuf, LONG dwNewSize, LPSTR lpStr )
{
    LPRESITEM lpResItem = (LPRESITEM) lpBuf;

    while (strcmp(lpResItem->lpszClassName, lpStr)) {
        lpBuf += lpResItem->dwSize;
        dwNewSize -= lpResItem->dwSize;
        if (dwNewSize<=0)
            return LPNULL;
        lpResItem = (LPRESITEM) lpBuf;
    }
    return lpResItem;
}

static DWORD CalcID( WORD wId, BOOL bFlag )
{
    // We want to calculate the ID Relative to the WORD wId
    // If we have any other ID with the same value then we return
    // the incremental number + the value.
    // If no other Item have been found then the incremental number will be 0.
    // If bFlag = TRUE then the id get added to the present list.
    // If bFlag = FALSE then the list is reseted and the function return

    // Clean the array if needed
    if (!bFlag) {
        wIDArray.RemoveAll();
        return 0;
    }

    // Add the value to the array
    wIDArray.Add(wId);

    // Walk the array to get the number of duplicated ID
    short c = -1; // will be 0 based
    for (short i=(short)wIDArray.GetUpperBound(); i>=0 ; i-- ) {
        if (wIDArray.GetAt(i)==wId)
            c++;
    }
    TRACE3("CalcID: ID: %hd\tPos: %hd\tFinal: %lx\n", wId, c, MAKELONG( wId, c ));
    return MAKELONG( wId, c );
}

static LONG Allign( BYTE** lplpBuf, LONG* plBufSize, LONG lSize )
{
    LONG lRet = 0;
    BYTE bPad = (BYTE)Pad4(lSize);
    lRet = bPad;
    if (bPad && *plBufSize>=bPad) {
        while (bPad && *plBufSize) {
            **lplpBuf = 0x00;
            *lplpBuf += 1;
            *plBufSize -= 1;
            bPad--;
        }
    }
    return lRet;
}

static void ChangeLanguage( LPVOID lpBuffer, UINT uiBuffSize )
{
    BYTE * pBuf = (BYTE*)lpBuffer;
    LONG lSize = 0;

    while (uiBuffSize) {
        // Skip
        lSize += SkipByte( &pBuf, 2, (LONG*)&uiBuffSize );
        lSize += SkipByte( &pBuf, strlen((LPCSTR)pBuf)+1, (LONG*)&uiBuffSize );
        lSize += SkipByte( &pBuf, Pad4(lSize), (LONG*)&uiBuffSize );

        lSize += SkipByte( &pBuf, 2, (LONG*)&uiBuffSize );
        lSize += SkipByte( &pBuf, strlen((LPCSTR)pBuf)+1, (LONG*)&uiBuffSize );
        lSize += SkipByte( &pBuf, Pad4(lSize), (LONG*)&uiBuffSize );

        lSize += PutDWord( &pBuf, gLang, (LONG*)&uiBuffSize );

        lSize += SkipByte( &pBuf, 4, (LONG*)&uiBuffSize );

        lSize += SkipByte( &pBuf, 4, (LONG*)&uiBuffSize );
    }


}

////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation

////////////////////////////////////////////////////////////////////////////
// This function should be used verbatim.  Any initialization or termination
// requirements should be handled in InitPackage() and ExitPackage().
//
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        // NOTE: global/static constructors have already been called!
        // Extension DLL one-time initialization - do not allocate memory
        // here, use the TRACE or ASSERT macros or call MessageBox
        AfxInitExtensionModule(extensionDLL, hInstance);
    } else if (dwReason == DLL_PROCESS_DETACH) {
        // Terminate the library before destructors are called
        AfxWinTerm();
    }

    if (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)
        return 0;       // CRT term	Failed

    return 1;   // ok
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\checksum.h ===
/*++ BUILD Version: 0001     Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    imagehlp.h

Abstract:

    This module defines the prptotypes and constants required for the image
    help routines.

Revision History:

--*/

#ifndef _IMAGEHLP_
#define _IMAGEHLP_

DWORD MapFileAndFixCheckSumA( LPSTR Filename);
DWORD MapFileAndFixCheckSumW( PWSTR Filename);

#ifdef UNICODE
#define MapFileAndFixCheckSum MapFileAndFixCheckSumW
#else
#define MapFileAndFixCheckSum MapFileAndFixCheckSumA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\win16\newexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERESWDS]; /* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    unsigned short int  ne_magic;       /* Magic number NE_MAGIC */
    char                ne_ver;         /* Version number */
    char                ne_rev;         /* Revision number */
    unsigned short int  ne_enttab;      /* Offset of Entry Table */
    unsigned short int  ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short int  ne_flags;       /* Flag word */
    unsigned short int  ne_autodata;    /* Automatic data segment number */
    unsigned short int  ne_heap;        /* Initial heap allocation */
    unsigned short int  ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short int  ne_cseg;        /* Count of file segments */
    unsigned short int  ne_cmod;        /* Entries in Module Reference Table */
    unsigned short int  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short int  ne_segtab;      /* Offset of Segment Table */
    unsigned short int  ne_rsrctab;     /* Offset of Resource Table */
    unsigned short int  ne_restab;      /* Offset of resident name table */
    unsigned short int  ne_modtab;      /* Offset of Module Reference Table */
    unsigned short int  ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short int  ne_cmovent;     /* Count of movable entries */
    unsigned short int  ne_align;       /* Segment alignment shift count */
    unsigned short int  ne_cres;        /* Count of resource segments */

#ifdef NEVER
    unsigned short int  ne_psegcsum;    /* offset to segment chksums */
#else
    unsigned char	ne_exetyp;	/* Target Operating system */
    unsigned char	ne_flagsothers;	/* Other .EXE flags */
#endif
    unsigned short int  ne_pretthunks;  /* offset to return thunks */
    unsigned short int  ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int  ne_swaparea;    /* Minimum code swap area size */
    unsigned short int  ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res
#define NE_EXETYPE(x)	(x).ne_exetyp

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   c                                  Non-conforming
 *    e                                 Errors in image
 *     xxxxxxxxx                        Unused
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
    unsigned short      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    char                nr_stype;       /* Source type */
    char                nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            char        nr_segno;       /* Target segment number */
            char        nr_res;         /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define OSFIXUP 	0x03		/* Floating point fixup */


/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;            /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004	/* True if handler proc return handle */

#define RNCOMPR     0x0200	/* Resource is compressed in ROM */

/* Resource table */
struct new_rsrc
    {
    unsigned short int rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

/* Target operating systems:  Possible values of ne_exetyp field */

#define NE_UNKNOWN	0	/* Unknown (any "new-format" OS) */
#define NE_OS2		1	/* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS	2	/* Microsoft Windows		 */
#define NE_DOS4 	3	/* Microsoft MS-DOS 4.x		 */
#define NE_DEV386	4	/* Microsoft Windows 386	 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\win32\checkfix.cpp ===
#include <afxwin.h>

#include "imagehlp.h"
#include "iodll.h"

//... PROTOTYPES

static PIMAGE_NT_HEADERS MyRtlImageNtHeader(
    PVOID pBaseAddress);

static BOOL MyUpdateDebugInfoFileEx(
    LPSTR ImageFileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath,
    PIMAGE_NT_HEADERS NtHeaders,
    DWORD OldCheckSum
    );

//...........................................................................


DWORD QuitA( DWORD err, LPCSTR, LPSTR )
{
    return err;
}

DWORD FixCheckSum( LPCSTR ImageName, LPCSTR OrigFileName, LPCSTR SymbolPath)
{
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID BaseAddress;
    ULONG CheckSum;
    ULONG FileLength;
    ULONG HeaderSum;
    ULONG OldCheckSum;
    DWORD iErr = ERROR_NO_ERROR;


    FileHandle = CreateFileA( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);

    if ( FileHandle == INVALID_HANDLE_VALUE )
    {
        QuitA( 1, ImageName, NULL);
    }

    MappingHandle = CreateFileMapping( FileHandle,
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       0,
                                       NULL);

    if ( MappingHandle == NULL )
    {
        CloseHandle( FileHandle );
        QuitA( 22, ImageName, NULL);
    }
    else
    {
        BaseAddress = MapViewOfFile( MappingHandle,
                                     FILE_MAP_READ | FILE_MAP_WRITE,
                                     0,
                                     0,
                                     0);
        CloseHandle( MappingHandle );

        if ( BaseAddress == NULL )
        {
            CloseHandle( FileHandle );
            QuitA( 23, ImageName, NULL);
        }
        else
        {
            //
            // Get the length of the file in bytes and compute the checksum.
            //

            FileLength = GetFileSize( FileHandle, NULL );

            //
            // Obtain a pointer to the header information.
            //

            NtHeaders = MyRtlImageNtHeader( BaseAddress);

            if ( NtHeaders == NULL )
            {
                CloseHandle( FileHandle );
                UnmapViewOfFile( BaseAddress );
                QuitA( 17, ImageName, NULL);
            }
            else
            {
                //
                // Recompute and reset the checksum of the modified file.
                //

                OldCheckSum = NtHeaders->OptionalHeader.CheckSum;

                (VOID) CheckSumMappedFile( BaseAddress,
                                           FileLength,
                                           &HeaderSum,
                                           &CheckSum);

                NtHeaders->OptionalHeader.CheckSum = CheckSum;

                if (SymbolPath && *SymbolPath)
                {
                    TCHAR DebugFilePath[MAX_PATH];

                    SetLastError(0);
                    MyUpdateDebugInfoFileEx((LPSTR)OrigFileName,
                                                (LPSTR)SymbolPath,
                                                DebugFilePath,
                                                NtHeaders,
                                                OldCheckSum);

                        iErr = GetLastError();
                        switch(iErr)
                        {
                            case ERROR_INVALID_DATA:
                                iErr = ERROR_IO_CHECKSUM_MISMATCH;
                                break;
                            case ERROR_FILE_NOT_FOUND:
                                iErr = ERROR_IO_SYMBOLFILE_NOT_FOUND;
                                break;
                            case ERROR_NO_ERROR:
                                break;
                            default:
                                iErr += LAST_ERROR;
                        }

                }

                if ( ! FlushViewOfFile( BaseAddress, FileLength) )
                {
                    QuitA( 24, ImageName, NULL);
                }

                if ( NtHeaders->OptionalHeader.CheckSum != OldCheckSum )
                {
                    if ( ! TouchFileTimes( FileHandle, NULL) )
                    {
                        QuitA( 25, ImageName, NULL);
                    }
                }
                UnmapViewOfFile( BaseAddress );
                CloseHandle( FileHandle );
            }
        }
    }
    return( iErr);
}

//.........................................................................

static PIMAGE_NT_HEADERS MyRtlImageNtHeader( PVOID pBaseAddress)
{
    IMAGE_DOS_HEADER *pDosHeader = (IMAGE_DOS_HEADER *)pBaseAddress;

    return( pDosHeader->e_magic == IMAGE_DOS_SIGNATURE
            ? (PIMAGE_NT_HEADERS)(((PBYTE)pBaseAddress) + pDosHeader->e_lfanew)
            : NULL);
}

BOOL
MyUpdateDebugInfoFileEx(
    LPSTR ImageFileName,
    LPSTR SymbolPath,
    LPSTR DebugFilePath,
    PIMAGE_NT_HEADERS NtHeaders,
    DWORD OldCheckSum
    )
{
    // UnSafe...

    HANDLE hDebugFile, hMappedFile;
    PVOID MappedAddress;
    PIMAGE_SEPARATE_DEBUG_HEADER DbgFileHeader;
    BOOL bRet;

    hDebugFile = FindDebugInfoFile(
                    ImageFileName,
                    SymbolPath,
                    DebugFilePath
                    );
    if ( hDebugFile == NULL ) {
        return FALSE;
    }
    CloseHandle(hDebugFile);

    hDebugFile = CreateFile( DebugFilePath,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_DELETE | FILE_SHARE_READ
                                | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL
                           );
    if ( hDebugFile == INVALID_HANDLE_VALUE ) {
        return FALSE;
    }

    hMappedFile = CreateFileMapping(
                    hDebugFile,
                    NULL,
                    PAGE_READWRITE,
                    0,
                    0,
                    NULL
                    );
    if ( !hMappedFile ) {
        CloseHandle(hDebugFile);
        return FALSE;
    }

    MappedAddress = MapViewOfFile(hMappedFile,
                        FILE_MAP_WRITE,
                        0,
                        0,
                        0
                        );
    CloseHandle(hMappedFile);
    if ( !MappedAddress ) {
        CloseHandle(hDebugFile);
        return FALSE;
    }

    DbgFileHeader = (PIMAGE_SEPARATE_DEBUG_HEADER)MappedAddress;
    if (DbgFileHeader->ImageBase != NtHeaders->OptionalHeader.ImageBase ||
        DbgFileHeader->CheckSum != NtHeaders->OptionalHeader.CheckSum
       ) {
        if (OldCheckSum != DbgFileHeader->CheckSum) {
            DbgFileHeader->Flags |= IMAGE_SEPARATE_DEBUG_MISMATCH;
            SetLastError(ERROR_INVALID_DATA);
        } else {
            SetLastError(ERROR_SUCCESS);
        }
        DbgFileHeader->ImageBase = (DWORD) NtHeaders->OptionalHeader.ImageBase;
        DbgFileHeader->CheckSum = NtHeaders->OptionalHeader.CheckSum;
        DbgFileHeader->TimeDateStamp = NtHeaders->FileHeader.TimeDateStamp;
        bRet = TRUE;
    }
    else
    {
        bRet =  FALSE;
    }

    if (bRet)
        TouchFileTimes(hDebugFile,NULL);

    UnmapViewOfFile(MappedAddress);
    CloseHandle(hDebugFile);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\checksum.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    checksum.c

Abstract:

    This module implements a function for computing the checksum of an
    image file. It will also compute the checksum of other files as well.

Author:

    David N. Cutler 21-Mar-1993

Revision History:

--*/

#include <windows.h>
#include "checksum.h"
#include "rlmsgtbl.h"

void QuitA( int, LPSTR,  LPSTR);
void QuitW( int, LPWSTR, LPWSTR);

// Helper routines

static PIMAGE_NT_HEADERS ImageNtHeader( PVOID Base);
static USHORT ChkSum( DWORD PartialSum,
    				  PUSHORT Source,
    				  DWORD Length);

static PIMAGE_NT_HEADERS
CheckSumMappedFile (
    LPVOID pBaseAddress,
    DWORD  dwFileLength,
    LPDWORD pdwHeaderSum,
    LPDWORD pdwCheckSum
    );

static BOOL
TouchFileTimes (
    HANDLE hFileHandle,
    LPSYSTEMTIME lpSystemTime
    );



/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

static PIMAGE_NT_HEADERS ImageNtHeader( PVOID pBase)
{
    PIMAGE_NT_HEADERS pNtHeaders = NULL;

    if ( pBase != NULL && pBase != (PVOID)-1 ) 
    {
        if ( ((PIMAGE_DOS_HEADER)pBase)->e_magic == IMAGE_DOS_SIGNATURE ) 
        {
            pNtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)pBase + ((PIMAGE_DOS_HEADER)pBase)->e_lfanew);

            if ( pNtHeaders->Signature != IMAGE_NT_SIGNATURE ) 
            {
                pNtHeaders = NULL;
            }
        }
    }
    return( pNtHeaders);
}


/*++

Routine Description:

    Compute a partial checksum on a portion of an imagefile.

Arguments:

    PartialSum - Supplies the initial checksum value.

    Sources - Supplies a pointer to the array of words for which the
        checksum is computed.

    Length - Supplies the length of the array in words.

Return Value:

    The computed checksum value is returned as the function value.

--*/

static USHORT ChkSum(

ULONG   PartialSum,
PUSHORT Source,
ULONG   Length)
{

    //
    // Compute the word wise checksum allowing carries to occur into the
    // high order half of the checksum longword.
    //

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xffff);
    }

    //
    // Fold final carry into a single word result and return the resultant
    // value.
    //

    return (USHORT)(((PartialSum >> 16) + PartialSum) & 0xffff);
}


/*++

Routine Description:

    This functions computes the checksum of a mapped file.

Arguments:

    BaseAddress - Supplies a pointer to the base of the mapped file.

    FileLength - Supplies the length of the file in bytes.

    HeaderSum - Suppllies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    None.

--*/


static PIMAGE_NT_HEADERS CheckSumMappedFile(

LPVOID  pBaseAddress,
DWORD   dwFileLength,
LPDWORD pdwHeaderSum,
LPDWORD pdwCheckSum)
{
    USHORT  usPartialSum;
    PUSHORT pusAdjustSum;
    PIMAGE_NT_HEADERS pNtHeaders = NULL;

    //
    // Compute the checksum of the file and zero the header checksum value.
    //

    *pdwHeaderSum = 0;
    usPartialSum = ChkSum(0, (PUSHORT)pBaseAddress, (dwFileLength + 1) >> 1);

    //
    // If the file is an image file, then subtract the two checksum words
    // in the optional header from the computed checksum before adding
    // the file length, and set the value of the header checksum.
    //

	pNtHeaders = ImageNtHeader( pBaseAddress);

    if ( (pNtHeaders != NULL) && (pNtHeaders != pBaseAddress) ) 
    {
        *pdwHeaderSum = pNtHeaders->OptionalHeader.CheckSum;
        pusAdjustSum  = (PUSHORT)(&pNtHeaders->OptionalHeader.CheckSum);
        usPartialSum -= (usPartialSum < pusAdjustSum[0]);
        usPartialSum -= pusAdjustSum[0];
        usPartialSum -= (usPartialSum < pusAdjustSum[1]);
        usPartialSum -= pusAdjustSum[1];
    }

    //
    // Compute the final checksum value as the sum of the paritial checksum
    // and the file length.
    //

    *pdwCheckSum = (DWORD)usPartialSum + dwFileLength;
    return( pNtHeaders);
}

/*++

Routine Description:

    This functions maps the specified file and computes the checksum of
    the file.

Arguments:

    Filename - Supplies a pointer to the name of the file whose checksum
        is computed.

    HeaderSum - Supplies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    0 if successful, else error number.

--*/


DWORD MapFileAndFixCheckSumW( PWSTR pszwFilename)
{
    HANDLE hFileHandle    = NULL;
    HANDLE hMappingHandle = NULL;
    LPVOID pBaseAddress   = NULL;
    DWORD  dwFileLength   = 0;
	DWORD  dwHeaderSum    = 0;
	DWORD  dwCheckSum     = 0;
	DWORD  dwOldCheckSum  = 0;
    PIMAGE_NT_HEADERS pNtHeaders = NULL;

    //
    // Open the file for read access
    //

    hFileHandle = CreateFileW( pszwFilename,
                         	   GENERIC_READ | GENERIC_WRITE,
                         	   FILE_SHARE_READ | FILE_SHARE_WRITE,
                         	   NULL,
                         	   OPEN_EXISTING,
                         	   FILE_ATTRIBUTE_NORMAL,
                        	   NULL);

    if ( hFileHandle == INVALID_HANDLE_VALUE ) 
    {
        QuitW( IDS_ENGERR_01, L"image", pszwFilename);
    }

    //
    //  Create a file mapping, map a view of the file into memory,
    //  and close the file mapping handle.
    //

    hMappingHandle = CreateFileMapping( hFileHandle,
                                        NULL,
                                        PAGE_READWRITE,
                                        0,
                                        0,
                                        NULL);

    if ( hMappingHandle == NULL ) 
    {
        CloseHandle( hFileHandle );
        QuitW( IDS_ENGERR_22, pszwFilename, NULL);
    }

    //
    // Map a view of the file
    //

    pBaseAddress = MapViewOfFile( hMappingHandle, 
                                  FILE_MAP_READ | FILE_MAP_WRITE, 
                                  0, 
                                  0, 
                                  0);
    CloseHandle( hMappingHandle);

    if ( pBaseAddress == NULL ) 
    {
        CloseHandle( hFileHandle );
        QuitW( IDS_ENGERR_23, pszwFilename, NULL);
    }

    //
    // Get the length of the file in bytes and compute the checksum.
    //
    dwFileLength = GetFileSize( hFileHandle, NULL );
    pNtHeaders   = CheckSumMappedFile( pBaseAddress, dwFileLength, &dwHeaderSum, &dwCheckSum);

    if ( pNtHeaders == NULL )
    {
        CloseHandle( hFileHandle );
        UnmapViewOfFile( pBaseAddress );
        QuitW( IDS_ENGERR_17, pszwFilename, NULL);
    }

    dwOldCheckSum = pNtHeaders->OptionalHeader.CheckSum;

    pNtHeaders->OptionalHeader.CheckSum = dwCheckSum;
        
    if ( ! FlushViewOfFile( pBaseAddress, dwFileLength) )
    {
        UnmapViewOfFile( pBaseAddress);
        CloseHandle( hFileHandle);
        QuitW( IDS_ENGERR_24, pszwFilename, NULL);
    }    
    UnmapViewOfFile( pBaseAddress);

    if ( dwCheckSum != dwOldCheckSum )
    {
        if ( ! TouchFileTimes( hFileHandle, NULL) )
        {
            CloseHandle( hFileHandle);
            QuitW( IDS_ENGERR_25, pszwFilename, NULL);
        }
    }

    CloseHandle( hFileHandle);
    return( 0);
}


/*++

Routine Description:

    This functions maps the specified file and computes the checksum of
    the file.

Arguments:

    Filename - Supplies a pointer to the name of the file whose checksum
        is computed.

    HeaderSum - Supplies a pointer to a variable that receives the checksum
        from the image file, or zero if the file is not an image file.

    CheckSum - Supplies a pointer to the variable that receive the computed
        checksum.

Return Value:

    0 if successful, else error number.

--*/


ULONG MapFileAndFixCheckSumA( LPSTR pszFilename)
{
    WCHAR   szFileNameW[ MAX_PATH ];

    //
    //  Convert the file name to unicode and call the unicode version
    //  of this function.
    //

    if ( MultiByteToWideChar( CP_ACP,
                    		  MB_PRECOMPOSED,
                    		  pszFilename,
                    		  -1,
                    		  szFileNameW,
                    		  MAX_PATH) ) 
    {
        return( MapFileAndFixCheckSumW( szFileNameW));
    }
    return( (ULONG)-1L);
}

//.........................................

static BOOL TouchFileTimes(

HANDLE       FileHandle,
LPSYSTEMTIME lpSystemTime)
{
    SYSTEMTIME SystemTime;
    FILETIME SystemFileTime;

    if ( lpSystemTime == NULL ) 
    {
        lpSystemTime = &SystemTime;
        GetSystemTime( lpSystemTime );
    }

    if ( SystemTimeToFileTime( lpSystemTime, &SystemFileTime ) ) 
    {
        return( SetFileTime( FileHandle, NULL, NULL, &SystemFileTime ));
    }
    else 
    {
        return( FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\rw\win32\win32.cpp ===
//+---------------------------------------------------------------------------
//
//  File:       win32.cpp
//
//  Contents:   Implementation for the Windows 32 Read/Write module
//
//  Classes:    one
//
//  History:    05-Jul-93   alessanm    created
//
//----------------------------------------------------------------------------

#include <afxwin.h>
#include "..\common\rwdll.h"
#include "..\common\rw32hlpr.h"

#include <limits.h>
#include <malloc.h>

/////////////////////////////////////////////////////////////////////////////
// Initialization of MFC Extension DLL

#include "afxdllx.h"    // standard MFC Extension DLL routines

static AFX_EXTENSION_MODULE NEAR extensionDLL = { NULL, NULL };

/////////////////////////////////////////////////////////////////////////////
// Check sum function

DWORD FixCheckSum( LPCSTR ImageName, LPCSTR OrigFileName, LPCSTR SymbolPath );


/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define RWTAG "WIN32"

static RESSECTDATA ResSectData;
static ULONG gType;
static ULONG gLng;
static ULONG gResId;
static WCHAR gwszResId[256];
static WCHAR gwszTypeId[256];

/////////////////////////////////////////////////////////////////////////////
// Function Declarations
static LONG WriteResInfo(
                 LPLPBYTE lpBuf, LONG* uiBufSize,
                 WORD wTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
                 WORD wNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
                 DWORD dwLang,
                 DWORD dwSize, DWORD dwFileOffset );

static UINT GetUpdatedRes(
                 BYTE far * far* lplpBuffer,
                 UINT* uiSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwlang, DWORD* dwSize );

static UINT GetRes(
                 BYTE far * far* lplpBuffer,
                 UINT* puiBufSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwLang, DWORD* dwSize, DWORD* dwFileOffset );


static UINT FindResourceSection( CFile*, ULONG_PTR * );

static LONG ReadFile(CFile*, UCHAR *, LONG);
static UINT ParseDirectory( CFile*,
                            LPLPBYTE lpBuf, UINT* uiBufSize,
                            BYTE,
                            PIMAGE_RESOURCE_DIRECTORY,
                            PIMAGE_RESOURCE_DIRECTORY );

static UINT ParseDirectoryEntry( CFile*,
                                 LPLPBYTE lpBuf, UINT* uiBufSize,
                                 BYTE,
                                 PIMAGE_RESOURCE_DIRECTORY,
                                 PIMAGE_RESOURCE_DIRECTORY_ENTRY );

static UINT ParseSubDir( CFile*,
                         LPLPBYTE lpBuf, UINT* uiBufSize,
                         BYTE,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY_ENTRY );

static UINT ProcessData( CFile*,
                         LPLPBYTE lpBuf, UINT* uiBufSize,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DATA_ENTRY );


/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

//[registration]
extern "C"
BOOL    FAR PASCAL RWGetTypeString(LPSTR lpszTypeName)
{
    strcpy( lpszTypeName, RWTAG );
    return FALSE;
}

extern "C"
BOOL    FAR PASCAL RWValidateFileType   (LPCSTR lpszFilename)
{
    TRACE("WIN32.DLL: RWValidateFileType()\n");

    CFile file;

    // we Open the file to see if it is a file we can handle
    if (!file.Open( lpszFilename, CFile::typeBinary | CFile::modeRead | CFile::shareDenyNone))
        return FALSE;

    // Read the file signature
    WORD w;
    file.Read((WORD*)&w, sizeof(WORD));
    if (w==IMAGE_DOS_SIGNATURE) {
    file.Seek( 0x18, CFile::begin );
    file.Read((WORD*)&w, sizeof(WORD));
    if (w<0x0040) {
        // this is not a Windows Executable
            file.Close();
        return FALSE;
    }
    // get offset to header
    file.Seek( 0x3c, CFile::begin );
    file.Read((WORD*)&w, sizeof(WORD));
    // get windows magic word
        file.Seek( w, CFile::begin );
    file.Read((WORD*)&w, sizeof(WORD));
    if (w==LOWORD(IMAGE_NT_SIGNATURE)) {
        file.Read((WORD*)&w, sizeof(WORD));
        if (w==HIWORD(IMAGE_NT_SIGNATURE)) {
            // this is a Windows NT Executable
        // we can handle the situation
        file.Close();
        return TRUE;
            }
    }
    }
    file.Close();
    return FALSE;
}

extern "C"
DllExport
UINT
APIENTRY
RWReadTypeInfo(
    LPCSTR lpszFilename,
    LPVOID lpBuffer,
    UINT* puiSize

    )
{
    TRACE("WIN32.DLL: RWReadTypeInfo()\n");
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    UINT uiBufSize = *puiSize;
    CFile file;
    // check if it is  a valid win32 file
    if (!RWValidateFileType(lpszFilename))
        return ERROR_RW_INVALID_FILE;

    // Make sure we are using the right code page and global settings
    // Get the pointer to the function
	HINSTANCE hDllInst = LoadLibrary("iodll.dll");
    if (hDllInst)
    {
        UINT (FAR PASCAL * lpfnGetSettings)(LPSETTINGS);
        // Get the pointer to the function to get the settings
        lpfnGetSettings = (UINT (FAR PASCAL *)(LPSETTINGS))
                            GetProcAddress( hDllInst, "RSGetGlobals" );
        if (lpfnGetSettings!=NULL) {
            SETTINGS settings;
	        (*lpfnGetSettings)(&settings);

    	    g_cp      = settings.cp;
            g_bAppend = settings.bAppend;
            g_bUpdOtherResLang = settings.bUpdOtherResLang;
            strcpy( g_char, settings.szDefChar );
		}

        FreeLibrary(hDllInst);
    }


    // Parse the resource tree and extract the information
    // Open the file and try to read the information on the resource in it.
    if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return ERROR_FILE_OPEN;

    // we try to read as much information as we can
    // Because this is a res file we can read all the information we need.

    UINT uiBufStartSize = uiBufSize;


    UCHAR * pResources = LPNULL;
    uiError = FindResourceSection( &file, (ULONG_PTR *)&pResources );
    if (uiError) {
        file.Close();
        return uiError;
    }
    uiError = ParseDirectory( &file,
                              (LPLPBYTE) &lpBuffer, &uiBufSize,
                              0,
                              (PIMAGE_RESOURCE_DIRECTORY)pResources,
                              (PIMAGE_RESOURCE_DIRECTORY)pResources );

    free(pResources);

    file.Close();
    *puiSize = uiBufStartSize-uiBufSize;
    return uiError;
}

extern "C"
DllExport
DWORD
APIENTRY
RWGetImage(
    LPCSTR  lpszFilename,
    DWORD   dwImageOffset,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    DWORD dwBufSize = dwSize;
    // we can consider the use of a CMemFile so we get the same speed as memory access.
    CFile file;

    // Open the file and try to read the information on the resource in it.
    if (!file.Open(lpszFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return (DWORD)ERROR_FILE_OPEN;

    if ( dwImageOffset!=(DWORD)file.Seek( dwImageOffset, CFile::begin) )
        return (DWORD)ERROR_FILE_INVALID_OFFSET;
    if (dwSize>UINT_MAX) {
        // we have to read the image in different steps
        return (DWORD)0L;
    } else uiError = file.Read( lpBuf, (UINT)dwSize);
    file.Close();

    return (DWORD)uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWParseImageEx(
	LPCSTR  lpszType,
    LPCSTR  lpszResId,
	LPVOID  lpImageBuf,
	DWORD   dwImageSize,
	LPVOID  lpBuffer,
	DWORD   dwSize,
    LPCSTR  lpRCFilename
	)
{
    UINT uiError = ERROR_NO_ERROR;
    BYTE far * lpBuf = (BYTE far *)lpBuffer;
    DWORD dwBufSize = dwSize;

    // The Type we can parse are only the standard ones
    // This function should fill the lpBuffer with an array of ResItem structure
    if (HIWORD(lpszType))
    {
        if (strcmp(lpszType, "REGINST") ==0)
        {
            return (ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize ));
        }
    }
    switch ((UINT)LOWORD(lpszType)) {
        case 1:
        case 12:
        	uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
        case 2:
        case 14:
        	uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;

        case 3:
        	uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;

        case 4:
            uiError = ParseMenu( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;

        case 5:
            uiError = ParseDialog( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
        case 6:
            uiError = ParseString( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
        case 9:
            uiError = ParseAccel( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
        case 11:
            uiError = ParseMsgTbl( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;
        case 16:
            uiError = ParseVerst( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;

        case 23:
        case 240:
        case 2110:
        case 1024:
            uiError = ParseEmbeddedFile( lpImageBuf, dwImageSize,  lpBuffer, dwSize );
        break;

        case 7:
        case 8:
        case 13:
        case 15:
        break;
        //
        // To support RCDATA and user defined function we will call back the iodll,
        // get the file name and check if we have a DLL that will handle RCDATA.
        // We expect the DLL name to be RCfilename.dll.
        // This Dll will export a function called RWParseImageEx. This function will
        // be called by the RW to fill the buffer, all this without the iodll knowing.
        //
        case 10:
        default:
            //
            // Get the file name from the iodll
            //
            if(lpRCFilename && strcmp(lpRCFilename, ""))
            {
                // try to Load the dll
                HINSTANCE hRCDllInst = LoadLibrary(lpRCFilename);
                if (hRCDllInst)
                {
                    UINT (FAR PASCAL  * lpfnParseImageEx)(LPCSTR, LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPCSTR);

                    // Get the pointer to the function to extract the resources
                    lpfnParseImageEx = (UINT (FAR PASCAL *)(LPCSTR, LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPCSTR))
                                        GetProcAddress( hRCDllInst, "RWParseImageEx" );

                    if (lpfnParseImageEx)
                    {
                        uiError = (*lpfnParseImageEx)(lpszType,
                                     lpszResId,
                                     lpImageBuf,
                                     dwImageSize,
                                     lpBuffer,
                                     dwSize,
                                     NULL);
                    }

                    FreeLibrary(hRCDllInst);
                }
            }

        break;
    }

    return uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWParseImage(
    LPCSTR  lpszType,
    LPVOID  lpImageBuf,
    DWORD   dwImageSize,
    LPVOID  lpBuffer,
    DWORD   dwSize
    )
{
    //
    // Just a wrapper to be compatible...
    //
    return RWParseImageEx(lpszType, NULL, lpImageBuf, dwImageSize, lpBuffer, dwSize, NULL);
}

extern"C"
DllExport
UINT
APIENTRY
RWWriteFile(
    LPCSTR          lpszSrcFilename,
    LPCSTR          lpszTgtFilename,
    HANDLE          hResFileModule,
    LPVOID          lpBuffer,
    UINT            uiSize,
    HINSTANCE       hDllInst,
    LPCSTR          lpszSymbolPath
    )
{
    UINT uiError = ERROR_NO_ERROR;
    UINT uiBufSize = uiSize;
    CFile fileIn;
    CFile fileOut;
    BOOL  bfileIn = TRUE;


    // Open the file and try to read the information on the resource in it.
	CFileStatus status;
    if (CFile::GetStatus( lpszSrcFilename, status )) {
        // check if the size of the file is not null
        if (!status.m_size)
            CFile::Remove(lpszSrcFilename);
    }

    if (!fileIn.Open(lpszSrcFilename, CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone))
        return ERROR_FILE_OPEN;

    if (!fileOut.Open(lpszTgtFilename, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
        return ERROR_FILE_CREATE;

    // Create a copy of the US file
    uiError = CopyFile( &fileIn, &fileOut );

    fileIn.Close();
    fileOut.Close();

    // Get the pointer to the function
	hDllInst = LoadLibrary("iodll.dll");
    if (!hDllInst)
        return ERROR_DLL_LOAD;

    DWORD (FAR PASCAL * lpfnGetImage)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD);
    // Get the pointer to the function to extract the resources image
    lpfnGetImage = (DWORD (FAR PASCAL *)(HANDLE, LPCSTR, LPCSTR, DWORD, LPVOID, DWORD))
                        GetProcAddress( hDllInst, "RSGetResImage" );
    if (lpfnGetImage==NULL) {
        FreeLibrary(hDllInst);
        return (UINT)GetLastError()+LAST_ERROR;
    }

    // We read the resources from the file and then we check if the resource has been updated
    // or if we can just copy it

    WORD wTypeId;
    char szTypeId[128];

    WORD wNameId;
    char szNameId[128];

    DWORD dwSize;
    DWORD dwLang;

    WORD wUpdTypeId = 0;
    static char szUpdTypeId[128];

    WORD wUpdNameId;
    static char szUpdNameId[128];

    static WCHAR szwTypeId[128];
    static WCHAR szwNameId[128];

    DWORD dwUpdLang = 0;
    DWORD dwUpdSize = 0;

    UINT uiBufStartSize = uiBufSize;
    DWORD dwImageBufSize;
    DWORD dwLstErr = 0l;
    BYTE * lpImageBuf;
    static WCHAR szwTgtFilename[400];

    SetLastError(0);
    // Convert the Target file name to a unicode name
    _MBSTOWCS(szwTgtFilename, (char *)lpszTgtFilename, 400 );

    // Get the updated resource and replace them
    HANDLE hUpd = BeginUpdateResourceW( (LPCWSTR)&szwTgtFilename[0], !g_bAppend );
    dwLstErr = GetLastError();

    if (!hUpd) {
        FreeLibrary(hDllInst);
        return((UINT)dwLstErr);
    }

    // Parse the original file an get the list of resources

    UINT uiBSize = 100000;
    BYTE far * lpBuf = new far BYTE[uiBSize];
    BYTE far * lpStartBuf = lpBuf;
    if (!lpBuf) {
        FreeLibrary(hDllInst);
        return ERROR_NEW_FAILED;
    }

    uiError = RWReadTypeInfo( lpszSrcFilename, (LPVOID)lpBuf, &uiBSize );
    if (uiError!=ERROR_NO_ERROR) {
        FreeLibrary(hDllInst);
        delete lpBuf;
        return uiError;
    }

    DWORD dwDummy;

    while(uiBSize>0) {
        if (uiBSize)
            GetRes( &lpBuf,
                    &uiBSize,
                    &wTypeId, &szTypeId[0],
                    &wNameId, &szNameId[0],
                    &dwLang,
                    &dwSize,
                    &dwDummy
            );

        dwLang = MAKELONG(LOWORD(dwLang),LOWORD(dwLang));

        if ((!wUpdTypeId) && (uiBufSize))
            GetUpdatedRes( (BYTE**)&lpBuffer,
                    &uiBufSize,
                    &wUpdTypeId, &szUpdTypeId[0],
                    &wUpdNameId, &szUpdNameId[0],
                    &dwUpdLang,
                    &dwUpdSize
                    );

        // check if the resource has been updated or not
        if ( (wUpdTypeId==wTypeId) &&
             ( (CString)szUpdTypeId==(CString)szTypeId) &&
             (wUpdNameId==wNameId) &&
             ( (CString)szUpdNameId==(CString)szNameId) &&
             (LOWORD(dwLang) == LOWORD(dwUpdLang))
           ) {
             dwLang = dwUpdLang;
             dwSize = dwUpdSize;
             wUpdTypeId = 0;
        }


        // all resources of specific language need to be marked
        if (LOWORD(dwLang) == LOWORD(dwUpdLang) && g_bUpdOtherResLang)
        {
            dwLang = dwUpdLang;
        }


        // The resource has been updated get the image from the IODLL
        lpImageBuf = new BYTE[dwSize];

        // convert the Name to unicode
        LPWSTR  lpUpdType = LPNULL;
        LPWSTR  lpUpdRes = LPNULL;
        LPCSTR  lpType = LPNULL;
        LPCSTR  lpRes = LPNULL;

        if (wTypeId) {
            lpUpdType = (LPWSTR) MAKEINTRESOURCE((WORD)wTypeId);
            lpType = MAKEINTRESOURCE((WORD)wTypeId);
        } else {
            SetLastError(0);
            _MBSTOWCS(szwTypeId, szTypeId, 128 );
            // Check for error
            if(GetLastError()) {
                FreeLibrary(hDllInst);
                return ERROR_DLL_LOAD;
            }
            lpUpdType = (LPWSTR) &szwTypeId[0];
            lpType = &szTypeId[0];
        }

        if (wNameId) {
            lpUpdRes = (LPWSTR) MAKEINTRESOURCE((WORD)wNameId);
            lpRes = MAKEINTRESOURCE((WORD)wNameId);
        } else {
            SetLastError(0);
            _MBSTOWCS(szwNameId, szNameId, 128 );
            // Check for error
            if(GetLastError()) {
                FreeLibrary(hDllInst);
                return ERROR_DLL_LOAD;
            }
            lpUpdRes = (LPWSTR) &szwNameId[0];
            lpRes = &szNameId[0];
        }

        dwImageBufSize = (*lpfnGetImage)(  hResFileModule,
                                        lpType,
                                        lpRes,
                                        (DWORD)LOWORD(dwLang),
                                        lpImageBuf,
                                        dwSize
                                        );
        if (dwImageBufSize>dwSize ) {
            // The buffer is too small
            delete []lpImageBuf;
            lpImageBuf = new BYTE[dwImageBufSize];
            dwUpdSize = (*lpfnGetImage)(  hResFileModule,
                                            lpType,
                                            lpRes,
                                            (DWORD)LOWORD(dwLang),
                                            lpImageBuf,
                                            dwImageBufSize
                                           );
            if ((dwUpdSize-dwImageBufSize)!=0 ) {
                delete []lpImageBuf;
                lpImageBuf = LPNULL;
            }
        }else if (dwImageBufSize==0){
             delete []lpImageBuf;
             lpImageBuf = LPNULL;
        }

        SetLastError(0);

        TRACE1("\t\tUpdateResourceW: %d\n", (WORD)dwUpdLang);

        if(!UpdateResourceW( hUpd,
                             lpUpdType,
                             lpUpdRes,
                             HIWORD(dwLang),
                             (LPVOID)lpImageBuf,
                             dwImageBufSize ))
        {
            dwLstErr = GetLastError();
        }

        if (lpImageBuf) delete []lpImageBuf;
    }

    SetLastError(0);
    EndUpdateResourceW( hUpd, FALSE );

    dwLstErr = GetLastError();

    if (dwLstErr)
        dwLstErr +=LAST_ERROR;

    // Fix the check sum
    DWORD error;
    if(error = FixCheckSum(lpszTgtFilename,lpszSrcFilename, lpszSymbolPath))
        dwLstErr = error;

    delete lpStartBuf;
	FreeLibrary(hDllInst);

    return (UINT)dwLstErr;
}

extern "C"
DllExport
UINT
APIENTRY
RWUpdateImageEx(
    LPCSTR  lpszType,
    LPVOID  lpNewBuf,
    DWORD   dwNewSize,
    LPVOID  lpOldImage,
    DWORD   dwOldImageSize,
    LPVOID  lpNewImage,
    DWORD*  pdwNewImageSize,
    LPCSTR  lpRCFilename
    )
{
    UINT uiError = ERROR_NO_ERROR;

    // The Type we can parse are only the standard ones
    switch ((UINT)LOWORD(lpszType)) {

        case 4:
            uiError = UpdateMenu( lpNewBuf, dwNewSize,
                                  lpOldImage, dwOldImageSize,
                                  lpNewImage, pdwNewImageSize );
        break;

        case 5:
            uiError = UpdateDialog( lpNewBuf, dwNewSize,
                                  lpOldImage, dwOldImageSize,
                                  lpNewImage, pdwNewImageSize );
        break;

        case 6:
            uiError = UpdateString( lpNewBuf, dwNewSize,
                                    lpOldImage, dwOldImageSize,
                                    lpNewImage, pdwNewImageSize );
        break;

        case 9:
            uiError = UpdateAccel( lpNewBuf, dwNewSize,
                                   lpOldImage, dwOldImageSize,
                                   lpNewImage, pdwNewImageSize );
        break;

        case 11:
            uiError = UpdateMsgTbl( lpNewBuf, dwNewSize,
                                  lpOldImage, dwOldImageSize,
                                  lpNewImage, pdwNewImageSize );
        break;

        case 16:
            uiError = UpdateVerst( lpNewBuf, dwNewSize,
                                   lpOldImage, dwOldImageSize,
                                   lpNewImage, pdwNewImageSize );
        break;

        default:
            //
            // Get the file name from the iodll
            //
            if(lpRCFilename && strcmp(lpRCFilename, ""))
            {
                // try to Load the dll
                HINSTANCE hRCDllInst = LoadLibrary(lpRCFilename);
                if (hRCDllInst)
                {
                    UINT (FAR PASCAL * lpfnGenerateImageEx)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*, LPCSTR);

                    lpfnGenerateImageEx = (UINT (FAR PASCAL *)(LPCSTR, LPVOID, DWORD, LPVOID, DWORD, LPVOID, DWORD*, LPCSTR))
                                                GetProcAddress( hRCDllInst, "RWUpdateImageEx" );

                    if (lpfnGenerateImageEx)
                    {
                        uiError = (*lpfnGenerateImageEx)( lpszType,
                                            lpNewBuf,
                                            dwNewSize,
                                            lpOldImage,
                                            dwOldImageSize,
                                            lpNewImage,
                                            pdwNewImageSize,
                                            NULL );
                    }
                    else
                    {
                        *pdwNewImageSize = 0L;
                        uiError = ERROR_RW_NOTREADY;
                    }

                    FreeLibrary(hRCDllInst);
                }
                else
                {
                    *pdwNewImageSize = 0L;
                    uiError = ERROR_RW_NOTREADY;
                }
            }
            else
            {
                *pdwNewImageSize = 0L;
                uiError = ERROR_RW_NOTREADY;
            }
        break;
    }

    return uiError;
}

extern "C"
DllExport
UINT
APIENTRY
RWUpdateImage(
    LPCSTR  lpszType,
    LPVOID  lpNewBuf,
    DWORD   dwNewSize,
    LPVOID  lpOldImage,
    DWORD   dwOldImageSize,
    LPVOID  lpNewImage,
    DWORD*  pdwNewImageSize
    )
{
    return RWUpdateImageEx(lpszType, lpNewBuf, dwNewSize,
            lpOldImage, dwOldImageSize, lpNewImage, pdwNewImageSize,
            NULL);
}

///////////////////////////////////////////////////////////////////////////
// Functions implementation
static UINT
GetResInfo( CFile* pfile,
            WORD* pwTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
            WORD* pwNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
            WORD* pwFlags,
            DWORD* pdwSize, DWORD* pdwFileOffset )
{
    // Here we will parese the win32 file and will extract the information on the
    // resources included in the file.
    // Let's go and get the .rsrc sections
    UINT uiError = ERROR_NO_ERROR;

    return 1;
}

static UINT FindResourceSection( CFile* pfile, ULONG_PTR * pRes )
{
    UINT uiError = ERROR_NO_ERROR;
    LONG lRead;

    // We check again that is a file we can handle
    WORD w;

    pfile->Read((WORD*)&w, sizeof(WORD));
    if (w!=IMAGE_DOS_SIGNATURE) return ERROR_RW_INVALID_FILE;

    pfile->Seek( 0x18, CFile::begin );
    pfile->Read((WORD*)&w, sizeof(WORD));
    if (w<0x0040) {
    // this is not a Windows Executable
        return ERROR_RW_INVALID_FILE;
    }

    // get offset to new header
    pfile->Seek( 0x3c, CFile::begin );
    pfile->Read((WORD*)&w, sizeof(WORD));

    // read windows new header
    static IMAGE_NT_HEADERS NTHdr;
    pfile->Seek( w, CFile::begin );

    pfile->Read(&NTHdr, sizeof(IMAGE_NT_HEADERS));

    // Check if the magic word is the right one
    if (NTHdr.Signature!=IMAGE_NT_SIGNATURE)
                return ERROR_RW_INVALID_FILE;

    // Check if the we have 64-bit image
#ifdef _WIN64
    if (NTHdr.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
        pfile->Seek(IMAGE_SIZEOF_NT_OPTIONAL32_HEADER - 
                    IMAGE_SIZEOF_NT_OPTIONAL64_HEADER, 
                    CFile::current);
#else
    if (NTHdr.OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
        pfile->Seek(IMAGE_SIZEOF_NT_OPTIONAL64_HEADER - 
                    IMAGE_SIZEOF_NT_OPTIONAL32_HEADER, 
                    CFile::current);
#endif

    // this is a Windows NT Executable
    // we can handle the situation

    // Later we want to check for the file type

    // Read the section table
    UINT uisize = sizeof(IMAGE_SECTION_HEADER)
          * NTHdr.FileHeader.NumberOfSections;
    PIMAGE_SECTION_HEADER pSectTbl =
            new IMAGE_SECTION_HEADER[NTHdr.FileHeader.NumberOfSections];

    if (pSectTbl==LPNULL)
    return ERROR_NEW_FAILED;

    // Clean the memory we allocated
    memset( (PVOID)pSectTbl, 0, uisize);

    lRead = pfile->Read(pSectTbl, uisize);

    if (lRead!=(LONG)uisize) {
        delete []pSectTbl;
        return ERROR_FILE_READ;
    }

    PIMAGE_SECTION_HEADER pResSect     = NULL;
    PIMAGE_SECTION_HEADER pResSect1    = NULL;
    // Check all the sections for the .rsrc or .rsrc1
    USHORT us =0;
    for (PIMAGE_SECTION_HEADER pSect = pSectTbl;
         us < NTHdr.FileHeader.NumberOfSections; us++ )     {
        if ( !strcmp((char*)pSect->Name, ".rsrc") && (!pResSect)) {
            pResSect = pSect;
        } else if (!strcmp((char*)pSect->Name, ".rsrc1") && (!pResSect1)) {
            // This mean that the binary we are parsing
            // has been already updated using UpdateResource()
            pResSect1 = pSect;
        }
        pSect++;
    }

    if (!pResSect) {
        delete []pSectTbl;
        return ERROR_RW_NO_RESOURCES;
    }
    // Read the resources in memory
    ResSectData.ulOffsetToResources  = pResSect->PointerToRawData;
    ResSectData.ulOffsetToResources1 = pResSect1 ? pResSect1->PointerToRawData
                                       : LPNULL;

    ResSectData.ulVirtualAddress   = pResSect->VirtualAddress;
    ResSectData.ulSizeOfResources  = pResSect->SizeOfRawData;
    ResSectData.ulVirtualAddress1  = pResSect1 ? pResSect1->VirtualAddress
                                           : LPNULL;
    ResSectData.ulSizeOfResources1 = pResSect1 ? pResSect1->SizeOfRawData
                                           : 0L;
    UCHAR * pResources = (UCHAR *) malloc((ResSectData.ulSizeOfResources
                  +ResSectData.ulSizeOfResources1));

    if (pResources==LPNULL) {
        delete []pSectTbl;
        return ERROR_NEW_FAILED;
    }

    // We read the data for the first section
    pfile->Seek( (LONG)ResSectData.ulOffsetToResources, CFile::begin);
    lRead = ReadFile(pfile, pResources, (LONG)ResSectData.ulSizeOfResources);

    if (lRead!=(LONG)ResSectData.ulSizeOfResources) {
        delete []pSectTbl;
        free(pResources);
        return ERROR_FILE_READ;
    }

    // We read the data for the second section
    if (ResSectData.ulSizeOfResources1 > 0L) {
        pfile->Seek( (LONG)ResSectData.ulOffsetToResources1, CFile::begin);
        lRead = ReadFile( pfile, (pResources+ResSectData.ulSizeOfResources),
                              (LONG)ResSectData.ulSizeOfResources1);

        if (lRead!=(LONG)ResSectData.ulSizeOfResources1) {
            delete []pSectTbl;
            free(pResources);
            return ERROR_FILE_READ;
        }
    }

    delete []pSectTbl;
    // We want to copy the pointer to the resources
    *pRes = (ULONG_PTR)pResources;
    return uiError;
}

static UINT ParseDirectory( CFile* pfile,
            LPLPBYTE lplpBuf, UINT* puiBufSize,
            BYTE bLevel,
            PIMAGE_RESOURCE_DIRECTORY pResStart,
            PIMAGE_RESOURCE_DIRECTORY pResDir)
{
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirStart;

    // Get the pointer to the first entry
    pResDirStart = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)
            ((BYTE far *)pResDir + sizeof( IMAGE_RESOURCE_DIRECTORY));

    UINT uiError = 0;
    UINT uiCount = pResDir->NumberOfNamedEntries
             + pResDir->NumberOfIdEntries;

    for ( PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry = pResDirStart;
      pResDirEntry < pResDirStart+uiCount && uiError == 0;
          ++pResDirEntry )
    {
        if (bLevel==0) GetNameOrOrdU( (PUCHAR) pResStart,
                            pResDirEntry->Name,
                            (LPWSTR)&gwszTypeId,
                            &gType );
        if (bLevel==1) GetNameOrOrdU( (PUCHAR) pResStart,
                            pResDirEntry->Name,
                            (LPWSTR)&gwszResId,
                            &gResId );
        if (bLevel==2) gLng = pResDirEntry->Name;

        // Check if the user want to get all the resources
        // or only some of them
        uiError = ParseDirectoryEntry( pfile,
                lplpBuf, puiBufSize,
                bLevel,
            pResStart,
            pResDirEntry );
    }
    return uiError;
}

static UINT ParseDirectoryEntry( CFile * pfile,
            LPLPBYTE lplpBuf, UINT* puiBufSize,
            BYTE bLevel,
            PIMAGE_RESOURCE_DIRECTORY pResStart,
            PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    UINT uiError;

    // Check if it is a SubDir or if it is a final Node
    if (pResDirEntry->OffsetToData & IMAGE_RESOURCE_DATA_IS_DIRECTORY) {
        // It is a SubDir
        uiError = ParseSubDir( pfile,
            lplpBuf, puiBufSize,
            bLevel,
            pResStart,
            pResDirEntry );

    } else {
        uiError = ProcessData( pfile,
                    lplpBuf, puiBufSize,
                    pResStart,
                    (PIMAGE_RESOURCE_DATA_ENTRY)((BYTE far *)pResStart
                    + pResDirEntry->OffsetToData));
    }
    return uiError;
}

static UINT ParseSubDir( CFile * pfile,
            LPLPBYTE lplpBuf, UINT* puiBufSize,
            BYTE bLevel,
            PIMAGE_RESOURCE_DIRECTORY pResStart,
            PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    PIMAGE_RESOURCE_DIRECTORY pResDir;

    pResDir = (PIMAGE_RESOURCE_DIRECTORY)((BYTE far *)pResStart
          + (pResDirEntry->OffsetToData &
            (~IMAGE_RESOURCE_DATA_IS_DIRECTORY)));

    return( ++bLevel < MAXLEVELS ? ParseDirectory( pfile,
                                        lplpBuf, puiBufSize,
                        bLevel,
                                    pResStart,
                                    pResDir)
                         : ERROR_RW_TOO_MANY_LEVELS);
}

static UINT ProcessData( CFile * pfile,
                         LPLPBYTE lplpBuf, UINT* puiBufSize,
                         PIMAGE_RESOURCE_DIRECTORY pResStart,
                         PIMAGE_RESOURCE_DATA_ENTRY pResData)
{
    UINT uiError = ERROR_NO_ERROR;

    // Let's calculate the offset to the data
    ULONG ulOffset = pResData->OffsetToData - ResSectData.ulVirtualAddress;

    if ( ulOffset >= ResSectData.ulSizeOfResources ) {
        if ( ResSectData.ulSizeOfResources1 > 0L )      {
            // What we need is in the .rsrc1 segment
            // Recalculate the offset;
            ulOffset = pResData->OffsetToData - ResSectData.ulVirtualAddress1;
            if ( ulOffset >= ResSectData.ulSizeOfResources +
                             ResSectData.ulSizeOfResources1) {
                // There is an error in the offset
                return ERROR_FILE_INVALID_OFFSET;
            } else ulOffset += ResSectData.ulOffsetToResources1;
        } else return ERROR_FILE_INVALID_OFFSET;
    } else ulOffset += ResSectData.ulOffsetToResources;

    // Convert the UNICODE to SB string
    static char szResName[128];
    UINT cch = _WCSLEN(gwszResId);
    _WCSTOMBS( szResName, gwszResId, 128 );

    static char szTypeName[128];
    cch = _WCSLEN(gwszTypeId);
    _WCSTOMBS( szTypeName, gwszTypeId, 128 );


    TRACE("WIN32.DLL:\tType: %ld\tType Name: %s\tLang: %ld\tRes Id: %ld", gType, szTypeName, gLng, gResId);
    TRACE1("\tSize: %d", pResData->Size);
    TRACE2("\tRes Name: %s\tOffset: %lX\n", szResName, ulOffset );

    // fill the buffer

    WriteResInfo(lplpBuf, (LONG*)puiBufSize,
                 (WORD)gType, szTypeName, 128,
                 (WORD)gResId, szResName, 128,
                 (DWORD)gLng,
                 (DWORD)pResData->Size, (DWORD)ulOffset );
    return uiError;
};

static LONG WriteResInfo(
                 LPLPBYTE lplpBuffer, LONG* plBufSize,
                 WORD wTypeId, LPSTR lpszTypeId, BYTE bMaxTypeLen,
                 WORD wNameId, LPSTR lpszNameId, BYTE bMaxNameLen,
                 DWORD dwLang,
                 DWORD dwSize, DWORD dwFileOffset )
{
    LONG lSize = 0;
    lSize = PutWord( lplpBuffer, wTypeId, plBufSize );
    lSize += PutStringA( lplpBuffer, lpszTypeId, plBufSize );
	 // Check if it is alligned
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutWord( lplpBuffer, wNameId, plBufSize );
    lSize += PutStringA( lplpBuffer, lpszNameId, plBufSize );
    lSize += Allign( lplpBuffer, plBufSize, lSize);

    lSize += PutDWord( lplpBuffer, dwLang, plBufSize );

    lSize += PutDWord( lplpBuffer, dwSize, plBufSize );

    lSize += PutDWord( lplpBuffer, dwFileOffset, plBufSize );

    return (LONG)lSize;
}

static UINT GetUpdatedRes(
                 BYTE far * far* lplpBuffer,
                 UINT* puiBufSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwLang, DWORD* dwSize )
{
    UINT uiSize = 0l;
	LONG lSize = *puiBufSize;

    uiSize = GetWord( lplpBuffer, wTypeId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszTypeId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, PadPtr(uiSize), (LONG*)&lSize );

    uiSize += GetWord( lplpBuffer, wNameId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszNameId, (LONG*)&lSize );
	uiSize += SkipByte( lplpBuffer, PadPtr(uiSize), (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwLang, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwSize, (LONG*)&lSize );

	*puiBufSize = lSize;

    return 0;
}

static UINT GetRes(
                 BYTE far * far* lplpBuffer,
                 UINT* puiBufSize,
                 WORD* wTypeId, LPSTR lplpszTypeId,
                 WORD* wNameId, LPSTR lplpszNameId,
                 DWORD* dwLang, DWORD* dwSize, DWORD* dwFileOffset )
{
    UINT uiSize = 0l;
	 LONG lSize = *puiBufSize;

    uiSize = GetWord( lplpBuffer, wTypeId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszTypeId, (LONG*)&lSize );
	 uiSize += SkipByte( lplpBuffer, PadPtr(uiSize), (LONG*)&lSize );

    uiSize += GetWord( lplpBuffer, wNameId, (LONG*)&lSize );
    uiSize += GetStringA( lplpBuffer, lplpszNameId, (LONG*)&lSize );
	 uiSize += SkipByte( lplpBuffer, PadPtr(uiSize), (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwLang, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwSize, (LONG*)&lSize );

    uiSize += GetDWord( lplpBuffer, dwFileOffset, (LONG*)&lSize );

	 *puiBufSize = lSize;
    return uiSize;
}

static LONG ReadFile(CFile* pFile, UCHAR * pBuf, LONG lRead)
{
    LONG lLeft = lRead;
    WORD wRead = 0;
    DWORD dwOffset = 0;

    while(lLeft>0){
        wRead =(WORD) (32738ul < lLeft ? 32738: lLeft);
        if (wRead!=_lread( (HFILE)pFile->m_hFile, (UCHAR *)pBuf+dwOffset, wRead))
            return 0l;
        lLeft -= wRead;
        dwOffset += wRead;
    }
    return dwOffset;

}


////////////////////////////////////////////////////////////////////////////
// DLL Specific code implementation

////////////////////////////////////////////////////////////////////////////
// Library init

////////////////////////////////////////////////////////////////////////////
// This function should be used verbatim.  Any initialization or termination
// requirements should be handled in InitPackage() and ExitPackage().
//
extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory
		// here, use the TRACE or ASSERT macros or call MessageBox
		AfxInitExtensionModule(extensionDLL, hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxWinTerm();
	}

	if (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)
		return 0;		// CRT term	Failed

	return 1;   // ok
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\commbase.c ===
#ifdef RLWIN32
#include <windows.h>
#else
#ifdef RLWIN16
#include <windows.h>
//#include <ntimage.h>
//#else // DOS BUILD
//#include <ntimage.h>
#endif
#endif


// CRT includes
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <io.h>
#include <time.h>
//#include <sys\types.h>
//#include <sys\stat.h>

#ifdef RLDOS
    #include "dosdefs.h"
#else
    #include "windefs.h"
#endif


#include "commbase.h"
#include "restok.h"
#include "tokenapi.h"

extern UCHAR szDHW[];


/**
  *  Function: StripNewLine
  *    Replaces new line characters with nulls
  *
  *  Arguments:
  *    sz, string to be stripped
  *
  *  Returns:
  *    nothing
  *
  *  Error Codes:
  *    none
  *
  *  History:
  *    2/92, Implemented    SteveBl
  *   10/92, Simplified to only check last char in non-empty string - DaveWi
  */

void StripNewLineA( CHAR *sz)
{
    int i;

    if ( sz && (i = lstrlenA( sz)) > 0 )
    {
        if ( sz[ --i] == '\n' )
        {
            sz[i] = 0;
        }
    }
}


//.....................................................
//...
//... A Unicode NewLine is TEXT("\r\n") - two separate characters

void StripNewLineW(  LPWSTR sz)
{
    int i = lstrlenW( sz);

    if ( i > 0 && sz[ --i] == TEXT('\n') )
    {
        sz[i] = TEXT('\0');

        if ( i > 0 && sz[ --i] == TEXT('\r') )
        {
            sz[i] = TEXT('\0');
        }
    }
}

//+-------------------------------------------------------------------------
//
// Function:    IsExe, Public
//
// Synopsis:    Determines if the specified file is an executable image file
//
//
// Arguments:   [szFileName]    The name of the file to determine whether it is an exe
//
//
// Effects:
//
// Returns:     -1  Error Condition
//              NOTEXE     File is not an exe
//              WIN16EXE   File is a Win 16 exe
//              NTEXE      File is a win 32 exe
//              UNKNOWEXE  File is not a valid exe
//
// Modifies:
//
// History:
//              10-Oct-92   Created     TerryRu
//
//
// Notes:
//
//--------------------------------------------------------------------------

int IsExe( CHAR *szFileName )
{
    static IMAGE_DOS_HEADER        DosHeader;
    static IMAGE_OS2_HEADER        ImageNeFileHdr;
    static IMAGE_FILE_HEADER       ImageFileHdr;
    static IMAGE_OPTIONAL_HEADER   ImageOptionalHdr;
    DWORD   neSignature;
    FILE    *fIn = NULL;
    WORD    rc;


    if ( (fIn = FOPEN( szFileName, "rb")) == NULL )
    {
        return ( -1 );
    }

    if ( ResReadBytes( fIn,
               (char *)&DosHeader,
               sizeof( IMAGE_DOS_HEADER),
               NULL) == FALSE
      || (DosHeader.e_magic != IMAGE_DOS_SIGNATURE ))
    {
        FCLOSE( fIn);
        return( NOTEXE);
    }

    // 1st byte was a valid signature, and we were able to read a DOS Hdr

    // now seek to address of new exe header


    if ( fseek( fIn, DosHeader.e_lfanew, SEEK_SET))
    {
        FCLOSE( fIn);
        return( NOTEXE);
    }

    // assume file is a Win 16 file,

    // Read the NT signature
    neSignature = (WORD) GetWord( fIn, NULL );

    if ( neSignature == IMAGE_OS2_SIGNATURE )
    {
        // return signature into input stream,
        // and read ne header as a whole
        UnGetWord( fIn, (WORD) neSignature, NULL );

    if ( ResReadBytes( fIn,
               (char *)&ImageNeFileHdr,
               sizeof( IMAGE_OS2_HEADER),
               NULL) == FALSE )
        {
            FCLOSE( fIn);
            return( NOTEXE);
        }

        // determine if file is a WIN 16 Image File
        if ( ImageNeFileHdr.ne_ver >= 4 && ImageNeFileHdr.ne_exetyp == 2 )
        {
            FCLOSE( fIn);
            return( WIN16EXE);
        }
    }

    // not a win 16 exe, check for a NT exe.
    UnGetWord( fIn, (WORD) neSignature, NULL );
    neSignature =  GetdWord( fIn, NULL );

    if ( neSignature == IMAGE_NT_SIGNATURE )
    {
        if ( ResReadBytes( fIn,
               (char *)&ImageFileHdr,
               sizeof( IMAGE_FILE_HEADER),
               NULL) == FALSE )
        {
            FCLOSE( fIn);
            return( NOTEXE);
        }


        if ( ImageFileHdr.SizeOfOptionalHeader )
        {

            // read the optional header  only to validate the ImageFileHeader
            // we currently don\'t use any info in the Optional Header

            if ( ImageFileHdr.SizeOfOptionalHeader
                 > sizeof( IMAGE_OPTIONAL_HEADER ) )
            {
                FCLOSE( fIn);
                return( NOTEXE);
            }

            if ( ResReadBytes( fIn,
                   (char *)&ImageOptionalHdr,
                   (size_t)min( sizeof( IMAGE_OPTIONAL_HEADER),
                                            ImageFileHdr.SizeOfOptionalHeader),
                   NULL) == FALSE )
            {
                FCLOSE( fIn);
                return( NOTEXE);
            }
        }

        // determine if file is an executable image file
        if ( (ImageFileHdr.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) ||
	     (ImageFileHdr.Characteristics & IMAGE_FILE_DLL) )
        {
            FCLOSE( fIn);
            return( NTEXE);
        }
        else
        {
            FCLOSE( fIn);
            return( NOTEXE);
        }
    }
    FCLOSE( fIn);

    // did not regonize signature type

    return( NOTEXE);
}




BOOL IsWin32Res( CHAR * szFileName)
{
    BOOL fRC = FALSE;

    if ( IsRes( szFileName) )
    {
        FILE *pF = fopen( szFileName, "rb");

        if ( pF )
        {
            DWORD dwSize = GetdWord( pF, NULL);
            fclose( pF);

            fRC = (dwSize == 0L) ? TRUE : FALSE;
        }
        else
        {
            fRC = FALSE;
        }
    }
    else
    {
        fRC = FALSE;
    }
    return( fRC);
}



//+-------------------------------------------------------------------------
//
// Function:    IsRes, Public
//
// Synopsis:    Determines if the specified file has a .RES extention.
//
//
// Arguments:   [szFileName]    The name of the file to determine whether it is a res
//
//
// Effects:
//
// Returns:     TRUE, File has a .RES extention
//              FALSE, File does not have a .RES extention
//
// Modifies:
//
// History:
//              16-Oct-92   Created     TerryRu
//
//
// Notes:
//
//--------------------------------------------------------------------------

BOOL IsRes( CHAR *szFileName)
{
    int i = lstrlenA( szFileName);

    return( (i > 4 && lstrcmpiA( szFileName + i - 4, ".RES") == 0) ? TRUE : FALSE );
}




/**
  * Function TranslateFileTime
  *    Translates a Win32 filetime structure into a useful string
  *    representation.
  *
  *  Arguments:
  *    sz, destination buffer (ANSI string)
  *    ft, file time structure
  *
  *  Returns:
  *    sring representation of date/time in sz
  *
  *  History:
  *    7/92 implemented SteveBl
  */
#ifdef RLWIN32
void TranslateFileTime(CHAR *sz, FILETIME ft)
{
    sprintf(sz,"FILETIME STRUCTURE: %Lu:%Lu",ft.dwHighDateTime,ft.dwLowDateTime);
}
#endif

/**
  *  Function: SzDateFromFileName
  *    Returns a string containing the time and date stamp on a file.
  *
  *  Arguments:
  *   sz, destination buffer
  *   szFile, path to file
  *
  *  Returns:
  *   date and time in sz
  *
  *  Error Codes:
  *   none (but leaves sz empty)
  *
  *  Comments:
  *   Assumes sz is large enough for date string.
  *
  *  History:
  *   2/92, Implemented       SteveBl
  */
void SzDateFromFileName(CHAR *sz,CHAR *szFile)
{

#ifdef RLWIN32

    HANDLE hFile;
    WCHAR szt[MAXFILENAME];

    _MBSTOWCS( szt,
               szFile,
               WCHARSIN( sizeof( szt)),
               ACHARSIN( lstrlenA( szFile) + 1));

    hFile = CreateFile( szt,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL);

    if ( hFile != (HANDLE)-1 )
    {
        FILETIME ft;

        GetFileTime( hFile, NULL, NULL, &ft);
        TranslateFileTime( sz, ft);
        CloseHandle( hFile);
    }
#else //RLWIN32
    struct _stat s;

    if (!_stat(szFile,&s))
    {
        sprintf(sz,"%s",ctime(&s.st_atime));
        StripNewLine(sz);
    }
    else
    {
        sz[0] = 0;
    }
#endif
}


//..........................................................................

#ifdef _DEBUG
FILE * MyFopen( char * pszFileName, char * pszMode, char * pszFile, int nLine)
#else
FILE * MyFopen( char * pszFileName, char * pszMode)
#endif
{
    FILE *pfRC = NULL;

//#ifdef _DEBUG
//    fprintf( stderr, "fopening \"%s\" at %d in %s",
//                     pszFileName,
//                     nLine,
//                     pszFile);
//#endif
    pfRC = fopen( pszFileName, pszMode);

//#ifdef _DEBUG
//    fprintf( stderr, ": FILE ptr = %p\n", pfRC);
//#endif
    return( pfRC);
}

//..........................................................................
#ifdef _DEBUG
int MyClose( FILE **pf, char * pszFile, int nLine)
#else
int MyClose( FILE **pf)
#endif
{
	int nRC = 0;

//#ifdef _DEBUG
//    fprintf( stderr, "\tclosing %p at %d in %s\n", *pf, nLine, pszFile);
//#endif

	if ( *pf )
	{
		nRC = fclose( *pf);
		*pf = NULL;
	}
    return( nRC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\checkfix.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "imagehlp.h"
#include "restok.h"

//... PROTOTYPES

USHORT ChkSum(

    DWORD   PartialSum,
    PUSHORT Source,
    DWORD   Length);

static PIMAGE_NT_HEADERS MyRtlImageNtHeader(

    PVOID pBaseAddress);



//...........................................................................

DWORD FixCheckSum( LPSTR ImageName)
{
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PIMAGE_NT_HEADERS NtHeaders;
    PVOID BaseAddress;


    FileHandle = CreateFileA( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);

    if ( FileHandle == INVALID_HANDLE_VALUE )
    {
        QuitA( IDS_ENGERR_01, "image", ImageName);
    }

    MappingHandle = CreateFileMapping( FileHandle,
                                       NULL,
                                       PAGE_READWRITE,
                                       0,
                                       0,
                                       NULL);

    if ( MappingHandle == NULL )
    {
        CloseHandle( FileHandle );
        QuitA( IDS_ENGERR_22, ImageName, NULL);
    }
    else
    {
        BaseAddress = MapViewOfFile( MappingHandle,
                                     FILE_MAP_READ | FILE_MAP_WRITE,
                                     0,
                                     0,
                                     0);
        CloseHandle( MappingHandle );

        if ( BaseAddress == NULL )
        {
            CloseHandle( FileHandle );
            QuitA( IDS_ENGERR_23, ImageName, NULL);
        }
        else
        {
		    DWORD dwFileLength = 0;

            //
            // Get the length of the file in bytes and compute the checksum.
            //

            dwFileLength = GetFileSize( FileHandle, NULL );

            //
            // Obtain a pointer to the header information.
            //

            NtHeaders = MyRtlImageNtHeader( BaseAddress);

            if ( NtHeaders == NULL )
            {
                CloseHandle( FileHandle );
                UnmapViewOfFile( BaseAddress );
                QuitA( IDS_ENGERR_17, ImageName, NULL);
            }
            else
            {
      			DWORD dwHeaderSum   = 0;
			    DWORD dwCheckSum    = 0;
			    DWORD dwOldCheckSum = 0;
                //
                // Recompute and reset the checksum of the modified file.
                //

                dwOldCheckSum = NtHeaders->OptionalHeader.CheckSum;

                (VOID) MapFileAndCheckSumA( ImageName,
                                            &dwHeaderSum,
                                            &dwCheckSum);

                NtHeaders->OptionalHeader.CheckSum = dwCheckSum;

                if ( ! FlushViewOfFile( BaseAddress, dwFileLength) )
                {
                    QuitA( IDS_ENGERR_24, ImageName, NULL);
                }

                if ( NtHeaders->OptionalHeader.CheckSum != dwOldCheckSum )
                {
                    if ( ! TouchFileTimes( FileHandle, NULL) )
                    {
                        QuitA( IDS_ENGERR_25, ImageName, NULL);
                    }
                }
                UnmapViewOfFile( BaseAddress );
                CloseHandle( FileHandle );
            }
        }
    }
    return( 0);
}

//.........................................................................

static PIMAGE_NT_HEADERS MyRtlImageNtHeader( PVOID pBaseAddress)
{
    IMAGE_DOS_HEADER *pDosHeader = (IMAGE_DOS_HEADER *)pBaseAddress;

    return( pDosHeader->e_magic == IMAGE_DOS_SIGNATURE
            ? (PIMAGE_NT_HEADERS)(((PBYTE)pBaseAddress) + pDosHeader->e_lfanew)
            : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\commbase.h ===
#ifndef _COMMBASE_H_
#define _COMMBASE_H_

void StripNewLineA(  LPSTR sz);
void StripNewLineW( LPWSTR sz);

#ifdef UNICODE
#define StripNewLine StripNewLineW
#else
#define StripNewLine StripNewLineA
#endif

void SzDateFromFileName( char *sz, char *szFile);

#endif // _COMMBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\exentres.h ===
#define  IDERR_SUCCESS   0

int   ExtractResFromExe32A( char *, char *, WORD);
int   BuildExeFromRes32A(   char *, char *, char *);
ULONG GetListOfResLangIDs( char *szExeName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\custres.h ===
/* CustRes.h
 *
 * Header file for CustRes.c
 */

#ifndef _CUSTRES_H_
#define _CUSTRES_H_

#include <stdio.h>

#ifndef BYTELN
#include "restok.h"
#endif

#ifndef CHAR
#define CHAR char
#endif

typedef struct Custom_Resource
{
    void far *pData;
    struct Custom_Resource far* pNext;
} CUSTOM_RESOURCE;

typedef CUSTOM_RESOURCE far * FPCUSTOM_RESOURCE;
int  ParseResourceDescriptionFile(FILE *ResourceDescriptionFile,
                                  int *piErrorLine);

void ClearResourceDescriptions(void);

int  GetCustomResource(FILE *inResFile, DWORD *lSize,
                       FPCUSTOM_RESOURCE *ppCustomResource,
                       RESHEADER ResHeader);

void TokCustomResource(FILE *TokFile, RESHEADER ResHeader,
                       FPCUSTOM_RESOURCE*ppCustomResource);

void PutCustomResource(FILE *OutResFile, FILE *TokFile,
                       RESHEADER ResHeader,
                       FPCUSTOM_RESOURCE *ppCustomResource);

void ClearCustomResource(FPCUSTOM_RESOURCE *ppCustomResource);

int  ParseResourceDescriptionFile(FILE *,int *);
int  LoadCustResDescriptions( CHAR *);

WCHAR * BinToTextW( WCHAR rgc[], int cSource);
char  * BinToTextA(  CHAR rgc[], int cSource);

int     TextToBinW( TCHAR rgc[], TCHAR sz[], int l);
int     TextToBinA(  CHAR rgc[],  CHAR sz[], int l);

#ifdef RLRES32
#define TextToBin TextToBinW
#define BinToText BinToTextW
#else  //RLRES32
#define TextToBin TextToBinA
#define BinToText BinToTextA
#endif //RLRES32

int atoihex( CHAR szStr[]);

#endif // _CUSTRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\dosdefs.h ===
/* DOS macros and globals */

#ifndef _DOSDEFS_H_
#define _DOSDEFS_H_

#pragma message("Using the DOS translation of the common macros.")

#ifndef RLDOS
#pragma message("\n****************************************************************************\n")
#pragma message("Hey!  I think you meant to use the Windows translation of the common macros!")
#pragma message("\n****************************************************************************\n")
#endif

#include "fcntl.h"
#include "dos.h"

#ifndef NULL
   #if (_MSC_VER >= 600)
      #define NULL   ((void *)0)
   #elif (defined(M_I86SM) || defined(M_I86MM))
      #define NULL   0
   #else
      #define NULL   0L
   #endif
#endif

#define FALSE     0
#define TRUE      1

#define FAR       far
#define NEAR      near
#define LONG      long
#define VOID      void
#define PASCAL	  pascal
#define WINAPI

#define MAKELONG(a,b)  ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)      ((BYTE)(w))
#define HIBYTE(w)	   (((WORD)(w) >> 8) & 0xFF)
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
typedef unsigned char   BYTE;
typedef unsigned char  *PBYTE;
typedef unsigned long	DWORD;
typedef unsigned int	UINT;
typedef unsigned	WORD;
typedef int             BOOL;
typedef char           *PSTR;
typedef char NEAR      *NPSTR;
typedef char FAR       *LPSTR;
typedef int  FAR       *LPINT;
#define  CHAR           char
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#define WCHAR wchar_t
typedef WCHAR *PWCHAR;
typedef WCHAR *LPWSTR, *PWSTR;
typedef LPSTR PTSTR, LPTSTR;
#define TEXT(quote) quote
typedef unsigned char UCHAR;
typedef char *PCHAR;
#define UNALIGNED
#define DS_SETFONT 0x40L
int         _ret;
unsigned    _error;

/* These macros are for near heap only */

#define FOPEN(sz)                ((_ret=-1),(_error=_dos_open(sz,O_RDONLY,&_ret)),_ret)
#define FCREATE(sz)              ((_ret=-1),(_error=_dos_creat(sz,_A_NORMAL,&_ret)),_ret)
#define FCLOSE(fh)               ((_error=_dos_close(fh)))
#define FREAD(fh,buf,len)        ((_error=_dos_read(fh,buf,len,&_ret)),_ret)
#define FWRITE(fh,buf,len)       ((_error=_dos_write(fh,buf,len,&_ret)),_ret)
#define FSEEK(fh,off,i)          lseek(fh,(long)(off),i)
#define FERROR()		 _error

#define __FCLOSE(fp)  {fflush(fp);fclose(fp);}	// NT 348 bug workaround DHW
#define ALLOC(n)                 malloc(n)
#define FREE(p)                  free(p)
#define SIZE(p)                  _msize(p)
#define REALLOC(p,n)             realloc(p,n)
#define FMEMMOVE( szDst, szSrc, uSize)  _fmemmove( szDst, szSrc, uSize )
#define FSTRNCPY( szDst, szSrc, uSize)  _fstrncpy( szDst, szSrc, uSize )


#define _MBSTOWCS(ds,ss,dc,sc) mbstowcs(ds,ss,sc)
#define _WCSTOMBS(ds,ss,dc,sc) wcstombs(ds,ss,sc)

/* here are some macros for allocating and freeing far heap space */

#define FALLOC(n)                _fmalloc(n)
#define FFREE(n)                 _ffree(n)
#define FREALLOC(p,n)            _frealloc(p,n)

/* Some common translations macros                                */
#define SPRINTF                  sprintf
#define STRUPR                   strupr

#endif // _DOSDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\exe2res.h ===
#ifndef _EXE2RES_H_
#define _EXE2RES_H_

#define BUFSIZE 2048

/* error codes for file handling functions */
#define  IDERR_SUCCESS          0
#define  IDERR_BASE         255
#define  IDERR_ALLOCFAIL        (IDERR_BASE+1)
#define  IDERR_LOCKFAIL         (IDERR_BASE+2)
#define  IDERR_OPENFAIL         (IDERR_BASE+3)
#define  IDERR_READFAIL         (IDERR_BASE+4)
#define  IDERR_WINFUNCFAIL      (IDERR_BASE+5)
#define  IDERR_INVALIDPARAM     (IDERR_BASE+6)
#define  IDERR_FILETYPEBAD      (IDERR_BASE+7)
#define  IDERR_EXETYPEBAD       (IDERR_BASE+8)
#define  IDERR_WINVERSIONBAD    (IDERR_BASE+9)
#define  IDERR_RESTABLEBAD      (IDERR_BASE+10)
#define  IDERR_ICONBAD          (IDERR_BASE+11)
#define  IDERR_NOICONS          (IDERR_BASE+12)
#define  IDERR_ARRAYFULL        (IDERR_BASE+13)



#ifdef  RLDOS
/* Predefined resource types */
#define RT_NEWRESOURCE  0x2000
#define RT_ERROR        0x7fff

#define RT_CURSOR       1
#define RT_BITMAP       2
#define RT_ICON         3
#define RT_MENU         4
#define RT_DIALOG       5
#define RT_STRING       6
#define RT_FONTDIR      7
#define RT_FONT         8
#define RT_ACCELERATORS 9
#define RT_RCDATA       10
/* Error tables were never implemented and can be removed from RC */
/* #define RT_ERRTABLE     11 (done for 3.1) */
#define RT_GROUP_CURSOR 12
/* The value 13 is unused */
#define RT_GROUP_ICON   14
/* Name Tables no longer exist (this change made for 3.1) */
#define RT_NAMETABLE    15
#define RT_VERSION      16

#endif //RLDOS

#ifndef RLWIN32
typedef unsigned short USHORT;
typedef short SHORT;
#endif


typedef struct resinfo
{
    struct resinfo *next;
    SHORT flags;
    WORD nameord;
    PSTR name;
    LONG BinOffset;
    LONG size;
    WORD *poffset;
} RESINFO;



typedef struct typinfo
{
    struct typinfo *next;
    WORD typeord;
    PSTR type;
    SHORT nres;
    struct resinfo *pres;
} TYPINFO;


/* ----- Function prototypes ----- */

int ExtractResFromExe16A( CHAR *szInputExe,
                          CHAR *szOutputRes,
                          WORD   wFilter);

int BuildExeFromRes16A( CHAR *szTargetExe,
                        CHAR *szSourceRes,
                        CHAR *szSourceExe);

/* ----- Symbols ----- */

#define PRELOAD_ALIGN   5
#define PRELOAD_MINPADDING 16
#define DO_PRELOAD  1
#define DO_LOADONCALL   2
#define NUMZEROS 512
#define RESTABLEHEADER  4

#define MAXCODE     8192
#define MAXFARCODE  65500

#define WINDOWSEXE    2

#define OLDEXESIGNATURE       0x5A4D
#define NEWEXESIGNATURE       0x454E
#define ORDINALFLAG   0x8000

#define CV_OLD_SIG      0x42524e44L /* Old Signature is 'DNRB' */
#define CV_SIGNATURE    0x424e      /* New signature is 'NBxx' (x = digit) */

/* local typedefs */

typedef struct {      /* DOS 1, 2, 3, 4 .EXE header */
    WORD   ehSignature; /* signature bytes */
    WORD   ehcbLP;      /* bytes on last page of file */
    WORD   ehcp;        /* pages in file */
    WORD   ehcRelocation; /* count of relocation table entries*/
    WORD   ehcParagraphHdr; /* size of header in paragraphs */
    WORD   ehMinAlloc;      /* minimum extra paragraphs needed */
    WORD   ehMaxAlloc;      /* maximum extra paragraphs needed */
    WORD   ehSS;            /* initial \(relative\) SS value */
    WORD   ehSP;            /* initial SP value */
    WORD   ehChecksum;      /* checksum */
    WORD   ehIP;            /* initial IP value */
    WORD   ehCS;            /* initial \(relative\) CS value */
    WORD   ehlpRelocation;  /* file address of relocation table */
    WORD   ehOverlayNo;     /* overlay number */
    WORD   ehReserved[16];  /* reserved words */
    LONG ehPosNewHdr;       /* file address of new exe header */
} EXEHDR;                   /* eh */

typedef struct {            /* new .EXE header */
    WORD nhSignature;       /* signature bytes */
    char   nhVer;           /* LINK version number */
    char   nhRev;           /* LINK revision number */
    WORD nhoffEntryTable;   /* offset of Entry Table */
    WORD nhcbEntryTable;    /* number of bytes in Entry Table */
    LONG nhCRC;             /* checksum of whole file */
    WORD nhFlags;           /* flag word */
    WORD nhAutoData;        /* automatic data segment number */
    WORD nhHeap;            /* initial heap allocation */
    WORD nhStack;           /* initial stack allocation */
    LONG nhCSIP;            /* initial CS:IP setting */
    LONG nhSSSP;            /* initial SS:SP setting */
    WORD nhcSeg;            /* count of file segments */
    WORD nhcMod;            /* entries in Module Reference Table*/
    WORD nhcbNonResNameTable; /* size of non-resident name table */
    WORD nhoffSegTable;       /* offset of Segment Table */
    WORD nhoffResourceTable;  /* offset of Resource Table */
    WORD nhoffResNameTable;   /* offset of Resident Name Table */
    WORD nhoffModRefTable;    /* offset of Module Reference Table */
    WORD nhoffImpNameTable;   /* offset of Imported Names Table */
    LONG nhoffNonResNameTable; /* offset of Non-resident Names Tab */
    WORD nhcMovableEntries;    /* count of movable entries */
    WORD nhcAlign;             /* segment alignment shift count */
    WORD nhCRes;               /* count of resource segments */
    BYTE nhExeType;            /* target OS \(OS/2=1, Windows=2\) */
    BYTE nhFlagsOther;         /* additional exe flags */
    WORD nhGangStart;          /* offset to gangload area */
    WORD nhGangLength;         /* length of gangload area */
    WORD nhSwapArea;           /* minimum code swap area size*/
    WORD nhExpVer;             /* expected Windows version number */
} NEWHDR;                      /* nh */

typedef struct {
    WORD rtType;
    WORD rtCount;
    LONG rtProc;
} RESTYPEINFO;

typedef struct {            /* Resource name information block */
    WORD   rnOffset;        /* file offset to resource data */
    WORD   rnLength;        /* length of resource data */
    WORD   rnFlags;         /* resource flags */
    WORD   rnID;            /* resource name id */
    WORD   rnHandle;        /* reserved for runtime use */
    WORD   rnUsage;         /* reserved for runtime use */
} RESNAMEINFO;              /* rn */


/* ----- CodeView types and symbols ----- */

typedef struct
{
    char signature[4];
    long secTblOffset;
} CVINFO;

typedef struct
{
    long secOffset[5];
    unsigned version;
} CVSECTBL;

#endif // _EXE2RES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\custres.c ===
/** CustRes.c
  *
  * Custom resource handler module for TOKRES.
  *
  * Written by SteveBl
  *
  * Exported Functions:
  * int  ParseResourceDescriptionFile(FILE *ResourceDescriptionFile);
  *
  * int  GetCustomResource(FILE *inResFile, DWORD *lsize,
  *                CUSTOM_RESOURCE *pCustomResource,
  *                WORD wTypeId);
  *
  * void TokCustomResource(FILE *TokFile, RESHEADER ResHeader,
  *                CUSTOM_RESOURCE *pCustomResource);
  *
  * void PutCustomResource(FILE *OutResFile, FILE *TokFile,
  *                RESHEADER ResHeader,
  *                CUSTOM_RESOURCE *pCustomResource);
  *
  * void ClearCustomResource(CUSTOM_RESOURCE *pCustomResource);
  *
  * History:
  * Initial version written January 21, 1992.  -- SteveBl
  *
  * 01/21/93 - Changes to allow arb length token texts.  Also, fix
  *             some latent bugs.  MHotchin
  **/

#include <stdio.h>

#include <string.h>
#include <stdlib.h>
#include <tchar.h>

#ifdef RLDOS
#include "dosdefs.h"
#else
#include <windows.h>
#include "windefs.h"
#endif

#include "custres.h"
#include "restok.h"
#include "resread.h"


extern PROJDATA gProj;          //... Fields filled in main (UI)


extern BOOL  gbMaster;
extern UCHAR szDHW[];

enum LOCALIZABLE_TYPES  // determines data storage, reading, and printing method
{
    NOTLOCALIZABLE, // not to be stored
    NOTLOCALIZABLESZ,   // unlocalizable null terminated string
    NOTLOCALIZABLEWSZ,  // unlocalizable null terminated Unicode string
    LT_INTEGER,     // store as a long integer
    LT_FLOAT,       // store as a double preceision floating point number
    LT_CHAR,        // store as a single character
    LT_STRING,      // an array of char
    LT_SZ,          // a null terminated array of characters
    LT_WCHAR,       // store as a single Unicode character
    LT_WSTRING,     // an array of Unicode char
    LT_WSZ,         // a null terminated array of Unicode characters
    LT_UNSIGNED=16  // add with the others
};

typedef struct typesizes
{
    CHAR                  *szType;
    enum LOCALIZABLE_TYPES iType;
    int                    iShortSize;
    int                    iLongSize;
} TYPESIZES;

TYPESIZES rgTypeSizes[] =
{
#ifdef RLWIN32
    "WCHAR",    LT_WCHAR,       2,  2,
    "TCHAR",    LT_WCHAR,       2,  2,
    "INT",      LT_INTEGER,     4,  4,
    "SIGNED",   LT_INTEGER,     4,  4,
    "UNSIGNED", LT_INTEGER,     4,  4,
    "ENUM",     LT_INTEGER,     4,  4,
#else  //RLWIN32
    "TCHAR",    LT_CHAR,        1,  1,
    "INT",      LT_INTEGER,     2,  4,
    "SIGNED",   LT_INTEGER,     2,  4,
    "UNSIGNED", LT_INTEGER,     2,  4,
    "ENUM",     LT_INTEGER,     2,  2,
#endif //RLWIN32
    "CHAR",     LT_CHAR,        1,  1,
    "BYTE",     LT_INTEGER,     1,  1,
    "WORD",     LT_INTEGER,     2,  2,
    "SHORT",    LT_INTEGER,     2,  2,
    "FLOAT",    LT_FLOAT,       4,  4,
    "LONG",     LT_INTEGER,     4,  4,
    "DOUBLE",   LT_FLOAT,       8,  8,
    "DWORD",    LT_INTEGER,     4,  4
};

typedef struct resourcetypes
{
    CHAR *szType;
    int   iType;
} RESOURCETYPES;

RESOURCETYPES rgResourceTypes[] =
{
    "CURSOR",        1,
    "BITMAP",        2,
    "ICON",          3,
    "MENU",          4,
    "DIALOG",        5,
    "STRING",        6,
    "FONTDIR",       7,
    "FONT",          8,
    "ACCELERATORS",  9,
    "RCDATA",       10,
    "ERRTABLE",     11,
    "GROUP_CURSOR", 12,
    "GROUP_ICON",   14,
    "NAMETABLE",    15,
    "VERSION",      16
};

typedef struct CustResTemplate
{
    enum LOCALIZABLE_TYPES      iType;
    unsigned                    uSize;
    struct CustResTemplate far *pNext;
} CUSTRESTEMPLATE;

typedef struct CustResNode
{
    BYTE    bTypeFlag;      /* Indicat's if ID or string */
    BYTE    bNameFlag;      /* Indicat's if ID or string */
    WORD    wTypeID;
    WORD    wNameID;
    TCHAR    *pszType;
    TCHAR    *pszName;
    CUSTRESTEMPLATE far *pTemplate;
    struct CustResNode far *pNext;
} CUSTRESNODE;

typedef CUSTRESTEMPLATE far * FPCUSTRESTEMPLATE;
typedef CUSTRESNODE far * FPCUSTRESNODE;

CUSTRESNODE far *pCustResList = NULL;

#define SYMBOLSIZE 255

int  fUseSavedSymbol = FALSE;
int *piLineNumber    = NULL;
CHAR szSavedSymbol[ SYMBOLSIZE];

/*
 * Function Predefinitions:
 */
static int GetResourceType( CHAR sz[]);
static int AddStructureElement( int iType,
                                int nSize,
                                FPCUSTRESTEMPLATE *ppCRT,
                                int fMerge);
#ifdef RLWIN32
static void AddToW( TCHAR *sz, int *c, int lTarget, TCHAR ch);
static TCHAR *CheckBufSizeW(
    int   *lTarget,     //... Length of output buffer
    int    cOutBufLen,  //... Bytes already used in output buffer
    int    cDelta,      //... # characters we want to add to output buffer
    TCHAR *szOutBuf);   //... ptr to output buffer
#endif

static CHAR *CheckBufSize(
    int  *lTarget,      //... Length of output buffer
    int   cOutBufLen,   //... Bytes already used in output buffer
    int   cDelta,       //... # characters we want to add to output buffer
    CHAR *szOutBuf);    //... ptr to output buffer
static void AddTo( CHAR *sz, int *c, int lTarget, CHAR ch);
static int  UngetSymbol( CHAR sz[]);
static int  GetNextSymbol( CHAR sz[], unsigned n, FILE *f);
static int  ParseBlock( FILE *f, FPCUSTRESTEMPLATE  *ppCRT);
static CUSTRESNODE far * MatchResource( RESHEADER Resheader);
static void far * GetResData( enum LOCALIZABLE_TYPES wType,
                              unsigned uSize,
                              FILE *f,
                              DWORD *lSize);
static int PutResData( void far *pData,
                       enum LOCALIZABLE_TYPES wType,
                       unsigned uSize,
                       FILE *f);
static void far * GetTextData( enum LOCALIZABLE_TYPES wType,
                               unsigned uSize,
                               TCHAR sz[]);
static int PutTextData( void far *pData,
                        enum LOCALIZABLE_TYPES wType,
                        unsigned uSize,
                        TCHAR sz[],
                        int l);
int  atoihex( CHAR sz[]);

/** Function: GetResourceType
  * Returns the value of the number or resource type in sz.
  *
  * Arguments:
  * sz, string containing either a positive number or a resource type
  *
  * Returns:
  * value in resource
  *
  * Error Codes:
  * -1 if illegal value
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  **/
static int GetResourceType( CHAR sz[])
{
    int i;

    if (sz[0] >= '0' && sz[0] <= '9')
    {
        return atoi(sz);
    }

    for (i = sizeof(rgResourceTypes)/sizeof(RESOURCETYPES);i--;)
    {
        if ( ! lstrcmpiA( sz, rgResourceTypes[i].szType) )
        {
            return rgResourceTypes[i].iType;
        }
    }
    return -1;
}

/** Function: AddStructureElement
  * Adds an element's type and size to the Template list.
  * If this element can be merged with the last element do so.
  *
  * Arguments:
  * iType, how the data is interpreted
  * nSize, number of bytes used by the data
  * ppCRT, pointer to the next Custom Resource Template pointer
  * fMerge, if true then NOTLOCALIZABLE data will be merged.
  *
  * Returns:
  * 0 - if successful
  * !0 - if unsuccessful
  *
  * Error Codes:
  * 1 - out of memory
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  **/

static int AddStructureElement(

int                iType,
int                nSize,
FPCUSTRESTEMPLATE *ppCRT,
int                fMerge)
{
    if ( fMerge
      && ((iType == NOTLOCALIZABLE    && (*ppCRT)->iType == NOTLOCALIZABLE)
       || (iType == NOTLOCALIZABLESZ  && (*ppCRT)->iType == NOTLOCALIZABLESZ)
       || (iType == NOTLOCALIZABLEWSZ && (*ppCRT)->iType == NOTLOCALIZABLEWSZ)))
    {
        // combine this with the last one
        (*ppCRT)->uSize+=nSize;
        return 0;
    }
    // can't be combined with previous element
    (*ppCRT)->pNext = (CUSTRESTEMPLATE far *)FALLOC( sizeof( CUSTRESTEMPLATE));
    (*ppCRT) = (*ppCRT)->pNext;
    if (!*ppCRT)
    {
        return 1;
    }
    (*ppCRT)->iType = iType;
    (*ppCRT)->uSize = nSize;
    (*ppCRT)->pNext = NULL;
    return 0;
}

/**
 * Function: UngetSymbol
 * Causes GetNextSymbol to get this symbol next time.
 *
 * Arguments:
 * sz, string buffer for symbol
 *
 * Returns:
 * 0 - if successful
 * 1 - if unsuccessful
 *
 * Error Codes:
 * 1 - tried to unget two symbols in a row
 *
 * History:
 * 1/92 - initial implementation -- SteveBl
 *
 **/

static int UngetSymbol( CHAR sz[])
{
    if ( fUseSavedSymbol )
    {
        return 1;   // can only unget one symbol
    }
    fUseSavedSymbol = 1;     
    CopyMemory( szSavedSymbol, sz, min( sizeof( szSavedSymbol) - 1, lstrlenA( sz)));
    szSavedSymbol[ sizeof( szSavedSymbol) - 1] = '\0';
    return( 0);
}

/**
 * Function: GetNextSymbol
 * Retrieves the next symbol from the file f.
 * Whitespace and comments are removed.
 * Comments are delimited by either c type comments or
 * # (in which case comment extends until end of line)
 * If the fUseSavedSymbol flag is set then it gets its symbol
 * from szSavedSymbol instead of the file.
 *
 * Arguments:
 * sz - string buffer for next symbol
 * n  - size of buffer
 * f  - handle to the input file
 *
 * Returns:
 * 0 if successful with symbol in sz
 * 1 if unsuccessful (sz undefined)
 *
 * Error Codes:
 * 1 - eof
 *
 * History:
 * 1/92 - initial implementation -- SteveBl
 **/

static int GetNextSymbol( CHAR sz[], unsigned n, FILE *f)
{
    unsigned c = 0;
    CHAR ch, chLast;

    if ( fUseSavedSymbol )
    {
        CopyMemory( sz, szSavedSymbol, min( (int)n, lstrlenA( szSavedSymbol) + 1));
        sz[ n == 0 ? 0 : n - 1] = '\0';
        fUseSavedSymbol = FALSE;
        return 0;
    }

    do
    {
        if (feof(f)) return 1;
            ch = (CHAR) getc(f);
        if (ch == '\n')
            ++*piLineNumber;
    }
    while ((ch == ' ') ||
           (ch == '\n') ||
           (ch == '\t') ||
           (ch == '\f') ||
           (ch == '\r') ||
           (ch == (CHAR)-1));

    if (ch == '#') // commented rest of line
    {
        do
        {
            if (feof(f))
            {
                return 1;
            }
        ch = (CHAR) getc(f);
        } while (ch != '\n');

        ++*piLineNumber;
        return GetNextSymbol( sz, n, f);
    }

    if (ch == '"') // it is a label, parse to the next quote
    {
        do
        {
            if (c<n)
            {
                sz[c++]=ch; // write all but the last quote
            }

            if (feof(f))
            {
                return 1;
            }
            ch = (CHAR)getc(f);

            if (ch == '\n')
            {
                return 1;
            }
        } while (ch != '"');

        if (c<n)
        {
            sz[ c++] = '\0';
        }
        else
        {
            sz[ n == 0 ? 0 : n - 1] = '\0';
        }
        return 0;
    }

    if (ch == '/') // possible comment
    {
        if (feof(f))
        {
            return 1;
        }
        ch = (CHAR) getc(f);

        if (ch == '/') // commented rest of line
        {
            do
            {
                if (feof(f))
                {
                    return 1;
                }
                ch = (CHAR) getc(f);
            } while (ch != '\n');

            ++*piLineNumber;
            return( GetNextSymbol( sz, n, f));
        }

        if (ch == '*') // commented until */
        {
            if (feof(f))
            {
                return 1;
            }
            ch = (CHAR) getc(f);

            if (ch == '\n')
            {
                ++*piLineNumber;
            }

            do
            {
                chLast = ch;
                if (feof(f))
                {
                    return 1;
                }
                ch = (CHAR) getc(f);

                if (ch == '\n')
                    ++*piLineNumber;
            } while (!(chLast == '*' && ch == '/'));
            return( GetNextSymbol( sz, n, f));
        }
        ungetc(ch, f);
    }
    // finally found the beginning of a symbol
    if (ch < '0' || (ch > '9' && ch < '@')
        || (ch > 'Z' && ch < 'a') || ch > 'z')
    {
        if (c<n)
        {
            sz[c++] = ch;
        }
        if (c<n)
        {
            sz[c] = '\0';
        }
        else
        {
            sz[ n == 0 ? 0 : n - 1] = 0;
        }
        return 0;
    }

    do
    {
        if (c<n)
        {
            sz[c++]=ch;
        }
        if (feof(f))
        {
            return 0;
        }
        ch = (CHAR) getc(f);
    } while((ch >= '0' && ch <= '9') ||
            (ch >= '@' && ch <= 'Z') ||
            (ch >= 'a' && ch <= 'z'));
    ungetc(ch, f);

    if (c<n)
    {
        sz[c] = '\0';
    }
    else
    {
        sz[ n == 0 ? 0 : n - 1] = '\0';
    }
    return 0;
}

/**
 * Function: ParseBlock
 *    Parses a block of a custom resource description from just after the
 *    first curly braces { to just after the closing curly braces } .
 *    It returns the size of the block it just parsed (in bytes).
 *
 * Arguments:
 * f, handle to an open description file
 * ppCRT, pointer to a pointer to the next Custom Resource Template node.
 *
 * Returns:
 * Updated pointer to the next Custom Resource Template node.
 * Number of bytes in this block.
 * (<0 if there was an error)
 *
 * Error Codes:
 * -1 - Syntax error
 * -2 - Unexpected end of file
 * -3 - out of memory
 *
 * History:
 * 1/92 - initial implementation -- SteveBl
 */

static int ParseBlock( FILE *f, FPCUSTRESTEMPLATE   * ppCRT)
{
    int c = 0; // size of the whole block
    int n = 0; // size of the current item
    int i;  //scratch variable
    int fUnsigned;
    int fLong;
    int iType; // type of the current item
    int nElements; // size of the array (if one exists)
    CHAR szSymbol[SYMBOLSIZE], sz[SYMBOLSIZE];
    CUSTRESTEMPLATE far *  pFirst,
        // saves the first one so we know where to count
        // from in case of an array
        far *pTemp, far *pEnd;
    int fMerge = 0;
        // it's only ok to merge after the first element has been written

    while (1)
    {
        pFirst = *ppCRT;

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
        {
            return -2;
        }

        if (szSymbol[0] == '}')
        {
            return c;
        }

        if ( ! lstrcmpiA( "near", szSymbol) )
        { // near * type
            if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
            {
                return -2;
            }

            if (szSymbol[0]!='*')
            {
                return -1;
            }
            // may want to check for a legal type here
            do
            {
                if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                {
                    return -2;
                }
            } while ((szSymbol[0] != '[') &&
                     (szSymbol[0] != '}') &&
                     (szSymbol[0] != ','));

            UngetSymbol(szSymbol);
            n = 2;
            iType = NOTLOCALIZABLE;

            if (AddStructureElement(iType, n, ppCRT, fMerge))
            {
                return -3;
            }
        }
        else
        {
            if ( ! lstrcmpiA( "far", szSymbol) )
            { // far * type
                if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                {
                    return -2;
                }

                if (szSymbol[0] != '*')
                {
                    return -1;
                }
                // may want to check for a legal type here
                do
                {
                    if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                    {
                        return -2;
                    }
                } while ((szSymbol[0] != '[') &&
                         (szSymbol[0] != '}') &&
                         (szSymbol[0] != ','));

                UngetSymbol(szSymbol);
                n = 4;
                iType = NOTLOCALIZABLE;

                if(AddStructureElement(iType, n, ppCRT, fMerge))
                {
                    return -3;
                }
            }
            else
            {
        
                if (szSymbol[0] == '*')
                { // * type
                    // may want to check for a legal type here
                    do
                    {
                        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                        {
                            return -2;
                        }
                    } while ((szSymbol[0] != '[') &&
                             (szSymbol[0] != '}') &&
                             (szSymbol[0] != ','));

                    UngetSymbol(szSymbol);
                    n = 2;
                    iType = NOTLOCALIZABLE;

                    if(AddStructureElement(iType, n, ppCRT, fMerge))
                    {
                        return -3;
                    }
                }
                else
                {
                    if (szSymbol[0] == '{')
                    {
                        n = ParseBlock(f, ppCRT);

                        if (n<0)
                        {
                            return n;
                        }
                    }
                    else
                    { //it must be in our list of types
                        fUnsigned = 0;
                        fLong = 0;

                        if ( ! lstrcmpiA( "UNSIGNED", szSymbol) )
                        { // unsigned
                            if ( GetNextSymbol( sz, sizeof( sz), f) )
                            {
                                return -2;
                            }

                            if (sz[0] == '[' || sz[0] == ',')
                            {
                                UngetSymbol(sz);
                            }
                            else
                            {
                                lstrcpyA( szSymbol, sz);

                                if ( lstrcmpiA( sz, "SHORT")
                                  && lstrcmpiA( sz, "LONG")  
                                  && lstrcmpiA( sz, "CHAR")  
                                  && lstrcmpiA( sz, "TCHAR") 
                                  && lstrcmpiA( sz, "INT") )
                                {
                                    // must be followed by one of these
                                    return -1;
                                }
                            }
                            fUnsigned = 1;
                        }
                        else
                        {
                            if ( ! lstrcmpiA( "SIGNED", szSymbol) )
                            { // signed
                                if ( GetNextSymbol( sz, sizeof( sz), f) )
                                {
                                    return -2;
                                }

                                if (sz[0] == '[' || sz[0] == ',')
                                {
                                    UngetSymbol(sz);
                                }
                                else
                                {
                                    lstrcpyA( szSymbol, sz);

                                    if ( lstrcmpiA( sz, "SHORT") 
                                      && lstrcmpiA( sz, "LONG")  
                                      && lstrcmpiA( sz, "CHAR")  
                                      && lstrcmpiA( sz, "TCHAR") 
                                      && lstrcmpiA( sz, "INT") )
                                    {
                                        // must be followed by one of these
                                        return -1;
                                    }
                                }
                            }
                        }

                        if ( ! lstrcmpiA( "SHORT", szSymbol) )
                        { // short
                            if ( GetNextSymbol( sz, sizeof( sz), f) )
                            {
                                return -2;
                            }

                            if (sz[0] == '[' || sz[0] == ',')
                            {
                                UngetSymbol(sz);
                            }
                            else
                            {
                                lstrcpyA( szSymbol, sz);
                
                                if ( lstrcmpiA( sz, "INT") )
                                {
                                    // must be followed by one of these
                                    return -1;
                                }
                            }
                        }
                        else
                        {
                            if ( ! lstrcmpiA( "LONG", szSymbol) )
                            { // long
                                if ( GetNextSymbol( sz, sizeof( sz), f) )
                                {
                                    return -2;
                                }

                                if (sz[0] == '[' || sz[0] == ',')
                                {
                                    UngetSymbol(sz);
                                }
                                else
                                {
                                    lstrcpyA( szSymbol, sz);

                                    if ( lstrcmpiA( sz, "INT") 
                                      && lstrcmpiA( sz, "DOUBLE"))
                                    {
                                        // must be followed by one of these
                                        return -1;
                                    }
                                }
                                // BUG! - this code allows UNSIGNED LONG DOUBLE
                                // which is an illegal type in c.  But it's not
                                // a serious bug so I'll leave it.
                                fLong = 1;
                            }
                        }

                        i = sizeof(rgTypeSizes)/sizeof(TYPESIZES);

                        do
                        {
                            --i;
                        } while ( lstrcmpiA( szSymbol, rgTypeSizes[i].szType) && i);

                        if ( lstrcmpiA( szSymbol, rgTypeSizes[i].szType) )
                        {
                            return -1; // type not found in the list
                        }

                        if (fLong)
                        {
                            n = rgTypeSizes[i].iLongSize;
                        }
                        else
                        {
                            n = rgTypeSizes[i].iShortSize;
                        }

                        iType = rgTypeSizes[i].iType;

                        if (fUnsigned)
                        {
                            iType+=LT_UNSIGNED;
                        }

                        if ( lstrcmpA( szSymbol, rgTypeSizes[i].szType) )
                        {
                            iType = NOTLOCALIZABLE;  // type was not in all caps
                        }

                        if ( lstrcmpiA( szSymbol, "CHAR")  == 0
                          || lstrcmpiA( szSymbol, "TCHAR") == 0
                          || lstrcmpiA( szSymbol, "WCHAR") == 0 )
                        { // check for a string

                            lstrcpyA( szDHW, szSymbol);   // So can be used later

                            if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                            {
                                return -2;
                            }

                            if (szSymbol[0] == '[') // we have a string
                            {
                                if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                                {
                                    return -2;
                                }

                                if (szSymbol[0] == ']') // null terminated string
                                {
                                    n = 0;

                                    if (iType != NOTLOCALIZABLE)
                                    {
                                        if ( lstrcmpiA( szDHW, "CHAR") == 0 )
                                        {
                                            iType += LT_SZ-LT_CHAR;
                                        }
                                        else if ( lstrcmpiA( szDHW,
                                                             "WCHAR") == 0 )
                                        {
                                            iType += LT_WSZ-LT_WCHAR;
                                        }
                                        else
                                        {
#ifdef RLRES32
                                            iType += LT_WSZ-LT_WCHAR;
#else
                                            iType += LT_SZ-LT_CHAR;
#endif
                                        }
                                    }
                                    else
                                    {
                                        if ( lstrcmpiA( szDHW, "CHAR") == 0 )
                                        {
                                            iType = NOTLOCALIZABLESZ;
                                        }
                                        else if ( lstrcmpiA( szDHW,
                                                             "WCHAR") == 0 )
                                        {
                                            iType = NOTLOCALIZABLEWSZ;
                                        }
                                        else
                                        {
#ifdef RLWIN32
                                            iType = NOTLOCALIZABLEWSZ;
#else
                                            iType = NOTLOCALIZABLESZ;
#endif
                                        }
                                    }
                                }
                                else
                                {
                                    i = atoi(szSymbol);

                                    if (i<1)
                                    {
                                        return -1;
                                    }
                                    n *= i;

                                    if (iType != NOTLOCALIZABLE)
                                    {
                                        if ( lstrcmpiA( szDHW, "CHAR") == 0 )
                                        {
                                            iType += LT_STRING-LT_CHAR;
                                        }
                                        else if ( lstrcmpiA( szDHW,
                                                           "WCHAR") == 0 )
                                        {
                                            iType += LT_WSTRING-LT_WCHAR;
                                        }
                                        else
                                        {
#ifdef RLRES32
                                            iType += LT_WSTRING-LT_WCHAR;
#else
                                            iType += LT_STRING-LT_CHAR;
#endif
                                        }
                                    }

                                    if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
                                    {
                                        return -2;
                                    }

                                    if (szSymbol[0] != ']')
                                    {
                                        return -1;
                                    }
                                }
                            }
                            else
                            {
                                UngetSymbol(szSymbol);
                            }
                        }

                        if(AddStructureElement(iType, n, ppCRT, fMerge))
                        {
                            return -3;
                        }
                    }
                }
            }
        }

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
        {
            return -2;
        }

        while (szSymbol[0] == '[')
        {// we have an array
            if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
            {
                return -2;
            }

            if ((szSymbol[0] < '0' || szSymbol[0] > '9') && szSymbol[0] != ']')
            {
                return -1;
            }

            nElements = atoi(szSymbol);

            if (nElements < 1)
            {
                return -1;
            }

            if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
            {
                return -2;
            }

            if (szSymbol[0] != ']')
            {
                return -1;
            }

            pEnd = *ppCRT;

            if (pEnd != pFirst)
            {
                for (i=nElements-1;i--;)
                {
                    pTemp = pFirst;

                    do
                    {
                        pTemp = pTemp->pNext;
                        AddStructureElement(pTemp->iType,
                                            pTemp->uSize,
                                            ppCRT,
                                            0);
                    } while (pTemp != pEnd);
                }
            }

            if ( GetNextSymbol( szSymbol, sizeof( szSymbol), f) )
            {
                return -2;
            }
        }
        c += n;

        if (szSymbol[0] == '}')
        {
            return c;
        }

        if (szSymbol[0] != ',')
        {
            return -1;
        }
        fMerge = 1;
    }
}

//+-------------------------------------------------------------------------
//
// Function:    LoadCustResDescriptions, Public
//
// Synopsis:    Loads the Cusutom Resource Descriptions defined in the RDF
//              files, to all the tokenize to parse them.
//
//
// Arguments:   [szFileName]    The RDF file containing the resource
//              descriptions.
//
//
// Effects:     The custom resources are loaded into a global list of
//              resource descriptions, and used by ReadWinRes to tokenize
//              the particular custom resources
//
// Returns:     -1  Error Condition
//               1   Resource descrptions loaded
//
//
//
//
// Modifies:    [pCustResList]  Global list of Custom resource descriptions.
//
// History:
//              16-Oct-92   Created     TerryRu
//
//
// Notes:       ParseResourceDescriptionFile is the function called to
//              actually load the descriptions resources.
//
//--------------------------------------------------------------------------

int LoadCustResDescriptions( CHAR *szRDFs)
{
    FILE  *fRdf = NULL;
    CHAR   szCurRDF[MAXFILENAME] = "";
    int    i1, i2;

    if (szRDFs && *szRDFs)    //... resource description file name given?
    {
        i1 = 0;

        while (szRDFs[i1] == ' ' && szRDFs[i1] != 0)
        {
            ++i1;
        }

        while (szRDFs[i1] != 0)
        {
            i2 = 0;

            while (szRDFs[i1] != ' ' && szRDFs[i1] != 0)
            {
                szCurRDF[i2++] = szRDFs[i1++];
            }
            szCurRDF[i2] = 0;

            while (szRDFs[i1] == ' ' && szRDFs[i1] != 0)
            {
                ++i1;
            }

            if (fRdf = FOPEN( szCurRDF, "rt"))
            {
                ParseResourceDescriptionFile(fRdf, &i2);
                FCLOSE(fRdf);
            }
            else
            {
                return(-1);
            }
        }
    }
    return(1);     //... Success
}



/**
  * Function: ParseResourceDescriptionFile
  * Parses a resource description block creating a structure definining
  * all recognized custom resources.
  *
  * Arguments:
  * ResourceDescriptionFile, handle to an open description file
  *              (or the beginning of a description block)
  * piErrorLine, pointer to an integer that will hold the line number
  *     an error occured at in the event that a parsing error is
  *     encountered.
  *
  * Returns:
  * 0 if successful
  *    !0 if some error was encountered
  * *piErrorLine will hold the line number for the error
  *
  * Error Codes:
  * -1 - Syntax error
  * -2 - Unexpected end of file
  * -3 - out of memory
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  *
  **/

int  ParseResourceDescriptionFile(

FILE *pfResourceDescriptionFile,
int  *piErrorLine)
{
    CUSTRESNODE far * lpCustResNode = NULL;
    CUSTRESTEMPLATE far * pCustResTemplate;
    static CHAR szSymbol[SYMBOLSIZE];
/*************************************************************************
    TCHAR *szResourceType;
*************************************************************************/
    int iResourceType;
    int r;
    BOOL fBeginList = TRUE;

    // position lpCustResNode at end of the custom reosource list.
    if ( lpCustResNode == NULL )
    {
        pCustResList = lpCustResNode =
            (CUSTRESNODE far *)FALLOC( sizeof( CUSTRESNODE));
    }
    else
    {
        fBeginList    = FALSE;
        lpCustResNode = pCustResList;

        while ( lpCustResNode->pNext )
        {
            lpCustResNode = lpCustResNode->pNext;
        }
    }
    piLineNumber  = piErrorLine;
    *piLineNumber = 1;


    if ( GetNextSymbol( szSymbol, 
                        sizeof( szSymbol), 
                        pfResourceDescriptionFile) )
    {
        return 0; // file is empty
    }

    while ( lstrcmpiA( szSymbol, "END") )
    {
        if ( szSymbol[0] != '<' )
        {
            return -1; // must begin with a resource number
        }

        if ( fBeginList == FALSE )
        {
            lpCustResNode->pNext =
                (CUSTRESNODE far *)FALLOC( sizeof( CUSTRESNODE));
            lpCustResNode  = lpCustResNode->pNext;
        }
        fBeginList = FALSE;

        // intialize nodes fields to Zero defaults.

        memset( lpCustResNode, 0, sizeof( CUSTRESNODE));

                                //... Next symbol will be the resource type

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), pfResourceDescriptionFile) )
        {
            return -2; // need a number
        }
                                //... Is type a string or a number?
        if ( szSymbol[0] != '"' )
        {                       //... number
            iResourceType = GetResourceType( szSymbol);

            if ( iResourceType < 0 )
            {
                return -1;
            }
            lpCustResNode->wTypeID   = (WORD)iResourceType;
            lpCustResNode->bTypeFlag = TRUE;
        }
        else                    //... string
        {
            UINT uChars = lstrlenA( szSymbol+1) + 1;

            lpCustResNode->pszType = (TCHAR *)FALLOC( MEMSIZE( uChars));

            if ( lpCustResNode->pszType == NULL )
            {
                return -3;
            }
            _MBSTOWCS( lpCustResNode->pszType, szSymbol+1, uChars, (UINT)-1);
            lpCustResNode->bTypeFlag = FALSE;
        }

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), pfResourceDescriptionFile) )
        {
            return -2;
        }
/*************************************************************************
                                //... Is a name provided?

        if (szSymbol[0] != '>' && szSymbol[0] != ',')
        {
            return -1; // must have closing symbol for resource id #
        }

        if (szSymbol[0] == ',')
        {                       //... Yes, name is provided
            if (iResourceType >= 0)
            {
                lpCustResNode->wNameID = (WORD)iResourceType;
                lpCustResNode->bNameFlag = TRUE;
            }
            else
            {
                lpCustResNode->wTypeID = 0;
                lpCustResNode->wNameID = IDFLAG;
                lpCustResNode->pszType = szResourceType;
                lpCustResNode->bTypeFlag = 0;
            }
        }
        else
        {
            if (iResourceType >= 0)
            {
                lpCustResNode->wNameID = iResourceType;
            }
            else
            {
                lpCustResNode->wNameID = 0;
                lpCustResNode->pszName = szResourceType;
                lpCustResNode->bNameFlag = 0xff;
            }

            if (GetNextSymbol(szSymbol, sizeof( szSymbol), pfResourceDescriptionFile))
            {
                return -2;
            }

            if (szSymbol[0] != '"')
            {
                r = GetResourceType(szSymbol);
                lpCustResNode->wTypeID = (WORD)r;
            }
            else
            {
                lpCustResNode->wTypeID = 0;
                lpCustResNode->bTypeFlag = 0;
        szResourceType = (TCHAR *)FALLOC(
                                       MEMSIZE( (strlen( szSymbol + 1) + 1)));
        strcpy((PCHAR)szResourceType, szSymbol+1);
                lpCustResNode->pszType = szResourceType;
            }
            if (GetNextSymbol(szSymbol, sizeof( szSymbol), pfResourceDescriptionFile))
            {
                return -2;
            }
            if (szSymbol[0] != '>')
            {
                return -1;
            }
        }
*************************************************************************/

        // Start the template by creating a single empty node
        // This is necessary for handling recursive arrays.
        // There might be a way around it but this works and it is easy.
        lpCustResNode->pTemplate=
                       (FPCUSTRESTEMPLATE)FALLOC( sizeof( CUSTRESTEMPLATE));

        if (!lpCustResNode->pTemplate)
        {
            return -3;
        }

        pCustResTemplate = (lpCustResNode->pTemplate);
        pCustResTemplate->iType = NOTLOCALIZABLE;
        pCustResTemplate->uSize = 0;
        pCustResTemplate->pNext = NULL;

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), pfResourceDescriptionFile) )
        {
            return -2;
        }

        if (szSymbol[0] != '{')
        {
            return -1; // must have at least one block
        }

        r = ParseBlock( pfResourceDescriptionFile,
                       (FPCUSTRESTEMPLATE *)&pCustResTemplate);
        if (r < 0)
        {
            return r;
        }

        // Now remove that initial empty node (not necessary but cleaner)
        pCustResTemplate = lpCustResNode->pTemplate;
        lpCustResNode->pTemplate = pCustResTemplate->pNext;
        RLFREE( pCustResTemplate);

        // the last thing the ParseBlock routine should have read in was a
        // closing brace to close the block.  The next thing we read should
        // either be "end", the end of file, or a new resource definition.

        if ( GetNextSymbol( szSymbol, sizeof( szSymbol), pfResourceDescriptionFile) )
        {
            return 0; // reached end of file
        }
    }
    return 0;
}

/**
  * Function: GetCustomResource
  * Reads a custom resource from the resource file and returns a pointer
  * to the resource data.
  *
  * Arguments:
  * inResFile, handle to an open resource file
  * lSize, size in bytes of the resource
  * ppCustomResource, address of a pointer to an empty custom resource
  *           structure
  * ResHeader, resource header for this resource
  *
  * Returns:
  * if resource has a definition:
  *     returns 0 and
  *     inResFile containing a linked list of the localizable resource data
  * else
  *     returns 1
  *
  * Error Codes:
  * 0 - no error -- resource was retrieved
  * 1 - resource is not an understood custom resource (use another method
  *     or ignore the resource)
  * 2 - some error occured parsing the resource
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  *
  **/

int  GetCustomResource(

FILE              *inResFile,
DWORD             *plSize,
FPCUSTOM_RESOURCE *ppCustomResource,
RESHEADER          ResHeader)
{
    CUSTOM_RESOURCE far *lpCustomResource;
    CUSTRESNODE     far *pCRN;
    CUSTRESTEMPLATE far *pCRT;
    void            far * pData;
    BOOL            fBeginList = TRUE;


    if ( ! (pCRN = MatchResource( ResHeader)) )
    {
        return 1; // resource doesn't have a match
    }

    *ppCustomResource = lpCustomResource =
                     (CUSTOM_RESOURCE far *)FALLOC( sizeof( CUSTOM_RESOURCE));
    pCRT = pCRN->pTemplate;

    while ( *plSize )
    {
        // allocate new custome resrouce structure

        if ( fBeginList == FALSE )
        {
            lpCustomResource->pNext =
                     (CUSTOM_RESOURCE far *)FALLOC( sizeof( CUSTOM_RESOURCE));
            lpCustomResource = lpCustomResource->pNext;
        }

        if ( ! lpCustomResource )
        {
            return 2; // no memory
        }
        pData = GetResData( pCRT->iType, pCRT->uSize, inResFile, plSize);

        if ( ! pData )
        {
            return 2; //GetResData crapped out
        }
        lpCustomResource->pData = pData;
        lpCustomResource->pNext = NULL;
        fBeginList = FALSE;

        pCRT = pCRT->pNext;

        if (!pCRT)
        {
            pCRT = pCRN->pTemplate; //begin next structure
        }
    }
    return 0;
}

/**
  * Function: TokCustomResource
  * Writes custom resource information to the token file.
  *
  * Arguments:
  * TokFile, handle to the token file
  * ResHeader, resource header for this resource
  * ppCustomResource, address of a pointer to a filled out
  *           custom resource structure
  *
  * Returns:
  * Data written to TokFile
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  *
  * 01/93 - Add support for var length Token texts      MHotchin
  *
  **/

void TokCustomResource(

FILE              *TokFile,
RESHEADER          ResHeader,
FPCUSTOM_RESOURCE *ppCustomResource)
{
    CUSTRESNODE     far *pCRN;
    CUSTRESTEMPLATE far *pCRT;
    CUSTOM_RESOURCE far *lpCustomResource;
    TCHAR       sz[ MAXTEXTLEN];
    TOKEN               Token;
    WORD                wID = 0;
    int                 l;


    lpCustomResource = *ppCustomResource;

    if (!(pCRN = MatchResource(ResHeader)))
    {
        QuitT( IDS_ENGERR_09, (LPTSTR)IDS_NOCUSTRES, NULL);
    }

    pCRT = pCRN->pTemplate;

    while ( lpCustomResource )
    {
        if ( pCRT->iType != NOTLOCALIZABLE
          && pCRT->iType != NOTLOCALIZABLESZ
          && pCRT->iType != NOTLOCALIZABLEWSZ )
        {
            if ( PutTextData( lpCustomResource->pData,
                              pCRT->iType,
                              pCRT->uSize,
                              sz,
                              sizeof( sz)) )
            {
                QuitT( IDS_ENGERR_09, (LPTSTR)IDS_CUSTRES, NULL);
            }
            /* UNCOMMENT THIS WHEN STRING TYPES ARE SUPPORTED IN TOKENS
             **********
             Token.szType[0] = '\0';
             if (!ResHeader.bTypeFlag)
             {
             Token.wType = IDFLAG;
             _tcscpy( Token.szType, ResHeader.pszType);
             }
             else
             **********
             */
            Token.wType = ResHeader.wTypeID;
            Token.wName = ResHeader.wNameID;

            if ( ResHeader.bNameFlag == IDFLAG )
            {
                lstrcpy( Token.szName, ResHeader.pszName);
            }
            else
            {
                Token.szName[0] = '\0';
            }
            Token.wID = wID++;
            Token.wReserved = (gbMaster ? ST_NEW : ST_TRANSLATED);
            Token.wFlag = 0;

            if ( (pCRT->iType == LT_UNSIGNED + LT_STRING)
              || (pCRT->iType == LT_STRING)
              || (pCRT->iType == LT_WSTRING) )
            {
                l = pCRT->uSize;
                while( l > 1 && ! sz[l-1])
                {
                    --l; // skip any trailing nulls
                }
                Token.szText = BinToText( sz, l);
            }
            else
            {
                Token.szText = BinToText( sz, lstrlen( sz));
            }
            PutToken( TokFile, &Token);
            RLFREE( Token.szText);                                                 
        }
        pCRT = pCRT->pNext;

        if ( ! pCRT )
        {
            pCRT = pCRN->pTemplate; //begin next structure
        }
        lpCustomResource = lpCustomResource->pNext;
    }
}

/**
  * Function: PutCustomResource
  * Writes custom resource information to the output resource
  * file.  If the information is localizable it is retrieved from the
  * indicated token file.
  *
  * Arguments:
  * OutResFile, handle to the target resource file
  * TokFile, handle to the token file
  * ResHeader, resource header for this resource
  * ppCustomResource, address of a pointer to a filled out
  *           custom resource structure
  *
  * Returns:
  * CustomResource written to OutResFile
  *
  * Error Codes:
  * none
  *
  * History:
  * ??/??       Created by ???
  *
  * 01/93       Added support for var length token texts.       MHotchin
  *
  **/

void PutCustomResource(

FILE              *OutResFile,
FILE              *TokFile,
RESHEADER          ResHeader,
FPCUSTOM_RESOURCE *ppCustomResource)
{
    CUSTRESNODE     far *pCRN = NULL;
    CUSTRESTEMPLATE far *pCRT = NULL;
    CUSTOM_RESOURCE far *lpCustomResource = NULL;
    TCHAR       sz[ MAXTEXTLEN] = TEXT("");
    void            far *pData = NULL;
    TOKEN           Token;
    DWORD           lSize = 0;
    fpos_t          ResSizePos;
    WORD            wID=0;
    unsigned n;


    lpCustomResource = *ppCustomResource;

    if ( ! (pCRN = MatchResource( ResHeader)) )
    {
        QuitT( IDS_ENGERR_09, (LPTSTR)IDS_NOCUSTRES, NULL);
    }

    if ( PutResHeader( OutResFile, ResHeader, &ResSizePos, &lSize) )
    {
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_CUSTRES, NULL);
    }

    lSize = 0;

    pCRT = pCRN->pTemplate;

    while ( lpCustomResource )
    {
        BOOL fAlloced = FALSE;

        if ( pCRT->iType != NOTLOCALIZABLE
          && pCRT->iType != NOTLOCALIZABLESZ
          && pCRT->iType != NOTLOCALIZABLEWSZ )
        {
            /* UNCOMMENT THIS WHEN STRING TYPES ARE SUPPORTED IN TOKENS
             *
             Token.szwType[0] = '\0';
             if (!ResHeader.bTypeFlag)
             {
             Token.wType = IDFLAG;
             _tcscpy(Token.szwType, ResHeader.pszType);
             }
             else
             *
             */
            Token.wType = ResHeader.wTypeID;
            Token.wName = ResHeader.wNameID;

            if ( ResHeader.bNameFlag == IDFLAG )
            {
                lstrcpy( Token.szName, ResHeader.pszName);
            }
            else
            {
                Token.szName[0] = '\0';
            }
            Token.wID = wID++;
            Token.wFlag = 0;
            Token.wReserved =(gbMaster ? ST_NEW : ST_TRANSLATED);
            Token.szText = NULL;                                                

            if ( ! FindToken( TokFile, &Token, ST_TRANSLATED) )                      
            {
                QuitT( IDS_ENGERR_06, (LPTSTR)IDS_NOCUSTRES, NULL);
            }
            n = TextToBin( sz, Token.szText, sizeof( sz));
            RLFREE( Token.szText);                                                 

            while ( n < pCRT->uSize )
            {
                sz[n++]='\0';   // padd additional space with nulls
            }
            pData = GetTextData( pCRT->iType, pCRT->uSize, sz);

            if ( ! pData)
            {
                QuitT( IDS_ENGERR_09, (LPTSTR)IDS_CUSTRES, NULL);
            }
            fAlloced = TRUE;
        }
        else
        {
            pData = lpCustomResource->pData;
            fAlloced = FALSE;
        }

        lSize += PutResData( pData, pCRT->iType, pCRT->uSize, OutResFile);

        if ( fAlloced )
        {
            RLFREE( pData);
        }
        pCRT = pCRT->pNext;

        if ( ! pCRT )
        {
            pCRT = pCRN->pTemplate; //begin next structure
        }
        lpCustomResource = lpCustomResource->pNext;
    }

    if( ! UpdateResSize( OutResFile, &ResSizePos, lSize) )
    {
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_CUSTRES, NULL);
    }
}

/**
  * Function: ClearCustomResource
  * Frees memory allocated to a custom resource list.
  *
  * Arguments:
  * ppCustomResource, address of a pointer to a filled out
  *           custom resource structure
  *
  * Returns:
  * Memory allocatd to pCustomResource is freed.
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

void ClearCustomResource( FPCUSTOM_RESOURCE *ppCustomResource)
{
    CUSTOM_RESOURCE far *pCR;
    CUSTOM_RESOURCE far *lpCustomResource;

    lpCustomResource = *ppCustomResource;

    while ( lpCustomResource )
    {
        pCR = lpCustomResource;

        RLFREE( pCR->pData);
        
        lpCustomResource = pCR->pNext;
        RLFREE( pCR);
    }
}

/**
  * Function:
  * Tries to find a custom resource that matches the resource specified
  * in the resource header.
  *
  * Arguments:
  * Resheader, resource header.
  *
  * Returns:
  * pointer to the resource template (or null)
  *
  * Error Codes:
  * null -- resource not found
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

static CUSTRESNODE far * MatchResource( RESHEADER Resheader)
{
    CUSTRESNODE far *pCR = pCustResList;


    while ( pCR )
    {
        if ( (0==pCR->bTypeFlag) == (0==Resheader.bTypeFlag) )
        {
            if ( ((!pCR->bTypeFlag) && ! _tcscmp( pCR->pszType,
                                                  Resheader.pszType)) 
              || ((pCR->bTypeFlag) && pCR->wTypeID == Resheader.wTypeID))
            { // TYPES MATCH
/*************************************************************************

                if (pCR->wNameID == IDFLAG)
                {
                    pCRTypeMatch = pCR;
                }
                else
                {
                    if ((0==pCR->bNameFlag) == (0==Resheader.bNameFlag))
                    {
                        if (((!pCR->bNameFlag) 
                          && ! _tcscmp(pCR->pszName, Resheader.pszName)) ||
                            ((pCR->bNameFlag) &&
                             pCR->wNameID == Resheader.wNameID))
                        { // NAMES MATCH
*************************************************************************/
                            return( pCR); // an exact match
/*************************************************************************
                        }
                    }
                }
*************************************************************************/
            }
        }
        pCR = pCR->pNext;
    }
    return( NULL); // either only the type matched or nothing matched
}

/**
  * Function: GetResData
  * Reads data of the specified type and size from a resource file.
  *
  * Arguments:
  * wType, type of this resource (from resource template)
  * uSize, size in bytes of resource (ignored for null terminated strings)
  * f, resource file
  * lSize, pointer to the number of bytes left in the resource
  *
  * Returns:
  * pointer to the data, lSize is updated
  *
  * Error Codes:
  * null pointer on error
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

static void far * GetResData(

enum LOCALIZABLE_TYPES wType,
unsigned uSize,
FILE    *f,
DWORD   *lSize)
{
    BYTE *pData = NULL;
    int   i     = 0;
    

    if ( wType % LT_UNSIGNED == LT_SZ
      || wType == NOTLOCALIZABLESZ
      || wType % LT_UNSIGNED == LT_WSZ
      || wType == NOTLOCALIZABLEWSZ )
    { // read in the null terminated string
        TCHAR ch = IDFLAG;


        pData = FALLOC( MEMSIZE(*lSize) );

        while ( *lSize && ch != TEXT('\0') )
        {
#ifdef RLWIN32

            if ( wType % LT_UNSIGNED == LT_WSZ
              || wType == NOTLOCALIZABLEWSZ )
            {
                ((TCHAR *)pData)[i] = ch = GetWord( f, lSize);
            }
            else
            {
                char  chTmp[2];


                chTmp[0] = GetByte( f, lSize);

                if ( IsDBCSLeadByte( chTmp[0]) )
                {
                    chTmp[1] = GetByte( f, lSize);
                    _MBSTOWCS( &((TCHAR *)pData)[i], chTmp, 1, 2);
                }
                else
                {
                    _MBSTOWCS( &((TCHAR *)pData)[i], chTmp, 1, 1);
                }
                ch = ((TCHAR *)pData)[i];
            }
#else  //RLWIN32

            *(pData+i) = ch = GetByte( f, lSize);

#endif //RLWIN32

            i++;

        } // END while( *lSize ...
    }
    else
    {
        pData = FALLOC( uSize);

        if ( ! pData )
        {
            QuitA( IDS_ENGERR_11, NULL, NULL);
        }

        while (uSize-- && *lSize)
        {
            *(pData+i) = GetByte(f, lSize);
            i++;
        }
    }
    return( pData);
}

/**
  * Function: PutResData
  * Writes data of the specified type to a resource file.
  *
  * Arguments:
  * pData, pointer to data
  * wType, type of this resource (from resource template)
  * uSize, size in bytes of resource (ignored for null terminated strings)
  * f, resource file
  *
  * Returns:
  * Number of bytes written.
  *
  * Error Codes:
  * -1 - error
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

static int PutResData(

void far *pData,
enum LOCALIZABLE_TYPES wType,
unsigned  uSize,
FILE     *f)
{
    DWORD dw = 0;

    if ( wType % LT_UNSIGNED == LT_SZ
      || wType == NOTLOCALIZABLESZ
      || wType % LT_UNSIGNED == LT_WSZ
      || wType == NOTLOCALIZABLEWSZ )
    {
        // write the null terminated string

#ifdef RLWIN32

        TCHAR *pChar = (TCHAR *)pData;

        if ( wType % LT_UNSIGNED == LT_WSZ
          || wType == NOTLOCALIZABLEWSZ )
        {
            while( *pChar )
            {
                PutWord( f, *pChar, &dw);
                pChar++;
            }
            PutWord( f, 0, &dw);
        }
        else
        {
            _WCSTOMBS( szDHW, pChar, DHWSIZE, lstrlen( pChar) + 1);

            while( szDHW[ dw] )
            {
                PutByte( f, szDHW[ dw], &dw);
            }
            PutByte( f, 0, &dw);
        }

#else  //RLWIN32

        while( *((BYTE far *)pData+i) )
        {
            PutByte( f, *((BYTE far *)pData+dw), &dw);
        }
        PutByte( f, 0, &dw);

#endif //RLWIN32

    }
    else
    {
        while( dw < uSize)
        {
            PutByte( f, *((BYTE far *)pData+dw), &dw);
        }
    }
    return( (int)dw);
}

/**
  * Function: GetTextData
  * Reads data of the specified type and size from a string.
  *
  * Arguments:
  * wType, type of this resource (from resource template)
  * uSize, size in bytes of resource (ignored for null terminated strings)
  * sz,    source string (always in Unicode if in NT version of tool)
  *
  * Returns:
  * pointer to the data
  *
  * Error Codes:
  * null pointer on error
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

static void far * GetTextData(

enum LOCALIZABLE_TYPES wType,
unsigned uSize,
TCHAR    sz[])
{
    PBYTE pData = NULL;
    int   i = 0;


    if ( wType % LT_UNSIGNED == LT_WSZ
      || wType % LT_UNSIGNED == LT_SZ )
    {
        pData = FALLOC( MEMSIZE( MAXTEXTLEN));
    }
    else if ( wType % LT_UNSIGNED == LT_WSTRING
           || wType % LT_UNSIGNED == LT_STRING )

    {
        pData = FALLOC( MEMSIZE( uSize));
    }
    else
    {
        pData = FALLOC( uSize);
    }

    switch (wType)
    {
    case LT_CHAR:
    case LT_UNSIGNED+LT_CHAR:

        *pData = (BYTE) sz[0];
        break;

    case LT_WCHAR:
    case LT_UNSIGNED+LT_WCHAR:

        *((TCHAR *)pData) = sz[0];
        break;

    case LT_INTEGER:

        if ( uSize == 2 )
        {
            sscanf( (PCHAR)sz, "%Fhi", pData);
        }
        else
        {
            sscanf( (PCHAR)sz, "%Fli", pData);
        }
        break;

    case LT_UNSIGNED+LT_INTEGER:

        if ( uSize == 2 )
        {
            sscanf( (PCHAR)sz, "%Fhu", pData);
        }
        else
        {
            sscanf( (PCHAR)sz, "%Flu", pData);
        }
        break;

    case LT_FLOAT:
    case LT_UNSIGNED+LT_FLOAT:

        if ( uSize == 4 )
        {
            sscanf( (PCHAR)sz, "%Ff", pData);
        }
        else
        {
            sscanf( (PCHAR)sz, "%Flf", pData);
        }
        break;

    case LT_STRING:
    case LT_UNSIGNED+LT_STRING:
    case LT_WSTRING:
    case LT_UNSIGNED+LT_WSTRING:

        for ( i = uSize; i--; )
        {
            *((TCHAR far *)pData + i) = sz[i];
        }
        break;

    case LT_SZ:
    case LT_UNSIGNED+LT_SZ:
    case LT_WSZ:
    case LT_UNSIGNED+LT_WSZ:

#ifdef RLWIN32
        CopyMemory( pData, sz, MEMSIZE( min( lstrlen( sz) + 1, MAXTEXTLEN)));      
#else
        FSTRNCPY( (CHAR far *)pData, sz, MAXTEXTLEN);
#endif
        break;

    default:

        RLFREE( pData);
    }
    return( pData);
}

/**
  * Function: PutTextData
  * Writes data of the specified type to a string.
  *
  * Arguments:
  * pData, pointer to data
  * wType, type of this resource (from resource template)
  * uSize, size in bytes of resource (ignored for null terminated strings)
  * sz,    destination string
  * l,     length of destination string (in bytes)
  *
  * Returns:
  * 0 - no errors
  *
  * Error Codes:
  * 1 - error
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  **/

static int PutTextData(

void far *pData,
enum LOCALIZABLE_TYPES wType,
unsigned uSize,
TCHAR    sz[],
int      l)
{
    switch (wType)
    {
    case LT_CHAR:
    case LT_UNSIGNED+LT_CHAR:
    case LT_WCHAR:
    case LT_UNSIGNED+LT_WCHAR:

        CopyMemory( sz, pData, min( uSize, (UINT)l));
        break;

    case LT_INTEGER:

        if ( uSize == 2 )
        {
            wsprintf( sz, TEXT("%Fhi"), pData);
        }
        else
        {
            wsprintf( sz, TEXT("%Fli"), pData);
        }
        break;

    case LT_UNSIGNED+LT_INTEGER:

        if ( uSize == 2 )
        {
            wsprintf( sz, TEXT("%Fhu"), pData);
        }
        else
        {
            wsprintf( sz, TEXT("%Flu"), pData);
        }
        break;

    case LT_FLOAT:
    case LT_UNSIGNED+LT_FLOAT:

        if ( uSize == 4 )
        {
            wsprintf( sz, TEXT("%Ff"), pData);
        }
        else
        {
            wsprintf( sz, TEXT("%Flf"), pData);
        }
        break;

    case LT_STRING:
    case LT_UNSIGNED+LT_STRING:
    case LT_WSTRING:
    case LT_UNSIGNED+LT_WSTRING:

        CopyMemory( sz, pData, uSize);
        break;

    case LT_SZ:
    case LT_UNSIGNED+LT_SZ:

        CopyMemory( sz, pData, MEMSIZE(min( lstrlen( pData) + 1, l)));
        ((LPSTR)sz)[ l - 1] = '\0';
        break;

    case LT_WSZ:
    case LT_UNSIGNED+LT_WSZ:

        CopyMemory( sz, pData, min( MEMSIZE( lstrlen( pData) + 1), WCHARSIN( l)));
        sz[ WCHARSIN( l) - 1] = TEXT('\0');
        break;

//#ifdef RLWIN32
//    CopyMemory( sz, pData, l > 0 ? l * sizeof( TCHAR) : 0);
//#else
//    FSTRNCPY( (CHAR far *) sz, (CHAR far *)pData, l);
//#endif
        break;

    default:

        return( 1);
    }
    return( 0);
}

/**
  * Function: AddTo
  * Adds a character to a string at position c.
  * c is then incremented only if it is still less than the maximum
  * length of the target string.  This is to prevent runover.
  *
  * Arguments:
  * sz, target string
  * c,  pointer to current position value
  * lTarget, maximum length of the target string
  * ch, character to be added to the string
  */

void AddTo( CHAR *sz, int *c, int lTarget, CHAR ch)
{
    sz[*c] = ch;

    if (*c < lTarget)
    {
        (*c)++;
    }
}


#ifdef RLWIN32


void AddToW( TCHAR *sz, int *c, int lTarget, TCHAR ch)
{
    sz[*c] = ch;

    if (*c < lTarget)
    {
        (*c)++;
    }
}

/**
  * Function: BinToTextW
  * Converts a binary string to it's c representation
  * (complete with escape sequences).  If the target string is NULL,
  * space will be allocated for it.
  *
  * Arguments:
  * rgc, source string
  * lSource, length of source string
  *
  * Returns:
  * nothing
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  * 01/21/93  MHotchin - Made changes to allow this function to allocate
  *             the memory for the destination string.  If the target string
  *             is NULL, then space will be allocated for it.  The target
  *             string is returned to the caller.
  **/


UINT _MBSTOWCS( WCHAR wszOut[], CHAR szIn[], UINT cOut, UINT cIn)
{
    UINT n;


    n = MultiByteToWideChar( gProj.uCodePage,
                             MB_PRECOMPOSED,
                             szIn,
                             cIn,
                             wszOut,
                             cOut);

    return( n > 0 ? n - 1 : 0);
}

UINT _WCSTOMBS( CHAR szOut[], WCHAR wszIn[], UINT cOut, UINT cIn)
{
    UINT n;


    n = WideCharToMultiByte( gProj.uCodePage,
                             0,
                             wszIn,
                             cIn,
                             szOut,
                             cOut,
                             NULL,
                             NULL);

    return( (cIn > 0 ) ? cIn - 1 : 0);
}


WCHAR * BinToTextW(

TCHAR *szInBuf,    //... Input, binary, string
int    lSource)    //... Length of szInBuf
{
    int i;
    int cOutBufLen = 0;
    int lTarget    = 0;         //... Max length of szOutBuf
    TCHAR *szOutBuf  = NULL;    //... Output string with escape sequences


    // If the target is NULL, allocate some memory.  We set aside
    // 5% more than the source length.  MHotchin
    // chngd to 5% or 5 chars if 10% is less than 50    davewi

    lTarget = (lSource == 0) ? 0 : lSource + 1;
        
    szOutBuf = (TCHAR *)FALLOC( MEMSIZE( lTarget));

    for ( i = 0; i < lSource; i++ )
    {
        switch( szInBuf[i] )
        {
            case TEXT('\a'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('a'));
                break;

            case TEXT('\b'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('b'));
                break;

            case TEXT('\f'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('f'));
                break;

            case TEXT('\n'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('n'));
                break;

            case TEXT('\r'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('r'));
                break;

            case TEXT('\t'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('t'));
                break;

            case TEXT('\v'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('v'));
                break;

            case TEXT('\\'):

                szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                break;

            default:
            {
                TCHAR wTmp = szInBuf[i];

                if ( wTmp == 0 )
                {
                    szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 2, szOutBuf);
                    AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                    AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('0'));
                }
                else if ( (wTmp >= 0 && wTmp < 32)
                  || wTmp == 0x7f
                  || wTmp == 0xa9
                  || wTmp == 0xae )
                {
                    CHAR szt[5];

                    szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 4, szOutBuf);
                    sprintf( szt, "%#04hx", wTmp);
                    AddToW( szOutBuf, &cOutBufLen, lTarget, TEXT('\\'));
                    AddToW( szOutBuf, &cOutBufLen, lTarget, (TCHAR)(szt[0]));
                    AddToW( szOutBuf, &cOutBufLen, lTarget, (TCHAR)(szt[1]));
                    AddToW( szOutBuf, &cOutBufLen, lTarget, (TCHAR)(szt[2]));
                    AddToW( szOutBuf, &cOutBufLen, lTarget, (TCHAR)(szt[3]));
                }
                else
                {
                    szOutBuf = CheckBufSizeW( &lTarget, cOutBufLen, 1, szOutBuf);
                    AddToW( szOutBuf, &cOutBufLen, lTarget, wTmp);
                }
                break;
            }
        }
    }
    szOutBuf[ cOutBufLen] = TEXT('\0');

    return( szOutBuf);
}


#endif //RLWIN32



/** Function: atoihex
  * Converts a string containing hex digits to an integer.  String is
  * assumed to contain nothing but legal hex digits.  No error checking
  * is performed.
  *
  * Arguments:
  * sz, null terminated string containing hex digits
  *
  * Returns:
  * value of hex digits in sz
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  *
  */

int atoihex( CHAR sz[])
{
    int r = 0;
    int i = 0;
    CHAR ch;

    while (sz[i])
    {
        r *= 16;
        ch = (CHAR)toupper(sz[i++]);

        if (ch<='9' && ch>='0')
        {
            r += ch - '0';
        }
        else
        {
            if (ch <= 'F' && ch >= 'A')
            {
                r += ch - 'A' + 10;
            }
        }
    }
    return r;
}


#ifdef RLRES32

/**
  * Function: TextToBinW
  * Converts a string with c escape sequences to a true binary string.
  *
  * Arguments:
  * rgc, target string
  * sz, source string
  * l, maximum length of target string
  *
  * Returns:
  * length of target string
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  * 9/92 -- changed to UNICODE-only version -- davewi
  * 01/21/93 -- Changed to allow arb length strings     MHotchin.
  *
  **/

int TextToBinW(

WCHAR szOutBuf[],   //... Output, binary, string
WCHAR szInBuf[],    //... Input string with escape sequences
int   lTarget)      //... Max length of szOutBuf
{
    int  i = 0;
    int  c = 0;


    while ( szInBuf[ c] )
    {
        if ( szInBuf[ c] == TEXT('\\') )
        {           // escape sequence!
            c++;

            switch ( szInBuf[ c++] )
            {
                case TEXT('a'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\a'));
                    break;

                case TEXT('b'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\b'));
                    break;

                case TEXT('f'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\f'));
                    break;

                case TEXT('n'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\n'));
                    break;

                case TEXT('r'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\r'));
                    break;

                case TEXT('t'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\t'));
                    break;

                case TEXT('v'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\v'));
                    break;

                case TEXT('\''):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\''));
                    break;

                case TEXT('\"'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\"'));
                    break;

                case TEXT('\\'):

                    AddToW( szOutBuf, &i, lTarget, TEXT('\\'));
                    break;

                case TEXT('0'):
                case TEXT('1'):
                case TEXT('2'):
                {
                    CHAR szt[4];


                    szt[0] = szt[1] = szt[2] = szt[3] = '\0';

                    if ( szInBuf[c-1] == TEXT('0')
                      && (szInBuf[c]  < TEXT('0') || szInBuf[c] > TEXT('9'))
                      && szInBuf[c] != TEXT('x') && szInBuf[c] != TEXT('X') )
                    {
                                //  Must be '\0'
                        AddToW( szOutBuf, &i, lTarget, (TCHAR)0);
                    }
                    else if ( szInBuf[c] >= TEXT('0') && szInBuf[c] <= TEXT('9') )
                    {
                        szt[0] = (CHAR)(szInBuf[c-1]);
                        szt[1] = (CHAR)(szInBuf[c++]);

                        if ( szInBuf[c] >= TEXT('0') && szInBuf[c] <= TEXT('9'))
                        {
                            szt[2] = (CHAR)(szInBuf[c++]);
                        }
                        AddToW( szOutBuf, &i, lTarget, (TCHAR)atoi( szt));
                    }
                    else if ( szInBuf[c] == TEXT('X')
                           || szInBuf[c] == TEXT('x') )
                    {
                        c++;
                        szt[0] = (CHAR)(szInBuf[c++]);
                        szt[1] = (CHAR)(szInBuf[c++]);
                        AddToW( szOutBuf, &i, lTarget, (TCHAR)atoihex( szt));
                    }
                    else
                    {
                        QuitT( IDS_INVESCSEQ, &szInBuf[c-2], NULL);
                    }
                    break;
                }
                case TEXT('x'):
                case TEXT('X'):
                {
                    CHAR szt[4];


                    szt[0] = szt[1] = szt[2] = szt[3] = '\0';

                    if ( (szInBuf[c] <= TEXT('9') && szInBuf[c] >= TEXT('0'))
                      || (szInBuf[c] >= TEXT('A') && szInBuf[c] <= TEXT('F'))
                      || (szInBuf[c] >= TEXT('a') && szInBuf[c] <= TEXT('f')) )
                    {
                        szt[0] = (CHAR)(szInBuf[c++]);

                        if (  (szInBuf[c] <= TEXT('9')
                            && szInBuf[c] >= TEXT('0'))
                          ||  (szInBuf[c] >= TEXT('A')
                            && szInBuf[c] <= TEXT('F'))
                          ||  (szInBuf[c] >= TEXT('a')
                            && szInBuf[c] <= TEXT('f')) )
                        {
                            szt[1] = (CHAR)(szInBuf[c++]);

                            if (  (szInBuf[c] <= TEXT('9')
                                && szInBuf[c] >= TEXT('0'))
                              ||  (szInBuf[c] >= TEXT('A')
                                && szInBuf[c] <= TEXT('F'))
                              ||  (szInBuf[c] >= TEXT('a')
                                && szInBuf[c] <= TEXT('f')) )
                            {
                                szt[2] = (CHAR)(szInBuf[c++]);
                            }
                        }
                    }
                    AddToW( szOutBuf, &i, lTarget, (TCHAR)atoihex( szt));
                    break;
                }
                default:

                    AddToW( szOutBuf, &i, lTarget, szInBuf[c-1]);
                    break;
            }                   //... END switch
        }
        else
        {
            AddToW( szOutBuf, &i, lTarget, szInBuf[c++]);
        }
    }                           //... END while
    szOutBuf[i++] = TEXT('\0');

    return(i);
}


#endif

void ClearResourceDescriptions( void)
{
    CUSTRESNODE far *pCR          = pCustResList;
    CUSTRESNODE far *pCRNext      = NULL;
    CUSTRESTEMPLATE far *pCRT     = NULL;
    CUSTRESTEMPLATE far *pCRTNext = NULL;
    CUSTRESTEMPLATE far *pCRTTmp  = NULL;

    while ( pCR )
    {
        pCRNext = pCR->pNext;

        if ( pCR->pszType )
        {
            RLFREE(pCR->pszType);
        }
        if ( pCR->pszName )
        {
            RLFREE(pCR->pszName);
        }
        pCRT = pCR->pTemplate;
        while ( pCRT )
        {
            pCRTTmp = pCRT->pNext;
            RLFREE( pCRT);
            pCRT=pCRTTmp;
        }
        RLFREE( pCR);
        pCR = pCRNext;
    }
    pCustResList = NULL;
}

// Check to see if we need more room.  If we have less that 5 bytes
// left, grow the target by another 5%.         MHotchin
// chngd to 10% or 10 chars if 10% is less than 10 davewi

static CHAR *CheckBufSize(

int  *lTarget,      //... Length of output buffer
int   cOutBufLen,   //... Bytes already used in output buffer
int   cDelta,       //... # characters we want to add to output buffer
CHAR *szOutBuf)     //... ptr to output buffer
{
                                //... add 1 to allow for trailing nul

    if ( *lTarget - cOutBufLen < cDelta + 1 )
    {
        *lTarget += cDelta;

        szOutBuf = (CHAR *)FREALLOC( (BYTE *)szOutBuf, *lTarget);
    }
    return( szOutBuf);
}

#ifdef RLWIN32

static TCHAR *CheckBufSizeW(

int   *lTarget,     //... Length of output buffer
int    cOutBufLen,  //... Bytes already used in output buffer
int    cDelta,      //... # characters we want to add to output buffer
TCHAR *szOutBuf)    //... ptr to output buffer
{
                                //... add 1 to allow for trailing nul

    if ( *lTarget - cOutBufLen < (int)(MEMSIZE( cDelta + 1)) )
    {
        *lTarget += MEMSIZE( cDelta);

        szOutBuf = (TCHAR *)FREALLOC( (BYTE *)szOutBuf, MEMSIZE(*lTarget));
    }
    return( szOutBuf);
}

#endif //RLWIN32


/**
  * Function: BinToTextA
  * Converts a binary string to it's c representation
  * (complete with escape sequences)
  *
  * Arguments:
  * rgc, source string
  * lSource, length of source string
  *
  * Returns:
  * nothing
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  * 9/92 -- made this ANSII version-- DaveWi
  *     because err msg tables in NT are not UNICODE
  * 01/19/93 -- Removed the string copies.  They were not needed, and
  * MHotchin    broke anything that had embedded nulls in it.
  *             Also added support for allocating memory as needed.
  **/

PCHAR BinToTextA(

PCHAR szInBuf,     //... Input, binary, string
int   lSource)     //... Length of szInBuf
{
    int   i;
    int   cOutBufLen  = 0;
    int   lTarget     = 0;      //... Max length of szOutBuf
    PCHAR szOutBuf    = NULL;   //... Output string with escape sequences


    // If the target is NULL, allocate some memory.  We set aside
    // 5% more than the source length.  MHotchin
    // chngd to 5% or 5 chars if 10% is less than 50    davewi

    lTarget = (lSource == 0) ? 0 : lSource + 1;
    
    szOutBuf = (PCHAR)FALLOC( lTarget);

    for ( i = 0; i < lSource; i++ )
    {
        switch( szInBuf[i] )
        {
            case '\a':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'a');
                break;

            case '\b':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'b');
                break;

            case '\f':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'f');
                break;

            case '\n':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'n');
                break;

            case '\r':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'r');
                break;

            case '\t':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 't');
                break;

            case '\v':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, 'v');
                break;

            case '\\':

                szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 2, szOutBuf);
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                break;

            default:
            {
                unsigned char ucTmp = szInBuf[i];

                if ( (ucTmp >= 0 && ucTmp < 32)
                  || ucTmp == 0x7f
                  || ucTmp == 0xa9
                  || ucTmp == 0xae )
                {
                    CHAR szt[5];

                    szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 4, szOutBuf);
                    sprintf( szt, "%#04hx", (unsigned short)ucTmp);
                    AddTo(szOutBuf, &cOutBufLen, lTarget, '\\');
                    AddTo(szOutBuf, &cOutBufLen, lTarget, szt[0]);
                    AddTo(szOutBuf, &cOutBufLen, lTarget, szt[1]);
                    AddTo(szOutBuf, &cOutBufLen, lTarget, szt[2]);
                    AddTo(szOutBuf, &cOutBufLen, lTarget, szt[3]);
                }
                else
                {
                    szOutBuf = CheckBufSize( &lTarget, cOutBufLen, 1, szOutBuf);
                    AddTo(szOutBuf, &cOutBufLen, lTarget, szInBuf[i]);
                }
                break;
            }
        }
    }
    szOutBuf[ cOutBufLen] = '\0';

    return( szOutBuf);
}



/**
  * Function: TextToBinA
  * Converts a string with c escape sequences to a true binary string.
  *
  * Arguments:
  * rgc, target string
  * sz, source string
  * l, maximum length of target string
  *
  * Returns:
  * length of target string
  *
  * Error Codes:
  * none
  *
  * History:
  * 1/92 -- initial implementation -- SteveBl
  * 9/92 -- made this ANSII version-- DaveWi
  *     because msg resource table strings are not UNICODE
  * 01/21/93 - Removed the string copies - it breaks on embedded NULL's,
  *             and they aren't needed anyways.        MHotchin
  *
  **/

int TextToBinA(

CHAR szOutBuf[],    //... Output, binary, string
CHAR szInBuf[],     //... Input string with escape sequences
int  lTarget)       //... Max length of szOutBuf
{
    int  i = 0;
    int  c = 0;


    while (szInBuf[c])
    {
        if (szInBuf[c] == '\\')
        {           // escape sequence!
            c++;

            switch (szInBuf[c++])
            {
                case 'a':

                    AddTo(szOutBuf, &i, lTarget, '\a');
                    break;

                case 'b':

                    AddTo(szOutBuf, &i, lTarget, '\b');
                    break;

                case 'f':

                    AddTo(szOutBuf, &i, lTarget, '\f');
                    break;

                case 'n':

                    AddTo(szOutBuf, &i, lTarget, '\n');
                    break;

                case 'r':

                    AddTo(szOutBuf, &i, lTarget, '\r');
                    break;

                case 't':

                    AddTo(szOutBuf, &i, lTarget, '\t');
                    break;

                case 'v':

                    AddTo(szOutBuf, &i, lTarget, '\v');
                    break;

                case '\'':

                    AddTo(szOutBuf, &i, lTarget, '\'');
                    break;

                case '\"':

                    AddTo(szOutBuf, &i, lTarget, '\"');
                    break;

                case '\\':

                    AddTo(szOutBuf, &i, lTarget, '\\');
                    break;

                case '0':
                case '1':
                case '2':
                {
                    CHAR szt[4];


                    szt[0] = szt[1] = szt[2] = szt[3] = '\0';

                    if ( szInBuf[c] >= '0' && szInBuf[c] <= '9' )
                    {
                        szt[0] = szInBuf[c-1];
                        szt[1] = szInBuf[c++];

                        if ( szInBuf[c] >= '0' && szInBuf[c] <= '9' )
                        {
                        szt[2] = (CHAR)szInBuf[c++];
                        }
                        AddTo(szOutBuf, &i, lTarget, (CHAR)atoi( szt));
                    }
                    else if ( toupper( szInBuf[c]) == 'X' )
                    {
                        c++;
                        szt[0] = szInBuf[c++];
                        szt[1] = szInBuf[c++];
                        AddTo(szOutBuf, &i, lTarget, (CHAR)atoihex( szt));
                    }
                    else
                    {
                        QuitA( IDS_INVESCSEQ, &szInBuf[c-2], NULL);
                    }
                    break;
                }
                case 'x':
                {
                    CHAR szt[4];


                    // Changed letters we were comparing to - it used
                    // to be lower case.  MHotchin

                    szt[0] = szt[1] = szt[2] = szt[3] = '\0';

                    if ((szInBuf[c] <= '9' && szInBuf[c] >= '0')
                        || (toupper(szInBuf[c]) >= 'A'
                            && toupper(szInBuf[c]) <= 'F'))
                    {
                szt[0] = (CHAR)szInBuf[c++];

                        if ((szInBuf[c] <= '9' && szInBuf[c] >= '0')
                            || (toupper(szInBuf[c]) >= 'A'
                                && toupper(szInBuf[c]) <= 'F'))
                        {
                            szt[1] = szInBuf[c++];

                            if ((szInBuf[c] <= '9' && szInBuf[c] >= '0')
                                || (toupper(szInBuf[c]) >= 'A'
                                    && toupper(szInBuf[c]) <= 'F'))
                            {
                                szt[2] = szInBuf[c++];
                            }
                        }
                    }
                AddTo(szOutBuf, &i, lTarget, (CHAR)atoihex(szt));
                    break;
                }
                default:

                    AddTo(szOutBuf, &i, lTarget, szInBuf[c-1]);
                    break;
            }                   //... END switch
        }
        else
        {
        AddTo(szOutBuf, &i, lTarget, (CHAR)szInBuf[c++]);
        }
    }                           //... END while
    szOutBuf[i++] = '\0';

    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\exe2res.c ===
#include <dos.h>
#include <stdio.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <fcntl.h>
#include <string.h>
#include <ctype.h>
#include <malloc.h>
//#include <tchar.h>


#ifdef RLDOS
    #include "dosdefs.h"
#else
    #include <windows.h>
    #include "windefs.h"
#endif

#include "restok.h"
#include "exe2res.h"
#include "newexe.h"


/* ----- Function prototypes ----- */

static void  PrepareFiles(         PSTR, PSTR, PSTR);
static void  ReadSegmentTable(     void);
static void  ComputeResTableSize(  void);
static void  ComputeStringOffsets( void);
static void  BuildResTable(        void);
static void  SegsWrite(            WORD);
static DWORD RelocCopy(            WORD);
static void  ResWrite(             WORD);
static void  SetEXEHeaderFlags(    void);
static void  RewriteTables(        void);
static void  CopyCodeViewInfo(     FILE *, FILE *);
static void  OutPutError(          char *);
static void  ResTableBufferInit(   WORD);
static void  ResTableBufferFree(   void);
static WORD  GetAlign(             DWORD,  WORD);
static LONG  MoveFilePos(          FILE *, WORD, WORD);
static WORD  RoundUp(              LONG,   WORD);
static WORD  AlignFilePos(         FILE *, WORD, BOOL);
static WORD  ReadExeOldHeader(     FILE *, LONG, LONG *) ;
static WORD  ReadExeNewHeader(     FILE *, LONG, LONG, LONG *);
static WORD  ExtractExeResources(  FILE *, FILE *, LONG , LONG);
static void  ExtractString(        FILE *, FILE *, LONG);
static WORD  WriteResFromExe(      FILE *,
                                   FILE *,
                                   LONG,
                                   RESNAMEINFO,
                                   RESTYPEINFO,
                                   WORD);

static TYPINFO *AddResType(      CHAR *, WORD);
static PSTR  MyMakeStr(          PSTR);
static SHORT MyRead(             FILE *, PSTR, WORD);
static SHORT MyWrite(            FILE *, PSTR, WORD);
static LONG  MySeek(             FILE *, LONG, WORD);
static void  MyCopy(             FILE *, FILE *, DWORD);
static int   ProcessBinFile(     void);
static PSTR  RcAlloc(            WORD);
static void  AddResToResFile(    TYPINFO *, RESINFO *);
static void  AddDefaultTypes(    void);
static void  GetOrdOrName(       unsigned int *, unsigned char *);

/* ----- Version functions (added for 3.1) ----- */

static void RcPutWord(   unsigned int);
static int  RcPutString( char *);



/* ----- Module variables ----- */

static struct exe_hdr  OldExe;
static struct new_exe  NewExe;
static struct new_seg *pSegTable;
static PSTR   pResTable;
static PSTR   pResNext;
static FILE * fhInput;
static FILE * fhOutput;
static FILE * fhBin;
static DWORD  dwMaxFilePos;
static DWORD  dwNewExe;
static WORD   wPreloadOffset;
static WORD   wPreloadLength;
static WORD   wResTableOffset;
static WORD   wSegTableLen;
static WORD   wResTableLen;
static BYTE   zeros[ NUMZEROS] = "";
static DWORD  dwExeEndFile;
static WORD   fMultipleDataSegs;



//.........................................................................

int ExtractResFromExe16A( CHAR *szInputExe, CHAR *szOutputRes, WORD wFilter)
{
    QuitT( IDS_NO16RESWINYET, NULL, NULL);

#ifdef 0
    WORD    wResult = (WORD)-1;
    LONG    lPosNewHdr;
    LONG    lPosResourceTable;
    LONG    lFileLen;
    FILE    *fExeFile;
    FILE    *fResFile;
    struct     _stat ExeStats;
    /* initialize */
    wResult      = IDERR_SUCCESS;



    /* open file for reading */
    if ((fExeFile = FOPEN(szInputExe, "rb" )) == NULL ) {
        wResult = IDERR_OPENFAIL;
    }

    if ((fResFile = FOPEN(szOutputRes, "wb" )) == NULL ) {
        wResult = IDERR_OPENFAIL;
    }

    /* get file length */
    if (wResult == IDERR_SUCCESS) {
        _stat(szInputExe , &ExeStats );
        lFileLen = ExeStats.st_size;
    }

    /* read old header, verify contents, and get positon of new header */
    if (wResult == IDERR_SUCCESS) {
        wResult = ReadExeOldHeader( fExeFile, lFileLen, &lPosNewHdr );
    }

    /* read new header, verify contents, &  get position of resource table */
    if (wResult == IDERR_SUCCESS)
        wResult = ReadExeNewHeader(
                                  fExeFile,
                                  lFileLen,
                                  lPosNewHdr,
                                  &lPosResourceTable
                                  );

    wResult = ExtractExeResources( fExeFile , fResFile, lPosResourceTable , lFileLen);
    return ( wResult);
#endif // 0
}

//....................................................................

int BuildExeFromRes16A(

                      CHAR *pstrDest,
                      CHAR *pstrRes,
                      CHAR *pstrSource )
{
    QuitT( IDS_NO16WINRESYET, NULL, NULL);

#ifdef 0
    SHORT nResTableDelta;

    fSortSegments = TRUE;
    /* Get a memory block to use for MyCopy\(\) */


    PrepareFiles(pstrSource, pstrDest, pstrRes);

    ProcessBinFile();

    /* Read the segment table */
    ReadSegmentTable();

    /* Compute the length of the resource table */
    ComputeResTableSize();

    /* Compute string offsets for non-ordinal type and resource names */
    ComputeStringOffsets();

    /* Build the resource table */
    BuildResTable();

    /* Now go back to the beginning */
    MySeek(fhInput, 0L, 0);

    /* Copy from input to output up to the segment table */
    MyCopy(fhInput, fhOutput, dwNewExe + (DWORD)NewExe.ne_segtab);

    /* Copy the segment table */
    MyCopy(fhInput, fhOutput, (long)wSegTableLen);

    /* Save a pointer to the start of the resource table */
    wResTableOffset = (unsigned)(MySeek(fhOutput, 0L, 1) - dwNewExe);

    /* Write our resource table out */
    if (wResTableLen) {
        MyWrite(fhOutput, pResTable, wResTableLen);
    }

    /* Now we\'re looking at the beginning of the resident name table */
    MySeek(fhInput, (LONG)NewExe.ne_restab + dwNewExe, 0);

    /* Copy all the other tables \(they must fall between the resident
     *  names table and the non-resident names table.
     */
    MyCopy(fhInput, fhOutput,
           NewExe.ne_nrestab - (LONG)NewExe.ne_restab - dwNewExe);

    /* Copy the nonresident name table as well */
    MyCopy(fhInput, fhOutput, (LONG)NewExe.ne_cbnrestab);

    /* Compute new pointers in new exe header */
    NewExe.ne_rsrctab = wResTableOffset;
    nResTableDelta = wResTableOffset + wResTableLen - NewExe.ne_restab;
    NewExe.ne_restab += nResTableDelta;
    NewExe.ne_modtab += nResTableDelta;
    NewExe.ne_imptab += nResTableDelta;
    NewExe.ne_enttab += nResTableDelta;
    NewExe.ne_nrestab += nResTableDelta;
    #ifdef VERBOSE
    /* Tell the user what we\'re doing */
    if (fVerbose && fSortSegments) {
        fprintf(errfh, "Sorting preload segments and"
                " resources into fast-load section\n");
        if (fBootModule)
            fprintf(errfh,"This is a boot module; the .DEF file"
                    " is assumed to be correct!\n");
    }
    #endif

    /* If we\'re sorting segments, write preload segments and resources
     *  into a section separate from the load on call stuff.
     */
    if (fSortSegments) {
        /* Save the start of the preload section */
        wPreloadOffset = AlignFilePos(fhOutput, NewExe.ne_align, TRUE);

        /* Write PRELOAD segments and resources */
        SegsWrite(DO_PRELOAD);
        ResWrite(DO_PRELOAD);

        /* Compute the properly aligned length of the preload section */
        wPreloadLength = AlignFilePos(fhOutput, NewExe.ne_align, TRUE) -
                         wPreloadOffset;

        /* Now do the LOADONCALL segs and resources */
        SegsWrite(DO_LOADONCALL);
        ResWrite(DO_LOADONCALL);
    }

    /* If we\'re not sorting segments, just write them into a common block */
    else {
        /* Write the segs and resources */
        SegsWrite(DO_PRELOAD | DO_LOADONCALL);
        ResWrite(DO_PRELOAD | DO_LOADONCALL);
    }

    #ifdef SETEXEFLAGS
    /* Set flags and other values in the EXE header */
    SetEXEHeaderFlags();
    #endif

    /* Rewrite the new exe header, segment table and resource table */
    RewriteTables();
    ResTableBufferFree();

    /* Handle CodeView info */
    CopyCodeViewInfo(fhInput, fhOutput);

    /* Seek to end of output file and issue truncating write */
    MySeek(fhOutput, 0L, 2);
    MyWrite(fhOutput, zeros, 0);
    fclose(fhInput);
    fclose(fhOutput);
    fclose(fhBin);
    FreePTypInfo(pTypInfo);
    pTypInfo=NULL;
    MyFree(pSegTable);
    pSegTable=NULL;
    return TRUE;
#endif // 0
}

/*
 *
 * ReadExeOldHeader\( fExeFile, lFileLen, plPosNewHdr \) : WORD;
 *
 *    fExeFile        file handle of .exe file being read
 *    lFileLen         length of file
 *    plPosNewHdr      pointer to file position of new header
 *
 *     This function reads the old header from an executable file, checks to be
 * sure that it is a valid header, and saves the position of the file\'s
 * new header.
 *
 * This function returns IDERR_SUCCESS if there are no errors, or a non-zero
 * error code if there are.
 *
 */

static WORD ReadExeOldHeader(

                            FILE  *fExeFile,
                            LONG   lFileLen,
                            LONG  *plPosNewHdr )
{
    LONG  lPos;
    WORD    cb;
    EXEHDR        ehOldHeader;
    WORD  wResult;

    /* initialize */
    wResult = IDERR_SUCCESS;

    lPos = fseek( fExeFile, 0L, SEEK_SET );


    if (lPos != 0L)
        wResult = IDERR_READFAIL;

    if (wResult == IDERR_SUCCESS) {
        cb = fread(  (void *) &ehOldHeader, sizeof( EXEHDR) , 1, fExeFile );

        if (cb != 1 ) {
            wResult = IDERR_READFAIL;
        } else if (ehOldHeader.ehSignature != OLDEXESIGNATURE) {
            wResult = IDERR_FILETYPEBAD;
        } else if (ehOldHeader.ehPosNewHdr < sizeof(EXEHDR)) {
            wResult = IDERR_EXETYPEBAD;
        } else if ( ehOldHeader.ehPosNewHdr > (LONG)(lFileLen - sizeof(NEWHDR)) ) {
            wResult = IDERR_EXETYPEBAD;
        } else {
            *plPosNewHdr = ehOldHeader.ehPosNewHdr;
        }
    }

    return wResult;
}

/*
 *
 * ReadExeNewHeader\( fExeFile, lFileLen, lPosNewHdr, plPosResourceTable \) : WORD;
 *
 *    fExeFile        file handle of .exe file being read
 *    lFileLen         length of file
 *    lPosNewHdr       file position of new header
 *    plPosResourceTable   pointer to file position of resource table
 *
 *     This function reads the new header from an executable file, checks to be
 * sure that it is a valid header, and saves the position of the file\'s
 * resource table.
 *
 * This function returns IDERR_SUCCESS if there are no errors, or a non-zero
 * error code if there are.
 *
 */

static WORD ReadExeNewHeader(

                            FILE *fExeFile,
                            LONG  lFileLen,
                            long  lPosNewHdr,
                            LONG *plPosResourceTable )
{
    WORD wResult;
    WORD cb;
    LONG lPos;
    NEWHDR       nhNewHeader;

    /* initialize */
    wResult = IDERR_SUCCESS;

    fseek( fExeFile, lPosNewHdr, SEEK_SET );
    lPos = ftell( fExeFile );

    if (lPos == (long) -1 || lPos > lFileLen || lPos != lPosNewHdr) {
        wResult = IDERR_READFAIL;
    } else {
        cb = fread( ( void *)&nhNewHeader, sizeof(nhNewHeader) , 1, fExeFile );

        if (cb != 1 ) {
            wResult = IDERR_READFAIL;
        } else if (nhNewHeader.nhSignature != NEWEXESIGNATURE) {
            wResult = IDERR_FILETYPEBAD;
        } else if (nhNewHeader.nhExeType != WINDOWSEXE) {
            wResult = IDERR_EXETYPEBAD;
        } else if (nhNewHeader.nhExpVer < 0x0300) {
            wResult = IDERR_WINVERSIONBAD;
        } else if (nhNewHeader.nhoffResourceTable == 0) {
            wResult = IDERR_RESTABLEBAD;
        } else {
            *plPosResourceTable = lPosNewHdr + nhNewHeader.nhoffResourceTable;
        }
    }

    return wResult;
}

/*
 *
 * ReadExeTable\( fExeFile , lPosResourcTable \) : WORD;
 *
 *    fExeFile      file handle of .exe file being read
 *
 * This function reads through the entries in an .exe file\'s resource table,
 * identifies any icons in that table, and saves the file offsets of the data
 * for those icons. This function expects the initial file position to point
 * to the first entry in the resource table.
 *
 * This function returns IDERR_SUCCESS if there are no errors, or a non-zero
 * error code if there are.
 *
 */

static WORD ExtractExeResources(

                               FILE  *fExeFile,
                               FILE  *fResFile,
                               LONG   lPosResourceTable,
                               LONG   lFileLen )
{
    BOOL    fLoop;
    WORD    wResult;
    WORD    cb;
    LONG    lPos;
    WORD    wShiftCount;
    wResult = IDERR_SUCCESS;


    // posistion file pointer at resource table
    fseek( fExeFile, lPosResourceTable, SEEK_SET );
    lPos = ftell(fExeFile);

    if (lPos == (LONG) -1 || lPos > lFileLen || lPos != lPosResourceTable) {
        return  IDERR_READFAIL ;
    }

    if (wResult == IDERR_SUCCESS) {
        cb = fread( (void *) &wShiftCount, sizeof(wShiftCount), 1 , fExeFile );
    }

    if (cb != 1 ) {
        return IDERR_READFAIL;
    }

    if (wShiftCount > 16) {
        return IDERR_RESTABLEBAD;
    }

    /* initialize */
    wResult       = IDERR_SUCCESS;
    fLoop         = TRUE;


    /* loop through entries in resource table */
    while (fLoop == TRUE) {
        WORD    cb;
        WORD    iFile;
        RESTYPEINFO   rt;

        /* read RESTYPEINFO */
        cb = fread( (void *)&rt, sizeof(rt), 1, fExeFile );

        if (cb != 1 ) {
            wResult = IDERR_READFAIL;
            break;
        }

        if ( rt.rtType == 0 )
            break;

        // now get all the resource of this type
        for (
            iFile = 0;
            iFile<rt.rtCount && wResult==IDERR_SUCCESS;
            iFile++
            ) {
            RESNAMEINFO rn;

            cb = fread(  (void *) &rn, sizeof(rn) , 1 , fExeFile );

            if (cb != 1 ) {
                wResult = IDERR_READFAIL;
            }

            WriteResFromExe( fExeFile, fResFile,lPos, rn, rt, wShiftCount );

        }
        fLoop = (rt.rtType != 0) && (wResult == IDERR_SUCCESS);
    }
    FCLOSE(fExeFile);
    FCLOSE(fResFile);
    return wResult;
}

//.................................................................

static WORD WriteResFromExe(

                           FILE        *fExeFile,
                           FILE        *fResFile,
                           LONG         lPos,
                           RESNAMEINFO  ResNameInfo,
                           RESTYPEINFO  ResTypeInfo,
                           WORD         wShiftCount )
{
    LONG lCurPos;
    LONG lResPos;
    LONG wLength;
    LONG wTmpLength;

    wLength =  (LONG) ResNameInfo.rnLength << wShiftCount;

    lCurPos = ftell( fExeFile );
    // position file pointer at resouce location
    lResPos = (LONG) ResNameInfo.rnOffset << wShiftCount;
    fseek( fExeFile, lResPos, SEEK_SET );

    if ( ResTypeInfo.rtType & 0x8000) {
        PutByte( fResFile, (BYTE) 0xff, NULL );
        PutWord( fResFile, (WORD)(ResTypeInfo.rtType & 0x7FFF), NULL);
    } else {
        ExtractString(fExeFile,fResFile,lPos+ResTypeInfo.rtType);
    }

    if ( ResNameInfo.rnID & 0x8000 ) {
        PutByte( fResFile, (BYTE) 0xff, NULL );
        PutWord( fResFile, (WORD)(ResNameInfo.rnID & 0x7fFF), NULL);
    } else {
        ExtractString(fExeFile,fResFile,lPos+ResNameInfo.rnID);
    }

    PutWord( fResFile, ResNameInfo.rnFlags , NULL );
    PutdWord( fResFile, (LONG) wLength, NULL );
    wTmpLength = wLength;
    // now write the actual data

    fseek( fExeFile, lResPos, SEEK_SET );
    ReadInRes( fExeFile, fResFile, &wTmpLength );
    fseek( fExeFile, lCurPos, SEEK_SET );

    return 0;
}

//..................................................................

static void ExtractString( FILE *fExeFile, FILE *fResFile, LONG lPos)
{
    BYTE n,b;

    fseek(fExeFile, lPos, SEEK_SET);

    n=GetByte(fExeFile, NULL);
    for (;n--; ) {
        b=GetByte(fExeFile, NULL);
        PutByte(fResFile, (CHAR) b, NULL);
    }
    PutByte(fResFile, (CHAR) 0, NULL);
}


// Modifications for RLTOOLS

// Currently we dont support any dynamic flags
BOOL    fBootModule   = FALSE;
BOOL    fSortSegments = TRUE;

TYPINFO *pTypInfo = NULL;

static void FreePTypInfo( TYPINFO *pTypInfo)
{
    RESINFO * pRes, *pRTemp;
    TYPINFO * pTItemp;

    while (pTypInfo) {
        pRes = pTypInfo->pres;
        while (pRes) {
            pRTemp = pRes->next;
            MyFree(pRes->name);
            MyFree(pRes);
            pRes = pRTemp;
        }
        pTItemp = pTypInfo->next;
        MyFree(pTypInfo->type);
        MyFree(pTypInfo);
        pTypInfo = pTItemp;
    }
}

/* ----- Helper functions ----- */


/*  PrepareFiles
 *  Prepares the EXE files \(new and old\) for writing and verifies
 *  that all is well.
 *  Exits on error, returns if processing should continue.
 */

static void PrepareFiles(

                        PSTR pstrSource,
                        PSTR pstrDest,
                        PSTR pstrRes )
{
    /* Open the .EXE file the linker gave us */
    if ( (fhInput = FOPEN(pstrSource, "rb" )) == NULL ) {
        OutPutError("Unable to open Exe Source  File");
    }

    if ((fhBin = FOPEN(pstrRes, "rb")) == NULL ) {
        OutPutError("Unable to open Resource File");
    }

    /* Read the old format EXE header */
    MyRead(fhInput, (PSTR)&OldExe, sizeof (OldExe));

    /* Make sure its really an EXE file */
    if (OldExe.e_magic != EMAGIC) {
        OutPutError("Invalid .EXE file" );
    }

    /* Make sure theres a new EXE header floating around somewhere */
    if (!(dwNewExe = OldExe.e_lfanew)) {
        OutPutError("Not a Microsoft Windows format .EXE file");
    }

    /* Go find the new .EXE header */
    MySeek(fhInput, dwNewExe, 0);
    MyRead(fhInput, (PSTR)&NewExe, sizeof (NewExe));

    /* Check version numbers */
    if (NewExe.ne_ver < 4) {
        OutPutError("File not created by LINK");
    }

    /* Were there linker errors? */
    if (NewExe.ne_flags & NEIERR) {
        OutPutError("Errors occurred when linking file.");
    }

    /* Make sure that this program\'s EXETYPE is WINDOWS \(2\) not OS/2 \(1\) */
    if (NewExe.ne_exetyp != 2)
        OutPutError("The EXETYPE of the program is not WINDOWS.\n"
                    "(Make sure the .DEF file is correct.");
#ifdef VERBOSE
    if (fVerbose) {
        fprintf(errfh, "\n");
    }
#endif

    /* Open the all new executable file */
    if ( (fhOutput = FOPEN( pstrDest, "wb")) == NULL ) {
        OutPutError("Unable to create destination");
    }
}


/*  ReadSegmentTable
 *  Reads the segment table from the file.
 */

static void ReadSegmentTable( void)
{
    struct new_seg* pSeg;
    WORD i;

    MySeek(fhInput, (LONG)NewExe.ne_segtab + dwNewExe, 0);
    if ((wSegTableLen = NewExe.ne_cseg * sizeof (struct new_seg)) > 0) {
        pSegTable = (struct new_seg *)RcAlloc   (wSegTableLen);
        MyRead(fhInput, (PSTR)pSegTable, wSegTableLen);

        /* See if we have more than one data segment */
        fMultipleDataSegs = 0;
        for (pSeg = pSegTable, i = NewExe.ne_cseg ; i ; --i, ++pSeg) {
            if ((pSeg->ns_flags & NSTYPE) == NSDATA) {
                ++fMultipleDataSegs;
            }
        }
        if (fMultipleDataSegs) {
            --fMultipleDataSegs;
        }
    } else {
        pSegTable = NULL;
    }
}

/*  ComputeResTableSize
 *  Computes the size of the resource table by enumerating all the
 *  resources currently in the linked lists.
 */

static void ComputeResTableSize( void)
{
    TYPINFO **pPrev;
    TYPINFO *pType;
    RESINFO *pRes;

    /* Start with the minimum overhead size of the resource table.  This
     *  is the resource alignment count and the zero WORD terminating the
     *  table.  This is necessary so that we put the correct file offset
     *  in for the string offsets to named resources.
     */
    wResTableLen = RESTABLEHEADER;

    /* Loop over type table, computing the fixed length of the
     *  resource table, removing unused type entries.
     */
    pPrev = &pTypInfo;
    dwMaxFilePos = 0L;
    while (pType = *pPrev) {
        if (pRes = pType->pres) {
            /* Size of type entry */
            wResTableLen += sizeof (struct rsrc_typeinfo);
            while (pRes) {
                /* Size of resource entry */
                wResTableLen += sizeof (struct rsrc_nameinfo);
                if (pType->next || pRes->next) {
                    dwMaxFilePos += pRes->size;
                }
                pRes = pRes->next;
            }
            pPrev = &pType->next;
        } else {
            *pPrev = pType->next;
            MyFree(pType->type);
            MyFree(pType);
        }
    }
}


/*  ComputeStringOffsets
 *  Computes offsets to strings from named resource and types.
 */

static void ComputeStringOffsets( void)
{
    TYPINFO *pType;
    RESINFO *pRes;

    /* Loop over type table, computing string offsets for non-ordinal
     *  type and resource names.
     */
    pType = pTypInfo;
    while (pType) {
        pRes = pType->pres;

        /* Is there an ordinal? */
        if (pType->typeord) {
            /* Mark the ordinal */
            pType->typeord |= RSORDID;

            /* Flush the string name */
            MyFree(pType->type);
            pType->type = NULL;
        } else if (pType->type) {           /* is there a type string? */
            /* Yes, compute location of the type string */
            pType->typeord = wResTableLen;
            wResTableLen += strlen(pType->type) + 1;
        }

        while (pRes) {
            /* Is there an ordinal? */
            if (pRes->nameord) {
                /* Mark the ordinal */
                pRes->nameord |= RSORDID;

                /* Flush the string name */
                MyFree(pRes->name);
                pRes->name = NULL;
            }

            /* Is there a resource name? */
            else if (pRes->name) {
                /* Yes, compute location of the resource string */
                pRes->nameord = wResTableLen;
                wResTableLen += strlen(pRes->name) + 1;
            }
            pRes = pRes->next;
        }
        pType = pType->next;
    }
}


/*  BuildResTable
 *  Builds the local memory image of the resource table.
 */

static void BuildResTable( void)
{
    TYPINFO *pType;
    RESINFO *pRes;

    /* Check to see if we have any resources.  If not, just omit the table */
    if (wResTableLen > RESTABLEHEADER) {

        /* Set up the temporary resource table buffer */
        ResTableBufferInit(wResTableLen);

        /* Alignment shift count
         *  \(we default here to the segment alignment count\)
         */
        RcPutWord(NewExe.ne_align);

        pType = pTypInfo;
        while (pType) {
            /* output the type and number of resources */
            RcPutWord(pType->typeord); /* DW type id */
            RcPutWord(pType->nres);    /* DW #resources for this type */
            RcPutWord(0);              /* DD type procedure */
            RcPutWord(0);

            /* output flags and space for the file offset for each resource */
            pRes = pType->pres;
            while (pRes) {
                pRes->poffset = (WORD *)pResNext;
                RcPutWord(0);           /* DW file offset */
                RcPutWord(0);           /* DW resource size */
                pRes->flags |= NSDPL;
                RcPutWord(pRes->flags ); /* DW flags */
                RcPutWord(pRes->nameord ); /* DW name id */
                RcPutWord(0);              /* DW handle */
                RcPutWord(0);              /* DW usage or minalloc */
                pRes = pRes->next;
            }
            pType = pType->next;
        }

        /* Null entry terminates table */
        RcPutWord(0);

        /* Output type and name strings for non-ordinal resource types
         *  and names */
        pType = pTypInfo;
        while (pType) {
            /* Dump out any strings for this type */
            if (pType->type && !(pType->typeord & RSORDID)) {
                RcPutString(pType->type);
            }

            pRes = pType->pres;
            while (pRes) {
                if (pRes->name && !(pRes->nameord & RSORDID))
                    RcPutString(pRes->name);

                pRes = pRes->next;
            }

            pType = pType->next;
        }
    } else
        wResTableLen = 0;
}


/*  SegsWrite
 *  Copies segments to the file.  This routine will do only preload,
 *  only the load on call, or both types of segments depending on
 *  the flags.
 */

static void SegsWrite( WORD wFlags)
{
    WORD wExtraPadding;
    WORD i;
    static struct new_seg *pSeg;
    DWORD dwSegSize;
    DWORD dwWriteSize;
    WORD wTemp;
    WORD wcbDebug;

    /* We only need extra padding in the preload section.
     *  Note that when wFlags == DO_PRELOAD | DO_LOADONCALL, we DON\'T
     *  need extra padding because this is NOT a preload section.
     *  \(hence the \'==\' instead of an \'&\'\)
     */
    wExtraPadding = (wFlags == DO_PRELOAD);

    /* Copy segment data for each segment, fixed and preload only */
    for (i = 1, pSeg = pSegTable; i <= NewExe.ne_cseg; i++, pSeg++) {
        /* If there\'s no data in segment, skip it here */
        if (!pSeg->ns_sector) {
            continue;
        }

        /* Force some segments to be preload if doing preload resources */
        if ((wFlags & DO_PRELOAD) && !fBootModule) {
            char *reason = NULL;

            /* Check various conditions that would force preloading */
            if (i == (unsigned)(NewExe.ne_csip >> 16)) {
                reason = "Entry point";
            }
            if (!(pSeg->ns_flags & NSMOVE)) {
                reason = "Fixed";
            }
            if (pSeg->ns_flags & NSDATA) {
                reason = "Data";
            }
            if (!(pSeg->ns_flags & NSDISCARD)) {
                reason = "Non-discardable";
            }

            /* If this segment must be preload and the segment is not already
             *  marked as such, warn the user and set it.
             */
            if (reason && !(pSeg->ns_flags & NSPRELOAD)) {
#ifdef VERBOSE
                fprintf(errfh,
                        "RC: warning RW4002: %s segment %d set to PRELOAD\n",
                        reason, i);
#endif
                pSeg->ns_flags |= NSPRELOAD;
            }
        }

        /* Skip this segment if it doesn\'t match the current mode */
        wTemp = pSeg->ns_flags & NSPRELOAD ? DO_PRELOAD : DO_LOADONCALL;
        if (!(wTemp & wFlags)) {
            continue;
        }

        /* Get the true segment length.  A zero length implies 64K */
        if (pSeg->ns_cbseg) {
            dwSegSize = pSeg->ns_cbseg;
        } else {
            dwSegSize = 0x10000L;
        }

#ifdef VERBOSE

        if (fVerbose)
            fprintf(errfh, "Copying segment %d (%lu bytes)\n", i, dwSegSize);
#endif

        /* Align the segment correctly and pad the file to match */
        MoveFilePos(fhInput, pSeg->ns_sector, NewExe.ne_align);
        pSeg->ns_sector = AlignFilePos(fhOutput, NewExe.ne_align,
                                       wExtraPadding);

        /* Copy the segment */
        MyCopy(fhInput, fhOutput, dwSegSize);

        /* Pad out all segments in the preload area to their minimum
         *  memory allocation size so that KERNEL doesn\'t have to realloc
         *  the segment.
         */
        if (wExtraPadding && pSeg->ns_cbseg != pSeg->ns_minalloc) {
            /* A minalloc size of zero implies 64K */
            if (!pSeg->ns_minalloc) {
                dwWriteSize = 0x10000L - pSeg->ns_cbseg;
            } else {
                dwWriteSize = pSeg->ns_minalloc - pSeg->ns_cbseg;
            }

            /* Add in to total size of segment */
            dwSegSize += dwWriteSize;

            /* Set the segment table size to this new size */
            pSeg->ns_cbseg = pSeg->ns_minalloc;

            /* Pad the file */
            while (dwWriteSize) {
                dwWriteSize -= MyWrite(fhOutput,
                                       zeros,
                                       (WORD)(dwWriteSize > (DWORD) NUMZEROS
                                              ? NUMZEROS : dwWriteSize));
            }
        }

        /* Copy the relocation information */
        if (pSeg->ns_flags & NSRELOC) {
            /* Copy the relocation stuff */
            dwSegSize += RelocCopy(i);

            /* Segment + padding + relocations can\'t be >64K for preload
             *  segments.
             */
            if (fSortSegments && (pSeg->ns_flags & NSPRELOAD) &&
                dwSegSize > 65536L) {
#ifdef VERBOSE
                fprintf(errfh,
                        "RC : fatal error RW1031: Segment %d and its\n"
                        "     relocation information is too large for load\n"
                        "     optimization. Make the segment LOADONCALL or\n"
                        "     rerun RC using the -K switch if the segment must\n"
                        "     be preloaded.\n", i);
#endif
            }
        }

        /* Copy any per-segment debug information */
        if (pSeg->ns_flags & NSDEBUG) {
            MyRead(fhInput, (PSTR)&wcbDebug, sizeof (WORD));
            MyWrite(fhOutput, (PSTR)&wcbDebug, sizeof (WORD));
            MyCopy(fhInput, fhOutput, (LONG)wcbDebug);
        }
    }
}


/*  RelocCopy
 *  Copys all the relocation records for a given segment.
 *  Also checks for invalid fixups.
 */

static DWORD RelocCopy( WORD wSegNum)
{
    WORD wNumReloc;
    struct new_rlc RelocRec;
    WORD i;
    BYTE byFixupType;
    BYTE byFixupFlags;
    WORD wDGROUP;

    /* Get the number of relocations */
    MyRead(fhInput, (PSTR)&wNumReloc, sizeof (WORD));
    MyWrite(fhOutput, (PSTR)&wNumReloc, sizeof (WORD));

    /* Get the automatic data segment */
    wDGROUP = NewExe.ne_autodata;

    /* Copy and verify all relocations */
    for (i = 0 ; i < wNumReloc ; ++i) {
        /* Copy the record */
        MyRead(fhInput, (PSTR)&RelocRec, sizeof (RelocRec));
        MyWrite(fhOutput, (PSTR)&RelocRec, sizeof (RelocRec));

        /* Validate it only if necessary */
        if ((NewExe.ne_flags & (NENOTP | NESOLO)) ||
            wSegNum == wDGROUP || fMultipleDataSegs) {
            continue;
        }

        /* Bad fixups are fixups to DGROUP in code segments in apps
         *  that can be multi-instanced.  Since we can\'t fix up locations
         *  that are different from instance to instance in shared code
         *  segments, we have to warn the user.  We only warn because this
         *  may be allowable if the app only allows a single instance of
         *  itself to run.
         */
        byFixupType = (BYTE) (RelocRec.nr_stype & NRSTYP);
        byFixupFlags = (BYTE) (RelocRec.nr_flags & NRRTYP);
#ifdef VERBOSE
        if ((byFixupType == NRSSEG || byFixupType == NRSOFF) &&
            byFixupFlags == NRRINT &&
            RelocRec.nr_union.nr_intref.nr_segno == wDGROUP)

            fprintf(errfh,
                    "RC : warning RW4005: Segment %d (offset %04X) contains a\n"
                    "     relocation record pointing to the automatic\n"
                    "     data segment.  This will cause the program to crash\n"
                    "     if the instruction being fixed up is executed in a\n"
                    "     multi-instance application.  If this fixup is\n"
                    "     necessary, the program should be restricted to run\n"
                    "     only a single instance.\n", wSegNum, RelocRec.nr_soff);
#endif
    }

    return wNumReloc * sizeof (struct new_rlc);
}


/*  ResWrite
 *  Copies resources to the file.  This routine will do only the preload,
 *  only the load on call, or both types of resources depending on the
 *  flags.
 */

static void ResWrite( WORD wFlags)
{
    WORD wExtraPadding;
    WORD wTemp;
    WORD wResAlign;
    TYPINFO *pType;
    RESINFO *pRes;

    /* If we have no resource table, just ignore this */
    if (!wResTableLen) {
        return;
    }

    /* We only need extra padding in the preload section.
     *  Note that when wFlags == DO_PRELOAD | DO_LOADONCALL, we DON\'T
     *  need extra padding because this is NOT a preload section.
     *  \(hence the \'==\' instead of an \'&\'\)
     */
    wExtraPadding = (wFlags == DO_PRELOAD);

    /* Compute resource alignment.  Note that the alignment is not the
     *  same as the segment alignment ONLY IF there is no segment sorting
     *  and some resources cannot be reached with the current segment
     *  align count.
     */
    wResAlign = NewExe.ne_align;

    if (!fSortSegments) {
        /* Compute the needed alignment */
        dwMaxFilePos += MySeek(fhOutput, 0L, 2);
        wResAlign = GetAlign(dwMaxFilePos, NewExe.ne_align);

#ifdef VERBOSE
        if (fVerbose)
            fprintf(errfh, "Resources will be aligned on %d byte boundaries\n",
                    1 << wResAlign);
#endif

        /* Point back to the start of the local memory resource table */
        pResNext = pResTable;
        RcPutWord(wResAlign);
    }

    /* Output contents associated with each resource */
    for (pType = pTypInfo ; pType; pType = pType->next) {
        for (pRes = pType->pres ; pRes ; pRes = pRes->next) {
            /* Make sure this is the right kind of resource */
            wTemp = pRes->flags & RNPRELOAD ? DO_PRELOAD : DO_LOADONCALL;
            if (!(wTemp & wFlags)) {
                continue;
            }

            /* Give some info to the user */
#ifdef VERBOSE
            if (fVerbose) {
                fprintf(errfh, "Writing resource ");
                if (pRes->name && !(pRes->nameord & RSORDID)) {
                    fprintf(errfh, "%s", pRes->name);
                } else {
                    fprintf(errfh, "%d", pRes->nameord & 0x7FFF);
                }

                if (pType->type && !(pType->typeord & RSORDID)) {
                    fprintf(errfh, ".%s", pType->type);
                } else {
                    fprintf(errfh, ".%d", pType->typeord & 0x7FFF);
                }

                fprintf(errfh, " (%lu bytes)\n", pRes->size);
                fflush(errfh);
            }
#endif

            /* Copy the resource from the RES file to the EXE file */
            MySeek(fhBin, (long)pRes->BinOffset, 0);
            *(pRes->poffset)++ =
            AlignFilePos(fhOutput, wResAlign, wExtraPadding);
            *(pRes->poffset) = RoundUp(pRes->size, wResAlign);
            MyCopy(fhBin, fhOutput, pRes->size);
        }
    }

    /* Compute the end of the EXE file thus far for the CV info */
    dwExeEndFile = AlignFilePos(fhOutput, wResAlign, wExtraPadding);
}

#ifdef SETEXEFLAGS
/*  SetEXEHeaderFlags
 *  Sets necessary flags and values in the EXE header.
 */

static void SetEXEHeaderFlags( void)
{
    /* Tell loader we initialized previously unused fields */
    if (NewExe.ne_ver == 4) {
        NewExe.ne_rev = 2;
    }

    /* Set command line values into the header */
    NewExe.ne_expver   = expWinVer;
    NewExe.ne_swaparea = swapArea;

    /* Set the preload section values */
    if (fSortSegments) {
        /* Set the new fastload section values */
        NewExe.ne_gangstart = wPreloadOffset;
        NewExe.ne_ganglength = wPreloadLength;
    #ifdef VERBOSE
        if (fVerbose)
            fprintf(errfh, "Fastload area is %ld bytes at offset 0x%lX.\n",
                    (LONG)wPreloadLength << NewExe.ne_align,
                    (LONG)wPreloadOffset << NewExe.ne_align);
    }
    #endif

    /* Clear all the flags */
    NewExe.ne_flags &=
    ~(NELIM32|NEMULTINST|NEEMSLIB|NEPRIVLIB|NEPRELOAD);

    /* Set appropriate flags */
    if (fLim32) {
        NewExe.ne_flags |= NELIM32;
    }
    if (fMultInst) {
        NewExe.ne_flags |= NEMULTINST;
    }
    if (fEmsLibrary) {
        NewExe.ne_flags |= NEEMSLIB;
    }
    if (fPrivateLibrary) {
        NewExe.ne_flags |= NEPRIVLIB;
    }
    if (fProtOnly) {
        NewExe.ne_flags |= NEPROT;
    }

    if (fSortSegments && wPreloadLength) {
        NewExe.ne_flagsother |= NEPRELOAD;
    }

    NewExe.ne_flags |= NEWINAPI;
}
#endif

/*  RewriteTables
 *  Rewrites the EXE header and the resource and segment tables
 *  with their newly-updated information.
 */

static void RewriteTables( void)
{
    /* Write the new EXE header */
    MySeek(fhOutput, (LONG)dwNewExe, 0);
    MyWrite(fhOutput, (PSTR)&NewExe, sizeof (NewExe));

    /* Seek to the start of the segment table */
    MySeek(fhOutput, dwNewExe + (LONG)NewExe.ne_segtab, 0);
    MyWrite(fhOutput, (PSTR)pSegTable, wSegTableLen);

    /* Seek to and write the resource table */
    if (wResTableLen) {
        MySeek(fhOutput, dwNewExe + (LONG)NewExe.ne_rsrctab, 0);
        MyWrite(fhOutput, pResTable, wResTableLen);
    }
}



/*  CopyCodeViewInfo
 *  Copies CodeView info to the new EXE file and relocates it if
 *  necessary.  This routine is designed to work with the
 *  DNRB-style info as well as NBxx info where x is a digit.
 */

static void CopyCodeViewInfo( FILE *fhInput, FILE *fhOutput)
{
    unsigned long dwcb;
    unsigned int i;
    CVINFO cvinfo;
    CVSECTBL cvsectbl;

    /* See if old format \(DNRB\) symbols present at end of input file
     *  If they are, relocate the table to the new file position and
     *  fix up the file-position dependent offsets.
     */
    dwcb = MySeek( fhInput, -(signed long)sizeof (CVINFO), 2);
    MyRead( fhInput, (char *)&cvinfo, sizeof (cvinfo));

    if (*(unsigned long *)cvinfo.signature == CV_OLD_SIG) {
        dwcb -= cvinfo.secTblOffset;
        MySeek( fhInput, cvinfo.secTblOffset, 0);
        MyRead( fhInput, (char *)&cvsectbl, sizeof (cvsectbl));
        dwcb -= sizeof (cvsectbl);

        for (i = 0 ; i < 5 ; ++i) {
            cvsectbl.secOffset[i] -= cvinfo.secTblOffset;
        }

        cvinfo.secTblOffset = dwExeEndFile;

        for (i = 0 ; i < 5 ; ++i) {
            cvsectbl.secOffset[i] += cvinfo.secTblOffset;
        }

        MySeek( fhOutput, cvinfo.secTblOffset, 0);
        MyWrite( fhOutput, (char *)&cvsectbl, sizeof (cvsectbl));
        MyCopy( fhInput, fhOutput, dwcb);
        MyWrite( fhOutput, (char *)&cvinfo, sizeof (cvinfo));
    }

    /* Check for new format \(NBxx\) symbols.  Since these symbols are
     *  file-position independent, just copy them over; no need to
     *  fix them up as with the old format symbols.
     */
    else if (*(unsigned short int *)cvinfo.signature == CV_SIGNATURE &&
             isdigit(cvinfo.signature[2]) && isdigit(cvinfo.signature[3])) {
        MySeek( fhOutput, 0L, 2);
        MySeek( fhInput, -cvinfo.secTblOffset, 2);
        MyCopy( fhInput, fhOutput, cvinfo.secTblOffset);
    }
}

/*  OutPutError
 *  Outputs a fatal error message and exits.
 */

static void OutPutError( char *szMessage)
{
    QuitA( 0, szMessage, NULL);
}


/*  ResTableBufferInit
 *  Creates the resource table buffer and points global pointers
 *  to it.  This table is written to so that we can modifiy it
 *  before writing it out to the EXE file.
 */

static void ResTableBufferInit( WORD wLen)
{
    /* Allocate local storage for resource table */
    pResTable = RcAlloc   (wLen);

    /* Point to the start of the table for the PutXXXX\(\) */
    pResNext = pResTable;
}

/*  ResTableBufferFree
 *  Frees the temporary storage for resource table
 */

static void ResTableBufferFree( void)
{
    /* Nuke the table */
    MyFree(pResTable);
}



/*  GetAlign
 *  Computes the alignment value needed for the given maximum file
 *  position passed in.  This is done by computing the number of
 *  bits to be shifted left in order to represent the maximum
 *  file position in 16 bits.
 */

static WORD GetAlign( DWORD dwMaxpos, WORD wAlign)
{
    DWORD dwMask;
    WORD i;

    /* Compute the initial mask based on the input align value */
    dwMask = 0xFFFFL;
    for (i = 0; i < wAlign ; ++i) {
        dwMask <<= 1;
        dwMask |= 1;
    }

    /* See if we need to increase the default mask to reach the maximum
     *  file position.
     */
    while (dwMaxpos > dwMask) {
        dwMask <<= 1;
        dwMask |= 1;
        ++wAlign;
    }

    /* Return the new alignment */
    return wAlign;
}


/*  MoveFilePos
 *  Moves the file pointer to the position indicated by wPos, using the
 *  align shift count wAlign.  This converts the WORD value wPos
 *  into a LONG value by shifting left wAlign bits.
 */

static LONG MoveFilePos( FILE *fh, WORD wPos, WORD wAlign)
{
    return MySeek(fh, ((LONG)wPos) << wAlign, 0);
}


/*  RoundUp
 *  Computes the value that should go into a 16 bit entry in an EXE
 *  table by rounding up to the next boundary determined by the
 *  passed in alignment value.
 */

static WORD RoundUp( LONG lValue, WORD wAlign)
{
    LONG lMask;

    /* Get all the default mask of all ones except in the bits below the
     *  alignment value.
     */
    lMask = -1L;
    lMask <<= wAlign;

    /* Now round up using this mask */
    lValue += ~lMask;
    lValue &= lMask;

    /* Return as a 16 bit value */
    return ((WORD) (lValue >> (LONG) wAlign));
}


/*  AlignFilePos
 *  Computes a correctly aligned file position based on the current
 *  alignment.
 */

static WORD AlignFilePos( FILE *fh, WORD wAlign, BOOL fPreload)
{
    LONG lCurPos;
    LONG lNewPos;
    LONG lMask;
    WORD nbytes;
    WORD wNewAlign;

    /* If we\'re in the preload section, we have tougher alignment
     *  restrictions:  We have to be at least 32-byte aligned and have
     *  at least 32 bytes between objects for arena headers.  It turns
     *  out that this feature is not really used in KERNEL but could be
     *  implemented someday.
     */
    if (fPreload && wAlign < PRELOAD_ALIGN) {
        wNewAlign = PRELOAD_ALIGN;
    } else {
        wNewAlign = wAlign;
    }

    /* Get the current file position */
    lCurPos = MySeek(fh, 0L, 1);

    /* Compute the new position by rounding up to the align value */
    lMask = -1L;
    lMask <<= wNewAlign;
    lNewPos = lCurPos + ~lMask;
    lNewPos &= lMask;

    /* We have to have at least 32 bytes between objects in the preload
     *  section.
     */
    if (fPreload) {
        while (lNewPos - lCurPos < PRELOAD_MINPADDING) {
            lNewPos += 1 << wNewAlign;
        }
    }

    /* Check to see if it\'s representable in 16 bits */
    if (lNewPos >= (0x10000L << wAlign)) {
        OutPutError(".EXE file too large; relink with higher /ALIGN value");
    }

    /* Write stuff out to file until new position reached */
    if (lNewPos > lCurPos) {
        /* Compute number of bytes to write out and write them out */
        nbytes = (WORD) (lNewPos - lCurPos);
        while (nbytes) {
            nbytes -= MyWrite( fh,
                               zeros,
                               (WORD)(nbytes > NUMZEROS ? NUMZEROS : nbytes));
        }
    }

    /* Seek to and return this new position */
    return (WORD)(MySeek(fh, lNewPos, (WORD) 0) >> (LONG) wAlign);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  AddResType\(\) -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

static TYPINFO *AddResType( CHAR *s, WORD n )
{
    TYPINFO *pType;

    if (pType = pTypInfo) {
        while (TRUE) {
            /* search for resource type, return if already exists */
            if ((s && !strcmp(s, pType->type)) || (!s && n && pType->typeord == n)) {
                return (pType);
            } else if (!pType->next) {
                break;
            } else {
                pType = pType->next;
            }
        }

        /* if not in list, add space for it */
        pType->next = (TYPINFO *) RcAlloc(sizeof(TYPINFO));
        pType = pType->next;
    } else {
        /* allocate space for resource list */
        pTypInfo = (TYPINFO *)RcAlloc   (sizeof(TYPINFO));
        pType = pTypInfo;
    }

    /* fill allocated space with name and ordinal, and clear the resources
       of this type */
    pType->type = MyMakeStr(s);
    pType->typeord = n;
    pType->nres = 0;
    pType->pres = NULL;
    pType->next = NULL;

    return (pType);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  GetOrdOrName\(\) -                                */
/*                                      */
/*--------------------------------------------------------------------------*/

static void GetOrdOrName( unsigned int *pint, unsigned char *szstr)
{
    unsigned char c1;

    /* read the first character of the identifier */
    MyRead(fhBin, &c1, sizeof(unsigned char));

    /* if the first character is 0xff, the id is an ordinal, else a string */
    if (c1 == 0xFF) {
        MyRead(fhBin, (PSTR)pint, sizeof (int));
    } else {                                   /* string */
        *pint = 0;
        *szstr++ = c1;
        do {
            MyRead( fhBin, szstr, 1);
        }
        while (*szstr++ != 0);
    }
}



/*--------------------------------------------------------------------------*/
/*                                      */
/*  AddDefaultTypes\(\) -                             */
/*                                      */
/*--------------------------------------------------------------------------*/

static void AddDefaultTypes( void)
{
    AddResType( "CURSOR",       ID_RT_GROUP_CURSOR);
    AddResType( "ICON",         ID_RT_GROUP_ICON);
    AddResType( "BITMAP",       ID_RT_BITMAP);
    AddResType( "MENU",         ID_RT_MENU);
    AddResType( "DIALOG",       ID_RT_DIALOG);
    AddResType( "STRINGTABLE",  ID_RT_STRING);
    AddResType( "FONTDIR",      ID_RT_FONTDIR);
    AddResType( "FONT",         ID_RT_FONT);
    AddResType( "ACCELERATORS", ID_RT_ACCELERATORS);
    AddResType( "RCDATA",       ID_RT_RCDATA);
    AddResType( "VERSIONINFO",  ID_RT_VERSION);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  ProcessBinFile\(\) -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

static int ProcessBinFile( void)
{
    unsigned int  ord;
    unsigned char tokstr[64];
    RESINFO   *pRes;
    TYPINFO   *pType;
    long      curloc;
    long      eofloc;
    WORD wResType;

    /* initialize for reading .RES file */
    AddDefaultTypes();
    eofloc = MySeek(fhBin, 0L, 2);      /* get file size */
    curloc = MySeek(fhBin, 0L, 0);      /* go to beginning of file */

    /* while there are more resources in the .RES file */
    while (curloc < eofloc) {

#ifdef VERBOSE
        if (fVerbose) {
            fprintf(errfh, ".");
            fflush(errfh);
        }
#endif

        /* find the resource type of the next resource */
        GetOrdOrName(&ord, tokstr);

        if (!ord) {
            pType = AddResType(tokstr, 0);
        } else {
            pType = AddResType(NULL, (WORD)ord);
        }

        if (!pType) {
            break;
        }

        /* Save the type number so we can see if we want to skip it later */
        wResType = ord;

        /* find the identifier \(name\) of the resource */
        GetOrdOrName(&ord, tokstr);
        pRes = (RESINFO *)RcAlloc   (sizeof(RESINFO));
        if (!ord) {
            pRes->name = MyMakeStr(tokstr);
        } else {
            pRes->nameord = ord;
        }

        /* read the flag bits */
        MyRead(fhBin, (PSTR)&pRes->flags, sizeof(int));

        /* Clear the old DISCARD bits. */
        pRes->flags &= 0x1FFF;

        /* find the size of the resource */
        MyRead(fhBin, (PSTR)&pRes->size, sizeof(long));

        /* save the position of the resource for when we add it to the .EXE */
        pRes->BinOffset = (long)MySeek(fhBin, 0L, 1);

        /* skip the resource to the next resource header */
        curloc = MySeek(fhBin, (long)pRes->size, 1);

        /* add the resource to the resource lists.  We don\'t add name
         *  tables.  They are an unnecessary 3.0 artifact.
         */
        if (wResType != ID_RT_NAMETABLE) {
            AddResToResFile(pType, pRes);
        } else {
            MyFree(pRes->name);
            MyFree(pRes);
        }
    }

    return 1;
}



/*--------------------------------------------------------------------------*/
/*                                      */
/*  AddResToResFile\(pType, pRes\)          */
/*                                      */
/*  Parameters:                                 */
/*  pType  : Pointer to Res Type                        */
/*  pRes   : Pointer to resource                        */
/*                                      */
/*--------------------------------------------------------------------------*/

static void AddResToResFile( TYPINFO *pType, RESINFO *pRes)
{
    RESINFO *p;

    p = pType->pres;

    /* add resource to end of resource list for this type */
    if (p) {
        while (p->next) {
            p = p->next;
        }

        p->next = pRes;
        p->next->next = NULL;
    } else {
        pType->pres = pRes;
        pType->pres->next = NULL;
    }
    /* keep track of number of resources and types */
    pType->nres++;
}



/*  MyMakeStr
 *  Makes a duplicate string from the string passed in.  The new string
 *  should be freed when it is no longer useful.
 */

static PSTR MyMakeStr( PSTR s)
{
    PSTR s1;

    if (s) {
        s1 = RcAlloc( (WORD)(strlen(s) + 1)); /* allocate buffer */
        strcpy(s1, s);                  /* copy string */
    } else {
        s1 = s;
    }

    return s1;
}




static SHORT MyRead( FILE *fh, PSTR p, WORD n)
{
    size_t n1;

    if ( (n1 = fread( p, 1, n, fh)) != n )
        ;                               //  quit\("RC : fatal error RW1021: I/O error reading file."\);
    else
        return ( n1);
}


/*  MyWrite
 *  Replaces calls to write\(\) and does error checking.
 */

static SHORT MyWrite( FILE *fh, PSTR p, WORD n)
{
    size_t n1;

    if ( (n1 = fwrite( p, 1, n, fh)) != n )
        ;                               // quit\("RC : fatal error RW1022: I/O error writing file."\);
    else
        return ( n1);
}



/*  MySeek
 *  Replaces calls to lseek\(\) and does error checking
 */

static LONG MySeek( FILE *fh, LONG pos, WORD cmd)
{

    if ( (pos = fseek( fh, pos, cmd)) != 0 ) {
        OutPutError ("RC : fatal error RW1023: I/O error seeking in file");
    }
    return ( pos);
}


/*  MyCopy
 *  Copies dwSize bytes from source to dest in fixed size chunks.
 */

static void MyCopy( FILE *srcfh, FILE *dstfh, DWORD dwSize)
{
    WORD n;
    static char  chCopyBuffer[ BUFSIZE];

    while ( dwSize ) {
        n = MyRead( srcfh, chCopyBuffer, sizeof( chCopyBuffer));
        MyWrite( dstfh, chCopyBuffer, n);
        dwSize -= n;
    }
}


static void RcPutWord( unsigned int w)
{
    *((WORD *)pResNext) = w;
    pResNext++;
    pResNext++;
}


/*  PutStringWord
 *  Writes a string to the static resource buffer pointed to by pResNext.
 *  The string is stored in Pascal-format \(leading byte first\).
 *  Returns the number of characters written.
 */

static int RcPutString( char *pstr)
{
    int i;

    /* Make sure we have a valid string */
    if (!pstr || !(i = strlen(pstr))) {
        return 0;
    }

    /* Write the length byte */
    *pResNext++ = (char) i;

    /* Write all the characters */
    while (*pstr) {
        *pResNext++ = *pstr++;
    }

    /* Return the length */
    return (i + 1);
}


static PSTR RcAlloc( WORD nbytes)
{
    PSTR ps = NULL;

    if ( ps = (PSTR)MyAlloc( nbytes)) {
        return ( ps);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\exentres.c ===
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>

#include "windefs.h"
#include "restok.h"
#include "exentres.h"
#include "resread.h"
#include "checksum.h"

#define SAME        0   //... Used in string compares
#define MAXLEVELS   3   //... Max # of levels in resource directory

typedef struct tagResSectData {
    ULONG ulVirtualAddress; //... Virtual address of section .rsrc
    ULONG ulSizeOfResources;    //... Size of resources in section .rsrc
    ULONG ulVirtualSize;        //... Virtual Size of resources in .rsrc
    ULONG ulVirtualAddressX;    //... Virtual address of section .rsrc1
    ULONG ulSizeOfResourcesX;   //... Size of resources in section .rsrc1
    ULONG ulVirtualSizeX;       //... Virtual Size of resources in .rsrc1
} RESSECTDATA, *PRESSECTDATA;

WORD  gwFilter = 0;

int   InsertResourcesInExe( FILE *, HANDLE);
LONG  GetFileResources(     FILE *, FILE *, ULONG);
ULONG MoveFilePos(          FILE *, ULONG);
ULONG MyWrite(              FILE *, PUCHAR, ULONG);
ULONG MyRead(               FILE *, PUCHAR, ULONG);
WCHAR *GetDirNameU(        WCHAR *, PIMAGE_RESOURCE_DIR_STRING_U);
ULONG ReadResources(        FILE *, ULONG, ULONG, PUCHAR);
DWORD AddToLangIDList( DWORD);

ULONG ProcessDirectory(  FILE *,
                         USHORT,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY);

ULONG ProcessDirEntry(   FILE *,
                         USHORT,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY_ENTRY);

ULONG ProcessSubDir(     FILE *,
                         USHORT,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY_ENTRY);

ULONG ProcessNamedEntry( FILE *,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY_ENTRY);

ULONG ProcessIdEntry(    FILE *,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DIRECTORY_ENTRY);

ULONG ProcessDataEntry(  FILE *,
                         PRESSECTDATA,
                         PIMAGE_RESOURCE_DIRECTORY,
                         PIMAGE_RESOURCE_DATA_ENTRY);

int FindNewExeHdr( FILE *, ULONG *);

IMAGE_DOS_HEADER ExeDosHdr;//... Exe's DOS header
IMAGE_NT_HEADERS NTHdrs;   //... Exe's NT headers

struct tagLevelData  //... Holds ID or name for each directory level
{
    //... level [0] is for resource type
    ULONG dwID;                     //... level [1] is for resource name
    WCHAR wszName[128];             //... level [2] is for resource language
}
LevelData[ MAXLEVELS] = { 0L, TEXT(""), 0L, TEXT(""), 0L, TEXT("")};

BOOL fGetResLangIDs = FALSE;

extern BOOL      fInThirdPartyEditer;//.. Are we in a 3rd-party resource editor?

extern MSTRDATA gMstr;              //... Data from Master Project file (MPJ)
extern PROJDATA gProj;              //... Data from Language Project file (PRJ)
extern UCHAR    szDHW[];


PLANGLIST pLangIDList = NULL;


//..........................................................................

void FreeLangIDList( void)
{
    PLANGLIST pID = NULL;

    while ( pLangIDList ) {
        pID = pLangIDList->pNext;
        RLFREE( pLangIDList);
        pLangIDList = pID;
    }
}

//..........................................................................

ULONG GetListOfResLangIDs( char *szExeName)
{
    ULONG ulRC     = SUCCESS;
    ULONG ulOffset = 0;
    static RESHEADER ResHeader;         // Structure contain Resource Header info.


    if ( IsExe( szExeName) ) {                                //.. open the original exe file
        FILE *fpExe = FOPEN( szExeName, "rb");

        if ( fpExe != NULL ) {
            //... Get list of languages in exe file

            ulRC = (ULONG)FindNewExeHdr( fpExe, &ulOffset);

            if ( ulRC == SUCCESS ) {
                fGetResLangIDs = TRUE;

                ulRC = (ULONG)GetFileResources( fpExe, NULL, ulOffset);

                fGetResLangIDs = FALSE;
            }
            FCLOSE( fpExe);
        } else {
            ulRC = ERROR_OPEN_FAILED;
        }
    } else if ( IsWin32Res( szExeName) ) {
        FILE *fpRes = FOPEN( szExeName, "rb");

        if ( fpRes != NULL ) {
            LONG  lEndOffset = 0L;


            //... How large is the res file?
            fseek( fpRes, 0L, SEEK_END);
            lEndOffset = ftell( fpRes);

            rewind( fpRes);
            //... Get list of languages in .RES file

            while ( ulRC == SUCCESS && ! feof( fpRes) ) {
                LONG lCurrOffset = 0L;


                lCurrOffset = (LONG)ftell( fpRes);

                if ( (lCurrOffset + (LONG)sizeof( RESHEADER)) >= lEndOffset ) {
                    break;
                }

                if ( GetResHeader( fpRes, &ResHeader, NULL) == -1 ) {
                    ulRC = 1L;
                    break;
                }
                //... Is this the dummy, res32-identifying, res?

                if ( ResHeader.lSize == 0L ) {
                    continue;
                }
                ulRC = AddToLangIDList( (DWORD)ResHeader.wLanguageId);

                SkipBytes( fpRes, (DWORD *)&ResHeader.lSize);
                ClearResHeader( ResHeader);

                DWordUpFilePointer( fpRes, MYREAD, ftell( fpRes), NULL);

            }   // END while ( ! feof( InResFile)
            FCLOSE( fpRes);
        } else {
            ulRC = ERROR_OPEN_FAILED;
        }
    }

    if ( ulRC != SUCCESS ) {
        FreeLangIDList();
    }
    return ( ulRC);
}

//..........................................................................

int ExtractResFromExe32A(

                        char *szExeName,
                        char *szResName,
                        WORD  wFilter)
{
    FILE *fpExe = NULL;        //... Handle of input .EXE file
    FILE *fpRes = NULL;        //... Handle of output .RES file
    ULONG ulRC     = 0;
    ULONG ulOffset = 0;
    int nRC = SUCCESS;


    gwFilter = wFilter;

    //.. open the original exe file

    fpExe = FOPEN( szExeName, "rb");

    if ( fpExe == NULL ) {
        return ( ERROR_OPEN_FAILED);
    }
    nRC = FindNewExeHdr( fpExe, &ulOffset);

    if ( nRC != SUCCESS ) {
        FCLOSE( fpExe);
        return ( nRC);
    }
    fpRes = FOPEN( (CHAR *)szResName, "wb");

    if ( fpRes != NULL ) {
        //... First, write the dummy 32bit identifier

        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x20, NULL);
        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x00, NULL);
        PutByte( fpRes, 0x00, NULL);

        PutWord( fpRes, 0xffff, NULL);
        PutWord( fpRes, 0x00,   NULL);
        PutWord( fpRes, 0xffff, NULL);
        PutWord( fpRes, 0x00,   NULL);

        PutdWord( fpRes, 0L, NULL);
        PutdWord( fpRes, 0L, NULL);

        PutdWord( fpRes, 0L, NULL);
        PutdWord( fpRes, 0L, NULL);

        ulRC = (ULONG)GetFileResources( fpExe, fpRes, ulOffset);

        FCLOSE( fpRes);
    } else {
        ulRC = GetLastError();
    }
    FCLOSE( fpExe);
    return ( ulRC);
}

//..........................................................................

int BuildExeFromRes32A(

                      char * szOutExe,    //... Output EXE file's name
                      char * szRes,       //... File of replacement resources
                      char * szInExe )    //... Intput EXE file's name
{
    HANDLE  hExeFile = NULL;
    FILE    *fpRes = NULL;
    DWORD   dwRC = 0;
    WORD    wRC  = 0;


    //... Copy Input exe to out put exe

    if ( CopyFileA( szInExe, szOutExe, FALSE) == FALSE ) {
        QuitA( IDS_COPYFILE_FAILED, szInExe, szOutExe);
    }

    if ( (fpRes = FOPEN( szRes, "rb")) == NULL ) {
        return -2;
    }

    SetLastError(0);

//if Source file was set attributes READ-ONLY, CopyFile sets temp file also.
//And BeginUpdateResourceA returns ERROR.

    SetFileAttributesA(szOutExe, FILE_ATTRIBUTE_NORMAL);

    hExeFile = BeginUpdateResourceA( szOutExe, TRUE);

    dwRC = GetLastError();

    if ( ! hExeFile ) {
        FCLOSE( fpRes);
        return ( -3);
    }

    wRC = (WORD)InsertResourcesInExe( fpRes, hExeFile);

    FCLOSE( fpRes);

    if ( wRC != 1 ) {
        return ( wRC);
    }

    SetLastError(0);    // needed only to see if EndUpdateResource
    // sets last error value.

    dwRC = EndUpdateResource( hExeFile, FALSE);

    if ( dwRC == FALSE ) {
        return ( -4);
    }
    MapFileAndFixCheckSumA( szOutExe); //... This func always calls QuitT or returns 0

    return (1);
}

//..........................................................................

int FindNewExeHdr( FILE *fpExe, ULONG *ulOffset)
{
    ULONG ulRC     = 0;

    //... read the old format EXE header

    ulRC = MyRead( fpExe, (void *)&ExeDosHdr, sizeof( ExeDosHdr));

    if ( ulRC != 0L && ulRC != sizeof( ExeDosHdr) ) {
        return ( ERROR_READ_FAULT);
    }

    //... make sure its really an EXE file

    if ( ExeDosHdr.e_magic != IMAGE_DOS_SIGNATURE ) {
        return ( ERROR_INVALID_EXE_SIGNATURE);
    }

    //... make sure theres a new EXE header
    //... floating around somewhere

    if ( ! (*ulOffset = ExeDosHdr.e_lfanew) ) {
        return ( ERROR_BAD_EXE_FORMAT);
    }
    return ( SUCCESS);
}

//..........................................................................

int InsertResourcesInExe(

                        FILE *fpRes,
                        HANDLE hExeFile )
{
    PVOID   pResData   = NULL;
    LONG    lEndOffset = 0L;
    BOOL    bUpdRC     = FALSE;
    LANGID  wLangID    = 0;
    int nResCnt = 0;
    int nResOut = 0;
    static RESHEADER    ResHeader;

    //... How big is the .RES file?

    fseek( fpRes, 0L, SEEK_END);
    lEndOffset = ftell( fpRes);

    rewind( fpRes);

    //... Update all resources, found in the .RES,
    //... to the .EXE
    while ( ! feof( fpRes) ) {
        DWordUpFilePointer( fpRes, MYREAD, ftell( fpRes), NULL);
        RLFREE( pResData);

        if (  ftell( fpRes) >= lEndOffset ) {
            return (1);
        }
        ZeroMemory( &ResHeader, sizeof( ResHeader));

        // Read in the resource header

        if ( ( GetResHeader( fpRes, &ResHeader, (DWORD *) NULL) == -1 ) ) {
            return ( -1);
        }

        if ( ResHeader.lSize > 0L ) {
            wLangID = ResHeader.wLanguageId;

            // Allocate Memory to hold resource data

            pResData = (PVOID)FALLOC( ResHeader.lSize);

            // Read it into the buffer

            if ( ResReadBytes( fpRes,
                               pResData,
                               (size_t)ResHeader.lSize,
                               NULL ) == FALSE ) {
                RLFREE( pResData);
                return (-1);
            }

            nResCnt++;   // Increment # resources read

            DWordUpFilePointer( fpRes, MYREAD, ftell( fpRes), NULL);
        } else {
            continue;
        }

        // now write the data

        if ( ResHeader.bTypeFlag == IDFLAG ) {
            if ( ResHeader.bNameFlag == IDFLAG ) {
                SetLastError(0);

                bUpdRC = UpdateResource( hExeFile,
                                         MAKEINTRESOURCE( ResHeader.wTypeID),
                                         MAKEINTRESOURCE( ResHeader.wNameID),
                                         wLangID,
                                         pResData,
                                         ResHeader.lSize);

                if ( ! bUpdRC ) {
                    RLFREE( pResData);
                    return (-1);
                }
            } else {
                SetLastError(0);

                bUpdRC = UpdateResource( hExeFile,
                                         MAKEINTRESOURCE( ResHeader.wTypeID),
                                         ResHeader.pszName,
                                         wLangID,
                                         pResData,
                                         ResHeader.lSize);

                if ( ! bUpdRC ) {
                    RLFREE( pResData);
                    return (-1);
                }
            }
        } else {
            if (ResHeader.bNameFlag == IDFLAG) {
                SetLastError(0);//BUGUG

                bUpdRC = UpdateResource( hExeFile,
                                         ResHeader.pszType,
                                         MAKEINTRESOURCE( ResHeader.wNameID),
                                         wLangID,
                                         pResData,
                                         ResHeader.lSize);

                if ( ! bUpdRC ) {
                    RLFREE( pResData);
                    return (-1);
                }
            } else {
                SetLastError(0);

                bUpdRC = UpdateResource( hExeFile,
                                         ResHeader.pszType,
                                         ResHeader.pszName,
                                         wLangID,
                                         pResData,
                                         ResHeader.lSize);

                if ( ! bUpdRC ) {
                    RLFREE( pResData);
                    return (-1);
                }
            }
        }
        ClearResHeader( ResHeader);
        RLFREE( pResData);
    }               //... END WHILE ( ! feof...
    return (1);
}

//............................................................

LONG GetFileResources(

                     FILE *fpExe,
                     FILE *fpRes,
                     ULONG ulHdrOffset)
{
    ULONG  ulOffsetToResources;
    ULONG  ulOffsetToResourcesX;
    ULONG  ulRead;
    ULONG  ulToRead;
    ULONG  ulRC = SUCCESS;
    PUCHAR pResources = NULL;  //... Ptr to start of resource directory table

    PIMAGE_SECTION_HEADER pSectTbl     = NULL;
    PIMAGE_SECTION_HEADER pSectTblLast = NULL;
    PIMAGE_SECTION_HEADER pSect        = NULL;
    PIMAGE_SECTION_HEADER pResSect     = NULL;
    PIMAGE_SECTION_HEADER pResSectX    = NULL;
    static RESSECTDATA ResSectData;

    //... Read the NT image headers into memory

    ulRC = MoveFilePos( fpExe, ulHdrOffset);

    if ( ulRC != 0L ) {
        return ( -1L);
    }
    ulRead = MyRead( fpExe, (PUCHAR)&NTHdrs, sizeof( IMAGE_NT_HEADERS));

    if ( ulRead != 0L && ulRead != sizeof( IMAGE_NT_HEADERS) ) {
        return ( -1L);
    }
    //... Check for valid exe

    if ( *(PUSHORT)&NTHdrs.Signature != IMAGE_NT_SIGNATURE ) {
        return ( ERROR_INVALID_EXE_SIGNATURE);
    }

    if ((NTHdrs.FileHeader.Characteristics&IMAGE_FILE_EXECUTABLE_IMAGE) == 0 &&
        (NTHdrs.FileHeader.Characteristics&IMAGE_FILE_DLL) == 0) {
        return ( ERROR_EXE_MARKED_INVALID);
    }
    //... Where is resource section in file
    //... and how big is it?

    //... First, read section table

    ulToRead = NTHdrs.FileHeader.NumberOfSections
               * sizeof( IMAGE_SECTION_HEADER);
    pSectTbl = (PIMAGE_SECTION_HEADER)FALLOC( ulToRead);

    memset( (PVOID)pSectTbl, 0, ulToRead);

    ulHdrOffset += sizeof(ULONG) + sizeof(IMAGE_FILE_HEADER) +
                   NTHdrs.FileHeader.SizeOfOptionalHeader;
    MoveFilePos( fpExe, ulHdrOffset);
    ulRead = MyRead( fpExe, (PUCHAR)pSectTbl, ulToRead);

    if ( ulRead != 0L && ulRead != ulToRead ) {
        SetLastError(ERROR_BAD_FORMAT);
        RLFREE( pSectTbl);
        return ( -1L);
    }
    pSectTblLast = pSectTbl + NTHdrs.FileHeader.NumberOfSections;

    for ( pSect = pSectTbl; pSect < pSectTblLast; ++pSect ) {
        if ( lstrcmpA( (CHAR *)pSect->Name, ".rsrc") == SAME && pResSect==NULL ) {
            pResSect = pSect;
        } else if ( lstrcmpA( (CHAR *)pSect->Name, ".rsrc1") == SAME && pResSectX==NULL ) {
            pResSectX = pSect;
        }
    }

    if ( pResSect == NULL ) {
        RLFREE( pSectTbl);
        QuitA( IDS_NO_RES_SECTION, gMstr.szSrc, NULL);
    }

    ulOffsetToResources  = pResSect->PointerToRawData;
    ulOffsetToResourcesX = pResSectX ? pResSectX->PointerToRawData : 0L;

    ResSectData.ulVirtualAddress   = pResSect->VirtualAddress;
    ResSectData.ulSizeOfResources  = pResSect->SizeOfRawData;
    ResSectData.ulVirtualSize      = pResSect->Misc.VirtualSize;
    ResSectData.ulVirtualAddressX  = pResSectX ? pResSectX->VirtualAddress : 0L;
    ResSectData.ulSizeOfResourcesX = pResSectX ? pResSectX->SizeOfRawData  : 0L;
    ResSectData.ulVirtualSizeX   = pResSectX ? pResSectX->Misc.VirtualSize : 0L;

    //... Read resource section into memory

    pResources = (PUCHAR)FALLOC((ulToRead =
                                 (max(ResSectData.ulVirtualSize,  ResSectData.ulSizeOfResources) +
                                  max(ResSectData.ulVirtualSizeX, ResSectData.ulSizeOfResourcesX))));
    memset( (PVOID)pResources, 0, ulToRead);

    ulRC = ReadResources( fpExe,
                          ulOffsetToResources,
                          ResSectData.ulSizeOfResources,
                          pResources);

    if ( ulRC != 0L ) {
        RLFREE( pSectTbl);
        RLFREE( pResources);
        return ( ulRC);
    } else if ( ResSectData.ulSizeOfResourcesX > 0L ) {
        ulRC = ReadResources( fpExe,
                              ulOffsetToResourcesX,
                              ResSectData.ulSizeOfResourcesX,
                              &pResources[ ResSectData.ulVirtualSize]);
        if ( ulRC != 0L ) {
            RLFREE( pSectTbl);
            RLFREE( pResources);
            return ( ulRC);
        }
    }
    //... Now process the resource table

    ulRC = ProcessDirectory( fpRes,
                             0,
                             &ResSectData,
                             (PIMAGE_RESOURCE_DIRECTORY)pResources,
                             (PIMAGE_RESOURCE_DIRECTORY)pResources);

    RLFREE( pSectTbl);
    RLFREE( pResources);

    return ( (LONG)ulRC);
}

//......................................................................

ULONG ProcessDirectory(

                      FILE *fpRes,
                      USHORT usLevel,
                      PRESSECTDATA pResSectData,
                      PIMAGE_RESOURCE_DIRECTORY pResStart,
                      PIMAGE_RESOURCE_DIRECTORY pResDir)
{
    ULONG ulRC = SUCCESS;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirStart;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEnd;


    pResDirStart = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)
                   ((PBYTE)pResDir + sizeof( IMAGE_RESOURCE_DIRECTORY));

    pResDirEnd = pResDirStart
                 + pResDir->NumberOfNamedEntries
                 + pResDir->NumberOfIdEntries;

    for ( pResDirEntry = pResDirStart, ulRC = 0L;
        pResDirEntry < pResDirEnd && ulRC == 0L;
        ++pResDirEntry ) {
        ulRC = ProcessDirEntry( fpRes,
                                usLevel,
                                pResSectData,
                                pResStart,
                                pResDirEntry);
    }
    return ( ulRC);
}

//......................................................................

ULONG ProcessDirEntry(

                     FILE *fpRes,
                     USHORT usLevel,
                     PRESSECTDATA pResSectData,
                     PIMAGE_RESOURCE_DIRECTORY pResStart,
                     PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    ULONG ulRC = SUCCESS;

    if ( pResDirEntry->Name & IMAGE_RESOURCE_NAME_IS_STRING ) {
        GetDirNameU( LevelData[ usLevel].wszName,
                     (PIMAGE_RESOURCE_DIR_STRING_U)((PBYTE)pResStart
                                                    + (pResDirEntry->Name & (~IMAGE_RESOURCE_NAME_IS_STRING))));
        LevelData[ usLevel].dwID = IMAGE_RESOURCE_NAME_IS_STRING;
    } else {
        LevelData[ usLevel].wszName[0] = TEXT('\0');
        LevelData[ usLevel].dwID = pResDirEntry->Name;
    }

    if ( pResDirEntry->OffsetToData & IMAGE_RESOURCE_DATA_IS_DIRECTORY ) {
        ulRC = ProcessSubDir( fpRes,
                              usLevel,
                              pResSectData,
                              pResStart,
                              pResDirEntry);
    } else if ( pResDirEntry->Name & IMAGE_RESOURCE_NAME_IS_STRING ) {
        ulRC = ProcessNamedEntry( fpRes, pResSectData, pResStart, pResDirEntry);
    } else {
        ulRC = ProcessIdEntry( fpRes, pResSectData, pResStart, pResDirEntry);
    }
    return ( ulRC);
}

//......................................................................

ULONG ProcessSubDir(

                   FILE *fpRes,
                   USHORT usLevel,
                   PRESSECTDATA pResSectData,
                   PIMAGE_RESOURCE_DIRECTORY pResStart,
                   PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    PIMAGE_RESOURCE_DIRECTORY pResDir;

    pResDir = (PIMAGE_RESOURCE_DIRECTORY)((PBYTE)pResStart
                                          + (pResDirEntry->OffsetToData & (~IMAGE_RESOURCE_DATA_IS_DIRECTORY)));

    return ( ++usLevel < MAXLEVELS ? ProcessDirectory( fpRes,
                                                       usLevel,
                                                       pResSectData,
                                                       pResStart,
                                                       pResDir)
             : -1L);
}

//......................................................................

ULONG ProcessIdEntry(

                    FILE *fpRes,
                    PRESSECTDATA pResSectData,
                    PIMAGE_RESOURCE_DIRECTORY pResStart,
                    PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    return ( ProcessDataEntry( fpRes,
                               pResSectData,
                               pResStart,
                               (PIMAGE_RESOURCE_DATA_ENTRY)((PBYTE)pResStart
                                                            + pResDirEntry->OffsetToData)));
}


//......................................................................

ULONG ProcessNamedEntry(

                       FILE *fpRes,
                       PRESSECTDATA pResSectData,
                       PIMAGE_RESOURCE_DIRECTORY pResStart,
                       PIMAGE_RESOURCE_DIRECTORY_ENTRY pResDirEntry)
{
    return ( ProcessDataEntry( fpRes,
                               pResSectData,
                               pResStart,
                               (PIMAGE_RESOURCE_DATA_ENTRY)((PBYTE)pResStart
                                                            + pResDirEntry->OffsetToData)));
}

//......................................................................

ULONG ProcessDataEntry(

                      FILE *fpRes,
                      PRESSECTDATA pResSectData,
                      PIMAGE_RESOURCE_DIRECTORY  pResStart,
                      PIMAGE_RESOURCE_DATA_ENTRY pResData)
{
    ULONG  ulOffset;
    ULONG  ulCopied;
    DWORD  dwHdrSize = 0L;
    fpos_t HdrSizePos;


    if ( fGetResLangIDs ) {      //... Are we just looking for LANG IDs?
        return ( AddToLangIDList( (WORD)(LevelData[2].dwID)));
    }

    if ( gwFilter != 0 ) {        //... Filtering turned on?
        //... Yes, is this a resource we want?
        if ( LevelData[0].dwID == IMAGE_RESOURCE_NAME_IS_STRING
             || LevelData[0].dwID != (DWORD)gwFilter ) {
            return ( 0L);        //... Not a resource we want
        }
    }

    //... Are we in the dialog editor?
    if ( fInThirdPartyEditer ) {                           //... Is the language we want?
        if ( LevelData[2].dwID != gMstr.wLanguageID ) {
            return ( 0L);        //... Not the language we want
        }
    }


    ulOffset = pResData->OffsetToData - pResSectData->ulVirtualAddress;

    if ( ulOffset >= pResSectData->ulVirtualSize ) {
        if ( pResSectData->ulVirtualSizeX > 0L ) {
            ulOffset = pResData->OffsetToData
                       + pResSectData->ulVirtualSize
                       - pResSectData->ulVirtualAddressX;

            if ( ulOffset >= pResSectData->ulVirtualSize
                 + pResSectData->ulSizeOfResourcesX ) {
                return ( (ULONG)-1L);
            }
        } else {
            return ( (ULONG)-1L);
        }
    }
    //... write out the resource header info
    //... First, write the resource's size

    PutdWord( fpRes, pResData->Size, &dwHdrSize);

    //... Remember where to write real hdr size and
    //... write out bogus hdr size, fix up later

    fgetpos( fpRes, &HdrSizePos);
    PutdWord( fpRes, 0, &dwHdrSize);

    //... Write resource type

    if ( LevelData[0].dwID == IMAGE_RESOURCE_NAME_IS_STRING ) {
        PutString( fpRes, (TCHAR *)LevelData[0].wszName, &dwHdrSize);
    } else {
        PutWord( fpRes, IDFLAG, &dwHdrSize);
        PutWord( fpRes, LOWORD( LevelData[0].dwID), &dwHdrSize);
    }

    //... Write resource name
    //... dbl-null-terminated if string

    if ( LevelData[1].dwID == IMAGE_RESOURCE_NAME_IS_STRING ) {
        PutString( fpRes, (TCHAR *)LevelData[1].wszName, &dwHdrSize);
    } else {
        PutWord( fpRes, IDFLAG, &dwHdrSize);
        PutWord( fpRes, LOWORD( LevelData[1].dwID), &dwHdrSize);
    }

    DWordUpFilePointer( fpRes, MYWRITE, ftell( fpRes), &dwHdrSize);

    //... More Win32 header stuff

    PutdWord( fpRes, 0, &dwHdrSize);        //... Data version
    PutWord( fpRes, 0x1030, &dwHdrSize);    //... MemoryFlags (WORD)

    //... language is always a number (WORD)

    PutWord( fpRes, LOWORD( LevelData[2].dwID), &dwHdrSize);

    //... More Win32 header stuff

    PutdWord( fpRes, 0, &dwHdrSize);        //... Version
    PutdWord( fpRes, 0, &dwHdrSize);        //... Characteristics

    //... Now, fix up the resource header size

    UpdateResSize( fpRes, &HdrSizePos, dwHdrSize);

    //... Copy the resource data to the res file

    ulCopied = MyWrite( fpRes, (PUCHAR)pResStart + ulOffset, pResData->Size);

    if ( ulCopied != 0L && ulCopied != pResData->Size ) {
        return ( (ULONG)-1);
    }
    DWordUpFilePointer( fpRes, MYWRITE, ftell( fpRes), NULL);
    return ( 0L);
}

//......................................................................

/*
 * Utility routines
 */


ULONG ReadResources(

                   FILE  *fpExe,
                   ULONG  ulOffsetToResources,
                   ULONG  ulSizeOfResources,
                   PUCHAR pResources)
{
    ULONG ulRC = SUCCESS;
    ULONG ulRead;


    ulRC = MoveFilePos( fpExe, ulOffsetToResources);

    if ( ulRC != 0L ) {
        return ( (ULONG)-1L);
    }
    ulRead = MyRead( fpExe, pResources, ulSizeOfResources);

    if ( ulRead != 0L && ulRead != ulSizeOfResources ) {
        return ( (ULONG)-1L);
    }
    return ( 0L);
}

//......................................................................

WCHAR * GetDirNameU(

                   WCHAR *pszDest,
                   PIMAGE_RESOURCE_DIR_STRING_U pDirStr)
{
    CopyMemory( pszDest, pDirStr->NameString, MEMSIZE( pDirStr->Length));
    pszDest[ pDirStr->Length] = L'\0';
    return ( pszDest);
}

//......................................................................

ULONG MoveFilePos( FILE *fp, ULONG pos)
{
    return ( fseek( fp, pos, SEEK_SET));
}

//......................................................................

ULONG MyWrite( FILE *fp, UCHAR *p, ULONG ulToWrite)
{
    size_t  cWritten;



    cWritten = fwrite( p, 1, (size_t)ulToWrite, fp);

    return ( (ULONG)(cWritten == ulToWrite ? 0L : cWritten));
}

//......................................................................

ULONG MyRead( FILE *fp, UCHAR*p, ULONG ulRequested )
{
    size_t  cRead;


    cRead = fread( p, 1, (size_t)ulRequested, fp);

    return ( (ULONG)(cRead == ulRequested ? 0L : cRead));
}

//......................................................................

DWORD AddToLangIDList( DWORD dwLangID)
{
    WORD wLangID = (WORD)dwLangID;

    if ( pLangIDList ) {
        PLANGLIST pID;

        for ( pID = pLangIDList; pID; pID = pID->pNext ) {
            if ( pID->wLang == wLangID ) {
                break;          //... LANGID already in list
            } else if ( pID->pNext == NULL ) {
                pID->pNext = (PLANGLIST)FALLOC( sizeof( LANGLIST));
                pID = pID->pNext;
                pID->pNext = NULL;
                pID->wLang = wLangID;
                //... LANGID now added to list
            }
        }
    } else {
        pLangIDList = (PLANGLIST)FALLOC( sizeof( LANGLIST));
        pLangIDList->pNext = NULL;
        pLangIDList->wLang = wLangID;
    }
    return ( SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\langlist.h ===
// This file will get used when the "list of languages" feature is added.

#define ID_LANGID_LIST  1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\ntmsgtbl.h ===
#ifndef _NTMSGTBL_H_
#define _NTMSGTBL_H_

VOID  *GetResMessage( FILE *, DWORD *);
void   PutResMessage( FILE *, FILE *, RESHEADER, VOID *);
void   TokResMessage( FILE *, RESHEADER, VOID *);
void   ClearResMsg(   VOID **);


#endif	 //... _NTMSGTBL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RLSTRNGS.RC
//
#define IDS_UPDATE_YESNO                3101
#define IDS_UPDATE_TITLE                3102
#define IDS_UPDATE_CANCEL               3103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\newexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERESWDS]; /* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    unsigned short int  ne_magic;       /* Magic number NE_MAGIC */
    char                ne_ver;         /* Version number */
    char                ne_rev;         /* Revision number */
    unsigned short int  ne_enttab;      /* Offset of Entry Table */
    unsigned short int  ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short int  ne_flags;       /* Flag word */
    unsigned short int  ne_autodata;    /* Automatic data segment number */
    unsigned short int  ne_heap;        /* Initial heap allocation */
    unsigned short int  ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short int  ne_cseg;        /* Count of file segments */
    unsigned short int  ne_cmod;        /* Entries in Module Reference Table */
    unsigned short int  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short int  ne_segtab;      /* Offset of Segment Table */
    unsigned short int  ne_rsrctab;     /* Offset of Resource Table */
    unsigned short int  ne_restab;      /* Offset of resident name table */
    unsigned short int  ne_modtab;      /* Offset of Module Reference Table */
    unsigned short int  ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short int  ne_cmovent;     /* Count of movable entries */
    unsigned short int  ne_align;       /* Segment alignment shift count */
    unsigned short int  ne_cres;        /* Count of resource segments */

#ifdef NEVER
    unsigned short int  ne_psegcsum;    /* offset to segment chksums */
#else
    unsigned char	ne_exetyp;	/* Target Operating system */
    unsigned char	ne_flagsothers;	/* Other .EXE flags */
#endif
    unsigned short int  ne_pretthunks;  /* offset to return thunks */
    unsigned short int  ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int  ne_swaparea;    /* Minimum code swap area size */
    unsigned short int  ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res
#define NE_EXETYPE(x)	(x).ne_exetyp

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   c                                  Non-conforming
 *    e                                 Errors in image
 *     xxxxxxxxx                        Unused
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
    unsigned short      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    char                nr_stype;       /* Source type */
    char                nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            char        nr_segno;       /* Target segment number */
            char        nr_res;         /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define OSFIXUP 	0x03		/* Floating point fixup */


/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;            /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004	/* True if handler proc return handle */

#define RNCOMPR     0x0200	/* Resource is compressed in ROM */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

/* Target operating systems:  Possible values of ne_exetyp field */

#define NE_UNKNOWN	0	/* Unknown (any "new-format" OS) */
#define NE_OS2		1	/* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS	2	/* Microsoft Windows		 */
#define NE_DOS4 	3	/* Microsoft MS-DOS 4.x		 */
#define NE_DEV386	4	/* Microsoft Windows 386	 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\ntmsgtbl.c ===
//.....................................................................
//...
//... NTMSGTBL.C
//...
//... Contains functions for handling strings found in NT's Message
//... Resource Tables.  This recource type is not present in Win 3.1.
//...
//... Author - David Wilcox (davewi@microsoft)
//...
//... NOTES:  Created with tabstop set to 8
//...
//.....................................................................
//...
//... History:
//... Original - 10/92
//...            11/92 - Fixed to handle ULONG msg ID#'s - davewi
//...
//.....................................................................

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windef.h>
#include <tchar.h>
#include <winver.h>

#include "windefs.h"
#include "restok.h"
#include "custres.h"
#include "ntmsgtbl.h"
#include "resread.h"


typedef PMESSAGE_RESOURCE_ENTRY PMRE;

extern BOOL  gbMaster;
extern UCHAR szDHW[];

static PBYTE *pBlockEntries = NULL;

VOID  *pResMsgData = NULL;      // NT-specific Message Table resource


//.........................................................................
//...
//... Get Message Table from .res file
//...
//... This form of a message table, not found in Win 16, allows very long
//... strings and the text is stored as an ASCIIZ string in the .res file.


VOID *GetResMessage(

FILE  *pInResFile,      //... The file containing the resources
DWORD *plSize)          //... The size of this resource from GetResHeader
{
    ULONG  ulNumBlocks = 0L;            //... # of Message Table resource blocks
    ULONG  ulStartMsgDataPos = 0L;      //... Start of message data in file
    ULONG  ulBlock;                     //... Current message block number
    USHORT usCurrBlockSize  = 0;        //... Current size of temp block buffer
    USHORT usDeltaBlockSize = 4096;     //... Amount to increase usCurrBlockSize
    DWORD  dwNumMsgs = 0;               //... Count of msgs in the resource
    PBYTE  pMsgBlock = NULL;            //... Temp message block buffer

    PMESSAGE_RESOURCE_DATA  pMsgResData;//... Returned as ptr to the resource
    PMESSAGE_RESOURCE_BLOCK pMRB;       //... ptr to a block of messages



                                //... The resource header was read prior to
                                //... entring this function, so the current
                                //... file position should now be the start
                                //... of the resource data.

    ulStartMsgDataPos = ftell( pInResFile);

                                //... Get the number of message blocks and
                                //... allocate enough memory for the array.

    ulNumBlocks = GetdWord( pInResFile, plSize);

                                //... Allocate space for the array of
                                //... pointers to entries.  This array is used
                                //... to store pointers to the first entry
                                //... in each block of message entries.

    pBlockEntries = (PBYTE *)FALLOC( ulNumBlocks * sizeof( PBYTE));

    if ( ! pBlockEntries )
    {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    }

    pMsgResData = (PMESSAGE_RESOURCE_DATA)FALLOC( sizeof( ULONG) + ulNumBlocks
                                                   * sizeof( MESSAGE_RESOURCE_BLOCK));

    if ( ! pMsgResData )
    {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    }
    pResMsgData = pMsgResData;
    pMsgResData->NumberOfBlocks = ulNumBlocks;

                                //... Read the array of message block structs,
                                //... and initialize block entry pointer array.

    for ( ulBlock = 0L, pMRB = pMsgResData->Blocks;
          ulBlock < ulNumBlocks;
          ++ulBlock, ++pMRB )
    {
        pMRB->LowId           = GetdWord( pInResFile, plSize);
        pMRB->HighId          = GetdWord( pInResFile, plSize);
        pMRB->OffsetToEntries = GetdWord( pInResFile, plSize);

        if ( pMRB->HighId < pMRB->LowId )
        {
            ClearResMsg( &pResMsgData);
            QuitT( IDS_ENGERR_16, (LPTSTR)IDS_INVMSGRNG, NULL);
        }
        dwNumMsgs += (pMRB->HighId - pMRB->LowId + 1);

        pBlockEntries[ ulBlock] = NULL;
    }

                                //... Read in the MESSAGE_RESOURCE_ENTRY

    usCurrBlockSize = usDeltaBlockSize;

    for ( ulBlock = 0L, pMRB = pMsgResData->Blocks;
          ulBlock < ulNumBlocks;
          ++ulBlock, ++pMRB )
    {
        ULONG   ulCurrID;       //... Current message ID # in this block
        ULONG   ulEndID;        //... Last message ID # in this block + 1
        USHORT  usLen;          //... For length of a message - MUST BE USHORT
        USHORT  usMsgBlkLen;    //... Length of a block of messages


        usMsgBlkLen = 0;

                                //... Move to start of block of message entries
                                //... then read all the messages in this block.

        fseek( pInResFile,
               ulStartMsgDataPos + pMRB->OffsetToEntries,
               SEEK_SET);

        for ( ulCurrID = pMRB->LowId, ulEndID = pMRB->HighId + 1;
              ulCurrID < ulEndID;
              ++ulCurrID, --dwNumMsgs )
        {
                                //... Get Msg Resource entry length
                                //... (Length is in bytes and includes
                                //...  .Length and .Flags fields and any
                                //...  padding that may exist after the text.)

            usLen = GetWord( pInResFile, plSize);

            if ( usLen >= 2 * sizeof( USHORT) )
            {
                PMRE   pMRE;
                PUCHAR puchText;

                                //... Create, or expand size of, pMsgBlkData
                                //... so we can append this entry.
                                //... Always resave ptr to the message block
                                //... (it may have moved).

                if ( pMsgBlock )
                {
                    if ( (USHORT)(usMsgBlkLen + usLen) > usCurrBlockSize )
                    {
                        usCurrBlockSize += __max(usDeltaBlockSize, (USHORT)(usMsgBlkLen + usLen));
                        pMsgBlock = (PBYTE)FREALLOC( pMsgBlock,
                                                      usCurrBlockSize);
                    }
                }
                else
                {
                    pMsgBlock = FALLOC( usCurrBlockSize);
                }

                                //... If the malloc worked, read this msg entry.
                                //... The section assumes there is one WORD
                                //... per USHORT and one WORD per WCHAR.

                pMRE = (PMRE)(pMsgBlock + usMsgBlkLen);

                                //... Store the .Length field value (USHORT)

                pMRE->Length = usLen;
                usMsgBlkLen += usLen;

                                //... Get the .Flags field value (USHORT)

                pMRE->Flags = GetWord( pInResFile, plSize);

                                //... Check to make sure this message is stored
                                //... either in ASCII in the current code page
                                //... or in Unicode, else fail.

                if ( pMRE->Flags != 0                           //... ASCII
                  && pMRE->Flags != MESSAGE_RESOURCE_UNICODE )  //... Unicode
                {
                    if ( pMsgBlock != NULL )
                    {
                        RLFREE( pMsgBlock);
                    }
                    ClearResMsg( &pResMsgData);
                    QuitA( IDS_NON0FLAG, NULL, NULL);
                }

                                //... Get the .Text field string

                usLen -= (2 * sizeof( WORD));

                for ( puchText = (PUCHAR)pMRE->Text; usLen; ++puchText, --usLen )
                {
                    *puchText = (UCHAR)GetByte( pInResFile, plSize);
                }
                DWordUpFilePointer( pInResFile,
                                    MYREAD,
                                    ftell( pInResFile),
                                    plSize);
            }
            else
            {
                if ( pMsgBlock != NULL )
                {
                    RLFREE( pMsgBlock);
                }
                ClearResMsg( &pResMsgData);
                QuitT( IDS_ENGERR_05, (LPTSTR)IDS_INVMSGTBL, NULL);
            }
        }                       //... END FOR(each message entry in this block)

        if ( pMsgBlock != NULL && usMsgBlkLen > 0 )
        {
            pBlockEntries[ ulBlock] = FALLOC( usMsgBlkLen);

            memcpy( pBlockEntries[ ulBlock], pMsgBlock, usMsgBlkLen);
        }
    }                           //... END FOR(each message block)

    if ( pMsgBlock != NULL )
    {
        RLFREE( pMsgBlock);
    }

    DWordUpFilePointer( pInResFile, MYREAD, ftell( pInResFile), plSize);

    return( (VOID *)pMsgResData);
}




//.........................................................................
//...
//... Put localized Message Table into .res
//...
//... 01/93 - changes for var length Token text.  MHotchin
//... 02/93 - stripped out code that split msgs into multiple tokens.  davewi

void PutResMessage(

FILE *fpOutResFile,     //... File to which localized resources are written
FILE *fpInTokFile,      //... Output token file
RESHEADER ResHeader,    //... Resource header data
VOID *pMsgResData)      //... message table data built in GetResMessage
{
    WORD   wcCount = 0;
    fpos_t ulResSizePos   = 0L; //... File position for fixed up resource size
    fpos_t ulBlocksStartPos=0L; //... File position of start of message blocks
    ULONG  ulNumBlocks    = 0L; //... Number of Message Blocks
    ULONG  ulCurrOffset   = 0L; //... Offset to current msg block
    ULONG  ulResSize      = 0L; //... Size of this resource
    ULONG  ulBlock;             //... Temporary counter
    USHORT usEntryLen = 0;      //... Length of current message entry
    PMESSAGE_RESOURCE_DATA pData; //. Message table data from InResFile
    static TOKEN  Tok;          //... Token from localized token file


    if ( pMsgResData == NULL)
    {
        QuitT( IDS_ENGERR_05, (LPTSTR)IDS_NULMSGDATA, NULL);
    }
    memset( (void *)&Tok, 0, sizeof( Tok));
    pData = (PMESSAGE_RESOURCE_DATA)pMsgResData;

    if ( PutResHeader( fpOutResFile, ResHeader, &ulResSizePos, &ulResSize))
    {
        ClearResMsg( &pResMsgData);
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_MSGTBLHDR, NULL);
    }

    ulResSize = 0L;             //... Reset to zero (hdr len not to be included)

    ulNumBlocks = pData->NumberOfBlocks;

                                //... Write number of msg blocks

    PutdWord( fpOutResFile, ulNumBlocks, &ulResSize);

                                //... Remember this file position so we can
                                //... come back here and update the
                                //... OffsetToEntries field in each struct.

    ulBlocksStartPos = ftell( fpOutResFile);

                                //... Write the array of message block structs

    for ( ulBlock = 0L; ulBlock < ulNumBlocks; ++ulBlock )
    {
        PutdWord( fpOutResFile, pData->Blocks[ ulBlock].LowId,  &ulResSize);
        PutdWord( fpOutResFile, pData->Blocks[ ulBlock].HighId, &ulResSize);
        PutdWord( fpOutResFile, 0L, &ulResSize);  //... Will get fixed up later
    }
                                // Prep for find token call

    Tok.wType = ResHeader.wTypeID;
    Tok.wName = ResHeader.wNameID;
    Tok.wID   = 0;
    Tok.wFlag = 0;

    if ( ResHeader.bNameFlag == IDFLAG )
    {
        lstrcpy( Tok.szName, ResHeader.pszName);
    }
                                //... Write the MESSAGE_RESOURCE_ENTRY's. First
                                //... note offset from start of this resource's
                                //... data to first msg res entry struct which
                                //... starts right after the array of
                                //... RESOURCE_MESSAGE_BLOCK structs.

    ulCurrOffset = sizeof( ULONG) + ulNumBlocks*sizeof( MESSAGE_RESOURCE_BLOCK);

    for ( ulBlock = 0L; ulBlock < ulNumBlocks; ++ulBlock )
    {
        ULONG   ulCurrID;       //... Current message ID # in this block
        ULONG   ulEndID;        //... Last message ID # in this block + 1
        fpos_t  ulEntryPos;     //... Start of the current msg entry struct
        PBYTE   pMRE;           //... Ptr to a MESSAGE_RESOURCE_ENTRY
        PMESSAGE_RESOURCE_BLOCK pMRB;


                                //... Retrieve ptr to block of messages.  The
                                //... ptr was stored in the pBlockEntries array
                                //... in GetResMessage function above.

        pMRB = (PMESSAGE_RESOURCE_BLOCK)( &pData->Blocks[ ulBlock]);
        pMRE = pBlockEntries[ ulBlock];

                                //... Note offset to start of block's entries

        pData->Blocks[ ulBlock].OffsetToEntries = ulCurrOffset;

        for ( ulCurrID = pMRB->LowId, ulEndID = pMRB->HighId + 1;
              ulCurrID < ulEndID;
              ++ulCurrID )
        {
            static UCHAR szString[ 64] = "";
            static TCHAR szwTmp[ 4096] = TEXT("");
            USHORT usCnt = 0;
            BOOL   fFound = FALSE;
            ULONG  ulEntrySize = 0;


            ulEntryPos  = ftell( fpOutResFile);
            ulEntrySize = 0L;

                                //... Write dummy entry length.
                                //... Value gets corrected later.
                                //... Write the .Flags field's value (USHORT).

            PutWord( fpOutResFile, ((PMRE)pMRE)->Length, &ulEntrySize);
            PutWord( fpOutResFile, ((PMRE)pMRE)->Flags,  &ulEntrySize);

                                //... Get localized token then the length of
                                //... that token's new text.  Add to that length
                                //... the length of the two USHORTs and use this
                                //... combined length as the value to store in
                                //... the msg res entry's .Length field.

                                //... Put low word of ID# in .wID and
                                //... the high word in .szName

            Tok.wID = LOWORD( ulCurrID);
            _itoa( HIWORD( ulCurrID), szString, 10);
            _MBSTOWCS( Tok.szName,
                       szString,
                       TOKENSTRINGBUFFER,
                       lstrlenA( szString) + 1);

                                //... Always reset .wReserved because the code
                                //... in FindTokenText will change its value.

            Tok.wReserved = ST_TRANSLATED;

            Tok.szText = NULL;
            *szwTmp  = TEXT('\0');

            for ( fFound = FALSE, Tok.wFlag = 0;
                  fFound = FindToken( fpInTokFile, &Tok, ST_TRANSLATED);
                  Tok.wFlag++ )
            {
                TextToBin( szwTmp, Tok.szText, lstrlen( Tok.szText) + 1);

                                //... Write out localized message text. It may
                                //... be stored as ASCII or Unicode string.

                if ( ((PMRE)pMRE)->Flags == 0 )  //... ASCII message
                {
                    _WCSTOMBS( szDHW,
                               szwTmp,
                               DHWSIZE,
                               lstrlen( szwTmp) + 1);

                    for ( usCnt = 0; szDHW[ usCnt]; ++usCnt )
                    {
                        PutByte( fpOutResFile, szDHW[ usCnt], &ulEntrySize);
                    }
                }
                else                            //... Unicode message
                {
                    for ( usCnt = 0; szwTmp[ usCnt]; ++usCnt )
                    {
                        PutWord( fpOutResFile, szwTmp[ usCnt], &ulEntrySize);
                    }
                }
                *szwTmp  = TEXT('\0');
                RLFREE( Tok.szText);

                                //... Always reset .wReserved because the code
                                //... in FindTokenText will change its value.

                Tok.wReserved = ST_TRANSLATED;
            }

                                //... Did we find the token?

            if ( Tok.wFlag == 0 && ! fFound )
            {
                static TCHAR szToken[ 4160];


                ParseTokToBuf( szToken, &Tok);

                ClearResMsg( &pResMsgData);
                QuitT( IDS_ENGERR_05, szToken, NULL);
            }
                                //... nul-terminate the text

            if ( ((PMRE)pMRE)->Flags == 0 )  //... ASCII message
            {
                PutByte( fpOutResFile , '\0', (DWORD *)&ulEntrySize);
            }
            else                            //... Unicode message
            {
                PutWord( fpOutResFile , TEXT('\0'), (DWORD *)&ulEntrySize);
            }
            DWordUpFilePointer( fpOutResFile,
                                MYWRITE,
                                ftell( fpOutResFile),
                                &ulEntrySize);

                                //... Also, use this length in later updating
                                //... next msg block's OffsetToEntries value.

            ulResSize    += ulEntrySize;
            ulCurrOffset += ulEntrySize;

                                //... Write Msg Resource entry length
                                //... (Length is in bytes and includes
                                //...  .Length and .Flags fields and any
                                //...  padding needed after the text.)
                                //...
                                //... NOTE: Msg text is currently stored as
                                //... an ASCIIZ string.
            fseek( fpOutResFile, (long)ulEntryPos, SEEK_SET);

            PutWord( fpOutResFile, (WORD)ulEntrySize, NULL);

            fseek( fpOutResFile, 0L, SEEK_END);

                                //... Move pMRE to point to start of next
                                //... Message Resource Entry in memory.

            pMRE += ((PMRE)pMRE)->Length;

        }                       //... END FOR(each message entry in this block)

        ulCurrOffset = DWORDUP( ulCurrOffset);
        DWordUpFilePointer( fpOutResFile,
                            MYWRITE,
                            ftell( fpOutResFile),
                            &ulResSize);

    }                           //... END FOR(each message block)

                                //... Update resource size field in res header

    if ( UpdateResSize( fpOutResFile, &ulResSizePos, ulResSize) == 0L )
    {
        ClearResMsg( &pResMsgData);
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_MSGRESTBL, NULL);
    }
                                //... Now, update the OffsetToEntries fields.

    fseek( fpOutResFile, (long)ulBlocksStartPos, SEEK_SET);

    for ( ulBlock = 0L; ulBlock < ulNumBlocks; ++ulBlock )
    {
        PutdWord( fpOutResFile, pData->Blocks[ulBlock].LowId,           NULL);
        PutdWord( fpOutResFile, pData->Blocks[ulBlock].HighId,          NULL);
        PutdWord( fpOutResFile, pData->Blocks[ulBlock].OffsetToEntries, NULL);
    }
    fseek( fpOutResFile, 0L, SEEK_END);

}       //... END PutResMessage()




//.........................................................................
//...
//... Write Message Table to the token file
//...
//... This function assumes that, in each message block, the message ID's are
//... contiguouse within the range given in the fields LowId and HighId in a
//... MESSAGE_RESOURCE_BLOCK.
//
// 01/93 - Changes for var length token text strings.  Mhotchin
//

void TokResMessage(

FILE      *pfTokFile,       //... Output token file
RESHEADER  ResHeader,       //... Resource header data
VOID      *pMsgResData)     //... Data to tokenize (from GetResMessage call)
{
    static TOKEN Tok;
    ULONG  ulBlock;                 //... Message resource block number
    PMESSAGE_RESOURCE_DATA  pData;  //... Data to tokenize
    PMESSAGE_RESOURCE_BLOCK pMRB;   //... ptr to a message block struct


    pData = (PMESSAGE_RESOURCE_DATA)pMsgResData;
    memset( (void *)&Tok, 0, sizeof( Tok));

    Tok.wType = ResHeader.wTypeID;
    Tok.wName = ResHeader.wNameID;

    Tok.wReserved = (gbMaster ? ST_NEW : ST_NEW | ST_TRANSLATED);

    if ( ResHeader.bNameFlag == IDFLAG )
    {
        lstrcpy( Tok.szName, ResHeader.pszName);
    }

    for ( ulBlock = 0L; ulBlock < pData->NumberOfBlocks; ++ulBlock )
    {
        ULONG  ulCurrID  = 0L;  //... ID # of current msg being processed
        ULONG  ulEndID;         //... Last message ID # in this block + 1
        USHORT usLineNum = 0;   //... Count of lines in a message text
        PCHAR  pMRE;            //... ptr to a message entry struct


                                //... Get ptr to this message block struct

        pMRB = &pData->Blocks[ ulBlock];

                                //... Get ptr to first entry in
                                //... this block of messages

        pMRE = (PCHAR)pBlockEntries[ ulBlock];

                                //... Tokenize entries in this block of messages

        for ( ulCurrID = pMRB->LowId, ulEndID = pMRB->HighId + 1;
              ulCurrID < ulEndID;
              ++ulCurrID )
        {
            usLineNum = 0;

                                //... inclusive of .Length and .Flags fields so
                                //... we need get the real length of the text.

            if ( ((PMRE)pMRE)->Length >= 2 * sizeof( WORD) )
            {
                USHORT usLen        = 0;
                USHORT usTokTextLen = 0;
                PWCHAR pszwStart = NULL;
                                // This is really ugly.  This code was
                                // originally to get around the problem
                                // that tokens could hold only 260 chars.
                                // Now, it's whatever you want.
                                // Temp hack - assume each line will be
                                // less than 4k in size. (mhotchin)
                static TCHAR szwString[ 32768 ];

                                //... Put low word of ID# in .wID and
                                //... the high word in .szName

                Tok.wID = LOWORD( ulCurrID);
                _itoa( HIWORD( ulCurrID), szDHW, 10);
                _MBSTOWCS( Tok.szName,
                           szDHW,
                           TOKENSTRINGBUFFER,
                           lstrlenA( szDHW) +1);

                                //... The err msg table strings may be stored
                                //... in the resources as ANSI or Unicode.
                                //... If the pMRE->Flags field in the
                                //... table entry struct is 0, the text is a
                                //... ANSI striing so we need to convert it to
                                //... UNICODE (WCHAR).

                if ( ((PMRE)pMRE)->Flags == 0 ) //... ASCII message
                {
                    PUCHAR puchStart = (PUCHAR)((PMRE)pMRE)->Text;

                    usLen = (USHORT)_MBSTOWCS( szwString,
                                       puchStart,
                                       WCHARSIN( sizeof( szwString)),
                                       ACHARSIN( lstrlenA( puchStart) + 1));

                    if (usLen == 0)
                        QuitT( IDS_ENGERR_10, szwString, NULL);

                    pszwStart = szwString;
                }
                else                            //... Unicode message
                {
                    pszwStart = (WCHAR *)(((PMRE)pMRE)->Text);
                    usLen = (USHORT)lstrlen( pszwStart) /*+ 1*/;
                }
                                //... We need to split the token text at \r\n

                for ( Tok.wFlag = 0;
                      usLen > 0;
                      usLen -= usTokTextLen, Tok.wFlag++ )
                {
                    WCHAR wcTmp;


                    for ( usTokTextLen = 0, wcTmp = TEXT('\0');
                          usTokTextLen < usLen;
                        ++usTokTextLen )
                    {
                        if ( pszwStart[ usTokTextLen]   == TEXT('\r')
                          && pszwStart[ usTokTextLen+1] == TEXT('\n') )
                        {
                            usTokTextLen += 2;
                            wcTmp = pszwStart[ usTokTextLen];
                            pszwStart[ usTokTextLen] = TEXT('\0');

                            break;
                        }
                    }

                    Tok.szText = BinToTextW( pszwStart, usTokTextLen);

                    PutToken( pfTokFile, &Tok);

                    RLFREE( Tok.szText);

                    pszwStart += usTokTextLen;
                    *pszwStart = wcTmp;
                }
                //... Set up to move to start of next msg entry

                pMRE += ((PMRE)pMRE)->Length;
            }
            else
            {
                ClearResMsg( &pResMsgData);
                QuitT( IDS_ENGERR_05, (LPTSTR)IDS_MSGTOOSHORT, NULL);
            }
        }                       //... END FOR processing a msg block
    }                           //... END FOR processing all msg blocks
}





//.........................................................................
//...
//... Clear memory created in GetResMessage()

void ClearResMsg(

VOID **pData)      //... ptr to ptr to start of memory to free
{
    if ( pData != NULL && *pData != NULL )
    {
        ULONG                   ulBlock;
        PMESSAGE_RESOURCE_DATA  pMRD;   //... ptr to a message data struct
        PMESSAGE_RESOURCE_BLOCK pMRB;   //... ptr to a message block struct


        pMRD = (PMESSAGE_RESOURCE_DATA)*pData;
        pMRB = pMRD->Blocks;

        if ( pBlockEntries != NULL )
        {
            for ( ulBlock = 0L; ulBlock < pMRD->NumberOfBlocks; ++ulBlock )
            {
                if ( pBlockEntries[ ulBlock] )
                {
                    RLFREE( pBlockEntries[ ulBlock]);
                }
            }
            RLFREE( (PBYTE)pBlockEntries);
        }
        RLFREE( *pData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\projdata.h ===
#ifndef _PROJDATA_H_
#define _PROJDATA_H_

#define NAMELENBUFSIZE 32

typedef struct _tagLangData
{
    struct _tagLangData * pNext;
    WORD   wPriLang;
    WORD   wSubLang;
    TCHAR  szLangName[ NAMELENBUFSIZE];
} LANGDATA, * PLANGDATA;        

int MyAtoi( CHAR *pStr);

int GetMasterProjectData(
        CHAR * pszMasterFile,   //... Master Project file name
        CHAR * pszSrc,          //... Resource source file name or NULL
        CHAR * pszMtk,          //... Master token file name or NULL
        BOOL   fLanguageGiven);

int PutMasterProjectData(
        CHAR *pszMasterFile);   //... Master Project File name

int GetProjectData(
        CHAR *pszPrj,           //... Project file name
        CHAR *pszMpj,           //... Master Project file name or NULL
        CHAR *pszTok,           //... Project token file name or NULL
        BOOL  fCodePageGiven,
        BOOL  fLanguageGiven);

int PutProjectData(
        CHAR *pszPrj);          //... Project file name

WORD GetCopyright(
        CHAR *pszProg,          //... Program name
        CHAR *pszOutBuf,        //... Buffer for results
        WORD  wBufLen);         //... Length of pszOutBuf

WORD GetInternalName(
        CHAR *pszProg,          //... Program name
        CHAR *pszOutBuf,        //... Buffer for results
        WORD  wBufLen);         //... Length of pszOutBuf

//DWORD GetLanguageID( HWND hDlg, PMSTRDATA pMaster, PPROJDATA pProject);
//DWORD SetLanguageID( HWND hDlg, PMSTRDATA pMaster, PPROJDATA pProject);

LPTSTR    GetLangName( WORD wPriLangID, WORD wSubLangID);
PLANGDATA GetLangList( void);    
BOOL      GetLangIDs( LPTSTR pszName, PWORD pwPri, PWORD pwSub);
LONG      FillLangNameBox( HWND hDlg, int nControl);
void      FreeLangList( void);

void FillListAndSetLang( 
    HWND  hDlg,
    WORD  wLangNameList,    //... IDD_MSTR_LANG_NAME or IDD_PROJ_LANG_NAME
    WORD *pLangID,          //... Ptr to gMstr.wLanguageID or gProj.wLanguageID
    BOOL *pfSelected);      //... Did we select a language here? (Can be NULL)

#endif // _PROJDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\projdata.c ===
#include <windows.h>

#include <stdio.h>
#include <io.h>
#include <errno.h>
#include <stdlib.h>

#include "windefs.h"
#include "restok.h"
#include "projdata.h"
#include "showerrs.h"
#include "rlmsgtbl.h"
#include "commbase.h"
#include "custres.h"
#include "rlstrngs.h"
#include "resource.h"
#include "resourc2.h"
#include "resread.h"
#include "langlist.h"
#include "exentres.h"

extern MSTRDATA  gMstr;
extern PROJDATA  gProj;
extern UCHAR     szDHW[];
extern BOOL      fCodePageGiven;
extern BOOL      gfReplace;
extern HWND      hMainWnd;

BOOL   bRLGui;			//FALSE=RLMan TRUE=RLAdmin RLEdit RLquiked

#ifdef RLRES32
extern PLANGLIST pLangIDList;
#endif

static PLANGDATA pLangList = NULL;



//............................................................

                                //...RLtools are localized so we would like
                                //...to get correct locale's Version stamp
BOOL MyVerQueryValue(
LPVOID pBlock,
LPTSTR lpSubBlock,
LPVOID *lplpBuffer,
PUINT  puLen)
{

    LPWORD lpXlate;         // ptr to translations data

    DWORD cbValueTranslation=0;
    TCHAR szVersionKey[60]; // big enough for anything we need

    if( VerQueryValue( pBlock, TEXT("\\VarFileInfo\\Translation"),
       (LPVOID*)&lpXlate, &cbValueTranslation) )
    {

        wsprintf( szVersionKey, TEXT("\\StringFileInfo\\%04X04B0\\%s"),
            *lpXlate, lpSubBlock );

        if( VerQueryValue ( pBlock, szVersionKey, lplpBuffer, puLen) )
            return TRUE;

    }

    wsprintf( szVersionKey, TEXT("\\StringFileInfo\\%04X04B0\\%s"),
        LANGIDFROMLCID(GetThreadLocale()), lpSubBlock );

    if( !VerQueryValue (pBlock, szVersionKey, lplpBuffer, puLen) )
    {

        wsprintf( szVersionKey, TEXT("\\StringFileInfo\\040904B0\\%s"),
            lpSubBlock );

        if( !VerQueryValue (pBlock, szVersionKey, lplpBuffer, puLen) )
            return FALSE;
    }

    return TRUE;

}


int GetMasterProjectData(

CHAR * pszMasterFile,   //... Master Project file name
CHAR * pszSrc,          //... Resource source file name or NULL
CHAR * pszMtk,          //... Master token file name or NULL
BOOL   fLanguageGiven)
{
    int nRC = SUCCESS;  //... Return code

                                //... check for the special case where Master
                                //... Project File does not exist. If it doesn't
                                //... go ahead and create it.

    memset(&gMstr, '\0', sizeof(gMstr));

    if ( _access( pszMasterFile, 0) != 0 )
    {
        if ( ! (pszSrc && pszMtk) )
        {
            ShowErr( IDS_ERR_03, pszMasterFile, NULL);
            nRC = IDS_ERR_03;
        }
        else
        {
                                //... Get source resource file name

            if ( _fullpath( gMstr.szSrc, pszSrc, sizeof( gMstr.szSrc)-1) )
            {
                                //... Get Master token file name and its
                                //... modification date. Use that same date as
                                //... the initial date the master project was
                                //... last updated.

                if ( _fullpath( gMstr.szMtk, pszMtk, sizeof( gMstr.szMtk)-1) )
                {
                    SzDateFromFileName( gMstr.szSrcDate, gMstr.szSrc);
                    lstrcpyA( gMstr.szMpjLastRealUpdate, gMstr.szSrcDate);

                                //... Create the new Master Project file.

                    nRC = PutMasterProjectData( pszMasterFile);
                }
                else
                {
                    ShowErr( IDS_ERR_13, pszMtk, NULL);
                    nRC = IDS_ERR_13;
                }
            }
            else
            {
                ShowErr( IDS_ERR_13, pszSrc, NULL);
                nRC = IDS_ERR_13;
            }
        }
    }
    else
    {
        FILE *pfMpj = NULL;


        if ( (pfMpj = fopen( pszMasterFile, "rt")) == NULL )
        {
            ShowErr( IDS_ERR_07, pszMasterFile, NULL);
            nRC = IDS_ERR_07;
        }
        else
        {
                                //... Get resource source file name
                                //... and master token file name

            if ( fgets( gMstr.szSrc, sizeof( gMstr.szSrc), pfMpj)
              && fgets( gMstr.szMtk, sizeof( gMstr.szMtk), pfMpj) )
            {
								//... Make sure these two files exist
                if ( pszSrc )
                {
				    if ( !_fullpath(gMstr.szSrc,pszSrc,sizeof( gMstr.szSrc)-1) )
					{
                        ShowErr( IDS_ERR_07, pszSrc, NULL);
                        fclose( pfMpj );
						return( IDS_ERR_07 );
					}
                }

                if ( pszMtk )
				{
				    if ( !_fullpath(gMstr.szMtk,pszMtk,sizeof( gMstr.szMtk)-1) )
					{
                        ShowErr( IDS_ERR_07, pszMtk, NULL);
                        fclose( pfMpj );
						return( IDS_ERR_07 );
                    }
                }
                                //... If -c flag not given, get RDF file name
                                //... from master project file, else use name
                                //... from the -c cmd line arg.

                if ( gMstr.szRdfs[0] == '\0' )
                {
                    if ( ! fgets( gMstr.szRdfs, sizeof( gMstr.szRdfs), pfMpj) )
                    {
                        ShowErr( IDS_ERR_21,
                                 "Master Project",
                                 pszMasterFile);
                        nRC = IDS_ERR_21;
                    }
                }
                else
                {
                    if ( ! fgets( szDHW, DHWSIZE, pfMpj) )
                    {
                        ShowErr( IDS_ERR_21,
                                 "Master Project",
                                 pszMasterFile);
                        nRC = IDS_ERR_21;
                    }
                }
                                //... Get stored date of source file and
                                //... date of last master token file update

                if ( nRC == 0
                  && fgets( gMstr.szSrcDate, sizeof( gMstr.szSrcDate), pfMpj)
                  && fgets( gMstr.szMpjLastRealUpdate,
                            sizeof( gMstr.szMpjLastRealUpdate),
                            pfMpj) )
                {
                    WORD  wPriID = 0;
                    WORD  wSubID = 0;
                    UINT  uTmpCP = 0;

                                //... Strip any trailing new-lines from data

                    StripNewLineA( gMstr.szSrc);
                    StripNewLineA( gMstr.szMpjLastRealUpdate);
                    StripNewLineA( gMstr.szMtk);
                    StripNewLineA( gMstr.szRdfs);
                    StripNewLineA( gMstr.szSrcDate);

                                //... Try to get the.MPJ file's Language line.
                                //... If we find it and the -i arg was not
                                //... given, use the one found in the file.

                    if ( fgets( szDHW, DHWSIZE, pfMpj) != NULL //... CP line
                      && sscanf( szDHW, "Language %hx %hx", &wPriID, &wSubID) == 2 )
                    {
                        WORD  wTmpID = 0;

                        wTmpID = MAKELANGID( wPriID, wSubID);

                        if ( ! fLanguageGiven )
                        {
                            gMstr.wLanguageID = wTmpID;
                        }
                    }
                                //... Try to get the.MPJ file's Code Page line.
                                //... If we find it and the -p arg was not
                                //... given, use the one found in the file.

                    if ( fgets( szDHW, DHWSIZE, pfMpj) != NULL //... CP line
                      && sscanf( szDHW, "CodePage %u", &uTmpCP) == 1 )
                    {
                        if ( uTmpCP != gProj.uCodePage && ! fCodePageGiven )
                        {
                            gMstr.uCodePage = uTmpCP;
                        }
                    }
                    nRC = SUCCESS;
                }
                else
                {
                    ShowErr( IDS_ERR_21,
                             "Master Project",
                             pszMasterFile);
                    nRC = IDS_ERR_21;
                }
            }
            else
            {
                ShowErr( IDS_ERR_22, pszMasterFile, NULL);
                nRC = IDS_ERR_22;
            }
            fclose( pfMpj);
        }
    }
    return( nRC);
}

//............................................................

int PutMasterProjectData(

CHAR *pszMasterFile)    //... Master Project File name
{
    int   nRC   = SUCCESS;
    FILE *pfMpj = NULL;


    if ( (pfMpj = fopen( pszMasterFile, "wt")) == NULL )
    {
        ShowErr( IDS_ERR_06, pszMasterFile, NULL);
        nRC = -1;
    }
    else
    {
        fprintf( pfMpj, "%s\n%s\n%s\n%s\n%s\nLanguage %#04hx %#04hx\nCodePage %u",
                        gMstr.szSrc,
                        gMstr.szMtk,
                        gMstr.szRdfs,
                        gMstr.szSrcDate,
                        gMstr.szMpjLastRealUpdate,
                        PRIMARYLANGID( gMstr.wLanguageID),
                        SUBLANGID( gMstr.wLanguageID),
                        gMstr.uCodePage);

        fclose( pfMpj);
    }
    return( nRC);
}


//............................................................

int GetProjectData(

CHAR *pszPrj,       //... Project file name
CHAR *pszMpj,       //... Master Project file name or NULL
CHAR *pszTok,       //... Project token file name or NULL
BOOL  fCodePageGiven,
BOOL  fLanguageGiven)
{
    int nRC     = SUCCESS;
	int	iUpdate = 0;


    if ( _access( pszPrj, 0) != 0 )
    {
        if ( ! (pszMpj && pszTok) )
        {
            ShowErr( IDS_ERR_19, pszPrj, NULL);
            Usage();
            nRC = IDS_ERR_19;
        }
        else if ( ! fLanguageGiven )
        {
            ShowErr( IDS_ERR_24, pszPrj, NULL);
            Usage();
            nRC = IDS_ERR_24;
        }
        else
        {
            if ( _fullpath( gProj.szMpj,
                            pszMpj,
                            sizeof( gProj.szMpj)-1) )
            {
                if ( _fullpath( gProj.szTok,
                                pszTok,
                                sizeof( gProj.szTok)-1) )
                {
                    nRC = SUCCESS;
                }
                else
                {
                    ShowErr( IDS_ERR_13, pszTok, NULL);
                    nRC = IDS_ERR_13;
                }
            }
            else
            {
                ShowErr( IDS_ERR_13, pszMpj, NULL);
                nRC = IDS_ERR_13;
            }
        }
    }
    else
    {
        FILE *fpPrj = fopen( pszPrj, "rt");

        if ( fpPrj != NULL )
        {
            if ( fgets( gProj.szMpj,     sizeof( gProj.szMpj),     fpPrj)
              && fgets( gProj.szTok,     sizeof( gProj.szTok),     fpPrj)
              && fgets( gProj.szGlo,     sizeof( gProj.szGlo),     fpPrj)
              && fgets( gProj.szTokDate, sizeof( gProj.szTokDate), fpPrj) )
            {
                UINT  uTmpCP = 0;
                WORD  wPriID = 0;
                WORD  wSubID = 0;
								//... If named, make sure MPJ and TOK files exist
                if ( pszMpj )
                {
				    if ( !_fullpath( gProj.szMpj, pszMpj, sizeof( gProj.szMpj)-1) )
					{
                        ShowErr( IDS_ERR_21, pszMpj, NULL);
                        fclose( fpPrj );
						return( IDS_ERR_21);
                     }
				}

                if ( pszTok )
                {
                    if ( !_fullpath( gProj.szTok, pszTok, sizeof( gProj.szTok)-1) )
					{
                        ShowErr( IDS_ERR_21, pszTok, NULL);
                        fclose( fpPrj );
						return( IDS_ERR_21);
                    }
				}

                StripNewLineA( gProj.szMpj);
                StripNewLineA( gProj.szTok);
                StripNewLineA( gProj.szGlo);
                StripNewLineA( gProj.szTokDate);

                                //... Try to get the.PRJ file's Code Page line.
                                //... If we find it and the -p arg was not
                                //... given, use the one found in the file.

                if ( ! fgets( szDHW, DHWSIZE, fpPrj) )	//... CP line
				{
					iUpdate++;
				}
				else if ( sscanf( szDHW, "CodePage %u", &uTmpCP) == 1 )
                {
                    if ( uTmpCP != gProj.uCodePage && ! fCodePageGiven )
                    {
                        gProj.uCodePage = uTmpCP;
                    }
                }
                                //... Try to get the.PRJ file's Language line.
                                //... If we find it and the -i arg was not
                                //... given, use the one found in the file.

                if ( ! fgets( szDHW, DHWSIZE, fpPrj) ) //... LANGID line
				{
					iUpdate++;
				}
				else if ( sscanf( szDHW, "Language %hx %hx", &wPriID, &wSubID) == 2 )
                {
                    WORD  wTmpID = 0;

                    wTmpID = MAKELANGID( wPriID, wSubID);

                    if ( ! fLanguageGiven )
                    {
                        gProj.wLanguageID = wTmpID;
                    }
                }
                                //... Try to get the.PRJ file's Target File line

                if ( fgets( szDHW, DHWSIZE, fpPrj) != NULL )
                {
                    lstrcpyA( gProj.szBld, szDHW);
                    StripNewLineA( gProj.szBld);
                }
                                //... Try to get the.PRJ file's append/replace line

                if ( fgets( szDHW, DHWSIZE, fpPrj) != NULL )
                {
                    gfReplace = (*szDHW == 'R') ? TRUE : FALSE;
                }
                else
                {
                    gfReplace = TRUE;
                }
                nRC = SUCCESS;

				if ( iUpdate )
				{
					static TCHAR title[50];
					static TCHAR szMes[100];

					if ( bRLGui )
					{
								//Ask Update prj for 1.7? //RLadmin RLedit RLquiked

						LoadString( NULL,
									IDS_UPDATE_YESNO,
									szMes,
									TCHARSIN( sizeof( szMes)) );
						LoadString( NULL,
									IDS_UPDATE_TITLE,
									title,
									TCHARSIN( sizeof( title)) );
						
						if ( MessageBox( hMainWnd,
										 szMes,title,
										 MB_ICONQUESTION|MB_YESNO) == IDNO )
						{
								//User says no, then finish the job.
							LoadString( NULL,
										IDS_UPDATE_CANCEL,
										szMes,
										TCHARSIN( sizeof( szMes)) );
											
							MessageBox( hMainWnd,
										szMes,
										title,
										MB_ICONSTOP|MB_OK);
								//bye!
							nRC = IDS_UPDATE_CANCEL;
						}
						else
						{
								//replace Glossary <=> Bins
  	    	          		lstrcpyA( szDHW, gProj.szGlo );
							lstrcpyA( gProj.szGlo, gProj.szBld );
							lstrcpyA( gProj.szBld, szDHW );
						}
					}
					else		//For RLMan
					{
								//Update Message
						RLMessageBoxA( "Updating 1.0 files..." );
								//replace Glossary <=> Bins
              			lstrcpyA( szDHW, gProj.szGlo );
						lstrcpyA( gProj.szGlo, gProj.szBld );
						lstrcpyA( gProj.szBld, szDHW );
					}
				}
            }
            else
            {
                ShowErr( IDS_ERR_21, pszPrj, NULL);
                nRC = IDS_ERR_21;
            }
            fclose( fpPrj);
        }
        else
        {
            ShowErr( IDS_ERR_19, pszPrj, NULL);
            nRC = IDS_ERR_19;
        }
    }
    return( nRC);
}

//............................................................

int PutProjectData(

CHAR *pszPrj)       //... Project file name
{
    int   nRC   = 0;
    FILE *fpPrj = NULL;


    fpPrj = fopen( pszPrj, "wt");

    if ( fpPrj != NULL )
    {
        fprintf( fpPrj,
                 "%s\n%s\n%s\n%s\nCodePage %u\nLanguage %#04x %#04x\n%s\n%s",
                 gProj.szMpj,                       // Master Project file
                 gProj.szTok,                       // Project Token file
                 gProj.szGlo,                       // Project Glossary file
                 gProj.szTokDate,                   // Date token file changed
                 gProj.uCodePage,                   // Code Page of token file
                 PRIMARYLANGID( gProj.wLanguageID), // Project resource language
                 SUBLANGID( gProj.wLanguageID),
                 gProj.szBld,                       // Project target file
                 gfReplace ? "Replace" : "Append"); // Replace master lang?

        fclose( fpPrj);

        _fullpath( gProj.szPRJ, pszPrj, sizeof( gProj.szPRJ)-1);
    }
    else
    {
        ShowErr( IDS_ERR_21, pszPrj, NULL);
        nRC = IDS_ERR_21;
    }
    return( nRC);
}

//............................................................

WORD GetCopyright(

CHAR *pszProg,      //... Program name (argv[0])
CHAR *pszOutBuf,    //... Buffer for results
WORD  wBufLen)      //... Length of pszOutBuf
{
    BOOL    fRC       = FALSE;
    DWORD   dwRC      = 0L;
    DWORD   dwVerSize = 0L;         //... Size of file version info buffer
    LPSTR  *plpszFile = NULL;
    LPSTR   pszExt    = NULL;
    WCHAR  *pszVer    = NULL;
    PVOID   lpVerBuf  = NULL;       //... Version info buffer
    static CHAR  szFile[  MAXFILENAME+3] = "";

                                //... Figure out the full-path name of prog
                                //... so GetFileVersionInfoSize() will work.

    dwRC = lstrlenA( pszProg);

    if ( dwRC < 4 || lstrcmpiA( &pszProg[ dwRC - 4], ".exe") != 0 )
    {
        pszExt = ".exe";
    }

    dwRC = SearchPathA( NULL, pszProg, pszExt, sizeof( szFile), szFile, plpszFile);

    if ( dwRC == 0 )
    {
        return( IDS_ERR_25);
    }
    else if ( dwRC > sizeof( szFile) )
    {
        return( IDS_ERR_27);
    }

    // append the extension since SearchPath will not return it
    // if we have no extensio then a directory with the same name was returned
    // try to append the ext and hope that file will be there
    if ( lstrcmpiA( &szFile[dwRC - 4], ".exe") != 0 )
    {
        lstrcatA( szFile, pszExt );
    }


    //... Get # bytes in file version info

    if ( (dwVerSize = GetFileVersionInfoSizeA( szFile, &dwRC)) == 0L )
    {
        return( IDS_ERR_26);
    }
    lpVerBuf = (LPVOID)FALLOC( dwVerSize);

                                //... Retrieve version info
                                //... and get the file description

    if ( (dwRC = GetFileVersionInfoA( szFile, 0L, dwVerSize, lpVerBuf)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }

    if ( (fRC = MyVerQueryValue( lpVerBuf,
                               TEXT("FileDescription"),
                               &pszVer,
                               &dwVerSize)) == FALSE
      || (dwRC = WideCharToMultiByte( CP_ACP,
                                      0,
                                      pszVer,
                                      dwVerSize,
                                      pszOutBuf,
                                      dwVerSize,
                                      NULL,
                                      NULL)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }

    strcat( pszOutBuf, " ");

                                //... Get the file version

    if ( (fRC = MyVerQueryValue( lpVerBuf,
                                 TEXT("ProductVersion"),
                                 &pszVer,
                                 &dwVerSize)) == FALSE
    || (dwRC = WideCharToMultiByte( CP_ACP,
                                      0,
                                      pszVer,
                                      dwVerSize,
                                      &pszOutBuf[ lstrlenA( pszOutBuf)],
                                      dwVerSize,
                                      NULL,
                                      NULL)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }

    strcat( pszOutBuf, "\n");

                                //... Get the copyright statement

    if ( (fRC = MyVerQueryValue( lpVerBuf,
                                 TEXT("LegalCopyright"),
                                 &pszVer,
                                 &dwVerSize)) == FALSE
      || (dwRC = WideCharToMultiByte( CP_ACP,
                                      0,
                                      pszVer,
                                      dwVerSize,
                                      &pszOutBuf[ lstrlenA( pszOutBuf)],
                                      dwVerSize,
                                      NULL,
                                      NULL)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }
    RLFREE( lpVerBuf);
    return( SUCCESS);
}

//............................................................

WORD GetInternalName(

CHAR *pszProg,      //... Program name (argv[0])
CHAR *pszOutBuf,    //... Buffer for results
WORD  wBufLen)      //... Length of pszOutBuf
{
    BOOL    fRC       = FALSE;
    DWORD   dwRC      = 0L;
    DWORD   dwVerSize = 0L;         //... Size of file version info buffer
    LPSTR  *plpszFile = NULL;
    LPSTR   pszExt    = NULL;
    WCHAR  *pszVer    = NULL;
    PVOID   lpVerBuf  = NULL;       //... Version info buffer
    static CHAR  szFile[  MAXFILENAME+3] = "";

                                //... Figure out the full-path name of prog
                                //... so GetFileVersionInfoSize() will work.

    dwRC = lstrlenA( pszProg);

    if ( dwRC < 4 || lstrcmpiA( &pszProg[ dwRC - 4], ".exe") != 0 )
    {
        pszExt = ".exe";
    }

    dwRC = SearchPathA( NULL, pszProg, pszExt, sizeof( szFile), szFile, plpszFile);

    if ( dwRC == 0 )
    {
        return( IDS_ERR_25);
    }
    else if ( dwRC > sizeof( szFile) )
    {
        return( IDS_ERR_27);
    }

                                //... Get # bytes in file version info

    if ( (dwVerSize = GetFileVersionInfoSizeA( szFile, &dwVerSize)) == 0L )
    {
        return( IDS_ERR_26);
    }
    lpVerBuf = (LPVOID)FALLOC( dwVerSize);

                               //... Retrieve version info
                                //... and get the file description

    if ( (dwRC = GetFileVersionInfoA( szFile, 0L, dwVerSize, lpVerBuf)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }

    if ( (fRC = MyVerQueryValue( lpVerBuf,
                                 TEXT("InternalName"),
                                 &pszVer,
                                 &dwVerSize)) == FALSE
      || (dwRC = WideCharToMultiByte( CP_ACP,
                                      0,
                                      pszVer,
                                      dwVerSize,
                                      pszOutBuf,
                                      dwVerSize,
                                      NULL,
                                      NULL)) == 0L )
    {
        RLFREE( lpVerBuf);
        return( IDS_ERR_26);
    }
    RLFREE( lpVerBuf);
    return( SUCCESS);
}


//............................................................

int MyAtoi( CHAR *pStr)
{
    if ( lstrlenA( pStr) > 2
      && pStr[0] == '0'
      && tolower( pStr[1]) == 'x' )
    {
        return( atoihex( &pStr[2]));    //... in custres.c
    }
    else
    {
        return( atoi( pStr));
    }
}



//DWORD GetLanguageID( HWND hDlg, PMSTRDATA pMaster, PPROJDATA pProject)
//{
//    DWORD dwRC = SUCCESS;       //... Assume success
//    WORD wPriLangID = 0;
//    WORD wSubLangID = 0;
//
//
//    if ( pMaster )
//    {
//        GetDlgItemTextA( hDlg, IDD_PRI_LANG_ID, szDHW, DHWSIZE);
//        wPriLangID = MyAtoi( szDHW);
//
//        GetDlgItemTextA( hDlg, IDD_SUB_LANG_ID, szDHW, DHWSIZE);
//        wSubLangID = MyAtoi( szDHW);
//
//        pMaster->wLanguageID = MAKELANGID( wPriLangID, wSubLangID);
//    }
//
//    if ( pProject )
//    {
//        GetDlgItemTextA( hDlg, IDD_PROJ_PRI_LANG_ID, szDHW, DHWSIZE);
//        wPriLangID = MyAtoi( szDHW);
//
//        GetDlgItemTextA( hDlg, IDD_PROJ_SUB_LANG_ID, szDHW, DHWSIZE);
//        wSubLangID = MyAtoi( szDHW);
//
//        pProject->wLanguageID = MAKELANGID( wPriLangID, wSubLangID);
//    }
//    return( dwRC);
//}

//.................................................................
//... Set the language component names into the dlg box fields
//
//DWORD SetLanguageID( HWND hDlg, PMSTRDATA pMaster, PPROJDATA pProject)
//{
//    DWORD  dwRC = SUCCESS;      //... Assume success
//    WORD   wPriLangID  = 0;
//    WORD   wSubLangID  = 0;
//    LPTSTR pszLangName = NULL;
//
//                                //... Did we already load the data from
//                                //... the resources? If not, do so now.
//    if ( ! pLangList )
//    {
//        pLangList = GetLangList();
//    }
//
//    if ( pMaster )
//    {
//        wPriLangID = PRIMARYLANGID( pMaster->wLanguageID);
//        wSubLangID = SUBLANGID(     pMaster->wLanguageID);
//
//        if ( (pszLangName = GetLangName( wPriLangID, wSubLangID)) )
//        {
//            SetDlgItemText( hDlg, IDD_MSTR_LANG_NAME, pszLangName);
//        }
//        sprintf( szDHW, "%#04x", wPriLangID);
//        SetDlgItemTextA( hDlg, IDD_PRI_LANG_ID, szDHW);
//
//        sprintf( szDHW, "%#04x", wSubLangID);
//        SetDlgItemTextA( hDlg, IDD_SUB_LANG_ID, szDHW);
//    }
//
//    if ( pProject )
//    {
//        wPriLangID = PRIMARYLANGID( pProject->wLanguageID);
//        wSubLangID = SUBLANGID(     pProject->wLanguageID);
//
//        if ( (pszLangName = GetLangName( wPriLangID, wSubLangID)) )
//        {
//            SetDlgItemText( hDlg, IDD_PROJ_LANG_NAME, pszLangName);
//        }
//        sprintf( szDHW, "%#04x", wPriLangID);
//        SetDlgItemTextA( hDlg, IDD_PROJ_PRI_LANG_ID, szDHW);
//
//        sprintf( szDHW, "%#04x", wSubLangID);
//        SetDlgItemTextA( hDlg, IDD_PROJ_SUB_LANG_ID, szDHW);
//    }
//    return( dwRC);
//}

//...............................................................
//...
//... Build the list of Language names and component ID values

PLANGDATA GetLangList( void)
{
    PLANGDATA pRC = NULL;
    HRSRC hResource = FindResourceEx( NULL,
                                      (LPCTSTR)RT_RCDATA,
                                      (LPCTSTR)ID_LANGID_LIST,
                                      MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL));

    if ( hResource )
    {
        HGLOBAL hRes = LoadResource( NULL, hResource);

        if ( hRes )
        {
            PBYTE pRes = (PBYTE)LockResource( hRes);

            if ( pRes )
            {
                int nNameLen   = 0;
                PLANGDATA pTmp = NULL;

                nNameLen = lstrlenA( (LPSTR)pRes);
                pRC  = (PLANGDATA)FALLOC( sizeof( LANGDATA));
                pTmp = pRC;

                while ( nNameLen )
                {
                    MultiByteToWideChar( CP_ACP,
                                         MB_PRECOMPOSED,
                                         (LPSTR)pRes,
                                         -1,
                                         pTmp->szLangName,
                                         NAMELENBUFSIZE - 1);
                    pRes += ++nNameLen;

                    pTmp->wPriLang = MAKEWORD( *pRes, *(pRes+1) );
                    pRes += sizeof(WORD);
                    pTmp->wSubLang = MAKEWORD( *pRes, *(pRes+1) );
                    pRes += sizeof(WORD);

                    if ( (nNameLen = lstrlenA( (LPSTR)pRes)) )
                    {
                        PLANGDATA pNew = (PLANGDATA)FALLOC( sizeof( LANGDATA));
                        pTmp->pNext = pNew;
                        pTmp = pNew;
                    }
                }       //... END while( nNameLen )
            }           //... END if ( pRes )
            else
            {
                DWORD dwErr = GetLastError();
            }
        }               //... END if ( hRes )
        else
        {
            DWORD dwErr = GetLastError();
        }
    }                   //... END if ( hSrc )
    else
    {
        DWORD dwErr = GetLastError();
    }
    return( pRC);
}


//...............................................................
//...
//... Return the name of a language based on the given components

LPTSTR GetLangName( WORD wPriLangID, WORD wSubLangID)
{
    LPTSTR    pszRC = NULL;
    PLANGDATA pLang = NULL;

    if ( ! pLangList )
    {
        pLangList = GetLangList();
    }

    for ( pLang = pLangList; pLang && ! pszRC; pLang = pLang->pNext )
    {
        if ( pLang->wPriLang == wPriLangID && pLang->wSubLang == wSubLangID )
        {
            pszRC = pLang->szLangName;
        }
    }
    return( pszRC);
}

//...............................................................
//...
//... Return the language ID components based on the given name

BOOL GetLangIDs( LPTSTR pszName, PWORD pwPri, PWORD pwSub )
{
    BOOL fRC = FALSE;
    PLANGDATA pLang = NULL;

    if ( ! pLangList )
    {
        pLangList = GetLangList();
    }

    for ( pLang = pLangList; pLang && ! fRC; pLang = pLang->pNext )
    {
        if ( lstrcmp( pLang->szLangName, pszName) == 0 )
        {
            *pwPri = pLang->wPriLang;
            *pwSub = pLang->wSubLang;

            fRC = TRUE;
        }
    }
    return( fRC);
}


//...............................................................
//...
//... Fill the given combobox with the names of supported the languages.

LONG FillLangNameBox( HWND hDlg, int nControl)
{
    PLANGDATA pLang = NULL;
    PLANGLIST pID   = NULL;
    LONG lRC = -1;
    BOOL fListIt = TRUE;
    WORD wAddLang = 0;


    if ( nControl == IDD_MSTR_LANG_NAME )
    {
        if ( GetListOfResLangIDs( gMstr.szSrc) != SUCCESS )
        {
            return( lRC);
        }
    }

    if ( ! pLangList )
    {
        pLangList = GetLangList();
    }

    for ( pLang = pLangList; pLang; pLang = pLang->pNext )
    {
        fListIt = TRUE;

        if ( nControl == IDD_MSTR_LANG_NAME )
        {
            wAddLang = MAKELANGID( pLang->wPriLang, pLang->wSubLang);

            fListIt = FALSE;

            for ( pID = pLangIDList; pID; pID = pID->pNext )
            {
                if ( pID->wLang == wAddLang )
                {
                    fListIt = TRUE;
                    break;
                }
            }
        }

        if ( fListIt )
        {
            lRC = (LONG)SendDlgItemMessage( hDlg,
                                      nControl,
                                      CB_ADDSTRING,
                                      0,
                                      (LPARAM)pLang->szLangName);

            if ( lRC == CB_ERR || lRC == CB_ERRSPACE )
            {
                QuitT( IDS_ERR_16, NULL, NULL);
            }
        }
    }

    if ( nControl == IDD_MSTR_LANG_NAME )
    {
        FreeLangIDList();
    }
    return( lRC);
}


void FreeLangList( void)
{
    PLANGDATA pTmp = NULL;

    while ( pLangList )
    {
        pTmp = pLangList->pNext;
        RLFREE( pLangList);
        pLangList = pTmp;
    }

#ifdef RLRES32

    FreeLangIDList();

#endif

}


//...................................................................

void FillListAndSetLang(

HWND  hDlg,
WORD  wLangNameList,    //... IDD_MSTR_LANG_NAME or IDD_PROJ_LANG_NAME
WORD *pLangID,          //... Ptr to gMstr.wLanguageID or gProj.wLanguageID
BOOL *pfSelected)       //... Did we select a language here? (Can be NULL)
{
    int nSel =  FillLangNameBox( hDlg, wLangNameList);

    if ( nSel > 0L )
    {
        LPTSTR pszLangName = NULL;
                                //... See if the default master language is in the list

        if ( (pszLangName = GetLangName( (WORD)(PRIMARYLANGID( *pLangID)),
                                         (WORD)(SUBLANGID( *pLangID)))) != NULL )
        {
            if ( (nSel = (int)SendDlgItemMessage( hDlg,
                                             wLangNameList,
                                             CB_FINDSTRINGEXACT,
                                             (WPARAM)-1,
                                             (LPARAM)pszLangName)) != CB_ERR )
            {
                                //... default master language is in  list

                SendDlgItemMessage( hDlg,
                                    wLangNameList,
                                    CB_SETCURSEL,
                                    (WPARAM)nSel,
                                    (LPARAM)0);

                if ( pfSelected )
                {
                    *pfSelected = TRUE;
                }
            }
        }
    }
    else if ( nSel == 0 )
    {
                                //... Use first entry in the list

        SendDlgItemMessage( hDlg,
                            wLangNameList,
                            CB_SETCURSEL,
                            (WPARAM)nSel,
                            (LPARAM)0);

        if ( (nSel = (int)SendDlgItemMessage( hDlg,
                                         wLangNameList,
                                         CB_GETLBTEXT,
                                         (WPARAM)nSel,
                                         (LPARAM)(LPTSTR)szDHW)) != CB_ERR )
        {
            WORD wPri = 0;
            WORD wSub = 0;

            if ( GetLangIDs( (LPTSTR)szDHW, &wPri, &wSub) )
            {
                *pLangID   = MAKELANGID( wPri, wSub);

                if ( pfSelected )
                {
                    *pfSelected = TRUE;
                }
            }
            else
            {
                nSel = CB_ERR;
            }
        }
    }

    if ( nSel == CB_ERR )
    {
        SetDlgItemText( hDlg, wLangNameList, TEXT("UNKNOWN"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\resourc2.h ===
#ifndef _RESOURC2_H_
#define _RESOURC2_H_

#define IDC_STATIC           -1

// DIALOG ID's
#define IDD_TOKFILE         101
#define IDD_RESFILE         102
#define IDD_BROWSE          103
#define IDD_EXEFILE         104

#define IDD_INRESFILE       202
#define IDD_OUTRESFILE      203

#define IDD_TOKEDIT         500
#define IDD_TOKTYPE         505
#define IDD_TOKNAME         506
#define IDD_TOKID           507
#define IDD_TOKTEXT         508

#define IDD_TOKCURTRANS     509
#define IDD_TOKPREVTRANS    510
#define IDD_TOKCURTEXT      511
#define IDD_TOKPREVTEXT     512
#define IDD_ADD             513
#define IDD_SKIP            514
#define IDD_STATUS          515
#define IDD_TRANSLATE       516
#define IDD_UNTRANSLATE     517

#define IDD_TRANSTOK        610
#define IDD_TRANSGLOSS      620

#define IDD_TYPELST         700
#define IDD_READONLY        703
#define IDD_CHANGED         704
#define IDD_DIRTY           705

#define IDD_FINDTOK         710
#define IDD_FINDUP          711
#define IDD_FINDDOWN        712


#define IDD_SOURCERES       110
#define IDD_MTK             111
#define IDD_RDFS            112
#define IDD_MPJ             113
#define IDD_TOK             114
#define IDD_BUILTRES        115
#define IDD_GLOSS           116

#define IDD_PROJ_PRI_LANG_ID 130
#define IDD_PROJ_SUB_LANG_ID 131
#define IDD_PROJ_TOK_CP     132

#define IDD_PRI_LANG_ID     133
#define IDD_SUB_LANG_ID     134
#define IDD_TOK_CP          135
#define IDD_MSTR_LANG_NAME  136
#define IDD_PROJ_LANG_NAME  137

#define IDD_VIEW_SOURCERES  206
#define IDD_VIEW_MTK        207
#define IDD_VIEW_RDFS       208
#define IDD_VIEW_MPJ        209
#define IDD_VIEW_TOK        210
#define IDD_VIEW_TARGETRES  211
#define IDD_VIEW_GLOSSTRANS 212

#define IDD_LANGUAGES       300
#define IDC_REPLACE         301
#define IDC_APPEND          302

// MENU ID's
#define IDM_PROJECT         1000
#define IDM_P_NEW           1050
#define IDM_P_OPEN          1100
#define IDM_P_VIEW          1112
#define IDM_P_EDIT          1114
#define IDM_P_CLOSE         1125
#define IDM_P_SAVE          1150
#define IDM_P_SAVEAS        1200
#define IDM_P_EXIT          1250

#define IDM_EDIT            2000
#define IDM_E_COPYTOKEN     2050
#define IDM_E_COPY          2060
#define IDM_E_PASTE         2070
#define IDM_E_FIND          2090
#define IDM_E_FINDDOWN      2091
#define IDM_E_FINDUP        2092
#define IDM_E_REVIEW        2100
#define IDM_E_ALLREVIEW     2101

#define IDM_OPERATIONS      3000
#define IDM_O_UPDATE        3010
#define IDM_O_GENERATE      3020

#define IDM_G_GLOSS         3050

// 3100-3109 are reserved by RLEDIT for resource editing tools.
// A resource is given a menu item that passes this value for it's
// command parameter.  A corresponding string must exist in the string
// table indicating the name of the editer to be invoked.
//
// When the user selects the menu item, it generates the appropriate command.
// When RLEDIT recieves a command in the IDM_FIRST_EDIT and IDM_LAST_EDIT range
// it saves all the tokens and builds a temporary resource file.
// RLEDIT then retrieves the name of the editer from the string table and
// performs a WinExec command on the temporary resource file.
// When control is returned to RLEDIT (the user closes the resource editor)
// the token file is rebuilt from the edited resource file, the temporary
// resource file is deleted, and the tokens are loaded back into the system.

#define IDM_FIRST_EDIT      3100
#define IDM_LAST_EDIT       3109

#define IDM_HELP            4000
#define IDM_H_CONTENTS      4010
#define IDM_H_ABOUT         4030

// Control IDs
#define IDC_EDIT            401
#define IDC_LIST            402
#define IDC_COPYRIGHT       403

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        7001
#define _APS_NEXT_COMMAND_VALUE         6001
#define _APS_NEXT_CONTROL_VALUE         5001
#define _APS_NEXT_SYMED_VALUE           8001
#endif
#endif


#endif // _RESOURC2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\resread.h ===
//... Prototypes of functions in resread.c that are used in other modules

#ifndef _RESREAD_H_
#define _RESREAD_H_

int   MyStrLen( TCHAR *psz);

#ifdef _DEBUG
PBYTE MyAlloc( DWORD size, LPSTR pszFile, WORD wLine);
PBYTE MyReAlloc( BYTE *p, DWORD n, LPSTR pszFile, WORD wLine);
#else
PBYTE MyAlloc( DWORD n);
PBYTE MyReAlloc( BYTE *p, DWORD n);
#endif

void  MyFree( void *UNALIGNED*p);
int   InsDlgToks( CHAR * s1, CHAR * s2, WORD n);
void  FreeLangIDList( void);

typedef struct _tagLangList
{
    WORD wLang;
    struct _tagLangList *pNext;
} LANGLIST, * PLANGLIST;



#ifdef _DEBUG

typedef struct _tagMemList
{
    char szMemFile[ _MAX_PATH];
    WORD wMemLine;
    PBYTE  pMem;
    struct _tagMemList *pNext;
} MEMLIST, * PMEMLIST;

void FreeMemList( FILE *pfFile);
void FreeMemListItem( void *p, FILE *pfFile);

#endif // _DEBUG

#endif // _RESREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\reswin16.c ===
#include <windows.h>
#include <stdio.h>

#include "restok.h"
#include "reswin16.h"
#include "rlmsgtbl.h"


//.............................................................................

int ExtractResFromExe16A(

CHAR *szInputExe, 
CHAR *szOutputRes, 
WORD wFilter)
{
    szInputExe;
    szOutputRes; 
    wFilter;

    QuitT( IDS_NO16RESWINYET, NULL, NULL);

    return(-1);
}

//.............................................................................

int BuildExeFromRes16A(

CHAR *pstrDest,
CHAR *pstrRes,
CHAR *pstrSource )
{
    pstrDest;
    pstrRes;
    pstrSource;

    QuitT( IDS_NO16WINRESYET, NULL, NULL);

    return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\rlstrngs.h ===
#ifndef _RLSTRNGS_H_
#define _RLSTRNGS_H_

// String IDs
#define IDS_ERR_REGISTER_CLASS  1
#define IDS_ERR_CREATE_WINDOW   2
#define IDS_ERR_NO_HELP     3
#define IDS_ERR_NO_MEMORY   4
#define IDS_NOT_IMPLEMENTED 5
#define IDS_GENERALFAILURE  6
#define IDS_MPJ             7
#define IDS_RES_SRC         8
#define IDS_RES_BLD         9
#define IDS_TOK             10
#define IDS_READONLY        11
#define IDS_CLEAN           12
#define IDS_DIRTY           13
#define IDS_FILENOTFOUND    14
#define IDS_FILESAVEERR     15
#define IDS_RESOURCENAMES   15  // Incremented by res type # in rlstrngs.rc
                     // 16-31 used for Resource Type names
#define IDS_ERR_00  32
#define IDS_ERR_01  33
#define IDS_ERR_02  34
#define IDS_ERR_03  35
#define IDS_ERR_04  36
#define IDS_ERR_05  37
#define IDS_ERR_06  38
#define IDS_ERR_07  39
#define IDS_ERR_08  40
#define IDS_ERR_09  41
#define IDS_ERR_10  42
#define IDS_ERR_11  43
#define IDS_ERR_12  44
#define IDS_ERR_13  45
#define IDS_ERR_14  46
#define IDS_ERR_15  47
#define IDS_ERR_16  48
#define IDS_ERR_17  49
#define IDS_ERR_18  50
#define IDS_ERR_19  51
#define IDS_ERR_20  52
#define IDS_ERR_21  53
#define IDS_ERR_22  54
#define IDS_ERR_23  55
#define IDS_ERR_24  56
#define IDS_ERR_25  57
#define IDS_ERR_26  58
#define IDS_ERR_27  59
#define IDS_ERR_28  60


#define IDS_RLE_APP_NAME        64
#define IDS_RLQ_APP_NAME        65
#define IDS_RLA_APP_NAME        66
#define IDS_ERR_NO_GLOSSARY     70
#define IDS_ERR_NO_TOKEN        71
#define IDS_ERR_TMPFILE         72

#define IDS_RDF                 80
#define IDS_MTK                 81
#define IDS_GLOSS               86
#define IDS_RDFSPEC             87
#define IDS_PRJSPEC             88
#define IDS_RESSPEC             89
#define IDS_EXESPEC             90
#define IDS_TOKSPEC             91
#define IDS_MTKSPEC             92
#define IDS_MPJSPEC             93
#define IDS_DLLSPEC             94
#define IDS_CPLSPEC             95
#define IDS_GLOSSSPEC           96

#define IDS_MPJERR              112
#define IDS_MPJOUTOFDATE        113
#define IDS_UPDATETOK           114
#define IDS_REBUILD_TOKENS      115
#define IDS_TOKEN_FOUND         116
#define IDS_TOKEN_NOT_FOUND     117
#define IDS_FIND_TOKEN          118
#define IDS_OPENTITLE           119
#define IDS_SAVETITLE           120
#define IDS_ADDGLOSS            121
#define IDS_RLE_CANTSAVEASEXE   122
#define IDS_SAVECHANGES         123
#define IDS_NOCHANGESYET        124
#define IDS_CHANGED             125
#define IDS_UNCHANGED           126
#define IDS_NEW                 127
#define IDS_DRAGMULTIFILE       129
#define IDS_CANTSAVEASRES       130
#define IDS_RLQ_CANTSAVEASEXE   131
#define IDS_RLQ_CANTSAVEASRES   132

// 3100-3109 are reserved by RLQuikEd and RLRdit for resource editing tools.
// A resource is given a menu item that passes this value for it's
// command parameter.  A corresponding string must exist in the string
// table indicating the name of the editer to be invoked.
//
// When the user selects the menu item, it generates the appropriate command.
// When RLQuikEd recieves a command in the IDM_FIRST_EDIT and IDM_LAST_EDIT range
// it saves all the tokens and builds a temporary resource file.
// RLQuikEd then retrieves the name of the editer from the string table and
// performs a WinExec command on the temporary resource file.
// When control is returned to RLQuikEd (the user closes the resource editor)
// the token file is rebuilt from the edited resource file, the temporary
// resource file is deleted, and the tokens are loaded back into the system.

#define IDM_FIRST_EDIT  3100
#define IDM_LAST_EDIT   3109


#endif //_RLSTRNGS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\showerrs.c ===
#include <windows.h>

#include <stdio.h>

#include "restok.h"
#include "showerrs.h"


extern UCHAR szDHW[];
extern CHAR  szAppName[];

//............................................................

void ShowEngineErr( int n, void *p1, void *p2)
{
    CHAR *pMsg = NULL;
    CHAR *pArg[2];


    pArg[0] = p1;
    pArg[1] = p2;


    if ( B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                        | FORMAT_MESSAGE_FROM_HMODULE
                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         NULL,
                         (DWORD)n,
                         szDHW,
                         DHWSIZE,
                         (va_list *)pArg) )
    {
        RLMessageBoxA( szDHW);
    }
    else
    {

        sprintf( szDHW,
                 "Internal error: FormatMessage call failed: msg %d: err %Lu",
                 n,
                 GetLastError());

        RLMessageBoxA( szDHW);

    }
}

//...................................................................

void ShowErr( int n, void *p1, void *p2)
{
    CHAR *pMsg = NULL;
    CHAR *pArg[2];

    pArg[0] = p1;
    pArg[1] = p2;

    pMsg = GetErrMsg( n);

    if ( ! pMsg )
    {
        pMsg = "Internal error: UNKNOWN ERROR MESSAGE id# %1!d!";
        pArg[0] = IntToPtr(n);
    }

    if ( pMsg )
    {
        if ( FormatMessageA( FORMAT_MESSAGE_MAX_WIDTH_MASK | 72
                            | FORMAT_MESSAGE_FROM_STRING
                            | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                             pMsg,
                             0,
                             0,
                             szDHW,
                             DHWSIZE,
                             (va_list *)pArg) )
        {
            RLMessageBoxA( szDHW);
        }
        else
        {
            RLMessageBoxA( "Internal error: FormatMessage call failed");
        }
    }
    else
    {
        RLMessageBoxA( "Internal error: GetErrMsg call failed");
    }
}

//............................................................

CHAR *GetErrMsg( UINT uErrID)
{
    static CHAR szBuf[ 1024];

    int n = LoadStringA( NULL, uErrID, szBuf, sizeof( szBuf));

    return( n ? szBuf : NULL);
}

//.......................................................
//...
//... Bi-Lingual FormatMessage

DWORD B_FormatMessage(

DWORD    dwFlags,
LPCVOID  lpSource,
DWORD    dwMessageId,
LPSTR    lpBuffer,
DWORD    nSize,
va_list *Arguments )
{

    DWORD ret;
                                //... Look for message in current locale
    if ( !(ret = FormatMessageA( dwFlags,
                                 lpSource,
                                 dwMessageId,
	                             LOWORD( GetThreadLocale()),
	                             lpBuffer,
	                             nSize,
	                             Arguments)) )
    {
                                //... Not found, so look for US English message

        if ( GetLastError() == ERROR_RESOURCE_LANG_NOT_FOUND )
        {
            return( FormatMessageA( dwFlags,
                                    lpSource,
                                    dwMessageId,
                                    0x0409L,
                                    lpBuffer,
                                    nSize,
                                    Arguments) );
        }
    }
    return( ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\resread.c ===
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
//#include <malloc.h>
#include <tchar.h>
//#include <assert.h>
//#include <sys\types.h>
//#include <sys\stat.h>
#include <fcntl.h>

#ifdef RLDOS
    #include "dosdefs.h"
#else  //RLDOS
    #include <windows.h>
    #include "windefs.h"
#endif //RLDOS

#include "resread.h"
#include "restok.h"
#include "custres.h"
#ifdef RLRES32
    #include "exentres.h"
    #include "reswin16.h"
#else  //RLRES32
    #include "exe2res.h"
#endif //RLRES32


UCHAR szDHW[ DHWSIZE];         //... Common temporary buffer

char * gszTmpPrefix = "$RLT";   //... Temporary name prefix

BOOL gbMaster       = FALSE;    //... TRUE if Working in Master project
BOOL gfReplace      = TRUE;     //... FALSE if appending new language to exe
BOOL gbShowWarnings = FALSE;    //... Display warnining messages if TRUE

#ifdef _DEBUG
PMEMLIST pMemList = NULL;
#endif


static BOOL ShouldBeAnExe( CHAR *);
static BOOL NotExistsOrIsEmpty( PCHAR szTargetTokFile);


/**
  *
  *
  *  Function: DWORDfpUP
  * Move the file pointer to the next 32 bit boundary.
  *
  *
  *  Arguments:
  * Infile: File pointer to seek
  * plSize: Address of Resource size var
  *
  *  Returns:
  * Number of padding to next 32 bit boundary, and addjusts resource size var
  *
  *  Errors Codes:
  * -1, fseek failed
  *
  *  History:
  * 10/11/91    Implemented      TerryRu
  *
  *
  **/


DWORD DWORDfpUP(FILE * InFile, DWORD *plSize)
{
    DWORD tPos;
    DWORD Align;
    tPos = (ftell(InFile));
    Align = DWORDUP(tPos);

    *plSize -= (Align - tPos);
    fseek( InFile, Align,   SEEK_SET);

    return ( Align - tPos);
}

/*
 *
 * Function GetName,
 *  Copies a name from the OBJ file into the ObjInfo Structure.
 *
 */
void GetName( FILE *infile, TCHAR *szName , DWORD *lSize)
{
    WORD i = 0;

    do {

#ifdef RLRES16

        szName[ i ] = GetByte( infile, lSize);

#else

        szName[ i ] = GetWord( infile, lSize);

#endif

    } while ( szName[ i++ ] != TEXT('\0') );
}



/*
 *
 * Function MyAlloc:
 *  Memory allocation routine with error checking.
 *
 */

#ifdef _DEBUG
PBYTE MyAlloc( DWORD dwSize, LPSTR pszFile, WORD wLine)
#else
PBYTE MyAlloc( DWORD dwSize)
#endif
{
    PBYTE   ptr  = NULL;
    HGLOBAL hMem = GlobalAlloc( GMEM_MOVEABLE | GMEM_ZEROINIT,
                                (size_t)((dwSize > 0) ? dwSize : sizeof( TCHAR)));

    if ( hMem == NULL ) {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    } else {
        ptr = GlobalLock( hMem);
    }

#ifdef _DEBUG
    {
        PMEMLIST pTmpMem = (PMEMLIST)GlobalAlloc( GPTR, sizeof( MEMLIST));

        pTmpMem->pNext = pMemList;
        pMemList = pTmpMem;

        lstrcpyA( pMemList->szMemFile, pszFile);
        pMemList->wMemLine = wLine;
        pMemList->pMem     = ptr;
    }

#endif // _DEBUG

    return ( ptr);   // memory allocation okay.
}

//..........................................................................

//ppc cause access violation
void MyFree( void *UNALIGNED*p)
{
    if ( p && *p ) {

#ifdef _DEBUG

        FreeMemListItem( *p, NULL);
#else
        HGLOBAL hMem = GlobalHandle( (HANDLE)*p);
        GlobalUnlock( hMem);
        GlobalFree( hMem);

#endif // _DEBUG

        *p = NULL;
    }
}


#ifdef _DEBUG

void FreeMemList( FILE *pfMemFile)
{
    while ( pMemList ) {
        FreeMemListItem( pMemList->pMem, pfMemFile);
    }
}


void FreeMemListItem( void *p, FILE *pfMemFile)
{
    if ( pMemList && p ) {
        PMEMLIST pThisMem = NULL;
        PMEMLIST pNextMem = NULL;
        PMEMLIST pPrevMem = NULL;

        for ( pThisMem = pMemList; pThisMem; pThisMem = pNextMem ) {
            pNextMem = pThisMem->pNext;

            if ( pThisMem->pMem == p ) {
                HGLOBAL hMem = NULL;

                if ( pfMemFile ) {
                    fprintf( pfMemFile,
                             "%u\t%s\n",
                             pThisMem->wMemLine,
                             pThisMem->szMemFile);
                }
                hMem = GlobalHandle( p);
                GlobalUnlock( hMem);
                GlobalFree( hMem);

                GlobalFree( pThisMem);

                if ( pPrevMem ) {
                    pPrevMem->pNext = pNextMem;
                } else {
                    pMemList = pNextMem;
                }
                break;
            }
            pPrevMem = pThisMem;
        }
    }
}

#endif // _DEBUG

/*
 *
 * Function MyReAlloc
 *
 * Re-allocate memory with error checking.
 *
 * History:
 *      01/21/93  MHotchin      Implemented.
 *
 */

#ifdef _DEBUG
PBYTE MyReAlloc(
               PBYTE pOldMem,  //... Current ptr to buffer
               DWORD cSize,    //... New size for buffer
               LPSTR pszFile,
               WORD wLine)
#else
PBYTE MyReAlloc(
               PBYTE pOldMem,  //... Current ptr to buffer
               DWORD cSize)    //... New size for buffer
#endif // _DEBUG
{
    PBYTE    ptr      = NULL;
    HGLOBAL  hMem     = NULL;


    hMem = GlobalHandle( pOldMem);

    if ( hMem == NULL ) {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    }

    if ( GlobalUnlock( hMem) || GetLastError() != NO_ERROR ) {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    }
    hMem = GlobalReAlloc( hMem, cSize, GMEM_MOVEABLE | GMEM_ZEROINIT);

    if ( hMem == NULL ) {
        QuitT( IDS_ENGERR_11, NULL, NULL);
    }
    ptr = GlobalLock( hMem);

#ifdef _DEBUG

    if ( ptr != pOldMem ) {
        PMEMLIST pThisMem = NULL;
        PMEMLIST pNextMem = NULL;

        for ( pThisMem = pMemList; pThisMem; pThisMem = pThisMem->pNext ) {
            if ( pThisMem->pMem == pOldMem ) {
                pThisMem->pMem = ptr;
                break;
            }
        }
    }

#endif // _DEBUG

    return ( ptr);
}


/*
 *
 * Function GetByte:
 *  Reads a byte from the input file stream, and checks for EOF.
 *
 */
BYTE GetByte(FILE *pInFile, DWORD *pdwSize)
{
    register int n;

    if ( pdwSize ) {
        (*pdwSize)--;
    }
    n = fgetc( pInFile);

    if ( n == EOF ) {
        if ( feof( pInFile) ) {
            exit(-1);
        }
    }
    return ( (BYTE)n);
}


/*
 *
 * Function UnGetByte:
 *
 *   Returns the character C into the input stream, and updates the Record Length.
 *
 * Calls:
 *   ungetc, To return character
 *   DiffObjExit, If unable to insert the character into the input stream
 *
 * Caller:
 *   GetFixUpP,
 *
 */

void UnGetByte(FILE *infile, BYTE c, DWORD *lSize)
{
    if (lSize) {
        (*lSize)++;
    }


    if (ungetc(c, infile)== EOF) {
        exit (-1);
    }

    // c put back into input stream
}

/*
 *
 * Function UnGetWord:
 *
 *   Returns the word C into the input stream, and updates the Record Length.
 *
 * Calls:
 *
 * Caller:
 *
 */

void UnGetWord(FILE *infile, WORD c, DWORD *lSize)
{
    long lCurrentOffset;

    if (lSize) {
        (*lSize) += 2;
    }

    lCurrentOffset = ftell(infile);

    if (fseek(infile, (lCurrentOffset - 2L) , SEEK_SET)) {
        exit (-1);
    }
}


/*
 *
 * Function SkipBytes:
 *  Reads and ignores n bytes from the input stream
 *
 */


void SkipBytes(FILE *infile, DWORD *pcBytes)
{
    if (fseek(infile, (DWORD) *pcBytes, SEEK_CUR) == -1L) {
        exit (-1);
    }
    *pcBytes=0;
}



/*
 * Function GetWord:
 *  Reads a WORD from the RES file.
 *
 */

WORD GetWord(FILE *infile, DWORD *lSize)
{
    // Get low order byte
    register WORD lobyte;

    lobyte = GetByte(infile, lSize);
    return (lobyte + (GetByte(infile, lSize) << BYTELN));
}


/*
 *
 * Function GetDWORD:
 *   Reads a Double WORD from the OBJ file.
 *
 */

DWORD GetdWord(FILE *infile, DWORD *lSize)
{
    DWORD dWord = 0;

    dWord = (DWORD) GetWord(infile, lSize);
    // Get low order word
    // now get high order word, shift into upper word and or in low order word
    dWord |= ((DWORD) GetWord(infile, lSize) << WORDLN);

    return (dWord);
    // return complete double word
}



void  PutByte(FILE *Outfile, TCHAR b, DWORD *plSize)
{
    if (plSize) {
        (*plSize) ++;
    }

    if (fputc(b, Outfile) == EOF) {
        exit(-1);
    }
}

void PutWord(FILE *OutFile, WORD w, DWORD *plSize)
{
    PutByte(OutFile, (BYTE) LOBYTE(w), plSize);
    PutByte(OutFile, (BYTE) HIBYTE(w), plSize);
}

void PutdWord (FILE *OutFile, DWORD l, DWORD *plSize)
{
    PutWord(OutFile, LOWORD(l), plSize);
    PutWord(OutFile, HIWORD(l), plSize);
}


void PutString( FILE *OutFile, TCHAR *szStr , DWORD *plSize)
{
    WORD i = 0;


    do {

#ifdef RLRES16

        PutByte( OutFile , szStr[ i ], plSize);

#else

        PutWord( OutFile , szStr[ i ], plSize);

#endif

    } while ( szStr[ i++ ] != TEXT('\0') );
}


/**
  *  Function: MyGetTempFileName
  *    Generic funciton to create a unique file name,
  *    using the API GetTempFileName. This
  *    function is necessary because of the parameters
  *    differences betweenLWIN16, and WIN32.
  *
  *
  *  Arguments:
  *    BYTE   hDriveLetter
  *    LPCSTR lpszPrefixString
  *    UINT   uUnique
  *    LPSTR  lpszTempFileName
  *
  *  Returns:
  *    lpszFileNameTempFileName
  *
  *
  *  Error Codes:
  *    0 - invalid path returned
  *    1 - valid path returned
  *
  *  History:
  *    3/92, Implemented    TerryRu
  */


int MyGetTempFileName(BYTE    hDriveLetter,
                      LPSTR   lpszPrefixString,
                      WORD    wUnique,
                      LPSTR   lpszTempFileName)
{

#ifdef RLWIN16

    return (GetTempFileName(hDriveLetter,
                            (LPCSTR)lpszPrefixString,
                            (UINT)wUnique,
                            lpszTempFileName));
#else //RLWIN16
    #ifdef RLWIN32

    UINT uRC;
    CHAR szPathName[ MAX_PATH+1];

    if (! GetTempPathA((DWORD)sizeof(szPathName), (LPSTR)szPathName)) {
        szPathName[0] = '.';
        szPathName[1] = '\0';
    }

    uRC = GetTempFileNameA((LPSTR)szPathName,
                           lpszPrefixString,
                           wUnique,
                           lpszTempFileName);
    return ((int)uRC);

    #else  //RLWIN32

    return (tmpnam(lpszTempFileName) == NULL ? 0 : 1);

    #endif // RLWIN32
#endif // RLWIN16
}



/**
  *  Function GenerateImageFile:
  *     builds a resource from the token and rdf files
  *
  *  History:
  *     2/92, implemented       SteveBl
  *     7/92, modified to always use a temporary file   SteveBl
  */


int GenerateImageFile(

                     CHAR * szTargetImage,
                     CHAR * szSrcImage,
                     CHAR * szTOK,
                     CHAR * szRDFs,
                     WORD   wFilter)
{
    CHAR szTmpInRes[ MAXFILENAME];
    CHAR szTmpOutRes[ MAXFILENAME];
    CHAR szTmpTargetImage[ MAXFILENAME];
    BOOL bTargetExe = FALSE;
    BOOL bSrcExe  = FALSE;
    int  nExeType = NOTEXE;
    int  rc;
    FILE *fIn  = NULL;
    FILE *fOut = NULL;


    if ( IsRes( szTOK) ) {
        // The given szTOK file is really a localized resource file,
        // place these resources into outputimage file

        MyGetTempFileName( 0, "TMP", 0, szTmpTargetImage);

        if ( IsWin32Res( szTOK) ) {
            rc = BuildExeFromRes32A( szTmpTargetImage, szTOK, szSrcImage);
        } else {
            rc = BuildExeFromRes16A( szTmpTargetImage, szTOK, szSrcImage);
        }

        if ( rc != 1 ) {
            remove( szTmpTargetImage);
            QuitT( IDS_ENGERR_16, (LPTSTR)IDS_NOBLDEXERES, NULL);
        }

        if ( ! CopyFileA( szTmpTargetImage, szTargetImage, FALSE) ) {
            remove( szTmpTargetImage);
            QuitA( IDS_COPYFILE_FAILED, szTmpTargetImage, szTargetImage);
        }
        remove( szTmpTargetImage);
        return ( rc);
    }


    // We're going to now do this EVERY time.  Even if the target doesn't
    // exist.  This will enable us to always work, even if we get two different
    // paths that resolve to the same file.

    MyGetTempFileName(0, "TMP", 0, szTmpTargetImage);

    rc = IsExe( szSrcImage);

    if ( rc == NTEXE || rc == WIN16EXE ) {
        //... resources contained in image file
        nExeType = rc;
        MyGetTempFileName( 0, "RES", 0, szTmpInRes);

        if ( nExeType == NTEXE ) {
            ExtractResFromExe32A( szSrcImage, szTmpInRes, wFilter);
        } else {
            ExtractResFromExe16A( szSrcImage, szTmpInRes, wFilter);
        }
        bSrcExe = TRUE;
    } else if ( rc == -1 ) {
        QuitA( IDS_ENGERR_01, "original source", szSrcImage);
    } else if ( rc == NOTEXE ) {
        if ( ShouldBeAnExe( szSrcImage) ) {
            QuitA( IDS_ENGERR_18, szSrcImage, NULL);
        }
    } else {
        QuitA( IDS_ENGERR_18, szSrcImage, NULL);
    }

    if ( IsRes( szTargetImage) ) {
        bTargetExe = FALSE;
    } else {
        bTargetExe = TRUE;
    }

    // check for valid input files

    if ( bSrcExe == TRUE && bTargetExe == FALSE ) {
        if ( nExeType == NTEXE ) {
            GenerateRESfromRESandTOKandRDFs( szTargetImage,
                                             szTmpInRes,
                                             szTOK,
                                             szRDFs,
                                             FALSE);
            return 1;
        } else {
            return -1;  //... Can not generate a win16 .RES  (yet)
        }
    }

    if ( bSrcExe == FALSE && bTargetExe == TRUE ) {
        // can not go from res to exe
        return -1;
    }

    // okay we have valid file inputs, generate image file

    if ( bSrcExe ) {
        // create name for temporary localized resource file
        MyGetTempFileName(0, "RES", 0, szTmpOutRes);

        GenerateRESfromRESandTOKandRDFs( szTmpOutRes,
                                         szTmpInRes,
                                         szTOK,
                                         szRDFs,
                                         FALSE);

        // now szTmpOutRes file is a localized resource file,
        // place these resources into outputimage file

        if ( nExeType == NTEXE ) {
            rc = BuildExeFromRes32A( szTmpTargetImage, szTmpOutRes, szSrcImage);
        } else {
//            rc = BuildExeFromRes16A( szTmpTargetImage, szTmpOutRes, szSrcImage);

            remove( szTmpInRes);
            remove( szTmpOutRes);
            remove( szTmpTargetImage);

            QuitT( IDS_ENGERR_16, (LPTSTR)IDS_NOBLDEXERES, NULL);
        }

        // now clean up temporary files
        remove( szTmpInRes);
        remove( szTmpOutRes);

        if ( rc != 1 ) {
            remove( szTmpTargetImage);
            QuitT( IDS_ENGERR_16, (LPTSTR)IDS_NOBLDEXERES, NULL);
        }

        if ( ! CopyFileA( szTmpTargetImage, szTargetImage, FALSE) ) {
            remove( szTmpTargetImage);
            QuitA( IDS_COPYFILE_FAILED, szTmpTargetImage, szTargetImage);
        }
        remove( szTmpTargetImage);

        // szTargetImage is now generated,
        return 1;
    }

    if ( ! bSrcExe ) {
        // image files are resource files
        if ( szTmpTargetImage[0] ) {
            GenerateRESfromRESandTOKandRDFs( szTmpTargetImage,
                                             szSrcImage,
                                             szTOK,
                                             szRDFs,
                                             FALSE);
        }

        if ( ! CopyFileA( szTmpTargetImage, szTargetImage, FALSE) ) {
            remove( szTmpTargetImage);
            QuitA( IDS_COPYFILE_FAILED, szTmpTargetImage, szTargetImage);
        }
        remove( szTmpTargetImage);

        // sztarget Image is now generated,

        return 1;
    }
    return 1;
}




/**
  *  Function GenerateRESfromRESandTOKandRDFs:
  * builds a resource from the token and rdf files
  *
  *  History:
  * 2/92, implemented       SteveBl
  */
void GenerateRESfromRESandTOKandRDFs(

                                    CHAR * szTargetRES,     //... Output exe/res file name
                                    CHAR * szSourceRES,     //... Input  exe/res file name
                                    CHAR * szTOK,           //... Input token file name
                                    CHAR * szRDFs,          //... Custom resource definition file name
                                    WORD wFilter)
{
    FILE * fTok       = NULL;
    FILE * fSourceRes = NULL;
    FILE * fTargetRes = NULL;

    LoadCustResDescriptions( szRDFs);

    if ( (fTargetRes = FOPEN( szTargetRES, "wb")) != NULL ) {
        if ( (fSourceRes = FOPEN( szSourceRES, "rb")) != NULL ) {
            if ( (fTok = FOPEN( szTOK, "rt")) != NULL ) {
                ReadWinRes( fSourceRes,
                            fTargetRes,
                            fTok,
                            TRUE,        //... Building res/exe file
                            FALSE,       //... Not building token file
                            wFilter);

                FCLOSE( fTok);
                FCLOSE( fSourceRes);
                FCLOSE( fTargetRes);

                ClearResourceDescriptions();
            } else {
                FCLOSE( fSourceRes);
                FCLOSE( fTargetRes);

                ClearResourceDescriptions();
                QuitA( IDS_ENGERR_01, "token", szTOK);
            }
        } else {
            FCLOSE( fTargetRes);

            ClearResourceDescriptions();
            QuitA( IDS_ENGERR_20, (LPSTR)IDS_INPUT, szSourceRES);
        }
    } else {
        ClearResourceDescriptions();
        QuitA( IDS_ENGERR_20, (LPSTR)IDS_OUTPUT, szSourceRES);
    }
}




int GenerateTokFile(

                   char *szTargetTokFile,      //... Target token file, created or updated here
                   char *szSrcImageFile,       //... File from which tokens are to be made
                   BOOL *pbTokensChanged,      //... Set TRUE here if any token changes
                   WORD  wFilter)
{
    BOOL  bExeFile    = FALSE;
    int   rc          = 0;
    FILE *fTokFile    = NULL;
    FILE *fResFile    = NULL;
    FILE *fTmpTokFile = NULL;
    FILE *fCurTokFile = NULL;
    FILE *fNewTokFile = NULL;
    static char *pchTRes   = NULL;
    static char *pchTTok   = NULL;
    static char *pchTMerge = NULL;


    *pbTokensChanged = FALSE;   //... Assume nothing is changed

    rc = IsExe( szSrcImageFile);

    if ( rc == NOTEXE ) {
        if ( ShouldBeAnExe( szSrcImageFile) ) {
            QuitA( IDS_ENGERR_18, szSrcImageFile, NULL);
        } else {                       //... Src file must be a .RES file
            bExeFile = FALSE;
            pchTRes  = szSrcImageFile;
        }
    } else {
        if ( rc == NTEXE || rc == WIN16EXE ) {
            //... Resources are stored in a exe file
            //... extract resources out of exe file into
            //... a temporary file.

            pchTRes = _tempnam( "", gszTmpPrefix);

            if ( rc == NTEXE ) {
                rc = ExtractResFromExe32A( szSrcImageFile,
                                           pchTRes,
                                           wFilter);
            } else {
                QuitA( IDS_ENGERR_19, szSrcImageFile, "16");
//                rc = ExtractResFromExe16A( szSrcImageFile,
//                                           pchTRes,
//                                           wFilter);
            }

            if ( rc  != 0 ) {
                return ( 1);
            }
            bExeFile = TRUE;
        } else if ( rc == -1 ) {
            QuitA( IDS_ENGERR_01, "source image", szSrcImageFile);
        } else {
            QuitA( IDS_ENGERR_18, szSrcImageFile, NULL);
        }
    }

    //... now extract tokens out of resource file

    //... Open res file

    if ( (fResFile = FOPEN( pchTRes, "rb")) == NULL ) {
        QuitA( IDS_ENGERR_01,
               bExeFile ? "temporary resource" : "resource",
               pchTRes);
    }
    //... Does the token file already exist?

    if ( NotExistsOrIsEmpty( szTargetTokFile) ) {
        //... No, token file does not exist.

        if ( (fTokFile = FOPEN( szTargetTokFile, "wt")) == NULL ) {
            FCLOSE( fResFile);
            QuitA( IDS_ENGERR_02, szTargetTokFile, NULL);
        }
        ReadWinRes( fResFile,
                    NULL,
                    fTokFile,
                    FALSE,      //... Not building res/exe file
                    TRUE,       //... Building token file
                    wFilter);

        FCLOSE( fResFile);
        FCLOSE( fTokFile);
    } else {
        //... token file exists
        //... create a temporary file, and try to
        //... merge with existing one

        pchTTok   = _tempnam( "", gszTmpPrefix);
        pchTMerge = _tempnam( "", gszTmpPrefix);

        //... open temporary file name

        if ( (fTmpTokFile = FOPEN( pchTTok, "wt")) == NULL ) {
            FCLOSE( fResFile);
            QuitA( IDS_ENGERR_02, pchTTok, NULL);
        }

        //... write tokens to temporary file

        ReadWinRes( fResFile,
                    NULL,
                    fTmpTokFile,
                    FALSE,      //... Not building res/exe file
                    TRUE,       //... Building token file
                    wFilter);

        FCLOSE( fResFile);
        FCLOSE( fTmpTokFile);

        //... now merge temporary file with existing
        //... file open temporary token file

        if ( (fTmpTokFile = FOPEN( pchTTok, "rt")) == NULL ) {
            QuitA( IDS_ENGERR_01, "temporary token", pchTTok);
        }

        //... open current token file

        if ( (fCurTokFile = FOPEN( szTargetTokFile, "rt")) == NULL ) {
            FCLOSE( fTmpTokFile);
            QuitA( IDS_ENGERR_01, "current token", szTargetTokFile);
        }

        //... open new tok file name

        if ( (fNewTokFile = FOPEN( pchTMerge, "wt")) == NULL ) {
            FCLOSE( fTmpTokFile);
            FCLOSE( fCurTokFile);
            QuitA( IDS_ENGERR_02, pchTMerge, NULL);
        }

        //... Merge current tokens with temporary tokens

        *pbTokensChanged = MergeTokFiles( fNewTokFile,
                                          fCurTokFile,
                                          fTmpTokFile);

        FCLOSE( fNewTokFile);
        FCLOSE( fTmpTokFile);
        FCLOSE( fCurTokFile);

        //... bpTokensChanged, only valid if creating
        //... master token files so force it to be
        //... always true if building proj token files.

        if ( gbMaster == FALSE ) {
            *pbTokensChanged = TRUE;
        }

        if ( *pbTokensChanged ) {
            if ( ! CopyFileA( pchTMerge, szTargetTokFile, FALSE) ) {
                remove( pchTTok);
                remove( pchTMerge);
                RLFREE( pchTMerge);

                QuitA( IDS_COPYFILE_FAILED, pchTMerge, szTargetTokFile);
            }
        }
        remove( pchTTok);
        remove( pchTMerge);

        RLFREE( pchTTok);
        RLFREE( pchTMerge);
    }
    //... now szTargetTokFile contains latest
    //... tokens form szImageFile
    //... Clean up if we made a temp .RES file
    if ( bExeFile ) {
        rc = remove( pchTRes);
        RLFREE( pchTRes);
    }
    return ( 0);
}



BOOL ResReadBytes(

                 FILE   *InFile,     //... File to read from
                 CHAR   *pBuf,       //... Buffer to write to
                 size_t  dwSize,     //... # bytes to read
                 DWORD  *plSize)     //... bytes-read counter (or NULL)
{
    size_t dwcRead = 0;


    dwcRead = fread( pBuf, 1, dwSize, InFile);

    if ( dwcRead == dwSize ) {
        if ( plSize ) {
            *plSize -= dwcRead;
        }
        return ( TRUE);
    }
    return ( FALSE);
}


int InsDlgToks( PCHAR szCurToks, PCHAR szDlgToks, WORD wFilter)
{
    CHAR szMrgToks[MAXFILENAME];

    FILE * fCurToks = NULL;
    FILE * fDlgToks = NULL;
    FILE * fMrgToks = NULL;
    TOKEN Tok1, Tok2;

    MyGetTempFileName(0,"TOK",0,szMrgToks);

    fMrgToks = FOPEN(szMrgToks, "w");
    fCurToks = FOPEN(szCurToks, "r");
    fDlgToks = FOPEN(szDlgToks, "r");

    if (! (fMrgToks && fCurToks && fDlgToks)) {
        return -1;
    }

    while (!GetToken(fCurToks, &Tok1)) {
        if (Tok1.wType != wFilter) {
            PutToken(fMrgToks, &Tok1);
            RLFREE(Tok1.szText);
            continue;
        }

        Tok2.wType  = Tok1.wType;
        Tok2.wName  = Tok1.wName;
        Tok2.wID    = Tok1.wID;
        Tok2.wFlag  = Tok1.wFlag;
        Tok2.wLangID    = Tok1.wLangID;
        Tok2.wReserved  =  0 ;
        lstrcpy( Tok2.szType, Tok1.szType);
        lstrcpy( Tok2.szName, Tok1.szName);
        Tok2.szText = NULL;

        if (FindToken(fDlgToks, &Tok2, 0)) {
            Tok2.wReserved  =  Tok1.wReserved ;
            PutToken(fMrgToks, &Tok2);
            RLFREE(Tok2.szText);
        } else {
            PutToken(fMrgToks, &Tok1);
        }
        RLFREE(Tok1.szText);
    }
    FCLOSE (fMrgToks);
    FCLOSE (fCurToks);

    if ( ! CopyFileA( szMrgToks, szCurToks, FALSE) ) {
        remove( szDlgToks);
        remove( szMrgToks);
        QuitA( IDS_COPYFILE_FAILED, szMrgToks, szCurToks);
    }
    remove(szMrgToks);

    return 1;
}


//+-----------------------------------------------------------------------
//
// MergeTokFiles
//
// Returns: TRUE if a token changed, was added, or was deleted else FALSE
//
// History:
//      7-22-92     stevebl     added return value
//      9-8-92      terryru     changed order of translation/delta tokens
//      01-25-93    MHotchin    Added changes to handle var length token
//                              text.
//------------------------------------------------------------------------

BOOL MergeTokFiles(

                  FILE *fNewTokFile,      //... Final product of the merge process
                  FILE *fCurTokFile,      //... The soon-to-be-old current token file
                  FILE *fTmpTokFile)      //... The token file generated from the updated .EXE
{
    TOKEN Tok1, Tok2;
    BOOL bChangesDetected = FALSE;  //... Set TRUE if any token changes found
    BOOL bChangedText     = FALSE;  //... TRUE if a token's text has changed
    WORD cTokenCount = 0;       //... Count of tokens in the new token file

                                //... Scan through the new token file.  For
                                //... every token in the new token file, find
                                //... the corresponding token in the current
                                //... token file. This process will make sure
                                //... tokens that are no longer in the .EXE
                                //... will not be in the final token file.


    while ( GetToken( fTmpTokFile, &Tok1) == 0 ) {
        ++cTokenCount;          //... Used in checking for deleted tokens
        bChangedText = FALSE;   //... assume the token did not change

                                //... Copy pertanent data to use in search
        Tok2.wType  = Tok1.wType;
        Tok2.wName  = Tok1.wName;
        Tok2.wID    = Tok1.wID;
        Tok2.wFlag  = Tok1.wFlag;
        Tok2.wLangID    = Tok1.wLangID;
        Tok2.wReserved  = 0;
        Tok2.szText = NULL;

        lstrcpy( Tok2.szType, Tok1.szType);
        lstrcpy( Tok2.szName, Tok1.szName);

        //... Now look for the corresponding token

        //If token is Version stamp and szTexts is "Translation",
        //it is 1.0 version format. So ignore it.
        IGNORETRANSLATION:

        if ( FindToken( fCurTokFile, &Tok2, 0) ) {
            if ( gbMaster && !(Tok2.wReserved & ST_READONLY) ) {
                if ( _tcscmp( (TCHAR *)Tok2.szText, (TCHAR *)Tok1.szText) ) {
                    //... Token text changed

                    //If the changes are only align info, translate it to the "unchanged" status.
                    int l1, r1, t1, b1, l2, r2, t2, b2;
                    TCHAR   a1[20], a2[20];

                    //Cordinates token?
                    if ( (Tok1.wType==ID_RT_DIALOG) && (Tok1.wFlag&ISCOR)
                         //Including align info?
                         && _stscanf(Tok1.szText,TEXT("%d %d %d %d %s"),
                                     &l1,&r1,&t1,&b1,a1) == 5
                         //Not including align info?
                         && _stscanf(Tok2.szText,TEXT("%d %d %d %d %s"),
                                     &l2,&r2,&t2,&b2,a2) == 4
                         //Cordinates are same?
                         && l1==l2 && r1==r2 && t1==t2 && b1==b2 ) {
                        Tok1.wReserved = 0;
                    } else {
                        //If token is Version stamp and szTexts is "Translation",
                        //it is 1.0 version format. So ignore it.
                        if ( Tok1.wType == ID_RT_VERSION
                             && !_tcscmp( Tok2.szText, TEXT("Translation")) ) {
                            if ( Tok2.szText != NULL ) {
                                RLFREE( Tok2.szText);
                            }
                            Tok2.szText = NULL;
                            Tok2.wFlag = 1;
                            goto IGNORETRANSLATION;
                        }
                        bChangedText = bChangesDetected = TRUE;

                        Tok1.wReserved = ST_CHANGED|ST_NEW;
                        Tok2.wReserved = ST_CHANGED;
                    }
                } else {
                    Tok1.wReserved = 0;
                }
            } else {
                Tok1.wReserved = Tok2.wReserved;
            }
        } else {
            //... Must be a new token (not in current token file)

            //If token is Version stump, and old mtk is 1.0 data file, convert it.
            if ( Tok1.wType==ID_RT_VERSION ) {
                Tok2.szText = NULL;
                Tok2.wFlag = 1;
                _tcscpy( Tok2.szName, TEXT("VALUE") );

                if ( FindToken( fCurTokFile, &Tok2, 0)
                     && ! lstrcmp( Tok1.szText, Tok2.szText) ) {
                    Tok1.wReserved = Tok2.wReserved;
                } else
                    Tok1.wReserved = ST_TRANSLATED | ST_DIRTY;
            } else {
                Tok1.wReserved = ST_TRANSLATED | ST_DIRTY;
            }
            bChangesDetected = TRUE;
        }

        //... Copy token from new token file to final token
        //... file.  If a change was detected, then copy the
        //... original token (from the "current" token file
        //... into the final token file.

        PutToken( fNewTokFile, &Tok1);
        RLFREE( Tok1.szText);

        if ( bChangedText ) {
            PutToken( fNewTokFile, &Tok2);
            // now delta tokens follow translation tokens
        }

        if ( Tok2.szText != NULL ) {
            RLFREE( Tok2.szText);
        }
    }

    if ( ! bChangesDetected ) {
        // We have to test to be sure that no tokens were deleted
        // since we know that none changed.

        rewind( fCurTokFile);

        //... Look for tokens that exist in the current
        //... token file that do not exist in the token
        //... file created from the updated .EXE.

        while ( GetToken( fCurTokFile, &Tok1) == 0 ) {
            --cTokenCount;
            RLFREE( Tok1.szText);
        }

        if ( cTokenCount != 0 ) {
            bChangesDetected = TRUE;
        }
    }
    return ( bChangesDetected);
}


void MakeNewExt(char *NewName, char *OldName, char *ext)
{

    char drive[_MAX_DRIVE];
    char dir[_MAX_DIR];
    char fname[_MAX_FNAME];  // dummy vars to hold file name info
    char dext[_MAX_EXT];


    // Split obj file name into filename and extention
    _splitpath(OldName, drive, dir, fname, dext);

    // Make new file name with new ext extention
    _makepath(NewName, drive, dir, fname, ext);
}


//......................................................................
//...
//... Check to see if the given file name *should* be an EXE
//...
//... Return: TRUE if it should, else FALSE.


static BOOL ShouldBeAnExe( PCHAR szFileName)
{
    PCHAR psz;


    if ( (psz = strrchr( szFileName, '.')) != NULL ) {
        if ( IsRes( szFileName) ) {
            return ( FALSE);
        } else if ( lstrcmpiA( psz, ".exe") == 0
                    || lstrcmpiA( psz, ".dll") == 0
                    || lstrcmpiA( psz, ".com") == 0
                    || lstrcmpiA( psz, ".scr") == 0
                    || lstrcmpiA( psz, ".cpl") == 0 ) {
            return ( TRUE);
        }
        //... Because we think this case of filename
        //... would be not executable file rather than res file.
        else if ( lstrcmpiA( psz, ".tmp") == 0 ) { //for tmp file created by Dlgedit
            return ( FALSE );
        } else {
            return ( TRUE );
        }
    }
    return ( FALSE);
}

//.........................................................
//...
//... If the named file exists and is not empty, return FALSE, else TRUE.

static BOOL NotExistsOrIsEmpty( PCHAR pszFileName)
{
    BOOL fRC = TRUE;
    int  hFile = -1;

    //... Does file not exist?

    if ( _access( pszFileName, 0) == 0 ) {
        //... No, file exists.  Open it.

        if ( (hFile = _open( pszFileName, _O_RDONLY)) != -1 ) {
            //... Is it Empty?

            if ( _filelength( hFile) == 0L ) {
                fRC = TRUE;     //... Yes, file is empty.
            } else {
                fRC = FALSE;    //... No, file is not empty.
            }
            _close( hFile);
        } else {
            QuitA( IDS_ENGERR_01, "non-empty", pszFileName);
        }
    } else {
        fRC = TRUE;             //... Yes, file does not exist.
    }
    return ( fRC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\reswin16.h ===
int ExtractResFromExe16A( CHAR *szInputExe,
                          CHAR *szOutputRes,
                          WORD   wFilter);

int BuildExeFromRes16A( CHAR *szTargetExe,
                        CHAR *szSourceRes,
                        CHAR *szSourceExe);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\restok.h ===
#ifndef _RESTOK_H_
#define _RESTOK_H_

#include "tokenapi.h"
#include "rlmsgtbl.h"
#include "toklist.h"

/*--------------------------------------------------------------------------*/
/*  General Purpose Defines             */
/*--------------------------------------------------------------------------*/

#define SUCCESS     0

#define FALSE       0
#define TRUE        1

#define  BYTELN     8
#define  WORDLN     16

#define  NOTEXE     0
#define  WIN16EXE   1
#define  NTEXE      2
#define  UNKNOWNEXE 10
#define  DHWSIZE  4096  //... # Bytes in szDHW global buffer

#ifdef RLRES16
#define  IDFLAG     0xFF
#define  HIBITVALUE 0x80
#else
#define  IDFLAG     0xFFFF
#define  HIBITVALUE 0x8000
#endif

#ifdef D262
#define STRINGSIZE( x ) ((x) * sizeof( TCHAR))
#else
#define STRINGSIZE( x ) ((x) * sizeof(CHAR))
#endif

#define MEMSIZE( x ) ((x) * sizeof( TCHAR))

        //... How many chars will fit in a buffer? (
#define WCHARSIN( x) ((x) / sizeof( WCHAR))
#define ACHARSIN( x) (x)

#ifdef UNICODE
#define TCHARSIN( x) WCHARSIN( x)
#else
#define TCHARSIN( x) ACHARSIN( x)
#endif

// String Resource IDs  (see rlquiked.h, rledit.h, rladmin.h)
#define IDS_READONLY        11
#define IDS_CLEAN           12
#define IDS_DIRTY           13
#define IDS_RESOURCENAMES   15// IDs 16-31 are reserved for resource names

// Resource types ID

#define ID_RT_CURSOR        1
#define ID_RT_BITMAP        2
#define ID_RT_ICON          3
#define ID_RT_MENU          4
#define ID_RT_DIALOG        5
#define ID_RT_STRING        6
#define ID_RT_FONTDIR       7
#define ID_RT_FONT          8
#define ID_RT_ACCELERATORS  9
#define ID_RT_RCDATA       10
#define ID_RT_ERRTABLE     11
#define ID_RT_GROUP_CURSOR 12
#define ID_RT_GROUP_ICON   14
#define ID_RT_NAMETABLE    15
#define ID_RT_VERSION      16
#define ID_RT_DLGINIT     240

// Important MENU flags
#define POPUP       0x0010
#define ENDMENU     0x0080

#define MFR_POPUP   0x0001

#define MYREAD   1
#define MYWRITE  2

#ifndef NOMINMAX

#ifndef max
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

#endif  /* NOMINMAX */


#define AllocateName( ptr, buf) (ptr) = (TCHAR *)FALLOC( MEMSIZE( lstrlen( (buf)) + 1))

typedef struct _tagMast
{
    CHAR szSrc[  MAXFILENAME];              //... Source resource file
    CHAR szMtk[  MAXFILENAME];              //... Master token file
    CHAR szRdfs[ MAXFILENAME];              //... Cust Res Descr file name
    CHAR szSrcDate[           MAXFILENAME]; //... Date stamp of szSrc
    CHAR szMpjLastRealUpdate[ MAXFILENAME]; //... Date of last update
    WORD wLanguageID;                       //... Language ID for master project
    UINT uCodePage;                         //... CP used to create tok file
} MSTRDATA, * PMSTRDATA;

typedef struct _tagProj
{
    CHAR szPRJ[ MAXFILENAME];               //... This project's Project File name
    CHAR szMpj[ MAXFILENAME];               //... Master project file
    CHAR szTok[ MAXFILENAME];               //... Project token file
    CHAR szBld[ MAXFILENAME];               //... Resource file to be built
    CHAR szGlo[ MAXFILENAME];               //... Glosary file for this project
    CHAR szTokDate[ MAXFILENAME];           //... Date of last update
    UINT uCodePage;                         //... CP used to create tok file
    WORD wLanguageID;                       //... Language ID for this project
    BOOL fSourceEXE;
    BOOL fTargetEXE;
} PROJDATA, * PPROJDATA;


#pragma pack(1)

typedef struct ResHeader
{
#ifdef RLRES32
    DWORD   lHeaderSize;
    DWORD   lDataVersion;
    WORD    wLanguageId;
    DWORD   lVersion;
    DWORD   lCharacteristics;
#endif
    BOOL    bTypeFlag;      /* Indicat's if ID or string */
    BOOL    bNameFlag;      /* Indicat's if ID or string */
    WORD    wTypeID;
    WORD    wNameID;
    TCHAR   *pszType;
    TCHAR   *pszName;
    WORD    wMemoryFlags;
    DWORD   lSize;

} RESHEADER;

typedef struct ControlData
{
    WORD    x;
    WORD    y;
    WORD    cx;
    WORD    cy;
    DWORD   dwID;
    DWORD   lStyle;
    BOOL    bClass_Flag;    /* Indicat's if ID or string */
    WORD    bClass;
    TCHAR   *pszClass;
    BOOL    bID_Flag;       /* Indicat's if ID or string */
    WORD    wDlgTextID;
    TCHAR   *pszDlgText;
#ifdef RLRES16
    WORD    unDefined;
#else
    WORD    wExtraStuff;
    DWORD   lExtendedStyle;
#endif
#ifdef PDK2
    WORD    wUnKnow;
    DWORD   dwExtra;
#endif
    DWORD   dwHelpID;
    BYTE    *pExtraStuff;
} CONTROLDATA;

typedef struct DialogHeader
{
    DWORD   lStyle;
    WORD    wNumberOfItems;
    WORD    x;
    WORD    y;
    WORD    cx;
    WORD    cy;
    BOOL    bClassFlag;    /* Indicat's if ID or string */
    WORD    wDlgClassID;
    TCHAR   *pszDlgClass;
    BOOL    bMenuFlag;      /* Indicat's if ID or string */
    WORD    wDlgMenuID;
    TCHAR   *pszDlgMenu;
    TCHAR   *pszCaption;
    WORD    wPointSize;
    TCHAR   *pszFontName;
    CONTROLDATA *pCntlData;
#ifdef RLRES32
    DWORD   lExtendedStyle;
    BOOL    bNameFlag;
    WORD    wDlgNameID;
    TCHAR   *pszDlgName;
#endif
    WORD    wDlgVer;
    WORD    wSignature;
    DWORD   dwHelpID;
    short   wWeight;
    short   wItalic;
    BOOL    fDialogEx;

} DIALOGHEADER;


typedef struct MenuItem
{
    DWORD   dwType;
    DWORD   dwState;
    DWORD   dwMenuID;
    DWORD   dwHelpID;
    WORD    fItemFlags;
    TCHAR   *szItemText;
    struct  MenuItem *pNextItem;
} MENUITEM;

typedef struct MenuHeader
{
    WORD        wVersion;
    WORD        cbHeaderSize;
    MENUITEM    *pMenuItem;
    BOOL    fMenuEx;
    BYTE    *pExtraStuff;
} MENUHEADER;         

typedef struct StringHeader
{
	WORD   wChars[16];		    // # of characters in each string in this block
    TCHAR *pszStrings[16];      // Strings in this block
} STRINGHEADER;

// Version structures taken from ver.h and ver.dll code.

#ifndef RLRES32
#ifndef RLWIN32
typedef struct VS_FIXEDFILEINFO
{
    DWORD   dwSignature;    /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion; /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;    /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;    /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS; /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS; /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;    /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;    /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;       /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;     /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;  /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;   /* e.g. 0 */
    DWORD   dwFileDateLS;   /* e.g. 0 */
} VS_FIXEDFILEINFO;

#endif
#endif

typedef struct VERBLOCK
{
#ifdef RLRES32
    WORD  wLength;
    WORD  wValueLength;
    WORD  wType;
    WCHAR szKey[1];
#else
    int nTotLen;
    int nValLen;
    TCHAR szKey[1];
#endif
} VERBLOCK ;

typedef VERBLOCK * PVERBLOCK;



#define DWORDUP(x) (((x)+3)&~03)
#define DWORDUPOFFSET(x) (  (DWORDUP(x)) - (x) )


#define WORDUP(x) (((x)+1)&~01)
#define WORDUPOFFSET(x) (  (WORDUP(x)) - (x) )


typedef struct VERHEAD
{
    WORD wTotLen;
    WORD wValLen;
#ifdef RLRES32
    WORD wType;
#endif
    TCHAR szKey[( sizeof( TEXT("VS_VERSION_INFO" )) +3 )&~03];
    VS_FIXEDFILEINFO vsf;

} VERHEAD ;


typedef struct AccelTableEntry
{
    WORD fFlags;
    WORD wAscii;
    WORD wID;
#ifdef RLRES32
    WORD wPadding;
#endif
} ACCELTABLEENTRY;

typedef struct _tagDlgInitData
{
    struct _tagDlgInitData *pNext;
    WORD     wControlID;
    WORD     wMessageNumber;
    DWORD    dwStringLen;
    PCHAR    pszString;
} DLGINITDATA, * PDLGINITDATA;


#pragma pack()

// Menu item types

#define POPUP 0x0010

// function prototypes

DWORD             DWORDfpUP( FILE *, DWORD * );
void              ClearAccelTable ( ACCELTABLEENTRY * , WORD);
void              ClearMenu ( MENUHEADER * );
void              ClearDialog ( DIALOGHEADER * );
void              ClearResHeader ( RESHEADER );
void              ClearString ( STRINGHEADER * );
int               IsExe( char * );
int               IsRes( char * );
BOOL              IsWin32Res( CHAR *);
ACCELTABLEENTRY * GetAccelTable( FILE *, WORD *, DWORD * );
BYTE              GetByte ( FILE *, DWORD * );
void              GetBytes ( FILE *, DWORD * );
DWORD             GetdWord ( FILE *, DWORD * );
DIALOGHEADER    * GetDialog( FILE *, DWORD * );
void              GetName  ( FILE *, TCHAR *, DWORD * );
int               MyGetTempFileName(BYTE  , LPSTR, WORD, LPSTR);
WORD              GetWord  ( FILE *, DWORD * );
void              GetResMenu  ( FILE *, DWORD * , MENUHEADER *);
int               GenerateImageFile( char *, char *, char *, char *, WORD );
int               GenerateTokFile( char *, char *, BOOL *, WORD);
void              GenStatusLine( TOKEN * );
int               GetResHeader( FILE *, RESHEADER UNALIGNED *, DWORD *);
STRINGHEADER    * GetString( FILE *, DWORD * );
BOOL              isdup ( WORD, WORD *, WORD );
FILE            * OpenGlossary( CHAR *, CHAR);
int               MakeGlossIndex( long *);
int               TransString( TCHAR *, TCHAR *, TRANSLIST **, LONG *);
void              AddTranslation( TCHAR *szKey,
                                  TCHAR *szTranslation,
                                  LONG *lFilePointer);
void              ParseTokCrd( TCHAR *, 
                               WORD UNALIGNED *, 
                               WORD UNALIGNED *, 
                               WORD UNALIGNED *, 
                               WORD UNALIGNED * );
void              ParseTok( TCHAR *, TOKEN * );
void              PutAccelTable( FILE *,
                                 FILE *,
                                 RESHEADER,
                                 ACCELTABLEENTRY *,
                                 WORD );
void              PutByte ( FILE *, TCHAR, DWORD * );
void              PutDialog( FILE * , FILE *, RESHEADER , DIALOGHEADER *);
void              PutMenu( FILE * , FILE *, RESHEADER , MENUHEADER *);
void              PutMenuItem( FILE * , MENUITEM *, DWORD *, BOOL);
void              PutMenuRes( FILE * , MENUITEM *, DWORD *);
void              PutOrd( FILE *, WORD , TCHAR * , DWORD *);
int               PutResHeader( FILE *, RESHEADER , fpos_t * , DWORD * );
void              PutWord ( FILE *, WORD, DWORD * );
void              PutString ( FILE *, TCHAR *, DWORD * );
void              PutStrHdr ( FILE *, FILE *, RESHEADER, STRINGHEADER *);
void              PutdWord( FILE *, DWORD  , DWORD * );
BOOL              MergeTokFiles( FILE *, FILE *, FILE * );
void              DoExit( int nErrCode);
void              QuitA( int, LPSTR, LPSTR);

#ifdef UNICODE

void              QuitW( int, LPWSTR, LPWSTR);

#define QuitT QuitW

#else  // UNICODE

#define QuitT QuitA

#endif // UNICODE

void              GenerateRESfromRESandTOKandRDFs(CHAR * szTargetRES,
                                                  CHAR * szSourceRES,
                                                  CHAR * szTOK,
                                                  CHAR * szRDFs,
                                                  WORD wFilter);
void              SkipBytes( FILE *, DWORD * );
WORD              ReadHeaderField( FILE * , DWORD * );
void              ReadInRes( FILE *, FILE *, DWORD *);
BOOL              ResReadBytes( FILE *, char *, size_t, DWORD *);
int               ReadWinRes( FILE *, FILE *, FILE *, BOOL, BOOL, WORD );
void              ShowEngineErr( int, void *, void *);
void              TokAccelTable ( FILE *, RESHEADER, ACCELTABLEENTRY *, WORD);
void              TokDialog( FILE *, RESHEADER, DIALOGHEADER  *);
void              TokMenu( FILE *, RESHEADER, MENUHEADER * );
void              TokString( FILE *, RESHEADER, STRINGHEADER * );
WORD              UpdateResSize( FILE *, fpos_t *, DWORD );
void              UnGetByte( FILE *, BYTE, DWORD * );
void              UnGetWord( FILE *, WORD, DWORD * );
void              WordUpFilePointer( FILE *, BOOL, LONG, LONG, LONG *);
void              DWordUpFilePointer( FILE *, BOOL, LONG, DWORD *);

#ifdef RLRES32

WORD              GetResVer( FILE *, DWORD *, VERHEAD *, VERBLOCK **);
int       TokResVer( FILE *, RESHEADER, VERBLOCK *, WORD);
DWORD             FixCheckSum( LPSTR);

#else

int       GetResVer( FILE *, DWORD *, VERHEAD *, VERBLOCK **);
int       TokResVer( FILE *, RESHEADER, VERBLOCK *);

#endif

int       PutResVer( FILE *, FILE * , RESHEADER, VERHEAD *, VERBLOCK *);

PDLGINITDATA  GetDlgInit( FILE *, DWORD *);
void          TokDlgInit( FILE *, RESHEADER, PDLGINITDATA);
void          PutDlgInit( FILE *, FILE *, RESHEADER, PDLGINITDATA);
void          ClearDlgInitData( PDLGINITDATA);

#endif // _RESTOK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\restok.c ===
//#include <assert.h>
#include <ctype.h>
#include <malloc.h>
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
//#include <string.h>

#include <tchar.h>

#ifdef RLDOS
    #include "dosdefs.h"

#else
    #include <windows.h>
    #include "windefs.h"
#endif

#include "restok.h"
#include "custres.h"
#include "ntmsgtbl.h"
#include "rlmsgtbl.h"
#include "resread.h"
#include "projdata.h"

//B_FormatMessage prototype
#include "showerrs.h"

#define SAME  0     //... Used in string comparisons

#define STRINGFILEINFO (TEXT("StringFileInfo"))
#define VARFILEINFO    (TEXT("VarFileInfo"))
#define TRANSLATION    (TEXT("Translation"))
#define LANGUAGEINFO   (TEXT("Language Info"))

#define STRINGFILEINFOLEN  (lstrlen( (TCHAR *)STRINGFILEINFO) + 1)
#define VARFILEINFOLEN     (lstrlen( (TCHAR *)VARFILEINFO) + 1)
#define TRANSLATIONLEN     (lstrlen( (TCHAR *)TRANSLATION) + 1)

#define LANGSTRINGLEN  8    //... # WCHARs in string denoting language
//... and code page in a Version resource.

#define TRANSDATALEN   2    //... # bytes in a Translation value

#define VERTYPEBINARY  0    //... Version data value is binary
#define VERTYPESTRING  1    //... Version data value is a string
#define VERMEM      2048    //... Fixed size of buffer for new version stamp

//... Decrement WORD at *pw by given amount w
#define DECWORDBY( pw,w) if (pw) { *(pw) = (*(pw) > (w)) ? *(pw) - (w) : 0;}

//... Increment WORD at *pw by given amount w
#define INCWORDBY( pw,w) if (pw) { *(pw) += (w);}

//... How many BYTES in the given string?
#define BYTESINSTRING(s) (lstrlen( (TCHAR *)s) * sizeof( TCHAR))

//... Dialog box controls (from RC.H)
#define BUTTON  0x80
#define EDIT    0x81
#define STATIC  0x82



PVERBLOCK MoveAlongVer( PVERBLOCK, WORD *, WORD *, WORD *);
BOOL      FilterRes( WORD, RESHEADER *);
TCHAR    *GetVerValue( PVERBLOCK);
void      PutNameOrd( FILE *, BOOL, WORD , TCHAR *, DWORD *);
void      GetNameOrd( FILE *,
                      BOOL UNALIGNED*,
                      WORD UNALIGNED*,
                      TCHAR *UNALIGNED*,
                      DWORD *);
void  CopyRes( FILE      *fpInResFile,
               FILE      *fpOutResFile,
               RESHEADER *pResHeader,
               fpos_t    *pResSizePos);

BOOL fInThirdPartyEditer = FALSE;//.. Are we in a 3rd-party resource editor?
BOOL fInQuikEd   = FALSE;       //... Are we in RLQuiked? (see rlquiked.c)
BOOL gfShowClass = FALSE;       //... Set TRUE to put dlg box elemnt class
                                //... in token file
#if defined(DBCS)
BOOL gfExtendedTok = TRUE;     //... Set TRUE if -x is choosen
#else
BOOL gfExtendedTok = FALSE;     //... Set TRUE if -x is choosen
#endif

#ifdef _DEBUG
extern PMEMLIST pMemList;
#endif

#ifdef RLRES32
    #ifndef CAIRO
extern VOID *pResMsgData;       // NT-specific Message Table resource
    #endif //RLRES32
#endif //CAIRO
extern BOOL  gbMaster;          //... TRUE if we are working on a Master Project
extern BOOL  gfReplace;         //... FALSE if appending new language to existing resources
extern BOOL  gbShowWarnings;    //... Display warnining messages if TRUE
extern UCHAR szDHW[];

extern char * gszTmpPrefix;

MSTRDATA gMstr =                //... Data from Master Project file (MPJ)
{                               //... Fields filled in main (UI)
    "",
    "",
    "",
    "",
    "",
    MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US),
    CP_ACP                      //... System default Windows code page
};

PROJDATA gProj =                //... Data from Project file (PRJ)
{                               //... Fields filled in main (UI)
    "",
    "",
    "",
    "",
    "",
    "",
    CP_ACP,     //... System default Windows code page
    MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US),
    FALSE,
    FALSE
};


/**
  * Function: ReadWinRes
  *
  * The main resource Read/Writer function to process  the resource file to be
  * localzied.
  *
  * ReadWinRes reads the resource header to determine the current resource type,
  * then executes the corresponding Get/Put resource functions to extract and
  * insert localized information contained in the resource file.  ReadWinRes, is
  * excuted in two modes, Tokenize, and Generate. During Tokenize mode,
  * ReadWinRes writes all the localized information contained in the resouce to
  * a token file.  During Generate mode, ReadWinRes, replaces all the localized
  * information in the input resource file, with the corresponding information
  * in the token file to gernerate a localized resource file.
  *
  * Currently the following resouce types are supported.
  *
  *     Version Stamping.
  *     Menus.
  *     Dialogs.
  *     Accelerators.
  *     String Tables.
  *     Version Stamps
  *     Message Tables (NT)
  *
  * Arguments:
  *
  * InResFile,  Handle to binary input resource file.
  * OutFesFile, Handle to binary output resouce file. Not used during tokenize
  *             mode.
  * TokFile,    Handle to  text token file.
  * BOOL,       flag to indicate whether to build output resource file.
  * BOOL,       flag to indicate whether to build token file.
  *
  *
  *  Returns:
  * ???
  *
  *  Errors Codes:
  * ???
  *
  *  History:
  * 10/91  Added Version stamping support.                          TerryRu
  * 11/91, Completed Version stamping support.                      TerryRu
  *
  *
  **/


int ReadWinRes(

              FILE *InResFile,
              FILE *OutResFile,
              FILE *TokFile,
              BOOL  fBuildRes,
              BOOL  fBuildTok,
              WORD  wFilter)
{
    BOOL             fDoAccel = TRUE;   // set FALSE to not build accelerators
    MENUHEADER      *pMenuHdr = NULL;   // Linked list of Menu info.
    static RESHEADER ResHeader;         // Structure contain Resource Header info.
    VERBLOCK        *pVerBlk = NULL;    // Memory block containing Version Stamping String File Block,
    static VERHEAD   VerHdr;            // Memory block containing Version Stamping Header info
    DIALOGHEADER    *pDialogHdr = NULL; // Linked list of Dialog info
    STRINGHEADER    *pStrHdr = NULL;    // Array of String Tables.
    ACCELTABLEENTRY *pAccelTable = NULL;// Array of Accelerator Keys
    WORD            wcTableEntries = 0; // Number of Accelerator tables
    fpos_t          ResSizePos = 0;     // Position of lSize field in the
                                        //   Resource Header, used to fixup
                                        //   the Header once the size of the
                                        //   localized information is determined.
    CUSTOM_RESOURCE *pCustomResource = NULL;
    LONG            lEndOffset = 0L;


    //... How large is the res file?
    fseek( InResFile, 0L, SEEK_END);
    lEndOffset = ftell( InResFile);

    rewind( InResFile);

    //... process until end of input file

    while ( ! feof( InResFile) ) {
        LONG lCurrOffset = 0L;


        lCurrOffset = (LONG)ftell( InResFile);

        if ( (lCurrOffset + (LONG)sizeof( RESHEADER)) >= lEndOffset ) {
            return 0;
        }

        if ( GetResHeader( InResFile, &ResHeader, (DWORD *) NULL) == -1 ) {
            return (1);
        }
        //... Is this the dummy, res32-identifying, res?

        if ( ResHeader.lSize == 0L ) {                       //... Yes, we so simply copy the header if we
                                                             //... are building a res file.
            if ( fBuildRes ) {
                CopyRes( InResFile, OutResFile, &ResHeader, &ResSizePos);
            }

#ifdef RLRES32

            else {
                if ( gbShowWarnings && OutResFile && ftell( OutResFile) != 0L ) {
                    lstrcpyA( szDHW, "type");

                    if ( ResHeader.wTypeID == IDFLAG ) {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " \"%s\"",
                                 ResHeader.pszType);
                    } else {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " %hu,",
                                 ResHeader.wTypeID);
                    }
                    strcat( szDHW, " name");

                    if ( ResHeader.wNameID == IDFLAG ) {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " \"%s\"",
                                 ResHeader.pszName);
                    } else {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " %hu,",
                                 ResHeader.wNameID);
                    }
                    sprintf( &szDHW[ lstrlenA( szDHW)],
                             " pri-lang %#hx sub-lang %#hx",
                             PRIMARYLANGID( ResHeader.wLanguageId),
                             SUBLANGID( ResHeader.wLanguageId));

                    ShowEngineErr( IDS_ZERO_LEN_RES, szDHW, NULL);
                }
                DWordUpFilePointer( InResFile, MYREAD, ftell( InResFile), NULL);

                if (OutResFile != NULL) {
                    DWordUpFilePointer( OutResFile,
                                        MYWRITE,
                                        ftell(OutResFile),
                                        NULL);
                }
            }
#endif
            ClearResHeader( ResHeader);
            continue;           //... Ship this dummy header
        }
        //... Check to see if we want to filter out this
        //... resource type.

        if ( FilterRes( wFilter, &ResHeader) ) {
            //... skip this resource type

            SkipBytes( InResFile, (DWORD *)&ResHeader.lSize);

#ifdef RLRES32

            DWordUpFilePointer( InResFile, MYREAD, ftell( InResFile), NULL);

#endif
            ClearResHeader( ResHeader);
            continue;
        }

        if ( fBuildTok ) {
            if ( ResHeader.wLanguageId != (fInThirdPartyEditer
                                           ? gProj.wLanguageID
                                           : gMstr.wLanguageID) ) {
                //... Skip this resource (wrong lanugage)

                if ( gbShowWarnings ) {
                    lstrcpyA( szDHW, "type");

                    if ( ResHeader.wTypeID == IDFLAG ) {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " \"%s\"",
                                 ResHeader.pszType);
                    } else {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " %u,",
                                 ResHeader.wTypeID);
                    }
                    strcat( szDHW, " name");

                    if ( ResHeader.wNameID == IDFLAG ) {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " \"%s\"",
                                 ResHeader.pszName);
                    } else {
                        sprintf( &szDHW[ lstrlenA( szDHW)],
                                 " %u,",
                                 ResHeader.wNameID);
                    }
                    sprintf( &szDHW[ lstrlenA( szDHW)],
                             " pri-lang %#x sub-lang %#x",
                             PRIMARYLANGID( ResHeader.wLanguageId),
                             SUBLANGID( ResHeader.wLanguageId));

                    ShowEngineErr( IDS_SKIP_RES,
                                   LongToPtr(ResHeader.lSize),
                                   szDHW);
                }
                SkipBytes( InResFile, (DWORD *)&ResHeader.lSize);

#ifdef RLRES32

                DWordUpFilePointer( InResFile, MYREAD, ftell(InResFile), NULL);

#endif
                ClearResHeader( ResHeader);
                continue;
            }
        } else if ( fBuildRes ) {
            if ( gfReplace ) {
                if ( ResHeader.wLanguageId == gMstr.wLanguageID ) {
                    ResHeader.wLanguageId = gProj.wLanguageID;
                } else {
                    //... Copy this resource

                    CopyRes( InResFile, OutResFile, &ResHeader, &ResSizePos);
                    ClearResHeader( ResHeader);
                    continue;
                }
            } else {    //... ! gfReplace
                if ( ResHeader.wLanguageId == gMstr.wLanguageID ) {
                    fpos_t lFilePos = 0L;
                    DWORD  lTmpSize = 0L;

                    lFilePos = ftell( InResFile);   //... Save file position
                    lTmpSize = ResHeader.lSize;     //... and resource size

                    //... Duplicate this resource

                    CopyRes( InResFile, OutResFile, &ResHeader, &ResSizePos);
                    fseek( InResFile, (long)lFilePos, SEEK_SET);
                    ResHeader.wLanguageId = gProj.wLanguageID;
                    ResHeader.lSize       = lTmpSize;
                } else {
                    //... Simply copy this resource if not target language

                    if ( ResHeader.wLanguageId == gProj.wLanguageID ) {
                        SkipBytes( InResFile, (DWORD *)&ResHeader.lSize);

#ifdef RLRES32
                        DWordUpFilePointer( InResFile, MYREAD, ftell( InResFile), NULL);
#endif
                    } else {
                        CopyRes( InResFile, OutResFile, &ResHeader, &ResSizePos);
                    }
                    ClearResHeader( ResHeader);
                    continue;
                }
            }
        }

        switch ( ResHeader.wTypeID ) {
            case ID_RT_ACCELERATORS:

                pAccelTable = GetAccelTable(InResFile,
                                            &wcTableEntries,
                                            (DWORD *)&ResHeader.lSize);
                if (fBuildTok) {
                    TokAccelTable(TokFile,
                                  ResHeader,
                                  pAccelTable,
                                  wcTableEntries);
                }

                if (fBuildRes) {
                    PutAccelTable(OutResFile,
                                  TokFile,
                                  ResHeader,
                                  pAccelTable,
                                  wcTableEntries);
                }

                ClearAccelTable (pAccelTable , wcTableEntries);
                break;

            case ID_RT_DIALOG:

                pDialogHdr = GetDialog(InResFile, (DWORD *)&ResHeader.lSize);

                if (fBuildTok == TRUE) {
                    TokDialog(TokFile, ResHeader, pDialogHdr);
                }

                if (fBuildRes == TRUE) {
                    PutDialog(OutResFile, TokFile, ResHeader, pDialogHdr);
                }
                ClearDialog (pDialogHdr);

                break;

            case ID_RT_DLGINIT:
                {
                    PDLGINITDATA pDlgInit = GetDlgInit( InResFile, (DWORD *)&ResHeader.lSize);

                    if ( fBuildTok ) {
                        TokDlgInit( TokFile, ResHeader, pDlgInit);
                    }

                    if ( fBuildRes ) {
                        PutDlgInit( OutResFile, TokFile, ResHeader, pDlgInit);
                    }
                    ClearDlgInitData( pDlgInit);
                    break;
                }
            case ID_RT_MENU:
                // allocate space for a new header

                pMenuHdr = (MENUHEADER *)FALLOC( sizeof( MENUHEADER));
                GetResMenu(InResFile, (DWORD *)&ResHeader.lSize, pMenuHdr);

                if (fBuildTok == TRUE) {
                    TokMenu(TokFile, ResHeader, pMenuHdr);
                }

                if (fBuildRes == TRUE) {
                    PutMenu(OutResFile, TokFile, ResHeader, pMenuHdr);
                }

                ClearMenu(pMenuHdr);

                break;

            case ID_RT_STRING:

                pStrHdr = GetString(InResFile, (DWORD *)&ResHeader.lSize);

                if (fBuildTok == TRUE) {
                    TokString(TokFile, ResHeader, pStrHdr);
                }

                if (fBuildRes == TRUE) {
                    PutStrHdr(OutResFile, TokFile, ResHeader, pStrHdr);
                }

                ClearString(pStrHdr);

                break;

#ifdef RLRES32
    #ifndef CAIRO
                // we currently only do Error tables under NT,
                // under CAIRO we ignore them

            case ID_RT_ERRTABLE:    //... NT-specific Message Table resource

                pResMsgData = GetResMessage(InResFile, (DWORD *)&ResHeader.lSize);

                if (! pResMsgData) {
                    QuitT( IDS_ENGERR_13, (LPTSTR)IDS_MSGRESTBL, NULL);
                }

                if (fBuildTok == TRUE) {
                    TokResMessage(TokFile, ResHeader, pResMsgData);
                }

                if (fBuildRes == TRUE) {
                    PutResMessage(OutResFile, TokFile, ResHeader, pResMsgData);
                }

                ClearResMsg( &pResMsgData);

                break;
    #endif
#endif

#ifndef CAIRO

            case ID_RT_VERSION:
                {
                    WORD wRead = 0;


                    wRead = GetResVer(InResFile,
                                      (DWORD *)&ResHeader.lSize,
                                      &VerHdr,
                                      &pVerBlk);

    #ifdef RLRES32
                    if (wRead == (WORD)-1)
    #else
                    if (wRead == FALSE)
    #endif
                    {
                        QuitT( IDS_ENGERR_14, (LPTSTR)IDS_VERBLOCK, NULL);
                    }

                    // Building Tok file ?
                    // but only tokenize it if it contains a Version Block

                    if ( pVerBlk && fBuildTok == TRUE ) {
    #ifdef RLRES32
                        TokResVer( TokFile, ResHeader, pVerBlk, wRead);
    #else
                        TokResVer( TokFile, ResHeader, pVerBlk);
    #endif
                    }

                    // Building Res file ?

                    if ( fBuildRes == TRUE ) {
                        PutResVer( OutResFile, TokFile, ResHeader,&VerHdr, pVerBlk);
                    }
                    RLFREE( pVerBlk);
                }
                break;
#else
            case ID_RT_VERSION:
#endif

            case ID_RT_CURSOR:
            case ID_RT_BITMAP:
            case ID_RT_ICON:
            case ID_RT_FONTDIR:
            case ID_RT_FONT:
            case ID_RT_RCDATA:
#ifndef RLRES32
            case ID_RT_ERRTABLE:    //... NT-specific Message Table resourc
#endif
            case ID_RT_GROUP_CURSOR:
            case ID_RT_GROUP_ICON:
            case ID_RT_NAMETABLE:
            default:

                if (GetCustomResource(InResFile,
                                      (DWORD *)&ResHeader.lSize,
                                      &pCustomResource,
                                      ResHeader)) {
                    // Non localized resource type, skip or copy it

                    if (fBuildTok == TRUE) {
                        if ( gbShowWarnings
                             && ( ResHeader.wTypeID == ID_RT_RCDATA
                                  || ResHeader.wTypeID >  16) ) {
                            static CHAR szType[256];
                            static CHAR szName[256];

                            if ( ResHeader.bTypeFlag == IDFLAG )
                                sprintf( szType, "%u", ResHeader.wTypeID);
                            else {
                                _WCSTOMBS( &szType[1], ResHeader.pszType, sizeof( szType), (UINT)-1);
                                szType[0] = '\"';
                                szType[ lstrlenA( szType)] = '\"';
                            }

                            if ( ResHeader.bNameFlag == IDFLAG )
                                sprintf( szName, "%u", ResHeader.wNameID);
                            else {
                                _WCSTOMBS( &szName[1], ResHeader.pszName, sizeof( szName), (UINT)-1);
                                szName[0] = '\"';
                                szName[ lstrlenA( szName)] = '\"';
                            }
                            ShowEngineErr( IDS_UNK_CUST_RES, (void *)szType, (void *)szName);
                        }
                        SkipBytes(InResFile, (DWORD *)&ResHeader.lSize);
                    } else if ( fBuildRes ) {
                        CopyRes( InResFile, OutResFile, &ResHeader, &ResSizePos);
                    }
                } else {
                    if (fBuildTok == TRUE) {
                        TokCustomResource(TokFile, ResHeader, &pCustomResource);
                    }

                    if (fBuildRes == TRUE) {
                        PutCustomResource(OutResFile,
                                          TokFile,
                                          ResHeader,
                                          &pCustomResource);
                    }
                    ClearCustomResource(&pCustomResource);
                }

#ifdef RLRES32
                DWordUpFilePointer(InResFile, MYREAD, ftell(InResFile), NULL);

                if (OutResFile != NULL) {
                    DWordUpFilePointer(OutResFile,
                                       MYWRITE,
                                       ftell(OutResFile),
                                       NULL);
                }
#endif
                break;
        }   //... END SWITCH

#ifndef RLRES32
        // skip any extra bytes (Win 3.1 exes have
        // alot of extra stuff!).
        // No extra stuff in res extracted from NT exes

        SkipBytes(InResFile, (DWORD *)&ResHeader.lSize);
#endif

        ClearResHeader(ResHeader);

#ifdef RLRES32

        DWordUpFilePointer(InResFile, MYREAD, ftell(InResFile), NULL);

        if (OutResFile != NULL) {
            DWordUpFilePointer(OutResFile, MYWRITE, ftell(OutResFile), NULL);
        }
#endif

    }   // END while ( ! feof( InResFile)

    return 0;
}



/**
  *
  *
  *  Function:ClearAccelTable
  * Removes the accelerator table array from memory.
  *
  *  Arguments:
  * pAccelTable, pointer to arary of accelerators
  * wctablesEntries, number of accelerators in arrary
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, Implemented               Terryru
  *
  *
  **/

void ClearAccelTable(ACCELTABLEENTRY *pAccelTable, WORD wcTableEntries)
{
    RLFREE( pAccelTable);
}


/**
  *
  *
  *  Function: ClearDialog
  * Remove Dialog defintions from memory.
  *
  *  Arguments:
  * pDilaogHdr, Linked list of dialog information.
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, Implemented               TerryRu
  *
  *
  **/


void ClearDialog (DIALOGHEADER * pDialogHdr)
{
    BYTE i;

    for (i = 0; i < (BYTE) pDialogHdr->wNumberOfItems; i ++) {
        if (pDialogHdr->pCntlData[i].pszClass) {
            RLFREE( pDialogHdr->pCntlData[i].pszClass);
        }

        if ( pDialogHdr->pCntlData[i].pExtraStuff ) {
            RLFREE( pDialogHdr->pCntlData[i].pExtraStuff );
        }

        RLFREE( pDialogHdr->pCntlData[i].pszDlgText);
    }
    // now RLFREE fields in dialog header
    RLFREE( pDialogHdr->pszDlgClass);
    RLFREE( pDialogHdr->pszFontName);
    RLFREE( pDialogHdr->pszDlgMenu);
    RLFREE( pDialogHdr->pszCaption);
    RLFREE( pDialogHdr->pCntlData);

    // and finally clear header
    RLFREE( pDialogHdr);
}



/**
  *
  *
  *  Function: ClearMenu
  * Removes Menu defintions from memory.
  *
  *  Arguments:
  * pMenuHdr, linked list of Menu info
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, Implemented.              TerryRu
  *
  *
  **/

void ClearMenu(MENUHEADER *pMenuHdr)
{
    MENUITEM *pMenuItem;
    MENUITEM *pMenuHead;

    pMenuItem = pMenuHead = pMenuHdr->pMenuItem;

    // remove all the menu items from the list
    while (pMenuItem) {
        pMenuItem = pMenuHead->pNextItem;
        RLFREE( pMenuHead->szItemText);
        RLFREE( pMenuHead);
        pMenuHead = pMenuItem;
    }

    // now remove the menuheader
    if (pMenuHdr->pExtraStuff)
        RLFREE( pMenuHdr->pExtraStuff );

    RLFREE( pMenuHdr);
}



/**
  *
  *
  *  Function: ClearResHeader
  * Remove resheader name, and type fields from memory.
  *
  *  Arguments:
  * ResHdr, structure containing resheader info.
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, Implemented               TerryRu.
  *
  *
  **/

void ClearResHeader(RESHEADER ResHdr)
{
    RLFREE( ResHdr.pszType);
    RLFREE( ResHdr.pszName);
}




/**
  *
  *
  *  Function: ClearString
  * Removes the StringTable Defintions from memory.
  *
  *  Arguments:
  * pStrHdr, pointer to array of 16 string tables.
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, Implemented.              TerryRu
  *
  *
  **/

void ClearString( STRINGHEADER *pStrHdr)
{
    BYTE i;

    for (i = 0; i < 16; i++) {
        RLFREE( pStrHdr->pszStrings[i]);
    }
    RLFREE( pStrHdr);
}


/**
  *
  *
  *  Function: quit
  * quit, Error Handling routine used to display error code and terminate program
  *
  *  Arguments:
  * error, number of error.
  * pszError, descriptive error message.
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  *
  *
  *  History:
  * 7/91, Implemented                   TerryRu
  * 10/91, Hacked to work under windows         TerryRu
  * ??? Need to add better win/dos support
  *
  **/

void QuitA( int error, LPSTR pszArg1, LPSTR pszArg2)
{
    char  szErrStr1[2048] = "*?*";
    char  szErrStr2[2048] = "*?*";
    char *psz1 = pszArg1;
    char *psz2 = pszArg2;

    //... clean up after error and exit,
    //... returning error code
    _fcloseall();

    if ( pszArg1 != NULL && pszArg1 <= (LPSTR)0x0000ffff ) {

        B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                         | FORMAT_MESSAGE_IGNORE_INSERTS
                         | FORMAT_MESSAGE_FROM_HMODULE,
                         NULL,
                         (DWORD)(DWORD_PTR)pszArg1,
                         szErrStr1,
                         sizeof( szErrStr1),
                         NULL);
        psz1 = szErrStr1;
    }

    if ( pszArg2 != NULL && pszArg2 < (LPSTR)0x0000ffff ) {

        B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                         | FORMAT_MESSAGE_IGNORE_INSERTS
                         | FORMAT_MESSAGE_FROM_HMODULE,
                         NULL,
                         (DWORD)(DWORD_PTR)pszArg2,
                         szErrStr2,
                         sizeof( szErrStr2),
                         NULL);
        psz2 = szErrStr2;
    }
    ShowEngineErr( error, psz1, psz2);
    FreeLangList();

#ifdef _DEBUG
    FreeMemList( NULL);
#endif // _DEBUG

    DoExit( (error == 4) ? 0 : error);
}


#ifdef UNICODE

/* Handles errors, in UNICODE environments*/

LPSTR MakeMBMsgW(

                LPWSTR pszArg,      //... Msg ID# or msg text
                LPSTR  szBuf,       //... Buffer for converted msg
                USHORT usBufLen)    //... #bytes in szBuf
{
    char *pszRet = NULL;


    if ( pszArg ) {
        if ( pszArg >= (LPTSTR)0x0400 ) {
            _WCSTOMBS( szBuf,
                       (WCHAR *)pszArg,
                       usBufLen,
                       lstrlen( pszArg ) + 1 );
        } else {
            B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                             | FORMAT_MESSAGE_IGNORE_INSERTS
                             | FORMAT_MESSAGE_FROM_HMODULE,
                             NULL,
                             (DWORD)(DWORD_PTR)pszArg,
                             szBuf,
                             usBufLen,
                             NULL);
        }
        pszRet = szBuf;
    }
    return ( pszRet);
}

//...............................................................

void QuitW( int error, LPWSTR pszArg1, LPWSTR pszArg2)
{
    char  szErrStr1[2048] = "*?*";
    char  szErrStr2[2048] = "*?*";


    QuitA( error,
           MakeMBMsgW( pszArg1, szErrStr1, sizeof( szErrStr1)),
           MakeMBMsgW( pszArg2, szErrStr2, sizeof( szErrStr2)));
}


#endif



/**
  *
  *
  *  Function: GetAccelTable,
  * Reads the Accelerator key defintions from the resource file
  *
  *  Arguments:
  * InResFile, Handle to Resource file.
  * pwcTableEntries, pointer to an array of accelerator key defintions.
  * plSize, address of size of Resource.
  *
  *  Returns:
  * pwcTableEntries containing all the key defintions.
  *
  *  Errors Codes:
  *
  *  History:
  * 8/91    Implemented                 TerryRu
  * 4/92    Added RLRES32 support             TerryRu
  *
  *
  *
  **/

ACCELTABLEENTRY * GetAccelTable(FILE  *InResFile,
                                WORD  *pwcTableEntries,
                                DWORD *plSize)
{
    ACCELTABLEENTRY *pAccelTable;
    BOOL quit = FALSE;


    // need to use sizeof operator in memory
    // allocation because of structure packing.

    *pwcTableEntries = (WORD) 0;

    pAccelTable = (ACCELTABLEENTRY *) FALLOC( ((WORD)*plSize * sizeof( WORD)));

    while (*plSize && !quit) {

#ifdef RLRES32
        pAccelTable[ *pwcTableEntries].fFlags = (WORD) GetWord( InResFile,
                                                                plSize);
#else
        pAccelTable[ *pwcTableEntries].fFlags = (BYTE) GetByte( InResFile,
                                                                plSize);
#endif

        pAccelTable[*pwcTableEntries].wAscii = GetWord (InResFile, plSize);
        pAccelTable[*pwcTableEntries].wID = GetWord (InResFile, plSize);

#ifdef RLRES32
        pAccelTable[ *pwcTableEntries].wPadding =  GetWord( InResFile, plSize);
#endif

        if ( pAccelTable[ *pwcTableEntries].fFlags & HIBITVALUE ) {
            quit = TRUE;
        }
        ++*pwcTableEntries;
    }

    if ( (long)*plSize <= 0 ) {
        *plSize = 0;
    }
    return pAccelTable;
}



/**
  *
  *
  *  Function: GetDialog,
  * Reads the dialog defintions from the res file, and places the info
  * into a linked list.
  *
  *
  *  Arguments:
  * InResFile, Handle to input resource handle, posistioned to begining
  * of dialog defintion.
  * plSize, pointer to size in bytes of the dialog information.
  *
  *  Returns:
  * pointer to DIALOGHEADER type containing the dialog information,
  *
  *
  *  Errors Codes:
  * None ???
  *
  *  History:
  * 12/91, Cleaned up comments.             TerryRu
  * 04/92, Added RLRES32 support.             TerryRu
  *
  *
  **/

DIALOGHEADER *GetDialog( FILE *InResFile, DWORD * plSize)
{
    DIALOGHEADER  *pDialogHdr;
    TCHAR   *UNALIGNED*ptr;
    WORD    i;
    LONG    lStartingOffset;
    static TCHAR szBuf[ 255];
    LONG    lExtra;
    WORD    j;



    lStartingOffset = ftell(InResFile);

    pDialogHdr = (DIALOGHEADER *)FALLOC( sizeof( DIALOGHEADER));

    // lstyle
    pDialogHdr->lStyle = GetdWord(InResFile, plSize);

#ifdef RLRES32
    pDialogHdr->fDialogEx = (HIWORD(pDialogHdr->lStyle)==0xffff);

    if (pDialogHdr->fDialogEx) {
        pDialogHdr->wDlgVer        = LOWORD(pDialogHdr->lStyle);
        pDialogHdr->wSignature     = HIWORD(pDialogHdr->lStyle);
        pDialogHdr->dwHelpID       = GetdWord(InResFile, plSize);
        pDialogHdr->lExtendedStyle = GetdWord(InResFile, plSize);
        pDialogHdr->lStyle         = GetdWord(InResFile, plSize);
    } else {
        pDialogHdr->lExtendedStyle = GetdWord(InResFile, plSize);
    }

    pDialogHdr->wNumberOfItems = GetWord(InResFile, plSize);
#else
    pDialogHdr->wNumberOfItems = (BYTE) GetByte(InResFile, plSize);
#endif

    // allocate space to hold wNumberOfItems of pointers
    // to Control Data structures
    pDialogHdr->pCntlData = (CONTROLDATA *)
                            FALLOC( pDialogHdr->wNumberOfItems * sizeof( CONTROLDATA));


    // read x, y, cx, cy dialog cordinates
    pDialogHdr->x  = GetWord(InResFile, plSize);
    pDialogHdr->y  = GetWord(InResFile, plSize);
    pDialogHdr->cx = GetWord(InResFile, plSize);
    pDialogHdr->cy = GetWord(InResFile, plSize);

    //... Dialog Menu Name
    GetNameOrd( InResFile,
                (BOOL UNALIGNED *)&pDialogHdr->bMenuFlag,     // 9/11/91 (PW)
                (WORD UNALIGNED *)&pDialogHdr->wDlgMenuID,
                (TCHAR *UNALIGNED*)&pDialogHdr->pszDlgMenu,
                plSize);

    //... Dialog Class Name
    GetNameOrd( InResFile,
                (BOOL UNALIGNED *)&pDialogHdr->bClassFlag,     // 9/11/91 (PW)
                (WORD UNALIGNED *)&pDialogHdr->wDlgClassID,
                (TCHAR *UNALIGNED*)&pDialogHdr->pszDlgClass,
                plSize);

    // Dialog caption name
    GetName( InResFile, szBuf, plSize);
    ptr =  (TCHAR *UNALIGNED*)&pDialogHdr->pszCaption;
    AllocateName( *ptr, szBuf);
    lstrcpy( (TCHAR *)*ptr, (TCHAR *)szBuf);

    // does dialog define a font.

    if ( pDialogHdr->lStyle & DS_SETFONT ) {
        // extract this info.
        pDialogHdr->wPointSize = GetWord( InResFile, plSize);
        if (pDialogHdr->fDialogEx) {
            pDialogHdr->wWeight = GetWord( InResFile, plSize);
            pDialogHdr->wItalic = GetWord( InResFile, plSize);
        }
        GetName( InResFile, szBuf, plSize);
        ptr =  (TCHAR *UNALIGNED*)&pDialogHdr->pszFontName;
        AllocateName(*ptr, szBuf);

        lstrcpy( (TCHAR *)*ptr, (TCHAR *)szBuf);

    } else {
        pDialogHdr->pszFontName = (TCHAR*)FALLOC( 0);
    }

#ifdef RLRES32

    DWordUpFilePointer( InResFile, MYREAD, ftell(InResFile), plSize);

#endif

    //... read each dialog control

    for (i = 0; i < pDialogHdr->wNumberOfItems ; i++) {

#ifdef RLRES32

        if (pDialogHdr->fDialogEx) {
            pDialogHdr->pCntlData[i].dwHelpID = GetdWord(InResFile, plSize);
            pDialogHdr->pCntlData[i].lExtendedStyle = GetdWord(InResFile, plSize);
            pDialogHdr->pCntlData[i].lStyle = GetdWord(InResFile, plSize);
        } else {
            pDialogHdr->pCntlData[i].lStyle = GetdWord(InResFile, plSize);
            pDialogHdr->pCntlData[i].lExtendedStyle = GetdWord(InResFile, plSize);
        }

#endif // RLRES32

        pDialogHdr->pCntlData[i].x = GetWord(InResFile, plSize);
        pDialogHdr->pCntlData[i].y = GetWord(InResFile, plSize);
        pDialogHdr->pCntlData[i].cx = GetWord(InResFile, plSize);
        pDialogHdr->pCntlData[i].cy = GetWord(InResFile, plSize);

        // wId
        if (pDialogHdr->fDialogEx)
            pDialogHdr->pCntlData[i].dwID = GetdWord (InResFile, plSize);
        else
            pDialogHdr->pCntlData[i].dwID = (DWORD)GetWord (InResFile, plSize);

#ifdef RLRES16
        // lStyle
        pDialogHdr->pCntlData[i].lStyle = GetdWord(InResFile, plSize);


        pDialogHdr->pCntlData[i].bClass = (BYTE) GetByte(InResFile, plSize);

        // does dialog have a class?
        if (!(pDialogHdr->pCntlData[i].bClass & 0x80)) {
            GetName(InResFile, szBuf, plSize);
            ptr =  &pDialogHdr->pCntlData[i].pszClass;
            AllocateName(*ptr, szBuf);
            lstrcpy ((TCHAR *)*ptr, (TCHAR *)szBuf);
        } else {
            pDialogHdr->pCntlData[i].pszClass = NULL;
        }

#else
        GetNameOrd (InResFile,
                    (BOOL UNALIGNED *)&pDialogHdr->pCntlData[i].bClass_Flag,  // 9/11/91 (PW)
                    (WORD UNALIGNED *)&pDialogHdr->pCntlData[i].bClass,
                    (TCHAR *UNALIGNED*)&pDialogHdr->pCntlData[i].pszClass,
                    plSize);

#endif
        GetNameOrd (InResFile,
                    (BOOL UNALIGNED *)&pDialogHdr->pCntlData[i].bID_Flag, // 9/11/91 (PW)
                    (WORD UNALIGNED *)&pDialogHdr->pCntlData[i].wDlgTextID,
                    (TCHAR *UNALIGNED*)&pDialogHdr->pCntlData[i].pszDlgText,
                    plSize);

#ifdef RLRES16
        pDialogHdr->pCntlData[i].unDefined = (BYTE) GetByte(InResFile, plSize);

#else
        pDialogHdr->pCntlData[i].wExtraStuff = (WORD) GetWord(InResFile, plSize);
        if (pDialogHdr->fDialogEx && pDialogHdr->pCntlData[i].wExtraStuff) {
            lExtra = pDialogHdr->pCntlData[i].wExtraStuff;
            j = 0;
            pDialogHdr->pCntlData[i].pExtraStuff = (BYTE *)FALLOC( pDialogHdr->pCntlData[i].wExtraStuff );
            while ( lExtra-- )
                pDialogHdr->pCntlData[i].pExtraStuff[j++] = GetByte( InResFile, plSize );
        } else
            pDialogHdr->pCntlData[i].pExtraStuff = NULL;

#endif // RLRES16


#ifdef RLRES32

        DWordUpFilePointer( InResFile, MYREAD, ftell(InResFile), plSize);

#endif // RLRES32

    }

    // watch for overflow of plsize
    if ((long)  *plSize <= 0) {
        *plSize = 0;
    }
    return (pDialogHdr);
}




/**
  *
  *
  *  Function: GetResMenu,
  *   Reads the Menu defintions from the resrouce file, and insert the info
  *   into a linked list..
  *
  *  Arguments:
  *   InResFile, Input res handle, positioned at being of Menu Definition.
  *   lSize, pointer to size of Menu Defintion.
  *   pMenuHeader, pointer to structure to contain menu info.
  *
  *  Returns:
  *   pMenuHeader containing linkd list of Menu info.
  *
  *  Errors Codes:
  *   None.
  *
  *  History:
  *   7/91, implemented                           Terryru
  *   12/91, cleaned up comments                      Terryru
  *   4/92,  Added PDK2 support                       Terryru
  *   4/92,  Added RLRES32 support                      Terryru
  *
  **/

void GetResMenu(FILE *InResFile, DWORD *lSize , MENUHEADER *pMenuHeader)
{
    static TCHAR   szItemText[255];
    BOOL    fStart = TRUE;
    BOOL    fQuit = FALSE;
    LONG    lExtra = 0;
    WORD    i = 0;
    WORD    wPopItems = 0, wMenuID = 0;
    MENUITEM    * pcMenuItem;
    TCHAR   *UNALIGNED*ptr;
    WORD    wNestingLevel = 0;
    WORD    wFlags;
    LONG    lStartingOffset;    // used to dword align file

    lStartingOffset = ftell(InResFile);

    pMenuHeader->wVersion = GetWord(InResFile, lSize);
    pMenuHeader->cbHeaderSize = GetWord(InResFile, lSize);


    pMenuHeader->fMenuEx =  (pMenuHeader->wVersion == 1);

    if (pMenuHeader->fMenuEx && pMenuHeader->cbHeaderSize) {
        lExtra = pMenuHeader->cbHeaderSize;
        pMenuHeader->pExtraStuff = (BYTE *)FALLOC( pMenuHeader->cbHeaderSize );
        while ( lExtra-- )
            pMenuHeader->pExtraStuff[i++] = GetByte( InResFile, lSize);
    } else
        pMenuHeader->pExtraStuff = NULL;


    // add all the items to the list

    while ( (((signed long) *lSize) >= 0) && !fQuit) {
        if (fStart) {
            // start the menu item list
            pcMenuItem = pMenuHeader->pMenuItem =
                         (MENUITEM *)FALLOC( sizeof( MENUITEM));
            pcMenuItem->pNextItem = NULL;
            fStart = FALSE;
        } else {
            // add space to the menu list
            // allocate space for next Item
            pcMenuItem->pNextItem = (MENUITEM *)FALLOC (sizeof( MENUITEM));

            pcMenuItem = pcMenuItem->pNextItem;
            pcMenuItem->pNextItem = NULL;

        }


        if (pMenuHeader->fMenuEx) {
            pcMenuItem->dwType   = GetdWord( InResFile, lSize);
            pcMenuItem->dwState  = GetdWord( InResFile, lSize);
            pcMenuItem->dwMenuID = GetdWord( InResFile, lSize);

            pcMenuItem->fItemFlags = wFlags  = GetWord(InResFile,lSize); // read type of menu item
            if ( (wFlags & MFR_POPUP) ) {
                wFlags &= ~MFR_POPUP;           // Normalize the menu
                wFlags |= MF_POPUP;
            }
            //pcMenuItem->fItemFlags = wFlags;
        } else {
            wFlags = GetWord(InResFile,lSize); // read type of menu item
            pcMenuItem->fItemFlags = wFlags;

            // is it a popup?

            if ( ! (pcMenuItem->fItemFlags & POPUP) ) {
                pcMenuItem->dwMenuID = (DWORD)GetWord( InResFile, lSize);
            }
        }

        GetName( InResFile, szItemText, lSize);

        ptr  = (TCHAR *UNALIGNED*)&pcMenuItem->szItemText;
        * ptr = (TCHAR *)FALLOC( MEMSIZE( lstrlen( szItemText) + 1));

        lstrcpy( (TCHAR *)*ptr, (TCHAR *)szItemText);


        if (pMenuHeader->fMenuEx) {
            DWordUpFilePointer( InResFile, MYREAD, ftell(InResFile), lSize);

            if ( (wFlags & POPUP) ) {
                pcMenuItem->dwHelpID = GetdWord( InResFile, lSize);
            }
        }

        if (wFlags & POPUP) {
            ++wNestingLevel;
        }

        if (wFlags & ENDMENU) {
            if (wNestingLevel) {
                --wNestingLevel;
            } else {
                fQuit = TRUE;
            }
        }
    }

#ifdef RLRES32

    WordUpFilePointer( InResFile,
                       MYREAD,
                       lStartingOffset,
                       ftell( InResFile), lSize);
#endif

}



int MyEOF(FILE *fPtr)
{
#ifdef RLRES32
    LONG lCurOffset;
    LONG lEndOffset;

    lCurOffset = ftell(fPtr);
    lEndOffset = fseek(fPtr, SEEK_END, 0);

    // reset file pointer
    fseek( fPtr, lCurOffset, SEEK_SET);

    return ((lEndOffset - lCurOffset) < sizeof (DWORD));
#else
    return ( feof(fPtr));
#endif
}


void WordUpFilePointer(FILE *fPtr,
                       BOOL bMode,
                       LONG lStartingOffset,
                       LONG lCurrentOffset ,
                       LONG *plPos)
{

    LONG lDelta;
    LONG lOffset;
    char buffer[]="\0\0\0\0\0\0\0\0";

    lDelta = lCurrentOffset - lStartingOffset ;
    lOffset = WORDUPOFFSET( lDelta);

    if ( bMode == MYREAD ) {
        fseek( fPtr, lOffset , SEEK_CUR);
        *plPos -= lOffset;
    } else {
        fwrite( buffer, 1, (size_t) lOffset, fPtr);
        *plPos += lOffset;
    }
}


void DWordUpFilePointer(

                       FILE  *fPtr,
                       BOOL   bMode,
                       LONG   lCurrentOffset,
                       DWORD *plPos)    //... New file position
{
    LONG lOffset;

    lOffset = DWORDUPOFFSET( lCurrentOffset);

    if ( bMode == MYREAD ) {
        fseek( fPtr, lOffset, SEEK_CUR);

        if ( plPos != NULL ) {
            *plPos -= lOffset;
        }
    } else {
        char buffer[]="\0\0\0\0\0\0\0";

        fwrite( buffer, 1, (size_t)lOffset, fPtr);

        if ( plPos != NULL ) {
            *plPos += lOffset;
        }
    }
}



//
// Function:    FilterRes, Public
//
// Synopsis:    Determine whether the resource type is to be filtered
//              The non filtered resource are OR together, thus several
//              resource types can pass through the filter.  Zero indicates
//              no resources are to be filterd, 0xFFFF indicates to not filter
//              custom resource.
//
//
// Arguments:   [wFilter]   Indicates the resources which we are to pass thru.
//              [pRes]      Ptr to Resource header struct
//
//
// Effects:
//
// Returns:     TRUE       Skip the current resource
//              FALSE      Use the current resource
//
// Modifies:
//
// History:
//              18-Oct-92   Created     TerryRu
//
//
// Notes:
//

BOOL FilterRes( WORD wFilter, RESHEADER *pRes)
{
    WORD wCurRes;


    wCurRes = pRes->wTypeID;

    if ( wFilter == 0 ) {
        return ( FALSE);
    }

    if ( wCurRes == 0 ) {
        return ( FALSE);
    }

    // check for special case for custom resources

    if ( wFilter == (WORD)0xFFFF ) {
        if ( wCurRes > 16) {
            return ( FALSE);
        } else {
            return ( TRUE);
        }
    }

    return ( ! (wFilter == wCurRes));
}




/**

  *
  *
  *  Function: GetResVer
  *
  * Extracts the version stamping information that
  * requires loclization from the resource file. The resource
  * information is containd is a USER defined resource
  * (ID = 16, Type = 1).
  *
  * The resource block format:
  * WORD wTotLen
  * WORD wValLen
  * BYTE szKey
  * BYTE szVal
  *
  * All information in the version stampling is contained in
  * repeating patters of this block type.   All Key, and Value
  * fields  are padded to start on DWORD boundaries. The
  * padding necessary to allign the blocks is not included in
  * the wTotLen field, but the padding to allign the fields inside
  * the block is.
  *
  * The following information in the Resource block needs to be
  * tokenized:
  *
  *
  * Key Field in StringFileInfo Block
  * Value Fields in StringFileInfo String Blocks.
  * Code Page and Language ID Fields of VarFileInfo
  * Standard Var Blocks.
  *
  * By defintion, any value string contained in the String requires
  * in be localized.  It is assumed that there will be two
  * StringFileInfo Blocks in each international resource. The first
  * one, is to remain in English, while the second Block, is to be
  * localized in the language specified by the StingFileInfo Key Field.
  * The VarFileInfo Code Page and Language ID Fields localized to
  * indicate which StringFileInfo block the file supports.
  *
  *
  *  Arguments:
  * FILE *InResFile
  * File to extracte version stamping from
  *
  * DWORD *lSize
  * Size of version stamping information
  *
  * VERHEADER *pVerHeader
  * pointer to structure to contain parsed version info.
  *
  *  Returns:
  *
  * pVerHead  Buffer contain version stamping resource
  * pVerBlock starting location of children blocks
  *
  *  Errors Codes:
  * TRUE,  Read of Resource sucessfull.
  * FALSE, Read of Resource failed.
  *
  *  History:
  *
  * 11/91.  Created                                         TerryRu.
  * 10/92.  Added Support for NULL Version Blocks       TerryRu
  * 10/92.  Added RLRES32 version                 DaveWi
  **/

#ifdef RLRES32

WORD GetResVer(

              FILE      *InResFile,
              DWORD     *plSize,
              VERHEAD   *pVerHead,
              VERBLOCK **pVerBuf)
{
    WORD wVerHeadSize;
    WORD wcRead;


    *pVerBuf = NULL;

    //... Read the fixed info that will not change

    wVerHeadSize = (WORD)(3 * sizeof(WORD)
                   + MEMSIZE( lstrlen( TEXT( "VS_VERSION_INFO")) + 1)
                   + sizeof( VS_FIXEDFILEINFO));
    wVerHeadSize = DWORDUP(wVerHeadSize);

    if ( ResReadBytes( InResFile,
                       (CHAR *)pVerHead,
                       (size_t)wVerHeadSize,
                       plSize) == FALSE ) {
        return ( (WORD)-1);
    }
    //... check for the special case where
    //... there is no version block.

    if ( wVerHeadSize >= pVerHead->wTotLen) {
        return ( 0);
    }
    //... Version header information read okay
    //... so make a buffer for the rest of the res.

    *pVerBuf = (VERBLOCK *)FALLOC( DWORDUP( pVerHead->wTotLen) - wVerHeadSize);

    //... Now Read Value Information

    wcRead = DWORDUP( pVerHead->wTotLen) - wVerHeadSize;

    return ( ResReadBytes( InResFile,
                           (CHAR *)*pVerBuf,
                           (size_t)wcRead,
                           plSize) == FALSE ? (WORD)-1 : wcRead);
}


#else //... RLRES32


BOOL GetResVer(

              FILE      *InResFile,
              DWORD     *plSize,
              VERHEAD   *pVerHead,
              VERBLOCK **pVerBuf)
{
    size_t wcRead = sizeof( VERHEAD);


    if ( ResReadBytes( InResFile, (CHAR *) pVerHead, wcRead, plSize) == FALSE ) {
        return ( FALSE);
    }

    // check for the special case where there is no version block

    if ( (size_t)pVerHead->wTotLen == wcRead ) {
        *pVerBuf = NULL;
        return ( TRUE);
    }

    // Version header information read okay.

    *pVerBuf = (VERBLOCK *)FALLOC( DWORDUP( pVerHead->wTotLen) - wcRead);

    // Now Read Value Information


    return ( ResReadBytes( InResFile,
                           (CHAR *) *pVerBuf,
                           (size_t)(DWORDUP( pVerHead->wTotLen) - wcRead),
                           plSize));
}

#endif //... RLRES32


/**
  *
  *
  *  Function: GetNameOrd
  * Function to read either the string name, or ordinal number of a
  * resource ID.  If the ID begins with a 0xff, the resource ID
  * is a ordinal number, otherwise the ID is a string.
  *
  *
  *  Arguments:
  * InResFile, File handle positioned to location of resource
  * ID information.
  * cFlag, pointer to flag indicating which ID type is used.
  * pwID, pointer of ordinal ID number
  * pszText pointer, to address of ID string.
  *
  *  Returns:
  * cFlag to indicate if ID is string or ordinal number.
  * pwID, pszText containing actual ID info.
  *
  *  Errors Codes:
  *
  *  History:
  *
  *    7/91, Implemented                    TerryRu
  *    9/91, Inserted cFlag as a indicator for ID or string PeterW
  *    4/92, Added RLRES32 support                TerryRu
  **/


void GetNameOrd(

               FILE   *fpInResFile,       //... File to retrieve header from
               BOOL   UNALIGNED*pbFlag,//... For IDFLAG or 1st byte (WORD in RLRES32) of name/ord
               WORD   UNALIGNED*pwID,  //... For retrieved resource ID (if not a string)
               TCHAR  *UNALIGNED*pszText, // For retrieved resource name if it is a string
               DWORD  *plSize)            // Keeps count of bytes read (or NULL)
{
    WORD fFlag;

    //... get type info

#ifdef RLRES16

    fFlag = GetByte( fpInResFile, plSize);

#else

    fFlag = GetWord( fpInResFile, plSize);

#endif

    *pbFlag = fFlag;

    if ( fFlag == IDFLAG ) {
        //... field is a numbered item
#ifdef RLRES16
        *pwID    = GetByte( fpInResFile , plSize);
#else
        *pwID    = GetWord( fpInResFile , plSize);
#endif
        *pszText = (TCHAR *)FALLOC( 0);
    } else {
        static TCHAR szBuf[ 255];

        //... field is a named item.
        //... put fFlag byte(s) back into stream
        //... because it is part of the name.
        *pwID = IDFLAG;

#ifdef RLRES16

        UnGetByte( fpInResFile, (BYTE) fFlag, plSize);
#else

        UnGetWord( fpInResFile, (WORD) fFlag, plSize);
#endif
        GetName( fpInResFile, szBuf, plSize);
        *pszText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( szBuf) + 1));

        lstrcpy( (TCHAR *)*pszText, (TCHAR *)szBuf);
    }
}




/**
  *
  *
  *  Function: GetResHeader
  * Reads the Resource Header information, and stores it in a structure.
  *
  *  Arguments:
  * InResFile, File handle positioned to location of Resource Header.
  * pResHeader, pointer to Resource Header structure.
  *
  *  Returns:
  * pResHeader, containing resource header info.
  * plSize, contining size of remaining resource info.
  *
  *  Errors Codes:
  * -1, Read of resource header failed.
  *
  *  History:
  * 7/91, Implemented               TerryRu
  * 4/92, Added RLRES32 Support               Terryru
  *
  *
  **/

int GetResHeader(

                FILE      *InResFile,   //... File to get header from
                RESHEADER UNALIGNED*pResHeader,  //... buffer for the retrieved header
                DWORD     *plSize)      //... keeps track of the bytes read from the file
{

#ifdef RLRES32

    pResHeader->lSize       = GetdWord( InResFile, plSize);
    pResHeader->lHeaderSize = GetdWord( InResFile, plSize);

#endif

    //... get name ID and type ID

    GetNameOrd( InResFile,
                (BOOL UNALIGNED*)&pResHeader->bTypeFlag,
                (WORD UNALIGNED*)&pResHeader->wTypeID,
                (TCHAR *UNALIGNED*)&pResHeader->pszType,
                plSize);

    GetNameOrd( InResFile,
                (BOOL UNALIGNED*)&pResHeader->bNameFlag,
                (WORD UNALIGNED*)&pResHeader->wNameID,
                (TCHAR *UNALIGNED*)&pResHeader->pszName,
                plSize);

#ifdef RLRES32

    DWordUpFilePointer( InResFile, MYREAD, ftell( InResFile), plSize);

    pResHeader->lDataVersion = GetdWord( InResFile, plSize);

#endif

    pResHeader->wMemoryFlags = GetWord( InResFile, plSize);

#ifdef RLRES32

    pResHeader->wLanguageId      = GetWord(  InResFile, plSize);
    pResHeader->lVersion         = GetdWord( InResFile, plSize);
    pResHeader->lCharacteristics = GetdWord( InResFile, plSize);

#else // RLRES32

    pResHeader->lSize = (DWORD)GetdWord( InResFile, plSize);

#endif // RLRES32

    return ( 0);
}


/**
  *
  *
  *  Function: isdup
  * Used to determine if the current dialog control id is a duplicate
  * of an earlyier control id. If so, isdup returns a flag indicating the
  * ID is a duplicate.
  *
  *  Arguments:
  * wcCurrent, ID of current dialog control.
  * wpIdBuf, array of dialog control ID's processed so far.
  * wcItems, number of ID's in wpIdBuf
  *
  *  Returns:
  * TRUE, ID is a duplicate
  * FALSE, ID is not a duplicate
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented               TerryRu
  *
  *
  **/

BOOL isdup(WORD wCurrent, WORD *wpIdBuf, WORD wcItems)
{
    WORD i;


    for (i = 0; i < wcItems; i++) {
        if (wCurrent == wpIdBuf[i]) {
            return TRUE;
        }
    }
    return FALSE;
}


/**
  *
  *
  *  Function: ParseTokCrd
  * Places dialog coordinates into a buffer.
  *
  *  Arguments:
  * pszCrd, buffer to hold dialog control cordinates.
  * pwX, pwY, pwCX, pwCY, dialog control cordiantes.
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  * NA.
  *
  *  History:
  * 7/91, implemented               TerryRu
  *
  *
  **/

void ParseTokCrd(
                TCHAR *pszCrd,
                WORD UNALIGNED * pwX,
                WORD UNALIGNED * pwY,
                WORD UNALIGNED * pwCX,
                WORD UNALIGNED * pwCY)
{
#ifdef RLRES32

    int x  = 0;
    int y  = 0;
    int cx = 0;
    int cy = 0;

    _stscanf( pszCrd, TEXT("%d %d %d %d"), &x, &y, &cx, &cy);
    *pwX  = (WORD) x;
    *pwY  = (WORD) y;
    *pwCX = (WORD) cx;
    *pwCY = (WORD) cy;

#else  //RLRES32

    sscanf( pszCrd, "%hd %hd %hd %hd", pwX, pwY, pwCX, pwCY);

#endif //RLRES32
}

int GetAlignFromString( TCHAR *pszStr)
{
    TCHAR   *pStyle;

    if ( !(pStyle = _tcschr( pszStr, TEXT('('))) ) {
        return (-1);
    }

    while ( *pStyle ) {
        if ( *pStyle == TEXT('L') ) {
            if ( ! _tcsnicmp( pStyle, TEXT("LEFT"), 4) ) {
                return (0);
            }
        } else if ( *pStyle == TEXT('C') ) {
            if ( ! _tcsnicmp( pStyle, TEXT("CENTER"), 6)) {
                return (1);
            }
        } else if ( *pStyle == TEXT('R') ) {
            if ( ! _tcsnicmp( pStyle, TEXT("RIGHT"), 5) ) {
                return (2);
            }
        }
        pStyle++;
    }
    return ( -1 );           //none
}


void ParseTokCrdAndAlign(
                        TCHAR       *pszCrd,
                        CONTROLDATA *pCntrl)
{
    int     align = 0;

    if ( (pCntrl->bClass_Flag == IDFLAG)
         && ((pCntrl->bClass == STATIC)
             || (pCntrl->bClass == EDIT)) ) {

        if ( (align = GetAlignFromString( pszCrd)) >= 0 ) {

            if ( pCntrl->bClass == STATIC ) {
                pCntrl->lStyle &= ~(SS_LEFT|SS_RIGHT|SS_CENTER);

                if ( align == 2 )
                    pCntrl->lStyle |= SS_RIGHT;
                else if ( align == 1 )
                    pCntrl->lStyle |= SS_CENTER;
                else
                    pCntrl->lStyle |= SS_LEFT;
            } else {
                pCntrl->lStyle &= ~(ES_LEFT|ES_RIGHT|ES_CENTER);

                if ( align == 2 )
                    pCntrl->lStyle |= ES_RIGHT;
                else if ( align == 1 )
                    pCntrl->lStyle |= ES_CENTER;
                else
                    pCntrl->lStyle |= ES_LEFT;
            }
        }
    }
    ParseTokCrd( pszCrd,
                 (WORD UNALIGNED *)&pCntrl->x,
                 (WORD UNALIGNED *)&pCntrl->y,
                 (WORD UNALIGNED *)&pCntrl->cx,
                 (WORD UNALIGNED *)&pCntrl->cy);
}


/**
  *
  *
  *  Function: PutResHeader
  * Writes Resource Header information contained in the ResHeader structure
  * to the ouput resfile. Note, the value of the size field, is not yet
  * know, so it is left blank, to be fixed up once the size resource
  * determined.
  *
  *  Arguments:
  * OutResFile, File handle to Output Resource File.
  * ResHeader, Structure containing resource header information.
  * pResSizePos, file position buffer
  *
  *  Returns:
  * pResSizePos, position at localization of the OutResFile to insert
  * the resource size.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented                       Terryru
  * 9/91, Added bTypeFlag to handle case where ID is 255.   Peterw
  * 4/92, Added RLRES32 support                   Terryru
  *
  *
  **/

int PutResHeader(

                FILE     *OutResFile,   //... File to write to
                RESHEADER ResHeader,    //... Header to be written out
                fpos_t   *pResSizePos,  //... For offset at which to write the adjusted res size
                DWORD    *plSize)       //... Keeps track of bytes written
{
    int   rc;
    DWORD ltSize = *plSize;


#ifdef RLRES32
    //... save position to res size

    rc = fgetpos( OutResFile, pResSizePos);

    //... this size is bogus, will fill in later
    //... unless we are called in the mail loop

    PutdWord( OutResFile, ResHeader.lSize,       plSize);
    PutdWord( OutResFile, ResHeader.lHeaderSize, plSize);

#endif // RLRES32

    PutNameOrd( OutResFile,
                ResHeader.bTypeFlag,
                ResHeader.wTypeID,
                ResHeader.pszType,
                plSize);

    PutNameOrd( OutResFile,
                ResHeader.bNameFlag,
                ResHeader.wNameID,
                ResHeader.pszName,
                plSize);

#ifdef RLRES32

    DWordUpFilePointer( OutResFile, MYWRITE, ftell( OutResFile), plSize);

    PutdWord( OutResFile, ResHeader.lDataVersion, plSize);

#endif // RLRES32


    PutWord( OutResFile, ResHeader.wMemoryFlags, plSize);

#ifdef RLRES32

    PutWord(  OutResFile, ResHeader.wLanguageId,      plSize);
    PutdWord( OutResFile, ResHeader.lVersion,         plSize);
    PutdWord( OutResFile, ResHeader.lCharacteristics, plSize);

#else // RLRES32
    //... save position to res size

    rc = fgetpos( OutResFile, pResSizePos);

    //... this size is bogus, will fill in later
    //... unless we are called in the mail loop

    PutdWord( OutResFile, ltSize, plSize);

#endif // RLRES32

/////////////////// ??????? why?    *plSize = ltSize;

    return ( rc);
}



/**
  *
  *
  *  Function: PutDialog
  * PutDialog writes dialog information to the output resource file as
  * it traveres through the linked list of dialog info.  If the info
  * is of the type that needs to be localized, the corresponding translated
  * info is read from the token file, and writen to the resource file.
  *
  *  Arguments:
  * OutResFile, The file handle of the res file being generated.
  * TokFile, The file handle of the token file containing tokenized dialog info,
  *     typically this file has been localized.
  * ResHeader, Structure containg Dialog resource header information.
  * pDialogHdr, Linked list of unlocalized Dialog information.
  *
  *  Returns:
  * Translated dialog information written to the Output Resource file.
  *
  *  Errors Codes:
  * None,
  *
  *  History:
  *     7/91, Implemented.                                      TerryRu
  *     1/93, Now tokenize dlg fontnames                        TerryRu
  *     01/93 Support for var length token text                 MHotchin
  *
  **/

void PutDialog(FILE         *OutResFile,
               FILE         *TokFile,
               RESHEADER     ResHeader,
               DIALOGHEADER *pDialogHdr)
{
    static TOKEN   tok;
    int found = 0;
    WORD    wcDup = 0;
    WORD    *pwIdBuf;
    static TCHAR   pErrBuf[MAXINPUTBUFFER];
    WORD    i, j = 0, k = 0;
    fpos_t  ResSizePos;
    CONTROLDATA *pCntlData = pDialogHdr->pCntlData;
    DWORD   lSize = 0;
    LONG    lStartingOffset;    // used to dword align file
    WORD    y = 0;
    LONG    lExtra = 0;

    lStartingOffset = ftell(OutResFile);

    // Prep for find token call
    tok.wType     = ResHeader.wTypeID;
    tok.wName     = ResHeader.wNameID;
    tok.wID       = 0;
    tok.wReserved = ST_TRANSLATED;


    lstrcpy( (TCHAR *)tok.szName, (TCHAR *)ResHeader.pszName);
    tok.szText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( pDialogHdr->pszCaption) + 1));
    lstrcpy( (TCHAR *)tok.szText, (TCHAR *)pDialogHdr->pszCaption);

    // write the Dialog Res Header
    if ( PutResHeader( OutResFile, ResHeader , &ResSizePos, &lSize)) {
        RLFREE( tok.szText);
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_DLGBOX, NULL);
    }
    // write the dialog header

    lSize = 0L;

#ifdef RLRES32

    if (pDialogHdr->fDialogEx) {
        PutWord( OutResFile, pDialogHdr->wDlgVer, &lSize);
        PutWord( OutResFile, pDialogHdr->wSignature, &lSize);
        PutdWord( OutResFile, pDialogHdr->dwHelpID, &lSize);
        PutdWord( OutResFile, pDialogHdr->lExtendedStyle, &lSize);
        PutdWord( OutResFile, pDialogHdr->lStyle, &lSize);
    } else {
        PutdWord( OutResFile, pDialogHdr->lStyle, &lSize);
        PutdWord( OutResFile, pDialogHdr->lExtendedStyle, &lSize);
    }

    PutWord( OutResFile, pDialogHdr->wNumberOfItems, &lSize);

#else // RLRES32

    PutdWord( OutResFile, pDialogHdr->lStyle, &lSize);
    PutByte( OutResFile, (BYTE)pDialogHdr->wNumberOfItems, &lSize);

#endif // RLRES32

    // check to see if caption was localized
    // but don't put it in the res file yet
    // order of token is caption, cordinates,
    // while in res its cordinates, caption

    tok.wFlag = ISCAP;

    if ( ! FindToken( TokFile, &tok, ST_TRANSLATED) ) {
        // can not find token, terminate
        ParseTokToBuf( pErrBuf, &tok);
        RLFREE( tok.szText);
        QuitT( IDS_ENGERR_05, pErrBuf, NULL);
    }

    tok.wReserved = ST_TRANSLATED;

    // token found, continue
    RLFREE( pDialogHdr->pszCaption);
    pDialogHdr->pszCaption =
    (TCHAR *)FALLOC( MEMSIZE( lstrlen( tok.szText) + 1));

    TextToBin( pDialogHdr->pszCaption,
               tok.szText,
               lstrlen( tok.szText));
    RLFREE( tok.szText);

    // Now get the cordinates of the token
    tok.wFlag = (ISCAP) | (ISCOR);

    if ( ! FindToken( TokFile, &tok, ST_TRANSLATED) ) {
        // token not found, terminate
        ParseTokToBuf(pErrBuf, &tok);
        RLFREE( tok.szText);
        QuitT( IDS_ENGERR_05, pErrBuf, NULL);
    }
    tok.wReserved = ST_TRANSLATED;

    // token found continue

    ParseTokCrd( tok.szText,
                 (WORD UNALIGNED *)&pDialogHdr->x,
                 (WORD UNALIGNED *)&pDialogHdr->y,
                 (WORD UNALIGNED *)&pDialogHdr->cx,
                 (WORD UNALIGNED *)&pDialogHdr->cy);

    RLFREE( tok.szText);

    // put cordindates in new res file
    PutWord(OutResFile, pDialogHdr->x , &lSize);
    PutWord(OutResFile, pDialogHdr->y , &lSize);
    PutWord(OutResFile, pDialogHdr->cx , &lSize);
    PutWord(OutResFile, pDialogHdr->cy , &lSize);

    PutNameOrd(OutResFile,
               pDialogHdr->bMenuFlag,   // 9/11/91 (PW)
               pDialogHdr->wDlgMenuID,
               pDialogHdr->pszDlgMenu,
               &lSize);

    PutNameOrd( OutResFile,
                pDialogHdr->bClassFlag,  // 9/11/91 (PW)
                pDialogHdr->wDlgClassID,
                pDialogHdr->pszDlgClass,
                &lSize);

    PutString(OutResFile, pDialogHdr->pszCaption, &lSize);

    if ( pDialogHdr->lStyle & DS_SETFONT ) {

        if (gfExtendedTok) {

            static CHAR   szTmpBuf[30];

            // find dialog font size
            tok.wFlag = ISDLGFONTSIZE;
            tok.wReserved = ST_TRANSLATED;

            if ( ! FindToken( TokFile, &tok, ST_TRANSLATED) ) {
                // token not found, terminate
                ParseTokToBuf(pErrBuf, &tok);
                RLFREE( tok.szText);
                QuitT( IDS_ENGERR_05, pErrBuf, NULL);
            }

#ifdef RLRES32

            _WCSTOMBS( szTmpBuf,
                       tok.szText,
                       sizeof( szTmpBuf),
                       lstrlen( tok.szText) + 1);
            PutWord (OutResFile, (WORD) atoi(szTmpBuf), &lSize);

            if (pDialogHdr->fDialogEx) {
                PutWord(   OutResFile, pDialogHdr->wWeight , &lSize);
                PutWord(   OutResFile, pDialogHdr->wItalic , &lSize);
            }

#else // RLRES32

            PutWord( OutResFile, (WORD) atoi( tok.szText), &lSize);

#endif // RLRES32

            RLFREE( tok.szText);

            // find dialog font name
            tok.wFlag = ISDLGFONTNAME;
            tok.wReserved = ST_TRANSLATED;

            if ( ! FindToken( TokFile, &tok, ST_TRANSLATED) ) {
                // token not found, terminate
                ParseTokToBuf(pErrBuf, &tok);
                RLFREE( tok.szText);
                QuitT( IDS_ENGERR_05, pErrBuf, NULL);
            }
            PutString( OutResFile, tok.szText, &lSize);
            RLFREE( tok.szText);

        } else {
            PutWord(   OutResFile, pDialogHdr->wPointSize , &lSize);

            if (pDialogHdr->fDialogEx) {
                PutWord(   OutResFile, pDialogHdr->wWeight , &lSize);
                PutWord(   OutResFile, pDialogHdr->wItalic , &lSize);
            }

            PutString( OutResFile, pDialogHdr->pszFontName, &lSize);

        }

    }

#ifdef RLRES32

    DWordUpFilePointer( OutResFile, MYWRITE, ftell(OutResFile), &lSize);

#endif // RLRES32

    //... That was the end of the DialogBoxHeader
    //... Now we start with the ControlData's

    pwIdBuf = (WORD *)FALLOC( (DWORD)pDialogHdr->wNumberOfItems
                              * sizeof( WORD));

    tok.wReserved = ST_TRANSLATED;

    // now place each of the dialog controls in the new res file
    for (i = 0; i < pDialogHdr->wNumberOfItems; i ++) {
        if (isdup ((WORD)pDialogHdr->pCntlData[i].dwID, pwIdBuf, (WORD)j)) {
            tok.wID = (USHORT)wcDup++;
            tok.wFlag = ISDUP;
        } else {
            // wid is unique so store in buffer for dup check
            pwIdBuf[j++] = (USHORT)pDialogHdr->pCntlData[i].dwID;

            tok.wID = (USHORT)pDialogHdr->pCntlData[i].dwID;
            tok.wFlag = 0;
        }

        if (pDialogHdr->pCntlData[i].pszDlgText[0]) {
            tok.szText = NULL;

            if (!FindToken(TokFile, &tok, ST_TRANSLATED)) {
                // can not find the token, terminate program
                ParseTokToBuf(pErrBuf, &tok);
                RLFREE( tok.szText);
                QuitT( IDS_ENGERR_05, pErrBuf, NULL);
            }

            tok.wReserved = ST_TRANSLATED;

            // token found, continue
            RLFREE( pDialogHdr->pCntlData[i].pszDlgText);
            pDialogHdr->pCntlData[i].pszDlgText =
            (TCHAR *)FALLOC( MEMSIZE( lstrlen( tok.szText) + 1));

            if ( pDialogHdr->pCntlData[i].pszDlgText ) {
                TextToBin(pDialogHdr->pCntlData[i].pszDlgText,
                          (TCHAR *)tok.szText,
                          lstrlen((TCHAR *)tok.szText) + 1);
            }
            RLFREE( tok.szText);
        }

        tok.wFlag |= ISCOR;

        if ( ! FindToken( TokFile, &tok, ST_TRANSLATED) ) {
            ParseTokToBuf( pErrBuf, &tok);
            RLFREE( tok.szText);
            QuitT( IDS_ENGERR_05, pErrBuf, NULL);
        }
        tok.wReserved = ST_TRANSLATED;

        ParseTokCrdAndAlign( tok.szText, &pDialogHdr->pCntlData[i] );

        RLFREE( tok.szText);

#ifdef RLRES32

        if (pDialogHdr->fDialogEx) {
            PutdWord( OutResFile, pDialogHdr->pCntlData[i].dwHelpID, &lSize);
            PutdWord( OutResFile, pDialogHdr->pCntlData[i].lExtendedStyle, &lSize);
            PutdWord( OutResFile, pDialogHdr->pCntlData[i].lStyle, &lSize);
        } else {
            PutdWord( OutResFile, pDialogHdr->pCntlData[i].lStyle, &lSize);
            PutdWord( OutResFile, pDialogHdr->pCntlData[i].lExtendedStyle, &lSize);
        }

#endif // RLRES32
        // now put control info into res file
        PutWord (OutResFile, pDialogHdr->pCntlData[i].x , &lSize);
        PutWord (OutResFile, pDialogHdr->pCntlData[i].y , &lSize);
        PutWord (OutResFile, pDialogHdr->pCntlData[i].cx , &lSize);
        PutWord (OutResFile, pDialogHdr->pCntlData[i].cy , &lSize);

        if (pDialogHdr->fDialogEx)
            PutdWord (OutResFile, pDialogHdr->pCntlData[i].dwID , &lSize);
        else
            PutWord (OutResFile, (WORD)pDialogHdr->pCntlData[i].dwID , &lSize);

#ifdef RLRES16

        // lStyle
        PutdWord (OutResFile, pDialogHdr->pCntlData[i].lStyle , &lSize);


        PutByte(OutResFile, (BYTE) pDialogHdr->pCntlData[i].bClass, &lSize);

        if (! (pDialogHdr->pCntlData[i].bClass & 0x80)) {
            PutString (OutResFile, pDialogHdr->pCntlData[i].pszClass , &lSize);
        }

#else // RLRES16

        PutNameOrd(OutResFile,
                   pDialogHdr->pCntlData[i].bClass_Flag, // 9/11/91 (PW)
                   pDialogHdr->pCntlData[i].bClass,
                   pDialogHdr->pCntlData[i].pszClass,
                   &lSize);

#endif // RLRES16

        PutNameOrd(OutResFile,
                   pDialogHdr->pCntlData[i].bID_Flag, // 9/11/91 (PW)
                   pDialogHdr->pCntlData[i].wDlgTextID,
                   pDialogHdr->pCntlData[i].pszDlgText,
                   &lSize);


#ifdef RLRES16

        PutByte(OutResFile, (BYTE) pDialogHdr->pCntlData[i].unDefined, &lSize);
#else
        PutWord(OutResFile, (WORD)pDialogHdr->pCntlData[i].wExtraStuff, &lSize);

        if (pDialogHdr->fDialogEx && pDialogHdr->pCntlData[i].wExtraStuff) {
            lExtra = pDialogHdr->pCntlData[i].wExtraStuff;
            y = 0;
            while ( lExtra-- )
                PutByte (OutResFile, pDialogHdr->pCntlData[i].pExtraStuff[y++] , &lSize);
        }

        if ( i < pDialogHdr->wNumberOfItems - 1 ) {
            DWordUpFilePointer( OutResFile, MYWRITE, ftell(OutResFile), &lSize);
        }

#endif // RLRES16

    }

    RLFREE( pwIdBuf );

    if (!UpdateResSize (OutResFile, &ResSizePos , lSize)) {
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_DLGBOX, NULL);
    }
    DWordUpFilePointer( OutResFile, MYWRITE, ftell( OutResFile), NULL);
}



/**
  *
  *
  *  Function:  PutMenu
  * Traveres through the linked list of Menu information and writes the info to the
  * output resource file. If the infortion is the type that requires localization,
  * the translated info is read from the token file and writen to the resource.
  * call PutMenuItem to do the actual write of the menu info to the resource.
  *
  *  Arguments:
  * OutResFile, File handle of output resource file.
  * TokFile, File handle of token file.
  * ResHeader, Sturcture contain Menu Resource header information.
  * pMenuHdr, Linked list of menu info.
  *
  *  Returns:
  * Translated Menu Info written to output resource file.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented.              TerryRu.
  * 01/93 Changes to allow var length token text.  MHotchin
  *
  **/

void PutMenu(FILE *OutResFile,
             FILE *TokFile,
             RESHEADER ResHeader,
             MENUHEADER *pMenuHdr)
{
    DWORD lSize = 0;
    static TOKEN tok;
    static WORD    wcPopUp = 0;
    fpos_t ResSizePos;
    MENUITEM *pMenuItem = pMenuHdr->pMenuItem;
    static TCHAR pErrBuf[ MAXINPUTBUFFER];
    LONG    lExtra = 0;
    WORD    i = 0;


    // write the Menu Res header
    if ( PutResHeader (OutResFile, ResHeader , &ResSizePos, &lSize)) {
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_MENU, NULL);
    }

    lSize = 0;

    // write the Menu header
    PutWord (OutResFile, pMenuHdr->wVersion, &lSize);
    PutWord (OutResFile, pMenuHdr->cbHeaderSize , &lSize);

    if (pMenuHdr->fMenuEx && pMenuHdr->cbHeaderSize) {
        lExtra = pMenuHdr->cbHeaderSize;
        while ( lExtra-- )
            PutByte (OutResFile, pMenuHdr->pExtraStuff[i++] , &lSize);
    }

    // prep for findtoken call
    tok.wType     = ResHeader.wTypeID;
    tok.wName     = ResHeader.wNameID;
    tok.wReserved = ST_TRANSLATED;

    // for all menu items,
    // find translated token if item was tokenized
    // write out that menu item, using new translation if available.


    while (pMenuItem) {
        // if Menu Item is a seperator skip it
        if ( *pMenuItem->szItemText ) {
            // check for the popup menu items
            if ((pMenuItem->fItemFlags & MFR_POPUP) && pMenuHdr->fMenuEx) {
                tok.wID = (pMenuItem->dwMenuID == 0 ||
                           pMenuItem->dwMenuID == 0x0000ffff) ?
                          (USHORT)pMenuItem->dwMenuID : 0x8000 + wcPopUp++;
                tok.wFlag = ISPOPUP;
            } else if (pMenuItem->fItemFlags & POPUP) {
                tok.wID = wcPopUp++;
                tok.wFlag = ISPOPUP;
            } else {
                tok.wID = (USHORT)pMenuItem->dwMenuID;
                tok.wFlag = 0;
            }
            lstrcpy((TCHAR *)tok.szName, (TCHAR *)ResHeader.pszName);
            tok.szText = NULL;

            if ( ! FindToken( TokFile, &tok,ST_TRANSLATED) ) {
                // can not find token, terminate
                ParseTokToBuf(pErrBuf, &tok);
                RLFREE( tok.szText);
                QuitT( IDS_ENGERR_05, pErrBuf, NULL);
            }
            tok.wReserved = ST_TRANSLATED;

            // token found, continue
            RLFREE( pMenuItem->szItemText);
            pMenuItem->szItemText=
            (TCHAR *)FALLOC( MEMSIZE( lstrlen( tok.szText) + 1));

            TextToBin(pMenuItem->szItemText,
                      (TCHAR *)tok.szText,
                      lstrlen((TCHAR *)tok.szText)+1);
            RLFREE( tok.szText);
        }

        PutMenuItem (OutResFile, pMenuItem , &lSize, pMenuHdr->fMenuEx);

        pMenuItem = pMenuItem->pNextItem;
    }

    if (!UpdateResSize (OutResFile, &ResSizePos , lSize)) {
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_MENU, NULL);
    }
}



/**
  *
  *
  *  Function: PutMenuItem
  * Called by PutMenu to write a menu item info to the ouput resoruce file.
  *
  *
  *  Arguments:
  * OutResFile, File handle of output resfile, positioned at location to
  *     write menu item info.
  * pMenuItem, pointer to struture containing menu item info.
  * plSize, pointer of variable to count the number of bytes written to
  * the resource file. Used later to fixup the resource field in the
  * header.
  *
  *
  *
  *  Returns:
  * OutReFile, containing translated menu item info, and plSize containing
  * number of bytes written to resource file.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7//91, Implemented           TerryRu
  *
  *
  **/

void   PutMenuItem(FILE * OutResFile, MENUITEM * pMenuItem, DWORD * plSize, BOOL fMenuEx)
{
    if (fMenuEx) {
        PutdWord( OutResFile, pMenuItem->dwType, plSize);
        PutdWord( OutResFile, pMenuItem->dwState, plSize);
        PutdWord( OutResFile, pMenuItem->dwMenuID, plSize);
        PutWord( OutResFile, pMenuItem->fItemFlags, plSize);
    } else {
        PutWord( OutResFile, pMenuItem->fItemFlags, plSize);

        if ( ! (pMenuItem->fItemFlags & POPUP) ) {
            PutWord( OutResFile, (WORD)pMenuItem->dwMenuID, plSize);
        }
    }

    PutString( OutResFile, pMenuItem->szItemText, plSize);

    if (fMenuEx) {
        DWordUpFilePointer( OutResFile, MYWRITE, ftell(OutResFile), plSize);

        if (pMenuItem->fItemFlags & MFR_POPUP) {
            PutdWord( OutResFile, pMenuItem->dwHelpID, plSize);
        }
    }

}


/**
  *
  *
  *  Function: PutNameOrd
  * Writes either the string or ordinal ID of the resource class or type.
  *
  *
  *  Arguments:
  * OutResFile, File handle of resource file being generated.
  * bFlag,      Flag indicating whether ID is a string or ordinal.
  * pszText,    string ID, if used.
  * wId,        Ordinal ID if used.
  * pLsize,     pointer to DWORD counter var.
  *
  *  Returns:
  * OutResFile, containing ID info, and plSize containing the number of
  * bytes written to the file.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented.          TerryRu.
  *
  *
  **/

void PutNameOrd(

               FILE  *fpOutResFile,
               BOOL   bFlag,
               WORD   wID,
               TCHAR *pszText,
               DWORD *plSize)
{
    if ( bFlag == IDFLAG ) {

#ifdef RLRES16

        PutByte( fpOutResFile, (BYTE)IDFLAG, plSize);

#else

        PutWord( fpOutResFile, (WORD)IDFLAG, plSize);

#endif

        PutWord( fpOutResFile, wID, plSize);
    } else {
        PutString( fpOutResFile, pszText, plSize);
    }
}



/**
  *
  *
  *  Function: MyAtow,
  * Special Ascii to WORD function that works on 4 digit, hex strings.
  *
  *
  *  Arguments:
  * pszNum, 4 digit hex string to convert to binary.
  *
  *
  *  Returns:
  * Binary value of pszNumString
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 12//91, Implemented.            TerryRu.
  *
  *
  **/

WORD MyAtoX(

           CHAR *pszNum,   //... array of bytes to scan
           int nLen)       //... # oc bytes in pszNum to scan
{
    WORD wNum = 0;
    WORD i;
    WORD nPower = 1;

    if ( nLen > 4 ) {
        QuitT( IDS_ENGERR_16, (LPTSTR)IDS_CHARSTOX, NULL);
    }

    for ( i = 0; i < nLen; i++, nPower *= 16 ) {
        if ( isdigit( pszNum[ i]) ) {
            wNum +=  nPower * (pszNum[i] - '0');
        } else {
            wNum +=  nPower * (toupper( pszNum[i]) - 'A' + 10);
        }
    }
    return ( wNum);
}


WORD MyAtoW( CHAR *pszNum)
{
    return ( MyAtoX( pszNum, 4));
}





/**
  *
  *
  *  Function: PutResVer.
  * Writes the Version stamping info to the Resourc file. Unlike most
  * put functions, PutResVer writes all the localized version stamping info
  * into a memory block, then writes the complete version stamping info to
  * the resource file.  This was done because of large number of size
  * fixups needed for the version stamping info.
  *
  *
  *  Arguments:
  * OutResFile, file pointer of resource file being generated.
  * TokeFile, file pointer of input token file containing localized info.
  * ResHeader, Structure containing Resource Header info of the
  * version stamping block.
  * pVerHdr, address of Version Header. Note this is different the ResHdr.
  * pVerBlk, address of Version stamping info, which is contained in
  * a series of StringFile, and VarFile info blocks. The number of
  * such blocks is determined by the size fields.
  *
  *  Returns:
  * OutResFile, containing localized version stamping info.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 11/91, Implemented.                                         TerryRu.
  * 12/91, Various fixes to work with different padding.        TerryRu.
  * 01/92, Size of Version block updated                        PeterW.
  * 10/92, Now handles NULL Version Blocks                      TerryRu.
  * 10/92, Added RLRES32 version                                  DaveWi
  * 01/93, Added var length token text support.                 MHotchin
  **/

#ifdef RLRES32

int PutResVer(

             FILE     *fpOutResFile,
             FILE     *fpTokFile,
             RESHEADER ResHeader,
             VERHEAD  *pVerHdr,
             VERBLOCK *pVerBlk)
{
    TOKEN  Tok;
    BOOL   fInStringInfo = FALSE;   //... TRUE if reading StringFileInfo
    WORD   wTokNum = 0;             //... Put into Tok.wID field
    WORD   wTokContinueNum = 0;     //... Put into Tok.wFlag field
    WORD   wDataLen = 0;            //... Length of old resource data
    WORD   wVerHeadSize;            //... Sizeof of the VERHEAD struct
    fpos_t lResSizePos;
    DWORD  lSize = 0L;
    int    nWritten = 0;
    int    nNewVerBlockSize = 0;
    PVERBLOCK pNewVerStamp = NULL;
    PVERBLOCK pNewBlk      = NULL;


    wVerHeadSize = (WORD)(3 * sizeof(WORD)
                   + MEMSIZE( lstrlen( TEXT( "VS_FIXEDFILEINFO")) + 1)
                   + sizeof( VS_FIXEDFILEINFO));
    wVerHeadSize = DWORDUP(wVerHeadSize);

    //... write the Version resouce header

    if ( PutResHeader(fpOutResFile, ResHeader, &lResSizePos, &lSize) ) {
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_VERSTAMP, NULL);
    }

    lSize = 0L;

    if ( pVerBlk == NULL ) {
        //... We have no version block to write
        //... just write the version header and return

        nWritten = fwrite((void *)pVerHdr,
                          sizeof(char),
                          wVerHeadSize,
                          fpOutResFile);

        if (! UpdateResSize(fpOutResFile, &lResSizePos, (DWORD)nWritten)) {
            QuitT( IDS_ENGERR_07, (LPTSTR)IDS_VERSTAMP, NULL);
        }
        return (1);
    }

    wDataLen = pVerHdr->wTotLen;

    if ( wDataLen == 0 || wDataLen == (WORD)-1 ) {
        return (-1);             //... No resource data
    }
    //... Allocate buffer to hold New Version
    //... Stamping Block (make ne buffer large to
    //... account for expansion of strings during
    //... localization).

    pNewVerStamp = (PVERBLOCK)FALLOC( (nNewVerBlockSize = wDataLen * 4));

    //... Fill new memory block with zeros

    memset((void *)pNewVerStamp, 0, nNewVerBlockSize);

    //... Copy version header into buffer

    memcpy((void *)pNewVerStamp, (void *)pVerHdr, wVerHeadSize);
    pNewVerStamp->wLength = wVerHeadSize;

    //... Move to start of new version info block

    pNewBlk = (PVERBLOCK)((PBYTE)pNewVerStamp + wVerHeadSize);

    wDataLen -= wVerHeadSize;

    //... Fill in static part of TOKEN struct

    Tok.wType = ResHeader.wTypeID;
    Tok.wName = IDFLAG;
    Tok.szName[0] = TEXT('\0');
    Tok.szType[0] = TEXT('\0');
    Tok.wReserved = ST_TRANSLATED;

    //... Get a token for each string found in res

    while (wDataLen > 0) {
        WORD wRC;

        //... Start of a StringFileInfo block?
    #ifdef UNICODE
        wRC = (WORD)CompareStringW( MAKELCID( MAKELANGID( LANG_ENGLISH,
                                                          SUBLANG_ENGLISH_US),
                                              SORT_DEFAULT),
                                    0,
                                    pVerBlk->szKey,
                                    min( wDataLen, (WORD)STRINGFILEINFOLEN),
                                    STRINGFILEINFO,
                                    min( wDataLen, (WORD)STRINGFILEINFOLEN));
        if ( wRC == 2 )
    #else
        wRC = strncmp( pVerBlk->szKey,
                       STRINGFILEINFO,
                       min( wDataLen, (WORD)STRINGFILEINFOLEN));

        if ( wRC == SAME )
    #endif
        {
            WORD  wStringInfoLen = 0;   //... # of bytes in StringFileInfo
            WORD  wLen = 0;
            PVERBLOCK pNewStringInfoBlk; //... Start of this StringFileInfo blk


            pNewStringInfoBlk = pNewBlk;

            pNewStringInfoBlk->wLength    = 0; //... Gets fixed up later
            pNewStringInfoBlk->wValueLength = 0;
            pNewStringInfoBlk->wType      = pVerBlk->wType;

            lstrcpy( (TCHAR *)pNewStringInfoBlk->szKey, (TCHAR *)pVerBlk->szKey);

            //... Get # of bytes in this StringFileInfo
            //... (Length of value is always 0 here)

            wStringInfoLen = pVerBlk->wLength;

            //... Move to start of first StringTable blk.

            wLen = (WORD)(DWORDUP(sizeof(VERBLOCK)
                           - sizeof(TCHAR)
                           + MEMSIZE( STRINGFILEINFOLEN)));

            pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);
            pNewBlk = (PVERBLOCK)((PBYTE)pNewStringInfoBlk + wLen);

            DECWORDBY(&wDataLen,       wLen);
            DECWORDBY(&wStringInfoLen, wLen);

            INCWORDBY(&pNewVerStamp->wLength,      wLen);
            INCWORDBY(&pNewStringInfoBlk->wLength, wLen);

            while (wStringInfoLen > 0) {
                WORD      wStringTableLen = 0;
                PVERBLOCK pNewStringTblBlk = NULL;

                //... Get # of bytes in this StringTable
                //... (Length of value is always 0 here)

                wStringTableLen = pVerBlk->wLength;

                //... Copy StringFileInfo key into Token name

                Tok.wID = wTokNum++;
                Tok.wFlag = wTokContinueNum = 0;
                lstrcpy((TCHAR *)Tok.szName, (TCHAR *)LANGUAGEINFO);
                Tok.szText = NULL;

                //... Find token for this

                if ( ! FindToken( fpTokFile, &Tok, ST_TRANSLATED) ) {
                    //... token not found, flag error and exit.

                    ParseTokToBuf( (TCHAR *)szDHW, &Tok);
                    RLFREE( pNewVerStamp);
                    RLFREE( Tok.szText);
                    QuitT( IDS_ENGERR_05, (TCHAR *)szDHW, NULL);
                }
                Tok.wReserved = ST_TRANSLATED;

                //... Copy lang string into buffer

                pNewStringTblBlk = pNewBlk;

                pNewStringTblBlk->wLength      = 0; //... fixed up later
                pNewStringTblBlk->wValueLength = 0;
                pNewStringTblBlk->wType        = pVerBlk->wType;

                CopyMemory( pNewStringTblBlk->szKey,
                            Tok.szText,
                            MEMSIZE( LANGSTRINGLEN));

                RLFREE( Tok.szText);

                //... Move to start of first String.

                wLen = DWORDUP( sizeof(VERBLOCK)
                                - sizeof(TCHAR)
                                + MEMSIZE( LANGSTRINGLEN));

                pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);
                pNewBlk = (PVERBLOCK)((PBYTE)pNewBlk + wLen);

                DECWORDBY(&wDataLen,        wLen);
                DECWORDBY(&wStringInfoLen,  wLen);
                DECWORDBY(&wStringTableLen, wLen);

                INCWORDBY(&pNewVerStamp->wLength,      wLen);
                INCWORDBY(&pNewStringInfoBlk->wLength, wLen);
                INCWORDBY(&pNewStringTblBlk->wLength,  wLen);

                while ( wStringTableLen > 0 ) {
                    //... Is value a string?

                    if (pVerBlk->wType == VERTYPESTRING) {
                        wTokContinueNum = 0;

                        Tok.wID     = wTokNum++;
                        Tok.wReserved = ST_TRANSLATED;

                        lstrcpy( (TCHAR *)pNewBlk->szKey,
                                 (TCHAR *)pVerBlk->szKey);

                        pNewBlk->wLength =
                        DWORDUP(sizeof(VERBLOCK) +
                                MEMSIZE(lstrlen((TCHAR *)pNewBlk->szKey)));

                        Tok.wFlag   = wTokContinueNum++;

                        lstrcpy( (TCHAR *)Tok.szName, (TCHAR *)pVerBlk->szKey);

                        //... Find token for this

                        if ( ! FindToken( fpTokFile, &Tok, ST_TRANSLATED) ) {
                            //... token not found, flag error and exit.

                            ParseTokToBuf( (TCHAR *)szDHW, &Tok);
                            RLFREE( pNewVerStamp);
                            QuitT( IDS_ENGERR_05, (TCHAR *)szDHW, NULL);
                        }

                        Tok.wReserved = ST_TRANSLATED;

                        pNewBlk->wValueLength = (WORD)TextToBinW(
                                                                (TCHAR *)((PCHAR)pNewBlk + pNewBlk->wLength),
                                                                Tok.szText,
                                                                2048);

                        pNewBlk->wType    = VERTYPESTRING;
                        pNewBlk->wLength += MEMSIZE( pNewBlk->wValueLength);

                        INCWORDBY(&pNewVerStamp->wLength,
                                  DWORDUP(pNewBlk->wLength));
                        INCWORDBY(&pNewStringInfoBlk->wLength,
                                  DWORDUP(pNewBlk->wLength));
                        INCWORDBY(&pNewStringTblBlk->wLength,
                                  DWORDUP(pNewBlk->wLength));

                        pNewBlk = MoveAlongVer(pNewBlk, NULL, NULL, NULL);

                        RLFREE( Tok.szText);
                    }
                    //... Move to start of next String.

                    pVerBlk = MoveAlongVer(pVerBlk,
                                           &wDataLen,
                                           &wStringInfoLen,
                                           &wStringTableLen);

                }               //... END while wStringTableLen

            }                   //... END while wStringInfoLen
        } else {
            if (_tcsncmp((TCHAR *)pVerBlk->szKey,
                         (TCHAR *)VARFILEINFO,
                         min(wDataLen, (WORD)VARFILEINFOLEN)) == SAME) {
                WORD  wVarInfoLen = 0;  //... # of bytes in VarFileInfo
                WORD  wNewVarInfoLen = 0; //... # of bytes in new VarFileInfo
                WORD  wLen = 0;
                PVERBLOCK pNewVarStart = NULL; //... Start of VarInfo block


                wVarInfoLen = pVerBlk->wLength;
                pNewVarStart = pNewBlk;

                //... Get # of bytes in this VarFileInfo
                //... (Length of value is always 0 here)

                wLen = (WORD)(DWORDUP(sizeof(VERBLOCK)
                               - sizeof(TCHAR)
                               + MEMSIZE( VARFILEINFOLEN)));

                //... Copy non-localized header
                //... pNewVarStart->wLength field fixed up later

                memcpy((void *)pNewVarStart, (void *)pVerBlk, wLen);
                pNewVarStart->wLength = wLen;

                //... Move to start of first Var.

                pVerBlk = (PVERBLOCK)((PBYTE)pVerBlk + wLen);
                pNewBlk = (PVERBLOCK)((PBYTE)pNewBlk + wLen);

                DECWORDBY(&wDataLen, wLen);
                DECWORDBY(&wVarInfoLen, wLen);

                INCWORDBY(&pNewVerStamp->wLength, wLen);

                while (wDataLen > 0 && wVarInfoLen > 0) {
                    if (_tcsncmp((TCHAR *)pVerBlk->szKey,
                                 (TCHAR *)TRANSLATION,
                                 min(wDataLen, (WORD)TRANSLATIONLEN)) == SAME) {
                        WORD  wTransLen = 0;
                        PBYTE pValue = NULL;


                        wTokContinueNum = 0;

                        //... Copy VarFileInfo key into Token

                        Tok.wID     = wTokNum;
                        Tok.wFlag   = wTokContinueNum++;
                        Tok.szText  = NULL;
                        lstrcpy((TCHAR *)Tok.szName, (TCHAR *)TRANSLATION);

                        Tok.wReserved = ST_TRANSLATED;

                        pNewBlk->wLength =
                        DWORDUP(sizeof(VERBLOCK) +
                                MEMSIZE(lstrlen((TCHAR *)TRANSLATION)));

                        INCWORDBY(&pNewVerStamp->wLength, pNewBlk->wLength);
                        INCWORDBY(&pNewVarStart->wLength, pNewBlk->wLength);

                        pNewBlk->wValueLength = 0;  //... fixed up later
                        pNewBlk->wType = VERTYPEBINARY;
                        lstrcpy( (TCHAR *)pNewBlk->szKey, (TCHAR *)TRANSLATION);
                        lstrcpy((TCHAR *)Tok.szName, (TCHAR *)TRANSLATION);

                        //... Find token for this

                        if ( ! FindToken( fpTokFile, &Tok, ST_TRANSLATED) ) {
                            //... token not found, flag error and exit.

                            ParseTokToBuf((TCHAR *)szDHW, &Tok);
                            RLFREE( pNewVerStamp);
                            RLFREE( Tok.szText);
                            QuitT( IDS_ENGERR_05, (TCHAR *)szDHW, NULL);
                        } else {
                            PCHAR  pszLangIDs   = NULL;
                            PCHAR  pszLangStart = NULL;
                            WORD   wLangIDCount = 0;
                            size_t nChars;

                            //... Get # chars in input string (token text)

                            wTransLen = (WORD)lstrlen( Tok.szText);

                            pszLangIDs = (PCHAR)FALLOC( MEMSIZE( wTransLen + 1));

                            nChars = _WCSTOMBS( pszLangIDs,
                                                Tok.szText,
                                                MEMSIZE( wTransLen + 1),
                                                wTransLen + 1);

                            RLFREE( Tok.szText);

                            if ( ! nChars ) {
                                RLFREE( pNewVerStamp);
                                RLFREE( pszLangIDs);
                                QuitT( IDS_ENGERR_14,
                                       (LPTSTR)IDS_INVVERCHAR,
                                       NULL);
                            }

                            //... Where to put these bytes?

                            pValue = (PBYTE)GetVerValue( pNewBlk);

                            //... Get each lang ID in the token

                            for ( wLangIDCount = 0, pszLangStart = pszLangIDs;
                                wTransLen >= 2 * TRANSDATALEN;
                                ++wLangIDCount ) {
                                USHORT uByte1 = 0;
                                USHORT uByte2 = 0;
                                WORD   wIndex = 0;


                                if ( sscanf( pszLangStart,
                                             "%2hx%2hx",
                                             &uByte2,
                                             &uByte1) != 2 ) {
                                    QuitA( IDS_ENGERR_16,
                                           (LPSTR)IDS_ENGERR_21,
                                           pszLangStart);
                                }

                                wIndex = wLangIDCount * TRANSDATALEN;

                                pValue[ wIndex]     = (BYTE)uByte1;
                                pValue[ wIndex + 1] = (BYTE)uByte2;

                                INCWORDBY(&pNewVerStamp->wLength, TRANSDATALEN);
                                INCWORDBY(&pNewVarStart->wLength, TRANSDATALEN);
                                INCWORDBY(&pNewBlk->wLength,      TRANSDATALEN);
                                INCWORDBY(&pNewBlk->wValueLength, TRANSDATALEN);

                                //... Set up to get next lang ID in token

                                wTransLen    -= 2 * TRANSDATALEN;
                                pszLangStart += 2 * TRANSDATALEN;

                                while ( wTransLen > 2 * TRANSDATALEN
                                        && *pszLangStart != '\0'
                                        && isspace( *pszLangStart) ) {
                                    wTransLen--;
                                    pszLangStart++;
                                }
                            }   //... END for ( wLangIDCount = 0 ...
                            RLFREE( pszLangIDs);
                        }
                        Tok.wReserved = ST_TRANSLATED;

                    }           //... END if (_tcsncmp((TCHAR *)pVerBlk->szKey))

                    //... Move to start of next Var info block.

                    pVerBlk = MoveAlongVer(pVerBlk,
                                           &wDataLen,
                                           &wVarInfoLen,
                                           NULL);

                    pNewBlk = MoveAlongVer(pNewBlk, NULL, NULL, NULL);

                }               //... END while (wDataLen > 0 && wVarInfoLen)
            } else {
                RLFREE( pNewVerStamp);
                QuitT( IDS_ENGERR_14, (LPTSTR)IDS_INVVERBLK, NULL);
            }
        }
    }                           //... END while (wDataLen)

    //... write new version stamping information
    //... to the resource file

    nWritten = fwrite((void *)pNewVerStamp,
                      sizeof(char),
                      (WORD)lSize + pNewVerStamp->wLength,
                      fpOutResFile);

    if ( ! UpdateResSize( fpOutResFile,
                          &lResSizePos,
                          lSize + pNewVerStamp->wLength) ) {
        RLFREE(  pNewVerStamp);

        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_VERSTAMP, NULL);
    }
    RLFREE(  pNewVerStamp);

    return (0);
}

#else //... #ifdef RLRES32

int PutResVer(

             FILE     *OutResFile,
             FILE     *TokFile,
             RESHEADER ResHeader,
             VERHEAD  *pVerHdr,
             VERBLOCK *pVerBlk)
{

    TCHAR    *pszBuf;
    fpos_t    ResSizePos;
    WORD      wcLang = 0,
    wcBlock = 0;
    TOKEN     tok;
    VERBLOCK *pCurBlk;
    VERBLOCK *pNewBlk,
    *pNewBlkStart;
    TCHAR    *pszStr,
    pErrBuf[ 128];
    WORD     *pwVal;
    DWORD     lTotBlkSize,
    lSize = 0;
    int       wTotLen,
    wcCurBlkLen,
    wcTransBlkLen,
    wcRead;
    WORD     *pStrBlkSizeLoc,
    wStrBlkSize = 0;
    int       wcBlkLen;



    // write the Version resouce header

    if ( PutResHeader( OutResFile, ResHeader, &ResSizePos, &lSize) ) {
        QuitT( IDS_ENGERR_06, MAKEINTRESOURCE( IDS_VERSTAMP), NULL);
    }

    lSize = 0L;

    if ( pVerBlk == NULL ) {
        //... We have no version block to write
        //... just write the version header and return

        wcRead = fwrite( (void *)pVerHdr,
                         sizeof( char),
                         sizeof( VERHEAD),
                         OutResFile);

        if ( ! UpdateResSize( OutResFile, &ResSizePos, (DWORD)wcRead) ) {
            QuitT( IDS_ENGERR_07, MAKEINTRESOURCE( IDS_VERSTAMP), NULL);
        }
        return ( 1);
    }

    wTotLen = pVerBlk->nTotLen;


    // Allocate buffer to hold New Version Stamping Block

    pNewBlk = (VERBLOCK *)FALLOC( VERMEM));

    // Set new memory block to NULLS
    memset( (void *)pNewBlk, 0, VERMEM);

    // save start of new version info block
    pNewBlkStart = pNewBlk;
    wcTransBlkLen = sizeof(VERHEAD);
    lSize += wcTransBlkLen;

    // Insert version header info into new version info bluffer

    memcpy((void *)pNewBlk, (void *)pVerHdr, wcTransBlkLen);

    // Position pNewBlk point at location to insert next piece of version info
    pNewBlk = (VERBLOCK *) ((char *) pNewBlk +   wcTransBlkLen);


    // File in static part of TOKEN struct
    tok.wType     = ResHeader.wTypeID;
    tok.wName     = IDFLAG;
    tok.wReserved = ST_TRANSLATED;

    wTotLen = pVerBlk->nTotLen;
    pCurBlk = pVerBlk;

    tok.wID = wcLang++;
    pszStr = pCurBlk->szKey;

    wcCurBlkLen = 4 + DWORDUP(lstrlen((TCHAR *)pszStr) + 1);
    wTotLen -= wcCurBlkLen;


    // Insert StringFileInfo Header into new version info buffer
    // this info is not localized
    memcpy((void *)pNewBlk, (void *)pCurBlk, wcCurBlkLen);
    pszStr=pNewBlk->szKey;

    // reposition pointers
    pCurBlk = (VERBLOCK *) ((char *) pCurBlk + wcCurBlkLen);
    pNewBlk = (VERBLOCK *) ((char *) pNewBlk + wcCurBlkLen);

    lSize += wcCurBlkLen;

    // Read All the StringTableBlocks
    while (wTotLen > 8) {

        // For String tables blocks we localizes the key field
        tok.wFlag = ISKEY;

        wcBlkLen = pCurBlk->nTotLen;


        lstrcpy((TCHAR *)tok.szName, TEXT("Language Info"));
        tok.wID = wcBlock;
        tok.szText = NULL;

        if ((pszStr = FindTokenText (TokFile,&tok,ST_TRANSLATED)) == NULL) {
            // token not found, flag error and exit.
            ParseTokToBuf(pErrBuf, &tok);
            QuitT( IDS_ENGERR_05, pErrBuf, NULL);
        }

        RLFREE(tok.szText);
        tok.szText = NULL;

        tok.wReserved = ST_TRANSLATED;
        // Do not know length of the translated StringTable block
        // so set the nValLen to zero , and save location
        // of string file block size field, to be fixed up latter.

        pNewBlk->nValLen =  0;
        pStrBlkSizeLoc = (WORD *) &pNewBlk->nTotLen;

        // copy the translated key into that location
        TextToBin(pNewBlk->szKey,pszStr,VERMEM-2*sizeof(int));
        RLFREE( pszStr);

        // Update localized string block count

        wStrBlkSize = (WORD) DWORDUP (4 + lstrlen((TCHAR *)pNewBlk->szKey) + 1);

        // get the length of the current block, note the
        // translated length does not change.
        wcCurBlkLen = 4 + pVerBlk->nValLen + DWORDUP(lstrlen((TCHAR *)pCurBlk->szKey) + 1);
        lSize += wStrBlkSize;

        // Update counter vars
        wTotLen -= DWORDUP(wcBlkLen);
        wcBlkLen -= wcCurBlkLen;

        // repostion pointers
        pCurBlk = (VERBLOCK *) ((char *)pCurBlk + DWORDUP(wcCurBlkLen));
        pNewBlk = (VERBLOCK *) ((char *)pNewBlk + DWORDUP(wcCurBlkLen)) ;

        //  Read the String Blocks
        //  For String Blocks we localize the value fields.
        tok.wFlag = ISVAL;

        while (wcBlkLen > 0) {
            // for string blocks we translate the value fields.
            pszStr = pCurBlk->szKey;
            lstrcpy((TCHAR *)tok.szName, (TCHAR *)pszStr);
            tok.szText = NULL;

            if ((pszStr= FindTokenText(TokFile,&tok,ST_TRANSLATED)) == NULL) {
                //token not found, flag error and exit.
                ParseTokToBuf(pErrBuf, &tok);
                QuitT( IDS_ENGERR_05, pErrBuf, NULL);
            }
            RLFREE(tok.szText);
            tok.szText = NULL;

            tok.wReserved = ST_TRANSLATED;

            lstrcpy((TCHAR *)pNewBlk->szKey, (TCHAR *)pCurBlk->szKey);

            // position pointer to location to insert translated token text into pCurBlk
            pszBuf = (TCHAR*) pNewBlk + 4 +
                     DWORDUP(lstrlen((TCHAR *)pNewBlk->szKey) + 1);

            // now insert the token text
            TextToBin(pszBuf,
                      pszStr ,
                      VERMEM - (4+DWORDUP(lstrlen((TCHAR *)pNewBlk->szKey)+1)));
            RLFREE( pszStr);

            // fix up counter fields in pNewBlk
            pNewBlk->nValLen =  lstrlen((TCHAR *)pszBuf) + 1;
            pNewBlk->nTotLen = 4 + pNewBlk->nValLen +
                               DWORDUP(lstrlen((TCHAR *)pNewBlk->szKey) + 1);

            wcBlkLen -= DWORDUP(pCurBlk->nTotLen);

            lSize +=  DWORDUP(pNewBlk->nTotLen);
            wStrBlkSize +=  DWORDUP(pNewBlk->nTotLen);

            pCurBlk = (VERBLOCK *) ((char *) pCurBlk + DWORDUP(pCurBlk->nTotLen));
            pNewBlk = (VERBLOCK *) ((char *) pNewBlk + DWORDUP(pNewBlk->nTotLen));
        } // while
        wcBlock ++;
        *pStrBlkSizeLoc =   wStrBlkSize  ;
    }

    // this stuff is not translated so just copy it straight over
    // Skip past Head of VarInfoBlock
    pszStr = pCurBlk->szKey;
    wTotLen = pCurBlk->nTotLen;
    wcCurBlkLen = 4 + DWORDUP(pVerBlk->nValLen) +
                  DWORDUP(lstrlen((TCHAR *)pszStr) + 1);

    wTotLen -= wcCurBlkLen;

    // Insert Head of Var Info Into new block buffer
    memcpy((void *)pNewBlk, (void *)pCurBlk, wcCurBlkLen);

    pCurBlk = (VERBLOCK *) ((char *) pCurBlk + wcCurBlkLen);
    pNewBlk = (VERBLOCK *) ((char *) pNewBlk + wcCurBlkLen);

    lTotBlkSize = lSize;   // Save the size value for the total Version blk (PW)
    lSize += wcCurBlkLen;

    wcLang = 0;

    // Read the Var Info Blocks
    // For Var Info Blocks we localize the Translation Value field.
    tok.wFlag = ISVAL;

    while (wTotLen > 0) {
        pszStr = pCurBlk->szKey;
        lstrcpy((TCHAR *)tok.szName, TEXT("Translation"));
        tok.wID = wcLang;
        tok.szText = NULL;

        // Read Language ID

        if ((pszStr = FindTokenText(TokFile,  &tok,ST_TRANSLATED)) == NULL) {
            //token not found, flag error and exit.
            ParseTokToBuf(pErrBuf, &tok);
            QuitT( IDS_ENGERR_05, pErrBuf, NULL);
        }
        RLFREE(tok.szText);
        tok.szText = NULL;

        tok.wReserved = ST_TRANSLATED;

        // Found ascii translation string,
        // convert it to binary and insert into pCurBlk
        pwVal = (WORD *)((char *)pCurBlk +
                         DWORDUP(4 + lstrlen((TCHAR *)pCurBlk->szKey) + 1));

        *pwVal = MyAtoW((CHAR *)pszStr);
        pwVal++;
        *pwVal = MyAtoW((CHAR *)&pszStr[4]);

        wcLang ++;
        wTotLen -= DWORDUP(pCurBlk->nTotLen );
        memcpy((void *)pNewBlk, (void *)pCurBlk, pCurBlk->nTotLen);

        lSize += pCurBlk->nTotLen;

        // reposition pointers
        pCurBlk = (VERBLOCK *) ((char *) pCurBlk + DWORDUP(pCurBlk->nTotLen) + 4);
        pNewBlk = (VERBLOCK *) ((char *) pNewBlk + DWORDUP(pNewBlk->nTotLen) + 4);
        RLFREE( pszStr);

    }
    // Now fixup VerHeader Size. header not localized so
    // we do not need to update the value size.

    pVerHdr = (VERHEAD *) pNewBlkStart;
    pVerHdr->wTotLen = (WORD) lSize;

    // Update first size value of Version block (PW)
    wcTransBlkLen = sizeof (VERHEAD);
    pNewBlk = (VERBLOCK *) ((char *) pNewBlkStart + wcTransBlkLen);
    pNewBlk->nTotLen = (WORD) (lTotBlkSize - wcTransBlkLen);

    // write new version stamping information  to the resource file

    wcRead = fwrite( (void *)pNewBlkStart,
                     sizeof(char),
                     (size_t)lSize,
                     OutResFile);

    if (!UpdateResSize (OutResFile, &ResSizePos, lSize)) {
        QuitT( IDS_ENGERR_07, MAKEINTRESOURCE( IDS_VERSTAMP), NULL);
    }
    RLFREE( pNewBlkStart);
}

#endif //... RLRES32


/**
  *
  *
  *  Function: PutStrHdr.
  * Writes the string block info to the resource file.
  *
  *
  *  Arguments:
  * OutResFile, pointer to resource file being generated.
  * TokFile, pointer to token file containing localized string blocks.
  * ResHeader, structure containing Resource Header info for the string block.
  * pStrHder, Array of strings defined in the string block.
  *
  *
  *  Returns:
  * OutResFile, containing localized string blocks.
  *
  *  Errors Codes:
  * None.
  *
  *
  *  History:
  * 7/91. Implemented.              TerryRu.
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

void PutStrHdr( FILE * OutResFile,
                FILE * TokFile,
                RESHEADER ResHeader,
                STRINGHEADER *pStrHdr)
{
    static TOKEN tok;
    WORD    i, j, k;
    static TCHAR pErrBuf[MAXINPUTBUFFER];
    fpos_t ResSizePos;
    DWORD lSize = 0;

    // write the Menu Res header
    if ( PutResHeader (OutResFile, ResHeader , &ResSizePos, &lSize)) {
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_MENU, NULL);
    }

    lSize = 0L;

    for (i = 0; i < 16; i++) {
        tok.wType = ResHeader.wTypeID;
        tok.wName = ResHeader.wNameID;
        tok.wID = i;
        tok.wFlag = 0;
        tok.wReserved = ST_TRANSLATED;
        tok.szText = NULL;
        tok.szName[0] = 0;

        lstrcpy((TCHAR *)tok.szName, (TCHAR *)ResHeader.pszName);

        if ( ! FindToken(TokFile, &tok, ST_TRANSLATED) ) {
            // can not find token, terminate
            ParseTokToBuf( pErrBuf, &tok);
            QuitT( IDS_ENGERR_05, pErrBuf, NULL);
        }
        tok.wReserved = ST_TRANSLATED;

        // token text found continue
        {
            static TCHAR szTmp[4160];
            int    cChars = 0;  //... # chars in token text, including nul

            cChars = lstrlen( tok.szText) + 1;

            j = TextToBin( szTmp, tok.szText, cChars) - 1;
            RLFREE( tok.szText);

#ifdef RLRES16
            PutByte( OutResFile, (BYTE) j, &lSize);
#else
            PutWord( OutResFile, j, &lSize);
#endif

            for (k = 0; k < j; k++) {
#ifdef RLRES16
                PutByte( OutResFile, szTmp[k], &lSize);
#else
                PutWord( OutResFile, szTmp[k], &lSize);
#endif
            }
        }
    }

    if (!UpdateResSize (OutResFile, &ResSizePos , lSize)) {
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_MENU, NULL);
    }
}



/**
  *
  *
  *  Function: GetString.
  *    Read a block of 16 strings from string block in the resource file.
  *
  *  Arguments:
  *    InResFile, file pointer to location of string block in the
  *    resource file.
  *    lSize, dummy var not used.
  *
  *  Returns:
  *    pStrHdr containing 16 strings.
  *
  *
  *  Errors Codes:
  *    None.
  *
  *  History:
  *    7/91.       Implemented.            TerryRu.
  *
  *
  **/
STRINGHEADER *GetString( FILE *InResFile, DWORD *lSize)
{

    WORD wCharsLeft = 0;    // Count of remaining characters in the string
    WORD i = 0, j = 0;      // Indexes into current block of 16 strings

    STRINGHEADER *pStrHdr;

    pStrHdr = (STRINGHEADER *)FALLOC( sizeof( STRINGHEADER));

    for (j = 0; j < 16; j ++) {
#ifdef RLRES16
        wCharsLeft = pStrHdr->sChars[j] = (WORD)GetByte( InResFile, lSize);
#else
        wCharsLeft = pStrHdr->wChars[j] = GetWord( InResFile, lSize);
#endif
        pStrHdr->pszStrings[j] = (TCHAR *)FALLOC( MEMSIZE( wCharsLeft + 1));

        while ( wCharsLeft-- ) {
#ifdef RLRES32
            pStrHdr->pszStrings[j][i] = GetWord( InResFile, lSize);

#else  //RLRES32

            pStrHdr->pszStrings[j][i] = GetByte( InResFile, lSize);

#endif //RLRES32

            ++i;
        }
        pStrHdr->pszStrings[j][i] = TEXT('\0');
        i = 0;
    }
    return (pStrHdr);
}



/**
  *
  *
  *  Function: ReadInRes.
  * Reads a block of info from the input resource file, and
  *.    then writes the same info to the ouput resource file.
  *
  *
  *  Arguments:
  * InFile, handle of input file.
  * OutFile, handle of ouput file.
  * lSize, number of bytes to Copy.
  *
  *
  *  Returns:
  *
  *
  *  Errors Codes:
  * 8, read error.
  * 9, write error.
  *
  *  History:
  * 7/91, Implemented.                 TerryRu.
  * 11/91, Bug fix to copy more then 64k blocks.           PeterW.
  * 4/92, Bug fix to copy blocks in smaller chunks to save memory. SteveBl
  *
  **/
#define CHUNK_SIZE 5120

void ReadInRes( FILE *InFile, FILE *ResFile, DWORD *plSize )
{
    if ( *plSize > 0L ) {
        PBYTE   pBuf;
        size_t  cNum;
        size_t  cAmount;


        pBuf = (PBYTE)FALLOC( CHUNK_SIZE);

        do {
            cAmount = (*plSize > (DWORD)CHUNK_SIZE ? CHUNK_SIZE : *plSize);

            cNum = fread( (void *)pBuf, sizeof( BYTE), cAmount, InFile);

            if ( cNum != cAmount ) {
                QuitT( IDS_ENGERR_09, (LPTSTR)IDS_READ, NULL);
            }

            cNum = fwrite( (void *)pBuf, sizeof( BYTE), cAmount, ResFile);

            if ( cNum != cAmount) {
                QuitT( IDS_ENGERR_09, (LPTSTR)IDS_WRITE, NULL);
            }
            *plSize -= cAmount;

        } while ( *plSize);

        RLFREE( pBuf);
    }
}


/**
  *
  *
  *  Function: TokAccelTable
  * Reads array of accelerator keys, and writes info to be localized
  * to the token file.
  *
  *
  *  Arguments:
  *  TokeFile, file pointer of token file.
  *  ResHeader, Resource Header for Accelerator resource. This info
  * is need to generate token id.
  *  pAccelTable, array of accelerator keys.
  *  wcTableEntries, number of key definition in Accelerator table
  *
  *
  *  Returns:
  * Accelerator info to be localized writen to token file.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented.              TerryRu.
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

void   TokAccelTable (FILE *TokFile ,
                      RESHEADER ResHeader,
                      ACCELTABLEENTRY * pAccelTable,
                      WORD wcTableEntries)
{
    TOKEN tok;
    WORD  i, l;
    char  szBuf[10];

    tok.wType   = ResHeader.wTypeID;
    tok.wName   = ResHeader.wNameID;
    tok.wFlag   = 0;
    tok.wReserved = (gbMaster ? ST_NEW : ST_NEW | ST_TRANSLATED);

    lstrcpy( tok.szName,  ResHeader.pszName);

    for (i = 0; i < wcTableEntries ; i ++) {
        tok.wFlag = (WORD) pAccelTable[i].fFlags;
        tok.wID = i;

        // The order of wID and wAscii is reverse to the
        // oder in the accelerator structure and the .rc file

        sprintf( szBuf, "%hu %hu", pAccelTable[i].wID, pAccelTable[i].wAscii);

        l = lstrlenA( szBuf) + 1;
        tok.szText = (TCHAR *)FALLOC( MEMSIZE( l));
#ifdef RLRES32
        _MBSTOWCS( (TCHAR *)tok.szText, szBuf, l, l);
#else
        lstrcpyA(tok.szText, szBuf);
#endif
        PutToken(TokFile, &tok);
        RLFREE( tok.szText);
    }
}


/**
  *
  *
  *  Function: TokDialog.
  *     Travers through linked list of the Dialog defintion, and writes any info
  *     which requires localization to the token file.
  *
  *
  *  Arguments:
  *     TokFile, file pointer of token file.
  *     ResHeader, Resource header info of dialog resource. This info is needed
  *     to generate the token id.
  *     pDialogHdr, linked list of dialog info. Each dialog control is a node
  *     in the linked list.
  *
  *
  *  Returns:
  *     The info requiring localization written to the tok file.
  *
  *  Errors Codes:
  *     None.
  *
  *  History:
  *     7/91. Implemented.                          TerryRu.
  *     7/91. Now tokenize all control cordiantes, so they are
  *     maintained during updates.                  TerryRu.
  *     8/91. Supported signed coordinates.         TerryRu.
  *     1/93. Now tokenize dlg font names.          TerryRu
  *     01/93 Add support for var length token text MHotchin
  **/

void TokDialog( FILE * TokFile, RESHEADER ResHeader, DIALOGHEADER  *pDialogHdr)
{
    WORD wcDup = 0;
    WORD *pwIdBuf;
    WORD i, j = 0, k = 0, l = 0;
    static CHAR  szTmpBuf[256];
    static TCHAR szBuf[256];
    static TOKEN tok;


    *szTmpBuf = '\0';
    *szBuf    = TEXT('\0');

    // tok the dialog caption
    tok.wType   = ResHeader.wTypeID;
    tok.wName   = ResHeader.wNameID;
    tok.wID     = 0;
    tok.wFlag   = ISCAP;
    tok.wReserved = (gbMaster ? ST_NEW : ST_NEW | ST_TRANSLATED);

    lstrcpy ((TCHAR *)tok.szName , (TCHAR *)ResHeader.pszName);

    tok.szText = BinToText( pDialogHdr->pszCaption,
                            lstrlen( pDialogHdr->pszCaption));
    PutToken(TokFile, &tok);
    RLFREE( tok.szText);

    // tok the dialog cordinates
    // bug fix, cordinates can be signed.
    tok.wFlag = (ISCAP) | (ISCOR);

#ifdef RLRES32
    sprintf( szTmpBuf, "%4hd %4hd %4hd %4hd",
             pDialogHdr->x,
             pDialogHdr->y,
             pDialogHdr->cx,
             pDialogHdr->cy);

    if ( gfShowClass ) {
        sprintf( &szTmpBuf[ strlen( szTmpBuf)], " : TDB");
    }
    _MBSTOWCS( szBuf,
               szTmpBuf,
               WCHARSIN( sizeof( szBuf)),
               ACHARSIN( lstrlenA( szTmpBuf ) + 1 ));
#else
    sprintf( szBuf, "%4hd %4hd %4hd %4hd",
             pDialogHdr->x,
             pDialogHdr->y,
             pDialogHdr->cx,
             pDialogHdr->cy);
#endif

    tok.szText = BinToText( szBuf, lstrlen( szBuf));

    PutToken(TokFile, &tok);
    RLFREE( tok.szText);

    if (gfExtendedTok) {
        // toknize dialog fontname, and size

        if ( pDialogHdr->lStyle & DS_SETFONT ) {
            tok.wFlag = ISDLGFONTSIZE;
            sprintf(szTmpBuf, "%hu", pDialogHdr->wPointSize);
            l = lstrlenA( szTmpBuf) + 1;
            tok.szText = (TCHAR *)FALLOC( MEMSIZE( l));
#ifdef RLRES32
            _MBSTOWCS( (TCHAR*) tok.szText, szTmpBuf, l, l);
#else
            strcpy(tok.szText, szTmpBuf);
#endif

            PutToken(TokFile, &tok);
            RLFREE( tok.szText);

            tok.wFlag = ISDLGFONTNAME;
            tok.szText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( pDialogHdr->pszFontName) + 1));
            lstrcpy( tok.szText, pDialogHdr->pszFontName);

            PutToken( TokFile, &tok);
            RLFREE( tok.szText);
            tok.szText = NULL;
        }
    }

    // allocate buffer for for duplicate check
    pwIdBuf = (WORD *) FALLOC((DWORD) pDialogHdr->wNumberOfItems * sizeof(WORD));


    for (i = 0; i < (WORD) pDialogHdr->wNumberOfItems; i ++) {
        if (isdup ((WORD)pDialogHdr->pCntlData[i].dwID, pwIdBuf, (WORD)j)) {
            tok.wID = (USHORT)wcDup++;
            tok.wFlag = ISDUP;
        } else {
            // wid is unique so store in buffer for dup check
            pwIdBuf[j++] = (USHORT)pDialogHdr->pCntlData[i].dwID;

            tok.wID = (USHORT)pDialogHdr->pCntlData[i].dwID;
            tok.wFlag = 0;
        }

        if (pDialogHdr->pCntlData[i].pszDlgText[0]) {
            tok.szText = BinToText( pDialogHdr->pCntlData[i].pszDlgText,
                                    lstrlen( (TCHAR *)pDialogHdr->pCntlData[i].pszDlgText));

            PutToken(TokFile, &tok);
            RLFREE( tok.szText);
        }

        // now do the dialog corrdinates,
        // bug fix, cordinates can be signed.

#ifdef RLRES32
        sprintf( szTmpBuf,
                 "%4hd %4hd %4hd %4hd",
                 pDialogHdr->pCntlData[i].x,
                 pDialogHdr->pCntlData[i].y,
                 pDialogHdr->pCntlData[i].cx,
                 pDialogHdr->pCntlData[i].cy);

        _MBSTOWCS( szBuf,
                   szTmpBuf,
                   WCHARSIN( sizeof ( szBuf)),
                   ACHARSIN( lstrlenA( szTmpBuf ) + 1));

        if (gfExtendedTok)
            if ( (pDialogHdr->pCntlData[i].bClass_Flag == IDFLAG)
                 && ((pDialogHdr->pCntlData[i].bClass == STATIC)
                     || (pDialogHdr->pCntlData[i].bClass == EDIT) ) ) {
                TCHAR *pszCtrl[3] =
                {
                    TEXT("LEFT"),
                    TEXT("CENTER"),
                    TEXT("RIGHT")
                };
                TCHAR *pszAlign = NULL;
                DWORD dwStyle   = pDialogHdr->pCntlData[i].lStyle;

                if ( pDialogHdr->pCntlData[i].bClass == STATIC ) {
                    // STATIC class alignment values are constants
                    // not flags, so we handle them differently
                    // than we do for the EDIT class below.

                    dwStyle &= (SS_LEFT|SS_CENTER|SS_RIGHT);

                    if ( dwStyle == SS_RIGHT ) {
                        pszAlign = pszCtrl[2];
                    } else if ( dwStyle == SS_CENTER ) {
                        pszAlign = pszCtrl[1];
                    } else if ( dwStyle == SS_LEFT ) {
                        pszAlign = pszCtrl[0];
                    }
                } else {                // Dealing with an EDIT class
                    if ( dwStyle & ES_RIGHT ) {
                        pszAlign = pszCtrl[2];
                    } else if ( dwStyle & ES_CENTER ) {
                        pszAlign = pszCtrl[1];
                    } else if ( dwStyle & ES_LEFT ) {
                        pszAlign = pszCtrl[0];
                    }
                }

                if ( pszAlign ) {
                    _stprintf( &szBuf[ _tcslen( szBuf)], TEXT(" ( %s ) "), pszAlign);
                }
            }

        if ( gfShowClass ) {
            if ( pDialogHdr->pCntlData[i].bClass_Flag == IDFLAG ) {
                TCHAR *pszCtrl = TEXT("???");    //... DLG box control class

                switch ( pDialogHdr->pCntlData[i].bClass ) {
                    case BUTTON:
                        {
                            WORD  wTmp;

                            wTmp = (WORD)(pDialogHdr->pCntlData[i].lStyle & 0xffL);

                            switch ( wTmp ) {

                                case BS_PUSHBUTTON:
                                case BS_DEFPUSHBUTTON:

                                    pszCtrl = TEXT("BUT");
                                    break;

                                case BS_CHECKBOX:
                                case BS_AUTOCHECKBOX:
                                case BS_3STATE:
                                case BS_AUTO3STATE:

                                    pszCtrl = TEXT("CHX");
                                    break;

                                case BS_RADIOBUTTON:
                                case BS_AUTORADIOBUTTON:

                                    pszCtrl = TEXT("OPT");
                                    break;

                                case BS_GROUPBOX:
                                case BS_USERBUTTON:
                                case BS_OWNERDRAW:
                                case BS_LEFTTEXT:
                                default:

                                    pszCtrl = TEXT("DIA");
                                    break;

                            }   //... END switch( wTmp )
                            break;
                        }
                    case STATIC:

    #ifdef DBCS
//Special hack
//I will remove this code later.
//This code is for fix code between 1.84 and 1.85(STATIC alignment problem)

                        {
                            WORD  wTmp;

                            wTmp = (WORD)(pDialogHdr->pCntlData[i].lStyle & (SS_LEFT|SS_CENTER|SS_RIGHT));
                            if ( (wTmp==SS_CENTER)
                                 || (wTmp==SS_LEFT) || (wTmp==SS_RIGHT) ) {
                                pszCtrl = TEXT("TXB");
                            } else {
                                pszCtrl = TEXT("ICO");
                            }
                            break;
                        }
    #else // not DBCS
                        pszCtrl = TEXT("TXB");
                        break;
    #endif // DBCS
                    default:

                        pszCtrl = TEXT("DIA");
                        break;

                }   //... END switch ( pDialogHdr->pCntlData[i].bClass )

                wsprintf( &szBuf[ lstrlen( szBuf)], TEXT(" : %s"), pszCtrl);
            } else {
                wsprintf( &szBuf[ lstrlen( szBuf)],
                          TEXT(" : \"%s\""),
                          pDialogHdr->pCntlData[i].pszClass);
            }
        }

#else
        sprintf(szBuf, "%4hd %4hd %4hd %4hd",
                pDialogHdr->pCntlData[i].x,
                pDialogHdr->pCntlData[i].y,
                pDialogHdr->pCntlData[i].cx,
                pDialogHdr->pCntlData[i].cy);
#endif

        tok.wFlag |= ISCOR;

        tok.szText = BinToText( szBuf, lstrlen( (TCHAR *)szBuf));
        PutToken(TokFile, &tok);
        RLFREE( tok.szText);
        tok.szText = NULL;
    }
    RLFREE( pwIdBuf);
    pwIdBuf = NULL;
}


/**
  *
  *
  * Function: TokMenu,
  * Travers the linked list of the Menu definition, and writes any info
  * requiring localization to the token file.
  *
  *
  *  Arguments:
  * TokFile, file pointer of token file.
  * ResHeader, Resource header  of Menu info. Need to generate token ids.
  * pMenuHdr, Header of the menu used to access the linked list of token info.
  *
  *  Returns:
  * TokenFile contain all info requiring localization.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented.              TerryRu.
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

void TokMenu(FILE *TokFile ,   RESHEADER ResHeader, MENUHEADER *pMenuHdr)
{
    TOKEN tok;
    static WORD  wcPopUp = 0;
    MENUITEM *pMenuItem;

    pMenuItem = pMenuHdr->pMenuItem;

    tok.wReserved = (gbMaster? ST_NEW : ST_NEW | ST_TRANSLATED);

    while (pMenuItem) {
        // if Menu Item is a seperator skip it
        if (*pMenuItem->szItemText) {
            tok.wType = ResHeader.wTypeID;
            tok.wName = ResHeader.wNameID;

            // check for the popup menu items
            if ((pMenuItem->fItemFlags & MFR_POPUP) && pMenuHdr->fMenuEx) {
                tok.wID = (pMenuItem->dwMenuID == 0 ||
                           pMenuItem->dwMenuID == 0x0000ffff) ?
                          (USHORT)pMenuItem->dwMenuID : 0x8000 + wcPopUp++;
                tok.wFlag = ISPOPUP;
            } else if (pMenuItem->fItemFlags & POPUP) {
                tok.wID = wcPopUp++;
                tok.wFlag = ISPOPUP;
            } else {
                tok.wID = (USHORT)pMenuItem->dwMenuID;
                tok.wFlag = 0;
            }
            lstrcpy ((TCHAR *)tok.szName, (TCHAR *)ResHeader.pszName);

            tok.szText = BinToText( pMenuItem->szItemText,
                                    lstrlen( (TCHAR *)pMenuItem->szItemText));
            PutToken (TokFile, &tok);
            RLFREE( tok.szText);
        }
        pMenuItem = pMenuItem->pNextItem;
    }
}



/**
  *
  *
  *  Function: TokString
  * Write the 16 strings contained in the  string block.
  *
  *
  *  Arguments:
  * TokFile, file pointer of Token File.
  * ResHeader, Resource header info of String block.
  * pStrHdr, Array of 16 strings making up portion of the string table.
  *
  *  Returns:
  * Strings written to the Token File.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented.              TerryRu.
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

void TokString( FILE * TokFile, RESHEADER ResHeader, STRINGHEADER * pStrHdr)
{
//    int   nLen;
    TOKEN tok;
    BYTE  i;



    for ( i = 0; i < 16; i++ ) {
        tok.wType   = ResHeader.wTypeID;
        tok.wName   = ResHeader.wNameID;
        tok.wID     = i;
        tok.wFlag   = 0;
        tok.wReserved = (gbMaster ? ST_NEW : ST_NEW | ST_TRANSLATED);

        lstrcpy( (TCHAR *)tok.szName, (TCHAR *)ResHeader.pszName);

//        nLen = lstrlen( (TCHAR *)pStrHdr->pszStrings[i]);        //DHW_TOOLONG

        tok.szText = BinToText( (TCHAR *)pStrHdr->pszStrings[i], pStrHdr->wChars[i]);

        PutToken( TokFile, &tok);
        RLFREE( tok.szText);
    }
}


#ifdef RLRES32

//................................................................
//...
//... Move to start of value field in version resource blocks
//... and adjust remaining-data-sizes accordingly.

PVERBLOCK MoveAlongVer(

                      PVERBLOCK pVerData, //... Start of current version block
                      WORD     *pw1,      //... First word to decrement
                      WORD     *pw2,      //... Second word to decrement
                      WORD     *pw3)      //... Third word to decrement
{
    WORD  wLen;
    PBYTE pData = (PBYTE)pVerData;


    wLen = DWORDUP( pVerData->wLength);

    pData += DWORDUP( wLen);

    DECWORDBY( pw1, wLen);
    DECWORDBY( pw2, wLen);
    DECWORDBY( pw3, wLen);

    return ( (PVERBLOCK)pData);
}

//....................................................................



TCHAR *GetVerValue( PVERBLOCK pVerData)
{
    WORD  wLen = sizeof( VERBLOCK);

    //... sizeof(VERBLOCK) already includes
    //... the size of a WCHAR so we do not
    //... need to add 1 to length of the key.

    wLen += (WORD) (BYTESINSTRING( pVerData->szKey));
    wLen = DWORDUP( wLen);      //... Possible DWORD padding

    return ( (TCHAR *)((PBYTE)pVerData + wLen));
}

//....................................................................

#endif  //... RLRES32


/**
  *
  *
  *  Function: TokResVer
  * Reads through the Version Info blocks, and writes any info requiring
  * localization to the token file.
  *
  *
  *  Arguments:
  * TokeFile, file pointer of token file.
  * ResHeader, Resource Header info for version stamping. Need to generate
  * the token IDs.
  *
  *  Returns:
  *
  *  Errors Codes:
  * 1, info written to token file.
  *
  *  History:
  * 11/91. Implemented.             TerryRu.
  * 10/92.  Added RLRES32 version     DaveWi
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

#ifdef RLRES32

int TokResVer(

             FILE     *fpTokFile,      //... Output token file
             RESHEADER ResHeader,      //... Resource header of version resource
             VERBLOCK *pVerData,       //... Data to tokenize
             WORD      wDataLen)       //... # bytes in pVerData
{
    TOKEN  Tok;
    BOOL   fInStringInfo = FALSE;   //... TRUE if reading StringFileInfo
    WORD   wTokNum   = 0;           //... Put into Tok.wID field
    WORD   wTokContinueNum = 0;     //... Put into Tok.wFlag field


    if (wDataLen == 0 || wDataLen == (WORD)-1) {
        return (-1);             //... No data to tokenize
    }
    //... Fill in static part of TOKEN struct

    Tok.wType   = ResHeader.wTypeID;
    Tok.wName   = IDFLAG;
    Tok.szName[0] = TEXT('\0');
    Tok.szType[0] = TEXT('\0');
    Tok.wReserved = (gbMaster? ST_NEW : ST_NEW | ST_TRANSLATED);


    //... Make a token for each string found

    while (wDataLen > 0) {
        WORD wRC;

        //... Start of a StringFileInfo block?

        wRC =(WORD)_tcsncmp((TCHAR *)pVerData->szKey,
                            (TCHAR *)STRINGFILEINFO,
                            min(wDataLen, (WORD)STRINGFILEINFOLEN));

        if (wRC == SAME) {
            WORD  wStringInfoLen = 0;   //... # of bytes in StringFileInfo
            WORD  wLen = 0;

            //... Get # of bytes in this StringFileInfo
            //... (Length of value is always 0 here)

            wStringInfoLen = pVerData->wLength;

            //... Move to start of first StringTable blk.

            wLen = (WORD)(DWORDUP(sizeof(VERBLOCK)
                           - sizeof(WCHAR)
                           + MEMSIZE( STRINGFILEINFOLEN)));

            pVerData = (PVERBLOCK)((PBYTE)pVerData + wLen);
            DECWORDBY(&wDataLen, wLen);
            DECWORDBY(&wStringInfoLen, wLen);

            while (wStringInfoLen > 0) {
                WORD  wStringTableLen = 0;

                //... Get # of bytes in this StringTable
                //... (Length of value is always 0 here)

                wStringTableLen = pVerData->wLength;

                //... Copy Language BLOCK Info key
                //... into Token name

                lstrcpy((TCHAR *)Tok.szName, (TCHAR *)LANGUAGEINFO);

                //... Copy lang string into token

                Tok.szText = (TCHAR *) FALLOC(MEMSIZE(LANGSTRINGLEN+1));
                CopyMemory( Tok.szText,
                            pVerData->szKey,
                            LANGSTRINGLEN * sizeof ( TCHAR));

                Tok.szText[ LANGSTRINGLEN] = TEXT('\0');

                Tok.wID = wTokNum++;
                Tok.wFlag = 0;

                PutToken(fpTokFile, &Tok);
                RLFREE( Tok.szText);

                //... Move to start of first String.

                wLen = DWORDUP(sizeof(VERBLOCK)
                               - sizeof(WCHAR)
                               + MEMSIZE( LANGSTRINGLEN));

                pVerData = (PVERBLOCK)((PBYTE)pVerData + wLen);

                DECWORDBY(&wDataLen, wLen);
                DECWORDBY(&wStringInfoLen, wLen);
                DECWORDBY(&wStringTableLen, wLen);

                while (wStringTableLen > 0) {
                    //... Is value a string?

                    if (pVerData->wType == VERTYPESTRING) {
                        Tok.wID = wTokNum++;

                        lstrcpy( (TCHAR *)Tok.szName, (TCHAR *)pVerData->szKey);
                        Tok.szText = BinToText( GetVerValue( pVerData),
                                                lstrlen( GetVerValue( pVerData)));

                        PutToken(fpTokFile, &Tok);
                        RLFREE( Tok.szText);
                    }
                    //... Move to start of next String.

                    pVerData = MoveAlongVer(pVerData,
                                            &wDataLen,
                                            &wStringInfoLen,
                                            &wStringTableLen);

                }               //... END while (wStringTableLen)

            }                   //... END while (wStringInfoLen)
        } else {
            if (_tcsncmp((TCHAR *)pVerData->szKey,
                         (TCHAR *)VARFILEINFO,
                         min(wDataLen, (WORD)VARFILEINFOLEN)) == SAME) {
                WORD  wVarInfoLen = 0;  //... # of bytes in VarFileInfo
                WORD  wLen = 0;

                //... Get # of bytes in this VarFileInfo
                //... (Length of value is always 0 here)

                wVarInfoLen = pVerData->wLength;

                //... Move to start of first Var.

                wLen = (WORD)(DWORDUP(sizeof(VERBLOCK)
                               - sizeof(WCHAR)
                               + MEMSIZE( VARFILEINFOLEN)));
                pVerData = (PVERBLOCK)((PBYTE)pVerData + wLen);

                DECWORDBY(&wDataLen, wLen);
                DECWORDBY(&wVarInfoLen, wLen);

                while (wVarInfoLen > 0) {
                    if (_tcsncmp(pVerData->szKey,
                                 TRANSLATION,
                                 min( wDataLen, (WORD)TRANSLATIONLEN)) == SAME) {
                        PBYTE  pValue = NULL;
                        WORD   wTransLen = 0;
                        USHORT uByte1 = 0;
                        USHORT uByte2 = 0;
                        UINT   uLen   = 0;

                        wTokContinueNum = 0;

                        //... How many bytes are we to tokenize?

                        wTransLen = pVerData->wValueLength;

                        //... Where are those bytes?

                        pValue = (PBYTE)GetVerValue(pVerData);

                        //... Copy VarFileInfo into Token

                        lstrcpy((TCHAR *)Tok.szName, (TCHAR *)pVerData->szKey);

                        //... Allocate a buffer for a space-separated
                        //... list of the lang ID's in this vresion res.

                        *szDHW = '\0';

                        while ( wTransLen >= TRANSDATALEN ) {
                            //... Write translation language id by
                            //... reversing byte pairs so the id looks
                            //... like the language id string.  This will
                            //... have to be undone in PutResVer().

                            uByte1 = *pValue;
                            uByte2 = *(pValue + 1);

                            sprintf( &szDHW[ lstrlenA( szDHW)],
                                     "%02hx%02hx",
                                     uByte2,    //... Reverses byte order to
                                     uByte1);   //... be like transltn str.

                            //... Move to next possible translation value

                            wTransLen -= TRANSDATALEN;

                            if ( wTransLen >= TRANSDATALEN ) {
                                pValue += TRANSDATALEN;
                                strcat( szDHW, " ");   //... white-space sep
                            }
                        }       //... END while ( wTransLen ...

                        uLen = lstrlenA( szDHW) + 1;
                        Tok.szText = (TCHAR *)FALLOC( MEMSIZE( uLen));
                        _MBSTOWCS( (TCHAR *)Tok.szText, szDHW, uLen, (UINT)-1);

                        Tok.wID   = wTokNum;
                        Tok.wFlag = wTokContinueNum++;

                        PutToken( fpTokFile, &Tok);

                        RLFREE( Tok.szText);
                    }           //... END if (_tcsncmp( ...

                    //... Move to start of next Var info block.

                    pVerData = MoveAlongVer(pVerData,
                                            &wDataLen,
                                            &wVarInfoLen,
                                            NULL);

                }               //... END while (wVarInfoLen)
            } else {
                QuitT( IDS_ENGERR_14, (LPTSTR)IDS_INVVERBLK, NULL);
            }
        }
    }                           //... END while (wDataLen)
    return (0);
}

#else //... RLRES32

int TokResVer(FILE * TokFile, RESHEADER ResHeader, VERBLOCK *pVerBlk)
{
    TCHAR szLangIdBuf[20];
    TCHAR szCodePageIdBuf[20];
    #ifdef RLRES32
    CHAR  szTmpBuf[20];
    #endif
    WORD wcLang = 0, wcBlock = 0;
    TOKEN tok;
    VERBLOCK  *pCurBlk;
    TCHAR *pszStr;
    DWORD *pdwVal;
    int    wTotLen, nHeadLen, wBlkLen;


    // the count fields are int because count may go negative
    // because the last DWORD alignment is not counted in the
    // byte count.

    // Fill in static part of TOKEN struct
    tok.wType   = ResHeader.wTypeID;
    tok.wName   = IDFLAG;
    tok.wReserved =  (gbMaster? ST_NEW : ST_NEW |  ST_TRANSLATED);


    wTotLen = DWORDUP(pVerBlk->nTotLen);

    tok.wID = wcBlock;
    pszStr = pVerBlk->szKey;
    nHeadLen = 4 + DWORDUP(pVerBlk->nValLen) + DWORDUP(lstrlen((TCHAR *)pszStr) + 1);

    wTotLen -= nHeadLen;
    pCurBlk = (VERBLOCK *) ((TCHAR *) pVerBlk + nHeadLen);

    while (wTotLen > 0) {
        // For string file tables we localize the key field
        tok.wFlag = ISKEY;
        wBlkLen = DWORDUP(pCurBlk->nTotLen);
        pszStr = pCurBlk->szKey;

        tok.szText = BinToText( pszStr, lstrlen((TCHAR *)pszStr));

        lstrcpy((TCHAR *)tok.szName, TEXT("Language Info"));
        tok.wID = wcBlock;

        PutToken(TokFile, &tok);
        RLFREE(tok.szText);

        // Get offset to next block;
        nHeadLen = 4 +
                   DWORDUP(pVerBlk->nValLen) +
                   DWORDUP(lstrlen((TCHAR *)pszStr) + 1);

        // Update counter vars

        wTotLen -= wBlkLen;
        wBlkLen -= nHeadLen;

        // set pointer to next ver block
        pCurBlk = (VERBLOCK*) ((TCHAR *) pCurBlk + nHeadLen);

        // For string blocks we localize the value field.
        tok.wFlag = ISVAL;

        // Now output the tokens in String Block
        while (wBlkLen>0) {
            pszStr = pCurBlk->szKey;
            lstrcpy((TCHAR *)tok.szName, (TCHAR *)pszStr);
            pszStr = (TCHAR *) pCurBlk+4+DWORDUP(lstrlen((TCHAR *)pszStr)+1);

            tok.szText = BinToText( pszStr, lstrlen((TCHAR *)pszStr));
            PutToken(TokFile, &tok);
            RLFREE(tok.szText);

            wBlkLen -= DWORDUP(pCurBlk->nTotLen);
            pCurBlk = (VERBLOCK *) ((TCHAR *) pCurBlk + DWORDUP(pCurBlk->nTotLen));
        }
        wcBlock++;
    }

    // Skip past Head of VarInfoBlock

    wTotLen = DWORDUP(pCurBlk->nTotLen);

    pszStr = pCurBlk->szKey;
    nHeadLen = 4 + DWORDUP(pVerBlk->nValLen) + DWORDUP(lstrlen((TCHAR *)pszStr) + 1);
    wTotLen -= nHeadLen;
    pCurBlk = (VERBLOCK *)((TCHAR *) pCurBlk + nHeadLen);

    wcLang = 0;

    // In Var File blocks we localize the value fields.

    tok.wFlag = ISVAL;

    while (wTotLen > 0) {
        TCHAR szTemp[256];

        pszStr = pCurBlk->szKey;
        tok.wID = wcLang;
        lstrcpy((TCHAR *)tok.szName, TEXT("Translation"));
        pdwVal = (DWORD *)((TCHAR *) pCurBlk + 4 + DWORDUP(lstrlen((TCHAR *)pszStr) + 1));
    #ifdef RLRES32
        _itoa(HIWORD(*pdwVal) , szTmpBuf, 16);
        _MBSTOWCS( szLangIdBuf,
                   szTmpBuf,
                   WCHARSIN( sizeof( szLangIdBuf)),
                   ACHARSIN( strlen( szTmpBuf ) + 1));
    #else

        _itoa(HIWORD(*pdwVal) , szLangIdBuf, 16);
    #endif

    #ifdef RLRES32
        _itoa(LOWORD(*pdwVal), szTmpBuf, 16);
        _MBSTOWCS( szCodePageIdBuf,
                   szTmpBuf,
                   WCHARSIN( sizeof( szCodePageIdBuf)),
                   ACHARSIN( strlen( szTmpBuf ) + 1));
    #else
        _itoa(LOWORD(*pdwVal), szCodePageIdBuf, 16);
    #endif


        // Construct Token Text
        // Note leading zeros gets lost in itoa translation
        lstrcpy((TCHAR *)szTemp, TEXT("0"));
        _tcscat((TCHAR *)szTemp, _tcsupr((TCHAR *)szCodePageIdBuf));
        _tcscat((TCHAR *)szTemp, TEXT("0"));
        _tcscat((TCHAR *)szTemp, _tcsupr((TCHAR *)szLangIdBuf));

        tok.szText = BinToText( szTemp, lstrlen((TCHAR *)szTemp));
        PutToken(TokFile, &tok);
        RLFREE(tok.szText);
        wcLang ++;
        wTotLen -= DWORDUP(pCurBlk->nTotLen);
        pCurBlk = (VERBLOCK *) ((BYTE *) pCurBlk + DWORDUP(pCurBlk->nTotLen));
    }
    return (1);
}

#endif //... RLRES32


/**
  *
  *
  *  Function: UpdateResSize
  * Preforms the Resource Header size fixup, once the size of
  * the localized resource block is determined.
  *
  *
  *  Arguments:
  * OutResFile, File pointer of localized resource file.
  * pResSizePos, file location of size file, of the resoure header.
  * lSize, size of the localized resource.
  *
  *  Returns:
  * The size field fixed up to the value specfied in the lsize.
  *
  *  Errors Codes:
  * TRUE, fixup sucessfull.
  * Result of fsetpos, and fgetpos call.
  *
  *  History:
  *
  *
  **/

WORD    UpdateResSize (FILE * OutResFile, fpos_t *pResSizePos, DWORD lSize)
{
    WORD rc;
    fpos_t tResSizePos;

    if ((rc = (WORD) fgetpos (OutResFile, &tResSizePos)) != 0) {
        return (rc);
    }

    if ((rc = (WORD) fsetpos (OutResFile, pResSizePos)) != 0) {
        return (rc);
    }

    PutdWord(OutResFile, lSize, NULL);

    if ((rc = (WORD) fsetpos (OutResFile, &tResSizePos)) != 0) {
        return (rc);
    }

    return (TRUE) ;
}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

void PutAccelTable(FILE    *OutResFile,
                   FILE    *TokFile,
                   RESHEADER       ResHeader,
                   ACCELTABLEENTRY *pAccelTable,
                   WORD    wcAccelEntries)

{
    fpos_t ResSizePos = 0;
    TOKEN  tok;
    WORD   wcCount = 0;
    DWORD  lSize = 0L;
    TCHAR  pErrBuf[MAXINPUTBUFFER];
#ifdef RLRES32
    CHAR   szTmpBuf[30];
#endif
    TCHAR  *cpAscii, *cpID;

    if ( PutResHeader (OutResFile, ResHeader , &ResSizePos, &lSize)) {
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_ACCELKEY, NULL);
    }

    lSize = 0L;

    // Prep for find token call
    tok.wType   = ResHeader.wTypeID;
    tok.wName   = ResHeader.wNameID;
    tok.wID     = 0;
    tok.wFlag   = 0;
    tok.wReserved = ST_TRANSLATED;

    lstrcpy( tok.szName, ResHeader.pszName);

    for (wcCount = 0; wcCount < wcAccelEntries; wcCount++) {
        tok.wID     = wcCount;
        tok.wFlag   = (WORD) pAccelTable[wcCount].fFlags;
        tok.szText  = NULL;

        if (!FindToken(TokFile, &tok, ST_TRANSLATED)) {

            ParseTokToBuf(pErrBuf, &tok);
            QuitT( IDS_ENGERR_05, pErrBuf, NULL);
        }

        tok.wReserved = ST_TRANSLATED;

        cpID = (TCHAR *)tok.szText;
        cpAscii = _tcschr((TCHAR *)tok.szText, TEXT(' '));
        (*cpAscii) = '\0';
        cpAscii++;

#ifdef  RLRES16

    #ifndef PDK2

        PutByte (OutResFile, (BYTE) pAccelTable[wcCount].fFlags, &lSize);

    #else   // PDK2

        PutWord (OutResFile, (WORD) pAccelTable[wcCount].fFlags, &lSize);

    #endif  // PDK2

#else   // RLRES16

        PutWord (OutResFile, (WORD) pAccelTable[wcCount].fFlags, &lSize);

#endif  // RLRES16

#ifdef RLRES32

        _WCSTOMBS( szTmpBuf,
                   cpAscii,
                   ACHARSIN( sizeof( szTmpBuf)),
                   lstrlen( cpAscii ) + 1 );
        PutWord (OutResFile, (WORD) atoi(szTmpBuf), &lSize);

        _WCSTOMBS( szTmpBuf,
                   cpID,
                   ACHARSIN( sizeof( szTmpBuf)),
                   lstrlen( cpID ) + 1 );
        PutWord (OutResFile, (WORD) atoi(szTmpBuf), &lSize);

#else   // RLRES32

        PutWord (OutResFile, (WORD) atoi(cpAscii), &lSize);
        PutWord (OutResFile, (WORD) atoi(cpID), &lSize);

#endif  // RLRES32


#ifdef RLRES32
        PutWord (OutResFile, pAccelTable[wcCount].wPadding, &lSize);
#endif

        RLFREE( tok.szText);

    } // for

    if (!UpdateResSize (OutResFile, &ResSizePos , lSize)) {
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_ACCELKEY, NULL);
    }
} // PutAccelTable


void  CopyRes(

             FILE      *fpInResFile,
             FILE      *fpOutResFile,
             RESHEADER *pResHeader,
             fpos_t    *pResSizePos)
{
    DWORD dwTmp = 0L;


    PutResHeader( fpOutResFile, *pResHeader, pResSizePos, &dwTmp);

    ReadInRes( fpInResFile, fpOutResFile, (DWORD *)&(pResHeader->lSize));

#ifdef RLRES32

    DWordUpFilePointer( fpInResFile,  MYREAD,  ftell( fpInResFile),  NULL);

    DWordUpFilePointer( fpOutResFile, MYWRITE, ftell( fpOutResFile), NULL);

#endif

}

/////////////////////////////
// GetDlgInit
//
// VC++ uses a new resource type, DLGINIT (#240) when storing the
// initial contents of a list box. The data for this resource type
// is unaligned and containg non-Unicode strings. This function will
// read the resource data from the resource file pfInRes into a linked
// list of structures and will return a pointer to the head of that list.
// The parameter pdwSize contains the size of the resource as read from
// the resources associated resource header prior to this function
// being called.
// NOTE: The first entry in the list is aligned so it is treated
// slightly differently than are the remaining entries.

PDLGINITDATA GetDlgInit( FILE * pfInRes, DWORD *pdwSize)
{
    PDLGINITDATA pList = NULL;
    PDLGINITDATA pListEntry = NULL;
    WORD wTmp = 0;

    while ( *pdwSize > sizeof( DWORD) + 2 * sizeof( WORD) ) {
        if ( pList ) {                   // allocate the next entry in the list
            pListEntry->pNext = (PDLGINITDATA)FALLOC( sizeof( DLGINITDATA));
            pListEntry = pListEntry->pNext;
        } else {                   // allocate the head of the list
            pList = (PDLGINITDATA)FALLOC( sizeof( DLGINITDATA));
            pListEntry = pList;
        }
        // save the first two WORD fields of the data
        pListEntry->wControlID     = GetWord( pfInRes, pdwSize);
        pListEntry->wMessageNumber = GetWord( pfInRes, pdwSize);
        // get the string's length (incl nul terminator)
        pListEntry->dwStringLen = GetdWord( pfInRes, pdwSize);
        // get the string
        pListEntry->pszString = FALLOC( pListEntry->dwStringLen);

        for ( wTmp = 0; (pListEntry->pszString[ wTmp] = GetByte( pfInRes, pdwSize)); ++wTmp )
            ;   // empty loop
    }
    // Skip the trailing zero-value WORD
    SkipBytes( pfInRes, pdwSize);
#ifdef RLRES32
    DWordUpFilePointer( pfInRes, MYREAD, ftell( pfInRes),  NULL);
#endif
    return ( pList);
}

//////////////////////////////
// TokDlgInit
//
// Make tokens in pTokFile out of the data in the pDlgInit linked list.

void TokDlgInit( FILE *pfTokFile, RESHEADER ResHeader, PDLGINITDATA pDlgInit)
{
    int    nLen   = 0;
    WORD   wCount = 0;
    static TOKEN Tok;
#ifdef UNICODE
    static TCHAR szTmpBuf[ 256];
#else
    PCHAR szTmpBuf = NULL;
#endif

    ZeroMemory( &Tok, sizeof( Tok));

    Tok.wType   = ResHeader.wTypeID;
    Tok.wName   = ResHeader.wNameID;
    Tok.wReserved = (gbMaster ? ST_NEW : ST_NEW | ST_TRANSLATED);
    lstrcpy( Tok.szName, ResHeader.pszName);

    while ( pDlgInit ) {
        Tok.wID   = wCount++;
        Tok.wFlag = 0;
#ifdef UNICODE
        nLen = _MBSTOWCS( szTmpBuf,
                          pDlgInit->pszString,
                          WCHARSIN( sizeof( szTmpBuf)),
                          (UINT)-1);
#else
        nLen     = strlen( pDlgInit->pszString);
        szTmpBuf = pDlgInit->pszString;
#endif
        Tok.szText = BinToTextW( szTmpBuf, nLen);

        PutToken( pfTokFile, &Tok);
        RLFREE( Tok.szText);
        pDlgInit = pDlgInit->pNext;
    }
}

////////////////////////////
// PutDlgInit
//
// Create a new resource in pfOutRes using the data stored in pDlgInit
// and the token text in the pfTokFile.

void PutDlgInit( FILE *pOutResFile, FILE *pTokFile, RESHEADER ResHeader, PDLGINITDATA pDlgInit)
{
    fpos_t ResSizePos = 0;
    TOKEN  Tok;
    DWORD  lSize   = 0L;
    PCHAR  pszTmp  = NULL;

    if ( PutResHeader( pOutResFile, ResHeader , &ResSizePos, &lSize)) {
        QuitT( IDS_ENGERR_06, TEXT("DLGINIT"), NULL);
    }
    lSize = 0L;

    // Prep for find token call
    Tok.wType   = ResHeader.wTypeID;
    Tok.wName   = ResHeader.wNameID;
    Tok.wID     = 0;
    Tok.wFlag   = 0;
    Tok.wReserved = ST_TRANSLATED;

    lstrcpy( Tok.szName, ResHeader.pszName);

    while ( pDlgInit ) {
        Tok.szText = NULL;

        if ( ! FindToken( pTokFile, &Tok, ST_TRANSLATED)) {
            ParseTokToBuf( (LPTSTR)szDHW, &Tok);
            QuitT( IDS_ENGERR_05, (LPTSTR)szDHW, NULL);
        }
        Tok.wReserved = ST_TRANSLATED;
        Tok.wID++;
        // Write out the two unchanged WORD fields
        PutWord( pOutResFile, pDlgInit->wControlID, &lSize);
        PutWord( pOutResFile, pDlgInit->wMessageNumber, &lSize);
        // write the length of the new string (incl nul)
        _WCSTOMBS( szDHW, Tok.szText, DHWSIZE, (UINT)-1);
        PutdWord( pOutResFile, strlen( szDHW) + 1, &lSize);
        // write the new string (incl nul)
        for ( pszTmp = szDHW; *pszTmp; ++pszTmp ) {
            PutByte( pOutResFile, *pszTmp, &lSize);
        }
        PutByte( pOutResFile, '\0', &lSize);

        pDlgInit = pDlgInit->pNext;
    }
    // write the trailing zero-value WORD
    PutWord( pOutResFile, 0, &lSize);

    if ( ! UpdateResSize( pOutResFile, &ResSizePos, lSize) ) {
        QuitT( IDS_ENGERR_07, TEXT("DLGINIT"), NULL);
    }
#ifdef RLRES32
    DWordUpFilePointer( pOutResFile, MYWRITE, ftell( pOutResFile), NULL);
#endif
}

//////////////////////////////
// ClearDlgInitData
//
// Free the memory allocated for the DlgInitData linked list in GetDlgInit().

void ClearDlgInitData( PDLGINITDATA pDlgInit)
{
    while ( pDlgInit ) {
        PDLGINITDATA pTmp = pDlgInit->pNext;
        RLFREE( pDlgInit->pszString);
        RLFREE( pDlgInit);
        pDlgInit = pTmp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\showerrs.h ===
CHAR *GetErrMsg( UINT uErrID);
void ShowErr( int n, void *p1, void *p2);
void ShowEngineErr( int n, void *p1, void *p2);
int  RLMessageBoxA( LPCSTR pszMsgText);
void Usage( void);

DWORD B_FormatMessage( DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId,
    LPSTR lpBuffer, DWORD nSize, va_list *Arguments );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\toklist.h ===
#ifndef _TOKLIST_H_
#define _TOKLIST_H_

#include "tokenapi.h"

typedef struct _TOKENDELTAINFO
{
    TOKEN       DeltaToken;
    struct _TOKENDELTAINFO  FAR *  pNextTokenDelta;
} TOKENDELTAINFO;

typedef struct _TRANSLIST
{
    TCHAR * sz;
    struct _TRANSLIST * pPrev;
    struct _TRANSLIST * pNext;
} TRANSLIST;

typedef struct _TOKDATA
    {
    long	lMtkPointer;
    HANDLE	hToken;
}TOKDATA, *PTOKDATA, NEAR *NPTOKDATA, FAR *LPTOKDATA;

int MatchToken(TOKEN tToken,
               TCHAR * szFindType,
               TCHAR *szFindText,
               WORD wStatus,
               WORD    wStatusMask);
int DoTokenSearch (TCHAR *szFindType,
                   TCHAR *szFindText,
                   WORD  wStatus,
                   WORD wStatusMask,
                   BOOL fDirection,
                   BOOL fSkipFirst);

int DoTokenSearchForRledit (TCHAR *szFindType,
                            TCHAR *szFindText,
                            WORD  wStatus,
                            WORD wStatusMask,
                            BOOL fDirection,
                            BOOL fSkipFirst);

TCHAR FAR *FindDeltaToken(TOKEN tToken,
                          TOKENDELTAINFO FAR *pTokenDeltaInfo,
                          UINT wStatus);
TOKENDELTAINFO  FAR *UpdateTokenDeltaInfo(TOKEN *pDeltaToken);

TOKENDELTAINFO  FAR *InsertTokMtkList(FILE * fpTokFile, FILE *fpMtkFile);

void GenStatusLine(TOKEN *pTok);

#endif // _TOKLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\toktrans.c ===
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <tchar.h>

#ifdef RLDOS
#include "dosdefs.h"
#else
#include "windefs.h"
#endif

#include "restok.h"
#include "resread.h"
#include "toklist.h"
#include "commbase.h"


#define MAXLINE     1024
#define MAXTERM     512


extern UCHAR szDHW[];
extern PROJDATA gProj;
extern MSTRDATA gMstr;

#ifdef WIN32
extern HINSTANCE   hInst;       // Instance of the main window
#else
extern HWND        hInst;       // Instance of the main window
#endif

static fUnicodeGlossary = FALSE;


static long   GetGlossaryIndex( FILE *,  TCHAR, long []);
static void   ParseGlossEntry( TCHAR *, TCHAR *, TCHAR[], TCHAR *, TCHAR[]);
static void   ParseTextHotKeyToBuf( TCHAR *, TCHAR, TCHAR *);
static void   ParseBufToTextHotKey( TCHAR *, TCHAR[], TCHAR *);
static WORD   NormalizeIndex( TCHAR);
static int    MyPutGlossStr( TCHAR *, FILE *);
static TCHAR *MyGetGlossStr( TCHAR *, int, FILE *);
static void   BuildGlossEntry( TCHAR *, TCHAR *, TCHAR, TCHAR *, TCHAR);
static BOOL   NotAMember( TRANSLIST *, TCHAR *);




FILE * OpenGlossary( CHAR *szGlossFile, CHAR chAccessType)
{
    CHAR * szRW[4] = {"rb", "rt", "wb", "wt"};
    int nRW = 0;            // assume access type is 'r' (read)
    FILE *fpRC = NULL;

    if ( chAccessType == 'w' )          // is access type 'w' (write)?
    {
        nRW = fUnicodeGlossary ? 2 : 3; // yes (Unicode file or not?)
    }
    fpRC = fopen( szGlossFile, szRW[ nRW]);

    if ( fpRC && chAccessType == 'r' )
    {
        USHORT usMark = GetWord( fpRC, NULL);

        if ( usMark == 0xfeff )
        {
            fUnicodeGlossary = TRUE;            // it's a Unicode text file
        }
        else if ( usMark == 0xfffe )
        {
            QuitA( IDS_WRONGENDIAN, szGlossFile, NULL);
        }
        else
        {
            fclose( fpRC);
            fpRC = fopen( szGlossFile, szRW[ ++nRW]); // it's an ANSI text file
        }
    }
    return( fpRC);
}



/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

int MakeGlossIndex( LONG * lFilePointer)
{
    TCHAR szGlossEntry[MAXLINE] = TEXT("");
    WORD  iCurrent  =  0;
    LONG  lFPointer = -1;
    FILE *pFile  = NULL;


    pFile = OpenGlossary( gProj.szGlo, 'r');

    if ( pFile == NULL )
    {
        return( 1);
    }

    // Glossaries some times have this bogus header at the begining.
    // which we want to skip if it exists


    if ( ! MyGetGlossStr( szGlossEntry, MAXLINE, pFile) )
    {
        // Error during first read from the glossary.
        fclose( pFile);
        return( 1);
    }
    lFPointer = ftell( pFile);

    // check for glossary header

    if ( lstrlen( szGlossEntry) >= 7 )
    {
//        lstrcpy( (TCHAR *)szDHW, szGlossEntry);
//        szDHW[ MEMSIZE( 7)] = szDHW[ MEMSIZE( 7) + 1] = '\0';
//        CharLower( (TCHAR *)szDHW);
//
//        if ( lstrcmp( (TCHAR *)szDHW, TEXT("english")) == 0 )
        if ( CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                             SORT_STRINGSORT | NORM_IGNORECASE,
                             szGlossEntry,
                             7,
                             TEXT("ENGLISH"),
                             7) == 2 )
       {
            lFPointer = ftell (pFile);

            if (  ! MyGetGlossStr( szGlossEntry, MAXLINE, pFile) )
            {
                fclose( pFile);
                return (1);
            }
        }
    }

    // now assume we are at the correct location in glossary
    // file to begin generating the index, we want to save
    // this location

    lFilePointer[0] = lFPointer;

    // glossary file is sorted so,  any non letter items
    // in the glossary would be first. Index into this location
    // using the 1st position

    // 1st lets make sure we have non letters items in
    // the glossary

    // now skip ( if any ) the non letter entries in the glossary


    while( (WORD) szGlossEntry[0] < (WORD) TEXT('A' ) )
    {
        if ( ! MyGetGlossStr( szGlossEntry, MAXLINE, pFile) )
        {
            fclose( pFile);
            return( 1);
        }
    }

    // now position at alpha characters

    iCurrent = NormalizeIndex( szGlossEntry[0] );

    // now we read through the remaining glossary entries
    // and save the offsets for each index as we go

    do
    {
        if ( NormalizeIndex( szGlossEntry[0] ) > iCurrent )
        {
            // we passed the region for our current index
            // so save the location, and move to the next index.
            // note we may be skiping indexs,

            lFilePointer[ iCurrent] = lFPointer;
            iCurrent = NormalizeIndex( szGlossEntry[0] );
        }

        lFPointer = ftell( pFile );
        // otherwise the current index is valied for this
        // section of the glossary indexes, so just continue

    } while ( MyGetGlossStr( szGlossEntry, MAXLINE, pFile) );

    fclose( pFile);
    return( 0);
}


 /**
  *
  *
  *  Function: TransString
  * Builds a circular linked list containing all translations of a string.
  * The first entry in the list is the untranslated string.
  *
  *  Arguments:
  * fpGlossFile, handle to open glossary file
  * szKeyText, string with the text to build translation table
  * szCurrentText, text currently in the box.
  * ppTransList, pointer to a pointer to a node in a circular linked list
  * lFilePointer, pointer to index table for glossary file
  *
  *  Returns:
  * number of nodes in list
  *
  *  Errors Codes:
  *
  *  History:
  * Recoded by SteveBl, 3/92
  *
  **/

/* Translate the string, if possible. */

int TransString(

TCHAR      *szKeyText,
TCHAR      *szCurrentText,
TRANSLIST **ppTransList,
LONG       *lFilePointer)
{
    int  n = 0;
    long lFileIndex;
    TRANSLIST **ppCurrentPointer;
    static TCHAR  szGlossEntry[MAXLINE];
    static TCHAR  szEngText[260];
    static TCHAR  szIntlText[260];
    TCHAR *szCurText = NULL;
    TCHAR  cEngHotKey  = TEXT('\0');
    TCHAR  cIntlHotKey = TEXT('\0');
    TCHAR  cCurHotKey  = TEXT('\0');
    FILE  *fpGlossFile = NULL;

                                // *Is* there a glossary file?

    if ( (fpGlossFile = OpenGlossary( gProj.szGlo, 'r')) == NULL )
    {
        return( 0);
    }

    // FIRST let's erase the list
    if ( *ppTransList )
    {
        (*ppTransList)->pPrev->pNext = NULL; // so we can find the end of the list
    }

    while ( *ppTransList )
    {
        TRANSLIST *pTemp;

        pTemp = *ppTransList;
        *ppTransList = pTemp->pNext;
        RLFREE( pTemp->sz);
        RLFREE( pTemp);
    }
    ppCurrentPointer = ppTransList;

    // DONE removing the list
    // Now make the first node (which is the untranslated string)
    {
        TCHAR * psz;
        psz = (TCHAR *)FALLOC( MEMSIZE( lstrlen( szCurrentText) + 1));


        lstrcpy( psz,szCurrentText);
        *ppTransList = ( TRANSLIST *)FALLOC( sizeof( TRANSLIST));
        (*ppTransList)->pPrev = (*ppTransList)->pNext = *ppTransList;
        (*ppTransList)->sz = psz;
        ppCurrentPointer = ppTransList;
        n++;
    }
    szCurText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( szKeyText) + 1) );

    ParseBufToTextHotKey(  szCurText, &cCurHotKey, szKeyText);

    lFileIndex = GetGlossaryIndex( fpGlossFile, szCurText[0], lFilePointer);

    fseek (fpGlossFile, lFileIndex, SEEK_SET);

    while ( TRUE)
    {
        if ( ! MyGetGlossStr( szGlossEntry, MAXLINE, fpGlossFile) )
        {
            // Reached end of glossary file
            RLFREE( szCurText);
            fclose( fpGlossFile);
            return n;
        }
        ParseGlossEntry( szGlossEntry,
                         szEngText,
                         &cEngHotKey,
                         szIntlText,
                         &cIntlHotKey);

        // make comparision, using text, and hot keys

//        if ( ( ! lstrcmp( szCurText, szEngText )) && cCurHotKey == cEngHotKey )
        if ( CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                                         SORT_STRINGSORT,
                                         szCurText,
                                         -1,
                                         szEngText,
                                         -1) == 2
          && cCurHotKey == cEngHotKey )
        {
            TCHAR * psz;
            static TCHAR szTemp[ MAXINPUTBUFFER];

            // we have a match, put translated text into token
            if ( cIntlHotKey )
            {
                ParseTextHotKeyToBuf( szIntlText, cIntlHotKey, szTemp);
            }
            else
            {
                lstrcpy( szTemp, szIntlText);
            }

            if ( NotAMember( *ppTransList, szTemp) )
            {
                // add matched glossary text to circular list of matches

                psz = (TCHAR *) FALLOC( MEMSIZE( lstrlen( szTemp) + 1));

                lstrcpy( psz,szTemp);

                (*ppCurrentPointer)->pNext = (TRANSLIST *)
                                                FALLOC( sizeof( TRANSLIST));

                ((*ppCurrentPointer)->pNext)->pPrev = *ppCurrentPointer;
                ppCurrentPointer = (TRANSLIST **)&((*ppCurrentPointer)->pNext);
                (*ppCurrentPointer)->pPrev->pNext = *ppCurrentPointer;
                (*ppCurrentPointer)->pNext = *ppTransList;
                (*ppTransList)->pPrev = *ppCurrentPointer;
                (*ppCurrentPointer)->sz = psz;
                ++n;
            }
        }
        else
        {
            // can we terminate search?
//            if(  lstrcmpi( szEngText, szCurText ) > 0 )
            if ( CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                                             SORT_STRINGSORT,
                                             szEngText,
                                             -1,
                                             szCurText,
                                             -1) == 3 )
            {
                // went past index section
                RLFREE( szCurText);
                fclose( fpGlossFile);
                return( n);
            }
        }
    }
    RLFREE( szCurText);
    fclose( fpGlossFile);

    return( n);
}               // TransString


/**
  *
  *
  *  Function: NormalizeIndex
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/


static WORD NormalizeIndex( TCHAR chIndex )
{
    TCHAR chTmp = chIndex;

    CharLowerBuff( &chTmp, 1);

    return( (chTmp != TEXT('"') && chTmp >= TEXT('a') && chTmp <= TEXT('z'))
            ? chTmp - TEXT('a') + 1
            : 0);
}



/*
 * Function:NotAMember
 *
 * Arguments:
 *  pList, pointer to a TRANSLIST node
 *  sz, string to find
 *
 * Returns:
 *  TRUE if not found in the list else FALSE
 *
 * History:
 *  3/92, implemented       SteveBl
 **/

static BOOL NotAMember( TRANSLIST *pList, TCHAR *sz)
{
    TRANSLIST *pCurrent = pList;

    if ( ! pList )
    {
        return( TRUE);  // empty list
    }

    do
    {
//        if ( lstrcmp( sz, pCurrent->sz) == 0 )
        if ( CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                             SORT_STRINGSORT,
                             sz,
                             -1,
                             pCurrent->sz,
                             -1) == 2 )
        {
            return( FALSE); // found in list
        }
        pCurrent = pCurrent->pNext;

    }while ( pList != pCurrent );

    return( TRUE); // not found
}

/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

static void ParseGlossEntry(

TCHAR szGlossEntry[],
TCHAR szEngText[],
TCHAR cEngHotKey[1],
TCHAR szIntlText[],
TCHAR cIntlHotKey[1])
{

    WORD wIndex, wIndex2;

    // format is:
    // <eng text><tab><eng hot key><tab><loc text><tab><loc hot key>
    // Any field could be null and if there aren't the right amount of
    // tabs we'll just assume that the remaining fields are empty.

    wIndex=wIndex2=0;

    // first get the english text
    while ( szGlossEntry[wIndex2] != TEXT('\t')
         && szGlossEntry[wIndex2] != TEXT('\0') )
    {
        szEngText[ wIndex++] = szGlossEntry[ wIndex2++];
    }
    szEngText[wIndex]=TEXT('\0');

    if ( szGlossEntry[ wIndex2] == TEXT('\t') )
    {
        ++wIndex2; // skip the tab
    }
    // now get the eng hot key
    if ( szGlossEntry[wIndex2] != TEXT('\t')
      && szGlossEntry[wIndex2] != TEXT('\0') )
    {
        *cEngHotKey = szGlossEntry[wIndex2++];
    }
    else
    {
        *cEngHotKey = TEXT('\0');
    }

    while ( szGlossEntry[ wIndex2] != TEXT('\t')
         && szGlossEntry[ wIndex2] != TEXT('\0') )
    {
        ++wIndex2; // make sure the hot key field doesn't hold more than one char
    }

    if ( szGlossEntry[ wIndex2] == TEXT('\t') )
    {
        ++wIndex2; // skip the tab
    }
    wIndex = 0;

    // now get the intl text
    while ( szGlossEntry[ wIndex2] != TEXT('\t')
         && szGlossEntry[ wIndex2] != TEXT('\0') )
    {
        szIntlText[wIndex++]=szGlossEntry[wIndex2++];
    }
    szIntlText[wIndex]='\0';

    if ( szGlossEntry[ wIndex2] == TEXT('\t') )
    {
        ++wIndex2; // skip the tab
    }

    // now get the intl hot key
    if ( szGlossEntry[ wIndex2] != TEXT('\t')
      && szGlossEntry[ wIndex2] != TEXT('\0') )
    {
        *cIntlHotKey = szGlossEntry[ wIndex2++];
    }
    else
    {
        *cIntlHotKey = TEXT('\0');
    }
}



/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

static void ParseBufToTextHotKey(

TCHAR *szText,
TCHAR cHotKey[1],
TCHAR *szBuf)
{

    WORD wIndexBuf  = 0;
    WORD wIndexText = 0;

    *cHotKey = TEXT('\0');

    while( szBuf[ wIndexBuf] )
    {
        if ( szBuf[ wIndexBuf ] == TEXT('&') )
        {
            *cHotKey = szBuf[ ++wIndexBuf];
        }
        else
        {
            szText[ wIndexText++] = szBuf[ wIndexBuf++];
        }
    }
    szText[ wIndexText] = TEXT('\0');
}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

static void ParseTextHotKeyToBuf(

TCHAR *szText,
TCHAR cHotKey,
TCHAR *szBuf )
{
    WORD  wIndexBuf  = 0;
    WORD  wIndexText = 0;
//    TCHAR cTmp;


    while ( szText[ wIndexText] )
    {
//        cTmp = szText[ wIndexText];
//
//        CharUpperBuff( &cTmp, 1);
//
//        if ( cTmp == cHotKey )
        if ( szText[ wIndexText] == cHotKey )
        {
            szBuf[ wIndexBuf++] = TEXT('&');
            szBuf[ wIndexBuf++] = szText[ wIndexText++];
            break;
        }
        else
        {
            szBuf[ wIndexBuf++] = szText[ wIndexText++];
        }
    }

    // copy remaining string

    while( szText[ wIndexText] )
    {
        szBuf[ wIndexBuf++] = szText[ wIndexText++];
    }
    szBuf[ wIndexBuf] = TEXT('\0');
}


static long GetGlossaryIndex(

FILE *fpGlossFile,
TCHAR c,
long  *lGlossaryIndex )
{
    int   i    = 0;
    TCHAR cTmp = c;

    CharLowerBuff( &cTmp, 1);

    if ( cTmp >= TEXT('a')
      && cTmp <= TEXT('z') )
    {
        i = NormalizeIndex( c );
        return( lGlossaryIndex[ i > 0 ? i - 1 : 0]);
    }
    else
    {
        return( 0);
    }
}

/*******************************************************************************
*    PROCEDURE: BuildGlossEntry
*    Builds a glossary entry line.
*
*    Parameters:
*    sz, line buffer
*    sz1, untranslated text
*    c1, untranslated hot key (or 0 if no hot key)
*    sz2, translated text
*    c2, translated hot key (or 0 if no hot key)
*
*    Returns:
*    nothing.  sz contains the line.  (assumes there is room in the buffer)
*
*    History:
*    3/93 - initial implementation - SteveBl
*******************************************************************************/

static void BuildGlossEntry(

TCHAR *sz,
TCHAR *sz1,
TCHAR  c1,
TCHAR *sz2,
TCHAR  c2)
{
    *sz = TEXT('\0');
    wsprintf( sz, TEXT("%s\t%c\t%s\t%c"), sz1, c1, sz2, c2);
}

/******************************************************************************
*    PROCEDURE: AddTranslation
*    Adds a translation to a glossary file.
*
*    PARAMETERS:
*    szGlossFile, path to the glossary
*    szKey, untranslated text
*    szTranslation, translated text
*    lFilePointer, pointer to index hash table for glossary
*
*    RETURNS:
*    nothing.  Key is added to glossary if no errors are encountered else
*    file is left unchanged.
*
*    COMMENTS:
*    rebuilds the global pointer list lFilePointer
*
*    HISTORY:                                    *
*    3/92 - initial implementation - SteveBl
******************************************************************************/

void AddTranslation(

TCHAR *szKey,
TCHAR *szTranslation,
LONG  *lFilePointer)
{

// DBCS begin
    TCHAR szCurText [520];
    TCHAR szTransText   [520];
// DBCS end
    TCHAR cTransHot   = TEXT('\0');
    TCHAR cCurHotKey  = TEXT('\0');
    CHAR szTempFileName [255];
    FILE *fTemp       = NULL;
    FILE *fpGlossFile = NULL;
    TCHAR szTempText [MAXLINE];
// DBCS begin
    TCHAR szNewText [MAXLINE * 2];
// DBCS end
    TCHAR *r    = NULL;
    TCHAR chTmp = TEXT('\0');

    MyGetTempFileName( 0, "", 0, szTempFileName);

    if ( (fTemp = OpenGlossary( szTempFileName, 'w')) != NULL )
    {
        if ( fUnicodeGlossary )
        {
            fprintf( fTemp, "%hu", 0xfeff); // Mark new one as Unicode
        }

        ParseBufToTextHotKey( szCurText, &cCurHotKey, szKey);
        ParseBufToTextHotKey( szTransText, &cTransHot, szTranslation);

        BuildGlossEntry( szNewText,
                         szCurText,
                         cCurHotKey,
                         szTransText,
                         cTransHot);

                                // If the glossary file exists, get its first
                                // line. If it doesn't exist, we'll create it
                                // (via CopyFile) at the end of this function.

        if ( (fpGlossFile = OpenGlossary( gProj.szGlo, 'r')) != NULL )
        {
            if ( (r = MyGetGlossStr( szTempText,
                                     TCHARSIN( sizeof( szTempText)),
                                     fpGlossFile)) )
            {
//                lstrcpy( (TCHAR *)szDHW, szTempText);
//                szDHW[ MEMSIZE( 7)] = szDHW[ MEMSIZE( 7) + 1] = '\0';
//                CharLower( (TCHAR *)szDHW);
//
//                if ( lstrcmpi( (TCHAR *)szDHW, TEXT("ENGLISH")) == 0 )

                if ( CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                                     SORT_STRINGSORT | NORM_IGNORECASE,
                                     szTempText,
                                     7,
                                     TEXT("ENGLISH"),
                                     7) == 2 )
                {
                                // skip first line

                    MyPutGlossStr( szTempText, fTemp);
                    r = MyGetGlossStr( szTempText, TCHARSIN( sizeof( szTempText)), fpGlossFile);
                }
            }
        }
        else
        {
            r = NULL;
        }

//        if ( r )
//        {
//            chTmp = szTempText[0];
//            CharLowerBuff( &chTmp, 1);
//        }
//        else
//        {
//            chTmp = szTempText[0] = TEXT('\0');
//        }
//                // Does the new text begin with a letter?
//
//        if ( chTmp >= TEXT('a') )
//        {
//                // begins with a letter, we need to find where to put it
//
//            while ( r && chTmp < TEXT('a') )
            while ( r && CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                                         SORT_STRINGSORT,
                                         szTempText,
                                         -1,
                                         szNewText,
                                         -1) == 1 )
            {
                    // skip the non letter section
                MyPutGlossStr( szTempText, fTemp);

                r = MyGetGlossStr( szTempText,
                                   TCHARSIN( sizeof( szTempText)),
                                   fpGlossFile);
//                if ( (r = MyGetGlossStr( szTempText,
//                                         TCHARSIN( sizeof( szTempText)),
//                                         fpGlossFile)) )
//                {
//                    chTmp = szTempText[0];
//                    CharLowerBuff( &chTmp, 1);
//                }
            }

//            while ( r && _tcsicmp( szTempText, szNewText) < 0 )
//            {
//                    // skip anything smaller than me
//
//                    MyPutGlossStr( szTempText, fTemp);
//                    r = MyGetGlossStr( szTempText, TCHARSIN( sizeof( szTempText)), fpGlossFile);
//            }
//        }
//        else
//        {
//                // doesn't begin with a letter, we need to insert it before
//                // the letter sections begin but it still must be sorted
//
//            while ( r
//                 && chTmp < TEXT('a')
//                 && _tcsicmp( szTempText, szNewText) < 0 )
//            {
//                MyPutGlossStr( szTempText, fTemp);
//
//                if ( (r = MyGetGlossStr( szTempText,
//                                         TCHARSIN( sizeof( szTempText)),
//                                         fpGlossFile)) )
//                {
//                    chTmp = szTempText[0];
//                    CharLowerBuff( &chTmp, 1);
//                }
//            }
//        }
        MyPutGlossStr( szNewText, fTemp);

        while ( r )
        {
            MyPutGlossStr( szTempText,fTemp);
            r = MyGetGlossStr( szTempText, TCHARSIN( sizeof( szTempText)), fpGlossFile);
        }
        fclose( fTemp);

        if ( fpGlossFile )
        {
            fclose( fpGlossFile);
        }
                                // This call will create the glossary file
                                // if it didn't already exist.

        if ( ! CopyFileA( szTempFileName, gProj.szGlo, FALSE) )
        {
            QuitA( IDS_COPYFILE_FAILED, szTempFileName, gProj.szGlo);
        }
        remove( szTempFileName);

        MakeGlossIndex( lFilePointer);
    }
    else
    {
        QuitA( IDS_NO_TMP_GLOSS, szTempFileName, NULL);
    }
}

/**
  *
  *
  *  Function: MyGetGlossStr
  *     Replaces C runtime fgets function.
  *
  *  History:
  *     5/92, Implemented.              TerryRu.
  *
  *
  **/

static TCHAR *MyGetGlossStr( TCHAR * ptszStr, int nCount, FILE * fIn)
{
    int i = 0;

#ifdef RLRES32
                                // It this a Unicode glossary file?
    TCHAR  tCh = TEXT('\0');

    if ( fUnicodeGlossary )
    {
        do                      // Yes
        {
            tCh = ptszStr[ i++] = (TCHAR)GetWord( fIn, NULL);

        } while ( i < nCount && tCh != TEXT('\n') );

        if ( tCh == TEXT('\0') || feof( fIn) )
        {
            return( NULL);
        }
        ptszStr[i] = TEXT('\0');

        StripNewLineW( ptszStr);
    }
    else                        // No, it's an ANSI glossary file
    {
        if ( fgets( szDHW, DHWSIZE, fIn) != NULL )
        {
            StripNewLineA( szDHW);
            _MBSTOWCS( ptszStr, szDHW, nCount, (UINT)-1);
        }
        else
        {
            return( NULL);
        }
    }
    return( ptszStr);

#else  //RLRES32

    if ( fgets( ptszStr, nCount, fIn) )
    {
        StripNewLineA( ptszStr);
    }
    else
    {
        return( NULL);
    }

#endif //RLRES32
}




/**
  *
  *
  *  Function: MyPutGlossStr
  *   Replaces C runtime fputs function.

  *  History:
  *   6/92, Implemented.              TerryRu.
  *
  *
  **/
static int MyPutGlossStr( TCHAR * ptszStr, FILE * fOut)
{

#ifdef RLRES32

    int i = 0;

                                // It this a Unicode glossary file?
    if ( fUnicodeGlossary )
    {
        do                      // Yes
        {
            PutWord( fOut, ptszStr[i], NULL);

        } while ( ptszStr[ i++] );

        PutWord( fOut, TEXT('\r'), NULL);
        PutWord( fOut, TEXT('\n'), NULL);
        i += 2;
    }
    else                        // No, it's an ANSI glossary file
    {
        _WCSTOMBS( szDHW, ptszStr, DHWSIZE, lstrlen( ptszStr) + 1);
        i = fputs( szDHW, fOut);
        fputs( "\n",  fOut);
    }

#else  //RLRES32

    i = fputs( ptszStr,  fOut);
    fputs( "\n",  fOut);

#endif //RLRES32

    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\version.h ===
#define rmj		1
#define rmm		534
#define rup		1
#define szVerName	""
#define szVerUser	"July 1993"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\update.h ===
#ifndef _UPDATE_H_
#define _UPDATE_H_


////int PrepareUpdate(CHAR *szResourceFile,CHAR *szMasterTokenFile);
    int Update(CHAR *szMasterTokenFile, CHAR *szLanguageTokenFile);
////int Switch(TCHAR *szValue, CHAR *szTokenFile);


#endif // _UPDATE_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\tokenapi.h ===
#ifndef _TOKENAPI_H_
#define _TOKENAPI_H_


#define MAXINPUTBUFFER 564  // Longest supported line in the token file
#define MAXTOKENBUFFER 1024 // Size for the t_token struct plus the strings
#define MAXFILENAME 256 // maximum length of file pathname
#define MAXCUSTFILTER   40  // maximum size of custom filter buffer
#define CCHNPMAX    65535   // max number of bytes in a notepad file


// Token flag Masks

#define ISPOPUP       0x0001
#define ISCOR         0x0010
#define ISDUP         0x0020
#define ISCAP         0x0040
#define ISDLGFONTNAME 0x0004
#define ISDLGFONTSIZE 0x0008
#define ISALIGN	      0x0080

#define ISKEY    0x0010
#define ISVAL    0x0020

// status bits
#define ST_TRANSLATED  4
#define ST_READONLY    2
#define ST_NEW         1
#define ST_DIRTY       1
#define ST_CHANGED     4
    
#define TOKENSTRINGBUFFER 260
#define MAXTEXTLEN        (4096+TOKENSTRINGBUFFER)

// Increased buffer size of TokeString and TokenText to 260
// I increased to 260 and not 256 to be on the safe side. (PW)
// DHW - For Message Resource Table tokens, the high word of the ulong ID# is
//     now stored as a string in the szName field.  String is result of _itoa().
// MHotchin - Converted to szText field to a pointer, for var length text fields
//      Added a new constant - MAXTEXTLEN is the longest token text we are
//      willing to handle.

#pragma pack(1)

struct t_token {
    WORD wType;         // Type of the token
    WORD wName;         // Name ID of token, 65535 => contains TokenString
    WORD wID;           // Token item ID or duplicated number
    WORD wFlag;         // =0 -> ID is unique
                        // >0 -> ID not unique
    WORD wLangID;       // Locale ID for Win32 resources
    WORD wReserved;     // Not used now
    TCHAR szType[TOKENSTRINGBUFFER];    // Pointer to type string (Not yet used.)
    TCHAR szName[TOKENSTRINGBUFFER];    // Pointer to name string, or msg ID hiword
    TCHAR *szText;                      // Pointer to the text for the token
};

typedef struct t_token TOKEN;

int  GetToken(  FILE * , TOKEN * );
int  PutToken(  FILE * , TOKEN * );
int  FindToken( FILE * , TOKEN * , WORD);
void ParseTokToBuf( TCHAR *, TOKEN * );
void ParseBufToTok( TCHAR *, TOKEN * );
int  TokenToTextSize( TOKEN *);

#pragma pack()

#endif // _TOKENAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\tokenapi.c ===
#include <ctype.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#ifdef RLDOS
    #include "dosdefs.h"
#else
    #include <windows.h>
    #include "windefs.h"
#endif

#include "restok.h"
#include "commbase.h"
#include "resread.h"

extern UCHAR szDHW[];

//
//  The syssetup.dll, that has been contained Windows NT 4.00, has the largest
//  message strings than ever. So, we have to expand buffer size(to 20480).
//
#define MAX_OUT_BUFFER  20480
CHAR gt_szTextBuffer[ MAX_OUT_BUFFER];
TCHAR pt_szOutBuffer[MAX_OUT_BUFFER];

/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

/*---------------------------------------------------------
 * Function: GetToken
 * Input: fpInFile       File pointer, points to the token to be read.
 *        tToken         Pointer to a token.
 *
 *
 * Output: fpInFile      File pointer after read operation.
 *                       points to the next token in the file.
 *         tToken        The token read in from the file.  Memory will have been
 *                       allocated for the token text, unless no token was read in.
 *
 * Return code:
 *   0  = Read token, every thing OK
 *   1  = Empty line or line started with # (Comment)
 *  -1  = End of FILE
 *  -2  = Error reading from file.
 *
 * History:
 * 01/93 Re-written to read in long token text strings.  MHotchin
 *
 *----------------------------------------------------------*/


int GetToken(

            FILE *fpInFile,     //... File to get token from.
            TOKEN *pToken)      //... Buffer for token.
{
    int chNextChar = 0;
    int cTextLen   = 0;
    int rc = 0;

    // Read token from file.
    // we will want to use MyGetStr, when
    // tokens are in UNICODE

    // Strip off leading whitespace, and check
    // for blank lines.

    chNextChar = fgetc( fpInFile);

    while ( (chNextChar == ' ') || (chNextChar == '\t') ) {
        chNextChar = fgetc( fpInFile);
    }

    if ( chNextChar == EOF ) {
        return ( -1);
    } else if ( chNextChar == '\n' ) {
        return ( 1);
    }

    // Now we have the first non-white space
    // character.
    // Check for a comment line, and strip out the
    // remainder of the line if it is.

    else if ( chNextChar == '#' ) {
        fscanf( fpInFile, "%*[^\n]");
        chNextChar = fgetc( fpInFile);

        if ( chNextChar == EOF ) {
            return ( -1);
        } else {
            return ( 1);
        }
    }

    // Now we are positioned at the first
    // non-whitespace character. Check it, and
    // read in the numbers...

    else if ( chNextChar != '[' ) {
        // Bad format?
        return ( -2);
    }

    if ( fscanf( fpInFile,
                 "[%hu|%hu|%hu|%hu|%hu",
                 &pToken->wType,
                 &pToken->wName,
                 &pToken->wID,
                 &pToken->wFlag,
                 &pToken->wReserved) != 5 ) {
        QuitA( IDS_ENGERR_12, (LPSTR)IDS_BADTOKID, NULL);
    }

    // Now that we have all the numbers, we can
    // look for the name of the token.

    if ( (pToken->wName == IDFLAG) || (pToken->wType == ID_RT_ERRTABLE) ) {
        static char szName[ TOKENSTRINGBUFFER];
        int nRC = 0;

        nRC = fscanf( fpInFile, "|\"%[^\"]", szName);
        if ( nRC == EOF  ) {
            QuitT( IDS_ENGERR_05, (LPTSTR)IDS_INVTOKNAME, NULL);
        }

#ifndef UNITOK

    #ifdef RLRES32
        if (nRC)
            _MBSTOWCS( (TCHAR *)pToken->szName,
                       szName,
                       TOKENSTRINGBUFFER,
                       lstrlenA( szName) + 1);
        else
            _MBSTOWCS( (TCHAR *)pToken->szName,
                       "",
                       TOKENSTRINGBUFFER,
                       lstrlenA( szName) + 1);
    #else
        if (nRC)
            strcpy( pToken->szName, szName);
        else
            *pToken->szName = '\0';
    #endif

#else
        if (nRC)
            strcpy( pToken->szName, szName);
        else
            *pToken->szName = '\0';
#endif
    } else {
        if ( fscanf( fpInFile, "|\"%*[^\"]") != 0 ) {
            QuitT( IDS_ENGERR_05, (LPTSTR)IDS_NOSKIPNAME, NULL);
        }
        pToken->szName[0] = '\0';
    }

    // Now the name has been read, and we are
    // positioned at the last '"' in the text
    // stream.  Allocate memory for the token
    // text, and read it in.

    fgets( gt_szTextBuffer, sizeof(gt_szTextBuffer), fpInFile);

    // Now that the token text is read in,
    // convert it to whatever character type
    // we are expecting.  First strip the newline!

    StripNewLineA( gt_szTextBuffer);
    cTextLen = lstrlenA( gt_szTextBuffer);

    if ( cTextLen < 4 ) {         // Must be more than "\"]]=" in szTextBuffer
        return ( -2);
    }
    pToken->szText = (TCHAR *)FALLOC( MEMSIZE( cTextLen - 3));

#ifndef UNITOK

    #ifdef RLRES32
    _MBSTOWCS( pToken->szText, gt_szTextBuffer+4, cTextLen - 3, cTextLen - 3);
    #else
    strcpy( pToken->szText, gt_szTextBuffer+4);
    #endif  // RLRES32

#else   // UNITOK
    strcpy( pToken->szText, gt_szTextBuffer+4);
#endif  // UNITOK

    return ( 0);
}



/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  * 01/93 Added new character count field.  MHotchin
  *
  **/


int PutToken(

            FILE  *fpOutFile,   //... Token file to write to
            TOKEN *tToken)      //... Token to be writen to the token file
{
    WORD   rc     = 0;
    PCHAR  pszBuf = NULL;


    ParseTokToBuf( pt_szOutBuffer, tToken);
//    RLFREE( tToken->szText);

#ifdef RLRES32

    if ( ! _WCSTOMBS( szDHW, pt_szOutBuffer, DHWSIZE, lstrlen( pt_szOutBuffer) + 1) ) {
        QuitT( IDS_ENGERR_26, pt_szOutBuffer, NULL);
    }
    pszBuf = szDHW;

#else

    pszBuf = pt_szOutBuffer;

#endif


    return fprintf( fpOutFile, "%s\n", pszBuf);
}


/**
  *  Function: FindToken
  * Finds a token whose status bits match only where the mask is set.
  *
  *  Arguments:
  * fpSearchFile -- search file
  * psTok       -- pointer to the token
  * uMask       -- status bit mask
  *
  *  Returns:
  * string and status of found token
  *
  *  Errors Codes:
  * 0 - token not found
  * 1 - token found
  *
  *  History:
  * 01/93 Added support for var length token text strings.  Previous token text
  *     is de-allocated!  MHotchin
  *
  **/

int FindToken( FILE *fpSearchFile, TOKEN *psTok, WORD wMask)
{
    BOOL  fFound     = FALSE;
    BOOL  fStartOver = TRUE;
    int   error;
    int   nTokensRead = 0;
    long  lStartFilePos, lFilePos;
    TOKEN cTok;

    //... Remember where we are starting

    lFilePos = lStartFilePos = ftell(fpSearchFile);

    do {
        long lType11Pos = 0;


        do {
            lType11Pos = ftell( fpSearchFile);

            error = GetToken( fpSearchFile, &cTok);

            if ( error == 0 ) {
                //... Is this the token we are looking for?

                fFound = ((cTok.wType == psTok->wType)
                          && (cTok.wName == psTok->wName)
                          && (cTok.wID   == psTok->wID)
                          && (cTok.wFlag == psTok->wFlag)
                          && ((WORD)(cTok.wReserved & wMask) == psTok->wReserved)
                          && (_tcscmp( (TCHAR *)cTok.szName,
                                       (TCHAR *)psTok->szName) == 0));
            }

            if ( ! fFound ) {
                //... If we were looking for another segment to
                //... an NT Msg Table entry, move back to the
                //... token we just read and quit (speedup).

                if ( psTok->wType == ID_RT_ERRTABLE
                     && psTok->wFlag > 0
                     && error == 0 ) {
                    if ( cTok.wType != psTok->wType
                         || cTok.wName != psTok->wName
                         || cTok.wID   != psTok->wID
                         || cTok.wFlag  > psTok->wFlag ) {
                        fseek( fpSearchFile, lType11Pos, SEEK_SET);
                        RLFREE( cTok.szText);
                        return ( FALSE);
                    }
                } else if ( error >= 0 ) {
                    lFilePos = ftell(fpSearchFile);

                    if (error == 0) {
                        RLFREE(cTok.szText);
                    }
                } else if (error == -2) {
                    return ( FALSE);
                }
            }

        } while ( ! fFound
                  && (error >= 0)
                  && (fStartOver || (lFilePos < lStartFilePos)) );

        if ( ! fFound && (error == -1) && fStartOver ) {
            rewind(fpSearchFile);
            lFilePos = 0L;
            fStartOver = FALSE;
        }

    } while ( ! fFound && (lFilePos < lStartFilePos) );

    //... Did we find the desired token?
    if ( fFound ) {                           //... Yes, we found it
        psTok->wReserved = cTok.wReserved;

        RLFREE( psTok->szText);
        psTok->szText = cTok.szText;
    }
    return ( fFound);
}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  * 01/93 Added support for new token text count.  MHotchin
  *
  **/


void ParseBufToTok( TCHAR *szToken, TOKEN *pTok )
{
    TCHAR *pos;
    WORD  bChars;


    if ( _stscanf( szToken,
                   TEXT("[[%hu|%hu|%hu|%hu|%hu"),
                   &pTok->wType,
                   &pTok->wName,
                   &pTok->wID,
                   &pTok->wFlag,
                   &pTok->wReserved) != 5 ) {
        QuitT( IDS_BADTOK, szToken, NULL);
    }

    if ( pTok->wName == IDFLAG || pTok->wType == ID_RT_ERRTABLE ) {
        //... Find Names's first char and get it's len

        if ( pos = _tcschr( (TCHAR *)szToken, TEXT('"')) ) {
            TCHAR *pStart;

            pStart = ++pos;
            bChars = 0;

            while ( *pos && *pos != TEXT('"')
                    && bChars < TOKENSTRINGBUFFER - 1 ) {
                bChars++;
                pos++;
            } // while

            CopyMemory( pTok->szName, pStart, min( TOKENSTRINGBUFFER, bChars) * sizeof( TCHAR));
            pTok->szName[ bChars ] = TEXT('\0');
        } else {
            //... No token ID found
            QuitT( IDS_ENGERR_05, (LPTSTR)IDS_INVTOKNAME, NULL);
        }
    } else {
        // Don't forget the zero termination
        pTok->szName[0] = TEXT('\0');
    }

    // now do the token text

    pos = _tcschr ((TCHAR *)szToken, TEXT(']'));

    if ( pos ) {

        //  This can be written better now that we know the text length.

        bChars = (WORD)lstrlen( pos);

        if ( bChars > 3 ) {
            pos += 3;
            bChars -= 3;
            pTok->szText = (TCHAR *)FALLOC( MEMSIZE( bChars + 1));
            CopyMemory( pTok->szText, pos, MEMSIZE( bChars + 1));
            // Don't forget the zero termination
            pTok->szText[ bChars] = TEXT('\0');
        } else if ( bChars == 3 ) {
            //... Empty token text
            pTok->szText = (TCHAR *) FALLOC( 0);
        } else {
            //... No token ID found
            QuitT( IDS_ENGERR_05, (LPTSTR)IDS_INVTOKID, NULL);
        }
    } else {
        //... No token ID found
        QuitT( IDS_ENGERR_05, (LPTSTR)IDS_NOTOKID, NULL);
    }
}



/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  **/


void ParseTokToBuf( TCHAR *szToken, TOKEN *pTok )
{
    *szToken = TEXT('\0');

    if ( pTok != NULL) {
        wsprintf( szToken,
                  TEXT("[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]="),
                  pTok->wType,
                  pTok->wName,
                  pTok->wID,
                  pTok->wFlag,
                  pTok->wReserved,
                  pTok->szName);
        if (pTok->szText)
            lstrcat(szToken, pTok->szText);
    }
}


/**
  *
  *
  *  Function: TokenToTextSize
  *             This calculates the number of characters needed to hold
  *             the text representation of a token.
  *
  *  Arguments:
  *     pTok    The token to measure.
  *
  *  Returns:
  *     int     The number of characters needed to hold the token, not
  *             including a null terminator.  [[%hu|%hu|%hu|%hu|%hu|\"%s\"]]=%s
  *
  *  Errors Codes:
  *     None.
  *
  *  History:
  *     01/18/93        MHotchin        Created.
  *
  **/
int TokenToTextSize( TOKEN *pTok)
{
    int cTextLen;

    cTextLen = (14 +         //  Separators and terminator ( + 1 extra)
                30);         //  Space for 5 numeric fields  (65,535 = 6 chars)

    if ( pTok->szText != NULL ) {

        //  Add space for the Token text
        cTextLen += MEMSIZE( lstrlen( pTok->szText) );

    }

    cTextLen += lstrlen( pTok->szName);

    return ( cTextLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\toklist.c ===
#include <windows.h>

#include <assert.h>
#include <ctype.h>
#include <malloc.h>
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include "windefs.h"
#include "toklist.h"
#include "restok.h"
#include "resread.h"

#include "showerrs.h"

#define	MAXLINE	1024

#ifdef WIN32
extern HINSTANCE   hInst;       // Instance of the main window
#else
extern HWND        hInst;       // Instance of the main window
#endif

extern HWND hListWnd;
extern HWND hMainWnd;
extern HCURSOR hHourGlass;
extern int  nUpdateMode;
extern HWND hStatusWnd;
extern UCHAR szDHW[];

/**
  *
  *
  *  Function:
  *
  *  Returns:
  *
  *  History:
  *     01/92, Implemented.     TerryRu.
  *
  *
  **/

int MatchToken(TOKEN tToken,
               TCHAR * szFindType,
               TCHAR *szFindText,
               WORD wStatus,
               WORD    wStatusMask)
{
    TCHAR szResIDStr[20];

    if (tToken.wType <= 16)
    {
        LoadString( hInst,
                    IDS_RESOURCENAMES + tToken.wType,
                    szResIDStr,
                    TCHARSIN( sizeof(szResIDStr)));
    }
    else
    {
#ifndef UNICODE
        _itoa(tToken.wType,szResIDStr, 10);
#else
        CHAR szTemp[32];
        _itoa(tToken.wType, szTemp, 10);
        _MBSTOWCS( szResIDStr,
                   szTemp,
                   WCHARSIN( sizeof( szResIDStr)),
                   ACHARSIN( lstrlenA(szTemp) + 1));
#endif
    }
    // need to both check because checking szFindType[0]
    // when string is null cause exception
    if (szFindType && szFindType[0])
    {
        if (_tcsicmp((TCHAR *)szFindType, (TCHAR *)szResIDStr))
        {
            return FALSE;
        }
    }

// this has case problems.
// how do I work around this and work with extened characters?

    if ( szFindText && szFindText[0] )
    {
        if (!_tcsstr( (TCHAR *)tToken.szText, (TCHAR *)szFindText))
        {
            return FALSE;
        }
    }

    // if we made it to here,
    // all search criteria exept the status bits have matched.

    return (wStatus ==  (WORD) (wStatusMask & tToken.wReserved));
}

/**
  *
  *
  *  Function: DoTokenSearch
  *     BiDirection token search utility to find tokens.
  *     Search is based on, the status field, token type, and token text.
  *
  *  Paramaters:
  *     *szFindType, type of token to search for.
  *     *szFindText, token text to search for.
  * wStatus, status values to search for
  * wStatusMask, status mask to search with
  *     fDirection, direction to search through tokens 0 = down, 1 = up
  *
  *  Returns:
  *     TRUE, token located and selected.
  *     FALSE token not found.
  *
  *  History:
  * 01/92, Implemented.                     TerryRu.
  * 02/92, mask parameter added                 SteveBl
  * 01/93  Added support for var length token text strings.  MHotchin
  *
  **/

int DoTokenSearch (TCHAR *szFindType,
                   TCHAR *szFindText,
                   WORD  wStatus,
                   WORD wStatusMask,
                   BOOL fDirection,
                   BOOL fSkipFirst)
{

    UINT wLbCount;                      // number of tokens in list box
    LPTSTR lpstrToken;
    int wCurSelection;                  // current selected token.
    UINT wSaveSelection;                // location in token list where the search began
    TOKEN tToken;                       // info of current token
    BOOL fWrapped = FALSE;              // flag to indicate whether we wrapped during the search
    TCHAR *szBuffer;

    // get the number of tokens in the list
    wLbCount = (UINT)SendMessage( hListWnd,
                                  LB_GETCOUNT,
                                  (WPARAM)0,
                                  (LPARAM)0);

    // save the current in the token list
    wCurSelection = (UINT)SendMessage( hListWnd,
                                       LB_GETCURSEL,
                                       (WPARAM)0,
                                       (LPARAM)0);
    wSaveSelection = wCurSelection;

    // check for case where there is no current selection.
    if (wCurSelection == (UINT) -1)
    {
        wSaveSelection = wCurSelection = 0;
    }

    while (TRUE)
    {
        // get current token info in the tToken sturcture

        HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             (WPARAM)wCurSelection,
                                             (LPARAM)0);
        lpstrToken = (LPTSTR)GlobalLock( hMem);

        if ( lpstrToken )
        {
            szBuffer = (TCHAR *) FALLOC( MEMSIZE( lstrlen( lpstrToken)+1));
            lstrcpy( szBuffer, lpstrToken);
            GlobalUnlock( hMem);

            ParseBufToTok(szBuffer, &tToken);
            RLFREE( szBuffer);

                // is it a match?
            if ( MatchToken( tToken,
                             szFindType,
                             szFindText,
                             wStatus,
                             wStatusMask)
                && ! fSkipFirst)
            {
                    // yes, select and return TRUE
                RLFREE( tToken.szText);
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             (WPARAM)wCurSelection,
                             (LPARAM)0);
                return (TRUE);
            }
            RLFREE( tToken.szText);
        }
        fSkipFirst = FALSE;

        // no, continue search
        if (fDirection)
        {
            // going upward during the search
            if (--wCurSelection < 0)
            {
                LPSTR pszFind  = NULL;
                DWORD dwMsgLen = 0;

                // reached beginning of the tokens, do we want to wrap

                dwMsgLen = B_FormatMessage((FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                                          | FORMAT_MESSAGE_IGNORE_INSERTS
                                          | FORMAT_MESSAGE_FROM_HMODULE,
                                            NULL,
                                            IDS_REACHEDBEGIN,
                                            szDHW,
                                            DHWSIZE,
                                            NULL);
                pszFind = szDHW + dwMsgLen + 2;

                B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                               | FORMAT_MESSAGE_IGNORE_INSERTS
                               | FORMAT_MESSAGE_FROM_HMODULE,
                                 NULL,
                                 IDS_FINDTOKENS,
                                 pszFind,
                                 DHWSIZE - dwMsgLen - 2,
                                 NULL);
                if ( nUpdateMode == 0
                  && wSaveSelection != wLbCount
                  && !fWrapped
                  && (MessageBoxA( hMainWnd,
                                   szDHW,
                                   pszFind,
                                   MB_ICONQUESTION | MB_YESNO) == IDYES) )
                {
                    // yes, so wrap and reset counters
                    fWrapped = TRUE;
                    wCurSelection = wLbCount-1;
                    wLbCount = wSaveSelection;
                }
                // no, so return FALSE
                else
                {
                    break;
                }
            }
        }
        else
        {
            // going downward during the search
            if (++wCurSelection >= (int) wLbCount)
            {
                LPSTR pszFind  = NULL;
                DWORD dwMsgLen = 0;

                // reached end of the tokens, do we want to wrap

                dwMsgLen = B_FormatMessage((FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                                          | FORMAT_MESSAGE_IGNORE_INSERTS
                                          | FORMAT_MESSAGE_FROM_HMODULE,
                                            NULL,
                                            IDS_REACHEDEND,
                                            szDHW,
                                            DHWSIZE,
                                            NULL);
                pszFind = szDHW + dwMsgLen + 2;

                B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                               | FORMAT_MESSAGE_IGNORE_INSERTS
                               | FORMAT_MESSAGE_FROM_HMODULE,
                                 NULL,
                                 IDS_FINDTOKENS,
                                 pszFind,
                                 DHWSIZE - dwMsgLen - 2,
                                 NULL);
                if ( nUpdateMode == 0
                  && wSaveSelection != wLbCount
                  && !fWrapped
                  && (MessageBoxA( hMainWnd,
                                   szDHW,
                                   pszFind,
                                   MB_ICONQUESTION | MB_YESNO) == IDYES) )
                {
                    // yes, so wrap and reset counters
                    fWrapped = TRUE;
                    wCurSelection = 0;
                    wLbCount = wSaveSelection;
                }
                // no, so return FALSE
                else
                {
                    break;
                }
            }
        }
    }
    return FALSE;
}

//.......................................................................

int DoTokenSearchForRledit (TCHAR *szFindType,
                            TCHAR *szFindText,
                            WORD  wStatus,
                            WORD wStatusMask,
                            BOOL fDirection,
                            BOOL fSkipFirst)
{

    UINT      wLbCount;                     // number of tokens in list box
    LPTSTR    lpstrToken;
    int       wCurSelection;                // current selected token.
    UINT      wSaveSelection;               // location in token list where the search began
    TOKEN     tToken;                       // info of current token
    BOOL      fWrapped = FALSE;             // flag to indicate whether we wrapped during the search
    TCHAR     *szBuffer;

    LPTOKDATA lpTokData;

    // get the number of tokens in the list
    wLbCount = (UINT)SendMessage( hListWnd,
                                  LB_GETCOUNT,
                                  (WPARAM)0,
                                  (LPARAM)0);

    // save the current in the token list
    wCurSelection = (UINT)SendMessage( hListWnd,
                                       LB_GETCURSEL,
                                       (WPARAM)0,
                                       (LPARAM)0);
    wSaveSelection = wCurSelection;

    // check for case where there is no current selection.
    if (wCurSelection == (UINT) -1)
    {
        wSaveSelection = wCurSelection = 0;
    }

    while (TRUE)
    {
        // get current token info in the tToken sturcture

        HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             (WPARAM)wCurSelection,
                                             (LPARAM)0);
	//RLedit has different format data.
        lpTokData = (LPTOKDATA)GlobalLock( hMem );
        lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );

        if ( lpstrToken )
        {
            szBuffer = (TCHAR *) FALLOC( MEMSIZE( lstrlen( lpstrToken)+1));
            lstrcpy( szBuffer, lpstrToken);

            GlobalUnlock( lpTokData->hToken );
            GlobalUnlock( hMem);

            ParseBufToTok(szBuffer, &tToken);
            RLFREE( szBuffer);

                // is it a match?
            if ( MatchToken( tToken,
                             szFindType,
                             szFindText,
                             wStatus,
                             wStatusMask)
                && ! fSkipFirst)
            {
                    // yes, select and return TRUE
                RLFREE( tToken.szText);
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             (WPARAM)wCurSelection,
                             (LPARAM)0);
                return (TRUE);
            }
            RLFREE( tToken.szText);
        }
        fSkipFirst = FALSE;

        // no, continue search
        if (fDirection)
        {
            // going upward during the search
            if (--wCurSelection < 0)
            {
                LPSTR pszFind  = NULL;
                DWORD dwMsgLen = 0;

                // reached beginning of the tokens, do we want to wrap

                dwMsgLen = B_FormatMessage((FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                                          | FORMAT_MESSAGE_IGNORE_INSERTS
                                          | FORMAT_MESSAGE_FROM_HMODULE,
                                            NULL,
                                            IDS_REACHEDBEGIN,
                                            szDHW,
                                            DHWSIZE,
                                            NULL);
                pszFind = szDHW + dwMsgLen + 2;

                B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                               | FORMAT_MESSAGE_IGNORE_INSERTS
                               | FORMAT_MESSAGE_FROM_HMODULE,
                                 NULL,
                                 IDS_FINDTOKENS,
                                 pszFind,
                                 DHWSIZE - dwMsgLen - 2,
                                 NULL);
                if ( nUpdateMode == 0
                  && wSaveSelection != wLbCount
                  && !fWrapped
                  && (MessageBoxA( hMainWnd,
                                   szDHW,
                                   pszFind,
                                   MB_ICONQUESTION | MB_YESNO) == IDYES) )
                {
                    // yes, so wrap and reset counters
                    fWrapped = TRUE;
                    wCurSelection = wLbCount-1;
                    wLbCount = wSaveSelection;
                }
                // no, so return FALSE
                else
                {
                    break;
                }
            }
        }
        else
        {
            // going downward during the search
            if (++wCurSelection >= (int) wLbCount)
            {
                LPSTR pszFind  = NULL;
                DWORD dwMsgLen = 0;

                // reached end of the tokens, do we want to wrap

                dwMsgLen = B_FormatMessage((FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                                          | FORMAT_MESSAGE_IGNORE_INSERTS
                                          | FORMAT_MESSAGE_FROM_HMODULE,
                                            NULL,
                                            IDS_REACHEDEND,
                                            szDHW,
                                            DHWSIZE,
                                            NULL);
                pszFind = szDHW + dwMsgLen + 2;

                B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                               | FORMAT_MESSAGE_IGNORE_INSERTS
                               | FORMAT_MESSAGE_FROM_HMODULE,
                                 NULL,
                                 IDS_FINDTOKENS,
                                 pszFind,
                                 DHWSIZE - dwMsgLen - 2,
                                 NULL);
                if ( nUpdateMode == 0
                  && wSaveSelection != wLbCount
                  && !fWrapped
                  && (MessageBoxA( hMainWnd,
                                   szDHW,
                                   pszFind,
                                   MB_ICONQUESTION | MB_YESNO) == IDYES) )
                {
                    // yes, so wrap and reset counters
                    fWrapped = TRUE;
                    wCurSelection = 0;
                    wLbCount = wSaveSelection;
                }
                // no, so return FALSE
                else
                {
                    break;
                }
            }
        }
    }
    return FALSE;
}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

#ifdef NO
void FindAllDirtyTokens(void)
{
    int wSaveSelection;
    extern int wIndex;
    LONG lListParam = 0L;

    // set listbox selection to begining of the token list
    wSaveSelection = SendMessage( hListWnd, LB_GETCURSEL, 0 , 0L);

    wIndex = 0;
    SendMessage(hListWnd, LB_SETCURSEL, wIndex, 0L);

    while (DoTokenSearch (NULL, NULL, ST_TRANSLATED | ST_DIRTY , NULL))
    {
        // go into edit mode
        wIndex = (UINT) SendMessage(hListWnd, LB_GETCURSEL, 0 , 0L);

        lListParam  = MAKELONG(NULL, LBN_DBLCLK);
        SendMessage(hMainWnd, WM_COMMAND, IDC_LIST, lListParam);

        // move selection to next token
        wIndex++;
        SendMessage(hListWnd, LB_SETCURSEL, wIndex, 0L);
    }
    wIndex = wSaveSelection;
    SendMessage(hListWnd, LB_SETCURSEL, wIndex, 0L);
}


#endif

/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/
TCHAR FAR *FindDeltaToken(TOKEN tToken,
                          TOKENDELTAINFO FAR *pTokenDeltaInfo,
                          UINT wStatus)
{
    TOKENDELTAINFO FAR *ptTokenDeltaInfo;
    int found;
    ptTokenDeltaInfo = pTokenDeltaInfo;

    while (ptTokenDeltaInfo)
    {
        found = ((tToken.wType == ptTokenDeltaInfo->DeltaToken.wType)
              && (tToken.wName == ptTokenDeltaInfo->DeltaToken.wName)
              && (tToken.wID == ptTokenDeltaInfo->DeltaToken.wID)
              && (tToken.wFlag == ptTokenDeltaInfo->DeltaToken.wFlag)
              && (wStatus  == (UINT)ptTokenDeltaInfo->DeltaToken.wReserved)
#ifdef UNICODE
              && !_tcscmp((TCHAR FAR *)tToken.szName,
                          (TCHAR *)ptTokenDeltaInfo->DeltaToken.szName)
#else
//                 !lstrcmp((TCHAR FAR *)tToken.szName,
//                          (TCHAR *)ptTokenDeltaInfo->DeltaToken.szName)
              && CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                                 SORT_STRINGSORT,
                                 tToken.szName,
                                 -1,
                                 ptTokenDeltaInfo->DeltaToken.szName,
                                 -1) == 2
#endif

                 );

        if (found)
        {
            return ((TCHAR FAR *)ptTokenDeltaInfo->DeltaToken.szText);
        }
        ptTokenDeltaInfo = ptTokenDeltaInfo->pNextTokenDelta;
    }

    // token not found in token delta info
    return NULL;
}

/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/
TOKENDELTAINFO  FAR *UpdateTokenDeltaInfo(TOKEN *pDeltaToken)
{
    TOKENDELTAINFO FAR *pTokenDeltaInfo = NULL;
    int cTextLen;

    if ( pDeltaToken )
    {
        pTokenDeltaInfo = (TOKENDELTAINFO FAR *)FALLOC( sizeof( TOKENDELTAINFO));

        if ( pTokenDeltaInfo )
        {
            memcpy( (void *)&(pTokenDeltaInfo->DeltaToken),
                    (void *)pDeltaToken,
                    sizeof( TOKEN));

            cTextLen = lstrlen( pDeltaToken->szText) + 1;
            pTokenDeltaInfo->DeltaToken.szText =
                                    (TCHAR *)FALLOC( MEMSIZE( cTextLen));
            memcpy( (void *)pTokenDeltaInfo->DeltaToken.szText,
                    (void *)pDeltaToken->szText,
                    MEMSIZE( cTextLen));
            pTokenDeltaInfo->pNextTokenDelta = NULL;
        }
    }
    return(pTokenDeltaInfo);
}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *    02/93 - changed to use GetToken, rather that reading directly
  *             from the file.  This provides support for long token
  *             text.  MHotchin.
  *
  **/

TOKENDELTAINFO  FAR *InsertTokMtkList(FILE * fpTokFile, FILE *fpMtkFile )
{
    int rcFileCode;
    TOKENDELTAINFO FAR * ptTokenDeltaInfo, FAR * pTokenDeltaInfo = NULL;
    TOKEN tToken;
    UINT wcChars = 0;
    HANDLE         hTokData;
    LPTSTR         lpstrToken;
    LPSTR        lpstrDmy=0;
    LPTOKDATA    lpstrTokData=0;

    rewind(fpTokFile);

    rewind( fpMtkFile );

//only make Dmy buffer
    lpstrDmy = (LPSTR)FALLOC( MEMSIZE(MAXLINE) );


    while ((rcFileCode = GetToken(fpTokFile, &tToken)) >= 0)
    {
        if (rcFileCode == 0)
        {

//For fast moving, save Mtk position
//Create Data
            hTokData = GlobalAlloc( GMEM_MOVEABLE, sizeof(TOKDATA) );
            if( !hTokData ){
                RLFREE(tToken.szText);
                RLFREE( lpstrDmy );
                QuitA( IDS_ENGERR_16, (LPSTR)IDS_ENGERR_11, NULL);
            }
            lpstrTokData = (LPTOKDATA)GlobalLock( hTokData );

//MtkFilePointer get
            if( (lpstrTokData->lMtkPointer=ftell(fpMtkFile)) >= 0 ){
                TOKEN    cToken, ccToken;
                BOOL    fFound;
                if( !GetToken(fpMtkFile,&cToken) )
                {
                    RLFREE(cToken.szText);

                    if( cToken.wReserved & ST_CHANGED ){
                        if( !GetToken(fpMtkFile,&ccToken) )
                        {
                            RLFREE(ccToken.szText);
                            fFound = ((cToken.wType ==ccToken.wType)
                                   && (cToken.wName == ccToken.wName)
                                   && (cToken.wID   == ccToken.wID)
                                   && (cToken.wFlag == ccToken.wFlag)
                                   && (_tcscmp((TCHAR *)cToken.szName,
                                       (TCHAR *)ccToken.szName) == 0));
                            fseek( fpMtkFile,
                                lpstrTokData->lMtkPointer, SEEK_SET);
                            fgets( lpstrDmy, MAXLINE, fpMtkFile );
                            if( fFound )
                                fgets( lpstrDmy, MAXLINE, fpMtkFile );
                        }
                    }
                }
            }

            if(tToken.wReserved & ST_TRANSLATED)
            {
                TCHAR *szTokBuf;

                szTokBuf = (TCHAR *) FALLOC(MEMSIZE(TokenToTextSize(&tToken)));
                ParseTokToBuf(szTokBuf, &tToken);

                // only add tokens with the translated status bit set to the token list
                lpstrTokData->hToken = GlobalAlloc(GMEM_MOVEABLE,
                    MEMSIZE(lstrlen((TCHAR *)szTokBuf)+1));

                if (!lpstrTokData->hToken){
                    RLFREE(tToken.szText);                    // MHotchin
                    RLFREE(szTokBuf);
                    RLFREE( lpstrDmy );
                    QuitA(IDS_ENGERR_16, (LPSTR)IDS_ENGERR_11, NULL);
                }

                lpstrToken = (LPTSTR) GlobalLock( lpstrTokData->hToken );
                lstrcpy (lpstrToken, szTokBuf);
                GlobalUnlock( lpstrTokData->hToken );
                GlobalUnlock( hTokData );
                RLFREE(szTokBuf);

                if( SendMessage(hListWnd,LB_ADDSTRING,0,(LONG_PTR)hTokData) < 0){
                    RLFREE(tToken.szText);                    // MHotchin
                    RLFREE( lpstrDmy );
                    QuitA (IDS_ENGERR_16, (LPSTR)IDS_ENGERR_11, NULL);
                }
            }
            else
            {
                // the current token is delta info so save in delta list.
                if (!pTokenDeltaInfo){
                    ptTokenDeltaInfo = pTokenDeltaInfo =
                        UpdateTokenDeltaInfo(&tToken);
                }
                else{
                    ptTokenDeltaInfo->pNextTokenDelta =
                        UpdateTokenDeltaInfo(&tToken);
                    ptTokenDeltaInfo = ptTokenDeltaInfo->pNextTokenDelta;
                }
//don't use TokData
                GlobalUnlock( hTokData );
                GlobalFree( hTokData );
            }

            RLFREE(tToken.szText);                    // MHotchin
        }
    }

    RLFREE( lpstrDmy );
    return(pTokenDeltaInfo);

}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/
void GenStatusLine( TOKEN *pTok)
{
    TCHAR szName[32];
    TCHAR szStatus[20];
#ifdef UNICODE
    CHAR  szTmpBuf[32];
#endif //UNICODE
    TCHAR szResIDStr[20];
    static BOOL fFirstCall = TRUE;

    if (fFirstCall)
    {
        SendMessage( hStatusWnd,
                     WM_FMTSTATLINE,
                     (WPARAM)0,
                     (LPARAM)TEXT("15s7s4i5s4i"));
        fFirstCall = FALSE;
    }

    if (pTok->szName[0])
    {
        lstrcpy( szName, pTok->szName);
    }
    else
    {
#ifdef UNICODE
        _itoa(pTok->wName, szTmpBuf, 10);
        _MBSTOWCS( szName,
                   szTmpBuf,
                   WCHARSIN( sizeof( szTmpBuf)),
                   ACHARSIN( lstrlenA( szTmpBuf) + 1));
#else
        _itoa(pTok->wName, szName, 10);
#endif
    }

    if (pTok->wReserved & ST_READONLY)
    {
        LoadString( hInst, IDS_READONLY, szStatus, TCHARSIN( sizeof( szStatus)));
    }
    else if (pTok->wReserved & ST_DIRTY)
    {
        LoadString( hInst, IDS_DIRTY, szStatus, TCHARSIN( sizeof( szStatus)));
    }
    else
    {
        LoadString( hInst, IDS_CLEAN, szStatus, TCHARSIN( sizeof( szStatus)));
    }

    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)3, (LPARAM)szStatus);

    if (pTok->wType <= 16)
    {
        LoadString( hInst,
                    IDS_RESOURCENAMES+pTok->wType,
                    szResIDStr,
                    TCHARSIN( sizeof( szResIDStr)));
    }
    else
    {

#ifdef UNICODE
        _itoa(pTok->wType, szTmpBuf, 10);
        _MBSTOWCS( szResIDStr,
                   szTmpBuf,
                   WCHARSIN( sizeof( szTmpBuf)),
                   ACHARSIN( lstrlenA( szTmpBuf) + 1));
#else
        _itoa(pTok->wType, szResIDStr, 10);
#endif
    }
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)0,
                 (LPARAM)szName);
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)1,
                 (LPARAM)szResIDStr);
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)2,
                 (LPARAM)pTok->wID);
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)4,
                 (LPARAM)lstrlen( pTok->szText));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\update.c ===
/** Update.c
  *
  * Resource update tool.
  *
  * Written by SteveBl
  *
  * Exported Functions:
  * int PrepareUpdate(TCHAR *szResourcePath,TCHAR *szMasterTokenFile);
  *
  * int Update(TCHAR *szMasterTokenFile, TCHAR *szLanguageTokenFile);
  *
  * History:
  * Initial version written January 31, 1992.  -- SteveBl
  **/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <io.h>
#include <string.h>
#include <tchar.h>

#include "windefs.h"
#include "restok.h"
#include "custres.h"
#include "update.h"
#include "resread.h"

extern char *gszTmpPrefix;
extern UCHAR szDHW[];


/** Function: Update
  * Updates a language token file from a master token file.
  * This step should be executed after a Prepare Update.
  *
  * Arguments:
  * szMasterTokenFile, token file created by PrepareUpdate.
  * szLanguageTokenFile, token file to be updated with new tokens.
  *
  * Returns:
  * updated token file
  *
  * Error Codes:
  * 0  - successfull execution
  * !0 - error
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  **/

int Update(

CHAR *szMasterTokenFile,    //... Master token file to update from.
CHAR *szLanguageTokenFile)  //... Token file to update or create.
{
    FILE *pfMTK = NULL;
    FILE *pfTOK = NULL;
    FILE *pfTmpTOK = NULL;
    int rc = 0;
    static TOKEN MstrTok;
    static TOKEN LangTok;
    static CHAR szTempTok[ MAX_PATH+1];
    

    MstrTok.szText = NULL;
    LangTok.szText = NULL;

    rc = MyGetTempFileName( 0, "", 0, szTempTok);
    
    pfMTK = FOPEN( szMasterTokenFile, "rt");

    if ( pfMTK == NULL )
    {
        QuitA( IDS_ENGERR_01, "Master token", szMasterTokenFile);
    }

    rc = _access( szLanguageTokenFile, 0);

    if ( rc != 0 )
    {
                                // Token file does not exist CREAT IT
        
        if ( (pfTOK = FOPEN( szLanguageTokenFile, "wt")) == NULL )
        {
            FCLOSE( pfMTK);
            QuitA( IDS_ENGERR_02, szLanguageTokenFile, NULL);
        }
        
        do
        {
            rc = GetToken( pfMTK, &MstrTok);
            
                                // If rc > 0, empty line or comment found
                                // and will not be copied to token file.

            if ( rc == 0 )
            {
                if ( *(MstrTok.szText) == TEXT('\0') ) // Empty token  (PW)
                {
                                // Do not mark empty token as DIRTY
                    
                    MstrTok.wReserved = ST_TRANSLATED;
                }
                else
                {
                    if (MstrTok.wReserved == ST_READONLY)
                    {
                        MstrTok.wReserved = ST_TRANSLATED | ST_READONLY;
                    }
                    else
                    {
                        MstrTok.wReserved = ST_TRANSLATED | ST_DIRTY;
                    }
                }                
                PutToken( pfTOK, &MstrTok);
                RLFREE( MstrTok.szText);
            }

        } while ( rc >= 0 );
        
        FCLOSE( pfMTK);
        FCLOSE( pfTOK);
        
        if ( rc == -2 )
        {
            QuitT( IDS_ENGERR_11, (LPTSTR)IDS_UPDMODE, NULL);
        }
    }
    else
    {                           // file exists -- UPDATE IT
        
        pfTOK = FOPEN(szLanguageTokenFile, "rt");

        if ( pfTOK == NULL)
        {
            FCLOSE( pfMTK);
            QuitA( IDS_ENGERR_01, "Language token", szLanguageTokenFile);
        }
        
        pfTmpTOK = FOPEN(szTempTok, "wt");

        if ( pfTmpTOK == NULL)
        {
            FCLOSE( pfMTK);
            FCLOSE( pfTOK);
            QuitA( IDS_ENGERR_02, szTempTok, NULL);
        }
        
        do
        {
            rc = GetToken( pfTOK, &LangTok);
            
                                // If rc > 0, empty line or comment found
                                // and will not be copied to token file.

            if ( rc == 0 )
            {
                if ( LangTok.wReserved & ST_TRANSLATED )
                {
                    PutToken( pfTmpTOK, &LangTok);
                }
                RLFREE( LangTok.szText);
            }

        } while ( rc >= 0 );
        
        FCLOSE( pfTOK);
        FCLOSE( pfTmpTOK);
        
        if( rc == -2 )
        {
            QuitT( IDS_ENGERR_11, (LPTSTR)IDS_UPDMODE, NULL);
        }
        
        pfTmpTOK = FOPEN(szTempTok, "rt");

        if ( pfTmpTOK == NULL )
        {
            FCLOSE( pfMTK);
            QuitA( IDS_ENGERR_01, "temporary token", szTempTok);
        }
        
        pfTOK = FOPEN(szLanguageTokenFile, "wt");

        if ( pfTOK == NULL )
        {
            FCLOSE( pfMTK);
            FCLOSE( pfTOK);
            QuitA( IDS_ENGERR_02, szLanguageTokenFile, NULL);
        }
        
        do
        {
            rc = GetToken( pfMTK, &MstrTok);
            
                                // If rc > 0, empty line or comment found
                                // and will not be copied to token file.

            if ( rc == 0 )
            {
                int fTokenFound = 0;
                
                LangTok.wType     = MstrTok.wType;
                LangTok.wName     = MstrTok.wName;
                LangTok.wID       = MstrTok.wID;
                LangTok.wFlag     = MstrTok.wFlag;
                LangTok.wLangID   = MstrTok.wLangID;
                LangTok.wReserved = ST_TRANSLATED;
				LangTok.szText    = NULL;

                lstrcpy( LangTok.szType, MstrTok.szType);
                lstrcpy( LangTok.szName, MstrTok.szName);
                
                if ( MstrTok.wReserved & ST_READONLY )
                {
                    fTokenFound = 1;
                    LangTok.szText = (TCHAR *)FALLOC( 0);
                }
                else if ( MstrTok.wReserved != ST_CHANGED )
                {
                    fTokenFound = FindToken( pfTmpTOK, &LangTok, ST_TRANSLATED);
                }
                
                if ( fTokenFound )
                {
                    if ( MstrTok.wReserved & ST_READONLY )
                    {
                                // token marked read only in token file and
                                // this token is not an old token
                        
                        MstrTok.wReserved = ST_READONLY | ST_TRANSLATED;
                        
                        PutToken( pfTOK, &MstrTok);
                    }
                    else if ( MstrTok.wReserved & ST_NEW )
                    {
                                // flagged as new but previous token existed
                        
                        if ( LangTok.szText[0] == TEXT('\0') )
                        {
                                // Put new text in token, easier for
                                // the localizers to see.

                            RLFREE( LangTok.szText);
                            LangTok.szText =
                                (TCHAR *) FALLOC(
                                         MEMSIZE( lstrlen( MstrTok.szText)+1));
                            lstrcpy( LangTok.szText, MstrTok.szText);                            
                        }
                        LangTok.wReserved = ST_TRANSLATED|ST_DIRTY;
                        
                        PutToken( pfTOK, &LangTok);
                        
                                // write out as a new untranslated token
                        
                        MstrTok.wReserved = ST_NEW;
                        
                        PutToken( pfTOK, &MstrTok);
                    }
                    else if ( MstrTok.wReserved & ST_CHANGED )
                    {
                                // Language token is empty, but new
                                // token contains text.
                        
                        if ( MstrTok.wReserved == (ST_CHANGED | ST_NEW) )
                        {
                            
                            if ( LangTok.szText[0] == TEXT('\0') )
                            {
                                RLFREE( LangTok.szText);
                                LangTok.szText = (TCHAR *)
                                    FALLOC(
                                        MEMSIZE( lstrlen( MstrTok.szText)+1));
                                
                                lstrcpy( LangTok.szText, MstrTok.szText);
                            }
                            LangTok.wReserved = ST_DIRTY|ST_TRANSLATED;
                            
                            PutToken( pfTOK, &LangTok);
                        }
                                // only write old token once
                        
                        MstrTok.wReserved &= ST_NEW;
                        
                        PutToken( pfTOK, &MstrTok);
                    }
                    else
                    {
                                // token did not change at all
                        
								//If align info was added into Mtk, add it to Tok also.
                        int l1, r1, t1, b1, l2, r2, t2, b2;
                        TCHAR   a1[20], a2[20], *ap;

                                                   //Cordinates token?
                        if ( (LangTok.wType == ID_RT_DIALOG)
						    && (LangTok.wFlag&ISCOR)
                                                   //Not including align info?
                            && _stscanf( LangTok.szText, TEXT("%d %d %d %d %s"),
						        		&l1,&r1,&t1,&b1,a1) == 4
                                                   //Including align info?
                            && _stscanf( MstrTok.szText, TEXT("%d %d %d %d %s"),
                                		&l2,&r2,&t2,&b2,a2) == 5 
                            && (ap = _tcschr( MstrTok.szText,TEXT('('))) )
                        {
                            RLFREE( LangTok.szText );
                            LangTok.szText = (TCHAR *)FALLOC(
                                        MEMSIZE( _tcslen( MstrTok.szText)+1));
                            _stprintf( LangTok.szText,
                                TEXT("%4hd %4hd %4hd %4hd %s"), l1, r1, t1, b1, ap );
                        }
								//If LangToken is Version stamp and szTexts is "Translation",
								//it is 1.0 version format. So Translate it.
                        if ( LangTok.wType == ID_RT_VERSION
                            && ! _tcscmp( LangTok.szText, TEXT("Translation")) )
                        {
                            
                            _stprintf( LangTok.szText, 
                            		  TEXT("%04x 04b0"), 
                            		  GetUserDefaultLangID());
                        }
                        PutToken( pfTOK, &LangTok);
                    }
                    RLFREE( LangTok.szText);
                }
                else
                {
                                // BRAND NEW TOKEN
                    
                                // write out any token but a changed mstr token.
                    
                    if ( MstrTok.wReserved != ST_CHANGED )
                    {
                                // do not write out old changed tokens if
                                // there is no token in target
                        
                        if ( MstrTok.wReserved == ST_READONLY )
                        {
                            MstrTok.wReserved = ST_TRANSLATED | ST_READONLY;
                        }
                        else
                        {
								//If MstrTok is Version stamp and there are 1.0 format Version stamp,
								//insert 1.0 version stamp by 1.7 format but flag should be TRANSLATED. 
                            if ( MstrTok.wType == ID_RT_VERSION )
                            {
                                LangTok.szText = NULL;
                                LangTok.wFlag = 1;
                                _tcscpy( LangTok.szName, TEXT("VALUE") );
																
                                if ( FindToken( pfTmpTOK, &LangTok, ST_TRANSLATED))
                                {
                                    MstrTok.wReserved = ST_TRANSLATED;
                                    RLFREE( MstrTok.szText );
                                    MstrTok.szText = LangTok.szText;
                                }
								else
								    MstrTok.wReserved = ST_TRANSLATED|ST_DIRTY;
                             }
                             else
                                MstrTok.wReserved = ST_TRANSLATED|ST_DIRTY;
                        }
                        
                        if ( MstrTok.szText[0] == 0 )
                        {
                            MstrTok.wReserved = ST_TRANSLATED;
                        }
                        PutToken( pfTOK, &MstrTok);
                    }
                }
                RLFREE( MstrTok.szText);
            }

        } while ( rc >= 0 );
        
        FCLOSE( pfMTK);
        FCLOSE( pfTmpTOK);
        FCLOSE( pfTOK);
        
        
        if ( rc == -2 )
        {
            QuitT( IDS_ENGERR_11, (LPTSTR)IDS_UPDMODE, NULL);
        }
        remove( szTempTok);
    }
    return( 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\wincomon.h ===
#ifndef _WINCOMON_H_
#define _WINCOMON_H_

extern HWND   hMainWnd;
extern CHAR   szFileName[];
extern CHAR   szAppName[];
extern CHAR   szCustFilterSpec[MAXCUSTFILTER];
extern CHAR   szFileTitle[];

BOOL	      GetFileNameFromBrowse( HWND, PSTR, UINT, PSTR, PSTR, PSTR );
INT_PTR APIENTRY StatusWndProc( HWND, UINT, WPARAM, LPARAM);
void	      cwCenter( HWND, int);
int	      LoadStrIntoAnsiBuf( HINSTANCE, UINT, LPSTR, int);
BOOL	      LoadNewFile(CHAR *);
void          szFilterSpecFromSz1Sz2(char *sz,char *sz1,char *sz2);
void          CatSzFilterSpecs(char *sz,char *sz1,char *sz2);


#endif // _WINCOMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rladmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RLADMIN.RC
//
#define IDS_SELECTLANG                  3101
#define IDS_NOCPXTABLE                  3102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        7001
#define _APS_NEXT_COMMAND_VALUE         6001
#define _APS_NEXT_CONTROL_VALUE         5002
#define _APS_NEXT_SYMED_VALUE           8001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\wincomon.c ===
// Not sure which of these includes are/will be needed - t-gregti

#include <windows.h>
//#include <port1632.h>
#include <commdlg.h>

// CRT includes
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <io.h>
#include <time.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <ctype.h>

// RL TOOLS SET includes
#include "windefs.h"
#include "restok.h"
#include "wincomon.h"


int LoadStrIntoAnsiBuf(

HINSTANCE hinst,
UINT      idResource,
LPSTR     lpszBuffer,
int       cbBuffer )
{
    int rc;
#ifdef RLRES32
    WCHAR tszTmpBuf[256];

    rc = LoadString( hinst, idResource, tszTmpBuf,  TCHARSIN( sizeof( tszTmpBuf)));
    _WCSTOMBS( lpszBuffer,
               tszTmpBuf,
               cbBuffer,
               lstrlen( tszTmpBuf ) + 1 );
#else
    rc = LoadString( hinst, idResource, lpszBuffer, cbBuffer );
#endif
    return( rc);
}

/**
*  Function: GetFileNameFromBrowse.
  * Uses the commdlg.dll GetOpenFileName function to prompt the user
  * file name.
  *
  *  Arguments:
  *     hDlg, Owner for browse dialog.
  *     pszFileName,   // buffer to insert file name
  *     cbFilePath,    // Max length of file path buffer.
  *     szTitle,       // Working directory
  *     szFilter,      // filters string.
  *     szDefExt       // Default extension to file name
  *
  *  Returns:
  * TRUE, pszFileName contains file name.
  * FALSE, GetFileName aborted.
  *
  *  History:
  * 9/91 Copied from NotePad sources.       TerryRu.
  **/
BOOL GetFileNameFromBrowse(HWND hDlg,
       PSTR pszFileName,
       UINT cbFilePath,
       PSTR szTitle,
       PSTR szFilter,
       PSTR szDefExt)
{
    OPENFILENAMEA ofn;       // Structure used to init dialog.
    CHAR szBrowserDir[128]; // Directory to start browsing from.
    szBrowserDir[0] = '\0'; // By default use CWD.


    // initalize ofn to NULLS

    memset( (void *)&ofn, 0, sizeof( OPENFILENAMEA ) );

    /* fill in non-variant fields of OPENFILENAMEA struct. */

    ofn.lStructSize     = sizeof(OPENFILENAMEA);
    ofn.lpstrCustomFilter   = szCustFilterSpec;
    ofn.nMaxCustFilter      = MAXCUSTFILTER;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = pszFileName;
    ofn.nMaxFile            = MAXFILENAME;
    ofn.lpstrFileTitle      = szFileTitle;
    ofn.nMaxFileTitle       = MAXFILENAME;
    ofn.lpTemplateName      = NULL;
    ofn.lpfnHook            = NULL;

    // Setup info for comm dialog.
    ofn.hwndOwner           = hDlg;
    ofn.lpstrInitialDir     = szBrowserDir;
    ofn.Flags               = OFN_HIDEREADONLY;
    ofn.lpstrDefExt         = szDefExt;
    ofn.lpstrFileTitle      = szFileTitle;
    ofn.lpstrTitle          = szTitle;
    ofn.lpstrFilter         = szFilter;

    // Get a filename from the dialog.
    return GetOpenFileNameA(&ofn);
}

#define MAX_STATUS_FIELDS 5
#define MAXBUFFERSIZE     80

/****************************************************************************
*Procedure: StatusWndProc
*
*Inputs:
*
*Returns:
*    depends on message
*
*History:
*    7/92 - created - t-gregti
*
*Comments:
*    More general than strictly neccesary for the RL tools, but
*    it makes adding new fields to the status line really easy.
*    For WM_FMTSTATLINE the lParam should be a string with length/type pairs
*    much like a printf format, e.g. "10s5i10s20i".
*    For WM_UPDSTATLINE the wParam contains the field to change and the lParam
*    contains a pointer to a string or int to display.
*
*****************************************************************************/

INT_PTR APIENTRY StatusWndProc( HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    PAINTSTRUCT ps;
    HDC hDC;
    static HFONT hFontCourier;
        static UINT cFields = 0;
        static UINT aiSize[MAX_STATUS_FIELDS];
        static TCHAR aszStatusStrings[MAX_STATUS_FIELDS][MAXBUFFERSIZE];
        static BOOL abIntegers[MAX_STATUS_FIELDS];

    switch( wMsg )
    {
    case WM_CREATE:
        {
                LOGFONT lf;

        memset( (void *)&lf, 0, sizeof(LOGFONT) );

                // Intialize font info
                lf.lfWeight         = 400; //Normal
                lf.lfCharSet        = ANSI_CHARSET;
                lf.lfOutPrecision   = OUT_DEFAULT_PRECIS;
                lf.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
                lf.lfQuality        = PROOF_QUALITY;
                lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
                lf.lfHeight         = 14;
                lf.lfWidth          = 0;
                lf.lfUnderline      = 0;
        lstrcpy ( lf.lfFaceName, TEXT("Courier"));

                // Get a handle to the courier font
        hFontCourier = CreateFontIndirect( (void *)& lf );

                break;
    }

    case WM_DESTROY:
        DeleteObject((HGDIOBJ)hFontCourier);
                break;

        case WM_FMTSTATLINE:
        {
                TCHAR *psz;

#ifdef RLRES32
                CHAR sz[MAXBUFFERSIZE];
#endif

                cFields = 0;

                for (psz = (LPTSTR)lParam; *psz; psz++)
                {
                    cFields++;

#ifdef RLRES32
                    _WCSTOMBS( sz,
                               psz,
                               ACHARSIN( sizeof( sz)),
                               lstrlen( psz) + 1);
                        aiSize[cFields-1] = atoi(sz);
#else
                        aiSize[cFields-1] = atoi(psz);
#endif

                        while(_istdigit(*psz))
                        {
                                psz++;
                        }

                        switch(*psz)
                        {
                        case 'i':
                                abIntegers[cFields-1] = TRUE;
                                break;
                        case 's':
                                abIntegers[cFields-1] = FALSE;
                                break;
                        default:
                                cFields = 0;
                                return(FALSE);
                        }
                }
                return(TRUE);
        }


    case WM_UPDSTATLINE:
                // intialize status line info, and force it to be painted
                if (wParam > cFields)
                {
                        return(FALSE);
                }
                if (abIntegers[wParam]) // Is it for an integer field?
                {
#ifdef RLRES32
                        char sz[MAXBUFFERSIZE] = "";

                        _itoa((INT)lParam, sz, 10);
                        _MBSTOWCS( aszStatusStrings[ wParam],
                                   sz,
                                   WCHARSIN( sizeof( sz)),
                                   ACHARSIN( lstrlenA( sz)+1));
#else
                        _itoa(lParam, aszStatusStrings[wParam], 10);
#endif
                }
                else
                {

#ifdef RLWIN32
                        CopyMemory( aszStatusStrings[ wParam],
                                    (LPTSTR)lParam,
                                    min( MAXBUFFERSIZE, MEMSIZE( lstrlen( (LPTSTR)lParam) + 1)));
                        aszStatusStrings[ wParam][ MAXBUFFERSIZE - 1] = TEXT('\0');
#else
                        _fstrncpy(aszStatusStrings[wParam], (LPTSTR)lParam, MAXBUFFERSIZE-1);
#endif
                        aszStatusStrings[wParam][MAXBUFFERSIZE-1] = 0;
                }
                InvalidateRect( hWnd, NULL, TRUE );
                break;

    case WM_PAINT:
    {
                RECT r;
        HFONT hOldFont;
                HBRUSH hbrOld, hbrFace, hbrHilite, hbrShadow;
                TEXTMETRIC tm;
                int iWidth, iHeight;
                UINT i;

                /* Obtain a handle to the device context        */
        memset((void *)&ps, 0x00, sizeof(PAINTSTRUCT));
                hDC = BeginPaint(hWnd, &ps);
                GetTextMetrics(hDC, &tm);

                GetClientRect( hWnd, &r );
                iWidth  = r.right  - r.left;
                iHeight = r.bottom - r.top;

                // Create the brushes for the 3D effect
                hbrFace   = CreateSolidBrush(RGB(0xC0, 0xC0, 0xC0));
                hbrHilite = CreateSolidBrush(RGB(0xFF, 0xFF, 0xFF));
                hbrShadow = CreateSolidBrush(RGB(0x80, 0x80, 0x80));

                // Paint outer 3D effect for raised slab
        hbrOld = (HBRUSH)SelectObject(hDC, (HGDIOBJ)hbrHilite);
                PatBlt(hDC, r.left, r.top, iWidth, 1, PATCOPY);
                PatBlt(hDC, r.left, r.top+1, 1, iHeight-2, PATCOPY);
        SelectObject(hDC, (HGDIOBJ)hbrShadow);
                PatBlt(hDC, r.left, r.bottom-1, iWidth, 1, PATCOPY);
                PatBlt(hDC, r.right-1, r.top+1, 1, iHeight-2, PATCOPY);

                // Paint surface of slab
                r.left   += 1;
                r.top    += 1;
                r.right  -= 1;
                r.bottom -= 1;
                iWidth   -= 2;
                iHeight  -= 2;
        SelectObject(hDC, (HGDIOBJ)hbrFace);
                PatBlt(hDC, r.left, r.top, iWidth, iHeight, PATCOPY);

                // Get Courier font
        hOldFont = (HFONT)SelectObject( hDC, (HGDIOBJ)hFontCourier );
                SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

                // Paint inner 3D effect for tray carved into slab and write text
                r.left   += 9;
                r.right  -= 9;
                r.top    += 3;
                r.bottom -= 3;
                iHeight = r.bottom - r.top;

                for (i = 0; i < cFields; i++)
                {
                        iWidth = tm.tmMaxCharWidth * aiSize[i];
                        r.right = r.left + iWidth - 2;
            SelectObject(hDC, (HGDIOBJ)hbrShadow);
                        PatBlt(hDC, r.left-1, r.top-1, iWidth, 1, PATCOPY);
                        PatBlt(hDC, r.left-1, r.top, 1, iHeight-2, PATCOPY);
            SelectObject(hDC, (HGDIOBJ)hbrHilite);
                        PatBlt(hDC, r.left-1, r.bottom, iWidth, 1, PATCOPY);
                        PatBlt(hDC, r.left + iWidth-1, r.top, 1, iHeight-2, PATCOPY);
                        DrawText(hDC, aszStatusStrings[i],
                                         STRINGSIZE( lstrlen( aszStatusStrings[i])),
                                         &r, DT_SINGLELINE);
                        r.left += iWidth + 8;
                }

                // Put old brush back and delete the rest
        SelectObject(hDC, (HGDIOBJ)hbrOld);
        DeleteObject((HGDIOBJ)hbrFace);
        DeleteObject((HGDIOBJ)hbrHilite);
        DeleteObject((HGDIOBJ)hbrShadow);

        SelectObject(hDC,(HGDIOBJ)hOldFont);
        EndPaint ( hWnd, (CONST PAINTSTRUCT *)&ps );

                break;  /*  End of WM_PAINT */
    }

    }
    return( DefWindowProc( hWnd, wMsg, wParam, lParam ));
}

/**
  *  Function: cwCenter
  *   Centers Dialog boxes in main window.
  *
  **/

void cwCenter( HWND hWnd, int top )
{
    POINT   pt;
    RECT    swp;
    RECT    rParent;
    int     iwidth;
    int     iheight;

    GetWindowRect(hWnd, &swp);
    GetWindowRect(hMainWnd, &rParent);

    /* calculate the height and width for MoveWindow    */
    iwidth = swp.right - swp.left;
    iheight = swp.bottom - swp.top;

    /* find the center point */
    pt.x = (rParent.right - rParent.left) / 2;
    pt.y = (rParent.bottom - rParent.top) / 2;

    /* calculate the new x, y starting point    */
    pt.x = pt.x - (iwidth / 2);
    pt.y = pt.y - (iheight / 2);

    ClientToScreen(hMainWnd,&pt);


    /* top will adjust the window position, up or down  */
    if(top)
        pt.y = pt.y + top;

    if (pt.x < 0)
        pt.x=0;
    else
        if (pt.x + iwidth > GetSystemMetrics(SM_CXSCREEN))
            pt.x = GetSystemMetrics(SM_CXSCREEN)-iwidth;

    /* move the window         */
    MoveWindow(hWnd, pt.x, pt.y, iwidth, iheight, FALSE);
}

/**
  *  Function: szFilterSpecFromSz1Sz2
  *    Returns a filter spec with the format "%s\0%s\0\0" suitable for
  *    use with the Windows 3.1 standard load dialog box.
  *
  *  Arguments:
  *    sz, destination buffer
  *    sz1, first string
  *    sz2, second string
  *
  *  Returns:
  *    result in sz
  *
  *  Error Codes:
  *    none
  *
  *  Comments:
  *    Performs no bounds checking.  sz is assumed to be large enough to
  *    accomidate the filter string.
  *
  *  History:
  *    2/92, Implemented    SteveBl
  */
void szFilterSpecFromSz1Sz2(CHAR *sz,CHAR *sz1, CHAR *sz2)
{
    int i1 = 0;
    int i2 = 0;

    while (sz[i1++] = sz1[i2++]);
    i2 = 0;

    while (sz[i1++] = sz2[i2++]);
    sz[i1]=0;
}

/**
  *  Function: CatSzFilterSpecs
  *    Concatonates two szFilterSpecs (double null terminated strings)
  *    and returns a buffer with the result.
  *
  *  Arguments:
  *    sz, destination buffer
  *    sz1, first Filter Spec
  *    sz2, second Filter Spec
  *
  *  Returns:
  *    result in sz
  *
  *  Error Codes:
  *    none
  *
  *  Comments:
  *    performs no bounds checking
  *
  *  History:
  *    3/92, initial implementation -- SteveBl
  */
void CatSzFilterSpecs(CHAR *sz,CHAR *sz1,CHAR *sz2)
{
    int i1 = 0;
    int i2 = 0;

    while (sz1[i2] || sz1[i2+1]) // looking for double byte
    {
        sz[i1++]=sz1[i2++];
    }
    sz[i1++] = '\0';
    i2 = 0;
    while (sz2[i2] || sz2[i2+1])
    {
        sz[i1++]=sz2[i2++];
    }
    sz[i1++] = '\0';
    sz[i1++] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rledit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by rledit.rc
//
#define IDC_APPENDREPLACE               1007
#define IDS_NOCPXTABLE                  3101
#define IDS_WILLREPLACE                 3102
#define IDS_WILLAPPEND                  3103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rladmin\rladmin.h ===
#ifndef _RLADMIN_H_
#define _RLADMIN_H_

#include "rlstrngs.h"
#include "resourc2.h"

void cwCenter(HWND, int);

INT_PTR FAR PASCAL MainWndProc(HWND, UINT,  WPARAM, LPARAM);
INT_PTR FAR PASCAL GENERATEMsgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR FAR PASCAL EXECUTEDLGEDITMsgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR FAR PASCAL EXECUTERCWMsgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR FAR PASCAL TOKENIZEMsgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR FAR PASCAL TOKFINDMsgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR FAR PASCAL TRANSLATEMsgProc( HWND, UINT, WPARAM, LPARAM );

#define MAXFILENAME     256         /* maximum length of file pathname      */
#define MAXCUSTFILTER   40          /* maximum size of custom filter buffer */
#define CCHNPMAX        65535       /* max number of bytes in a notepad file */


void        CwUnRegisterClasses(void);
INT_PTR     DoMenuCommand    ( HWND, UINT, WPARAM, LPARAM );
INT_PTR     DoListBoxCommand ( HWND, UINT, WPARAM, LPARAM );
TCHAR        FAR *FindDeltaToken( TOKEN , TOKENDELTAINFO FAR * , UINT );
BOOL        GetFileNameFromBrowse( HWND, PSTR, UINT, PSTR, PSTR, PSTR );
BOOL        InitApplication(HINSTANCE);
BOOL        InitInstance(HINSTANCE, int);
TOKENDELTAINFO FAR *InsertTokList( FILE * );
void        FindAllDirtyTokens( void );
void        MakeNewExt ( TCHAR *, TCHAR *, TCHAR * );
int         nCwRegisterClasses(void);
void        SetNewBuffer(HWND, HANDLE, PSTR);

#ifdef RLWIN32
INT_PTR     CALLBACK TokEditDlgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR     CALLBACK NewDlgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR     CALLBACK ViewDlgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR     CALLBACK About( HWND, UINT, WPARAM, LPARAM );
#else
BOOL        APIENTRY TokEditDlgProc( HWND, UINT, UINT, LONG );
BOOL        APIENTRY NewDlgProc( HWND, UINT, UINT, LONG );
BOOL        APIENTRY ViewDlgProc( HWND, UINT, UINT, LONG );
BOOL        APIENTRY About( HWND, UINT, UINT, LONG );
#endif // RLWIN32

#endif // _RLADMIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rladmin\rladmin.c ===
// INCLUSION PREVENTION DEFINITIONS
#define NOMETAFILE
#define NOMINMAX
#define NOSOUND
#define NOPROFILER
#define NODEFERWINDOWPOS
#define NODRIVERS
#define NOCOMM
#define NOBITMAP
#define NOSCROLL
#define NOWINOFFSETS
#define NOWH
#define NORASTEROPS
#define NOOEMRESOURCE
#define NOGDICAPMASKS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NOATOM
#define NOLOGERROR
#define NOSYSTEMPARAMSINFO

#include <windows.h>

#ifdef RLWIN32
#include <windowsx.h>
#endif

#include <commdlg.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>

#include "windefs.h"
#include "toklist.h"
#include "RLADMIN.H"
#include "RESTOK.H"
#include "update.h"
#include "custres.h"
#include "exe2res.h"
#include "commbase.h"
#include "wincomon.h"
#include "projdata.h"
#include "showerrs.h"
#include "resread.h"
#include "langlist.h"
#include "resource.h"

// Global Variables:

extern BOOL     gbMaster;
extern MSTRDATA gMstr;
extern PROJDATA gProj;
extern UCHAR    szDHW[];

extern BOOL     bRLGui;

#ifdef WIN32
    HINSTANCE   hInst;          // Instance of the main window
#else
    HWND        hInst;          // Instance of the main window
#endif

int  nUpdateMode    = 0;
BOOL fCodePageGiven = FALSE;    //... Set to TRUE if -p arg given
CHAR szFileTitle[14] = "";      // holds base name of latest opened file
CHAR szCustFilterSpec[MAXCUSTFILTER]="";    // custom filter buffer
HWND hMainWnd   = NULL;         // handle to main window
HWND hListWnd   = NULL;         // handle to tok list window
HWND hStatusWnd = NULL;         // handle to status windows


static int     iLastBox    = IDD_SOURCERES;
static CHAR  * gszHelpFile = "rltools.hlp";
static TCHAR   szSearchType[80]   = TEXT("");
static TCHAR   szSearchText[4096] = TEXT("");
static WORD    wSearchStatus = 0;
static WORD    wSearchStatusMask = 0;
static BOOL    fSearchDirection;
static BOOL    fSearchStarted = FALSE;
static BOOL    fLanguageGiven = FALSE;
static BOOL    fLangSelected  = FALSE;

static void           DrawLBItem(         LPDRAWITEMSTRUCT lpdis);
static void           MakeStatusLine(     TOKEN *pTok);
static BOOL           SaveMtkList(        HWND hWnd, FILE *fpTokFile);
static TOKENDELTAINFO FAR *InsertMtkList( FILE * fpTokFile);
static void           CleanDeltaList(     void);

static long lFilePointer[30];

// File IO vars

static OPENFILENAMEA ofn;

static CHAR    szFilterSpec    [60] = "";
static CHAR    szExeFilterSpec [60] = "";
static CHAR    szDllFilterSpec [60] = "";
static CHAR    szResFilterSpec [60] = "";
static CHAR    szExeResFilterSpec [180] = "";
static CHAR    szMtkFilterSpec [60] = "";
static CHAR    szMPJFilterSpec [60] = "";
static CHAR    szRdfFilterSpec [60] = "";

static CHAR    szFileName[MAXFILENAME] = "";// holds full name of latest opened file
static TCHAR   tszAppName[100] = TEXT("");
static CHAR    szAppName[100] = "";
static TCHAR   szClassName[]=TEXT("RLAdminClass");
static TCHAR   szStatusClass[]=TEXT("RLAdminStatus");

static BOOL    fMtkChanges = FALSE;        // set to true when toke file is out of date
static BOOL    fMtkFile    = FALSE;
static BOOL    fMpjChanges = FALSE;
static BOOL    fMPJOutOfDate = FALSE;
static BOOL    fPRJOutOfDate = FALSE;

static CHAR    szOpenDlgTitle[80] = ""; // title of File open dialog
static CHAR    szSaveDlgTitle[80] = ""; // title of File saveas dialog
static CHAR    szNewFileName[MAXFILENAME] = "";
static CHAR    szPrompt[80] = "";
static CHAR   *szFSpec = NULL;
static CHAR   *szExt   = NULL;


static TOKENDELTAINFO FAR *pTokenDeltaInfo;       // linked list of token deta info

// Window vars
static HCURSOR    hHourGlass  = NULL;   // handle to hourglass cursor
static HCURSOR    hSaveCursor = NULL;   // current cursor handle
static HACCEL     hAccTable   = NULL;
static RECT       Rect = {0,0,0,0};     // dimension of the client window
static UINT       cyChildHeight = 0;    // height of status windows


// NOTIMPLEMENTED is a macro that displays a "Not implemented" dialog
#define NOTIMPLEMENTED {\
            LoadString(hInst,IDS_NOT_IMPLEMENTED,szDHW, DHWSIZE);\
            MessageBox(hMainWnd,szDHW,tszAppName,MB_ICONEXCLAMATION | MB_OK);}

// Edit Tok Dialog

static FARPROC lpTokEditDlg   = NULL;
static HWND    hTokEditDlgWnd = 0;



/**
  *
  *
  *  Function: InitApplication
  *   Regsiters the main window, which is a list box composed of tokens
  *   read from the token file. Also register the status window.
  *
  *
  *  Arguments:
  *   hInstance, instance handle of program in memory.
  *
  *  Returns:
  *
  *  Errors Codes:
  *   TRUE, windows registered correctly.
  *   FALSE, error during register of one of the windows.
  *
  *  History:
  *   9/91, Implemented.                TerryRu
  *
  *
  **/

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS  wc;
    CHAR sz[60] = "";
    CHAR sztFilterSpec[180] = "";

    gbMaster=TRUE;

    LoadStrIntoAnsiBuf(hInstance,IDS_RESSPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szResFilterSpec,sz,"*.RES");

    LoadStrIntoAnsiBuf(hInstance,IDS_EXESPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szExeFilterSpec,sz,"*.EXE");

    LoadStrIntoAnsiBuf(hInstance,IDS_DLLSPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szDllFilterSpec,sz,"*.DLL");
    CatSzFilterSpecs(sztFilterSpec,szExeFilterSpec,szDllFilterSpec);
    CatSzFilterSpecs(szExeResFilterSpec,sztFilterSpec,szResFilterSpec);

    LoadStrIntoAnsiBuf(hInstance,IDS_MTKSPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szMtkFilterSpec,sz,"*.MTK");

    LoadStrIntoAnsiBuf(hInstance,IDS_RDFSPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szRdfFilterSpec,sz,"*.RDF");

    LoadStrIntoAnsiBuf(hInstance,IDS_MPJSPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szMPJFilterSpec,sz,"*.MPJ");
    szFilterSpecFromSz1Sz2(szFilterSpec,sz,"*.MPJ");

    LoadStrIntoAnsiBuf(hInstance,
                       IDS_OPENTITLE,
                       szOpenDlgTitle,
                       sizeof(szOpenDlgTitle));
    LoadStrIntoAnsiBuf(hInstance,
                       IDS_SAVETITLE,
                       szSaveDlgTitle,
                       sizeof(szSaveDlgTitle));

    wc.style            = 0;
    wc.lpfnWndProc      = StatusWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInstance;
    wc.hIcon            = LoadIcon((HINSTANCE) NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor((HINSTANCE) NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = szStatusClass;

    if (! RegisterClass( (CONST WNDCLASS *)&wc))
    {
        return (FALSE);
    }

    wc.style            = 0;
    wc.lpfnWndProc      = MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInstance;
    wc.hIcon            = LoadIcon(hInstance,TEXT("RLAdminIcon"));
    wc.hCursor          = LoadCursor((HINSTANCE) NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName     = TEXT("RLAdmin");
    wc.lpszClassName    = szClassName;

    return( RegisterClass( (CONST WNDCLASS *)&wc) ? TRUE : FALSE);
}



/**
  *
  *
  *  Function: InitInstance
  *   Creates the main, and status windows for the program.
  *   The status window is sized according to the main window
  *   size.  InitInstance also loads the acclerator table, and prepares
  *   the global openfilename structure for later use.
  *
  *
  *  Errors Codes:
  *   TRUE, windows created correctly.
  *   FALSE, error on create windows calls.
  *
  *  History:
  *   9/11, Implemented         TerryRu
  *
  *
  **/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    RECT    Rect;

    hAccTable = LoadAccelerators(hInst, TEXT("RLAdmin"));

    hMainWnd = CreateWindow( szClassName,
                             tszAppName,
                             WS_OVERLAPPEDWINDOW,
                             CW_USEDEFAULT,
                             CW_USEDEFAULT,
                             CW_USEDEFAULT,
                             CW_USEDEFAULT,
                             (HWND) NULL,
                             (HMENU) NULL,
                             (HINSTANCE)hInstance,
                             (LPVOID) NULL);

    if ( ! hMainWnd )
    {
        return( FALSE);
    }

    DragAcceptFiles(hMainWnd, TRUE);

    GetClientRect(hMainWnd, (LPRECT) &Rect);

    // Create a child list box window

    hListWnd = CreateWindow( TEXT("LISTBOX"),
                             NULL,
                             WS_CHILD |
                             LBS_WANTKEYBOARDINPUT |
                             LBS_NOTIFY | LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED |
                             WS_VSCROLL | WS_HSCROLL | WS_BORDER ,
                             0,
                             0,
                             (Rect.right-Rect.left),
                             (Rect.bottom-Rect.top),
                             hMainWnd,
                             (HMENU)IDC_LIST, // Child control i.d.
                             hInstance,
                             NULL);

    if ( ! hListWnd )
    {
        DeleteObject((HGDIOBJ)hMainWnd);
        return( FALSE);
    }

    // Creat a child status window

    hStatusWnd = CreateWindow( szStatusClass,
                               NULL,
                               WS_CHILD | WS_BORDER | WS_VISIBLE,
                               0, 0, 0, 0,
                               hMainWnd,
                               NULL,
                               hInst,
                               NULL);

    if ( ! hStatusWnd )
    {                           // clean up after errors.
        DeleteObject((HGDIOBJ)hListWnd);
        DeleteObject((HGDIOBJ)hMainWnd);
        return( FALSE);
    }

    hHourGlass = LoadCursor( (HINSTANCE) NULL, IDC_WAIT);

    // Fill in non-variant fields of OPENFILENAMEA struct.
    ofn.lStructSize         = sizeof( OPENFILENAMEA);
    ofn.hwndOwner           = hMainWnd;
    ofn.lpstrFilter         = szFilterSpec;
    ofn.lpstrCustomFilter   = szCustFilterSpec;
    ofn.nMaxCustFilter      = MAXCUSTFILTER;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = szFileName;
    ofn.nMaxFile            = MAXFILENAME;
    ofn.lpstrInitialDir     = NULL;
    ofn.lpstrFileTitle      = szFileTitle;
    ofn.nMaxFileTitle       = MAXFILENAME;
    ofn.lpstrTitle          = NULL;
    ofn.lpstrDefExt         = "MPJ";
    ofn.Flags               = 0;

    GetLangList();

    ShowWindow(hMainWnd, nCmdShow);
    UpdateWindow(hMainWnd);

    return TRUE;
}

/**
  *
  *
  *  Function: WinMain
  *   Calls the intialization functions, to register, and create the
  *   application windows. Once the windows are created, the program
  *   enters the GetMessage loop.
  *
  *
  *  Arguements:
  *   hInstace, handle for this instance
  *   hPrevInstanc, handle for possible previous instances
  *   lpszCmdLine, long pointer to exec command line.
  *   nCmdShow,  code for main window display.
  *
  *
  *  Errors Codes:
  *   IDS_ERR_REGISTER_CLASS, error on windows register
  *   IDS_ERR_CREATE_WINDOW, error on create windows
  *   otherwise, status of last command.
  *
  *  History:
  *
  *
  **/


INT WINAPI WinMain(

HINSTANCE hInstance,
HINSTANCE hPrevInstance,
LPSTR     lpszCmdLine,
int       nCmdShow)
{
    MSG   msg;
    HWND  FirstWnd      = NULL;
    HWND  FirstChildWnd = NULL;
    static TCHAR szString[256] = TEXT("");


    hInst  = hInstance;
    bRLGui = TRUE;

    if ( FirstWnd = FindWindow( szClassName,NULL) )
    {
        // checking for previous instance
        FirstChildWnd = GetLastActivePopup( FirstWnd);
        BringWindowToTop( FirstWnd);
        ShowWindow( FirstWnd, SW_SHOWNORMAL);

        if ( FirstWnd != FirstChildWnd )
        {
            BringWindowToTop( FirstChildWnd);
        }
        return( FALSE);
    }

    GetModuleFileNameA( hInst, szDHW, DHWSIZE);
    GetInternalName( szDHW, szAppName, ACHARSIN( sizeof( szAppName)));
    szFileName[0] = '\0';
    lFilePointer[0] = (LONG)-1;

#ifdef UNICODE
    _MBSTOWCS( tszAppName,
               szAppName,
               WCHARSIN( sizeof( tszAppName)),
               ACHARSIN( strlen( szAppName) + 1));
#else
    strcpy( tszAppName, szAppName);
#endif

    // register window classes if first instance of application
    if ( ! hPrevInstance )
    {
        if ( ! InitApplication( hInstance) )
        {
            /* Registering one of the windows failed      */
            LoadString( hInst,
                        IDS_ERR_REGISTER_CLASS,
                        szString,
                        TCHARSIN( sizeof( szString)));
            MessageBox( NULL, szString, NULL, MB_ICONEXCLAMATION);
            return( IDS_ERR_REGISTER_CLASS);
        }
    }

    // Create windows for this instance of application
    if ( ! InitInstance( hInstance, nCmdShow) )
    {
        LoadString( hInst,
                    IDS_ERR_CREATE_WINDOW,
                    szString,
                    TCHARSIN( sizeof( szString)));
        MessageBox( NULL, szString, NULL, MB_ICONEXCLAMATION);
        return( IDS_ERR_CREATE_WINDOW);
    }

    // Main Message Loop

    while ( GetMessage( &msg, (HWND)NULL, 0, 0) )
    {
        if ( hTokEditDlgWnd )
        {
            if ( IsDialogMessage( hTokEditDlgWnd, &msg) )
            {
                continue;
            }
        }

        if ( TranslateAccelerator( hMainWnd, hAccTable, &msg) )
        {
            continue;
        }

        TranslateMessage( (CONST MSG *)&msg);
        DispatchMessage( (CONST MSG *)&msg);
    }
    return( (INT)msg.wParam);
}

/**
  *
  *
  *  Function: MainWndProc
  *   Process the windows messages for the main window of the application.
  *   All user inputs go through this window procedure.
  *   See cases in the switch table for a description of each message type.
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

INT_PTR APIENTRY MainWndProc(

HWND   hWnd,
UINT   wMsg,
WPARAM wParam,
LPARAM lParam)
{
    DoListBoxCommand (hWnd, wMsg, wParam, lParam);

    switch (wMsg)
    {
    case WM_DROPFILES:
        {
#ifndef CAIRO
            DragQueryFileA((HDROP)wParam, 0, szDHW, MAXFILENAME);
#else
            DragQueryFile((HDROP)wParam, 0, szDHW, MAXFILENAME);
#endif
            MessageBoxA( hWnd, szDHW, szAppName, MB_OK);

            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
            {
                if ( GetMasterProjectData( gProj.szMpj,
                                           NULL,
                                           NULL,
                                           FALSE) == SUCCESS )
                {
                    sprintf( szDHW, "%s - %s", szAppName, gProj.szMpj);
                    SetWindowTextA( hMainWnd, szDHW);
                    SendMessage( hMainWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
                }
            }
            DragFinish((HDROP)wParam);
            return( TRUE);
        }

    case WM_COMMAND:

        if ( DoMenuCommand( hWnd, wMsg, wParam, lParam) )
        {
            return( TRUE);
        }
        break;

    case WM_CLOSE:

        SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0);
        DestroyWindow( hMainWnd);
        DestroyWindow( hListWnd);
        DestroyWindow( hStatusWnd);
        _fcloseall();
        FreeLangList();

#ifdef _DEBUG
        {
            FILE *pLeakList = fopen( "C:\\LEAKLIST.TXT", "wt");
            FreeMemList( pLeakList);
            fclose( pLeakList);
        }
#endif // _DEBUG

        break;

    case WM_CREATE:
        {
            HDC hdc;
            int cyBorder;
            TEXTMETRIC tm;

            hdc  = GetDC (hWnd);
            GetTextMetrics(hdc, &tm);
            ReleaseDC(hWnd, hdc);

            cyBorder = GetSystemMetrics(SM_CYBORDER);

            cyChildHeight = tm.tmHeight + 6 + cyBorder * 2;
            break;
        }


    case WM_DESTROY:

        WinHelpA( hWnd, gszHelpFile, HELP_QUIT, 0L);
        DragAcceptFiles( hMainWnd, FALSE);
        PostQuitMessage( 0);
        break;

    case WM_INITMENU:
        // Enable or Disable the Paste menu item
        // based on available Clipboard Text data
        if ( wParam == (WPARAM)GetMenu( hMainWnd) )
        {
            if ( OpenClipboard( hWnd))
            {
#if defined(UNICODE)
                if ((IsClipboardFormatAvailable(CF_UNICODETEXT) ||
                     IsClipboardFormatAvailable(CF_OEMTEXT)) &&
                    fMtkFile)
#else // not UNICODE
                if ((IsClipboardFormatAvailable(CF_TEXT) ||
                     IsClipboardFormatAvailable(CF_OEMTEXT)) &&
                    fMtkFile)
#endif // UNICODE
                {
                    EnableMenuItem((HMENU) wParam, IDM_E_PASTE, MF_ENABLED);
                }
                else
                {
                    EnableMenuItem((HMENU) wParam, IDM_E_PASTE, MF_GRAYED);
                }

                CloseClipboard();
                return (TRUE);
            }
        }
        break;

    case WM_QUERYENDSESSION:
        /* message: to end the session? */
        if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }

    case WM_SETFOCUS:
        SetFocus (hListWnd);
        break;

    case WM_DRAWITEM:
        DrawLBItem((LPDRAWITEMSTRUCT) lParam);
        break;

    case WM_DELETEITEM:
        GlobalFree((HGLOBAL) ((LPDELETEITEMSTRUCT) lParam)->itemData);
        break;

    case WM_SIZE:
        {
            int cxWidth;
            int cyHeight;
            int xChild;
            int yChild;

            cxWidth  = LOWORD(lParam);
            cyHeight = HIWORD(lParam);

            xChild = 0;
            yChild = cyHeight - cyChildHeight + 1;

            MoveWindow(hListWnd, 0, 0, cxWidth, yChild , TRUE);
            MoveWindow(hStatusWnd, xChild, yChild, cxWidth, cyChildHeight, TRUE);
            break;
        }

    case WM_LOADTOKENS:
        {
            HMENU hMenu = NULL;
            FILE *f = NULL;
            OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

            // Remove the current token list
            SendMessage( hListWnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
            CleanDeltaList();

            // Hide token list, while we add new tokens
            ShowWindow(hListWnd, SW_HIDE);

            if ( OpenFile( gMstr.szMtk, &Of, OF_EXIST) == HFILE_ERROR )
            {
                // file doesn't exist, create it
                BOOL bUpdate;
                HCURSOR hOldCursor;

                hOldCursor = SetCursor(hHourGlass);
                LoadCustResDescriptions(gMstr.szRdfs);

                GenerateTokFile(gMstr.szMtk,
                                gMstr.szSrc,
                                &bUpdate, 0);
                SetCursor(hOldCursor);
                ClearResourceDescriptions();
                SzDateFromFileName( gMstr.szSrcDate,           gMstr.szSrc);
                SzDateFromFileName( gMstr.szMpjLastRealUpdate, gMstr.szMtk);
                fMpjChanges   = TRUE;
                fMPJOutOfDate = FALSE;
            }

            SzDateFromFileName( szDHW, gMstr.szSrc);

            if ( lstrcmpA( szDHW, gMstr.szSrcDate) )
            {
                HCURSOR hOldCursor;
                BOOL bUpdate;

                // MPJ is not up to date
                fMPJOutOfDate = TRUE;
                hOldCursor = SetCursor( hHourGlass);
                LoadCustResDescriptions( gMstr.szRdfs);
                GenerateTokFile( gMstr.szMtk,
                                 gMstr.szSrc,
                                 &bUpdate, 0);
                if ( bUpdate )
                {
                    SzDateFromFileName( gMstr.szMpjLastRealUpdate,
                                        gMstr.szMtk);
                }

                ClearResourceDescriptions();
                SzDateFromFileName(gMstr.szSrcDate,
                                   gMstr.szSrc);
                fMpjChanges   = TRUE;
                fMPJOutOfDate = FALSE;
                SetCursor(hOldCursor);
            }
            else
            {
                fMPJOutOfDate = FALSE;
            }

            if ( f = fopen(gMstr.szMtk,"rt") )
            {
                HCURSOR hOldCursor;

                hOldCursor = SetCursor(hHourGlass);

                // Insert tokens from token file into the list box
                pTokenDeltaInfo = InsertMtkList(f);
                FCLOSE(f);

                // Make list box visible
                ShowWindow(hListWnd, SW_SHOW);

                hMenu=GetMenu(hWnd);
                EnableMenuItem(hMenu, IDM_P_CLOSE,     MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_P_VIEW,      MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FIND,      MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FINDUP,    MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FINDDOWN,  MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_REVIEW,    MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_COPY,      MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_COPYTOKEN, MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_PASTE,     MF_ENABLED|MF_BYCOMMAND);
                fMtkFile = TRUE;
                fMtkChanges = FALSE;

                SetCursor(hOldCursor);
            }
            break;
        }

    case WM_SAVEPROJECT:
        {
            fMtkFile = FALSE;

            if ( fMtkChanges )
            {
                FILE *f = NULL;

                if ( (f = fopen( gMstr.szMtk, "wt")) )
                {
                    SaveMtkList( hWnd,f);
                    FCLOSE(f);
                    SzDateFromFileName( gMstr.szMpjLastRealUpdate,
                                        gMstr.szMtk);
                    fMtkChanges = FALSE;
                    fMpjChanges = TRUE;
                }
                else
                {
                    LoadStrIntoAnsiBuf(hInst, IDS_FILESAVEERR, szDHW, DHWSIZE);
                    MessageBoxA( hWnd,
                                 szDHW,
                                 gMstr.szMtk,
                                 MB_ICONHAND | MB_OK);
                    return FALSE;
                }
            }

            if ( fMpjChanges )
            {
                if ( PutMasterProjectData( gProj.szMpj) != SUCCESS )
                {
                    LoadStrIntoAnsiBuf(hInst, IDS_FILESAVEERR, szDHW, DHWSIZE);
                    MessageBoxA(hWnd, szDHW,gProj.szMpj, MB_ICONHAND | MB_OK);
                    return FALSE;
                }
                fMpjChanges = FALSE;
            }
            return TRUE; // everything saved ok
        }
    default:
        break;
    }
    return (DefWindowProc(hWnd, wMsg, wParam, lParam));
}

/**
  *
  *
  *  Function: DoListBoxCommand
  *   Processes the messages sent to the list box. If the message is
  *   not reconized as a list box message, it is ignored and not processed.
  *   As the user scrolls through the tokens WM_UPDSTATLINE messages are
  *   sent to the status window to indicate the current selected token.
  *   The list box goes into Edit Mode by  pressing the enter key, or
  *   by double clicking on the list box.  After the edit is done, a WM_TOKEDIT
  *   message is sent back to the list box to update the token. The
  *   list box uses control ID IDC_LIST.
  *
  *
  *
  *  Arguments:
  *   wMsg    List Box message ID
  *   wParam  Either IDC_LIST, or VK_RETURN depending on wMsg
  *   lParam  LPTSTR to selected token during WM_TOKEDIT message.
  *
  *  Returns:
  *
  *
  *  Errors Codes:
  *   TRUE.  Message processed.
  *   FALSE. Message not processed.
  *
  *  History:
  *   01/92 Implemented.            TerryRu.
  *   01/92 Fixed problem with DblClick, and Enter processing.  TerryRu.
  *
  *
  **/

INT_PTR DoListBoxCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    TOKEN  tok;                     // struct for token read from token list
    TCHAR  szName[32] = TEXT("");   // buffer to hold token name

    CHAR   szTmpBuf[64] = "";
    TCHAR  szID[14]     = TEXT(""); // buffer to hold token id
    TCHAR  sz[512]      = TEXT(""); // buffer to hold messages
    static UINT wIndex= 0;
    LONG   lListParam = 0L;
    HWND   hCtl       = NULL;
    LPTSTR lpstrToken = NULL;
    HGLOBAL hMem = NULL;

    // this is the WM_COMMAND

    switch (wMsg)
    {
    case WM_TOKEDIT:
        {
            WORD wReservedOld;
            TCHAR *szBuffer;

            // Message sent by TokEditDlgProc to
            // indicate change in the token text.
            // Response to the message by inserting
            // new token text into list box

            // Insert the selected token into token struct

            hMem = (HGLOBAL)SendMessage( hListWnd,
                                         LB_GETITEMDATA,
                                         (WPARAM)wIndex,
                                         (LPARAM)0);
            lpstrToken = (LPTSTR)GlobalLock( hMem);
            szBuffer = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
            lstrcpy( szBuffer, lpstrToken);
            GlobalUnlock( hMem);
            ParseBufToTok(szBuffer, &tok);
            RLFREE( szBuffer);

            wReservedOld = tok.wReserved;

            switch (LOWORD(wParam))
            {
            case 0:
                tok.wReserved = 0;
                break;

            case 1:
                tok.wReserved = ST_CHANGED|ST_NEW;
                break;

            case 2:
                tok.wReserved = ST_NEW;
                break;

            case 3:
                tok.wReserved = ST_READONLY;
                break;
            }

            if (wReservedOld != tok.wReserved)
            {
                fMtkChanges = TRUE;
            }
            szBuffer = (TCHAR *)FALLOC( MEMSIZE( TokenToTextSize( &tok)));
            ParseTokToBuf( szBuffer, &tok);
            RLFREE( tok.szText);

            SendMessage( hListWnd, WM_SETREDRAW, (WPARAM)FALSE, (LPARAM)0);

            // Now remove old token
            SendMessage( hListWnd, LB_DELETESTRING, (WPARAM)wIndex, (LPARAM)0);

            // Replacing with the new token
            hMem = GlobalAlloc( GMEM_ZEROINIT, MEMSIZE( lstrlen( szBuffer) + 1));
            lpstrToken = (LPTSTR)GlobalLock( hMem);
            lstrcpy( lpstrToken, szBuffer);
            GlobalUnlock( hMem);
            SendMessage( hListWnd,
                         LB_INSERTSTRING,
                         (WPARAM)wIndex,
                         (LPARAM)hMem);
            RLFREE( szBuffer);

            // Now put focus back on the current string
            SendMessage( hListWnd, LB_SETCURSEL, (WPARAM)wIndex, (LPARAM)0);
            SendMessage( hListWnd, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0);
            InvalidateRect( hListWnd, NULL, TRUE);

            return TRUE;
        }
    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        {
#ifdef RLWIN16
            LONG lListParam = 0;
#endif
            UINT wListParam = 0;

            // Messages sent to list box when  keys are depressed.
            // Check for Return key pressed.
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
            case VK_RETURN:
#ifdef RLWIN16
                lListParam = (LONG) MAKELONG(NULL,  LBN_DBLCLK);
                SendMessage( hMainWnd,
                             WM_COMMAND,
                             (WPARAM)IDC_LIST,
                             (LPARAM)lListParam);
#else
                SendMessage( hMainWnd,
                             WM_COMMAND,
                             MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                             (LPARAM)0);
#endif

            default:
                break;
            }
            break;
        }
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_LIST:
            /*
             *
             * This is where we process the list box messages.
             * The TokEditDlgProc is used to
             * edit the token selected in LBS_DBLCLK message
             *
             */
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case (UINT) LBN_ERRSPACE:
                LoadString( hInst,
                            IDS_ERR_NO_MEMORY,
                            sz,
                            TCHARSIN( sizeof( sz)));
                MessageBox ( hWnd,
                             sz,
                             tszAppName,
                             MB_ICONHAND | MB_OK);
                return TRUE;

            case LBN_DBLCLK:
                {
                    TCHAR szResIDStr[20] = TEXT("");
                    LPTSTR lpstrToken;
                    TCHAR *szBuffer;

                    wIndex = (UINT)SendMessage( hListWnd,
                                                LB_GETCURSEL,
                                                (WPARAM)0,
                                                (LPARAM)0);
                    if (wIndex == (UINT) -1)
                    {
                        return TRUE;
                    }

                    // double click, or Return entered, go into token edit mode.

                    if (!hTokEditDlgWnd)
                    {
                        // set up modaless dialog box to edit token
#ifdef RLWIN32
                        hTokEditDlgWnd = CreateDialog(hInst,
                                                      TEXT("RLAdmin"),
                                                      hWnd,
                                                      TokEditDlgProc);
#else
                        lpTokEditDlg = (FARPROC) MakeProcInstance(TokEditDlgProc,
                                                                  hInst);
                        hTokEditDlgWnd = CreateDialog(hInst,
                                                      TEXT("RLAdmin"),
                                                      hWnd,
                                                      lpTokEditDlg);
#endif
                    }

                    // Get token info from listbox, and place in token struct
                    hMem = (HGLOBAL)SendMessage( hListWnd,
                                                 LB_GETITEMDATA,
                                                 (WPARAM)wIndex,
                                                 (LPARAM)0);
                    lpstrToken = (LPTSTR)GlobalLock( hMem);
                    szBuffer = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
                    lstrcpy( szBuffer, lpstrToken);
                    GlobalUnlock( hMem);
                    ParseBufToTok(szBuffer, &tok);
                    RLFREE( szBuffer);

                    // Now get the token name
                    // Its either a string, or ordinal number

                    if (tok.szName[0])
                    {
                        lstrcpy(szName, tok.szName);
                    }
                    else
                    {
#ifdef UNICODE
                        _itoa( tok.wName, szTmpBuf, 10);
                        _MBSTOWCS( szName,
                                   szTmpBuf,
                                   WCHARSIN( sizeof( szName)),
                                   ACHARSIN( strlen( szTmpBuf) + 1));
#else

                        _itoa(tok.wName, szName, 10);
#endif
                    }
                    // Now get the token id
#ifdef UNICODE
                    _itoa( tok.wID, szTmpBuf, 10);
                    _MBSTOWCS( szID,
                               szTmpBuf,
                               WCHARSIN( sizeof( szID)),
                               ACHARSIN( strlen( szTmpBuf) + 1));
#else
                    _itoa( tok.wID, szID, 10);
#endif
                    if ( tok.wType <= 16 || tok.wType == ID_RT_DLGINIT )
                    {
                        LoadString( hInst,
                                    IDS_RESOURCENAMES+tok.wType,
                                    szResIDStr,
                                    TCHARSIN( sizeof( szResIDStr)));
                    }
                    else
                    {
#ifdef UNICODE
                        _itoa( tok.wType, szTmpBuf, 10);
                        _MBSTOWCS( szResIDStr,
                                   szTmpBuf,
                                   WCHARSIN( sizeof( szResIDStr)),
                                   ACHARSIN( strlen( szTmpBuf) + 1));
#else
                        _itoa( tok.wType, szResIDStr, 10);
#endif
                    }

                    // Now insert token info  in TokEdit Dialog Box
                    SetDlgItemText(hTokEditDlgWnd,
                                   IDD_TOKTYPE,
                                   (LPTSTR) szResIDStr);
                    SetDlgItemText(hTokEditDlgWnd,
                                   IDD_TOKNAME,
                                   (LPTSTR) szName);
                    SetDlgItemText(hTokEditDlgWnd,
                                   IDD_TOKID,
                                   (LPTSTR) szID);
                    SetDlgItemText(hTokEditDlgWnd,
                                   IDD_TOKCURTEXT,
                                   (LPTSTR) tok.szText);
                    SetDlgItemText(hTokEditDlgWnd,
                                   IDD_TOKPREVTEXT,
                                   (LPTSTR) FindDeltaToken(tok,
                                                           pTokenDeltaInfo,
                                                           ST_CHANGED));

                    hCtl = GetDlgItem(hTokEditDlgWnd,IDD_STATUS);
                    {
                        int i;

                        if (tok.wReserved & ST_READONLY)
                        {
                            i = 3;
                        }
                        else if (tok.wReserved == ST_NEW)
                        {
                            i = 2;
                        }
                        else if (tok.wReserved & ST_CHANGED)
                        {
                            i = 1;
                        }
                        else
                        {
                            i = 0;
                        }
                        SendMessage( hCtl, CB_SETCURSEL, (WPARAM)i, (LPARAM)0);
                    }

                    SetActiveWindow(hTokEditDlgWnd);
                    wIndex = (UINT)SendMessage( hListWnd,
                                                LB_GETCURSEL,
                                                (WPARAM)0,
                                                (LPARAM)0);
                    RLFREE( tok.szText);

                    return TRUE;
                }

                // let these messages fall through,
            default:
                break;
            }
        default:
            return FALSE;
        }

        break; // WM_COMMAND Case

    } // Main List Box Switch

    return FALSE;
}

/**
  *
  *
  *  Function: DoMenuCommand.
  *   Processes the Menu Command messages.
  *
  *  Errors Codes:
  *   TRUE. Message processed.
  *   FALSE. Message not processed.
  *
  *  History:
  *   01/92. Implemented.       TerryRu.
  *
  *
  **/

INT_PTR DoMenuCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fListBox = FALSE;
    CHAR        sz[256]="";
    TCHAR       tsz[256] = TEXT("");
#ifndef RLWIN32
    FARPROC     lpNewDlg,lpViewDlg;
#endif

    // Commands entered from the application menu, or child windows.
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {

    case IDM_P_NEW:

        if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
        {
            CHAR szOldFile[MAXFILENAME] = "";


            strcpy( szOldFile, szFileName);

            if ( ! GetFileNameFromBrowse( hWnd,
                                          szFileName,
                                          MAXFILENAME,
                                          szSaveDlgTitle,
                                          szFilterSpec,
                                          "MPJ"))
            {
                break;
            }
            strcpy( gProj.szMpj, szFileName);

#ifdef RLWIN32
            if (DialogBox(hInst, TEXT("PROJECT"), hWnd, NewDlgProc))
#else
            lpNewDlg = MakeProcInstance( NewDlgProc, hInst);

            if (DialogBox(hInst, TEXT("PROJECT"), hWnd, lpNewDlg))
#endif
            {
                sprintf( szDHW, "%s - %s", szAppName, gProj.szMpj);
                SetWindowTextA( hWnd,szDHW);
                gMstr.szSrcDate[0] = 0;
                gMstr.szMpjLastRealUpdate[0] = 0;
                SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
            }
            else
            {
                strcpy( gProj.szMpj, szOldFile);
            }
#ifndef RLWIN32
            FreeProcInstance(lpTokEditDlg);
#endif
        }
        break;

    case IDM_P_OPEN:

        if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
        {
            if ( GetFileNameFromBrowse( hWnd,
                                        gProj.szMpj,
                                        MAXFILENAME,
                                        szOpenDlgTitle,
                                        szFilterSpec,
                                        "MPJ"))
            {
                if ( GetMasterProjectData( gProj.szMpj, NULL, NULL, FALSE) == SUCCESS )
                {

                    sprintf( szDHW, "%s - %s", szAppName, gProj.szMpj);
                    SetWindowTextA( hMainWnd, szDHW);
                    SendMessage( hMainWnd,
                                 WM_LOADTOKENS,
                                 (WPARAM)0,
                                 (LPARAM)0);
                }
            }
        }
        break;

    case IDM_P_VIEW:

#ifdef RLWIN32
        DialogBox(hInst, TEXT("VIEWPROJECT"), hWnd, ViewDlgProc);
#else
        lpViewDlg = MakeProcInstance(ViewDlgProc, hInst);
        DialogBox(hInst, TEXT("VIEWPROJECT"), hWnd, lpViewDlg);
#endif
        break;

    case IDM_P_CLOSE:
        {
            HMENU hMenu;

            hMenu = GetMenu(hWnd);
            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
            {
                // Remove file name from window title
                SetWindowTextA(hMainWnd, szAppName);

                // Hide token list since it's empty
                ShowWindow(hListWnd, SW_HIDE);

                // Remove the current token list
                SendMessage( hListWnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
                CleanDeltaList();

                // Force Repaint of status Window
                InvalidateRect(hStatusWnd, NULL, TRUE);

                EnableMenuItem(hMenu,IDM_P_CLOSE,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_P_VIEW,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_FIND,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_FINDUP,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_FINDDOWN,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_REVIEW,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_COPY,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_COPYTOKEN,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_PASTE,MF_GRAYED|MF_BYCOMMAND);
            }
            break;
        }

    case IDM_P_EXIT:
        // send wm_close message to main window
        PostMessage(hMainWnd, WM_CLOSE, (WPARAM)0, (LPARAM)0);
        break;

    case IDM_E_COPYTOKEN:
        {
            HGLOBAL hStringMem = NULL;
            LPTSTR  lpString   = NULL;
            int     nIndex  = 0;
            int     nLength = 0;
            LPTSTR  lpstrToken = NULL;

            // Is anything selected in the listbox
            if ( (nIndex = (int)SendMessage( hListWnd,
                                             LB_GETCURSEL,
                                             (WPARAM)0,
                                             (LPARAM)0)) != LB_ERR )
            {
                HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                     LB_GETITEMDATA,
                                                     (WPARAM)nIndex,
                                                     (LPARAM)0);
                lpstrToken = (LPTSTR)GlobalLock( hMem);
                nLength = lstrlen( lpstrToken);

                // Allocate memory for the string
                if ( (hStringMem =
                      GlobalAlloc(GHND, (DWORD) MEMSIZE(nLength+1))) != NULL )
                {
                    if ( (lpString = (LPTSTR)GlobalLock( hStringMem)) != NULL )
                    {
                        // Get the selected text
                        lstrcpy( lpString, lpstrToken);
                        GlobalUnlock( hMem);
                        // Unlock the block
                        GlobalUnlock( hStringMem);

                        // Open the Clipboard and clear its contents
                        OpenClipboard( hWnd);
                        EmptyClipboard();

                        // Give the Clipboard the text data

#if defined(UNICODE)
                        SetClipboardData(CF_UNICODETEXT, hStringMem);
#else // not UNICODE
                        SetClipboardData( CF_TEXT, hStringMem);
#endif // UNICODE

                        CloseClipboard();

                        hStringMem = NULL;
                    }
                    else
                    {
                        LoadString( hInst,
                                    IDS_ERR_NO_MEMORY,
                                    tsz,
                                    TCHARSIN( sizeof( tsz)));
                        MessageBox( hWnd,
                                    tsz,
                                    tszAppName,
                                    MB_ICONHAND | MB_OK);
                    }
                }
                else
                {
                    LoadString( hInst,
                                IDS_ERR_NO_MEMORY,
                                tsz,
                                TCHARSIN( sizeof(tsz)));
                    MessageBox( hWnd,
                                tsz,
                                tszAppName,
                                MB_ICONHAND | MB_OK);
                }
            }
            break;
        }

    case IDM_E_COPY:
        {
            HGLOBAL hStringMem  = NULL;
            HGLOBAL hMem = NULL;
            LPTSTR  lpString = NULL;
            TCHAR  *pszString = NULL;
            int     nIndex  = 0;
            int     nLength = 0;
            int     nActual = 0;
            TOKEN   tok;
            LPTSTR  lpstrToken   = NULL;

            // Is anything selected in the listbox
            if ( (nIndex = (int)SendMessage( hListWnd,
                                             LB_GETCURSEL,
                                             (WPARAM)0,
                                             (LPARAM)0)) != LB_ERR )
            {
                hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             (WPARAM)nIndex,
                                             (LPARAM)0);
                lpstrToken = (LPTSTR)
                pszString = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1 ));
                lstrcpy( pszString, lpstrToken);
                GlobalUnlock( hMem);
                ParseBufToTok( pszString, &tok);
                RLFREE( pszString);

                nLength = lstrlen(tok.szText);

                // Allocate memory for the string
                if ((hStringMem =
                     GlobalAlloc(GHND, (DWORD)MEMSIZE( nLength + 1))) != NULL)
                {
                    if ( (lpString = (LPTSTR)GlobalLock( hStringMem)) != NULL)
                    {
                        // Get the selected text
                        lstrcpy( lpString, tok.szText);

                        // Unlock the block
                        GlobalUnlock( hStringMem);

                        // Open the Clipboard and clear its contents
                        OpenClipboard(hWnd);
                        EmptyClipboard();

                        // Give the Clipboard the text data

#if defined(UNICODE)
                        SetClipboardData(CF_UNICODETEXT, hStringMem);
#else // not UNICODE
                        SetClipboardData(CF_TEXT, hStringMem);
#endif // UNICODE

                        CloseClipboard();

                        hStringMem = NULL;
                    }
                    else
                    {
                        LoadString( hInst,
                                    IDS_ERR_NO_MEMORY,
                                    tsz,
                                    TCHARSIN( sizeof(tsz)));
                        MessageBox( hWnd,
                                    tsz,
                                    tszAppName,
                                    MB_ICONHAND | MB_OK);
                    }
                }
                else
                {
                    LoadString( hInst,
                                IDS_ERR_NO_MEMORY,
                                tsz,
                                TCHARSIN( sizeof( tsz)));
                    MessageBox( hWnd,
                                tsz,
                                tszAppName,
                                MB_ICONHAND | MB_OK);
                }
                RLFREE( tok.szText);
            }
            break;
        }

    case IDM_E_PASTE:
        {
            HGLOBAL hClipMem  = NULL;
            HGLOBAL hMem = NULL;
            LPTSTR  lpClipMem = NULL;
            TCHAR   *pszPasteString = NULL;
            int     nIndex    = 0;
            TOKEN   tok;
            LPTSTR  lpstrToken = NULL;

            if (OpenClipboard(hWnd))
            {

#if defined(UNICODE)
                if(IsClipboardFormatAvailable(CF_UNICODETEXT) ||
                    IsClipboardFormatAvailable(CF_OEMTEXT))
#else // not UNICODE
                if(IsClipboardFormatAvailable(CF_TEXT) ||
                    IsClipboardFormatAvailable(CF_OEMTEXT))
#endif // UNICODE

                {
                    // Check for current position and change that token's text
                    nIndex = (int) SendMessage( hListWnd,
                                                LB_GETCURSEL,
                                                (WPARAM)0,
                                                (LPARAM)0);

                    if (nIndex == LB_ERR)
                    {
#if defined(UNICODE)	// if no select, just ignore it.
                        break;
#else // not UNICODE
			nIndex = -1;
#endif // UNICODE
                    }

#if defined(UNICODE)	//enabled Paste command
                    hClipMem = GetClipboardData(CF_UNICODETEXT);
#else // not UNICODE
                    hClipMem = GetClipboardData(CF_TEXT);
#endif // UNICODE

                    lpClipMem = (LPTSTR)GlobalLock( hClipMem);
                    hMem = (HGLOBAL)SendMessage( hListWnd,
                                                 LB_GETITEMDATA,
                                                 (WPARAM)nIndex,
                                                 (LPARAM)0);
                    lpstrToken = (LPTSTR)GlobalLock( hMem);
                    pszPasteString = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
                    lstrcpy( pszPasteString, lpstrToken);
                    GlobalUnlock( hMem);
                        // copy the string to the token
                    ParseBufToTok( pszPasteString, &tok);
                    RLFREE( pszPasteString);
                    RLFREE( tok.szText);

                    tok.szText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpClipMem) + 1));
                    lstrcpy( tok.szText, lpClipMem);

                    GlobalUnlock(hClipMem);
                    pszPasteString = (LPTSTR)FALLOC( MEMSIZE( TokenToTextSize( &tok) + 1));
                    ParseTokToBuf( pszPasteString, &tok);
                    RLFREE( tok.szText);

                        // Paste the text
                    SendMessage( hListWnd,
                                 WM_SETREDRAW,
                                 (WPARAM)FALSE,
                                 (LPARAM)0);

                    SendMessage( hListWnd,
                                 LB_DELETESTRING,
                                 (WPARAM)nIndex,
                                 (LPARAM)0);

                    hMem = GlobalAlloc( GMEM_ZEROINIT, MEMSIZE( lstrlen( pszPasteString)+1));
                    lpstrToken = (LPTSTR)GlobalLock( hMem);
                    lstrcpy( lpstrToken, pszPasteString);
                    GlobalUnlock( hMem);
                    SendMessage( hListWnd,
                                 LB_INSERTSTRING,
                                 (WPARAM)nIndex,
                                 (LPARAM)hMem);
                    SendMessage( hListWnd,
                                 LB_SETCURSEL,
                                 (WPARAM)nIndex,
                                 (LPARAM)0);
                    SendMessage( hListWnd,
                                 WM_SETREDRAW,
                                 (WPARAM)TRUE,
                                 (LPARAM)0);
                    InvalidateRect(hListWnd,NULL,TRUE);
                    fMtkChanges = TRUE; // Set Dirty Flag
                    RLFREE( pszPasteString);

                    // Close the Clipboard
                    CloseClipboard();

                    SetFocus(hListWnd);
                }
            }
            CloseClipboard();
            break;
        }

    case IDM_E_FINDDOWN:

        if (fSearchStarted)
        {
            if ( ! DoTokenSearch( szSearchType,
                                  szSearchText,
                                  wSearchStatus,
                                  wSearchStatusMask,
                                  0,
                                  TRUE) )
            {
                TCHAR sz1[80], sz2[80];

                LoadString( hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWnd, sz2, sz1, MB_ICONINFORMATION | MB_OK);
            }
            break;
        }               //... ELSE fall thru

    case IDM_E_FINDUP:

        if (fSearchStarted)
        {
            if ( ! DoTokenSearch( szSearchType,
                                  szSearchText,
                                  wSearchStatus,
                                  wSearchStatusMask,
                                  1,
                                  TRUE) )
            {
                TCHAR sz1[80], sz2[80];
                LoadString( hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWnd, sz2, sz1, MB_ICONINFORMATION | MB_OK);
            }
            break;
        }               //... ELSE fall thru

    case IDM_E_FIND:
        {
#ifndef RLWIN32
            FARPROC lpfnTOKFINDMsgProc;

            lpfnTOKFINDMsgProc = MakeProcInstance((FARPROC)TOKFINDMsgProc,
                                                  hInst);

            if (!DialogBox( hInst, TEXT("TOKFIND"), hWnd, lpfnTOKFINDMsgProc))
#else
            if (!DialogBox(hInst, TEXT("TOKFIND"), hWnd, TOKFINDMsgProc))
#endif
	    {
#ifndef DBCS
// 'Token Not Found' is strange because user selected cancel #3042
                TCHAR sz1[80] = TEXT("");
                TCHAR sz2[80] = TEXT("");

                LoadString( hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWnd, sz2, sz1, MB_ICONINFORMATION | MB_OK);
#endif	//DBCS
	    }
#ifndef RLWIN32
            FreeProcInstance( lpfnTOKFINDMsgProc);
#endif
            return TRUE;
        }

    case IDM_E_REVIEW:
        {
            LRESULT lrSaveSelection = 0;

            nUpdateMode = 1;

            // set listbox selection to begining of the token list
            lrSaveSelection = SendMessage( hListWnd,
                                           LB_GETCURSEL,
                                           (WPARAM)0,
                                           (LPARAM)0);

            SendMessage( hListWnd, LB_SETCURSEL, (WPARAM)0, (LPARAM)0);

            if ( DoTokenSearch( NULL, NULL, ST_NEW, ST_NEW, FALSE, FALSE) )
            {
#ifdef RLWIN32
                SendMessage( hMainWnd,
                             WM_COMMAND,
                             MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                             (LPARAM)0);
#else
                SendMessage( hMainWnd,
                             WM_COMMAND,
                             IDC_LIST,
                             MAKELONG( 0, LBN_DBLCLK));
#endif
            }
        }
        break;


    case IDM_H_CONTENTS:
    {
        OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

        if ( OpenFile( gszHelpFile, &Of, OF_EXIST) == HFILE_ERROR)
        {
            LoadString( hInst,
                        IDS_ERR_NO_HELP ,
                        tsz,
                        TCHARSIN( sizeof( tsz)));
            MessageBox( hWnd, tsz, NULL, MB_OK);
        }
        else
        {
            WinHelpA( hWnd, gszHelpFile, HELP_KEY,(DWORD_PTR)((LPSTR)"RLAdmin"));
        }
        break;
    }

    case IDM_H_ABOUT:
        {
#ifndef RLWIN32

            WNDPROC lpProcAbout;

            lpProcAbout = MakeProcInstance(About, hInst);
            DialogBox(hInst, TEXT("ABOUT"), hWnd, lpProcAbout);
            FreeProcInstance(lpProcAbout);
#else
            DialogBox(hInst, TEXT("ABOUT"), hWnd, About);
#endif
        }
        break;

    default:
        break;
    }  // WM_COMMAND switch
    return FALSE;
}

/**
  *
  *
  *  Function:  TokEditDlgProc
  *   Procedure for the edit mode dialog window. Loads the selected token
  *   info into the window, and allows the user to change the token text.
  *   Once the edit is complete, the procedure sends a message to the
  *   list box windows to update the current token info.
  *
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  *   TRUE, carry out edit, and update token list box.
  *   FALSE, cancel edit.
  *
  *  History:
  *
  *
  **/

INT_PTR TokEditDlgProc(

HWND   hDlg,
UINT   wMsg,
WPARAM wParam,
LPARAM lParam)
{
    HWND    hCtl;
    HWND    hParentWnd;
    UINT    static wcTokens = 0;
    UINT    wIndex;
    static BOOL fChanged = FALSE;

    switch(wMsg)
    {
    case WM_INITDIALOG:
        cwCenter(hDlg, 0);
        wcTokens = (UINT)SendMessage( hListWnd,
                                      LB_GETCOUNT,
                                      (WPARAM)0,
                                      (LPARAM)0);
        wcTokens--;
        hCtl = GetDlgItem(hDlg,IDD_STATUS);
        {
            TCHAR sz[80];

            LoadString( hInst, IDS_UNCHANGED, sz, TCHARSIN( sizeof( sz)));
            SendMessage( hCtl, CB_ADDSTRING, (WPARAM)0, (LPARAM)sz);

            LoadString( hInst, IDS_CHANGED, sz, TCHARSIN( sizeof( sz)));
            SendMessage( hCtl, CB_ADDSTRING, (WPARAM)0, (LPARAM)sz);

            LoadString( hInst, IDS_NEW, sz, TCHARSIN( sizeof( sz)));
            SendMessage( hCtl, CB_ADDSTRING, (WPARAM)0, (LPARAM)sz);

            LoadString( hInst, IDS_READONLY, sz, TCHARSIN( sizeof( sz)));
            SendMessage( hCtl, CB_ADDSTRING, (WPARAM)0, (LPARAM)sz);
        }

        if( ! nUpdateMode )
        {

            if (hCtl = GetDlgItem(hDlg, IDD_SKIP))
            {
                EnableWindow(hCtl, FALSE);
            }
        }
        else
        {
            if (hCtl = GetDlgItem(hDlg, IDD_SKIP))
            {
                EnableWindow(hCtl, TRUE);
            }
        }
        fChanged = FALSE;
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_SKIP:
            wIndex = (UINT)SendMessage( hListWnd,
                                        LB_GETCURSEL,
                                        (WPARAM)0,
                                        (LPARAM)0);

            if ( nUpdateMode &&  wIndex < wcTokens )
            {
                wIndex ++;
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             (WPARAM)wIndex,
                             (LPARAM)0);

                if ( DoTokenSearch( NULL, NULL, ST_NEW, ST_NEW, FALSE, FALSE) )
                {
                    wIndex = (UINT)SendMessage( hListWnd,
                                                LB_GETCURSEL,
                                                (WPARAM)0,
                                                (LPARAM)0);
                    SendMessage( hMainWnd,
                                 WM_COMMAND,
                                 MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                 (LPARAM)0);
                    return TRUE;
                }
            }
            nUpdateMode = 0;
            DestroyWindow(hDlg);
#ifndef RLWIN32
            FreeProcInstance(lpTokEditDlg);
#endif
            hTokEditDlgWnd = 0;
            break;

        case IDD_STATUS:
            fChanged = TRUE;
            break;

        case IDOK:
            wIndex = (UINT)SendMessage( hListWnd,
                                        LB_GETCURSEL,
                                        (WPARAM)0,
                                        (LPARAM)0);
            if (fChanged)
            {
                int i;
                fChanged = FALSE;

                hCtl = GetDlgItem(hDlg, IDD_STATUS);
                i = (int)SendMessage( hCtl,
                                      CB_GETCURSEL,
                                      (WPARAM)0,
                                      (LPARAM)0);
                hParentWnd = GetParent(hDlg);
                SendMessage( hParentWnd, WM_TOKEDIT, (WPARAM)i, (LPARAM)0);
            }
            // Exit, or goto to next changed token if in update mode

            if ( nUpdateMode && wIndex < wcTokens )
            {
                wIndex++;
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             (WPARAM)wIndex,
                             (LPARAM)0);

                if ( DoTokenSearch( NULL, NULL, ST_NEW, ST_NEW, FALSE, FALSE) )
                {
                    // go into edit mode
                    SendMessage( hMainWnd,
                                 WM_COMMAND,
                                 MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                 (LPARAM)0);

                    return TRUE;
                }
            }
            // fall through to IDCANCEL

        case IDCANCEL:
            nUpdateMode = 0;
            // remove edit dialog box
            DestroyWindow(hDlg);
#ifndef RLWIN32
            FreeProcInstance(lpTokEditDlg);
#endif
            hTokEditDlgWnd = 0;
            break;

        } // WM_COMMAND
        return TRUE;

    default:
        if (hCtl = GetDlgItem(hDlg, IDOK))
        {
            EnableWindow(hCtl, TRUE);
        }
        return FALSE;
    } // Main Switch
}

/**
  *
  *
  *  Function: TOKFINDMsgProc
  *
  *  Arguments:
  *
  *  Returns:
  *   NA.
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/


INT_PTR TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hCtl;
    int rgiTokenTypes[]=
    {
        ID_RT_MENU,
        ID_RT_DIALOG,
        ID_RT_STRING,
        ID_RT_ACCELERATORS,
        ID_RT_RCDATA,
        ID_RT_ERRTABLE,
        ID_RT_NAMETABLE,
        ID_RT_VERSION,
        ID_RT_DLGINIT
    };

    TCHAR szTokenType[40] = TEXT("");
    UINT i;

    switch(wMsg)
    {
    case WM_INITDIALOG:

        CheckDlgButton(hWndDlg, IDD_READONLY, 2);
        CheckDlgButton(hWndDlg, IDD_CHANGED, 2);
        CheckDlgButton(hWndDlg, IDD_FINDDOWN, 1);
        hCtl = GetDlgItem(hWndDlg, IDD_TYPELST);

        for ( i = 0; i < sizeof( rgiTokenTypes) / 2; i++)
        {
            LoadString( hInst,
                        IDS_RESOURCENAMES + rgiTokenTypes[i],
                        szTokenType,
                        TCHARSIN( sizeof( szTokenType)));
            SendMessage( hCtl,
                         CB_ADDSTRING,
                         (WPARAM)0,
                         (LPARAM)szTokenType);
        }
        return TRUE;
        break;

    case WM_COMMAND:

        switch(wParam)
        {
        case IDOK: /* Button text: "Okay"                        */
            fSearchStarted = TRUE;
            GetDlgItemText( hWndDlg,
                            IDD_TYPELST,
                            szSearchType,
                            TCHARSIN( sizeof( szSearchType)));
            GetDlgItemText( hWndDlg,
                            IDD_FINDTOK,
                            szSearchText,
                            TCHARSIN( sizeof( szSearchText)));

            wSearchStatus = wSearchStatusMask = 0;

            switch (IsDlgButtonChecked(hWndDlg, IDD_READONLY))
            {
            case 1:
                wSearchStatus |= ST_READONLY;

            case 0:
                wSearchStatusMask |= ST_READONLY;
            }

            switch (IsDlgButtonChecked(hWndDlg, IDD_CHANGED))
            {
            case 1:
                wSearchStatus |= ST_CHANGED;

            case 0:
                wSearchStatusMask |= ST_CHANGED;
            }

            fSearchDirection = IsDlgButtonChecked(hWndDlg, IDD_FINDUP);

            if( DoTokenSearch(szSearchType,
                              szSearchText,
                              wSearchStatus,
                              wSearchStatusMask,
                              fSearchDirection,
                              FALSE) )
            {
                EndDialog( hWndDlg, TRUE );
            }
            else
            {
                TCHAR sz1[80], sz2[80];

                LoadString( hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWndDlg, sz2, sz1, MB_ICONINFORMATION | MB_OK);
                EndDialog( hWndDlg, FALSE );
            }

        case IDCANCEL:

            EndDialog( hWndDlg, FALSE);
            return TRUE;
        }
        break;      /* End of WM_COMMAND     */

    default:
        return FALSE;
    }
    return FALSE;
}

/**
  *  Function:  NewDlgProc
  *   Procedure for the new project dialog window.
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  *   TRUE, carry out edit, and update token list box.
  *   FALSE, cancel edit.
  *
  *  History:
  **/

INT_PTR APIENTRY NewDlgProc(

HWND   hDlg,
UINT   wMsg,
WPARAM wParam,
LPARAM lParam)
{
    CHAR pszDrive[ _MAX_DRIVE] = "";
    CHAR pszDir[   _MAX_DIR]   = "";
    CHAR pszName[  _MAX_FNAME] = "";
    CHAR pszExt[   _MAX_EXT]   = "";


    switch ( wMsg )
    {
    case WM_INITDIALOG:
    {
        LPTSTR pszLangName = NULL;
        OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};
        int nSel = 0;


        iLastBox       = IDD_SOURCERES;
        fLangSelected  = FALSE;
        _splitpath( gProj.szMpj, pszDrive, pszDir, pszName, pszExt);

        sprintf( szDHW, "%s%s%s.%s", pszDrive, pszDir, pszName, "EXE");
        SetDlgItemTextA( hDlg, IDD_SOURCERES, szDHW);

        sprintf( szDHW, "%s%s%s.%s", pszDrive, pszDir, pszName, "MTK");
        SetDlgItemTextA( hDlg, IDD_MTK, szDHW);

        sprintf( szDHW, "%s%s%s.%s", pszDrive, pszDir, pszName, "RDF");

        if ( OpenFile( szDHW, &Of, OF_EXIST) != HFILE_ERROR )
            SetDlgItemTextA( hDlg, IDD_RDFS, szDHW);
        else
            SetDlgItemText( hDlg, IDD_RDFS, TEXT(""));

        if ( gMstr.uCodePage == CP_ACP )
            gMstr.uCodePage = GetACP();
        else if ( gMstr.uCodePage == CP_OEMCP )
            gMstr.uCodePage = GetOEMCP();

        if ( ! IsValidCodePage( gMstr.uCodePage) )
        {
            static TCHAR szMsg[ 256];
            CHAR *pszCP[1];

            pszCP[0] = UlongToPtr(gMstr.uCodePage);

            LoadString( hInst, IDS_NOCPXTABLE, szMsg, 256);
            FormatMessage( FORMAT_MESSAGE_FROM_STRING
                         | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           szMsg,
                           0,
                           0,
                           (LPTSTR)szDHW,
                           DHWSIZE/sizeof(TCHAR),
                           (va_list *)pszCP);
            MessageBox( hDlg, (LPCTSTR)szDHW, tszAppName, MB_ICONHAND|MB_OK);
            SetDlgItemInt( hDlg, IDD_TOK_CP, gMstr.uCodePage, FALSE);
            return( TRUE);
        }
        SetDlgItemInt( hDlg, IDD_TOK_CP, gMstr.uCodePage, FALSE);
        PostMessage( hDlg, WM_COMMAND, IDD_BROWSE, 0);
        return TRUE;
    }

    case WM_COMMAND:

        switch ( GET_WM_COMMAND_ID( wParam, lParam) )
        {
        case IDD_SOURCERES:
        case IDD_MTK:
        case IDD_RDFS:
            iLastBox = GET_WM_COMMAND_ID(wParam, lParam);
            break;

        case IDD_BROWSE:
            switch ( iLastBox )
            {
            case IDD_SOURCERES:
                szFSpec = szExeResFilterSpec;
                szExt = "EXE";
                LoadStrIntoAnsiBuf( hInst,
                                    IDS_RES_SRC,
                                    szPrompt,
                                    ACHARSIN( sizeof( szPrompt)));
                fLangSelected = FALSE;
                break;

            case IDD_RDFS:
                szFSpec = szRdfFilterSpec;
                szExt = "RDF";
                LoadStrIntoAnsiBuf( hInst,
                                    IDS_RDF,
                                    szPrompt,
                                    ACHARSIN( sizeof( szPrompt)));
                break;

            case IDD_MTK:
                szFSpec = szMtkFilterSpec;
                szExt = "MTK";
                LoadStrIntoAnsiBuf( hInst,
                                    IDS_MTK,
                                    szPrompt,
                                    ACHARSIN( sizeof(szPrompt)));
                break;
            }

            GetDlgItemTextA(hDlg, iLastBox, szNewFileName, MAXFILENAME);

            if ( GetFileNameFromBrowse( hDlg,
                                        szNewFileName,
                                        MAXFILENAME,
                                        szPrompt,
                                        szFSpec,
                                        szExt) )
            {
                SetDlgItemTextA( hDlg, iLastBox, szNewFileName);

                if ( iLastBox == IDD_SOURCERES )
                {                       // fill in suggested name for the MTK box
                    CHAR pszDrive[_MAX_DRIVE] = "";
                    CHAR pszDir[  _MAX_DIR]   = "";
                    CHAR pszName[ _MAX_FNAME] = "";
                    CHAR pszExt[  _MAX_EXT]   = "";


                    lstrcpyA( gMstr.szSrc, szNewFileName);

                    FillListAndSetLang( hDlg,
                                        IDD_MSTR_LANG_NAME,
                                        &gMstr.wLanguageID,
                                        &fLangSelected);

                    _splitpath( szNewFileName, pszDrive, pszDir, pszName, pszExt);
                    GetDlgItemTextA(hDlg, IDD_MTK, szNewFileName, MAXFILENAME);

                    if ( ! szNewFileName[0] )
                    {
                        sprintf( szNewFileName,
                                 "%s%s%s.%s",
                                 pszDrive,
                                 pszDir,
                                 pszName,
                                 "MTK");
                        SetDlgItemTextA( hDlg, IDD_MTK, szNewFileName);
                    }
                }
            }
            break;

        case IDD_MSTR_LANG_NAME:

            if ( GET_WM_COMMAND_CMD( wParam, lParam) == CBN_SELENDOK )
            {
                fLangSelected = TRUE;
            }
            break;

        case IDOK:

            if ( fLangSelected )
            {
                MSTRDATA stProject =
                { "", "", "", "", "",
                  MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US),
                  CP_ACP
                };
                BOOL fTranslated = FALSE;
                UINT uCP = GetDlgItemInt( hDlg,
                                          IDD_TOK_CP,
                                          &fTranslated,
                                          FALSE);

                                //... Get the selected language name
                                //... then set the appropriate lang id vals

                INT_PTR nSel = SendDlgItemMessage( hDlg,
                                               IDD_MSTR_LANG_NAME,
                                               CB_GETCURSEL,
                                               (WPARAM)0,
                                               (LPARAM)0);

                if ( nSel != CB_ERR
                  && SendDlgItemMessage( hDlg,
                                         IDD_MSTR_LANG_NAME,
                                         CB_GETLBTEXT,
                                         (WPARAM)nSel,
                                         (LPARAM)(LPTSTR)szDHW) != CB_ERR )
                {
                    WORD wPri = 0;
                    WORD wSub = 0;

                    if ( GetLangIDs( (LPTSTR)szDHW, &wPri, &wSub) )
                    {
                        gMstr.wLanguageID = MAKELANGID( wPri, wSub);
                    }
                    else
                    {
                        fLangSelected = FALSE;
                        return( TRUE);
                    }
                }

                if ( uCP == CP_ACP )
                    uCP = GetACP();
                else if ( uCP == CP_OEMCP )
                    uCP = GetOEMCP();

                if ( IsValidCodePage( uCP) )
                {
                    gMstr.uCodePage = uCP;
                }
                else
                {
                    static TCHAR szMsg[ 256];
                    CHAR *pszCP[1];

                    pszCP[0] = UlongToPtr(uCP);

                    LoadString( hInst, IDS_NOCPXTABLE, szMsg, 256);
                    FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                 | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   szMsg,
                                   0,
                                   0,
                                   (LPTSTR)szDHW,
                                   DHWSIZE/sizeof(TCHAR),
                                   (va_list *)pszCP);
                    MessageBox( hDlg, (LPCTSTR)szDHW, tszAppName, MB_ICONHAND|MB_OK);
                    SetDlgItemInt( hDlg, IDD_TOK_CP, gMstr.uCodePage, FALSE);
                    return( TRUE);
                }

                GetDlgItemTextA( hDlg,
                                 IDD_SOURCERES,
                                 stProject.szSrc,
                                 MAXFILENAME);

                GetDlgItemTextA( hDlg,
                                 IDD_RDFS,
                                 stProject.szRdfs,
                                 MAXFILENAME);

                GetDlgItemTextA( hDlg,
                                 IDD_MTK,
                                 stProject.szMtk,
                                 MAXFILENAME);

                if ( stProject.szSrc[0] && stProject.szMtk[0] )
                {
                    _fullpath( gMstr.szSrc,
                               stProject.szSrc,
                               ACHARSIN( sizeof( gMstr.szSrc)));

                    _fullpath( gMstr.szMtk,
                               stProject.szMtk,
                               ACHARSIN( sizeof( gMstr.szMtk)));

                    if ( stProject.szRdfs[0] )
                    {
                        _fullpath( gMstr.szRdfs,
                                   stProject.szRdfs,
                                   ACHARSIN( sizeof( gMstr.szRdfs)));
                    }
                    else
                    {
                        gMstr.szRdfs[0] = '\0';
                    }
                    gProj.fSourceEXE = IsExe( gMstr.szSrc);

                    EndDialog( hDlg, TRUE);
                    return( TRUE);
                }
                else
                {
                    break;
                }
            }
            else
            {
                LoadString( hInst, IDS_SELECTLANG, (LPTSTR)szDHW, TCHARSIN( DHWSIZE));
                MessageBox( hDlg, (LPTSTR)szDHW, tszAppName, MB_ICONHAND | MB_OK);
                break;
            }

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            return( TRUE);
        }
        break;
    }
    return( FALSE);
}

/**
  *
  *
  *  Function:  ViewDlgProc
  *   Procedure for the View project dialog window.
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  *   TRUE, carry out edit, and update token list box.
  *   FALSE, cancel edit.
  *
  *  History:
  *
  *
  **/

INT_PTR ViewDlgProc(

HWND hDlg,
UINT wMsg,
WPARAM wParam,
LPARAM lParam)
{
    static int iLastBox = IDD_SOURCERES;

    switch(wMsg)
    {
    case WM_INITDIALOG:
    {
        WORD wPri = PRIMARYLANGID( gMstr.wLanguageID);
        WORD wSub = SUBLANGID( gMstr.wLanguageID);
        LPTSTR pszName = GetLangName( wPri, wSub);

        SetDlgItemTextA( hDlg, IDD_VIEW_SOURCERES, gMstr.szSrc);
        SetDlgItemTextA( hDlg, IDD_VIEW_MTK,       gMstr.szMtk);
        SetDlgItemTextA( hDlg, IDD_VIEW_RDFS,      gMstr.szRdfs);
        SetDlgItemText(  hDlg, IDD_MSTR_LANG_NAME, pszName);
        SetDlgItemInt( hDlg, IDD_TOK_CP, gMstr.uCodePage, FALSE);
        return TRUE;
    }

    case WM_COMMAND:

        switch ( wParam )
        {
        case IDOK:
            EndDialog( hDlg, TRUE);
            return TRUE;
        }
    }
    return FALSE;
}


void DrawLBItem(LPDRAWITEMSTRUCT lpdis)
{
    LPRECT  lprc    = (LPRECT) &(lpdis->rcItem);
    DWORD   rgbOldText  = 0;
    DWORD   rgbOldBack  = 0;
    HBRUSH  hBrush;
    static DWORD    rgbHighlightText;
    static DWORD    rgbHighlightBack;
    static HBRUSH   hBrushHilite = NULL;
    static HBRUSH   hBrushNormal = NULL;
    static DWORD    rgbChangedText;
    static DWORD    rgbBackColor;
    static DWORD    rgbUnchangedText;
    static DWORD    rgbReadOnlyText;
    static DWORD    rgbNewText;
    TCHAR   *szToken = NULL;
    TOKEN   tok;
    LPTSTR lpstrToken = NULL;

    if (lpdis->itemAction & ODA_FOCUS)
    {
        DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
    }
    else
    {
        HANDLE hMem = (HANDLE)SendMessage( lpdis->hwndItem,
                                           LB_GETITEMDATA,
                                           (WPARAM)lpdis->itemID,
                                           (LPARAM)0);
        lpstrToken = (LPTSTR)GlobalLock( hMem);
        szToken = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
        lstrcpy( szToken, lpstrToken);
        GlobalUnlock( hMem);
        ParseBufToTok(szToken, &tok);
        RLFREE( szToken);

        if (lpdis->itemState & ODS_SELECTED)
        {
            if (!hBrushHilite)
            {
                rgbHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                rgbHighlightBack = GetSysColor(COLOR_HIGHLIGHT);
                hBrushHilite = CreateSolidBrush(rgbHighlightBack);
            }
            MakeStatusLine(&tok);

            rgbOldText = SetTextColor(lpdis->hDC, rgbHighlightText);
            rgbOldBack = SetBkColor(lpdis->hDC, rgbHighlightBack);

            hBrush = hBrushHilite;
        }
        else
        {
            if (!hBrushNormal)
            {
                rgbChangedText = RGB(255, 0, 0);
                rgbBackColor = RGB(192, 192, 192);
                rgbUnchangedText = RGB(0, 0, 0);
                rgbReadOnlyText = RGB(127, 127, 127);
                rgbNewText = RGB(0, 0, 255);
                hBrushNormal = CreateSolidBrush(rgbBackColor);
            }
            if (tok.wReserved & ST_READONLY)
            {
                rgbOldText = SetTextColor(lpdis->hDC, rgbReadOnlyText);
            }
            else if (tok.wReserved & ST_CHANGED)
            {
                rgbOldText = SetTextColor(lpdis->hDC, rgbChangedText);
            }
            else if (tok.wReserved & ST_NEW)
            {
                rgbOldText = SetTextColor(lpdis->hDC, rgbNewText);
            }
            else
            {
                rgbOldText = SetTextColor(lpdis->hDC, rgbUnchangedText);
            }
            rgbOldBack = SetBkColor(lpdis->hDC, rgbBackColor);
            hBrush = hBrushNormal;
        }
        FillRect(lpdis->hDC, (CONST RECT *)lprc, hBrush);

        DrawText(lpdis->hDC,
                 tok.szText,
                 STRINGSIZE(lstrlen(tok.szText)),
                 lprc,
                 DT_LEFT|DT_NOPREFIX);
        RLFREE( tok.szText);

        if (rgbOldText)
        {
            SetTextColor(lpdis->hDC, rgbOldText);
        }

        if (rgbOldBack)
        {
            SetBkColor(lpdis->hDC, rgbOldBack);
        }

        if (lpdis->itemState & ODS_FOCUS)
        {
            DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
        }
    }
}

/*
 * Function:  Make Status Line
 *   Builds status line string from a token
 *
 * Inputs:
 *    pszStatusLine, buffer to hold string
 *    pTok, pointer to token structure
 *
 * History:
 *   2/92, implemented      SteveBl
 *   7/92, changed to talk to new StatusWndProc  t-GregTi
 */
static void MakeStatusLine(TOKEN *pTok)
{
    static BOOL fFirstCall = TRUE;
    TCHAR szName[32] = TEXT("");
    TCHAR szStatus[20] = TEXT("");
    TCHAR szResIDStr[20] = TEXT("");

    CHAR  szTmpBuf[32] = "";

    // now build status line

    if (pTok->szName[0])
    {
        lstrcpy(szName, pTok->szName);
    }
    else
    {
#ifdef UNICODE
        _itoa(pTok->wName, szTmpBuf, 10);
        _MBSTOWCS( szName,
                   szTmpBuf,
                   WCHARSIN( sizeof( szName)),
                   ACHARSIN( strlen( szTmpBuf) + 1));
#else
        _itoa(pTok->wName, szName, 10);
#endif
    }

    if ( pTok->wReserved & ST_READONLY )
    {
        LoadString( hInst,
                    IDS_READONLY,
                    szStatus,
                    TCHARSIN( sizeof( szStatus)));
    }
    else if (pTok->wReserved == ST_NEW)
    {
        LoadString( hInst,
                    IDS_NEW,
                    szStatus,
                    TCHARSIN( sizeof( szStatus)));
    }
    else if (pTok->wReserved & ST_CHANGED)
    {
        LoadString( hInst,
                    IDS_CHANGED,
                    szStatus,
                    TCHARSIN( sizeof( szStatus)));
    }
    else
    {
        LoadString( hInst,
                    IDS_UNCHANGED,
                    szStatus,
                    TCHARSIN( sizeof( szStatus)));
    }

    if ( pTok->wType <= 16 || pTok->wType == ID_RT_DLGINIT )
    {
        LoadString( hInst,
                    IDS_RESOURCENAMES+pTok->wType,
                    szResIDStr,
                    TCHARSIN( sizeof( szResIDStr)));
    }
    else
    {
#ifdef UNICODE
        _itoa( pTok->wType, szTmpBuf, 10);
        _MBSTOWCS( szResIDStr,
                   szTmpBuf,
                   WCHARSIN( sizeof( szResIDStr)),
                   ACHARSIN( strlen( szTmpBuf) + 1));
#else
        _itoa(pTok->wType, szResIDStr, 10);
#endif
    }

    if (fFirstCall)
    {
        SendMessage( hStatusWnd,
                     WM_FMTSTATLINE,
                     (WPARAM)0,
                     (LPARAM)TEXT("10s10s5i8s4i"));
        fFirstCall = FALSE;
    }
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)0, (LPARAM)szResIDStr);
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)1, (LPARAM)szName);
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)2, (LPARAM)pTok->wID);
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)3, (LPARAM)szStatus);
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)4,
                 (LPARAM)lstrlen( pTok->szText));
}


/**********************************************************************
*FUNCTION: SaveMtkList(HWND)                                          *
*                                                                     *
*PURPOSE: Save current Token List                                     *
*                                                                     *
*COMMENTS:                                                            *
*                                                                     *
*This saves the current contents of the Token List                    *
**********************************************************************/

static BOOL SaveMtkList(HWND hWnd, FILE *fpTokFile)
{
    BOOL   bSuccess = TRUE;
    int    IOStatus;      // result of a file write
    UINT   cTokens;
    UINT   cCurrentTok = 0;
    TCHAR  *szTmpBuf;
    CHAR  *szTokBuf;
    TCHAR  str[255] = TEXT("");
    TOKENDELTAINFO FAR *pTokNode;
    LPTSTR lpstrToken;

    // Set the cursor to an hourglass during the file transfer

    hSaveCursor = SetCursor(hHourGlass);

    // Find number of tokens in the list

    cTokens = (UINT) SendMessage( hListWnd, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);

    if (cTokens != LB_ERR)
    {
        for (cCurrentTok = 0; bSuccess && (cCurrentTok < cTokens); cCurrentTok++)
        {
#ifdef UNICODE
            int nLenW = 0;
            int nLenA = 0;
#endif
            // Get each token from list
            HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                 LB_GETITEMDATA,
                                                 (WPARAM)cCurrentTok,
                                                 (LPARAM)0);
            lpstrToken = (LPTSTR)GlobalLock( hMem);

#ifdef UNICODE
            nLenW = lstrlen( lpstrToken) + 1;
            szTmpBuf = (TCHAR *)FALLOC( (nLenA = MEMSIZE( nLenW)));
            lstrcpy( szTmpBuf, lpstrToken);
            GlobalUnlock( hMem);
            szTokBuf = (CHAR *)FALLOC( nLenA);
            _WCSTOMBS( szTokBuf, szTmpBuf, nLenA, nLenW);
            RLFREE( szTmpBuf);
#else
            szTokBuf = (CHAR *)FALLOC( strlen( lpstrToken) + 1);
            lstrcpy( szTokBuf, lpstrToken);
#endif
            IOStatus = fprintf(fpTokFile, "%s\n", szTokBuf);

            if ( IOStatus != (int) strlen(szTokBuf) + 1 )
            {
                LoadString( hInst,
                            IDS_FILESAVEERR,
                            str,
                            TCHARSIN( sizeof( str)));
                MessageBox( hWnd, str, NULL, MB_OK | MB_ICONHAND);
                bSuccess = FALSE;
            }
            RLFREE( szTokBuf);
        }
    }

    pTokNode = pTokenDeltaInfo;

    while (pTokNode)
    {
        TOKEN *pTok;
        int nLenW = 0;
        int nLenA = 0;

        pTok = &(pTokNode->DeltaToken);

#ifdef UNICODE
        nLenW = TokenToTextSize( pTok);
        szTmpBuf = (TCHAR *)FALLOC( (nLenA = MEMSIZE( nLenW)));
        ParseTokToBuf( szTmpBuf, pTok);
        szTokBuf = (CHAR *)FALLOC( nLenA);
        _WCSTOMBS( szTokBuf, szTmpBuf, nLenA, nLenW);
        RLFREE( szTmpBuf);
#else
        szTokBuf = (CHAR *)FALLOC( TokenToTextSize( pTok));
        ParseTokToBuf( szTokBuf, pTok);
#endif

        IOStatus = fprintf(fpTokFile, "%s\n", szTokBuf);

        if ( IOStatus != (int) strlen(szTokBuf) + 1 )
        {
            LoadString( hInst,
                        IDS_FILESAVEERR,
                        str,
                        TCHARSIN( sizeof(str)));
            MessageBox( hWnd, str, NULL, MB_OK | MB_ICONHAND);
            bSuccess = FALSE;
        }
        pTokNode = pTokNode->pNextTokenDelta;
    }

    // restore cursor

    SetCursor(hSaveCursor);

    return (bSuccess);
}

/**
  * Function: CleanDeltaList
  *   frees the pTokenDeltaInfo list
  */
static void CleanDeltaList(void)
{
    TOKENDELTAINFO FAR *pTokNode;

    while (pTokNode = pTokenDeltaInfo)
    {
        pTokenDeltaInfo = pTokNode->pNextTokenDelta;
        RLFREE( pTokNode->DeltaToken.szText);
        RLFREE( pTokNode);
    }
}


static TOKENDELTAINFO FAR *InsertMtkList(FILE * fpTokFile)
{
    TOKENDELTAINFO FAR * ptTokenDeltaInfo, FAR * pTokenDeltaInfo = NULL;
    int scTokStat;
    TOKEN tToken;
    UINT wcChars = 0;
    LPTSTR lpstrToken;

    rewind(fpTokFile);

    while ( (scTokStat = GetToken( fpTokFile, &tToken)) >= 0 )
    {
        if ( scTokStat == 0 )
        {
            if ( tToken.wReserved != ST_CHANGED )
            {
                HGLOBAL hMem = GlobalAlloc( GMEM_ZEROINIT, MEMSIZE( TokenToTextSize( &tToken)));
                lpstrToken = (LPTSTR)GlobalLock( hMem);
                ParseTokToBuf( lpstrToken, &tToken);
                GlobalUnlock( hMem);
                    // only add tokens that aren't changed && old
                if ( SendMessage( hListWnd,
                                  LB_ADDSTRING,
                                  (WPARAM)0,
                                  (LPARAM)hMem) < 0 )
                {
                    QuitA( IDS_ENGERR_11, NULL, NULL);
                }
            }
            else
            {
                // the current token is delta info so save in delta list.
                if (!pTokenDeltaInfo)
                {
                    ptTokenDeltaInfo = pTokenDeltaInfo =
                        UpdateTokenDeltaInfo(&tToken);
                }
                else
                {
                    ptTokenDeltaInfo->pNextTokenDelta =
                        UpdateTokenDeltaInfo(&tToken);
                    ptTokenDeltaInfo = ptTokenDeltaInfo->pNextTokenDelta;
                }
            }
            RLFREE( tToken.szText);
        }
    }

    return(pTokenDeltaInfo);
}

/*
 * About -- message processor for about box
 *
 */
//#ifdef RLWIN32

INT_PTR CALLBACK About(

HWND   hDlg,
UINT   message,
WPARAM wParam,
LPARAM lParam)
{
    switch( message )
    {
        case WM_INITDIALOG:
            {
                WORD wRC = SUCCESS;
                CHAR szModName[ MAXFILENAME];

                GetModuleFileNameA( hInst, szModName, sizeof( szModName));

                if ( (wRC = GetCopyright( szModName,
                                          szDHW,
                                          DHWSIZE)) == SUCCESS )
                {
                    SetDlgItemTextA( hDlg, IDC_COPYRIGHT, szDHW);
                }
                else
                {
                    ShowErr( wRC, NULL, NULL);
                }
            }
            break;

        case WM_COMMAND:

            if ((wParam == IDOK) || (wParam == IDCANCEL))
            {
                EndDialog(hDlg, TRUE);
            }
            break;

        default:

            return( FALSE);
    }
    return( TRUE);
}


//...................................................................

int  RLMessageBoxA(

LPCSTR pszMsgText)
{
    return( MessageBoxA( hMainWnd, pszMsgText, szAppName, MB_ICONHAND|MB_OK));
}


//...................................................................

void Usage()
{
    return;
}


//...................................................................

void DoExit( int nErrCode)
{
    ExitProcess( (UINT)nErrCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\common\windefs.h ===
#ifndef _WINDEFS_H_
#define _WINDEFS_H_

// USER DEFINED MESSAGES

#define WM_TOKEDIT      WM_USER + 2
#define WM_UPDSTATLINE      WM_USER + 2

#define WM_FMTSTATLINE      WM_USER + 3
#define WM_READMPJDATA      WM_USER + 3
#define WM_LOADPROJECT      WM_USER + 3

#define WM_LOADTOKENS       WM_USER + 4
#define WM_SAVEPROJECT      WM_USER + 5
#define WM_EDITER_CLOSED    WM_USER + 6
#define WM_VIEW             WM_USER + 7
#define WM_TRANSLATE        WM_USER + 8
#define WM_SAVETOKENS       WM_USER + 9

#define ID_ICON     1


/* Windows macros */

#pragma message("Using the WIN translation of the common macros.")

#ifdef RLWIN32

#ifdef _DEBUG

FILE  * MyFopen( char *, char *, char *, int);
int     MyClose( FILE **, char *, int);

#define FALLOC(n)        MyAlloc( (size_t)(n), __FILE__, __LINE__)
#define FREALLOC(p,n)    MyReAlloc( (p),(n), __FILE__, __LINE__)
#define FOPEN(f,m) 		 MyFopen( (f), (m), __FILE__, __LINE__)
#define FCLOSE(p) 		 MyClose( &(p), __FILE__, __LINE__)

#else // _DEBUG

FILE  *MyFopen( char *, char *);
int     MyClose( FILE **);

#define FALLOC(n)        MyAlloc( (size_t)(n))
#define FREALLOC(p,n)    MyReAlloc( (p),(n))
#define FOPEN(f,m)  	 fopen( (f),(m))
//#define FOPEN(f,m)  	 MyFopen( (f),(m))
//#define FCLOSE(p)   	 MyClose( &(p))
//#define FCLOSE(p)   	 {if(p){fclose( p);p=NULL;}}
#define FCLOSE(p)   	 fclose( p);

#endif // _DEBUG

//#define RLFREE(p)        if(p){GlobalFree(p);p=NULL;}
#define RLFREE(p)        MyFree(&p)
#define ALLOC(n)         FALLOC(n)
#define REALLOC(p,n)     FREALLOC( (p),(n))
#define FMEMMOVE( szDst, szSrc, uSize)  memmove( (szDst), (szSrc), (uSize))
#define FSTRNCPY( szDst, szSrc, uSize)  strncpy( (szDst), (szSrc), (uSize))
#else // RLWIN32
#define FALLOC(n)        (VOID FAR *)MAKELONG( 0, GlobalAlloc(GPTR, (DWORD)n))
#define FFREE(n)         GlobalFree((HANDLE)HIWORD( (LONG)n))
#define FREALLOC(p,n)    (VOID FAR *)MAKELONG( 0, GlobalReAlloc( (HANDLE)HIWORD( (LONG)n),n,GPTR))
#define ALLOC(n)         (VOID NEAR *)LocalAlloc( LPTR,n)
#define FREE(p)          LocalFree( (LOCALHANDLE) p)
#define REALLOC(p,n)     LocalRealloc( p, n, LMEM_MOVEABLE)
#define FMEMMOVE( szDst, szSrc, uSize)  _fmemmove( szDst, szSrc, uSize )
#define FSTRNCPY( szDst, szSrc, uSize)  _fstrncpy( szDst, szSrc, uSize )
#endif // RLWIN32



#ifndef UNICODE
#define MessageBoxA         MessageBox
#define SetWindowTextA      SetWindowText
#define WinHelpA            WinHelp
#define SetDlgItemTextA     SetDlgItemText
#define GetDlgItemTextA     GetDlgItemText
#define GetOpenFileNameA    GetOpenFileName
#define OPENFILENAMEA       OPENFILENAME
#define DragQueryFileA      DragQueryFile
#endif



#ifndef RLWIN32

#ifndef CONST
#define CONST            const
#endif

#define CHAR char
typedef CHAR *LPSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#define WCHAR wchar_t
typedef WCHAR *PWCHAR;
typedef WCHAR *LPWSTR, *PWSTR;

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR LPCTSTR;
#define TEXT(quote) quote
typedef unsigned char UCHAR;
typedef char *PCHAR;
#define UNALIGNED
#endif

#ifdef CAIRO

#define OPENFILENAMEA      OPENFILENAME
#define GetOpenFileNameA   GetOpenFileName
#define HDROP HANDLE

#endif

#ifndef RLWIN32

#define _MBSTOWCS(ds,ss,dc,sc) mbstowcs(ds,ss,sc)
#define _WCSTOMBS(ds,ss,dc,sc) wcstombs(ds,ss,sc)

#else  //RLWIN32

UINT _MBSTOWCS( WCHAR*, CHAR*, UINT, UINT);
UINT _WCSTOMBS( CHAR*, WCHAR*, UINT, UINT);

#endif // RLWIN32

#ifndef MAKEINTRESOURCE

#define MAKEINTRESOURCEA(i) (LPSTR)((DWORD)((WORD)(i)))
#define MAKEINTRESOURCEW(i) (LPWSTR)((DWORD)((WORD)(i)))

#ifdef UNICODE
#define MAKEINTRESOURCE  MAKEINTRESOURCEW
#else
#define MAKEINTRESOURCE  MAKEINTRESOURCEA
#endif // UNICODE

#endif // !MAKEINTRESOURCE

#endif  // _WINDEFS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rlman\help.h ===
//...........................................................
//...
//... Header file for command-line RLMAN's help file
//...........................................................


#define IDM_HELPUSAGE       901
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rledit\rledit.c ===
// INCLUSION PREVENTION DEFINITIONS
#define NOMETAFILE
#define NOMINMAX
#define NOSOUND
#define NOPROFILER
#define NODEFERWINDOWPOS
#define NODRIVERS
#define NOCOMM
#define NOBITMAP
#define NOSCROLL
#define NOWINOFFSETS
#define NOWH
#define NORASTEROPS
#define NOOEMRESOURCE
#define NOGDICAPMASKS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NOATOM
#define NOLOGERROR
#define NOSYSTEMPARAMSINFO

// WINDOWS includes
#include <windows.h>
#include <windowsx.h>

#ifdef RLWIN16
//#include <toolhelp.h>
#endif

#include <shellapi.h>
#include <commdlg.h>

// CRT includes
#include <stdio.h>
#include <stdlib.h>

// RL TOOLS SET includes
#include "windefs.h"
#include "toklist.h"
#include "RESTOK.H"
#include "RLEDIT.H"
#include "update.h"
#include "custres.h"
#include "exe2res.h"
#include "exeNTres.h"
#include "commbase.h"
#include "wincomon.h"
#include "resread.h"
#include "projdata.h"
#include "showerrs.h"
#include "resource.h"

// Global Variables:
static CHAR * gszHelpFile = "rltools.hlp";
extern MSTRDATA gMstr;
extern PROJDATA gProj;

extern BOOL     bRLGui;

#ifdef RLWIN32
HINSTANCE   hInst;      /* Instance of the main window  */
#else
HWND        hInst;          /* Instance of the main window  */
#endif

int  nUpdateMode    = 0;
BOOL fCodePageGiven = FALSE;    //... Set to TRUE if -p arg given
HWND hMainWnd;                  // handle to main window
HWND hListWnd;                  // handle to tok list window
HWND hStatusWnd;                // handle to status windows
CHAR szFileTitle[MAXFILENAME] = ""; // holds base name of latest opened file
CHAR szCustFilterSpec[MAXCUSTFILTER] = "";

extern CHAR szDHW[];     //... used in debug strings
extern BOOL fInThirdPartyEditer;
extern BOOL gfReplace;

static TCHAR   szSearchType[80]   = TEXT("");
static TCHAR   szSearchText[4096] = TEXT("");
static WORD    wSearchStatus      = 0;
static WORD    wSearchStatusMask  = 0;
static BOOL    fSearchDirection;
static BOOL    fSearchStarted     = FALSE;

#ifndef UNICODE
BOOL PASCAL _loadds WatchTask(WORD wID, DWORD dwData);
#endif

#ifdef RLWIN16
static FARPROC lpfnWatchTask = NULL;
#endif

static void CleanDeltaList(void);
static int  ExecResEditor(HWND, CHAR *, CHAR *, CHAR *);
static void DrawLBItem(LPDRAWITEMSTRUCT lpdis);
static void SetNames( HWND hDlg, int iLastBox, LPSTR szNewFile);

// File IO vars

static OPENFILENAMEA ofn;

static CHAR     szFilterSpec    [60] = "";
static CHAR     szPRJFilterSpec [60] = "";
static CHAR     szResFilterSpec [60] = "";
static CHAR     szExeFilterSpec [60] = "";
static CHAR     szDllFilterSpec [60] = "";
static CHAR     szExeResFilterSpec [180] = "";
static CHAR     szTokFilterSpec [60] = "";
static CHAR     szMPJFilterSpec [60] = "";
static CHAR     szGlossFilterSpec[60] = "";
static CHAR     szTempFileName[MAXFILENAME] = "";
static CHAR     szFileName[MAXFILENAME] = "";  // holds full name of latest opened file
static TCHAR    szString[256] = TEXT("");      // variable to load resource strings
static TCHAR    tszAppName[100] = TEXT("");
static CHAR     szAppName[100] = "";
static TCHAR    szClassName[]=TEXT("RLEditClass");
static TCHAR    szStatusClass[]=TEXT("RLEditStatus");

static BOOL    gbNewProject  = FALSE;      // indicates to prompt for auto translate
static BOOL    fTokChanges   = FALSE;      // set to true when toke file is out of date
static BOOL    fTokFile      = FALSE;
static BOOL    fEditing      = FALSE;
static BOOL    fPrjChanges   = FALSE;
static BOOL    fMPJOutOfDate = FALSE;
static BOOL    fPRJOutOfDate = FALSE;

static CHAR     szOpenDlgTitle[80] = ""; // title of File open dialog
static CHAR     szSaveDlgTitle[80] = ""; // title of File saveas dialog

// linked list of token deta info
static TOKENDELTAINFO FAR *pTokenDeltaInfo = NULL;
static LONG    lFilePointer[30]= {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

// circular doubly linked list of translations
static TRANSLIST *pTransList = NULL;

// Window vars
static BOOL        fWatchEditor;
static CHAR        szTempRes[MAXFILENAME] = "";     // temp file for resource editor
// set true if a resource editer has been launched

static HCURSOR    hHourGlass;     /* handle to hourglass cursor     */
static HCURSOR    hSaveCursor;    /* current cursor handle      */
static HACCEL     hAccTable;
static RECT        Rect;   /* dimension of the client window   */
static int cyChildHeight;  /* height of status windows   */


// NOTIMPLEMENTED is a macro that displays a "Not implemented" dialog
#define NOTIMPLEMENTED {TCHAR sz[80];\
                        LoadString( hInst, \
                                    IDS_NOT_IMPLEMENTED, \
                                    sz, TCHARSIN( sizeof(sz)));\
                        MessageBox(hMainWnd, sz, tszAppName, \
                                   MB_ICONEXCLAMATION | MB_OK);}

// Edit Tok Dialog
#ifndef RLWIN32
//static DLGPROC lpTokEditDlg;
#endif
static HWND    hTokEditDlgWnd = 0;


/**
  *
  *
  *  Function: InitApplication
  * Regsiters the main window, which is a list box composed of tokens
  * read from the token file. Also register the status window.
  *
  *
  *  Arguments:
  * hInstance, instance handle of program in memory.
  *
  *  Returns:
  *
  *  Errors Codes:
  * TRUE, windows registered correctly.
  * FALSE, error during register of one of the windows.
  *
  *  History:
  * 9/91, Implemented.      TerryRu
  *
  *
  **/

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS  wc;
    CHAR sz[60] = "";
    CHAR sztFilterSpec[120] = "";


    LoadStrIntoAnsiBuf(hInstance, IDS_PRJSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szFilterSpec, sz, "*.PRJ");
    szFilterSpecFromSz1Sz2(szPRJFilterSpec, sz, "*.PRJ");

    LoadStrIntoAnsiBuf(hInstance, IDS_RESSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szResFilterSpec, sz, "*.RES");

    LoadStrIntoAnsiBuf(hInstance, IDS_EXESPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szExeFilterSpec, sz, "*.EXE");

    LoadStrIntoAnsiBuf(hInstance, IDS_DLLSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szDllFilterSpec, sz, "*.DLL");
    CatSzFilterSpecs(sztFilterSpec, szExeFilterSpec, szDllFilterSpec);
    CatSzFilterSpecs(szExeResFilterSpec, sztFilterSpec, szResFilterSpec);

    LoadStrIntoAnsiBuf(hInstance, IDS_TOKSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szTokFilterSpec, sz, "*.TOK");

    LoadStrIntoAnsiBuf(hInstance, IDS_MPJSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szMPJFilterSpec, sz, "*.MPJ");

    LoadStrIntoAnsiBuf(hInstance, IDS_GLOSSSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szGlossFilterSpec, sz, "*.TXT");

    LoadStrIntoAnsiBuf(hInstance,
                       IDS_OPENTITLE,
                       szOpenDlgTitle,
                       sizeof(szOpenDlgTitle));
    LoadStrIntoAnsiBuf(hInstance,
                       IDS_SAVETITLE,
                       szSaveDlgTitle,
                       sizeof(szSaveDlgTitle));

    wc.style        = 0;
    wc.lpfnWndProc  = StatusWndProc;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = 0;
    wc.hInstance    = hInstance;
    wc.hIcon        = LoadIcon((HINSTANCE) NULL, IDI_APPLICATION);
    wc.hCursor      = LoadCursor((HINSTANCE) NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
    wc.lpszMenuName = NULL;
    wc.lpszClassName    = szStatusClass;

    if (! RegisterClass((CONST WNDCLASS *)&wc)) {
        return (FALSE);
    }

    wc.style        = 0;
    wc.lpfnWndProc  = MainWndProc;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = 0;
    wc.hInstance    = hInstance;
    wc.hIcon        = LoadIcon(hInstance, TEXT("RLEditIcon"));
    wc.hCursor      = LoadCursor((HINSTANCE) NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = TEXT("RLEdit");
    wc.lpszClassName    = szClassName;

    if (!RegisterClass((CONST WNDCLASS *)&wc)) {
        return (FALSE);
    }

    // Windows register return sucessfully
    return (TRUE);
}



/**
  *
  *
  *  Function: InitInstance
  * Creates the main, and status windows for the program.
  * The status window is sized according to the main window
  * size.  InitInstance also loads the acclerator table, and prepares
  * the global openfilename structure for later use.
  *
  *
  *  Errors Codes:
  * TRUE, windows created correctly.
  * FALSE, error on create windows calls.
  *
  *  History:
  * 9/11, Implemented       TerryRu
  *
  *
  **/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    RECT    Rect = { 0,0,0,0};

    hAccTable = LoadAccelerators(hInst, TEXT("RLEdit"));

    hMainWnd = CreateWindow(szClassName,
                            tszAppName,
                            WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            (HWND) NULL,
                            (HMENU) NULL,
                            hInstance,
                            (LPVOID) NULL);

    if (!hMainWnd) {                           // clean up after errors.
        return ( FALSE);
    }
    DragAcceptFiles(hMainWnd, TRUE);

    GetClientRect(hMainWnd, (LPRECT) &Rect);

    // Create a child list box window

    hListWnd = CreateWindow(TEXT("LISTBOX"),
                            NULL,
                            WS_CHILD |
                            LBS_WANTKEYBOARDINPUT |
                            LBS_NOTIFY | LBS_NOINTEGRALHEIGHT |
                            LBS_OWNERDRAWFIXED | WS_VSCROLL |
                            WS_HSCROLL | WS_BORDER,
                            0,
                            0,
                            (Rect.right-Rect.left),
                            (Rect.bottom-Rect.top),
                            hMainWnd,
                            (HMENU)IDC_LIST,       // Child control i.d.
                            hInstance,
                            NULL);

    if (!hListWnd) {                           // clean up after errors.
        DeleteObject((HGDIOBJ)hMainWnd);
        return ( FALSE);
    }
    // Creat a child status window

    hStatusWnd = CreateWindow(szStatusClass,
                              NULL,
                              WS_CHILD | WS_BORDER | WS_VISIBLE,
                              0, 0, 0, 0,
                              hMainWnd,
                              NULL,
                              hInstance,
                              NULL);

    if (! hStatusWnd) {                           // clean up after errors.
        DeleteObject((HGDIOBJ)hListWnd);
        DeleteObject((HGDIOBJ)hMainWnd);
        return ( FALSE);
    }
    hHourGlass = LoadCursor((HINSTANCE) NULL, IDC_WAIT);

    // Fill in non-variant fields of OPENFILENAMEA struct.
    ofn.lStructSize       = sizeof( OPENFILENAMEA);
    ofn.hwndOwner         = hMainWnd;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = szCustFilterSpec;
    ofn.nMaxCustFilter    = MAXCUSTFILTER;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFileName;
    ofn.nMaxFile          = sizeof( szFileName);
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrFileTitle    = szFileTitle;
    ofn.nMaxFileTitle     = sizeof( szFileTitle);
    ofn.lpstrTitle        = NULL;
    ofn.lpstrDefExt       = "PRJ";
    ofn.Flags             = 0;

    ShowWindow(hMainWnd, nCmdShow);
    UpdateWindow(hMainWnd);
    return ( TRUE);
}

/**
  *
  *
  *  Function: WinMain
  * Calls the intialization functions, to register, and create the
  * application windows. Once the windows are created, the program
  * enters the GetMessage loop.
  *
  *
  *  Arguements:
  * hInstace, handle for this instance
  * hPrevInstanc, handle for possible previous instances
  * lpszCmdLine, LONG pointer to exec command line.
  * nCmdShow,  code for main window display.
  *
  *
  *  Errors Codes:
  * IDS_ERR_REGISTER_CLASS, error on windows register
  * IDS_ERR_CREATE_WINDOW, error on create windows
  * otherwise, status of last command.
  *
  *  History:
  *
  *
  **/

INT WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR     lpszCmdLine,
                   int       nCmdShow)
{
    MSG  msg;
    HWND FirstWnd      = NULL;
    HWND FirstChildWnd = NULL;
    WORD wRC           = SUCCESS;


    bRLGui = TRUE;            //... used in rlcommon.lib

    if (FirstWnd = FindWindow(szClassName, NULL)) {  // checking for previous instance
        FirstChildWnd = GetLastActivePopup(FirstWnd);
        BringWindowToTop(FirstWnd);
        ShowWindow(FirstWnd, SW_SHOWNORMAL);

        if (FirstWnd != FirstChildWnd) {
            BringWindowToTop(FirstChildWnd);
        }
        return (FALSE);
    }

    hInst = hInstance;

    GetModuleFileNameA( hInst, szDHW, DHWSIZE);
    GetInternalName( szDHW, szAppName, sizeof( szAppName));
    szFileName[0] = '\0';
    lFilePointer[0] = (LONG)-1;

#ifdef UNICODE
    _MBSTOWCS( tszAppName,
               szAppName,
               WCHARSIN( sizeof( tszAppName)),
               ACHARSIN( strlen( szAppName) + 1));
#else
    strcpy( tszAppName, szAppName);
#endif

    // register window classes if first instance of application

    if ( ! hPrevInstance ) {
        if ( ! InitApplication( hInstance) ) {
            /* Registering one of the windows failed    */
            LoadString( hInst,
                        IDS_ERR_REGISTER_CLASS,
                        szString,
                        TCHARSIN( sizeof( szString)));
            MessageBox( NULL, szString, NULL, MB_ICONEXCLAMATION);
            return IDS_ERR_REGISTER_CLASS;
        }
    }

    // Create windows for this instance of application

    if ( ! InitInstance(hInstance, nCmdShow) ) {
        LoadString( hInst,
                    IDS_ERR_CREATE_WINDOW,
                    szString,
                    TCHARSIN( sizeof(szString)));
        MessageBox( NULL, szString, NULL, MB_ICONEXCLAMATION);
        return IDS_ERR_CREATE_WINDOW;
    }

    // Main Message Loop

    while ( GetMessage( &msg, NULL, 0, 0) ) {
        if ( hTokEditDlgWnd ) {
            if ( IsDialogMessage( hTokEditDlgWnd, &msg)) {
                continue;
            }
        }

        if ( TranslateAccelerator( hMainWnd, hAccTable, &msg) ) {
            continue;
        }

        TranslateMessage( (CONST MSG *)&msg);
        DispatchMessage( (CONST MSG *)&msg);
    }
    return (INT)msg.wParam;
}

/**
  *  Function: MainWndProc
  * Process the windows messages for the main window of the application.
  * All user inputs go through this window procedure.
  * See cases in the switch table for a description of each message type.
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  **/

INT_PTR APIENTRY MainWndProc( HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    // if it's a list box message process it in  DoListBoxCommand

    if ( fInThirdPartyEditer ) {  //... only process messages sent by the editor
        switch (wMsg) {
            case WM_EDITER_CLOSED:
                {
                    CHAR    szDlgToks[MAXFILENAME] = "";
                    static WORD wSavedIndex;
#ifdef RLWIN16
                    NotifyUnRegister( NULL);
                    FreeProcInstance( lpfnWatchTask);
#endif
                    ShowWindow(hWnd, SW_SHOW);

                    {
                        TCHAR tsz[80] = TEXT("");
                        LoadString( hInst,
                                    IDS_REBUILD_TOKENS,
                                    tsz,
                                    TCHARSIN( sizeof(tsz)));

                        if ( MessageBox( hWnd,
                                         tsz,
                                         tszAppName,
                                         MB_ICONQUESTION | MB_YESNO) == IDYES) {
                            HCURSOR hOldCursor;
                            BOOL bUpdated = FALSE;

                            hOldCursor = SetCursor(hHourGlass);

                            LoadCustResDescriptions(gMstr.szRdfs);

                            // szTempRes returned from resource editor
                            MyGetTempFileName(0, "TOK", 0, szDlgToks);
                            GenerateTokFile(szDlgToks, szTempRes, &bUpdated, 0);

                            InsDlgToks(gProj.szTok,
                                       szDlgToks,
                                       ID_RT_DIALOG);
                            remove(szDlgToks);
                            ClearResourceDescriptions();

                            // gProj.szTok, now contains the latest tokens
                            SetCursor(hOldCursor);

                            //Rledit doesn't save when changed tokens by Dialog Editor.
                            fTokChanges = TRUE;
                        }
                    }
                    fInThirdPartyEditer = FALSE;

                    remove(szTempRes);
                    // UNDONE - delete all temp files with the same root in case
                    // the editor created additional files like DLGs and RCs.
                    // (DLGEDIT does this.)
                    // For now I'm just going to tack a .DLG
                    // at the end of the file name
                    // and delete it.
                    {
                        int i;
                        for (i = strlen(szTempRes);
                            i > 0 && szTempRes[i]!='.'; i--) {
                        }

                        if (szTempRes[i] == '.') {
                            szTempRes[++i]='D';
                            szTempRes[++i]='L';
                            szTempRes[++i]='G';
                            szTempRes[++i]='\0';
                            remove(szTempRes);
                        }
                    }

                    wSavedIndex = (UINT)SendMessage( hListWnd,
                                                     LB_GETCURSEL,
                                                     (WPARAM)0,
                                                     (LPARAM)0);
                    SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
                    SendMessage( hListWnd,
                                 LB_SETCURSEL,
                                 (WPARAM)wSavedIndex,
                                 (LPARAM)0);
                }
                return ( DefWindowProc( hWnd, wMsg, wParam, lParam));
        }
    }


    // Not a third party edit command.

    DoListBoxCommand (hWnd, wMsg, wParam, lParam);

    switch (wMsg) {

        case WM_DROPFILES:
            {
                CHAR sz[MAXFILENAME] = "";

                DragQueryFileA( (HDROP) wParam, 0, sz, MAXFILENAME);

                if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0)) {
                    GetProjectData( sz, NULL, NULL, FALSE, FALSE);
                }
                DragFinish( (HDROP) wParam);
                return ( TRUE);
            }

        case WM_COMMAND:
            if (DoMenuCommand(hWnd, wMsg, wParam, lParam)) {
                return TRUE;
            }
            break;

        case WM_CLOSE:
            SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0);
            DestroyWindow(hMainWnd);
            DestroyWindow(hListWnd);
            DestroyWindow(hStatusWnd);
            _fcloseall();

            FreeLangList();

#ifdef _DEBUG
            {
                FILE *pLeakList = fopen( "C:\\LEAKLIST.TXT", "wt");
                FreeMemList( pLeakList);
                fclose( pLeakList);
            }
#endif // _DEBUG

            break;

        case WM_CREATE:
            {
                HDC hdc;
                int cyBorder;
                TEXTMETRIC tm;

                hdc  = GetDC (hWnd);
                GetTextMetrics(hdc, &tm);
                ReleaseDC(hWnd, hdc);


                cyBorder = GetSystemMetrics(SM_CYBORDER);

                cyChildHeight = tm.tmHeight + 6 + cyBorder * 2;
                break;
            }

        case WM_DESTROY:
            WinHelpA(hWnd, gszHelpFile, HELP_QUIT, (DWORD)0);
            // remove translation list
            if (pTransList) {
                // so we can find the end of the list
                pTransList->pPrev->pNext = NULL;
            }

            while (pTransList) {
                TRANSLIST *pTemp;

                pTemp = pTransList;
                pTransList = pTemp->pNext;
                RLFREE( pTemp->sz);
                RLFREE( pTemp);
            }
            PostQuitMessage(0);
            break;

        case WM_INITMENU:
            // Enable or Disable the Paste menu item
            // based on available Clipboard Text data
            if (wParam == (WPARAM) GetMenu(hMainWnd)) {
                if (OpenClipboard(hWnd)) {

#if defined(UNICODE)
                    if ((IsClipboardFormatAvailable(CF_UNICODETEXT)
                         || IsClipboardFormatAvailable(CF_OEMTEXT)) && fTokFile)
#else // not UNICODE
                    if ((IsClipboardFormatAvailable(CF_TEXT)
                         || IsClipboardFormatAvailable(CF_OEMTEXT)) && fTokFile)
#endif // UNICODE
                    {
                        EnableMenuItem((HMENU) wParam, IDM_E_PASTE, MF_ENABLED);
                    } else {
                        EnableMenuItem((HMENU)wParam, IDM_E_PASTE, MF_GRAYED);
                    }

                    CloseClipboard();
                    return (TRUE);
                }
            }
            break;

        case WM_QUERYENDSESSION:
            /* message: to end the session? */
            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                return TRUE;
            } else {
                return FALSE;
            }

        case WM_SETFOCUS:
            SetFocus (hListWnd);
            break;

        case WM_DRAWITEM:
            DrawLBItem((LPDRAWITEMSTRUCT) lParam);
            break;

        case WM_DELETEITEM:
            {
                HGLOBAL   hTokData;
                LPTOKDATA lpTokData;

                hTokData = ((HGLOBAL)((LPDELETEITEMSTRUCT)lParam)->itemData);

                if ( hTokData ) {
                    lpTokData = (LPTOKDATA)GlobalLock( hTokData );
                    GlobalFree( lpTokData->hToken );
                    GlobalUnlock( hTokData );
                    GlobalFree( hTokData );
                }
            }
            break;

        case WM_SIZE:
            {
                int cxWidth;
                int cyHeight;
                int xChild;
                int yChild;

                cxWidth  = LOWORD(lParam);
                cyHeight = HIWORD(lParam);

                xChild = 0;
                yChild = cyHeight - cyChildHeight + 1;

                MoveWindow(hListWnd, 0, 0, cxWidth, yChild, TRUE);
                MoveWindow(hStatusWnd, xChild, yChild, cxWidth, cyChildHeight, TRUE);
                break;
            }

        case WM_READMPJDATA:
            {
                OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

                if ( OpenFile( gProj.szMpj, &Of, OF_EXIST) == HFILE_ERROR ) {
                    // file doesn't exist
                    LoadStrIntoAnsiBuf( hInst, IDS_MPJERR, szDHW, DHWSIZE);
                    MessageBoxA( hWnd,
                                 gProj.szMpj,
                                 szDHW,
                                 MB_ICONSTOP | MB_OK);
                } else if ( GetMasterProjectData( gProj.szMpj,
                                                  NULL,
                                                  NULL,
                                                  FALSE) == SUCCESS ) {
                    OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

                    gProj.fSourceEXE = IsExe( gMstr.szSrc);
                    gProj.fTargetEXE = (!IsRes( gProj.szBld));

                    if ( gProj.fTargetEXE  && !gProj.fSourceEXE ) {
                        int i = lstrlenA( gProj.szBld) - 3;

                        LoadStrIntoAnsiBuf( hInst,
                                            IDS_RLE_CANTSAVEASEXE,
                                            szDHW,
                                            DHWSIZE);

                        lstrcpyA( gProj.szBld+i, "RES");
                        MessageBoxA( hWnd,
                                     szDHW,
                                     gProj.szBld,
                                     MB_ICONHAND|MB_OK);
                        gProj.fTargetEXE = FALSE;
                    }

                    SzDateFromFileName( szDHW, gMstr.szSrc);
                    fMPJOutOfDate = FALSE;

                    if ( OpenFile( gProj.szTok, &Of, OF_EXIST) == HFILE_ERROR ) {

                        // file doesn't exist, create it
                        Update( gMstr.szMtk, gProj.szTok);

                        lstrcpyA( gProj.szTokDate,
                                  gMstr.szMpjLastRealUpdate);
                        fPrjChanges   = TRUE;
                        fPRJOutOfDate = FALSE;
                    } else {
                        if ( lstrcmpA( gMstr.szMpjLastRealUpdate,
                                       gProj.szTokDate) ) {
                            HCURSOR hOldCursor;

                            fPRJOutOfDate = TRUE;
                            hOldCursor    = SetCursor( hHourGlass);
                            Update( gMstr.szMtk, gProj.szTok);
                            SetCursor( hOldCursor);
                            lstrcpyA( gProj.szTokDate,
                                      gMstr.szMpjLastRealUpdate);
                            fPrjChanges   = TRUE;
                            fPRJOutOfDate = FALSE;
                        } else {
                            fPRJOutOfDate = FALSE;
                        }
                    }

                    // New code to do auto-translate

                    SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);

                    if ( gProj.szGlo[0]               // file name given exists?
                         && OpenFile( gProj.szGlo, &Of, OF_EXIST) != HFILE_ERROR ) {                                 // Yes
                        HCURSOR hOldCursor = SetCursor( hHourGlass);

                        MakeGlossIndex( lFilePointer);
                        SetCursor( hOldCursor);
                    }
                }       //... END case WM_READMPJDATA
            }           //... END switch (wMsg)
            break;

        case WM_LOADTOKENS:
            {
                HMENU hMenu = NULL;
                FILE *f     = NULL;

                // Remove the current token list
                SendMessage( hListWnd, LB_RESETCONTENT, (LPARAM)0, (LPARAM)0);
                CleanDeltaList();

                // Hide token list, while we add new tokens
                ShowWindow(hListWnd, SW_HIDE);

                if (f = FOPEN(gProj.szTok, "rt")) {
                    HCURSOR hOldCursor;

                    hOldCursor = SetCursor(hHourGlass);

                    // Insert tokens from token file into the list box
                    {
                        FILE    *fm;

                        if ( !(fm = fopen((CHAR *)gMstr.szMtk,"rt")) )
                            return TRUE;
                        pTokenDeltaInfo = InsertTokMtkList(f, fm );
                        FCLOSE( fm );
                    }
                    FCLOSE(f);

                    // Make list box visible
                    ShowWindow(hListWnd, SW_SHOW);

                    hMenu=GetMenu(hWnd);
                    EnableMenuItem(hMenu, IDM_P_CLOSE,     MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_VIEW,      MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_EDIT,      MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_SAVE,      MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FIND,      MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDUP,    MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDDOWN,  MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_REVIEW,    MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_ALLREVIEW, MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_COPY,      MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_COPYTOKEN, MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_PASTE,     MF_ENABLED|MF_BYCOMMAND);

                    if ((!fMPJOutOfDate) && (!fPRJOutOfDate)) {
                        int i;
                        EnableMenuItem(hMenu, IDM_O_GENERATE, MF_ENABLED|MF_BYCOMMAND);

                        for (i = IDM_FIRST_EDIT; i <= IDM_LAST_EDIT;i++) {
                            EnableMenuItem(hMenu, i, MF_ENABLED|MF_BYCOMMAND);
                        }
                    }
                    fTokFile = TRUE;
                    fTokChanges = FALSE;

                    SetCursor(hOldCursor);
                }
                return TRUE;
            }
            break;

        case WM_SAVEPROJECT:
            {
                HCURSOR hOldCursor;

                hOldCursor = SetCursor( hHourGlass);

                _fcloseall();

                if ( fPrjChanges ) {
                    // Generate PRJ file

                    if ( PutProjectData( gProj.szPRJ) != SUCCESS ) {
                        SetCursor( hOldCursor);
                        LoadStrIntoAnsiBuf (hInst, IDS_FILESAVEERR, szDHW, DHWSIZE);
                        MessageBoxA( hWnd,szDHW, gProj.szPRJ, MB_ICONHAND | MB_OK);
                        return FALSE;
                    }
                    fPrjChanges = FALSE;
                }

                fTokFile = FALSE;

                if (fTokChanges) {
                    FILE *f = FOPEN( gProj.szTok, "wt");

                    if ( f ) {
                        SaveTokList(hWnd, f);
                        FCLOSE(f);
                        fTokChanges = FALSE;
                    } else {
                        SetCursor( hOldCursor);
                        LoadStrIntoAnsiBuf(hInst, IDS_FILESAVEERR, szDHW, DHWSIZE);
                        MessageBoxA( hWnd,
                                     szDHW,
                                     gProj.szTok,
                                     MB_ICONHAND | MB_OK);
                        return FALSE;
                    }
                }
                SetCursor( hOldCursor);
                return TRUE; // everything saved ok
            }

        default:
            break;
    }
    return ( DefWindowProc(hWnd, wMsg, wParam, lParam));
}



static void GetTextFromMTK( HWND hWnd, TOKEN *pTok, long lMtkPointer )
{
    FILE *fp = FOPEN( gMstr.szMtk, "rt");

    if ( fp ) {
        TOKEN   cTok, ccTok;
        BOOL    fFound;

        pTok->wReserved = 0;

        if ( lMtkPointer >= 0 ) {
            fseek( fp, lMtkPointer, SEEK_SET);

            if ( !GetToken(fp,&cTok) ) {
                fFound = ((cTok.wType == pTok->wType)
                          && (cTok.wName == pTok->wName)
                          && (cTok.wID   == pTok->wID)
                          && (cTok.wFlag == pTok->wFlag)
                          && (lstrcmp((TCHAR *)cTok.szName,
                                      (TCHAR *)pTok->szName) == 0));

                if ( fFound ) {
                    // any changed old token
                    SetDlgItemText( hWnd,
                                    IDD_TOKCURTEXT,
                                    (LPTSTR)cTok.szText);

                    if ( ! GetToken( fp,&ccTok) ) {
                        fFound = ((cTok.wType == ccTok.wType)
                                  && (cTok.wName == ccTok.wName)
                                  && (cTok.wID   == ccTok.wID)
                                  && (cTok.wFlag == ccTok.wFlag)
                                  && (lstrcmp((TCHAR *)cTok.szName,
                                              (TCHAR *)ccTok.szName) == 0)
                                  && (cTok.wReserved & ST_CHANGED) );

                        if ( fFound ) {
                            SetDlgItemText( hWnd, IDD_TOKPREVTEXT, (LPTSTR)ccTok.szText);
                        } else {
                            // should this ever happen??
                            SetDlgItemText( hWnd, IDD_TOKPREVTEXT, (LPTSTR)TEXT(""));
                        }
                    } else {
                        // should this ever happen??
                        SetDlgItemText( hWnd, IDD_TOKPREVTEXT, (LPTSTR)TEXT(""));
                    }
                    FCLOSE( fp);
                    return;
                }
            }
        }

        pTok->wReserved = 0;

        if (FindToken(fp, pTok, 0)) {
            // any changed old token
            SetDlgItemText(hWnd, IDD_TOKCURTEXT, (LPTSTR)pTok->szText);
        } else {
            SetDlgItemText(hWnd, IDD_TOKCURTEXT, (LPTSTR)TEXT(""));
        }

        pTok->wReserved = ST_CHANGED;

        if (FindToken(fp, pTok, ST_CHANGED)) { // any old token
            SetDlgItemText(hWnd, IDD_TOKPREVTEXT, (LPTSTR)pTok->szText);
        } else {
            // should this ever happen??
            SetDlgItemText(hWnd, IDD_TOKPREVTEXT, (LPTSTR)TEXT(""));
        }
        FCLOSE(fp);
    }
}






/**
  *  Function: DoListBoxCommand
  * Processes the messages sent to the list box. If the message is
  * not reconized as a list box message, it is ignored and not processed.
  * As the user scrolls through the tokens WM_UPDSTATLINE messages are
  * sent to the status window to indicate the current selected token.
  * The list box goes into Edit Mode by  pressing the enter key, or
  * by double clicking on the list box.  After the edit is done, a WM_TOKEDIT
  * message is sent back to the list box to update the token. The
  * list box uses control ID IDC_LIST.
  *
  *  Arguments:
  * wMsg    List Box message ID
  * wParam  Either IDC_LIST, or VK_RETURN depending on wMsg
  * lParam  LPTSTR to selected token during WM_TOKEDIT message.
  *
  *  Returns:
  *
  *  Errors Codes:
  * TRUE.  Message processed.
  * FALSE. Message not processed.
  *
  *  History:
  * 01/92 Implemented.      TerryRu.
  * 01/92 Fixed problem with DblClick, and Enter processing.    TerryRu.
  *
  **/

INT_PTR DoListBoxCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    TOKEN tok;       // structure to hold token read from token list
    TCHAR szName[32] = TEXT("");          // buffer to hold token name
    CHAR  szTmpBuf[32] = "";      // buffer to hold token name
    TCHAR szID[7] = TEXT("");   // buffer to hold token id
    TCHAR sz[256] = TEXT("");   // buffer to hold messages
    static UINT wIndex;
    LONG lListParam = 0L;
    HWND    hCtl = NULL;
    HGLOBAL hMem = NULL;
    LPTSTR  lpstrToken = NULL;
    LPTOKDATA lpTokData;
    LONG      lMtkPointer;

    // this is the WM_COMMAND

    switch (wMsg) {
        case WM_VIEW:
            {
                TCHAR *szBuffer;

                // Message sent by TOkEdigDlgProc to fill IDD_TOKCURTEXT
                // and IDD_TOKPREVTEXT fields in dialog box

                hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             (WPARAM)wIndex,
                                             (LPARAM)0);

                lpTokData = (LPTOKDATA)GlobalLock( hMem );
                lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );
                lMtkPointer = lpTokData->lMtkPointer;

                szBuffer = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
                lstrcpy( szBuffer, lpstrToken);

                GlobalUnlock( lpTokData->hToken );

                GlobalUnlock( hMem);
                ParseBufToTok( szBuffer, &tok);
                RLFREE( szBuffer);
                GetTextFromMTK(hTokEditDlgWnd, &tok, lMtkPointer );

                RLFREE( tok.szText);

                return TRUE;
            }

        case WM_TRANSLATE:
            {
                // Message sent by TokEditDlgProc to build a translation list

                HWND hDlgItem = NULL;
                int cTextLen  = 0;
                TCHAR *szKey  = NULL;
                TCHAR *szText = NULL;


                hDlgItem = GetDlgItem( hTokEditDlgWnd, IDD_TOKCURTEXT);
                cTextLen = GetWindowTextLength( hDlgItem);
                szKey = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
                szKey[0] = 0;
                GetDlgItemText( hTokEditDlgWnd,
                                IDD_TOKCURTEXT,
                                szKey,
                                cTextLen + 1);

                hDlgItem = GetDlgItem( hTokEditDlgWnd, IDD_TOKCURTRANS);
                cTextLen = GetWindowTextLength( hDlgItem);
                szText = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
                *szText = 0;
                GetDlgItemText( hTokEditDlgWnd,
                                IDD_TOKCURTRANS,
                                szText,
                                cTextLen + 1);
                TransString( szKey, szText, &pTransList, lFilePointer);
                RLFREE( szKey);
                RLFREE( szText);

                break;
            }

        case WM_TOKEDIT:
            {
                TCHAR *szBuffer;
                int cTextLen;

                // Message sent by TokEditDlgProc to
                // indicate change in the token text.
                // Response to the message by inserting
                // new token text into list box

                // Insert the selected token into token struct
                hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             (WPARAM)wIndex,
                                             (LPARAM)0);

                lpTokData = (LPTOKDATA)GlobalLock( hMem );
                lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );

                cTextLen = lstrlen( lpstrToken);
                szBuffer = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
                lstrcpy( szBuffer, lpstrToken);

                lMtkPointer = lpTokData->lMtkPointer;
                GlobalUnlock( lpTokData->hToken );

                GlobalUnlock( hMem);
                ParseBufToTok( szBuffer, &tok);
                RLFREE( szBuffer);
                RLFREE( tok.szText);

                // Copy new token text from edit box into the token struct
                cTextLen = lstrlen( (LPTSTR)lParam);
                tok.szText = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
                lstrcpy( tok.szText, (LPTSTR)lParam);

                // Mark token as clean
#ifdef  RLWIN32
                tok.wReserved = (WORD) ST_TRANSLATED | (WORD) wParam;
#else
                tok.wReserved = ST_TRANSLATED | (WORD) wParam;
#endif

                // should we clean up the delta token information??
                szBuffer = (TCHAR *)FALLOC( MEMSIZE( TokenToTextSize( &tok)));
                ParseTokToBuf( szBuffer, &tok);
                RLFREE( tok.szText);

                // Now remove old token
                SendMessage( hListWnd, WM_SETREDRAW,    (WPARAM)FALSE,  (LPARAM)0);
                SendMessage( hListWnd, LB_DELETESTRING, (WPARAM)wIndex, (LPARAM)0);

                // Replacing with the new token

                hMem = GlobalAlloc( GMEM_MOVEABLE, sizeof(TOKDATA) );
                lpTokData = (LPTOKDATA)GlobalLock( hMem );
                lpTokData->hToken = GlobalAlloc(GMEM_MOVEABLE,
                                                MEMSIZE(lstrlen((TCHAR *)szBuffer)+1));
                lpstrToken = (LPTSTR) GlobalLock( lpTokData->hToken );
                lstrcpy((TCHAR *)lpstrToken, (TCHAR *)szBuffer);
                GlobalUnlock( lpTokData->hToken );
                lpTokData->lMtkPointer = lMtkPointer;            //MtkPointer

                GlobalUnlock( hMem);
                RLFREE( szBuffer);

                SendMessage( hListWnd,
                             LB_INSERTSTRING,
                             (WPARAM)wIndex,
                             (LPARAM)hMem);

                // Now put focus back on the current string
                SendMessage( hListWnd, LB_SETCURSEL, (WPARAM)wIndex, (LPARAM)0);
                SendMessage( hListWnd, WM_SETREDRAW, (WPARAM)TRUE,   (LPARAM)0);
                InvalidateRect(hListWnd, NULL, TRUE);

                return TRUE;
            }

        case WM_CHARTOITEM:
        case WM_VKEYTOITEM:
            {
#ifdef RLWIN16
                LONG lListParam = 0;
#endif
                // Messages sent to list box when  keys are depressed.
                // Check for Return key pressed.

                switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                    case VK_RETURN:
#ifdef RLWIN16
                        lListParam = (LONG) MAKELONG(NULL,  LBN_DBLCLK);
                        SendMessage(hMainWnd, WM_COMMAND, IDC_LIST, lListParam);
#else
                        SendMessage( hMainWnd,
                                     WM_COMMAND,
                                     MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                     (LPARAM)0);
#endif

                        return TRUE;

                    default:
                        break;
                }
                break;
            }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDC_LIST:
                    {
                        /*
                         *
                         * This is where we process the list box messages.
                         * The TokEditDlgProc is used to
                         * edit the token selected in LBS_DBLCLK message
                         *
                         */
                        switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                            case (UINT) LBN_ERRSPACE:
                                LoadString( hInst,
                                            IDS_ERR_NO_MEMORY,
                                            sz,
                                            TCHARSIN( sizeof( sz)));
                                MessageBox( hWnd,
                                            sz,
                                            tszAppName,
                                            MB_ICONHAND | MB_OK);
                                return TRUE;

                            case LBN_DBLCLK:
                                {
                                    LPTSTR CurText = NULL;
                                    LPTSTR PreText = NULL;
                                    TCHAR szResIDStr[20] = TEXT("");
                                    TCHAR *szBuffer;

                                    wIndex = (UINT)SendMessage( hListWnd,
                                                                LB_GETCURSEL,
                                                                (WPARAM)0,
                                                                (LPARAM)0);
                                    if (wIndex == (UINT) -1) {
                                        return TRUE;
                                    }

                                    // double click, or Return entered,
                                    // go into token edit mode.
                                    if (!hTokEditDlgWnd) {
                                        // set up modaless dialog box to edit token
#ifdef RLWIN32
                                        hTokEditDlgWnd = CreateDialog(hInst,
                                                                      TEXT("RLEdit"),
                                                                      hWnd,
                                                                      TokEditDlgProc);
#else
                                        //lpTokEditDlg =
                                        //(DLGPROC) MakeProcInstance(TokEditDlgProc,
                                        //                           hInst);
                                        //hTokEditDlgWnd = CreateDialog(hInst,
                                        //                              TEXT("RLEdit"),
                                        //                              hWnd,
                                        //                              lpTokEditDlg);
                                        hTokEditDlgWnd = CreateDialog(hInst,
                                                                      TEXT("RLEdit"),
                                                                      hWnd,
                                                                      TokEditDlgProc);
#endif
                                    }

                                    // Get token info from listbox, and place in token struct
                                    hMem = (HGLOBAL)SendMessage( hListWnd,
                                                                 LB_GETITEMDATA,
                                                                 (WPARAM)wIndex,
                                                                 (LPARAM)0);

                                    lpTokData = (LPTOKDATA)GlobalLock( hMem );
                                    lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );
                                    lMtkPointer = lpTokData->lMtkPointer;

                                    szBuffer = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
                                    lstrcpy( szBuffer, lpstrToken);

                                    GlobalUnlock( lpTokData->hToken );

                                    GlobalUnlock( hMem);
                                    ParseBufToTok(szBuffer, &tok);
                                    RLFREE( szBuffer);

                                    // Now get the token name
                                    // Its either a string, or ordinal number
                                    if (tok.szName[0]) {
                                        lstrcpy( szName, tok.szName);
                                    } else {
#ifdef UNICODE
                                        _itoa(tok.wName, szTmpBuf, 10);
                                        _MBSTOWCS( szName,
                                                   szTmpBuf,
                                                   WCHARSIN( sizeof( szName)),
                                                   ACHARSIN( strlen(szTmpBuf) + 1));
#else

                                        _itoa(tok.wName, szName, 10);
#endif
                                    }
                                    // Now get the token id
#ifdef UNICODE
                                    _itoa(tok.wID, szTmpBuf, 10);
                                    _MBSTOWCS( szID,
                                               szTmpBuf,
                                               WCHARSIN( sizeof( szID)),
                                               ACHARSIN( strlen(szTmpBuf) + 1));
#else
                                    _itoa(tok.wID, szID, 10);
#endif

                                    if ( tok.wType <= 16 || tok.wType == ID_RT_DLGINIT ) {
                                        LoadString(hInst,
                                                   IDS_RESOURCENAMES+tok.wType,
                                                   szResIDStr,
                                                   TCHARSIN( sizeof( szResIDStr)));
                                    } else {
#ifdef UNICODE
                                        _itoa(tok.wType, szTmpBuf, 10);
                                        _MBSTOWCS(szResIDStr,
                                                  szTmpBuf,
                                                  WCHARSIN( sizeof( szResIDStr)),
                                                  ACHARSIN( strlen(szTmpBuf) + 1));
#else
                                        _itoa(tok.wType, szResIDStr, 10);
#endif
                                    }

                                    // Now insert token info  in TokEdit Dialog Box
                                    SetDlgItemText(hTokEditDlgWnd,
                                                   IDD_TOKTYPE,
                                                   (LPTSTR) szResIDStr);
                                    SetDlgItemText(hTokEditDlgWnd,
                                                   IDD_TOKNAME,
                                                   (LPTSTR) szName);
                                    SetDlgItemText(hTokEditDlgWnd,
                                                   IDD_TOKID,
                                                   (LPTSTR) szID);
                                    SetDlgItemText(hTokEditDlgWnd,
                                                   IDD_TOKCURTRANS,
                                                   (LPTSTR) tok.szText);
                                    SetDlgItemText(hTokEditDlgWnd,
                                                   IDD_TOKPREVTRANS,
                                                   (LPTSTR) tok.szText);
                                    CheckDlgButton(hTokEditDlgWnd, IDD_DIRTY, 0);

                                    if (tok.wReserved & ST_READONLY) {
                                        CheckDlgButton(hTokEditDlgWnd, IDD_READONLY, 1);
                                        EnableWindow(GetDlgItem(hTokEditDlgWnd,
                                                                IDD_TOKCURTRANS),
                                                     FALSE);
                                        SetFocus(GetDlgItem(hTokEditDlgWnd, IDCANCEL));
                                    } else {
                                        CheckDlgButton(hTokEditDlgWnd, IDD_READONLY, 0);
                                        EnableWindow(GetDlgItem(hTokEditDlgWnd,
                                                                IDD_TOKCURTRANS),
                                                     TRUE);
                                    }

                                    // we did not find anything in the delta info,
                                    // so we need to read it from the master token.

                                    GetTextFromMTK(hTokEditDlgWnd, &tok, lMtkPointer );

                                    RLFREE( tok.szText);

                                    // Disable OK button.
                                    // User must enter text before it is enabled

                                    hCtl = GetDlgItem(hTokEditDlgWnd, IDOK);

                                    SendMessage( hMainWnd,
                                                 WM_TRANSLATE,
                                                 (LPARAM)0,
                                                 (LPARAM)0);
                                    EnableWindow(hCtl, FALSE);
                                    SetActiveWindow(hTokEditDlgWnd);
                                    wIndex = (UINT)SendMessage( hListWnd,
                                                                LB_GETCURSEL,
                                                                (WPARAM)0,
                                                                (LPARAM)0);
                                    return TRUE;
                                }

                                // let these messages fall through,
                            default:
                                break;
                        }
                    }
                default:
                    return FALSE;
            }

            break; // WM_COMMAND Case
    } // Main List Box Switch
    return FALSE;
}

/**
  *  Function: DoMenuCommand.
  * Processes the Menu Command messages.
  *
  *  Errors Codes:
  * TRUE. Message processed.
  * FALSE. Message not processed.
  *
  *  History:
  * 01/92. Implemented.       TerryRu.
  *
  **/

INT_PTR DoMenuCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fListBox = FALSE;
    TCHAR sz[256]=TEXT("");
#ifndef RLWIN32
    WNDPROC lpNewDlg, lpViewDlg;
#endif
    int rc;
    LPTOKDATA    lpTokData;
    long         lMtkPointer;

    // Commands entered from the application menu, or child windows.
    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDM_P_NEW:

            fEditing = FALSE;       //... We are *not* editing an existing .PRJ

            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                CHAR szFile[MAXFILENAME] = "";


                if ( GetFileNameFromBrowse( hWnd,
                                            gProj.szPRJ,
                                            MAXFILENAME,
                                            szSaveDlgTitle,
                                            szFilterSpec,
                                            "PRJ")) {
                    strcpy( szFile, gProj.szPRJ);
                } else {
                    break; // user cancelled
                }
#ifdef RLWIN32
                if ( DialogBox( hInst, TEXT("PROJECT"), hWnd, NewDlgProc) == IDOK )
#else
                //lpNewDlg = MakeProcInstance(NewDlgProc, hInst);
                //
                //if ( DialogBox( hInst, TEXT("PROJECT"), hWnd, lpNewDlg) == IDOK )
                if ( DialogBox( hInst, TEXT("PROJECT"), hWnd, NewDlgProc) == IDOK )
#endif
                {
                    sprintf( szDHW, "%s - %s", szAppName, szFile);
                    SetWindowTextA( hWnd, szDHW);
                    gbNewProject = TRUE;
                    gProj.szTokDate[0] = 0;
                    strcpy( gProj.szPRJ, szFile);
                    fPrjChanges = TRUE;
                    SendMessage( hWnd, WM_READMPJDATA, (WPARAM)0, (LPARAM)0);
                }

                gbNewProject = FALSE;
#ifndef RLWIN32
                //FreeProcInstance(lpNewDlg);
#endif
                break;
            }

        case IDM_P_EDIT:

            fEditing = TRUE;        //... We *are* editing an existing .PRJ

            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                CHAR szOldMpj[ MAXFILENAME];

                // Save old Master Project name
                lstrcpyA( szOldMpj, gProj.szMpj);

#ifdef RLWIN32
                if ( DialogBox( hInst, TEXT("PROJECT"), hWnd, NewDlgProc) == IDOK )
#else
                //lpNewDlg = MakeProcInstance(NewDlgProc, hInst);
                //
                //if ( DialogBox( hInst, TEXT("PROJECT"), hWnd, lpNewDlg) == IDOK )
                if ( DialogBox( hInst, TEXT("PROJECT"), hWnd, NewDlgProc) == IDOK )
#endif
                {
                    fPrjChanges = TRUE;

                    // Still same Master Project referenced?

                    if ( lstrcmpiA( szOldMpj, gProj.szMpj) != 0 ) {
                        gbNewProject = TRUE;        // No
                        gProj.szTokDate[0] = 0;
                        SendMessage( hWnd, WM_READMPJDATA, (WPARAM)0, (LPARAM)0);
                    }
                }
                gbNewProject = FALSE;

#ifndef RLWIN32
                //FreeProcInstance(lpNewDlg);
#endif
                break;
            }

        case IDM_P_OPEN:

            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                szTempFileName[0] = 0;

                if ( GetFileNameFromBrowse( hWnd,
                                            szTempFileName,
                                            MAXFILENAME,
                                            szOpenDlgTitle,
                                            szFilterSpec,
                                            "PRJ") ) {
                    if ( GetProjectData( szTempFileName,
                                         NULL,
                                         NULL,
                                         FALSE,
                                         FALSE) == SUCCESS ) {
                        SendMessage( hWnd, WM_READMPJDATA, (WPARAM)0, (LPARAM)0);
                        sprintf( szDHW, "%s - %s", szAppName, szTempFileName);
                        SetWindowTextA( hMainWnd, szDHW);
                        strcpy( gProj.szPRJ, szTempFileName);

                        SendMessage( hMainWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
                    }
                }
            }
            break;

        case IDM_P_VIEW:

#ifdef RLWIN32
            DialogBox(hInst, TEXT("VIEWPROJECT"), hWnd, ViewDlgProc);
#else
            //lpViewDlg = (WNDPROC) MakeProcInstance((WNDPROC)ViewDlgProc, hInst);
            //DialogBox(hInst, TEXT("VIEWPROJECT"), hWnd, lpViewDlg);
            DialogBox(hInst, TEXT("VIEWPROJECT"), hWnd, ViewDlgProc);
#endif
            break;

        case IDM_P_CLOSE:
            {
                HMENU hMenu;

                hMenu=GetMenu(hWnd);
                if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                    int i;

                    // Remove file name from window title
                    SetWindowTextA(hMainWnd, szAppName);

                    // Hide token list since it's going to be empty
                    ShowWindow(hListWnd, SW_HIDE);

                    // Remove the current token list
                    SendMessage( hListWnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

                    CleanDeltaList();

                    // Force Repaint of status Window
                    InvalidateRect(hStatusWnd, NULL, TRUE);

                    EnableMenuItem(hMenu, IDM_P_CLOSE,     MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_VIEW,      MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_EDIT,      MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_SAVE,      MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FIND,      MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDUP,    MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDDOWN,  MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_REVIEW,    MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_ALLREVIEW, MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_COPY,      MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_COPYTOKEN, MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_PASTE,     MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_O_GENERATE,  MF_GRAYED|MF_BYCOMMAND);

                    for (i = IDM_FIRST_EDIT; i <= IDM_LAST_EDIT;i++) {
                        EnableMenuItem(hMenu, i, MF_GRAYED|MF_BYCOMMAND);
                    }
                }
                break;
            }


        case IDM_P_SAVE:

            if (fTokChanges || fPrjChanges) {
                CHAR szPrjName[MAXFILENAME];

                strcpy(szPrjName, gProj.szPRJ);

                if ( SendMessage(hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                    GetProjectData( szPrjName, NULL, NULL, FALSE, FALSE);
                }
            } else {
                LoadString( hInst,
                            IDS_NOCHANGESYET,
                            sz,
                            TCHARSIN( sizeof( sz)));
                MessageBox( hWnd,
                            sz,
                            tszAppName,
                            MB_ICONHAND | MB_OK);
            }
            break;


        case IDM_P_EXIT:
            SendMessage( hWnd,     WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0);
            PostMessage( hMainWnd, WM_CLOSE,       (WPARAM)0, (LPARAM)0);
            break;

        case IDM_E_COPYTOKEN:
            {
                HANDLE  hStringMem;
                LPTSTR  lpString;
                int     nIndex = 0;
                int     nLength = 0;
                LPTSTR  lpstrToken;

                // Is anything selected in the listbox
                if ( (nIndex = (int)SendMessage( hListWnd,
                                                 LB_GETCURSEL,
                                                 (WPARAM)0,
                                                 (LPARAM)0)) != LB_ERR ) {
                    HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                         LB_GETITEMDATA,
                                                         (WPARAM)nIndex,
                                                         (LPARAM)0);

                    lpTokData = (LPTOKDATA)GlobalLock( hMem );
                    lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );
                    nLength = lstrlen(lpstrToken);
                    // Allocate memory for the string
                    if ( (hStringMem = GlobalAlloc(GHND,
                                                   (DWORD) MEMSIZE(nLength + 1))) != NULL ) {
                        if ( (lpString = (LPTSTR)GlobalLock(hStringMem)) != NULL ) {
                            // Get the selected text
                            lstrcpy( lpString, lpstrToken);

                            GlobalUnlock( lpTokData->hToken );

                            GlobalUnlock( hMem);
                            // Unlock the block
                            GlobalUnlock( hStringMem);

                            // Open the Clipboard and clear its contents
                            OpenClipboard( hWnd);
                            EmptyClipboard();

                            // Give the Clipboard the text data

#if defined(UNICODE)
                            SetClipboardData( CF_UNICODETEXT, hStringMem);
#else // not UNICODE
                            SetClipboardData( CF_TEXT, hStringMem);
#endif // UNICODE
                            CloseClipboard();

                            hStringMem = NULL;
                        } else {
                            GlobalUnlock( lpTokData->hToken );
                            GlobalUnlock( hMem);
                            LoadString( hInst,
                                        IDS_ERR_NO_MEMORY,
                                        sz,
                                        TCHARSIN( sizeof( sz)));
                            MessageBox( hWnd,
                                        sz,
                                        tszAppName,
                                        MB_ICONHAND | MB_OK);
                        }
                    } else {
                        GlobalUnlock( lpTokData->hToken );
                        GlobalUnlock( hMem);
                        LoadString( hInst,
                                    IDS_ERR_NO_MEMORY,
                                    sz,
                                    TCHARSIN( sizeof(sz)));
                        MessageBox( hWnd,
                                    sz,
                                    tszAppName,
                                    MB_ICONHAND | MB_OK);
                    }
                }
                break;
            }

        case IDM_E_COPY:
            {
                HANDLE  hStringMem;
                LPTSTR  lpString;
                int     nIndex = 0;
                int     nLength = 0;
                int     nActual = 0;
                TOKEN   tok;
                LPTSTR  lpstrToken;

                // Is anything selected in the listbox
                if ( (nIndex = (int)SendMessage( hListWnd,
                                                 LB_GETCURSEL,
                                                 (WPARAM)0,
                                                 (LPARAM)0)) != LB_ERR ) {
                    HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                         LB_GETITEMDATA,
                                                         (WPARAM)nIndex,
                                                         (LPARAM)0);

                    lpTokData = (LPTOKDATA)GlobalLock( hMem );
                    lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );
                    lstrcpy( szString, lpstrToken);

                    GlobalUnlock( lpTokData->hToken );
                    GlobalUnlock( hMem);
                    ParseBufToTok( szString, &tok);
                    nLength = lstrlen( tok.szText);

                    // Allocate memory for the string
                    if ( (hStringMem =
                          GlobalAlloc( GHND, (DWORD)MEMSIZE( nLength + 1))) != NULL ) {
                        if ( (lpString =
                              (LPTSTR)GlobalLock( hStringMem)) != NULL) {
                            // Get the selected text
#ifdef RLWIN32
                            lstrcpy( lpString, tok.szText);
#else
                            _fstrcpy( lpString, tok.szText);
#endif

                            // Unlock the block
                            GlobalUnlock(hStringMem);

                            // Open the Clipboard and clear its contents
                            OpenClipboard( hWnd);
                            EmptyClipboard();

                            // Give the Clipboard the text data

#if defined(UNICODE)
                            SetClipboardData(CF_UNICODETEXT, hStringMem);
#else // not UNICODE
                            SetClipboardData( CF_TEXT, hStringMem);
#endif // UNICODE
                            CloseClipboard();

                            hStringMem = NULL;
                        } else {
                            LoadString( hInst,
                                        IDS_ERR_NO_MEMORY,
                                        sz,
                                        TCHARSIN( sizeof( sz)));
                            MessageBox( hWnd,
                                        sz,
                                        tszAppName,
                                        MB_ICONHAND | MB_OK);
                        }
                    } else {
                        LoadString( hInst,
                                    IDS_ERR_NO_MEMORY,
                                    sz,
                                    TCHARSIN( sizeof( sz)));
                        MessageBox( hWnd,
                                    sz,
                                    tszAppName,
                                    MB_ICONHAND | MB_OK);
                    }
                    RLFREE( tok.szText);
                }
                break;
            }

        case IDM_E_PASTE:
            {
                HANDLE  hClipMem = NULL;
                LPTSTR  lpClipMem = NULL;
                HGLOBAL hMem = NULL;
                TCHAR *szString;
                int nIndex = 0;
                TOKEN   tok;
                LPTSTR lpstrToken;

                if ( OpenClipboard( hWnd) ) {

#if defined(UNICODE)
                    if (IsClipboardFormatAvailable(CF_UNICODETEXT)
                        || IsClipboardFormatAvailable(CF_OEMTEXT))
#else // not UNICODE
                    if ( IsClipboardFormatAvailable( CF_TEXT)
                         || IsClipboardFormatAvailable( CF_OEMTEXT))
#endif // UNICODE
                    {
                        // Check for current position and change that token's text
                        nIndex = (int)SendMessage( hListWnd,
                                                   LB_GETCURSEL,
                                                   (WPARAM)0,
                                                   (LPARAM)0);

                        if (nIndex == LB_ERR) {

#if defined(UNICODE)
                            //if no select, just ignore
                            break;
#else // not UNICODE
                            nIndex = -1;
#endif // UNICODE

                        }


#if defined(UNICODE)
                        hClipMem = GetClipboardData(CF_UNICODETEXT);
#else // not UNICODE
                        hClipMem = GetClipboardData( CF_TEXT);
#endif // UNICODE

                        lpClipMem = (LPTSTR)GlobalLock( hClipMem);
                        hMem = (HGLOBAL)SendMessage( hListWnd,
                                                     LB_GETITEMDATA,
                                                     (WPARAM)nIndex,
                                                     (LPARAM)0);

                        lpTokData = (LPTOKDATA)GlobalLock( hMem );
                        lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );

                        if ( lpstrToken ) {

#if defined(UNICODE)
                            szString = (TCHAR *)FALLOC(
                                                      MEMSIZE(lstrlen(lpstrToken)+1) );
#else // not UNICODE
                            szString = (TCHAR *)
                                       FALLOC( lstrlen( lpstrToken) + 1);
#endif // UNICODE

                            lstrcpy( szString, lpstrToken);

                            GlobalUnlock( lpTokData->hToken );
                            lMtkPointer = lpTokData->lMtkPointer;    //Save

                            GlobalUnlock( hMem);
                            // copy the string to the token
                            ParseBufToTok(szString, &tok);
                            RLFREE( szString);
                            RLFREE( tok.szText);

                            tok.szText = (TCHAR *)
                                         FALLOC( MEMSIZE( lstrlen( lpClipMem) + 1));
#ifdef RLWIN32
                            lstrcpy( tok.szText, lpClipMem);
#else
                            _fstrcpy(tok.szText, lpClipMem);
#endif

                            GlobalUnlock(hClipMem);
                            szString = (TCHAR *)
                                       FALLOC( MEMSIZE( TokenToTextSize( &tok)));
                            ParseTokToBuf(szString, &tok);
                            RLFREE( tok.szText);

                            // Paste the text
                            SendMessage( hListWnd,
                                         WM_SETREDRAW,
                                         (WPARAM)FALSE,
                                         (LPARAM)0);
                            SendMessage( hListWnd,
                                         LB_DELETESTRING,
                                         (WPARAM)nIndex,
                                         (LPARAM)0);

                            hMem = GlobalAlloc( GMEM_MOVEABLE, sizeof(TOKDATA) );
                            lpTokData = (LPTOKDATA)GlobalLock( hMem );
                            lpTokData->hToken = GlobalAlloc
                                                ( GMEM_MOVEABLE, MEMSIZE(lstrlen(szString)+1) );
                            lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );

                            lstrcpy( lpstrToken, szString);
                            RLFREE( szString);

                            GlobalUnlock( lpTokData->hToken );
                            lpTokData->lMtkPointer = lMtkPointer;

                            GlobalUnlock( hMem);
                            SendMessage( hListWnd,
                                         LB_INSERTSTRING,
                                         (WPARAM)nIndex,
                                         (LPARAM)hMem);
                            SendMessage( hListWnd,
                                         LB_SETCURSEL,
                                         (WPARAM)nIndex,
                                         (LPARAM)0);
                            fTokChanges = TRUE; // Set Dirty Flag
                        }
                        SendMessage( hListWnd,
                                     WM_SETREDRAW,
                                     (WPARAM)TRUE,
                                     (LPARAM)0);
                        InvalidateRect(hListWnd, FALSE, TRUE);

                        // Close the Clipboard
                        CloseClipboard();

                        SetFocus(hListWnd);
                    }
                }
                CloseClipboard();
                break;
            }

        case IDM_E_FINDDOWN:

            if (fSearchStarted) {
                if (!DoTokenSearchForRledit(szSearchType,
                                            szSearchText,
                                            wSearchStatus,
                                            wSearchStatusMask,
                                            0,
                                            TRUE)) {
                    TCHAR sz1[80], sz2[80];
                    LoadString( hInst,
                                IDS_FIND_TOKEN,
                                sz1,
                                TCHARSIN( sizeof( sz1)));
                    LoadString( hInst,
                                IDS_TOKEN_NOT_FOUND,
                                sz2,
                                TCHARSIN( sizeof( sz2)));
                    MessageBox( hWnd,
                                sz2,
                                sz1,
                                MB_ICONINFORMATION | MB_OK);
                }
                break;
            }
        case IDM_E_FINDUP:
            if (fSearchStarted) {
                if (!DoTokenSearchForRledit(szSearchType,
                                            szSearchText,
                                            wSearchStatus,
                                            wSearchStatusMask,
                                            1,
                                            TRUE)) {
                    TCHAR sz1[80], sz2[80];
                    LoadString( hInst,
                                IDS_FIND_TOKEN,
                                sz1,
                                TCHARSIN( sizeof( sz1)));
                    LoadString( hInst,
                                IDS_TOKEN_NOT_FOUND,
                                sz2,
                                TCHARSIN( sizeof( sz2)));
                    MessageBox( hWnd,
                                sz2,
                                sz1,
                                MB_ICONINFORMATION | MB_OK);
                }
                break;
            }

        case IDM_E_FIND:
            {
#ifndef RLWIN32
                //WNDPROC lpfnTOKFINDMsgProc;
                //
                //lpfnTOKFINDMsgProc = MakeProcInstance( (WNDPROC)TOKFINDMsgProc,
                //                                       hInst);
                //
                //if ( DialogBox( hInst, TEXT("TOKFIND"), hWnd, lpfnTOKFINDMsgProc) == -1)
                if ( DialogBox( hInst, TEXT("TOKFIND"), hWnd, TOKFINDMsgProc) == -1)
#else
                if ( DialogBox( hInst, TEXT("TOKFIND"), hWnd, TOKFINDMsgProc) == -1)
#endif
                {

#ifndef DBCS
// 'Token Not Found' is strange because user selected cancel
                    TCHAR sz1[80], sz2[80];

                    LoadString( hInst,
                                IDS_FIND_TOKEN,
                                sz1,
                                TCHARSIN( sizeof( sz1)));
                    LoadString( hInst,
                                IDS_TOKEN_NOT_FOUND,
                                sz2,
                                TCHARSIN( sizeof( sz2)));
                    MessageBox( hWnd,
                                sz2,
                                sz1,
                                MB_ICONINFORMATION | MB_OK);
#endif    //DBCS

                }
#ifndef RLWIN32
                FreeProcInstance( lpfnTOKFINDMsgProc);
#endif
                return TRUE;
            }

        case IDM_E_REVIEW:
            {
                int wSaveSelection;
                nUpdateMode = 1;

                // set listbox selection to begining of the token list
                wSaveSelection = (UINT)SendMessage( hListWnd,
                                                    LB_GETCURSEL,
                                                    (WPARAM)0,
                                                    (LPARAM)0);

                // Selection for REVIEW starts with the user-selected line, (PW)
                // not at the top of the token list.                            (PW)
                // SendMessage(hListWnd, LB_SETCURSEL, 0, 0L);          (PW)

                if ( DoTokenSearchForRledit( NULL,
                                             NULL,
                                             ST_TRANSLATED | ST_DIRTY,
                                             ST_TRANSLATED | ST_DIRTY,
                                             FALSE,
                                             FALSE) ) {
#ifdef RLWIN16
                    LONG lListParam;

                    lListParam      = MAKELONG(NULL, LBN_DBLCLK);
                    SendMessage( hMainWnd,
                                 WM_COMMAND,
                                 (WPARAM)IDC_LIST,
                                 (LPARAM)lListParam);
#else
                    SendMessage( hMainWnd,
                                 WM_COMMAND,
                                 MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                 (LPARAM)0);
#endif

                }
                break;
            }

        case IDM_E_ALLREVIEW:
            {
                UINT    wListParam;
                UINT    wIndex, wcTokens;

                wIndex   = (UINT)SendMessage( hListWnd, LB_GETCURSEL, 0, 0L);
                wcTokens = (UINT)SendMessage( hListWnd, LB_GETCOUNT, 0, 0L );

                if ( wcTokens == wIndex )
                    break;

                nUpdateMode = 2;
                SendMessage( hListWnd, LB_SETCURSEL, wIndex, 0L);
                wListParam  = (UINT) MAKELONG(IDC_LIST, LBN_DBLCLK);
                SendMessage(hMainWnd, WM_COMMAND, wListParam, (LPARAM)0);
                break;
            }


        case IDM_O_GENERATE:
            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                HCURSOR hOldCursor;

                hOldCursor = SetCursor( hHourGlass);
                rc = GenerateImageFile( gProj.szBld,
                                        gMstr.szSrc,
                                        gProj.szTok,
                                        gMstr.szRdfs,
                                        0);
                SetCursor( hOldCursor);
            }
            break;

        case IDM_H_CONTENTS:
            {
                OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

                if ( OpenFile( gszHelpFile, &Of, OF_EXIST) == HFILE_ERROR ) {
                    LoadString( hInst, IDS_ERR_NO_HELP, sz, TCHARSIN( sizeof( sz)));
                    MessageBox( hWnd, sz, NULL, MB_OK);
                } else {
                    WinHelpA( hWnd, gszHelpFile, HELP_KEY, (DWORD_PTR)(LPSTR)"RLEdit");
                }
                break;
            }

        case IDM_H_ABOUT:
            {

#ifndef RLWIN32

                //WNDPROC lpProcAbout;

                //lpProcAbout = MakeProcInstance(About, hInst);
                //DialogBox(hInst, TEXT("ABOUT"), hWnd, lpProcAbout);
                //FreeProcInstance(lpProcAbout);
                DialogBox(hInst, TEXT("ABOUT"), hWnd, About);
#else
                DialogBox(hInst, TEXT("ABOUT"), hWnd, About);
#endif
                break;
            }
            break;

        default:
            if (wParam <= IDM_LAST_EDIT && wParam >= IDM_FIRST_EDIT) {
                // USER IS INVOKING AN EDITOR
                CHAR szEditor[MAXFILENAME] = "";

                if ( LoadStrIntoAnsiBuf(hInst, (UINT)wParam, szEditor, sizeof(szEditor))) {
                    if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                        HCURSOR hOldCursor;

                        hOldCursor = SetCursor(hHourGlass);
                        MyGetTempFileName(0, "RES", 0, szTempRes);
                        fInThirdPartyEditer = TRUE;

                        if (gProj.fSourceEXE) {
                            // we need to first extract the .RES from the .EXE
                            CHAR sz[MAXFILENAME] = "";
                            MyGetTempFileName(0, "RES", 0, sz);
                            ExtractResFromExe32A( gMstr. szSrc, sz, 0);
                            GenerateRESfromRESandTOKandRDFs( szTempRes,
                                                             sz,
                                                             gProj.szTok,
                                                             gMstr.szRdfs,
                                                             ID_RT_DIALOG);
                            remove(sz);
                        } else {
                            GenerateRESfromRESandTOKandRDFs( szTempRes,
                                                             gMstr.szSrc,
                                                             gProj.szTok,
                                                             gMstr.szRdfs,
                                                             ID_RT_DIALOG);
                        }
                        SetCursor( hOldCursor);
                        ExecResEditor( hWnd, szEditor, szTempRes,  "");
                    }
                }
            }
            break;  // default
    }
    return FALSE;
}



#ifdef RLWIN16
static int ExecResEditor(HWND hWnd, CHAR *szEditor, CHAR *szFile, CHAR *szArgs)
{
    CHAR szExecCmd[256];
    int  RetCode;

    // generate command line
    lstrcpy( szExecCmd, szEditor);
    lstrcat( szExecCmd, " ");
    lstrcat( szExecCmd, szArgs);
    lstrcat( szExecCmd, " ");
    lstrcat( szExecCmd, szFile);

    lpfnWatchTask = MakeProcInstance(WatchTask, hInst);
    NotifyRegister(NULL, (LPFNNOTIFYCALLBACK)lpfnWatchTask, NF_NORMAL);
    fWatchEditor = TRUE;

    // exec resource editor
    RetCode = WinExec(szExecCmd, SW_SHOWNORMAL);

    if (RetCode > 31) {
        // successful execution
        ShowWindow(hWnd, SW_HIDE);
    } else {
        // unsuccessful execution
        CHAR sz[80];

        NotifyUnRegister(NULL);
        FreeProcInstance(lpfnWatchTask);
        remove(szFile);
        fInThirdPartyEditer = FALSE;
        SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
        LoadString( hInst, IDS_GENERALFAILURE, sz, TCHARSIN( sizeof( sz)));
        MessageBox( hWnd, sz, tszAppName, MB_OK);
    }
    return RetCode;
}

#endif

#ifdef RLWIN32

static int ExecResEditor(HWND hWnd, CHAR *szEditor, CHAR *szFile, CHAR *szArgs)
{
    TCHAR  wszExecCmd[256];
    CHAR   szExecCmd[256];
    DWORD  dwRetCode  = 0;
    DWORD  dwExitCode = 0;
    BOOL   fSuccess = FALSE;
    BOOL   fExit    = FALSE;

    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO     StartupInfo;

    StartupInfo.cb          = sizeof(STARTUPINFO);
    StartupInfo.lpReserved  = NULL;
    StartupInfo.lpDesktop   = NULL;
    StartupInfo.lpTitle     = TEXT("Resize Dialogs");
    StartupInfo.dwX         = 0L;
    StartupInfo.dwY         = 0L;
    StartupInfo.dwXSize     = 0L;
    StartupInfo.dwYSize     = 0L;
    StartupInfo.dwFlags     = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = SW_SHOWDEFAULT;
    StartupInfo.lpReserved2 = NULL;
    StartupInfo.cbReserved2 = 0;

    //  generate command line
    strcpy(szExecCmd, szEditor);
    strcat(szExecCmd, " ");
    strcat(szExecCmd, szArgs);
    strcat(szExecCmd, " ");
    strcat(szExecCmd, szFile);


    #ifdef UNICODE
    _MBSTOWCS( wszExecCmd,
               szExecCmd,
               WCHARSIN( sizeof( wszExecCmd)),
               ACHARSIN( strlen(szExecCmd) + 1));
    #else
    strcpy(wszExecCmd, szExecCmd);
    #endif


    fSuccess = CreateProcess( (LPTSTR) NULL,
                              wszExecCmd,
                              NULL,
                              NULL,
                              FALSE,
                              NORMAL_PRIORITY_CLASS,
                              NULL,
                              NULL,
                              &StartupInfo,
                              &ProcessInfo); /* try to create a process */

    if ( fSuccess ) {
        //  wait for the editor to complete */
        dwRetCode = WaitForSingleObject( ProcessInfo.hProcess, 0xFFFFFFFF) ;

        if ( ! dwRetCode ) {
            // editor terminated, check exit code
            fExit = GetExitCodeProcess( ProcessInfo.hProcess, &dwExitCode) ;
        } else {
            fExit = FALSE;
        }
        // close the editor object  handles

        CloseHandle( ProcessInfo.hThread) ;
        CloseHandle( ProcessInfo.hProcess) ;

        if ( fExit ) {
            // successful execution
            ShowWindow(hWnd, SW_HIDE);
            SendMessage(hMainWnd, WM_EDITER_CLOSED, 0, 0);
        } else {
            // unsuccessful execution
            remove( szFile);
            fInThirdPartyEditer = FALSE;
            SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
            LoadStrIntoAnsiBuf( hInst, IDS_GENERALFAILURE, szDHW, DHWSIZE);
            MessageBoxA( hWnd, szDHW, szEditor, MB_ICONSTOP|MB_OK);
        }
    } else {
        CHAR  szText[ 80] = "";
        LPSTR pszMsg = szText;


        dwRetCode = GetLastError();

        if ( dwRetCode == ERROR_PATH_NOT_FOUND ) {
            pszMsg = ", Path not found.";
        } else if ( dwRetCode == ERROR_FILE_NOT_FOUND ) {
            OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

            sprintf( szText,
                     ", File \"%s\" not found.",
                     OpenFile( szFile, &Of, OF_EXIST) != HFILE_ERROR
                     ? szEditor
                     : szFile);
        }
        sprintf( szDHW,
                 "Command  \"%s\"  failed.\nSystem error code = %d%s",
                 szExecCmd,
                 dwRetCode,
                 pszMsg);
        MessageBoxA( hWnd, szDHW, szAppName, MB_ICONEXCLAMATION|MB_OK);
        fExit = FALSE;
    }

    return ( fExit);
}

#endif

/**
  *  Function: WatchTask
  *    A callback function installed by a NotifyRegister function.
  *    This function is installed by the dialog editer command and is used
  *    to tell RLEDIT when the dialog editer has been closed by the user.
  *
  *    To use this function, set fWatchEditor to TRUE and install this
  *    callback function by using NotifyRegister.  The next task initiated
  *    (in our case via a WinExec call) will be watched for termination.
  *
  *    When WatchTask sees that the task being watched has terminated it
  *    posts a WM_EDITER_CLOSED message to RLEDITs main window.
  *
  *  History:
  *    2/92, implemented    SteveBl
  */
#ifdef RLWIN16
BOOL PASCAL _loadds  WatchTask(WORD wID, DWORD dwData)
{
    static HTASK htWatchedTask;
    static BOOL fWatching = FALSE;

    switch (wID) {
        case NFY_STARTTASK:
            if (fWatchEditor) {
                htWatchedTask = GetCurrentTask();
                fWatching = TRUE;
                fWatchEditor = FALSE;
            }
            break;

        case NFY_EXITTASK:
            if (fWatching) {
                if (GetCurrentTask() == htWatchedTask) {
                    PostMessage(hMainWnd, WM_EDITER_CLOSED, 0, 0);
                    fWatching = FALSE;
                }
            }
            break;
    }
    return FALSE;
}

#endif

/**
  *
  *
  *  Function:  TokEditDlgProc
  * Procedure for the edit mode dialog window. Loads the selected token
  * info into the window, and allows the user to change the token text.
  * Once the edit is complete, the procedure sends a message to the
  * list box windows to update the current token info.
  *
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  * TRUE, carry out edit, and update token list box.
  * FALSE, cancel edit.
  *
  *  History:
  *
  *
  **/

INT_PTR CALLBACK TokEditDlgProc(

                               HWND   hDlg,
                               UINT   wMsg,
                               WPARAM wParam,
                               LPARAM lParam)
{
    HWND    hCtl         = NULL;
    HWND    hParentWnd   = NULL;
    UINT static wcTokens = 0;
    UINT    wNotifyCode  = 0;
    UINT    wIndex       = 0;
#ifdef RLWIN16
    LONG    lListParam   = 0;
#endif

    switch ( wMsg ) {
        case WM_INITDIALOG:

            cwCenter( hDlg, 0);
            wcTokens = (UINT)SendMessage( hListWnd,
                                          LB_GETCOUNT,
                                          (WPARAM)0,
                                          (LPARAM)0);
            wcTokens--;

            // only allow skip button if in update mode
            if ( ! nUpdateMode ) {
                if ( (hCtl = GetDlgItem( hDlg, IDD_SKIP)) ) {
                    EnableWindow( hCtl, FALSE);
                }
            } else {
                if ( (hCtl = GetDlgItem( hDlg, IDD_SKIP)) ) {
                    EnableWindow( hCtl, TRUE);
                }
            }

            // disallow auto translate if we don't have a glossary file

            if ( *gProj.szGlo == '\0' ) {
                hCtl = GetDlgItem( hDlg, IDD_TRANSLATE);
                EnableWindow( hCtl, FALSE);
                hCtl = GetDlgItem( hDlg, IDD_ADD);
                EnableWindow( hCtl, FALSE);
            }
            return ( TRUE);

        case WM_COMMAND:

            switch ( GET_WM_COMMAND_ID( wParam, lParam) ) {
                case IDD_TOKCURTRANS:

                    wNotifyCode = GET_WM_COMMAND_CMD( wParam, lParam);
                    hCtl = GET_WM_COMMAND_HWND( wParam, lParam);

                    if ( wNotifyCode == EN_CHANGE ) {
                        if ( hCtl = GetDlgItem( hDlg, IDOK) ) {
                            EnableWindow( hCtl, TRUE);
                        }
                    }
                    break;

                case IDD_ADD:
                    {
                        TCHAR *szUntranslated = NULL;
                        TCHAR *szTranslated   = NULL;
                        TCHAR *sz             = NULL;
                        TCHAR szMask[80]      = TEXT("");
                        HWND hDlgItem         = NULL;
                        int  cCurTextLen      = 0;
                        int  cTotalTextLen    = 80;


                        hDlgItem       = GetDlgItem( hDlg, IDD_TOKCURTEXT);
                        cCurTextLen    = GetWindowTextLength( hDlgItem);
                        cTotalTextLen += cCurTextLen;
                        szUntranslated = (TCHAR *)FALLOC( MEMSIZE( cCurTextLen + 1));

                        GetDlgItemText( hDlg,
                                        IDD_TOKCURTEXT,
                                        szUntranslated,
                                        cCurTextLen + 1);

                        hDlgItem       = GetDlgItem( hDlg, IDD_TOKCURTRANS);
                        cCurTextLen    = GetWindowTextLength( hDlgItem);
                        cTotalTextLen += cCurTextLen;
                        szTranslated   = (TCHAR *)FALLOC( MEMSIZE( cCurTextLen + 1));
                        GetDlgItemText( hDlg,
                                        IDD_TOKCURTRANS,
                                        szTranslated,
                                        cCurTextLen + 1);

                        LoadString( hInst,
                                    IDS_ADDGLOSS,
                                    szMask,
                                    TCHARSIN( sizeof(szMask)));

                        sz = (TCHAR *)FALLOC( MEMSIZE( cTotalTextLen + 1));
                        wsprintf( sz, szMask, szTranslated, szUntranslated);

                        if ( MessageBox( hDlg,
                                         sz,
                                         tszAppName,
                                         MB_ICONQUESTION | MB_YESNO) == IDYES) {
                            HCURSOR hOldCursor = SetCursor( hHourGlass);

                            AddTranslation( szUntranslated,
                                            szTranslated,
                                            lFilePointer);

                            TransString( szUntranslated,
                                         szTranslated,
                                         &pTransList,
                                         lFilePointer);
                            SetCursor( hOldCursor);
                        }
                        RLFREE( sz);
                        RLFREE( szUntranslated);
                        RLFREE( szTranslated);
                        break;
                    }

                case IDD_UNTRANSLATE:
                    {
                        int cTextLen  = 0;
                        TCHAR *sz     = NULL;
                        HWND hDlgItem = NULL;

                        hDlgItem = GetDlgItem( hDlg, IDD_TOKCURTEXT);
                        cTextLen = GetWindowTextLength( hDlgItem);
                        sz = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));

                        GetDlgItemText( hDlg,
                                        IDD_TOKCURTEXT,
                                        sz,
                                        cTextLen + 1);

                        SetDlgItemText( hDlg, IDD_TOKCURTRANS, sz);
                        RLFREE( sz);
                        break;
                    }

                case IDD_TRANSLATE:
                    // Get next thing in the translation list
                    if ( pTransList ) {
                        pTransList = pTransList->pNext;
                        SetDlgItemText( hDlg, IDD_TOKCURTRANS, pTransList->sz);
                    }
                    break;

                case IDD_SKIP:

                    wIndex = (UINT)SendMessage( hListWnd,
                                                LB_GETCURSEL,
                                                (LPARAM)0,
                                                (LPARAM)0);

                    if ( nUpdateMode == 2 && wIndex < wcTokens ) {
                        wIndex++;
                        SendMessage( hListWnd, LB_SETCURSEL, wIndex, 0L );
                        SendMessage( hMainWnd,
                                     WM_COMMAND,
                                     MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                     (LPARAM)0);
                        return ( TRUE );
                    } else if ( nUpdateMode == 1 && (wIndex < wcTokens) ) {
                        wIndex++;
                        SendMessage( hListWnd,
                                     LB_SETCURSEL,
                                     (WPARAM)wIndex,
                                     (LPARAM)0);

                        if ( DoTokenSearchForRledit( NULL,
                                                     NULL,
                                                     ST_TRANSLATED | ST_DIRTY,
                                                     ST_TRANSLATED | ST_DIRTY,
                                                     FALSE,
                                                     FALSE) ) {
                            // go into edit mode
                            wIndex = (UINT)SendMessage( hListWnd,
                                                        LB_GETCURSEL,
                                                        (WPARAM)0,
                                                        (LPARAM)0);
#ifdef RLWIN16
                            SendMessage( hMainWnd,
                                         WM_COMMAND,
                                         IDC_LIST,
                                         MAKELONG( NULL, LBN_DBLCLK));
#else
                            SendMessage( hMainWnd,
                                         WM_COMMAND,
                                         MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                         (LPARAM)0);
#endif

                            return TRUE;
                        }
                    }
                    nUpdateMode = 0;

                    // remove edit dialog box
                    DestroyWindow( hDlg);
#ifndef RLWIN32
                    //FreeProcInstance( (FARPROC)lpTokEditDlg);
#endif
                    hTokEditDlgWnd = 0;
                    break;

                case IDD_READONLY:
                    if ( IsDlgButtonChecked( hDlg, IDD_READONLY) ) {
                        EnableWindow( GetDlgItem( hDlg, IDD_TOKCURTRANS), FALSE);
                    } else {
                        EnableWindow( GetDlgItem( hDlg, IDD_TOKCURTRANS), TRUE);
                    }
                    break;

                case IDOK:
                    {
                        int cTokenTextLen   = 0;
                        TCHAR *szTokTextBuf = NULL;
                        HWND hDlgItem       = NULL;

                        wIndex = (UINT)SendMessage( hListWnd,
                                                    LB_GETCURSEL,
                                                    (WPARAM)0,
                                                    (LPARAM)0);
                        fTokChanges  = TRUE;

                        // set flag to show token list has changed
                        // Extract String from IDD_TOKTEXT edit control

                        hDlgItem = GetDlgItem( hDlg, IDD_TOKCURTRANS);
                        cTokenTextLen = GetWindowTextLength( hDlgItem);
                        szTokTextBuf = (TCHAR *)FALLOC( MEMSIZE( cTokenTextLen + 1));
                        GetDlgItemText( hDlg,
                                        IDD_TOKCURTRANS,
                                        szTokTextBuf,
                                        cTokenTextLen+1);

                        hParentWnd = GetParent( hDlg);
                        SendMessage( hParentWnd,
                                     WM_TOKEDIT,
                                     (WPARAM)((IsDlgButtonChecked( hDlg, IDD_READONLY)
                                               ? ST_READONLY : 0)
                                              | (IsDlgButtonChecked( hDlg, IDD_DIRTY)
                                                 ? ST_DIRTY : 0)),
                                     (LPARAM)szTokTextBuf);

                        RLFREE( szTokTextBuf);

                        // Exit, or goto to next changed token if in update mode

                        if ( nUpdateMode == 2 && wIndex < wcTokens ) {
                            wIndex++;
                            SendMessage( hListWnd, LB_SETCURSEL, wIndex, 0L );
                            SendMessage( hMainWnd,
                                         WM_COMMAND,
                                         MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                         (LPARAM)0);
                            return ( TRUE );
                        } else if ( nUpdateMode == 1 && (wIndex < wcTokens) ) {
                            wIndex++;
                            SendMessage( hListWnd,
                                         LB_SETCURSEL,
                                         (WPARAM)wIndex,
                                         (LPARAM)0);

                            if ( DoTokenSearchForRledit( NULL,
                                                         NULL,
                                                         ST_TRANSLATED | ST_DIRTY,
                                                         ST_TRANSLATED | ST_DIRTY,
                                                         FALSE,
                                                         FALSE) ) {
                                // go into edit mode
#ifdef RLWIN16
                                lListParam = MAKELONG(NULL, LBN_DBLCLK);
                                SendMessage( hMainWnd,
                                             WM_COMMAND,
                                             IDC_LIST,
                                             lListParam);
#else
                                SendMessage( hMainWnd,
                                             WM_COMMAND,
                                             MAKEWPARAM(IDC_LIST, LBN_DBLCLK),
                                             (LPARAM)0);
#endif

                                return ( TRUE);
                            }
                        }
                    }
                    // fall through to IDCANCEL

                case IDCANCEL:

                    nUpdateMode = 0;

                    // remove edit dialog box
                    DestroyWindow( hDlg);
#ifndef RLWIN32
                    //FreeProcInstance( lpTokEditDlg);
#endif
                    hTokEditDlgWnd = 0;
                    break;
            } // GET_WM_COMMAND_ID
            return ( TRUE);

        default:

            if ( (hCtl = GetDlgItem(hDlg, IDOK)) ) {
                EnableWindow( hCtl, TRUE);
            }
            return ( FALSE);
    } // Main Switch
}


/**
  *
  *  Function: TOKFINDMsgProc
  *
  *  Arguments:
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  *
  *  History:
  *
  **/

//#ifdef RLWIN32
//BOOL CALLBACK TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, UINT wParam, LONG lParam)
//#else
INT_PTR CALLBACK TOKFINDMsgProc(

                               HWND   hWndDlg,
                               UINT   wMsg,
                               WPARAM wParam,
                               LPARAM lParam)
//#endif
{
    HWND hCtl;
    int rgiTokenTypes[]=
    {
        ID_RT_MENU,
        ID_RT_DIALOG,
        ID_RT_STRING,
        ID_RT_ACCELERATORS,
        ID_RT_RCDATA,
        ID_RT_ERRTABLE,
        ID_RT_NAMETABLE,
        ID_RT_VERSION,
        ID_RT_DLGINIT
    };
    TCHAR szTokenType[20] = TEXT("");
    WORD i;
    DWORD rc;

    switch (wMsg) {
        case WM_INITDIALOG:
            CheckDlgButton(hWndDlg, IDD_READONLY, 2);
            CheckDlgButton(hWndDlg, IDD_DIRTY, 2);
            CheckDlgButton(hWndDlg, IDD_FINDDOWN, 1);
            hCtl = GetDlgItem(hWndDlg, IDD_TYPELST);

            for (i = 0; i < sizeof(rgiTokenTypes)/sizeof(int); i ++) {
                LoadString( hInst,
                            IDS_RESOURCENAMES + rgiTokenTypes[i],
                            szTokenType,
                            TCHARSIN( sizeof( szTokenType)));
                SendMessage( hCtl,
                             CB_ADDSTRING,
                             (WPARAM)0,
                             (LPARAM)szTokenType);
            }
            return TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK: /* Button text: "Okay"                        */
                    GetDlgItemText(hWndDlg, IDD_TYPELST, szSearchType, 40);
                    GetDlgItemText(hWndDlg, IDD_FINDTOK, szSearchText, 256);
                    wSearchStatus = ST_TRANSLATED;
                    wSearchStatusMask = ST_TRANSLATED ;
                    switch (IsDlgButtonChecked(hWndDlg, IDD_READONLY)) {
                        case 1:
                            wSearchStatus |= ST_READONLY;

                        case 0:
                            wSearchStatusMask |= ST_READONLY;
                    }

                    switch (IsDlgButtonChecked(hWndDlg, IDD_DIRTY)) {
                        case 1:
                            wSearchStatus |= ST_DIRTY;

                        case 0:
                            wSearchStatusMask |= ST_DIRTY;
                    }
                    fSearchStarted = TRUE;
                    fSearchDirection = IsDlgButtonChecked(hWndDlg, IDD_FINDUP);
                    EndDialog( hWndDlg,
                               DoTokenSearchForRledit( szSearchType,
                                                       szSearchText,
                                                       wSearchStatus,
                                                       wSearchStatusMask,
                                                       fSearchDirection,
                                                       FALSE));
                    return TRUE;

                case IDCANCEL:
                    /* and dismiss the dialog window returning FALSE       */
                    EndDialog( hWndDlg, -1);
                    return TRUE;
            }
            break;    /* End of WM_COMMAND     */

        default:
            return FALSE;
    }
    return FALSE;
}

/**
  *  Function:  NewDlgProc
  * Procedure for the new project dialog window.
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  * TRUE, carry out edit, and update token list box.
  * FALSE, cancel edit.
  *
  *  History:
  **/
static CHAR szPrompt[80] = "";
static CHAR *szFSpec  = NULL;
static CHAR *szExt    = NULL;
static int   iLastBox = IDD_MPJ;

INT_PTR CALLBACK NewDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static PROJDATA OldProj;
    static CHAR     szNewFileName[ MAXFILENAME] = "";


    switch ( wMsg ) {
        case WM_INITDIALOG:
            {
                int    nSel = 0;
                LPTSTR pszLangName = NULL;

                // Save the old .PRJ

                CopyMemory( &OldProj, &gProj, sizeof( PROJDATA));

                if ( (pszLangName = GetLangName( (WORD)(PRIMARYLANGID( gMstr.wLanguageID)),
                                                 (WORD)(SUBLANGID( gMstr.wLanguageID)))) == NULL ) {
                    SetDlgItemText( hDlg, IDD_MSTR_LANG_NAME, TEXT("UNKNOWN"));
                } else {
                    SetDlgItemText( hDlg, IDD_MSTR_LANG_NAME, pszLangName);
                }

                FillListAndSetLang( hDlg,
                                    IDD_PROJ_LANG_NAME,
                                    &gProj.wLanguageID,
                                    NULL);

                if ( gProj.uCodePage == CP_ACP )
                    gProj.uCodePage = GetACP();
                else if ( gProj.uCodePage == CP_OEMCP )
                    gProj.uCodePage = GetOEMCP();

                if ( ! IsValidCodePage( gProj.uCodePage) ) {
                    static TCHAR szMsg[ 256];
                    CHAR *pszCP[1];

                    pszCP[0] = UlongToPtr(gProj.uCodePage);

                    LoadString( hInst, IDS_NOCPXTABLE, szMsg, 256);
                    FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                   | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   szMsg,
                                   0,
                                   0,
                                   (LPTSTR)szDHW,
                                   DHWSIZE/sizeof(TCHAR),
                                   (va_list *)pszCP);
                    MessageBox( hDlg, (LPCTSTR)szDHW, tszAppName, MB_ICONHAND|MB_OK);
                }
                SetDlgItemInt( hDlg, IDD_PROJ_TOK_CP, gProj.uCodePage, FALSE);

                if ( fEditing ) {
                    SetDlgItemTextA( hDlg, IDD_MPJ,      gProj.szMpj);
                    SetDlgItemTextA( hDlg, IDD_TOK,      gProj.szTok);
                    SetDlgItemTextA( hDlg, IDD_BUILTRES, gProj.szBld);
                    SetDlgItemTextA( hDlg, IDD_GLOSS,    gProj.szGlo);
                } else {
                    // fill in suggested name for the token file
                    SetDlgItemTextA( hDlg, IDD_TOK,      ".TOK");
                    SetDlgItemTextA( hDlg, IDD_BUILTRES, ".EXE");
                    SetDlgItemTextA( hDlg, IDD_GLOSS,    ".TXT");
                    iLastBox = IDD_MPJ;
                    PostMessage( hDlg, WM_COMMAND, IDD_BROWSE, 0);
                }
                CheckRadioButton( hDlg,
                                  IDC_REPLACE,
                                  IDC_APPEND,
                                  gfReplace ? IDC_REPLACE : IDC_APPEND);
                return TRUE;
            }

        case WM_COMMAND:

            switch ( GET_WM_COMMAND_ID( wParam, lParam) ) {
                case IDD_MPJ:
                case IDD_TOK:
                case IDD_BUILTRES:
                case IDD_GLOSS:

                    iLastBox = GET_WM_COMMAND_ID( wParam, lParam);
                    break;

                case IDD_BROWSE:
                    {
                        switch ( iLastBox ) {
                            case IDD_MPJ:

                                szFSpec = szMPJFilterSpec;
                                szExt   = "MPJ";
                                LoadStrIntoAnsiBuf( hInst,
                                                    IDS_MPJ,
                                                    szPrompt,
                                                    sizeof( szPrompt));
                                break;

                            case IDD_BUILTRES:

                                szFSpec = szExeResFilterSpec;
                                szExt   = "EXE";
                                LoadStrIntoAnsiBuf( hInst,
                                                    IDS_RES_BLD,
                                                    szPrompt,
                                                    sizeof( szPrompt));
                                break;

                            case IDD_TOK:

                                szFSpec = szTokFilterSpec;
                                szExt   = "TOK";
                                LoadStrIntoAnsiBuf( hInst,
                                                    IDS_TOK,
                                                    szPrompt,
                                                    sizeof( szPrompt));
                                break;

                            case IDD_GLOSS:

                                szFSpec = szGlossFilterSpec;
                                szExt   ="TXT";
                                LoadStrIntoAnsiBuf( hInst,
                                                    IDS_GLOSS,
                                                    szPrompt,
                                                    sizeof( szPrompt));
                                break;
                        } // END switch ( iLastBox )

                        if ( GetFileNameFromBrowse( hDlg,
                                                    szNewFileName,
                                                    MAXFILENAME,
                                                    szPrompt,
                                                    szFSpec,
                                                    szExt) ) {
                            SetDlgItemTextA( hDlg, iLastBox, szNewFileName);
                            SetNames( hDlg, iLastBox, szNewFileName);
                        }
                        break;
                    } // END case IDD_BROWSE:

                case IDC_REPLACE:
                case IDC_APPEND:

                    CheckRadioButton( hDlg,
                                      IDC_REPLACE,
                                      IDC_APPEND,
                                      GET_WM_COMMAND_ID( wParam, lParam));
                    break;

                case IDD_PROJ_LANG_NAME:

                    if ( GET_WM_COMMAND_CMD( wParam, lParam) == CBN_SELENDOK ) {
                        //... Get the selected language name
                        //... then set the appropriate lang id vals

                        INT_PTR nSel = SendDlgItemMessage( hDlg,
                                                           IDD_PROJ_LANG_NAME,
                                                           CB_GETCURSEL,
                                                           (WPARAM)0,
                                                           (LPARAM)0);

                        if ( nSel != CB_ERR
                             && SendDlgItemMessage( hDlg,
                                                    IDD_PROJ_LANG_NAME,
                                                    CB_GETLBTEXT,
                                                    (WPARAM)nSel,
                                                    (LPARAM)(LPTSTR)szDHW) != CB_ERR ) {
                            WORD wPri = 0;
                            WORD wSub = 0;

                            if ( GetLangIDs( (LPTSTR)szDHW, &wPri, &wSub) ) {
                                gProj.wLanguageID = MAKELANGID( wPri, wSub);
                            }
                        }
                    }
                    break;

                case IDOK:
                    {
                        PROJDATA stProject =
                        { "", "", "", "", "", "",
                            CP_ACP,
                            MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US),
                            FALSE,
                            FALSE
                        };
                        BOOL fTranslated = FALSE;
                        UINT uCP = GetDlgItemInt( hDlg,
                                                  IDD_TOK_CP,
                                                  &fTranslated,
                                                  FALSE);

                        if ( uCP == CP_ACP )
                            uCP = GetACP();
                        else if ( uCP == CP_OEMCP )
                            uCP = GetOEMCP();

                        if ( IsValidCodePage( uCP) ) {
                            gProj.uCodePage = uCP;
                        } else {
                            static TCHAR szMsg[ 256];
                            CHAR *pszCP[1];

                            pszCP[0] = UlongToPtr(uCP);

                            LoadString( hInst, IDS_NOCPXTABLE, szMsg, 256);
                            FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                           | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                           szMsg,
                                           0,
                                           0,
                                           (LPTSTR)szDHW,
                                           DHWSIZE/sizeof(TCHAR),
                                           (va_list *)pszCP);
                            MessageBox( hDlg, (LPCTSTR)szDHW, tszAppName, MB_ICONHAND|MB_OK);
                            SetDlgItemInt( hDlg, IDD_TOK_CP, gProj.uCodePage, FALSE);
                            return ( TRUE);
                        }

                        GetDlgItemTextA( hDlg, IDD_MPJ,      stProject.szMpj, MAXFILENAME);
                        GetDlgItemTextA( hDlg, IDD_BUILTRES, stProject.szBld, MAXFILENAME);
                        GetDlgItemTextA( hDlg, IDD_TOK,      stProject.szTok, MAXFILENAME);
                        GetDlgItemTextA( hDlg, IDD_GLOSS,    stProject.szGlo, MAXFILENAME);

                        //Why don't allow the partial path?
                        if ( stProject.szMpj[0]
                             && stProject.szBld[0]
                             && stProject.szTok[0]  ) {
                            _fullpath( gProj.szMpj,
                                       stProject.szMpj,
                                       sizeof( gProj.szMpj));
                            _fullpath( gProj.szBld,
                                       stProject.szBld,
                                       sizeof( gProj.szBld));
                            _fullpath( gProj.szTok,
                                       stProject.szTok,
                                       sizeof( gProj.szTok));

                            if ( stProject.szGlo[0] != '\0' ) {
                                _fullpath( gProj.szGlo,
                                           stProject.szGlo,
                                           sizeof( gProj.szGlo));
                            }
                            gfReplace = IsDlgButtonChecked( hDlg, IDC_REPLACE);
                            EndDialog( hDlg, TRUE);

                            return ( TRUE);
                        } else {
                            break;
                        }
                    } // END case ID_OK:

                case IDCANCEL:

                    CopyMemory( &gProj, &OldProj, sizeof( PROJDATA));
                    EndDialog( hDlg, FALSE);
                    return ( TRUE);
            } // END switch ( GET_WM_COMMAND_ID( wParam, lParam) )
            break;
    } // END switch ( wMsg )
    return ( FALSE);
}

/**
  *  Function:  ViewDlgProc
  * Procedure for the View project dialog window.
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  * TRUE, carry out edit, and update token list box.
  * FALSE, cancel edit.
  *
  *  History:
  **/

INT_PTR CALLBACK ViewDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static int iLastBox = IDD_MPJ;

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                LPTSTR pszLangName = NULL;


                if ( (pszLangName = GetLangName( (WORD)(PRIMARYLANGID( gMstr.wLanguageID)),
                                                 (WORD)(SUBLANGID( gMstr.wLanguageID)))) == NULL ) {
                    sprintf( szDHW, "Unknown LANGID %#06hx", gMstr.wLanguageID);
                    SetDlgItemTextA( hDlg, IDD_MSTR_LANG_NAME, szDHW);
                } else {
                    SetDlgItemText( hDlg, IDD_MSTR_LANG_NAME, pszLangName);
                }

                if ( (pszLangName = GetLangName( (WORD)(PRIMARYLANGID( gProj.wLanguageID)),
                                                 (WORD)(SUBLANGID( gProj.wLanguageID)))) == NULL ) {
                    sprintf( szDHW, "Unknown LANGID %#06hx", gProj.wLanguageID);
                    SetDlgItemTextA( hDlg, IDD_PROJ_LANG_NAME, szDHW);
                } else {
                    SetDlgItemText( hDlg, IDD_PROJ_LANG_NAME, pszLangName);
                }

                SetDlgItemTextA( hDlg, IDD_VIEW_SOURCERES,  gMstr.szSrc);
                SetDlgItemTextA( hDlg, IDD_VIEW_MTK,        gMstr.szMtk);
                SetDlgItemTextA( hDlg, IDD_VIEW_RDFS,       gMstr.szRdfs);
                SetDlgItemTextA( hDlg, IDD_VIEW_MPJ,        gProj.szMpj);
                SetDlgItemTextA( hDlg, IDD_VIEW_TOK,        gProj.szTok);
                SetDlgItemTextA( hDlg, IDD_VIEW_TARGETRES,  gProj.szBld);
                SetDlgItemTextA( hDlg, IDD_VIEW_GLOSSTRANS, gProj.szGlo);

                if ( gProj.uCodePage == CP_ACP )
                    gProj.uCodePage = GetACP();
                else if ( gProj.uCodePage == CP_OEMCP )
                    gProj.uCodePage = GetOEMCP();

                SetDlgItemInt( hDlg, IDD_PROJ_TOK_CP, gProj.uCodePage, FALSE);

                LoadString( hInst,
                            gfReplace ? IDS_WILLREPLACE : IDS_WILLAPPEND,
                            (LPTSTR)szDHW,
                            TCHARSIN( DHWSIZE));
                SetDlgItemText( hDlg, IDC_APPENDREPLACE, (LPTSTR)szDHW);

                return TRUE;
            }
        case WM_COMMAND:

            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:

                    EndDialog(hDlg, TRUE);
                    return TRUE;
            }
    }
    return FALSE;
}

/**
  *  Function:
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  **/
static void DrawLBItem(LPDRAWITEMSTRUCT lpdis)
{
    LPRECT  lprc        = (LPRECT) &(lpdis->rcItem);
    DWORD   rgbOldText  = 0;
    DWORD   rgbOldBack  = 0;
    HBRUSH  hBrush;
    static DWORD    rgbHighlightText;
    static DWORD    rgbHighlightBack;
    static HBRUSH   hBrushHilite = NULL;
    static HBRUSH   hBrushNormal = NULL;
    static DWORD    rgbDirtyText;
    static DWORD    rgbBackColor;
    static DWORD    rgbCleanText;
    static DWORD    rgbReadOnlyText;
    TCHAR           *szToken;
    TOKEN           tok;
    LPTSTR          lpstrToken;
    LPTOKDATA        lpTokData;


    if (lpdis->itemAction & ODA_FOCUS) {
        DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
    } else {
        HANDLE hMem = (HANDLE)SendMessage( lpdis->hwndItem,
                                           LB_GETITEMDATA,
                                           (WPARAM)lpdis->itemID,
                                           (LPARAM)0);

        lpTokData = (LPTOKDATA)GlobalLock( hMem );
        lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );

        szToken = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
        lstrcpy( szToken, lpstrToken);

        GlobalUnlock( lpTokData->hToken );
        GlobalUnlock( hMem);
        ParseBufToTok(szToken, &tok);
        RLFREE( szToken);

        if (lpdis->itemState & ODS_SELECTED) {
            if (!hBrushHilite) {
                rgbHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                rgbHighlightBack = GetSysColor(COLOR_HIGHLIGHT);
                hBrushHilite = CreateSolidBrush(rgbHighlightBack);
            }
            GenStatusLine(&tok);

            rgbOldText = SetTextColor(lpdis->hDC, rgbHighlightText);
            rgbOldBack = SetBkColor(lpdis->hDC, rgbHighlightBack);

            hBrush = hBrushHilite;
        } else {
            if (!hBrushNormal) {
                rgbDirtyText = RGB(255, 0, 0);
                rgbBackColor = RGB(192, 192, 192);
                rgbCleanText = RGB(0, 0, 0);
                rgbReadOnlyText = RGB(127, 127, 127);
                hBrushNormal = CreateSolidBrush(rgbBackColor);
            }
            if (tok.wReserved & ST_READONLY) {
                rgbOldText = SetTextColor(lpdis->hDC, rgbReadOnlyText);
            } else {
                if (tok.wReserved & ST_DIRTY) {
                    rgbOldText = SetTextColor(lpdis->hDC, rgbDirtyText);
                } else {
                    rgbOldText = SetTextColor(lpdis->hDC, rgbCleanText);
                }
            }
            rgbOldBack = SetBkColor(lpdis->hDC, rgbBackColor);
            hBrush = hBrushNormal;
        }
        FillRect(lpdis->hDC, (CONST RECT *)lprc, hBrush);
        DrawText(lpdis->hDC,
                 tok.szText,
                 STRINGSIZE(lstrlen(tok.szText)),
                 lprc,
                 DT_LEFT|DT_NOPREFIX);
        RLFREE( tok.szText);

        if (rgbOldText) {
            SetTextColor(lpdis->hDC, rgbOldText);
        }
        if (rgbOldBack) {
            SetBkColor(lpdis->hDC, rgbOldBack);
        }

        if (lpdis->itemState & ODS_FOCUS) {
            DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
        }
    }
}

/**********************************************************************
*FUNCTION: SaveTokList(HWND, FILE *fpTokFile)                         *
*                                                                     *
*PURPOSE: Save current Token List                                     *
*                                                                     *
*COMMENTS:                                                            *
*                                                                     *
*This saves the current contents of the Token List, and changes       *
*fTokChanges to indicate that the list has not been changed since the *
*last save.                                                           *
**********************************************************************/

static BOOL SaveTokList(HWND hWnd, FILE *fpTokFile)
{
    HCURSOR hSaveCursor;
    BOOL bSuccess = TRUE;
    int IOStatus;
    UINT cTokens;
    UINT cCurrentTok = 0;
    CHAR   *szTokBuf = NULL;
    LPTSTR lpstrToken = NULL;
    HGLOBAL hMem = NULL;
    LPTOKDATA    lpTokData;


    // Set the cursor to an hourglass during the file transfer

    hSaveCursor = SetCursor(hHourGlass);

    // Find number of tokens in the list

    cTokens = (UINT)SendMessage( hListWnd, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);

    if ( cTokens != LB_ERR ) {
        for (cCurrentTok = 0; bSuccess && (cCurrentTok < cTokens); cCurrentTok++) {
            int nLen1 = 0;
            int nLen2 = 0;

            // Get each token from list
            hMem = (HGLOBAL)SendMessage( hListWnd,
                                         LB_GETITEMDATA,
                                         (WPARAM)cCurrentTok,
                                         (LPARAM)0);

            if ( ! (lpTokData = (LPTOKDATA)GlobalLock(hMem)) ) {
                continue;
            }

            if ( (lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken)) ) {
                szTokBuf = (CHAR *)FALLOC( (nLen2 = MEMSIZE( (nLen1 = lstrlen(lpstrToken)+1))));
#ifdef UNICODE
                _WCSTOMBS( szTokBuf, lpstrToken, nLen2, nLen1);
#else
                lstrcpy(szTokBuf, lpstrToken);
#endif

                GlobalUnlock( lpTokData->hToken );
                GlobalUnlock( hMem);
                IOStatus = fprintf(fpTokFile, "%s\n", szTokBuf);

                if ( IOStatus != (int) strlen(szTokBuf) + 1 ) {
                    TCHAR szTmpBuf[256];

                    LoadString( hInst,
                                IDS_FILESAVEERR,
                                szTmpBuf,
                                TCHARSIN( sizeof(szTmpBuf)));
                    MessageBox( hWnd,
                                szTmpBuf,
                                tszAppName,
                                MB_OK | MB_ICONHAND);
                    bSuccess = FALSE;
                }
                RLFREE( szTokBuf);
            }
        }
    }
    // restore cursor
    SetCursor(hSaveCursor);
    return (bSuccess);
}




/**
  * Function: CleanDeltaList
  *   frees the pTokenDeltaInfo list
  */
static void CleanDeltaList(void)
{
    TOKENDELTAINFO FAR *pTokNode;

    while (pTokNode = pTokenDeltaInfo) {
        pTokenDeltaInfo = pTokNode->pNextTokenDelta;
        RLFREE( pTokNode->DeltaToken.szText);
        RLFREE( pTokNode);
    }
}

/*
 * About -- message processor for about box
 *
 */
//#ifdef RLWIN32
//
//BOOL CALLBACK About(
//
//HWND   hDlg,
//UINT   message,
//WPARAM wParam,
//LPARAM lParam)
//
//#else
//
INT_PTR CALLBACK About(

                      HWND   hDlg,
                      UINT   message,
                      WPARAM wParam,
                      LPARAM lParam)
//
//#endif
{
    switch ( message ) {
        case WM_INITDIALOG:
            {
                WORD wRC = SUCCESS;
                CHAR szModName[ MAXFILENAME];

                GetModuleFileNameA( hInst, szModName, sizeof( szModName));

                if ( (wRC = GetCopyright( szModName,
                                          szDHW,
                                          DHWSIZE)) == SUCCESS ) {
                    SetDlgItemTextA( hDlg, IDC_COPYRIGHT, szDHW);
                } else {
                    ShowErr( wRC, NULL, NULL);
                }
            }
            break;

        case WM_COMMAND:

            if ((wParam == IDOK) || (wParam == IDCANCEL)) {
                EndDialog(hDlg, TRUE);
            }
            break;

        default:

            return ( FALSE);
    }
    return ( TRUE);
}


//...................................................................

int  RLMessageBoxA(

                  LPCSTR pszMsgText)
{
    return ( MessageBoxA( NULL, pszMsgText, szAppName, MB_ICONHAND|MB_OK));
}


//...................................................................

void Usage()
{
    return;
}


//...................................................................

void DoExit( int nErrCode)
{
    ExitProcess( (UINT)nErrCode);
}


//...................................................................

static void SetNames( HWND hDlg, int iLastBox, LPSTR szNewFile)
{
    static CHAR szDrive[ _MAX_DRIVE] = "";
    static CHAR szDir[   _MAX_DIR]   = "";
    static CHAR szName[  _MAX_FNAME] = "";
    static CHAR szExt[   _MAX_EXT]   = "";
    static CHAR szOldFileName[ MAXFILENAME];


    if ( iLastBox == IDD_MPJ ) {
        lstrcpyA( gProj.szMpj, szNewFile);

        if ( ! fEditing && GetMasterProjectData( gProj.szMpj,
                                                 NULL,
                                                 NULL,
                                                 FALSE) == SUCCESS ) {
            // Suggest a name for the target file

            GetDlgItemTextA( hDlg, IDD_BUILTRES, szOldFileName, MAXFILENAME);

            if ( szOldFileName[0] == '\0' || szOldFileName[0] == '.' ) {
                _splitpath( gProj.szPRJ, szDrive, szDir, szName, szExt);

                sprintf( gProj.szBld, "%s%s", szDrive, szDir);

                _splitpath( gMstr.szSrc, szDrive, szDir, szName, szExt);

                sprintf( &gProj.szBld[ lstrlenA( gProj.szBld)],
                         "%s%s",
                         szName,
                         szExt);

                SetDlgItemTextA( hDlg, IDD_BUILTRES, gProj.szBld);
            }
        } else {
            return;
        }
    }

    if ( iLastBox == IDD_BUILTRES ) {
        lstrcpyA( gProj.szBld, szNewFile);
    }

    if ( ! fEditing && (iLastBox == IDD_MPJ || iLastBox == IDD_BUILTRES) ) {
        // Suggest a name for the project token file

        GetDlgItemTextA( hDlg, IDD_TOK, szOldFileName, MAXFILENAME);

        if ( szOldFileName[0] == '\0' || szOldFileName[0] == '.' ) {
            _splitpath( gProj.szPRJ, szDrive, szDir, szName, szExt);
            sprintf( gProj.szTok, "%s%s%s.%s", szDrive, szDir, szName, "TOK");
            SetDlgItemTextA( hDlg, IDD_TOK, gProj.szTok);
        }

        // Suggest a name for the glossary file

        GetDlgItemTextA( hDlg, IDD_GLOSS, szOldFileName, MAXFILENAME);

        if ( szOldFileName[0] == '\0' || szOldFileName[0] == '.' ) {
            _splitpath( gProj.szPRJ, szDrive, szDir, szName, szExt);
            sprintf( gProj.szGlo, "%s%s%s.%s", szDrive, szDir, szName, "TXT");
            SetDlgItemTextA( hDlg, IDD_GLOSS, gProj.szGlo);
        }
    }

    if ( iLastBox == IDD_TOK ) {
        lstrcpyA( gProj.szTok, szNewFile);
    }

    if ( iLastBox == IDD_GLOSS ) {
        lstrcpyA( gProj.szGlo, szNewFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rlman\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RLMAN.RC
//
#define IDS_SELECTMSTRLANG              3101
#define IDS_SELECTPROJLANG              3102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rlman\rlman.c ===
//........................................................................
//...
//... RLMAN.C
//...
//... Contains 'main' for rlman.exe.
//........................................................................


#include <stdio.h>
#include <stdlib.h>

#ifdef RLDOS
#include "dosdefs.h"
#else
#include <windows.h>
#include "windefs.h"
#endif

//#include <tchar.h>
#include "custres.h"
#include "rlmsgtbl.h"
#include "commbase.h"
#include "rlman.h"
#include "exe2res.h"
#include "exeNTres.h"
#include "rlstrngs.h"
#include "projdata.h"
#include "showerrs.h"
#include "resread.h"

#ifndef RLDOS
int Update( char *, char *);
#endif



extern MSTRDATA gMstr;           //... Data from Master Project file (MPJ)
extern PROJDATA gProj;           //... Data from Project file (PRJ)

HWND hListWnd       = NULL;
HWND hMainWnd       = NULL;
HWND hStatusWnd     = NULL;
int  nUpdateMode    = 0;
BOOL fCodePageGiven = FALSE; //... Set to TRUE if -p arg given
CHAR szCustFilterSpec[MAXCUSTFILTER];
CHAR szFileTitle[256]="";

extern BOOL gfReplace;      //... Set FALSE if -a option is given
extern BOOL gbMaster;       //... TRUE if working in a Master Project
extern BOOL gbShowWarnings; //... Display warnining messages if TRUE
extern BOOL gfShowClass;    //... Set TRUE to put dlg box elemnt class in
                            //... token file
extern BOOL gfExtendedTok;  //... Set TRUE if -x option is given
extern UCHAR szDHW[];       //... Common buffer, many uses

extern int  atoihex( CHAR sz[]);
extern BOOL bRLGui;
CHAR szModule[MAX_PATH];


//............................................................

void Usage( void)
{
    int i;

    for ( i = IDS_USG_00; i < IDS_USG_END; ++i )
    {
        LoadStringA( NULL, i, szDHW, DHWSIZE);
        CharToOemA( szDHW, szDHW);
        fprintf( stderr, "%s\n", szDHW);
    }
}

//............................................................
//...
//... This is a stub for console programs

int RLMessageBoxA(

LPCSTR lpError)
{
    fprintf( stderr, "RLMan (%s): %s\n", szModule, lpError);
    return( IDOK);  // Should return something.
}


#ifndef __cdecl
#define __cdecl __cdecl
#endif

//............................................................

void __cdecl main( int argc, char *argv[])
{
    BOOL    fBuildRes = FALSE;
    BOOL    fBuildTok = FALSE;
    BOOL    fExtRes   = FALSE;
    BOOL    bChanged  = FALSE;
    BOOL    fProject       = FALSE; //... Set to TRUE if -l arg given
    BOOL    fNewLanguageGiven = FALSE; //... Set to TRUE if -n arg given
    BOOL    fOldLanguageGiven = FALSE; //... Set to TRUE if -o arg given
    FILE   *pfCRFile = NULL;
    int     iCount = 0;
    int     iErrorLine = 0;
    UINT    usError = 0;
    WORD    wRC     = 0;
    WORD    wResTypeFilter = 0; //... Pass all resource types by default
    char   *pszMasterFile  = NULL;
    char   *pszProjectFile = NULL;
    int     chOpt = 0;

    bRLGui = FALSE;

    wRC = GetCopyright( argv[0], szDHW, DHWSIZE);

    if ( wRC != SUCCESS )
    {
        ShowErr( wRC, NULL, NULL);
        DoExit( wRC);
    }
    CharToOemA( szDHW, szDHW);
    fprintf( stderr, "\n%s\n\n", szDHW);

                                //... Enough args on command line?
    if ( argc < 2 )
    {
        ShowErr( IDS_ERR_01, NULL, NULL);
        Usage();
        DoExit( IDS_ERR_01);
    }
    gbMaster = FALSE;       //... Build project token file by default.

    iCount = 1;
                                //... Get the switches

    while ( iCount < argc && (*argv[ iCount] == '-' || *argv[ iCount] == '/') )
    {
        switch ( (chOpt = *CharLowerA( &argv[iCount][1])))
        {
            case '?':
            case 'h':

                WinHelp( NULL, TEXT("rlman.hlp"), HELP_CONTEXT, IDM_HELPUSAGE);
                DoExit( SUCCESS);
                break;

            case 'e':

                if ( fBuildTok != FALSE || fBuildRes != FALSE )
                {
                    ShowErr( IDS_ERR_02, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                fExtRes   = TRUE;
                gbMaster  = FALSE;
                fBuildTok = FALSE;
                break;

            case 't':           //... Create token file

                if ( fBuildRes != FALSE || fExtRes != FALSE )
                {
                    ShowErr( IDS_ERR_02, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                gbMaster  = FALSE;
                fProject  = FALSE;
                fBuildTok = TRUE;
                break;

                                //... Update 1.0 token files to fit upper 1.7 version,
                                //... it is same as 'm' + 'l' option.

            case 'u':           //...Update 1.0 token files to fit upper 1.7 version

                if ( argc - iCount < 6 )
                {
                    ShowErr( IDS_ERR_01, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                gbMaster  = TRUE;
                fProject  = TRUE;
                fBuildTok = TRUE;				
                pszMasterFile  = argv[++iCount];
                pszProjectFile = argv[++iCount];
                break;

           case 'm':           //... Build Master token file

                if ( argc - iCount < 2 )
                {
                    ShowErr( IDS_ERR_01, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                gbMaster  = TRUE;
                fProject  = FALSE;
                fBuildTok = TRUE;

                pszMasterFile = argv[ ++iCount];
                break;

            case 'l':           //... Build language project token file

                if ( argc - iCount < 2 )
                {
                    ShowErr( IDS_ERR_01, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                fProject  = TRUE;
                fBuildTok = TRUE;
                gbMaster  = FALSE;

                pszProjectFile = argv[ ++iCount];
                break;

            case 'a':
            case 'r':

                if ( fBuildTok != FALSE || fExtRes != FALSE )
                {
                    ShowErr( IDS_ERR_02, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_02);
                }
                fBuildRes = TRUE;
                gfReplace = (chOpt == 'a') ? FALSE : TRUE;
                gbMaster  = FALSE;
                fProject  = FALSE;
                break;

            case 'n':           //... Get ID components of new language

                if ( argc - iCount < 2 )
                {
                    ShowErr( IDS_ERR_01, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                else
                {
                    WORD wPri = (WORD)MyAtoi( argv[ ++iCount]);
                    WORD wSub = (WORD)MyAtoi( argv[ ++iCount]);
                    gProj.wLanguageID = MAKELANGID( wPri, wSub);
                    fNewLanguageGiven = TRUE;
                }
                break;

            case 'o':           //... Get old language ID components

                if ( argc - iCount < 2 )
                {
                    ShowErr( IDS_ERR_01, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                else
                {
                    WORD wPri = (WORD)MyAtoi( argv[ ++iCount]);
                    WORD wSub = (WORD)MyAtoi( argv[ ++iCount]);
                    gMstr.wLanguageID = MAKELANGID( wPri, wSub);
                    fOldLanguageGiven = TRUE;
                }
                break;

            case 'p':           //... Get code page number

                gMstr.uCodePage = gProj.uCodePage
                                = (UINT)MyAtoi( argv[ ++iCount]);
                fCodePageGiven = TRUE;
                break;

            case 'c':           //... Get custom resource def file name

                strcpy( gMstr.szRdfs, argv[ ++iCount]);

                pfCRFile = FOPEN( gMstr.szRdfs, "rt");

                if ( pfCRFile == NULL )
                {
                    QuitA( IDS_ENGERR_02, gMstr.szRdfs, NULL);
                }
                wRC = (WORD)ParseResourceDescriptionFile( pfCRFile, &iErrorLine);

                if ( wRC )
                {
                    switch ( (int)wRC )
                    {
                        case -1:

                            ShowErr( IDS_ERR_14, NULL, NULL);
                            break;

                        case -2:

                            ShowErr( IDS_ERR_15, NULL, NULL);
                            break;

                        case -3:

                            ShowErr( IDS_ERR_16, NULL, NULL);
                            break;
                    }       //... END switch ( wRC )
                }
                FCLOSE( pfCRFile);
                break;

            case 'f':           //... Get res type to retrieve

                wResTypeFilter = (WORD)MyAtoi( argv[ ++iCount]);
                break;

            case 'w':

                gbShowWarnings = TRUE;
                break;

            case 'd':

                gfShowClass = TRUE;
                break;

            case 'x':

                gfExtendedTok = TRUE;
                break;

            default:

                ShowErr( IDS_ERR_04, argv[ iCount], NULL);
                Usage();
                DoExit( IDS_ERR_04);
                break;

        }                       //... END switch
        iCount++;
    }                           //... END while

	lstrcpyA(szModule, argv[ iCount]);

    if ( fExtRes )
    {
        if ( argc - iCount < 2 )
        {
            ShowErr( IDS_ERR_01, NULL, NULL);
            Usage();
            DoExit( IDS_ERR_01);
        }
        ExtractResFromExe32A( argv[ iCount], argv[ iCount + 1], wResTypeFilter);
    }
    else if ( fBuildTok )
    {
        if ( ( fProject == FALSE && gbMaster == FALSE) && argc - iCount < 2 )
        {
            ShowErr( IDS_ERR_01, NULL, NULL);
            Usage();
            DoExit( IDS_ERR_01);
        }
                                //... check to see if we are updating a
                                //... Master Token file
        if ( gbMaster )
        {
            OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

            CHAR	*pExe, *pMtk;

            if ( chOpt == 'u' )			//Update them
            {
                pExe = argv[iCount++];
                pMtk = argv[iCount++];				
            }
            else
            {
               pExe = argc - iCount < 1 ? NULL : argv[ iCount];
               pMtk = argc - iCount < 2 ? NULL : argv[ iCount+1];
            }
		   	wRC = (WORD)GetMasterProjectData( pszMasterFile,
                                        pExe,
                                        pMtk,
                                        fOldLanguageGiven);

            if ( wRC != SUCCESS )
            {
                DoExit( wRC);
            }

            LoadCustResDescriptions( gMstr.szRdfs);

                                //... check for the special case where Master
                                //... Token file does not exists. This is
                                //... possible if the MPJ file was created
                                //... automatically.

            if ( OpenFile( gMstr.szMtk, &Of, OF_EXIST) == HFILE_ERROR )
            {
                                //... Master token file does not exists,
                                //... so go ahead and create it

                wRC = (WORD)GenerateTokFile( gMstr.szMtk,
                                       gMstr.szSrc,
                                       &bChanged,
                                       wResTypeFilter);

                SzDateFromFileName( gMstr.szMpjLastRealUpdate, gMstr.szMtk);
            }
            else
            {
                                //... we are doing an update, so we need to make
                                //... sure we don't do unecessary upates

                SzDateFromFileName( gMstr.szSrcDate, gMstr.szSrc);

                if ( strcmp( gMstr.szMpjLastRealUpdate, gMstr.szSrcDate) )
                {
                    wRC = (WORD)GenerateTokFile( gMstr.szMtk,
                                           gMstr.szSrc,
                                           &bChanged,
                                           wResTypeFilter);

                                //... did we really update anything ??

                    if( bChanged )
                    {
                        SzDateFromFileName( gMstr.szMpjLastRealUpdate, gMstr.szMtk);
                    }
                }
            }
                                //... write out the new mpj data

            PutMasterProjectData( pszMasterFile);
        }

#ifndef RLDOS

        if ( fProject )    //... Are we to update a project?
        {
                                //... Yes
            CHAR	*pMpj, *pTok;

            if ( chOpt == 'u' )	//Update it
            {
                pMpj = pszMasterFile;
                pTok = argv[iCount];
            }
            else
            {
                pMpj = argc - iCount < 1 ? NULL : argv[ iCount];
                pTok = argc - iCount < 2 ? NULL : argv[ iCount+1];
            }

            if ( GetProjectData( pszProjectFile,
                                 pMpj,
                                 pTok,
                                 fCodePageGiven,
                                 fNewLanguageGiven) )
            {
                DoExit( -1);
            }
                                //... Get source and master token file names
                                //... from the master project file.

            wRC = (WORD)GetMasterProjectData( gProj.szMpj,
                                        NULL,
                                        NULL,
                                        fOldLanguageGiven);

            if ( wRC != SUCCESS )
            {
                DoExit( wRC);
            }
                                //... Now we do the actual updating.

            wRC = (WORD)Update( gMstr.szMtk, gProj.szTok);

                                //... If that worked, we update the project file
            if ( wRC == 0 )
            {
                SzDateFromFileName( gProj.szTokDate, (CHAR *)gProj.szTok);
                PutProjectData( pszProjectFile);
            }
            else
            {
                ShowErr( IDS_ERR_18, gProj.szTok, gMstr.szMtk);
                DoExit( IDS_ERR_18);
            }
        }

#endif  // RLDOS

        if ( !gbMaster && !fProject )
        {
            wRC = (WORD)GenerateTokFile( argv[ iCount + 1],
                                   argv[ iCount],
                                   &bChanged,
                                   wResTypeFilter);
        }

        if ( wRC != 0 )
        {

#ifdef RLDOS

            ShowErr( IDS_ERR_08, errno, NULL);
            DoExit( -1);
#else
            usError = GetLastError();
            ShowErr( IDS_ERR_08, UlongToPtr(usError), NULL);

            switch ( usError )
            {
                case ERROR_BAD_FORMAT:

                    ShowErr( IDS_ERR_09, NULL, NULL);
                    DoExit( IDS_ERR_09);
                    break;

                case ERROR_OPEN_FAILED:

                    ShowErr( IDS_ERR_10, NULL, NULL);
                    DoExit( IDS_ERR_10);
                    break;

                case ERROR_EXE_MARKED_INVALID:
                case ERROR_INVALID_EXE_SIGNATURE:

                    ShowErr( IDS_ERR_11, NULL, NULL);
                    DoExit( IDS_ERR_11);
                    break;

                default:

                    if ( usError < ERROR_HANDLE_DISK_FULL )
                    {
                        ShowErr( IDS_ERR_12, _sys_errlist[ usError], NULL);
                        DoExit( IDS_ERR_12);
                    }
                    DoExit( (int)usError);
            }                   //... END switch
#endif

        }
    }
    else if ( fBuildRes )
    {
        if ( argc - iCount < 3 )
        {
            ShowErr( IDS_ERR_01, NULL, NULL);
            Usage();
            DoExit( IDS_ERR_01);
        }

        if ( GenerateImageFile( argv[iCount + 2],
                                argv[iCount],
                                argv[iCount + 1],
                                gMstr.szRdfs,
                                wResTypeFilter) != 1 )
        {
            ShowErr( IDS_ERR_23, argv[iCount + 2], NULL);
            DoExit( IDS_ERR_23);
        }
    }
    else
    {
        Usage();
        DoExit( IDS_ERR_28);
    }
    DoExit( SUCCESS);
}

//...................................................................


void DoExit( int nErrCode)
{

#ifdef _DEBUG

    FreeMemList( NULL);

#endif // _DEBUG

    exit( nErrCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rledit\rledit.h ===
#ifndef _RLEDIT_H_
#define _RLEDIT_H_

#include "rlstrngs.h"
#include "resourc2.h"

void cwCenter(HWND, int);

INT_PTR     APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY GENERATEMsgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY EXECUTEDLGEDITMsgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR FAR PASCAL StatusWndProc( HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY EXECUTERCWMsgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR APIENTRY TOKENIZEMsgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY TRANSLATEMsgProc( HWND, UINT, WPARAM, LPARAM );

#define MAXFILENAME     256         /* maximum length of file pathname      */
#define MAXCUSTFILTER   40          /* maximum size of custom filter buffer */
#define CCHNPMAX        65535       /* max number of bytes in a notepad file */

void        cwCenter(HWND, int);
void        CwUnRegisterClasses(void);
INT_PTR     DoMenuCommand    ( HWND, UINT, WPARAM, LPARAM );
INT_PTR     DoListBoxCommand ( HWND, UINT, WPARAM, LPARAM );
TCHAR  FAR *FindDeltaToken( TOKEN , TOKENDELTAINFO FAR * , UINT );
LONG        GetGlossaryIndex( FILE *, TCHAR, long [30] );
BOOL        InitApplication(HINSTANCE);
BOOL        InitInstance(HINSTANCE, int);
void        FindAllDirtyTokens( void );
int         nCwRegisterClasses(void);
BOOL        SaveTokList( HWND, FILE * );
void        SetNewBuffer(HWND, HANDLE, PSTR);
FILE       *UpdateFile( HWND, FILE *, FILE *, BOOL, TCHAR *, TCHAR *, TCHAR *, TCHAR * );
int         MyGetTempFileName( BYTE   hDriveLetter,
                               LPSTR  lpszPrefixString,
                               WORD   wUnique,
                               LPSTR  lpszTempFileName);

#ifdef RLWIN32
INT_PTR CALLBACK TokEditDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NewDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK ViewDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#else
BOOL APIENTRY TokEditDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );
BOOL APIENTRY TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, UINT wParam, LONG lParam);
BOOL APIENTRY NewDlgProc( HWND hDlg, UINT wMsg, UINT wParam, LONG lParam );
BOOL APIENTRY ViewDlgProc( HWND hDlg, UINT wMsg, UINT wParam, LONG lParam );
BOOL APIENTRY About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#endif // RLWIN32

#endif // _RLEDIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rlquiked\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by rlquiked.rc
//
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rlman\rlman.h ===
//... RLMAN.H

#define SUCCESS 0

#define IDM_HELPUSAGE 901

//... MSG ID #'s for usage message lines

#define IDS_USG_00  256
#define IDS_USG_01  IDS_USG_00 + 1
#define IDS_USG_02  IDS_USG_00 + 2
#define IDS_USG_03  IDS_USG_00 + 3
#define IDS_USG_04  IDS_USG_00 + 4
#define IDS_USG_05  IDS_USG_00 + 5
#define IDS_USG_06  IDS_USG_00 + 6
#define IDS_USG_07  IDS_USG_00 + 7
#define IDS_USG_08  IDS_USG_00 + 8
#define IDS_USG_09  IDS_USG_00 + 9
#define IDS_USG_10  IDS_USG_00 + 10
#define IDS_USG_11  IDS_USG_00 + 11
#define IDS_USG_12  IDS_USG_00 + 12
#define IDS_USG_13  IDS_USG_00 + 13
#define IDS_USG_14  IDS_USG_00 + 14
#define IDS_USG_15  IDS_USG_00 + 15
#define IDS_USG_16  IDS_USG_00 + 16
#define IDS_USG_17  IDS_USG_00 + 17
#define IDS_USG_18  IDS_USG_00 + 18
#define IDS_USG_19  IDS_USG_00 + 19
#define IDS_USG_20  IDS_USG_00 + 20
#define IDS_USG_21  IDS_USG_00 + 21
#define IDS_USG_22  IDS_USG_00 + 22
#define IDS_USG_23  IDS_USG_00 + 23
#define IDS_USG_24  IDS_USG_00 + 24
#define IDS_USG_25  IDS_USG_00 + 25
#define IDS_USG_26  IDS_USG_00 + 26
#define IDS_USG_27  IDS_USG_00 + 27
#define IDS_USG_END IDS_USG_27 + 1 //... Must be 1 greater than last IDS_USG_nn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rlquiked\rlquiked.h ===
#ifndef _RLQUIKED_H_
#define _RLQUIKED_H_

#include "rlstrngs.h"
#include "resourc2.h"



void cwCenter(HWND, int);

INT_PTR APIENTRY   MainWndProc(HWND, UINT,  WPARAM, LPARAM);
INT_PTR     DoMenuCommand    ( HWND, UINT, WPARAM, LPARAM );
INT_PTR     DoListBoxCommand ( HWND, UINT, WPARAM, LPARAM );
BOOL        InitApplication(HINSTANCE);
BOOL        InitInstance(HINSTANCE, int);
BOOL        SaveTokList( HWND, FILE * );


#ifdef RLWIN32
INT_PTR CALLBACK About(          HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK GetLangIDsProc( HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK TOKFINDMsgProc( HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK TokEditDlgProc( HWND, UINT, WPARAM, LPARAM);
#else
static BOOL APIENTRY About( HWND, UINT, UINT, LONG );
static BOOL APIENTRY TOKFINDMsgProc( HWND, UINT, UINT, LONG);
static BOOL APIENTRY TokEditDlgProc( HWND, UINT, UINT, LONG);
#endif // RLWIN32


#endif // _RLQUIKED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rltools\rlquiked\rlquiked.c ===
#include <windows.h>

#ifdef RLWIN16
//#include <toolhelp.h>
#endif
#ifdef RLWIN32
#include <windowsx.h>
#endif

#include <shellapi.h>
#include <commdlg.h>

// CRT includes
#include <stdio.h>
#include <stdlib.h>

// RL TOOLS SET includes
#include "windefs.h"
#include "toklist.h"
#include "RESTOK.H"
#include "RLQuikEd.H"
#include "custres.h"
#include "exe2res.h"
#include "exeNTres.h"
#include "commbase.h"
#include "wincomon.h"
#include "resread.h"
#include "projdata.h"
#include "showerrs.h"
#include "rlmsgtbl.h"

#ifdef WIN32
    HINSTANCE   hInst;      /* Instance of the main window  */
#else
    HWND        hInst;          /* Instance of the main window  */
#endif

HWND hMainWnd = NULL;        // handle to main window
HWND hListWnd = NULL;        // handle to tok list window
HWND hStatusWnd = NULL;      // handle to status windows
int  nUpdateMode    = 0;     // needed in rlcommon.lib
BOOL fCodePageGiven = FALSE; //... Set to TRUE if -p arg given
CHAR szAppName[50] = "";
CHAR szFileTitle[14] = "";   // holds base name of latest opened file
CHAR szCustFilterSpec[MAXCUSTFILTER]="";    // custom filter buffer

extern UCHAR szDHW[];     //... used in debug strings



#ifndef RLWIN32
static BOOL PASCAL _loadds  WatchTask( WORD wID,DWORD dwData);
static FARPROC lpfnWatchTask = NULL;
#endif

static int     ExecResEditor( HWND , CHAR *, CHAR *, CHAR *);
static void    DrawLBItem( LPDRAWITEMSTRUCT lpdis);
static void    CleanDeltaList( void);
static void    MakeStatusLine( TOKEN *pTok);
static TOKENDELTAINFO FAR *
               InsertQuikTokList( FILE * fpTokFile);

// File IO vars

static CHAR    szFilterSpec        [180] = "";
static CHAR    szResFilterSpec     [60] = "";
static CHAR    szExeFilterSpec     [60] = "";
static CHAR    szDllFilterSpec     [60] = "";
static CHAR    szCplFilterSpec     [60] = "";
static CHAR    szGlossFilterSpec   [60] = "";
static CHAR    szFileName[MAXFILENAME] = "";    // holds full name of latest opened file

static TCHAR   szString[256] = TEXT("");        // variable to load resource strings
static TCHAR   tszAppName[100] = TEXT("");
static CHAR    szEditor[MAXFILENAME] = "";

static BOOL    gbNewProject  = FALSE;      // indicates whether to prompt for auto translate
static BOOL    fTokChanges   = FALSE;      // set to true when toke file is out of date
static BOOL    fTokFile      = FALSE;
static BOOL    fPrjChanges   = FALSE;
static BOOL    fMPJOutOfDate = FALSE;
static BOOL    fPRJOutOfDate = FALSE;

static CHAR    szOpenDlgTitle[80] = "";    // title of File open dialog
static CHAR    szSaveDlgTitle[80] = "";    // title of File saveas dialog
static TCHAR   *szClassName   = TEXT("RLQuikEdClass");
static TCHAR   *szStatusClass = TEXT("RLQuikEdStatus");

static TOKENDELTAINFO FAR *
               pTokenDeltaInfo;        // linked list of token deta info
static LONG    lFilePointer[30]= { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
static TRANSLIST *pTransList =(TRANSLIST *) NULL;      // circular doubly linked list of translations

// Window vars
static BOOL    fWatchEditor;
static CHAR    szTempRes[MAXFILENAME] = "";    // the temporary file created by the resource editor
static CHAR    szTRes[MAXFILENAME] = "";

    // set true if a resource editer has been launched

static HCURSOR hHourGlass;    /* handle to hourglass cursor     */
static HCURSOR hSaveCursor;    /* current cursor handle        */
static HACCEL  hAccTable;
static RECT    Rect;           /* dimension of the client window    */
static int     cyChildHeight;  /* height of status windows */

static TCHAR   szSearchType[80] = TEXT("");
static TCHAR   szSearchText[512] = TEXT("");
static WORD    wSearchStatus = 0;
static WORD    wSearchStatusMask = 0;
static BOOL    fSearchDirection;
static BOOL    fSearchStarted = FALSE;


// NOTIMPLEMENTED is a macro that displays a "Not implemented" dialog
#define NOTIMPLEMENTED {TCHAR sz[80];\
            LoadString(hInst,IDS_NOT_IMPLEMENTED,sz,TCHARSIN(sizeof(sz)));\
            MessageBox(hMainWnd,sz,tszAppName,MB_ICONEXCLAMATION|MB_OK);}

// Edit Tok Dialog

#ifndef RLWIN32
  static FARPROC lpTokEditDlg;
#endif

static HWND hTokEditDlgWnd = NULL;

extern MSTRDATA gMstr;          //... Data from Master Project file (MPJ)
extern PROJDATA gProj;          //... Data from Project file (PRJ)

extern BOOL  gfReplace;         //... FALSE if appending new language to existing resources
extern BOOL  fInQuikEd;         //... Are we in the rlquiked?
extern BOOL  fInThirdPartyEditer;//.. Are we in a 3rd-party resource editor?
extern BOOL		bRLGui;

// Global Variables:
static CHAR * gszHelpFile = "RLTools.hlp";


/**
  *
  *
  *  Function: InitApplication
  *    Regsiters the main window, which is a list box composed of tokens
  *    read from the token file. Also register the status window.
  *
  *
  *  Arguments:
  *    hInstance, instance handle of program in memory.
  *
  *  Returns:
  *
  *  Errors Codes:
  *    TRUE, windows registered correctly.
  *    FALSE, error during register of one of the windows.
  *
  *  History:
  *    9/91, Implemented.      TerryRu
  *
  *
  **/

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS  wc;
    CHAR sz[60] = "";
    CHAR sztFilterSpec[120] = "";

    LoadStrIntoAnsiBuf(hInstance, IDS_RESSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szResFilterSpec, sz, "*.RES");

    LoadStrIntoAnsiBuf(hInstance, IDS_EXESPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szExeFilterSpec, sz, "*.EXE");

    LoadStrIntoAnsiBuf(hInstance, IDS_DLLSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szDllFilterSpec, sz, "*.DLL");

    LoadStrIntoAnsiBuf(hInstance, IDS_CPLSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szCplFilterSpec, sz, "*.CPL");

    CatSzFilterSpecs(szFilterSpec,  szExeFilterSpec, szDllFilterSpec);
    CatSzFilterSpecs(sztFilterSpec, szFilterSpec,    szCplFilterSpec);
    CatSzFilterSpecs(szFilterSpec,  sztFilterSpec,   szResFilterSpec);

    LoadStrIntoAnsiBuf(hInstance, IDS_GLOSSSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szGlossFilterSpec, sz, "*.TXT");

    LoadStrIntoAnsiBuf(hInstance,
                       IDS_OPENTITLE,
                       szOpenDlgTitle,
                       sizeof(szOpenDlgTitle));
    LoadStrIntoAnsiBuf(hInstance,
                       IDS_SAVETITLE,
                       szSaveDlgTitle,
                       sizeof(szSaveDlgTitle));

    wc.style            = 0;
    wc.lpfnWndProc      = StatusWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = szStatusClass;

    if (! RegisterClass((CONST WNDCLASS *)&wc))
    {
        return (FALSE);
    }

    wc.style            = 0;
    wc.lpfnWndProc      = MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInstance;
    wc.hIcon            = LoadIcon(hInstance,TEXT("RLQuikEdIcon"));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName     = TEXT("RLQuikEd");
    wc.lpszClassName    = szClassName;

    if (!RegisterClass((CONST WNDCLASS *)&wc))
    {
        return (FALSE);
    }

    // Windows register return sucessfully
    return (TRUE);
}



/**
  *
  *
  *  Function: InitInstance
  *   Creates the main, and status windows for the program.
  *   The status window is sized according to the main window
  *   size.  InitInstance also loads the acclerator table, and prepares
  *   the global openfilename structure for later use.
  *
  *
  *  Errors Codes:
  *   TRUE, windows created correctly.
  *   FALSE, error on create windows calls.
  *
  *  History:
  *   9/11, Implemented       TerryRu
  *
  *
  **/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    RECT    Rect;

    hAccTable = LoadAccelerators(hInst, TEXT("RLQuikEd"));

    hMainWnd = CreateWindow(szClassName,
                            tszAppName,
                            WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            (HWND) NULL,
                            (HMENU) NULL,
                            hInstance,
                            (LPVOID) NULL);

    if (!hMainWnd)
    {
        return( FALSE);
    }

    DragAcceptFiles(hMainWnd, TRUE);

    GetClientRect(hMainWnd, (LPRECT) &Rect);

    // Create a child list box window

    hListWnd = CreateWindow(TEXT("LISTBOX"),
                            NULL,
                            WS_CHILD |
                            LBS_WANTKEYBOARDINPUT |
                            LBS_NOTIFY | LBS_NOINTEGRALHEIGHT |
                            LBS_OWNERDRAWFIXED |
                            WS_VSCROLL | WS_HSCROLL | WS_BORDER ,
                            0,
                            0,
                            (Rect.right-Rect.left),
                            (Rect.bottom-Rect.top),
                            (HWND) hMainWnd,
                            (HMENU)IDC_LIST, // Child control i.d.
                            hInstance,
                            (LPVOID)NULL);

    if ( ! hListWnd )
    {
                                // clean up after error.

        DeleteObject((HGDIOBJ)hMainWnd);
        return( FALSE);
    }

    // Creat a child status window

    hStatusWnd = CreateWindow(szStatusClass,
                              NULL,
                              WS_CHILD | WS_BORDER | WS_VISIBLE,
                              0,
                              0,
                              0,
                              0,
                              hMainWnd,
                              NULL,
                              hInstance,
                              (LPVOID)NULL);

    if ( ! hStatusWnd )
    {
                                // clean up after error.

        DeleteObject((HGDIOBJ)hListWnd);
        DeleteObject((HGDIOBJ)hMainWnd);
        return( FALSE);
    }

    hHourGlass = LoadCursor(NULL, IDC_WAIT);

    ShowWindow(hMainWnd, nCmdShow);
    UpdateWindow(hMainWnd);
    return( TRUE);
}

/**
  *
  *
  *  Function: WinMain
  *     Calls the intialization functions, to register, and create the
  *     application windows. Once the windows are created, the program
  *     enters the GetMessage loop.
  *
  *
  *  Arguements:
  *     hInstace, handle for this instance
  *     hPrevInstanc, handle for possible previous instances
  *     lpszCmdLine, LONG pointer to exec command line.
  *     nCmdShow,  code for main window display.
  *
  *
  *  Errors Codes:
  *     IDS_ERR_REGISTER_CLASS, error on windows register
  *     IDS_ERR_CREATE_WINDOW, error on create windows
  *         otherwise, status of last command.
  *
  *  History:
  *
  *
  **/

#ifdef RLWIN32

INT WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR     lpszCmdLine,
                   int       nCmdShow)

#else

int PASCAL WinMain(HANDLE hInstance,
                   HANDLE hPrevInstance,
                   LPSTR  lpszCmdLine,
                   int    nCmdShow)

#endif
{
    MSG     msg;
    HWND    FirstWnd, FirstChildWnd;


	bRLGui = TRUE;

    if (FirstWnd = FindWindow(szClassName,NULL))
    {
        // checking for previous instance
        FirstChildWnd = GetLastActivePopup(FirstWnd);
        BringWindowToTop(FirstWnd);
        ShowWindow(FirstWnd,SW_SHOWNORMAL);

        if (FirstWnd != FirstChildWnd)
        {
            BringWindowToTop(FirstChildWnd);
        }

        return(FALSE);
    }
    fInQuikEd = TRUE;
    hInst = hInstance;

    gProj.wLanguageID = LANGIDFROMLCID( GetThreadLocale());

    GetModuleFileNameA( hInst, szDHW, DHWSIZE);
    GetInternalName( szDHW, szAppName, sizeof( szAppName));
    szFileName[0] = '\0';
    lFilePointer[0] = (LONG)-1;

#ifdef UNICODE
    _MBSTOWCS( tszAppName,
               szAppName,
               WCHARSIN( sizeof( tszAppName)),
               ACHARSIN( strlen( szAppName) + 1));
#else
    strcpy( tszAppName, szAppName);
#endif

    // register window classes if first instance of application
    if ( ! hPrevInstance )
    {
        if ( ! InitApplication( hInstance) )
        {
            /* Registering one of the windows failed      */
            LoadString( hInst,
                        IDS_ERR_REGISTER_CLASS,
                        szString,
                        TCHARSIN( sizeof( szString)));
            MessageBox(NULL, szString, tszAppName, MB_ICONEXCLAMATION);
            return( IDS_ERR_REGISTER_CLASS);
        }
    }

    // Create windows for this instance of application
    if ( ! InitInstance( hInstance, nCmdShow) )
    {
        LoadString( hInst,
                    IDS_ERR_CREATE_WINDOW,
                    szString,
                    TCHARSIN( sizeof( szString)));
        MessageBox( NULL, szString, tszAppName, MB_ICONEXCLAMATION);
        return( IDS_ERR_CREATE_WINDOW);
    }

    // Main Message Loop

    while ( GetMessage( &msg, NULL, 0, 0) )
    {
        if ( hTokEditDlgWnd )
        {
            if ( IsDialogMessage( hTokEditDlgWnd, &msg) )
            {
                continue;
            }
        }

        if( TranslateAccelerator( hMainWnd, hAccTable, &msg) )
        {
            continue;
        }
        TranslateMessage( &msg);
        DispatchMessage ( &msg);
    }
    return( (INT)msg.wParam);
}

/**
  *  Function: MainWndProc
  *     Process the windows messages for the main window of the application.
  *     All user inputs go through this window procedure.
  *     See cases in the switch table for a description of each message type.
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  **/

INT_PTR APIENTRY MainWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    FILE *f = NULL;
    WORD rc = 0;

    // if its a list box message process it in  DoListBoxCommand

    if ( fInThirdPartyEditer )  //... only process messages sent by the editor
    {
        switch (wMsg)
        {
        case WM_EDITER_CLOSED:
            {
                CHAR   szDlgToks[ MAXFILENAME] = "";
                static WORD wSavedIndex;
#ifdef RLWIN16
                NotifyUnRegister( NULL);
                FreeProcInstance( lpfnWatchTask);
#endif
                ShowWindow( hWnd, SW_SHOW);
                {
                    TCHAR tsz[80] = TEXT("");
                    LoadString( hInst,
                                IDS_REBUILD_TOKENS,
                                tsz,
                                TCHARSIN( sizeof( tsz)));

                    if ( MessageBox( hWnd,
                                     tsz,
                                     tszAppName,
                                     MB_ICONQUESTION | MB_YESNO) == IDYES)
                    {
                        HCURSOR hOldCursor;
                        BOOL bChanged;

                        hOldCursor = SetCursor( hHourGlass);

                        // szTempRes returned from resource editor, contains only dialogs
                        // need to merge it back into the main token file

                        MyGetTempFileName( 0, "TOK", 0, szDlgToks);
                        rc = (WORD)GenerateTokFile( szDlgToks,
                                              szTempRes,
                                              &bChanged,
                                              0);
                        InsDlgToks( gProj.szTok,
                                    szDlgToks,
                                    ID_RT_DIALOG);
                        remove( szDlgToks);

                        if ( rc )
                        {
                            QuitT( IDS_TOKGENERR, (LPTSTR)rc, NULL);
                            return FALSE;
                        }


                        // gProj.szTok, now contains the latest tokens
                        SetCursor( hOldCursor);

			//Rlqked10 doesn't save when changed tokens by DialogEditor.
			fTokChanges = TRUE;
                    }
                }
                fInThirdPartyEditer = FALSE;

                remove( szTempRes);
                // delete all temp files with the same root in case
                // the editor created additional files like DLGs and RCs.
                // \(DLGEDIT does this.\)
                // For now I'm just going to tack a .DLG at the end of the file name
                // and delete it.
                {
                    int i;
                    for (i = strlen(szTempRes);i > 0 && szTempRes[i]!='.';i--);

                    if (szTempRes[i] == '.')
                    {
                        szTempRes[++i]='D';
                        szTempRes[++i]='L';
                        szTempRes[++i]='G';
                        szTempRes[++i]=0;
                        remove(szTempRes);
                    }
                }
                wSavedIndex = (UINT)SendMessage( hListWnd,
                                                 LB_GETCURSEL,
                                                 (WPARAM)0,
                                                 (LPARAM)0);
                SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             (WPARAM)wSavedIndex,
                             (LPARAM)0);
            }
            return (DefWindowProc(hWnd, wMsg, wParam, lParam));
        }
    }


    // Not a thrid party edit command.


    // is it a list dox command ??
    DoListBoxCommand (hWnd, wMsg, wParam, lParam);


    switch (wMsg)
    {
    case WM_COMMAND:

        if (DoMenuCommand(hWnd, wMsg, wParam, lParam))
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }

        break;

    case WM_CLOSE:
        {
            char sz[128] = "";
            int rc ;

            LoadStrIntoAnsiBuf( hInst, IDS_SAVECHANGES, sz, sizeof( sz));

            if ( fPrjChanges || fTokChanges )
            {
                rc = MessageBoxA( hWnd,
                                  sz,
                                  szAppName,
                                  MB_ICONQUESTION | MB_YESNOCANCEL);
            }
            else
            {
                rc = IDNO;
            }

            if ( rc == IDYES )
            {
                if ( ! SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0))
                {
                    return FALSE;
                }
            }

            if (rc == IDCANCEL)
            {
                return(FALSE);
            }

            if (gProj.szTok[0])
            {
                remove(gProj.szTok);
                gProj.szTok[0] = 0;
            }

            if (hMainWnd)
            {
                DestroyWindow(hMainWnd);
            }

            if (hListWnd)
            {
                DestroyWindow(hListWnd);
            }

            if (hStatusWnd)
            {
                DestroyWindow(hStatusWnd);
            }
            _fcloseall();
            FreeLangList();

#ifdef _DEBUG
            {
                FILE *pLeakList = fopen( "C:\\LEAKLIST.TXT", "wt");
                FreeMemList( pLeakList);
                fclose( pLeakList);
            }
#endif // _DEBUG

            return FALSE;
            break;
        }

    case WM_CREATE:
        {
            HDC hdc;
            int cyBorder;
            TEXTMETRIC tm;

            hdc  = GetDC(hWnd);
            GetTextMetrics(hdc, &tm);
            ReleaseDC(hWnd, hdc);

            cyBorder = GetSystemMetrics(SM_CYBORDER);

            cyChildHeight = tm.tmHeight + 6 + cyBorder * 2;

            break;
        }

    case WM_DESTROY:
        WinHelpA(hWnd, gszHelpFile, HELP_QUIT, 0L);
        // remove translation list
        if (pTransList)
        {
            pTransList->pPrev->pNext = NULL; // so we can find the end of the list
        }

        while (pTransList)
        {
            TRANSLIST *pTemp;
            pTemp = pTransList;
            pTransList = pTemp->pNext;
            RLFREE( pTemp->sz);
            RLFREE( pTemp);
        }

        DragAcceptFiles(hMainWnd, FALSE);
        PostQuitMessage(0);
        break;

    case WM_INITMENU:
        // Enable or Disable the Paste menu item
        // based on available Clipboard Text data
        if (wParam == (WPARAM) GetMenu(hMainWnd))
        {
            if (OpenClipboard(hWnd))
            {

#if defined(UNICODE)
                if ((IsClipboardFormatAvailable(CF_UNICODETEXT) ||
                     IsClipboardFormatAvailable(CF_OEMTEXT)) && fTokFile)
#else // not UNICODE
                if ( (IsClipboardFormatAvailable(CF_TEXT)
                   || IsClipboardFormatAvailable(CF_OEMTEXT))
                  && fTokFile )
#endif // UNICODE

                {
                    EnableMenuItem( (HMENU)wParam, IDM_E_PASTE, MF_ENABLED);
                }
                else
                {
                    EnableMenuItem( (HMENU)wParam, IDM_E_PASTE, MF_GRAYED);
                }
                CloseClipboard();
                return (TRUE);
            }
        }
        break;

    case WM_SETFOCUS:
        SetFocus (hListWnd);
        break;

    case WM_DRAWITEM:
        DrawLBItem((LPDRAWITEMSTRUCT)lParam);
        break;

    case WM_DELETEITEM:
        {
            GlobalFree( (HGLOBAL)((LPDELETEITEMSTRUCT)lParam)->itemData);
            break;
        }

    case WM_SIZE:
        {
            int cxWidth;
            int cyHeight;
            int xChild;
            int yChild;

            cxWidth  = LOWORD(lParam);
            cyHeight = HIWORD(lParam);

            xChild = 0;
            yChild = cyHeight - cyChildHeight + 1;

            MoveWindow(hListWnd, 0, 0, cxWidth, yChild , TRUE);
            MoveWindow(hStatusWnd, xChild, yChild, cxWidth, cyChildHeight, TRUE);
            break;
        }

    case WM_LOADPROJECT:
        {
            HCURSOR hOldCursor = NULL;
            BOOL    bChanged   = FALSE;
            BOOL    fRC        = TRUE;

            hOldCursor = SetCursor( hHourGlass);

            if ( gProj.szTok[0] )
            {
                remove( gProj.szTok);
            }

#ifdef RLRES32
                                //... Get project lanuages

            fRC = DialogBox( hInst,
                             MAKEINTRESOURCE( IDD_LANGUAGES),
                             hMainWnd,
                             GetLangIDsProc) ? TRUE : FALSE;
#endif

            if ( fRC )
            {
                strcpy( gProj.szBld, gMstr.szSrc);

                rc = (WORD)GenerateTokFile( gProj.szTok,
                                      gMstr.szSrc,
                                      &fTokChanges,
                                      0);
                SetCursor( hOldCursor);

                if (rc)
                {
                    QuitT( IDS_TOKGENERR, (LPTSTR)rc, NULL);
                }

                if ( ( ! fTokChanges) && (gProj.wLanguageID != gMstr.wLanguageID) )
                {
                    fTokChanges = TRUE;
                }
                fPrjChanges   = FALSE;
                fPRJOutOfDate = FALSE;

                SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
            }
            else
            {
                SetWindowText( hMainWnd, tszAppName);
                SetCursor( hOldCursor);
            }
            break;
        }

    case WM_LOADTOKENS:
        {
            HMENU hMenu;

            // Remove the current token list
            SendMessage( hListWnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
            CleanDeltaList();

            // Hide token list, while we add new tokens
            ShowWindow(hListWnd, SW_HIDE);

            if (f = FOPEN(gProj.szTok, "rt"))
            {
                int i;
                HCURSOR hOldCursor;

                hOldCursor = SetCursor(hHourGlass);

                // Insert tokens from token file into the list box
                pTokenDeltaInfo = InsertQuikTokList(f);
                FCLOSE( f);

                // Make list box visible
                ShowWindow( hListWnd, SW_SHOW);

                if ( SendMessage( hListWnd,
                                  LB_GETCOUNT,
                                  (WPARAM)0,
                                  (LPARAM)0) > 0 )
                {
                    hMenu = GetMenu(hWnd);
                    EnableMenuItem(hMenu, IDM_P_SAVE,     MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_SAVEAS,   MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_CLOSE,    MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FIND,     MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDUP,   MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDDOWN, MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_COPY,     MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_PASTE,    MF_ENABLED|MF_BYCOMMAND);

                    for (i = IDM_FIRST_EDIT; i <= IDM_LAST_EDIT;i++)
                    {
                        EnableMenuItem(hMenu,i,MF_ENABLED|MF_BYCOMMAND);
                    }

                    fTokFile    = TRUE;
                    fTokChanges = (gProj.wLanguageID != gMstr.wLanguageID);

                    SetCursor(hOldCursor);
                }
                else
                {
                    SetCursor(hOldCursor);
                    fTokChanges = FALSE;
                    MessageBox( hListWnd,
                                TEXT("No tokens matching given criteria found"),
                                tszAppName,
                                MB_ICONINFORMATION|MB_OK);
                }
            }
        }
        break;

    case WM_SAVEPROJECT:
        {
            _fcloseall();

            if ( SendMessage( hWnd, WM_SAVETOKENS, (WPARAM)0, (LPARAM)0) )
            {
                if (fPrjChanges)
                {
                    HCURSOR hOldCursor = NULL;
                    CHAR  sz[100] = "";
                    WORD  rc;

                    if ( gProj.szBld[0] == '\0' )
                    {
                        if(gProj.fSourceEXE)
                        {
                            rc = (WORD)GetFileNameFromBrowse( hWnd,
                                                        szFileName,
                                                        MAXFILENAME,
                                                        szSaveDlgTitle,
                                                        szFilterSpec,
                                                        "EXE");
                        }
                        else
                        {
                            rc = (WORD)GetFileNameFromBrowse( hWnd,
                                                        szFileName,
                                                        MAXFILENAME,
                                                        szSaveDlgTitle,
                                                        szResFilterSpec,
                                                        "RES");
                        }

                        if (rc)
                        {
                            strcpy( gProj.szBld, szFileName);
                        }
                        else
                        {
                            return( FALSE); // user cancelled
                        }
                    }

                    hOldCursor = SetCursor(hHourGlass);

                    rc = (WORD)GenerateImageFile(gProj.szBld,
                                           gMstr.szSrc,
                                           gProj.szTok,
                                           gMstr.szRdfs,
                                           0);

                    SetCursor(hOldCursor);

                    switch(rc)
                    {
                    case 1:
                        gProj.fTargetEXE = IsExe( gProj.szBld);
                        gProj.fSourceEXE = IsExe( gMstr.szSrc);
                        fPrjChanges = FALSE;
                        sprintf( sz, "%s - %s", szAppName, gProj.szBld);
                        SetWindowTextA(hWnd,sz);
                        break;

                    case (WORD)-1:
                        lstrcpyA( gProj.szBld, gMstr.szSrc);
                        LoadStrIntoAnsiBuf(hInst, IDS_RLQ_CANTSAVEASRES, sz, sizeof(sz));
                        MessageBoxA( NULL, sz, gProj.szBld, MB_ICONHAND|MB_OK);
                        break;

                    case (WORD)-2:
                        lstrcpyA( gProj.szBld, gMstr.szSrc);
                        LoadStrIntoAnsiBuf(hInst, IDS_RLQ_CANTSAVEASEXE, sz, sizeof(sz));
                        MessageBoxA( NULL, sz, gProj.szBld,MB_ICONHAND|MB_OK);
                        break;
                    }
                    return(TRUE);
                }
                // no project changes to save
            }
            return TRUE;
        }
        break;

    case WM_SAVETOKENS:

        if ( fTokChanges )
        {
            if (f = FOPEN(gProj.szTok, "wt"))
            {
                SaveTokList(hWnd, f);
                FCLOSE(f);
                fTokChanges = FALSE;
                fPrjChanges = TRUE;
            }
            else
            {
                LoadStrIntoAnsiBuf( hInst, IDS_FILESAVEERR, szDHW, DHWSIZE);
                MessageBoxA( hWnd,
                             szDHW,
                             gProj.szTok,
                             MB_ICONHAND | MB_OK);
                return FALSE;
            }
        }
        return TRUE;                    // everything saved ok

    case WM_DROPFILES:
        {
            CHAR sz[MAXFILENAME] = "";

#ifndef CAIRO
            DragQueryFileA((HDROP) wParam, 0, sz, MAXFILENAME);
#else
            DragQueryFile((HDROP) wParam, 0, sz, MAXFILENAME);
#endif
            LoadNewFile(sz);
            DragFinish((HDROP) wParam);
            return(TRUE);
        }

    default:
        break;
    }

    return (DefWindowProc(hWnd, wMsg, wParam, lParam));
}

/**
  *  Function: DoListBoxCommand
  *     Processes the messages sent to the list box. If the message is
  *     not reconized as a list box message, it is ignored and not processed.
  *     As the user scrolls through the tokens WM_UPDSTATLINE messages are
  *     sent to the status window to indicate the current selected token.
  *     The list box goes into Edit Mode by  pressing the enter key, or
  *     by double clicking on the list box.  After the edit is done, a WM_TOKEDIT
  *     message is sent back to the list box to update the token. The
  *     list box uses control ID IDC_LIST.
  *
  *  Arguments:
  *     wMsg    List Box message ID
  *     wParam  Either IDC_LIST, or VK_RETURN depending on wMsg
  *     lParam  LPTSTR to selected token during WM_TOKEDIT message.
  *
  *  Returns:
  *
  *  Errors Codes:
  *     TRUE.  Message processed.
  *     FALSE. Message not processed.
  *
  *  History:
  *     01/92 Implemented.      TerryRu.
  *     01/92 Fixed problem with DblClick, and Enter processing.    TerryRu.
  *
  **/

INT_PTR DoListBoxCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    TOKEN   tok;                        // structure to hold token read from token list
    LPTSTR  lpstrBuffer;
    CHAR    szTmpBuf[32] = "";
    TCHAR   szName[32] = TEXT("");      // buffer to hold token name
    TCHAR   szID[7] = TEXT("");         // buffer to hold token id
    TCHAR   sz[256] = TEXT("");         // buffer to hold messages
    static  UINT wIndex;
    LONG    lListParam = 0L;

    // this is the WM_COMMAND

    switch (wMsg)
    {
    case WM_TRANSLATE:
        {
            // Message sent by TokEditDlgProc to build a translation list
            HWND hDlgItem = NULL;
            int cTextLen  = 0;
            TCHAR *szKey  = NULL;
            TCHAR *szText = NULL;

            hDlgItem = GetDlgItem( hTokEditDlgWnd, IDD_TOKPREVTRANS);
            cTextLen = GetWindowTextLength( hDlgItem);
            szKey    = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
            szKey[0] = TEXT('\0');
            GetDlgItemText( hTokEditDlgWnd,
                            IDD_TOKPREVTRANS,
                            szKey,
                            cTextLen+1);

            hDlgItem = GetDlgItem( hTokEditDlgWnd, IDD_TOKCURTRANS);
            cTextLen = GetWindowTextLength( hDlgItem);
            szText = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
            szText[0] = TEXT('\0');
            GetDlgItemText( hTokEditDlgWnd,
                            IDD_TOKCURTRANS,
                            szText,
                            cTextLen + 1);

            TransString( szKey, szText, &pTransList, lFilePointer);
            RLFREE( szKey);
            RLFREE( szText);
            return TRUE;
        }

    case WM_TOKEDIT:
        {
            TCHAR *szBuffer = NULL;
            int    cTextLen = 0;
            // Message sent by TokEditDlgProc to
            // indicate change in the token text.
            // Response to the message by inserting
            // new token text into list box

            // Insert the selected token into token struct

            HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                 LB_GETITEMDATA,
                                                 (WPARAM)wIndex,
                                                 (LPARAM)0);
            lpstrBuffer = (LPTSTR)GlobalLock( hMem);

            if ( ! lpstrBuffer )
            {
                QuitA( IDS_ENGERR_11, NULL, NULL);
            }

            cTextLen = lstrlen( lpstrBuffer);
            szBuffer = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
            lstrcpy( szBuffer, lpstrBuffer);
            GlobalUnlock( hMem);
            ParseBufToTok( szBuffer, &tok);
            RLFREE( szBuffer);
            RLFREE( tok.szText);

            // Copy new token text from edit box into the token struct
            cTextLen = lstrlen( (LPTSTR)lParam);
            tok.szText = (LPTSTR)FALLOC( MEMSIZE( cTextLen + 1));
            lstrcpy( tok.szText, (LPTSTR)lParam);
            RLFREE( (void *)lParam);

            // Mark token as clean

#ifdef  RLWIN32
            tok.wReserved = (WORD) ST_TRANSLATED;
#else
            tok.wReserved = ST_TRANSLATED;
#endif
            szBuffer = (TCHAR *)FALLOC( MEMSIZE( TokenToTextSize( &tok) + 1));
            ParseTokToBuf( szBuffer, &tok);
            RLFREE( tok.szText);

            // Now remove old token
            SendMessage( hListWnd, WM_SETREDRAW,    (WPARAM)FALSE,  (LPARAM)0);
            SendMessage( hListWnd, LB_DELETESTRING, (WPARAM)wIndex, (LPARAM)0);

            // Replacing with the new token
            hMem = GlobalAlloc( GMEM_ZEROINIT, MEMSIZE( lstrlen( szBuffer) + 1));
            lpstrBuffer = (LPTSTR)GlobalLock( hMem);
            lstrcpy( lpstrBuffer, szBuffer);
            GlobalUnlock( hMem);
            RLFREE( szBuffer);

            SendMessage( hListWnd,
                         LB_INSERTSTRING,
                         (WPARAM)wIndex,
                         (LPARAM)hMem);

            // Now put focus back on the current string
            SendMessage( hListWnd, LB_SETCURSEL, (LPARAM)wIndex, (LPARAM)0);
            SendMessage( hListWnd, WM_SETREDRAW, (WPARAM)TRUE,   (LPARAM)0);
            InvalidateRect( hListWnd, NULL, TRUE);

            return TRUE;

        }

    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        {
#ifdef RLWIN16
            LPARAM lListParam = 0;
#endif
            // Messages sent to list box when   keys are depressed.
            // Check for Return key pressed.

            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
            case VK_RETURN:
#ifdef RLWIN16
                lListParam = (LPARAM) MAKELONG( 0, LBN_DBLCLK);
                SendMessage( hMainWnd, WM_COMMAND, (WPARAM)IDC_LIST, lListParam);
#else
                SendMessage( hMainWnd,
                             WM_COMMAND,
                             MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                             (LPARAM)0);
#endif
                return TRUE;

            default:
                break;
            }
            break;
        }

    case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDC_LIST:
                {
                    /*
                     *
                     * This is where we process the list box messages.
                     * The TokEditDlgProc is used to
                     * edit the token selected in LBS_DBLCLK message
                     *
                     */
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                    case (UINT) LBN_ERRSPACE:

                        LoadString( hInst,
                                    IDS_ERR_NO_MEMORY,
                                    sz,
                                    TCHARSIN( sizeof( sz)));
                        MessageBox( hWnd,
                                    sz,
                                    tszAppName,
                                    MB_ICONHAND | MB_OK);
                        return TRUE;

                    case LBN_DBLCLK:
                        {
                            LPTSTR CurText = NULL;
                            LPTSTR PreText = NULL;
                            TCHAR szResIDStr[20] = TEXT("");
                            TCHAR *szBuffer;
                            HGLOBAL hMem = NULL;

                            wIndex = (UINT)SendMessage( hListWnd,
                                                        LB_GETCURSEL,
                                                        (WPARAM)0,
                                                        (LPARAM)0);
                            if (wIndex == (UINT) -1)
                            {
                                return TRUE;
                            }

                            // double click, or Return entered, go into token edit mode.
                            if (!hTokEditDlgWnd)
                            {
                                // set up modaless dialog box to edit token
#ifdef RLWIN32
                                hTokEditDlgWnd = CreateDialog (hInst,
                                                               TEXT("RLQuikEd"),
                                                               hWnd,
                                                               TokEditDlgProc);
#else
                                lpTokEditDlg =
                                    (FARPROC) MakeProcInstance(TokEditDlgProc,
                                                               hInst);

                                hTokEditDlgWnd = CreateDialog(hInst,
                                                              TEXT("RLQuikEd"),
                                                              hWnd,
                                                              lpTokEditDlg);
#endif

                            }

                            // Get token info from listbox, and place in token struct
                            hMem = (HGLOBAL)SendMessage( hListWnd,
                                                         LB_GETITEMDATA,
                                                         (WPARAM)wIndex,
                                                         (LPARAM)0);
                            lpstrBuffer = (LPTSTR)GlobalLock( hMem);
                            szBuffer = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrBuffer) +1));
                            lstrcpy(szBuffer, lpstrBuffer);
                            GlobalUnlock( hMem);
                            ParseBufToTok(szBuffer, &tok);
                            RLFREE( szBuffer);

                            // Now get the token name
                            // Its either a string, or ordinal number

                            if ( tok.szName[0] )
                            {
                                lstrcpy( szName, tok.szName);
                            }
                            else
                            {
#ifdef UNICODE
                                _itoa(tok.wName, szTmpBuf, 10);
                                _MBSTOWCS( szName,
                                           szTmpBuf,
                                           WCHARSIN( sizeof( szName)),
                                           ACHARSIN( strlen( szTmpBuf) + 1));
#else
                                _itoa( tok.wName, szName, 10);
#endif
                            }


                            // Now do the ID string
#ifdef UNICODE

                            _itoa( tok.wID, szTmpBuf, 10);
                            _MBSTOWCS( szID,
                                       szTmpBuf,
                                       WCHARSIN( sizeof( szID)),
                                       ACHARSIN( strlen( szTmpBuf) + 1));
#else
                            _itoa( tok.wID, szID, 10);
#endif

                            if ( tok.wType <= 16 || tok.wType == ID_RT_DLGINIT )
                            {
                                LoadString( hInst,
                                            IDS_RESOURCENAMES+tok.wType,
                                            szResIDStr,
                                            TCHARSIN( sizeof( szResIDStr)));
                            }
                            else
                            {
#ifdef UNICODE
                                _itoa(tok.wType, szTmpBuf, 10);
                                _MBSTOWCS( szResIDStr,
                                           szTmpBuf,
                                           WCHARSIN( sizeof( szResIDStr)),
                                           ACHARSIN( strlen( szTmpBuf) + 1));
#else
                                _itoa( tok.wType, szResIDStr, 10);
#endif
                            }
                            // Now insert token info  in TokEdit Dialog Box
                            SetDlgItemText( hTokEditDlgWnd,
                                            IDD_TOKTYPE,
                                            (LPTSTR) szResIDStr);
                            SetDlgItemText( hTokEditDlgWnd,
                                            IDD_TOKNAME,
                                            (LPTSTR) szName);
                            SetDlgItemText( hTokEditDlgWnd,
                                            IDD_TOKID,
                                            (LPTSTR) szID);
                            SetDlgItemText( hTokEditDlgWnd,
                                            IDD_TOKCURTRANS,
                                            (LPTSTR) tok.szText);
                            SetDlgItemText( hTokEditDlgWnd,
                                            IDD_TOKPREVTRANS,
                                            (LPTSTR) tok.szText);
                            RLFREE( tok.szText);

                            SendMessage( hMainWnd,
                                         WM_TRANSLATE,
                                         (WPARAM)0,
                                         (LPARAM)0);
                            SetActiveWindow(hTokEditDlgWnd);
                            wIndex = (UINT)SendMessage( hListWnd,
                                                        LB_GETCURSEL,
                                                        (WPARAM)0,
                                                        (LPARAM)0);
                            return TRUE;
                        }

                    default:
                        // let these messages fall through,
                        break;
                    }
                }

            default:
                return FALSE;
            }

        }

        break;              // WM_COMMAND Case
    }
    return FALSE;

}

/**
 *  Function: DoMenuCommand.
 *   Processes the Menu Command messages.
 *
 *  Errors Codes:
 *   TRUE. Message processed.
 *   FALSE. Message not processed.
 *
 *  History:
 *   01/92. Implemented.       TerryRu.
 *
 **/

INT_PTR DoMenuCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fListBox = FALSE;
    CHAR sz[256] = "";
    BOOL    fRC  = TRUE;


    sz[0] = 0;
    // Commands entered from the application menu, or child windows.
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
    case IDM_P_OPEN:

        if ( GetFileNameFromBrowse( hWnd,
                                    sz,
                                    MAXFILENAME,
                                    szOpenDlgTitle,
                                    szFilterSpec,
                                    ".EXE") )
        {
            LoadNewFile( sz);
            strcpy( gProj.szBld, gMstr.szSrc);
        }

        break;

    case IDM_P_SAVE:

        SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0);
        break;

    case IDM_P_SAVEAS:
        {
            CHAR szOldName[MAXFILENAME] = "";

            strcpy( szOldName, gProj.szBld);
            gProj.szBld [0] = 0;    // force user to enter a name
            fPrjChanges = TRUE;     // force project to be saved

            if ( ! SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
            {
                // restore the name
                strcpy( gProj.szBld, szOldName);
            }
            break;
        }

    case IDM_P_CLOSE:
        {
            HMENU hMenu;
            hMenu=GetMenu(hWnd);

            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
            {
                int i;
                // Remove file name from window title
                SetWindowText(hMainWnd, tszAppName);

                // Remove the current token list
                SendMessage( hListWnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
                CleanDeltaList();

                // Hide token list since it\'s empty
                ShowWindow(hListWnd, SW_HIDE);

                // Force Repaint of status Window
                InvalidateRect(hStatusWnd, NULL, TRUE);

                EnableMenuItem(hMenu, IDM_P_CLOSE,    MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_P_SAVE,     MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_P_SAVEAS,   MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FIND,     MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FINDUP,   MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FINDDOWN, MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_COPY,     MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_PASTE,    MF_GRAYED|MF_BYCOMMAND);

                for (i = IDM_FIRST_EDIT; i <= IDM_LAST_EDIT;i++)
                {
                    EnableMenuItem(hMenu, i, MF_GRAYED|MF_BYCOMMAND);
                }
            }
            break;
        }

    case IDM_P_EXIT:
        // send wm_close message to main window
        if (hMainWnd)
        {
            PostMessage(hMainWnd, WM_CLOSE, (WPARAM)0, (LPARAM)0); //bugbug??
        }
        return FALSE;
        break;

    case IDM_E_COPY:
        {
            HGLOBAL hStringMem  = NULL;
            LPTSTR  lpstrBuffer = NULL;
            LPTSTR  lpString    = NULL;
            TCHAR  *szString    = NULL;
            int nIndex  = 0;
            int nLength = 0;
            int nActual = 0;
            TOKEN   tok;

            // Is anything selected in the listbox
            if ( (nIndex = (int)SendMessage( hListWnd,
                                             LB_GETCURSEL,
                                             (WPARAM)0,
                                             (LPARAM)0)) != LB_ERR )
            {
                HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                     LB_GETITEMDATA,
                                                     (WPARAM)nIndex,
                                                     (LPARAM)0);
                lpstrBuffer = (LPTSTR)GlobalLock( hMem);
                szString = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrBuffer )+ 1));
                lstrcpy( szString, lpstrBuffer);
                GlobalUnlock( hMem);
                ParseBufToTok( szString, &tok);
                RLFREE( szString);

                nLength = lstrlen( tok.szText) + 1;

                // Allocate memory for the string
                hStringMem = GlobalAlloc( GHND, (DWORD)MEMSIZE( nLength));

                if ( hStringMem != NULL )
                {
                    if ( (lpString = GlobalLock( hStringMem)) != NULL )
                    {
#ifdef UNICODE
                        UINT uTextType = CF_UNICODETEXT;
#else
                        UINT uTextType = CF_TEXT;
#endif
                        // Get the selected text
                        lstrcpy( lpString, tok.szText);

                        // Unlock the block
                        GlobalUnlock( hStringMem);

                        // Open the Clipboard and clear its contents
                        OpenClipboard( hWnd);
                        EmptyClipboard();

                        // Give the Clipboard the text data

                        SetClipboardData( uTextType, hStringMem);

                        CloseClipboard();

                        hStringMem = NULL;
                    }
                    else
                    {
                        LoadStringA( hInst, IDS_ERR_NO_MEMORY, szDHW, DHWSIZE);
                        MessageBoxA( hWnd,
                                     szDHW,
                                     szAppName,
                                     MB_ICONHAND | MB_OK);
                    }
                }
                else
                {
                    LoadStringA( hInst, IDS_ERR_NO_MEMORY, szDHW, DHWSIZE);
                    MessageBoxA( hWnd,
                                 szDHW,
                                 szAppName,
                                 MB_ICONHAND | MB_OK);
                }
                RLFREE( tok.szText);
            }
            break;
        }

    case IDM_G_GLOSS:

        if ( GetFileNameFromBrowse( hWnd,
                                    gProj.szGlo,
                                    MAXFILENAME,
                                    szOpenDlgTitle,
                                    szGlossFilterSpec,
                                    NULL) )
        {
            OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};
                                                 // file exists?
            if ( OpenFile( gProj.szGlo, &Of, OF_EXIST) != HFILE_ERROR )
            {                                    // Yes
                HCURSOR hOldCursor = SetCursor( hHourGlass);

                MakeGlossIndex( lFilePointer);
                SetCursor( hOldCursor);
            }
            else
            {
                gProj.szGlo[0] = 0;
            }
        }
        break;

    case IDM_E_PASTE:

        if ( fTokFile && OpenClipboard( hWnd) )
        {
            UINT    puFormat[]  = { CF_TEXT, CF_OEMTEXT, CF_UNICODETEXT };
            int     nType   = GetPriorityClipboardFormat( puFormat, 3);


                    // Check for current position and change that token's text

            if ( nType != 0 && nType != -1 )
            {
                HGLOBAL hClipMem    = NULL;
                HGLOBAL hMem        = NULL;
                LPTSTR  lpstrBuffer = NULL;
                LPTSTR  lpClipMem   = NULL;
                TCHAR   *szString   = NULL;
                TOKEN   tok;
#ifdef UNICODE
                UINT    uWantType = CF_UNICODETEXT;
#else
                UINT    uWantType = CF_TEXT;
#endif
                int     nLength = 0;
                WPARAM  wIndex  = (WPARAM)SendMessage( hListWnd,
                                                       LB_GETCURSEL,
                                                       (WPARAM)0,
                                                       (LPARAM)0);

                if ( wIndex == LB_ERR )
                {
#if defined(UNICODE)
                     break;
#else // not UNICODE
		    wIndex = (WPARAM)-1;
#endif // UNICODE
                }
                hClipMem  = GetClipboardData( uWantType);
                lpClipMem = (LPTSTR)GlobalLock( hClipMem);

                hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             wIndex,
                                             (LPARAM)0);
                lpstrBuffer = (LPTSTR)GlobalLock( hMem);
                szString = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrBuffer) + 1));
                lstrcpy( szString, lpstrBuffer);
                GlobalUnlock( hMem);
                    // copy the string to the token
                ParseBufToTok( szString, &tok);
                RLFREE( szString);
                RLFREE( tok.szText);
                tok.szText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpClipMem) + 1));
                lstrcpy( tok.szText, lpClipMem);
                GlobalUnlock( hClipMem);

                szString = (TCHAR *)FALLOC( MEMSIZE( TokenToTextSize( &tok)+ 1));
                ParseTokToBuf( szString, &tok);
                RLFREE( tok.szText);

                    // Paste the text
                SendMessage( hListWnd,
                             WM_SETREDRAW,
                             (WPARAM)FALSE,
                             (LPARAM)0);
                SendMessage( hListWnd,
                             LB_DELETESTRING,
                             wIndex,
                             (LPARAM)0);

                hMem = GlobalAlloc( GMEM_ZEROINIT,
                                    MEMSIZE( lstrlen( szString) + 1));
                lpstrBuffer = (LPTSTR)GlobalLock( hMem);
                lstrcpy( lpstrBuffer, szString);
                GlobalUnlock( hMem);
                RLFREE( szString);

                SendMessage( hListWnd,
                             LB_INSERTSTRING,
                             wIndex,
                             (LPARAM)hMem);
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             wIndex,
                             (LPARAM)0);
                SendMessage( hListWnd,
                             WM_SETREDRAW,
                             (WPARAM)TRUE,
                             (LPARAM)0);
                InvalidateRect( hListWnd, NULL, TRUE);
                fTokChanges = TRUE; // Set Dirty Flag

                                // Close the Clipboard
                CloseClipboard();

                SetFocus( hListWnd);
            }
        }
        CloseClipboard();
        break;

    case IDM_E_FINDDOWN:

        if ( fSearchStarted )
        {
            if ( ! DoTokenSearch( szSearchType,
                                  szSearchText,
                                  wSearchStatus,
                                  wSearchStatusMask,
                                  0,
                                  TRUE) )
            {
                TCHAR sz1[80] = TEXT("");
                TCHAR sz2[80] = TEXT("");

                LoadString( hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWnd,
                            sz2,
                            sz1,
                            MB_ICONINFORMATION | MB_OK);
            }
            break;
        }               //... ELSE fall thru

    case IDM_E_FINDUP:

        if ( fSearchStarted )
        {
            if ( ! DoTokenSearch( szSearchType,
                                  szSearchText,
                                  wSearchStatus,
                                  wSearchStatusMask,
                                  1,
                                  TRUE) )
            {
                TCHAR sz1[80] = TEXT("");
                TCHAR sz2[80] = TEXT("");

                LoadString (hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWnd,
                            sz2,
                            sz1,
                            MB_ICONINFORMATION | MB_OK);
            }
            break;
        }               //... ELSE fall thru

    case IDM_E_FIND:
        {
#ifndef RLWIN32
            WNDPROC lpfnTOKFINDMsgProc;

            lpfnTOKFINDMsgProc = MakeProcInstance((WNDPROC)TOKFINDMsgProc, hInst);

            if (!DialogBox(hInst, TEXT("TOKFIND"), hWnd, lpfnTOKFINDMsgProc))
#else
            if (!DialogBox(hInst, TEXT("TOKFIND"), hWnd, TOKFINDMsgProc))
#endif
                {

#ifndef DBCS
// 'Token Not Found' is strange because user selected cancel
                    TCHAR sz1[80] = TEXT("");
		    TCHAR sz2[80] = TEXT("");

                    LoadString( hInst,
                                IDS_TOKEN_NOT_FOUND,
                                sz2,
                                TCHARSIN( sizeof( sz2)));
                    LoadString( hInst,
                                IDS_FIND_TOKEN,
                                sz1,
                                TCHARSIN( sizeof( sz1)));
                    MessageBox( hWnd,
                                sz2,
                                sz1,
                                MB_ICONINFORMATION | MB_OK);
#endif    //DBCS

                }
#ifndef RLWIN32
            FreeProcInstance( lpfnTOKFINDMsgProc);
#endif
            return TRUE;
        }

    case IDM_H_CONTENTS:
    {
        OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

        if ( OpenFile( gszHelpFile, &Of, OF_EXIST) == HFILE_ERROR )
        {
            LoadStringA( hInst, IDS_ERR_NO_HELP , szDHW, DHWSIZE);
            MessageBoxA( hWnd, szDHW, gszHelpFile, MB_OK);
        }
        else
        {
            WinHelpA( hWnd, gszHelpFile, HELP_KEY, (LPARAM)(LPSTR)"RLQuikEd");
        }
        break;
    }

    case IDM_H_ABOUT:
        {

#ifndef RLWIN32

            WNDPROC lpProcAbout;

            lpProcAbout = MakeProcInstance(About, hInst);
            DialogBox(hInst, TEXT("ABOUT"), hWnd, lpProcAbout);
            FreeProcInstance(lpProcAbout);
#else
            DialogBox(hInst, TEXT("ABOUT"), hWnd, About);
#endif
            break;
        }
        break;

    default:

        if (wParam <= IDM_LAST_EDIT && wParam >= IDM_FIRST_EDIT)
        {
            // USER IS INVOKING AN EDITOR
            if ( LoadStrIntoAnsiBuf(hInst, (UINT)wParam, szEditor, sizeof(szEditor)) )
            {
                if ( SendMessage( hWnd, WM_SAVETOKENS, (WPARAM)0, (LPARAM)0) )
                {
                    HCURSOR hOldCursor;

                    hOldCursor = SetCursor(hHourGlass);
                    MyGetTempFileName(0, "RES", 0, szTempRes);
			        fInThirdPartyEditer = TRUE;

                    if (gProj.fSourceEXE)
                    {
                        // we need to first extract the .RES from the .EXE
                        CHAR sz[MAXFILENAME] = "";
                        MyGetTempFileName(0, "RES", 0, sz);
                        ExtractResFromExe32A( gMstr.szSrc, sz, 0);
                        GenerateRESfromRESandTOKandRDFs( szTempRes,
                                                         sz,
                                                         gProj.szTok,
                                                         gMstr.szRdfs,
                                                         ID_RT_DIALOG);
                        remove(sz);
                    }
                    else
                    {
                        GenerateRESfromRESandTOKandRDFs( szTempRes,
                                                         gMstr.szSrc,
                                                         gProj.szTok,
                                                         gMstr.szRdfs,
                                                         ID_RT_DIALOG);
                    }
                    SetCursor( hOldCursor);
                    ExecResEditor( hWnd, szEditor, szTempRes,  "");
                }
            }
        }
        break;                          // default
    }
    return( FALSE);
}


#ifdef RLWIN16
static int ExecResEditor(HWND hWnd, CHAR *szEditor, CHAR *szFile, CHAR *szArgs)
{
    CHAR szExecCmd[256] = "";
    int  RetCode;

    // generate command line
    strcpy(szExecCmd, szEditor);
    lstrcat(szExecCmd, " ");
    lstrcat(szExecCmd, szArgs);
    lstrcat(szExecCmd, " ");
    lstrcat(szExecCmd, szFile);

    lpfnWatchTask = MakeProcInstance(WatchTask, hInst);
    NotifyRegister(NULL, lpfnWatchTask, NF_NORMAL);
    fWatchEditor = TRUE;

    // exec resource editor
    RetCode = WinExec(szExecCmd, SW_SHOWNORMAL);

    if (RetCode > 31)
    {
        // successful execution
        ShowWindow(hWnd,SW_HIDE);
    }
    else
    {
        // unsuccessful execution
        TCHAR sz[80] = TEXT("");
        NotifyUnRegister(NULL);
        FreeProcInstance(lpfnWatchTask);
        remove(szFile);
        fInThirdPartyEditer = FALSE;
        SendMessage(hWnd, WM_LOADTOKENS, 0, 0);
        LoadString(hInst, IDS_GENERALFAILURE, sz, CHARSIZE( sz));
    }
    return RetCode;
}
#endif

#ifdef RLWIN32
static int ExecResEditor(HWND hWnd, CHAR *szEditor, CHAR *szFile, CHAR *szArgs)
{
    TCHAR  wszExecCmd[256] = TEXT("");
    CHAR   szExecCmd[256] = "";
    DWORD  dwRetCode;
    DWORD  dwExitCode;
    BOOL   fSuccess;
    BOOL   fExit = FALSE;

    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO     StartupInfo;

    StartupInfo.cb          = sizeof( STARTUPINFO);
    StartupInfo.lpReserved  = NULL;
    StartupInfo.lpDesktop   = NULL;
    StartupInfo.lpTitle     = TEXT("Resize Dialogs");
    StartupInfo.dwX         = 0L;
    StartupInfo.dwY         = 0L;
    StartupInfo.dwXSize     = 0L;
    StartupInfo.dwYSize     = 0L;
    StartupInfo.dwFlags     = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = SW_SHOWDEFAULT;
    StartupInfo.lpReserved2 = NULL;
    StartupInfo.cbReserved2 = 0;

    //  generate command line
    strcpy(szExecCmd, szEditor);
    strcat(szExecCmd, " ");
    strcat(szExecCmd, szArgs);
    strcat(szExecCmd, " ");
    strcat(szExecCmd, szFile);


#ifdef UNICODE
    _MBSTOWCS( wszExecCmd,
               szExecCmd,
               WCHARSIN( sizeof( wszExecCmd)),
               ACHARSIN( strlen( szExecCmd) + 1));
#else
    strcpy(wszExecCmd, szExecCmd);
#endif

    fSuccess = CreateProcess( NULL,
                              wszExecCmd,
                              NULL,
                              NULL,
                              FALSE,
                              NORMAL_PRIORITY_CLASS,
                              NULL,
                              NULL,
                              &StartupInfo,
                              &ProcessInfo);
    /* try to create a process */

    if ( fSuccess )
    {
        //  wait for the editor to complete */

        dwRetCode = WaitForSingleObject(ProcessInfo.hProcess, 0xFFFFFFFF) ;

        if (!dwRetCode)
        {
            // editor terminated, check exit code
            fExit = GetExitCodeProcess(ProcessInfo.hProcess, &dwExitCode) ;
        }
        else
        {
            fExit = FALSE;
        }

        if (fExit)
        {

            // successful execution
            ShowWindow(hWnd,SW_HIDE);
            PostMessage(hMainWnd,WM_EDITER_CLOSED,0,0);
        }
        else
        {
            // unsuccessful execution
            remove(szFile);
	        fInThirdPartyEditer = FALSE;
            SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
            LoadStrIntoAnsiBuf( hInst, IDS_GENERALFAILURE, szDHW, DHWSIZE);
            MessageBoxA( hWnd, szDHW, szEditor, MB_ICONSTOP|MB_OK);
        }

        // close the editor object  handles

        CloseHandle(ProcessInfo.hThread) ;
        CloseHandle(ProcessInfo.hProcess) ;
    }
	else
	{
		dwRetCode = GetLastError();		// not used - debugging only (so far)
        fExit = FALSE;
	}

    return fExit;
}
#endif

/**
 *  Function: WatchTask
 *    A callback function installed by a NotifyRegister function.
 *    This function is installed by the dialog editer command and is used
 *    to tell RLQuikEd when the dialog editer has been closed by the user.
 *
 *    To use this function, set fWatchEditor to TRUE and install this
 *    callback function by using NotifyRegister.  The next task initiated
 *    \(in our case via a WinExec call\) will be watched for termination.
 *
 *    When WatchTask sees that the task being watched has terminated it
 *    posts a WM_EDITER_CLOSED message to RLQuikEds main window.
 *
 *  History:
 *    2/92, implemented    SteveBl
 */
#ifdef RLWIN16
static BOOL PASCAL _loadds  WatchTask(WORD wID,DWORD dwData)
{
    static HTASK htWatchedTask;
    static BOOL fWatching = FALSE;

    switch (wID)
    {
    case NFY_STARTTASK:
        if (fWatchEditor)
        {
            htWatchedTask = GetCurrentTask();
            fWatching = TRUE;
            fWatchEditor = FALSE;
        }
        break;
    case NFY_EXITTASK:
        if (fWatching)
        {
            if (GetCurrentTask() == htWatchedTask)
            {
                PostMessage(hMainWnd,WM_EDITER_CLOSED,0,0);
                fWatching = FALSE;
            }
        }
        break;
    }
    return FALSE;
}

#endif

/**
 *
 *
 *  Function:  TokEditDlgProc
 *     Procedure for the edit mode dialog window. Loads the selected token
 *     info into the window, and allows the user to change the token text.
 *     Once the edit is complete, the procedure sends a message to the
 *     list box windows to update the current token info.
 *
 *
 *  Arguments:
 *
 *  Returns:  NA.
 *
 *  Errors Codes:
 *     TRUE, carry out edit, and update token list box.
 *     FALSE, cancel edit.
 *
 *  History:
 *
 *
 **/

#ifdef RLWIN32
INT_PTR CALLBACK TokEditDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
#else
static BOOL APIENTRY TokEditDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
#endif
{
    HWND    hCtl;
    HWND    hParentWnd;
//    TCHAR   *szTokTextBuf;
    UINT    static wcTokens = 0;
    UINT    wNotifyCode;
    UINT    wIndex;

    switch(wMsg)
    {
    case WM_INITDIALOG:

        cwCenter(hDlg, 0);
        wcTokens = (UINT)SendMessage( hListWnd,
                                      LB_GETCOUNT,
                                      (WPARAM)0,
                                      (LPARAM)0);
        wcTokens--;

        // only allow skip button if in update mode

        // disallow auto translate if we don\'t have a glossary file
        if (*gProj.szGlo == '\0')
        {
            hCtl = GetDlgItem(hDlg, IDD_TRANSLATE);

            if (hCtl)
            {
                EnableWindow(hCtl, FALSE);
            }
            hCtl = GetDlgItem(hDlg, IDD_ADD);

            if (hCtl)
            {
                EnableWindow(hCtl, FALSE);
            }
        }
        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_TOKCURTRANS:

            wNotifyCode = GET_WM_COMMAND_CMD(wParam, lParam);
            hCtl = GET_WM_COMMAND_HWND(wParam, lParam);

            if (wNotifyCode == EN_CHANGE)
            {
                hCtl = GetDlgItem(hDlg, IDOK);

                if (hCtl)
                {
                    EnableWindow(hCtl, TRUE);
                }
            }
            break;

        case IDD_ADD:
            {
                TCHAR *szUntranslated = NULL;
                TCHAR *szTranslated   = NULL;
                TCHAR *sz = NULL;
                TCHAR szMask[80]  = TEXT("");
                HWND hDlgItem     = NULL;
                int cCurTextLen   = 0;
                int cTotalTextLen = 0;

                cTotalTextLen = 80;
                hDlgItem       = GetDlgItem(hDlg, IDD_TOKPREVTRANS);
                cCurTextLen    = GetWindowTextLength( hDlgItem);
                cTotalTextLen += cCurTextLen;

                szTranslated = (TCHAR *)FALLOC( MEMSIZE( cCurTextLen + 1));

                GetDlgItemText( hDlg,
                                IDD_TOKPREVTRANS,
                                (LPTSTR)szUntranslated,
                                cCurTextLen + 1);

                hDlgItem       = GetDlgItem( hDlg, IDD_TOKCURTRANS);
                cCurTextLen    = GetWindowTextLength( hDlgItem);
                cTotalTextLen += cCurTextLen;
                szTranslated = (TCHAR *)FALLOC( MEMSIZE( cCurTextLen + 1));
                GetDlgItemText( hDlg,
                                IDD_TOKCURTRANS,
                                (LPTSTR)szTranslated,
                                cCurTextLen + 1);

                LoadString( hInst,
                            IDS_ADDGLOSS,
                            szMask,
                            TCHARSIN( sizeof( szMask)));

                sz = (TCHAR *)FALLOC( MEMSIZE( cTotalTextLen + 1));

                wsprintf( sz, szMask, szTranslated, szUntranslated);

                if ( MessageBox( hDlg,
                                 sz,
                                 tszAppName,
                                 MB_ICONQUESTION | MB_YESNO) == IDYES)
                {
                    HCURSOR hOldCursor = SetCursor( hHourGlass);

                    AddTranslation( szUntranslated,
                                    szTranslated,
                                    lFilePointer);

                    TransString( szUntranslated,
                                 szTranslated,
                                 &pTransList,
                                 lFilePointer);
                    SetCursor( hOldCursor);
                }
                RLFREE( sz);
                RLFREE( szTranslated);
                RLFREE( szUntranslated);
                break;
            }

        case IDD_TRANSLATE:

            // if \(!pTransList\)
            //    SendMessage\(hMainWnd, WM_TRANSLATE, \(WPARAM\) 0,\(LPARAM\) 0\);

            // Get next thing in the translation list

            if ( pTransList )
            {
                pTransList = pTransList->pNext;
                SetDlgItemText( hDlg, IDD_TOKCURTRANS, (LPTSTR)pTransList->sz);
            }
            break;

        case IDOK:
            {
                int cTokenTextLen;
                HWND hDlgItem;
                TCHAR *szTokenTextBuf;

                wIndex = (UINT)SendMessage( hListWnd,
                                            LB_GETCURSEL,
                                            (WPARAM)0,
                                            (LPARAM)0);
                fTokChanges = TRUE;

                // set flag to show token list has changed
                // Extract String from IDD_TOKTEXT edit control
                hDlgItem = GetDlgItem(hDlg, IDD_TOKCURTRANS);
                cTokenTextLen = GetWindowTextLength(hDlgItem);
                szTokenTextBuf = (TCHAR *)FALLOC( MEMSIZE( cTokenTextLen + 1));
                GetDlgItemText(hDlg,
                               IDD_TOKCURTRANS,
                               szTokenTextBuf,
                               cTokenTextLen+1);

                hParentWnd = GetParent(hDlg);
                SendMessage( hParentWnd,
                             WM_TOKEDIT,
                             (WPARAM)0,
                             (LPARAM)szTokenTextBuf);
                // Exit, or goto to next changed token if in update mode

                // fall through to IDCANCEL
            }

        case IDCANCEL:

            // remove edit dialog box

            if (hDlg)
            {
                DestroyWindow(hDlg);
            }
            hTokEditDlgWnd = 0;
#ifndef RLWIN32
            FreeProcInstance(lpTokEditDlg);
#endif
            break;

        }                               // GET_WM_COMMAND_ID
        return TRUE;

    default:

        hCtl = GetDlgItem(hDlg, IDOK);

        if (hCtl)
        {
            EnableWindow(hCtl, TRUE);
        }
        return FALSE;

    }                                   // Main Switch
}


/**
 *
 *  Function: TOKFINDMsgProc
 *
 *  Arguments:
 *
 *  Returns:
 *     NA.
 *
 *  Errors Codes:
 *
 *  History:
 *
 **/
#ifdef RLWIN32
INT_PTR CALLBACK TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
#else
static BOOL APIENTRY TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, UINT wParam, LONG lParam)
#endif
{
    HWND hCtl;

    int rgiTokenTypes[]=
    {
        ID_RT_MENU,
        ID_RT_DIALOG,
        ID_RT_STRING,
        ID_RT_ACCELERATORS,
        ID_RT_RCDATA,
        ID_RT_ERRTABLE,
        ID_RT_NAMETABLE,
        ID_RT_VERSION,
        ID_RT_DLGINIT
    };

    TCHAR szTokenType[20] = TEXT("");

    WORD  i;
    DWORD rc;

    switch(wMsg)
    {
    case WM_INITDIALOG:

        CheckDlgButton( hWndDlg, IDD_FINDDOWN, 1);
        hCtl = GetDlgItem( hWndDlg, IDD_TYPELST);

        for ( i = 0; i < sizeof( rgiTokenTypes) / sizeof( int); i++ )
        {
            LoadString( hInst,
                        IDS_RESOURCENAMES + rgiTokenTypes[i],
                        szTokenType,
                        TCHARSIN( sizeof( szTokenType)));
            rc = (DWORD)SendMessage( hCtl,
                              CB_ADDSTRING,
                              (WPARAM)0,
                              (LPARAM)szTokenType);
        }
        return TRUE;
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:                      /* Button text: "Okay"                */
            fSearchStarted = TRUE;
            GetDlgItemText(hWndDlg, IDD_TYPELST, szSearchType, 40);
            GetDlgItemText(hWndDlg, IDD_FINDTOK, szSearchText, 256);
            wSearchStatus = ST_TRANSLATED;
            wSearchStatusMask = ST_TRANSLATED ;

            fSearchDirection = IsDlgButtonChecked(hWndDlg, IDD_FINDUP);

            if( DoTokenSearch (szSearchType,
                               szSearchText,
                               wSearchStatus,
                               wSearchStatusMask,
                               fSearchDirection,
                               0) )
			{
				EndDialog( hWndDlg, TRUE );
			}
			else
			{
                TCHAR sz1[80], sz2[80];

                LoadString(hInst, IDS_FIND_TOKEN, sz1, sizeof(sz1));
                LoadString(hInst, IDS_TOKEN_NOT_FOUND, sz2, sizeof(sz2));
                MessageBox(hWndDlg, sz2, sz1, MB_ICONINFORMATION | MB_OK);
				EndDialog( hWndDlg, FALSE );
			}
            return TRUE;

        case IDCANCEL:
            /* and dismiss the dialog window returning FALSE   */
            EndDialog(hWndDlg, FALSE);
            return TRUE;
        }
        break;                          /* End of WM_COMMAND    */

    default:
        return FALSE;
    }
    return FALSE;
}

/**
 *  Function:
 *
 *  Arguments:
 *
 *  Returns:
 *
 *  Errors Codes:
 *
 *  History:
 **/
static void DrawLBItem(LPDRAWITEMSTRUCT lpdis)
{
    LPRECT lprc    = (LPRECT) &(lpdis->rcItem);
    DWORD  rgbOldText   = 0;
    DWORD  rgbOldBack   = 0;
    LPTSTR  lpstrToken;
    HBRUSH hBrush;
    static DWORD    rgbHighlightText;
    static DWORD    rgbHighlightBack;
    static HBRUSH   hBrushHilite = NULL;
    static HBRUSH   hBrushNormal = NULL;
    static DWORD    rgbBackColor;
    static DWORD    rgbCleanText;
    TCHAR  *szToken;
    TOKEN  tok;

    if (lpdis->itemAction & ODA_FOCUS)
    {
        DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
    }
    else
    {
        HANDLE hMem = (HANDLE)SendMessage( lpdis->hwndItem,
                                           LB_GETITEMDATA,
                                           (WPARAM)lpdis->itemID,
                                           (LPARAM)0);
        lpstrToken = (LPTSTR)GlobalLock( hMem);
        szToken = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
        lstrcpy( szToken,lpstrToken);
        GlobalUnlock( hMem);
        ParseBufToTok( szToken, &tok);
        RLFREE( szToken);

        if ( lpdis->itemState & ODS_SELECTED )
        {
            if (!hBrushHilite)
            {
                rgbHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                rgbHighlightBack = GetSysColor(COLOR_HIGHLIGHT);
                hBrushHilite = CreateSolidBrush(rgbHighlightBack);
            }

            MakeStatusLine(&tok);

            rgbOldText = SetTextColor(lpdis->hDC, rgbHighlightText);
            rgbOldBack = SetBkColor(lpdis->hDC, rgbHighlightBack);

            hBrush = hBrushHilite;
        }
        else
        {
            if (!hBrushNormal)
            {
                rgbBackColor = RGB(192,192,192);
                rgbCleanText = RGB(0,0,0);
                hBrushNormal = CreateSolidBrush(rgbBackColor);
            }
            rgbOldText = SetTextColor(lpdis->hDC, rgbCleanText);
            rgbOldBack = SetBkColor(lpdis->hDC,rgbBackColor);
            hBrush = hBrushNormal;
        }

        FillRect(lpdis->hDC, (CONST RECT *)lprc, hBrush);
        DrawText(lpdis->hDC,
                 tok.szText,
                 STRINGSIZE(lstrlen(tok.szText)),
                 lprc,
                 DT_LEFT|DT_NOPREFIX);

        RLFREE( tok.szText);

        if (rgbOldText)
        {
            SetTextColor(lpdis->hDC, rgbOldText);
        }
        if (rgbOldBack)
        {
            SetBkColor(lpdis->hDC, rgbOldBack);
        }

        if (lpdis->itemState & ODS_FOCUS)
        {
            DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
        }
    }
}

/************************************************************************
 *FUNCTION: SaveTokList(HWND, FILE *fpTokFile)                          *
 *                                                                      *
 *PURPOSE: Save current Token List                                      *
 *                                                                      *
 *COMMENTS:                                                             *
 *                                                                      *
 *This saves the current contents of the Token List                     *
 **********************************************************************/

static BOOL SaveTokList(HWND hWnd, FILE *fpTokFile)
{
    HCURSOR hSaveCursor   = NULL;
    BOOL    bSuccess      = TRUE;
    int     cTokenTextLen = 0;
    int     IOStatus      = 0;
    UINT    cTokens       = 0;
    UINT    cCurrentTok   = 0;
    CHAR   *szTokBuf      = NULL;
    TCHAR  *szTmpBuf      = NULL;
    LPTSTR  lpstrToken    = NULL;

    // Set the cursor to an hourglass during the file transfer

    hSaveCursor = SetCursor(hHourGlass);

    // Find number of tokens in the list

    cTokens = (UINT)SendMessage( hListWnd, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);

    if ( cTokens != LB_ERR )
    {
        for ( cCurrentTok = 0;
              bSuccess && (cCurrentTok < cTokens);
              cCurrentTok++)
        {
            // Get each token from list
            HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                 LB_GETITEMDATA,
                                                 (WPARAM)cCurrentTok,
                                                 (LPARAM)0);
            if ( hMem )
            {
                if ( (lpstrToken = (LPTSTR)GlobalLock( hMem)) != NULL )
                {
#ifdef UNICODE

                    cTokenTextLen = MEMSIZE( lstrlen(lpstrToken) + 1 );
                    szTmpBuf = (TCHAR *)FALLOC( cTokenTextLen );
                    szTokBuf = FALLOC( cTokenTextLen );
                    lstrcpy( szTmpBuf, lpstrToken);

                    _WCSTOMBS( szTokBuf, szTmpBuf, cTokenTextLen, lstrlen(szTmpBuf)+1);
                    cTokenTextLen = lstrlenA( szTokBuf );

                    RLFREE( szTmpBuf);
#else	//UNICODE
                    cTokenTextLen = lstrlen( lpstrToken);
                    szTokBuf =  FALLOC( cTokenTextLen + 1);
                    lstrcpy( szTokBuf, lpstrToken);
#endif
                    GlobalUnlock( hMem);
                    IOStatus = fprintf( fpTokFile, "%s\n", szTokBuf);
                    RLFREE( szTokBuf);

                    if ( IOStatus != (int)cTokenTextLen + 1 )
                    {
                        TCHAR szTmpBuf[256];

                        LoadString( hInst,
                                    IDS_FILESAVEERR,
                                    szTmpBuf,
                                    TCHARSIN( sizeof( szTmpBuf)));
                        MessageBox( hWnd,
                                    szTmpBuf,
                                    NULL,
                                    MB_OK | MB_ICONHAND);
                        bSuccess = FALSE;
                    }
                }
            }
        }
    }
    // restore cursor
    SetCursor(hSaveCursor);
    return( bSuccess);
}



/**
 * Function: CleanDeltaList
 *   frees the pTokenDeltaInfo list
 */
static void CleanDeltaList(void)
{
    TOKENDELTAINFO FAR *pTokNode;

    while (pTokNode = pTokenDeltaInfo)
    {
        pTokenDeltaInfo = pTokNode->pNextTokenDelta;
        RLFREE( pTokNode->DeltaToken.szText);
        RLFREE( pTokNode);

    }
}

/*
 * About -- message processor for about box
 *
 */

#ifdef RLWIN32

INT_PTR CALLBACK About(

HWND     hDlg,
unsigned message,
WPARAM   wParam,
LPARAM   lParam)

#else

static BOOL APIENTRY About(

HWND     hDlg,
unsigned message,
UINT     wParam,
LONG     lParam)

#endif
{
    switch( message )
    {
        case WM_INITDIALOG:
            {
                WORD wRC = SUCCESS;
                CHAR szModName[ MAXFILENAME];

                GetModuleFileNameA( hInst, szModName, sizeof( szModName));

                if ( (wRC = GetCopyright( szModName,
                                          szDHW,
                                          DHWSIZE)) == SUCCESS )
                {
                    SetDlgItemTextA( hDlg, IDC_COPYRIGHT, szDHW);
                }
                else
                {
                    ShowErr( wRC, NULL, NULL);
                }
            }
            break;

        case WM_COMMAND:

            switch ( GET_WM_COMMAND_ID(wParam, lParam) )
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    break;
            }
            break;

        default:

            return( FALSE);
    }
    return( TRUE);
}



#ifdef RLWIN32

/*
 * GetLangIDsProc -- message processor for getting language IDs
 *
 */

INT_PTR CALLBACK GetLangIDsProc(

HWND     hDlg,
unsigned message,
WPARAM   wParam,
LPARAM   lParam)
{
    switch( message )
    {
        case WM_INITDIALOG:
            {
                LPTSTR pszName = NULL;
                int nSel = 0;


                FillListAndSetLang( hDlg,
                                    IDD_MSTR_LANG_NAME,
                                    &gMstr.wLanguageID,
                                    NULL);

                FillListAndSetLang( hDlg,
                                    IDD_PROJ_LANG_NAME,
                                    &gProj.wLanguageID,
                                    NULL);

                CheckRadioButton( hDlg, IDC_REPLACE, IDC_APPEND, IDC_REPLACE);
            }
            break;

        case WM_COMMAND:

            switch( GET_WM_COMMAND_ID( wParam, lParam) )
            {
                case IDC_REPLACE:
                case IDC_APPEND:

                    CheckRadioButton( hDlg,
                                      IDC_REPLACE,
                                      IDC_APPEND,
                                      GET_WM_COMMAND_ID( wParam, lParam));
                    break;

                case IDD_MSTR_LANG_NAME:

                    if ( GET_WM_COMMAND_CMD( wParam, lParam) == CBN_SELENDOK )
                    {
                                //... Get the selected language name
                                //... then set the appropriate lang id vals

                        INT_PTR nSel = -1;

                        if ( (nSel = SendDlgItemMessage( hDlg,
                                                         IDD_MSTR_LANG_NAME,
                                                         CB_GETCURSEL,
                                                         (WPARAM)0,
                                                         (LPARAM)0)) != CB_ERR
                          && SendDlgItemMessage( hDlg,
                                                 IDD_MSTR_LANG_NAME,
                                                 CB_GETLBTEXT,
                                                 (WPARAM)nSel,
                                                 (LPARAM)(LPTSTR)szDHW) != CB_ERR )
                        {
                            WORD wPri = 0;
                            WORD wSub = 0;

                            if ( GetLangIDs( (LPTSTR)szDHW, &wPri, &wSub) )
                            {
                                gMstr.wLanguageID = MAKELANGID( wPri, wSub);
                            }
                        }
                    }
                    else
                    {
                        return( FALSE);
                    }
                    break;

                case IDD_PROJ_LANG_NAME:

                    if ( GET_WM_COMMAND_CMD( wParam, lParam) == CBN_SELENDOK )
                    {
                                //... Get the selected language name
                                //... then set the appropriate lang id vals

                        INT_PTR nSel = SendDlgItemMessage( hDlg,
                                                       IDD_PROJ_LANG_NAME,
                                                       CB_GETCURSEL,
                                                       (WPARAM)0,
                                                       (LPARAM)0);
                        if ( nSel != CB_ERR
                          && SendDlgItemMessage( hDlg,
                                                 IDD_PROJ_LANG_NAME,
                                                 CB_GETLBTEXT,
                                                 (WPARAM)nSel,
                                                 (LPARAM)(LPTSTR)szDHW) != CB_ERR )
                        {
                            WORD wPri = 0;
                            WORD wSub = 0;

                            if ( GetLangIDs( (LPTSTR)szDHW, &wPri, &wSub) )
                            {
                                gProj.wLanguageID = MAKELANGID( wPri, wSub);
                            }
                        }
                    }
                    else
                    {
                        return( FALSE);
                    }
                    break;

                case IDOK:
                {
                    gfReplace = IsDlgButtonChecked( hDlg, IDC_REPLACE);

                    EndDialog( hDlg, TRUE);
                    break;
                }

                case IDCANCEL:

                    EndDialog( hDlg, FALSE);
                    break;

                default:

                    return( FALSE);
            }
            break;

        default:

            return( FALSE);
    }
    return( TRUE);
}

#endif //RLWIN32



/*
 * Function:  Make Status Line
 *   Builds status line string from a token
 *
 * Inputs:
 *    pszStatusLine, buffer to hold string
 *    pTok, pointer to token structure
 *
 * History:
 *   3/92, implemented      SteveBl
 */

static void MakeStatusLine( TOKEN *pTok)
{
    TCHAR szName[32]       = TEXT("");
    TCHAR szResIDStr[20]   = TEXT("");
    static BOOL fFirstCall = TRUE;

    if ( pTok->szName[0] )
    {
        lstrcpy( szName, pTok->szName);
    }
    else
#ifdef UNICODE
    {
        char szTmpBuf[32] = "";

        _itoa(pTok->wName, szTmpBuf, 10);
        _MBSTOWCS( szName,
                   szTmpBuf,
                   WCHARSIN( sizeof( szName)),
                   ACHARSIN( strlen( szTmpBuf) + 1));
    }
#else
    {
        _itoa(pTok->wName, szName, 10);
    }
#endif

    if ( pTok->wType <= 16 || pTok->wType == ID_RT_DLGINIT )
    {
        LoadString( hInst,
                    IDS_RESOURCENAMES+pTok->wType,
                    szResIDStr,
                    TCHARSIN( sizeof( szResIDStr)));
    }
    else
    {
#ifdef UNICODE

        char szTmpBuf[40] = "";


        _WCSTOMBS( szTmpBuf,
                   szResIDStr,
                   ACHARSIN( sizeof( szTmpBuf)),
                   (UINT)-1);
        _itoa( pTok->wType, szTmpBuf, 10);
#else
        _itoa( pTok->wType, szResIDStr, 10);
#endif
    }

    if ( fFirstCall )
    {
        SendMessage( hStatusWnd,
                     WM_FMTSTATLINE,
                     (WPARAM)0,
                     (LPARAM)TEXT("15s10s5i5i"));
        fFirstCall = FALSE;
    }
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)0, (LPARAM)szName);
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)1, (LPARAM)szResIDStr);
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)2, (LPARAM)pTok->wID);
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)3,
                 (LPARAM)lstrlen(pTok->szText));
}


/**************************************************************************
 *Procedure: InsertQuikTokList                                          *
 *                                                                      *
 *Inputs:                                                               *
 *    file pointer to the token file                                    *
 *                                                                      *
 *Returns:                                                              *
 *    pointer to token delta list \(always NULL\)                         *
 *                                                                      *
 *History:                                                              *
 *    3/92 - original implementation - SteveBl                          *
 *    2/93 - Rewrote to use get token, since tokens can be arb length   *
 *              MHotchin.                                               *
 *                                                                      *
 *Comments:                                                             *
 *    Since RLQuikEd\'s token files are always temporary files generated *
 *    from res files we know that all tokens are new and unique.  There is *
 *    never any tracking data so we never have to build a token delta info *
 *    list.  For this reason, InsertQuikTokList allways returns NULL.     *
 *    Also, every token must be marked as ST_TRANSLATED                 *
 *                                                                      *
 **************************************************************************/

static TOKENDELTAINFO FAR *InsertQuikTokList( FILE * fpTokFile)
{
    static TOKEN tInputToken;
    int    rcFileCode = 0;
    UINT   uTokCharsW = 0;
    LPTSTR pszTokBuf  = NULL;

    rewind(fpTokFile);

    while ( (rcFileCode = GetToken( fpTokFile, &tInputToken)) >= 0 )
    {
        if ( rcFileCode == 0 )
        {
            HGLOBAL hMem = NULL;
            uTokCharsW = TokenToTextSize( &tInputToken) + 1;
            hMem = GlobalAlloc( GMEM_ZEROINIT, MEMSIZE( uTokCharsW));
            pszTokBuf = (LPTSTR)GlobalLock( hMem);
            ParseTokToBuf( pszTokBuf, &tInputToken);
            GlobalUnlock( hMem);

            if ( SendMessage( hListWnd,
                              LB_ADDSTRING,
                              (WPARAM)0,
                              (LPARAM)hMem) < 0)
            {
                QuitT( IDS_ENGERR_11, NULL, NULL);
            }
        }
    }
    return NULL;
}



/****************************************************************************
 *Procedure: LoadNewFile                                                     *
 *                                                                           *
 *Inputs:                                                                    *
 *       Pointer to path string                                              *
 *                                                                           *
 *Returns:                                                                   *
 *   boolean success or failure                                              *
 *                                                                           *
 *History:                                                                   *
 *       6/92 - created from IDM_P_OPEN case in DoMenuCommand - t-gregti     *
 *                                                                           *
 *Comments:                                                                  *
 *       This is nice to have so code isn't repeated in the file-browse and  *
 *   drag-drop cases.                                                        *
 *****************************************************************************/

static BOOL LoadNewFile( CHAR *szPath)
{                               // Save old project
    OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

    if ( ! SendMessage( hMainWnd, WM_SAVEPROJECT, (LPARAM)0, (LPARAM)0) )
    {
        return( FALSE);
    }
    if ( gProj.szTok[0] )       // get rid of the old temp file
    {
        remove( gProj.szTok);
        gProj.szTok[0] = 0;
    }

    strcpy( szFileName, szPath);

    if ( OpenFile( szFileName, &Of, OF_EXIST) != HFILE_ERROR )
    {
        if ( IsExe( szFileName) )
        {
            gProj.fSourceEXE = TRUE;
            gProj.fTargetEXE = TRUE;
        }
        else
        {
            gProj.fSourceEXE = FALSE;
            gProj.fTargetEXE = FALSE;
        }
        strcpy( gMstr.szSrc, szFileName);
        gMstr.szRdfs[0] = 0;
        gProj.szTok[0]  = 0;
        MyGetTempFileName( 0,"TOK", 0, gProj.szTok);

        sprintf( szDHW, "%s - %s", szAppName, szFileName);
        SetWindowTextA( hMainWnd, szDHW);
        SendMessage( hMainWnd, WM_LOADPROJECT, (LPARAM)0, (LPARAM)0);
    }
    return(TRUE);
}


//...................................................................

int  RLMessageBoxA(

LPCSTR pszMsgText)
{
    return( MessageBoxA( hMainWnd, pszMsgText, szAppName, MB_ICONSTOP|MB_OK));
}


//...................................................................

void Usage()
{
    return;
}


void DoExit( int nErrCode)
{
    ExitProcess( (UINT)nErrCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\tct\display.h ===
#define	iStrMin	1
#define	iStrMax	40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\tct\display.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

#include "display.h"

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  main() -                                                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID __cdecl main(int argc, UCHAR **argv)
{
    int		iStr;
    TCHAR	buf[256];
    HMODULE	hmod;
    HBITMAP	hb;

    printf("System Language is:  %x\n", GetSystemDefaultLangID());
    printf("User Language is:  %x\n\n", GetUserDefaultLangID());

    for (iStr=iStrMin ; iStr<=iStrMax ; iStr++) {
	LoadString(NULL, iStr, buf, 256);
	printf("String %d is:\"%ws\"\n", iStr, buf);
    }

    hmod = GetModuleHandle(NULL);
    if (!hmod)
	printf("No module handle!\n");
    hb = LoadBitmap(hmod, TEXT("ONE"));
    if (!hb)
	printf("ONE not loaded!\n");
    hb = LoadBitmap(hmod, TEXT("TWO"));
    if (!hb)
	printf("TWO not loaded!\n");
    hb = LoadBitmap(hmod, TEXT("THREE"));
    if (!hb)
	printf("THREE not loaded!\n");
    hb = LoadBitmap(hmod, TEXT("FOUR"));
    if (!hb)
	printf("THREE not loaded!\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\unicode\nlsxlat.c ===
/****************************** Module Header ******************************\
* Module Name: nlsxlat.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* This modules contains the private routines for character translation:
* 8-bit <=> Unicode.
*
* History:
* 03-Jan-1992 gregoryw
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>

/*
 * External declarations - these are temporary tables
 */
extern USHORT TmpUnicodeToAnsiTable[];
extern WCHAR TmpAnsiToUnicodeTable[];
#ifdef DBCS
extern WCHAR sjtouni( USHORT );
#define IsDBCSFirst(w) (((unsigned char)w >= 0x81 && (unsigned char)w <= 0x9f) || (((unsigned char)w >= 0xe0 && (unsigned char)w <= 0xfc)))
#endif // DBCS

/*
 * Various defines for data access
 */
#define DBCS_TABLE_SIZE 256

#define LONIBBLE(b)         ((UCHAR)((UCHAR)(b) & 0xF))
#define HINIBBLE(b)         ((UCHAR)(((UCHAR)(b) >> 4) & 0xF))

#define LOBYTE(w)           ((UCHAR)(w))
#define HIBYTE(w)           ((UCHAR)(((USHORT)(w) >> 8) & 0xFF))

/*
 * Global data used by the translation routines.
 *
 */
UCHAR    NlsLeadByteInfo[DBCS_TABLE_SIZE]; // Lead byte info. for ACP
PUSHORT *NlsMbCodePageTables;         // Multibyte to Unicode translation tables
PUSHORT  NlsAnsiToUnicodeData = TmpAnsiToUnicodeTable; // Ansi CP to Unicode translation table
PUSHORT  NlsUnicodeToAnsiData = TmpUnicodeToAnsiTable; // Unicode to Ansi CP translation table


NTSTATUS
xxxRtlMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful


--*/

{
    UCHAR Entry;
    PWCH UnicodeStringAnchor;
    PUSHORT DBCSTable;

    UnicodeStringAnchor = UnicodeString;

#ifdef DBCS
        while (BytesInMultiByteString--) {
            if ( IsDBCSFirst( *MultiByteString ) ) {
                if (!BytesInMultiByteString) {
                    return STATUS_UNSUCCESSFUL;
                }
                *UnicodeString++ = sjtouni( (((USHORT)(*(PUCHAR)MultiByteString++)) << 8) +
                                            (USHORT)(*(PUCHAR)MultiByteString++)
                                          );
                BytesInMultiByteString--;
            } else {
                *UnicodeString++ = sjtouni( *(PUCHAR)MultiByteString++ );
            }
        }
#else
    if (NlsMbCodePageTag) {
        //
        // The ACP is a multibyte code page.  Check each character
        // to see if it is a lead byte before doing the translation.
        //
        while (BytesInMultiByteString--) {
            if ( NlsLeadByteInfo[*MultiByteString]) {
                //
                // Lead byte - translate the trail byte using the table
                // that corresponds to this lead byte.  NOTE: make sure
                // we have a trail byte to convert.
                //
                if (!BytesInMultiByteString) {
                    return STATUS_UNSUCCESSFUL;
                }
                Entry = NlsLeadByteInfo[*MultiByteString++];
                DBCSTable = NlsMbCodePageTables[HINIBBLE(Entry)] + (LONIBBLE(Entry) * DBCS_TABLE_SIZE);
                *UnicodeString++ = DBCSTable[*MultiByteString++];
                BytesInMultiByteString--;
            } else {
                //
                // Single byte character.
                //
                if (*MultiByteString & 0x80) {
                    *UnicodeString++ = NlsAnsiToUnicodeData[*MultiByteString++];
                } else {
                    *UnicodeString++ = (WCHAR)*MultiByteString++;
                }
            }
        }
    } else {
        //
        // The ACP is a single byte code page.
        //
        while (BytesInMultiByteString--) {
            if (*MultiByteString & 0x80) {
                *UnicodeString++ = NlsAnsiToUnicodeData[*MultiByteString++];
            } else {
                *UnicodeString++ = (WCHAR)*MultiByteString++;
            }
        }
    }
#endif

    if (ARGUMENT_PRESENT(BytesInUnicodeString)) {
        *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
xxxRtlUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done
        because a character in the unicode string does not map to an
        ansi character in the ACP, an error is returned.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The conversion failed.  A unicode character was encountered
        that has no translation for the current ANSI Code Page (ACP).

--*/

{
    USHORT Offset;
    USHORT Entry;
    ULONG CharsInUnicodeString;
    PCH MultiByteStringAnchor;

    MultiByteStringAnchor = MultiByteString;

    /*
     * convert from bytes to chars for easier loop handling.
     */
    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    while (CharsInUnicodeString--) {
        Offset = NlsUnicodeToAnsiData[HIBYTE(*UnicodeString)];
        if (Offset != 0) {
            Offset = NlsUnicodeToAnsiData[Offset + HINIBBLE(*UnicodeString)];
            if (Offset != 0) {
                Entry = NlsUnicodeToAnsiData[Offset + LONIBBLE(*UnicodeString)];
                if (HIBYTE(Entry) != 0) {
                    *MultiByteString++ = HIBYTE(Entry);  // lead byte
                }
                *MultiByteString++ = LOBYTE(Entry);
            } else {
                //
                // no translation for this Unicode character.  Return
                // an error.
                //
#ifdef DBCS // RtlUnicodeToMultiByteN : temporary hack to avoid error return
                if ( *UnicodeString <= (WCHAR)0xff )
                    *MultiByteString++ = (UCHAR)*UnicodeString;
                else
                    *MultiByteString++ = '\x20';
#else
                return STATUS_UNSUCCESSFUL;
#endif
            }
        } else {
            //
            // no translation for this Unicode character.  Return an error.
            //
#ifdef DBCS // RtlUnicodeToMultiByteN : temporary hack to avoid error return
            if ( *UnicodeString <= (WCHAR)0xff )
                *MultiByteString++ = (UCHAR)*UnicodeString;
            else
                *MultiByteString++ = '\x20';
#else
            return STATUS_UNSUCCESSFUL;
#endif
        }
        UnicodeString++;
    }

    if (ARGUMENT_PRESENT(BytesInMultiByteString)) {
        *BytesInMultiByteString = (ULONG)(MultiByteString - MultiByteStringAnchor);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\rm\rm.c ===
/*** RM.C - a generalized remove and unremove mechanism ***********************
*
*       Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
*
* Purpose:
*  The three tools EXP, RM and UNDEL are used to delete files so
*  that they can be undeleted.  This is done my renaming the file into
*  a hidden directory called DELETED.
*
* Notes:
*  All deleted files are kept in the directory .\deleted with a unique name.
*  The names are then kept in .\deleted\index.
*     deleted name (RM_RECLEN bytes).
*  The rm command will rename to the appropriate directory and make an entry.
*  the undelete command will rename back if there is a single item otherwise
*  it will give a list of alternatives.  The exp command will free all deleted
*  objects.
*
* Revision History:
*  07-Feb-1990 bw Add 'void' to walk() definition
*  08-Jan-1990 SB SLM version upgrading added; Add CopyRightYrs Macro
*  03-Jan-1990 SB define QH_TOPIC_NOT_FOUND
*  21-Dec-1989 SB Changes for new index file format
*  20-Dec-1989 SB Add check for return code of 3 for qh
*  14-Dec-1989 LN Update Copyright to include 1990
*  23-Oct-1989 LN Version no bumped to 1.01
*  12-Oct-1989 LN Changed Usage message
*  02-Oct-1989 LN Changed Version no to 1.00
*  08-Aug-1989 BW Add Version number and update copyright.
*  15-May-1987 WB Add /help
*  22-Apr-1987 DL Add /k
*  06-Apr-1987 BW Add copyright notice to usage.
*  30-Mar-1990 BW Get help on RM.EXE, not EXP.EXE
*  17-Oct-1990 w-barry Temporarily replaced 'rename' with 'rename_NT' until
*                      DosMove is completely implemented on NT.
*
******************************************************************************/

/* I N C L U D E    Files */

#include <process.h>
#include <string.h>

/* Next two from ZTools */
#include <stdio.h>
#include <conio.h>
#include <windows.h>
#include <tools.h>

/* D E F I N E s */

#define CopyRightYrs "1987-98"
/* Need 2 steps, first to get correct values in and 2nd to paste them */
/* paste() is hacked to allow LEADING  ZEROES    */
#define paste(a, b, c) #a ".0" #b ".00" #c
#define VERSION(major, minor, buildno) paste(major, minor, buildno)
#define QH_TOPIC_NOT_FOUND 3

/* G L O B A L s */

flagType fRecursive = FALSE;            /* TRUE => descend tree              */
flagType fPrompt = FALSE;               /* TRUE => query for removal         */
flagType fForce = FALSE;                /* TRUE => no query for R/O files    */
flagType fKeepRO = FALSE;               /* TRUE => keep R/O files            */
flagType fTakeOwnership = FALSE;        /* TRUE => attempt takeown if fail   */
flagType fExpunge = FALSE;              /* TRUE => expunge immediately       */
flagType fDelayUntilReboot = FALSE;     /* TRUE => do delete next reboot     */

// Forward Function Declarations...
void Usage( void );
void walk( char *, struct findType *, void * );

#if 0
extern BOOL TakeOwnership( char *lpFileName );
#endif /* 0 */

void Usage()
{
    printf(
"Microsoft File Removal Utility.  Version %s\n"
"Copyright (C) Microsoft Corp %s. All rights reserved.\n\n"
"Usage: RM [/help] [/ikft] [/x [/d]] [/r dir] files\n"
"    /help  invoke Quick Help for this utility\n"
"    /i     inquire of user for each file for permission to remove\n"
"    /k     keep read only files, no prompting to remove them\n"
"    /r dir recurse into subdirectories\n"
"    /f     force delete of read only files without prompting\n"
"    /t     attempt to take ownership of file if delete fails\n"
"    /x     dont save deleted files in deleted subdirectory\n"
"    /d     delay until next reboot.\n",
    VERSION(rmj, rmm, rup), CopyRightYrs);
    exit(1);
}

void walk(p, b, dummy)
char *p;
struct findType *b;
void * dummy;
{
    char buf[MAX_PATH];
    int i, rc;

    if (strcmp(b->fbuf.cFileName, ".") && strcmp(b->fbuf.cFileName, "..") &&
        _strcmpi(b->fbuf.cFileName, "deleted")) {
        if (HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)) {
            if (fRecursive) {
                switch (strend(p)[-1]) {
                case '/':
                case '\\':
                    sprintf(buf, "%s*.*", p);
                    break;
                default:
                    sprintf(buf, "%s\\*.*", p);
                    }
                forfile(buf, -1, walk, NULL);
                }
            }
        else if (fKeepRO && HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY)) {
            printf("%s skipped\n", p);
            return;
        }
        else {
            if (fPrompt || (!fForce && HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY))) {
                printf("%s? ", p);
                fflush(stdout);
                switch (_getch()) {
                case 'y':
                case 'Y':
                    printf("Yes\n");
                    break;
                case 'p':
                case 'P':
                    printf("Proceeding without asking again\n");
                    fPrompt = FALSE;
                    break;
                default:
                    printf(" skipped\n");
                    return;
                    }
                }
            fflush(stdout);
            if (HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY))
                SetFileAttributes(p, b->fbuf.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY);

            for (i=0; i<2; i++) {
                if (fExpunge) {
                    if (fDelayUntilReboot) {
                        if (MoveFileEx(p, NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
                            rc = 0;
                            }
                        else {
                            rc = 1;
                            }
                        }
                    else
                    if (DeleteFile(p)) {
                        rc = 0;
                        }
                    else {
                        rc = 1;
                        }
                    }
                else {
                    rc = fdelete(p);
                    }

#if 0
                if (rc == 0 || !fTakeOwnership) {
                    break;
                    }

                printf( "%s file not deleted - attempting to take ownership and try again.\n" );
                if (!TakeOwnership( p )) {
                    printf( "%s file not deleted - unable to take ownership.\n" );
                    rc = 0;
                    break;
                    }
#else
                    break;
#endif /* 0 */
                }

            switch (rc) {
            case 0:
                break;
            case 1:
                printf("%s file does not exist\n" , p);
                break;
            case 2:
                printf("%s rename failed: %s\n", p, error());
                break;
            default:
                printf("%s internal error: %s\n", p, error());
                break;
                }
            }
        }
    dummy;
}

__cdecl main(c, v)
int c;
char *v[];
{
    register char *p;
    int iRetCode;

    ConvertAppToOem( c, v );
    SHIFT(c,v);
    while (c && fSwitChr(*v[0])) {
        p = *v;
        while (*++p != '\0')
            switch (*p) {
            case 'f':
                fForce = TRUE;
                break;
            case 'i':
                fPrompt = TRUE;
                break;
            case 'k':
                fKeepRO = TRUE;
                break;
            case 'r':
                fRecursive = TRUE;
                break;
            case 't':
                fTakeOwnership = TRUE;
                break;
            case 'x':
                fExpunge = TRUE;
                break;
            case 'd':
                if (fExpunge) {
                    fDelayUntilReboot = TRUE;
                    break;
                    }
                // Fall thru if /d without /x
            case 'h':
                if (!_strcmpi(p, "help")) {
                    iRetCode = (int) _spawnlp(P_WAIT, "qh.exe", "qh", "/u",
                                       "rm.exe", NULL);
                    /* When qh returns QH_TOPIC_NOT_FOUND or when we
                     *    get -1 (returned when the spawn fails) then
                     *    give Usage() message
                     */
                    if (iRetCode != QH_TOPIC_NOT_FOUND && iRetCode != -1)
                        exit(0);
                }
                /*
                 * else fall thru...
                 */
            default:
                Usage();
            }
        SHIFT(c,v);
    }

    while (c) {
        if (!forfile(*v, -1, walk, NULL)) {
            printf("%s does not exist\n", *v);
        }
        SHIFT(c,v);
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sclist\sclist.c ===
//----------------------------------------------------------------------//
//
// Oct 1996 - fixed bug 54583 - simple typo in usage text		//
//		a-martih (Martin Holladay)
//
//----------------------------------------------------------------------//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

SC_HANDLE hSvc;
ENUM_SERVICE_STATUS SvcStat[1024];
ULONG i;
ULONG Resume;
ULONG NumSvc;
LPSTR p;
LPSTR CmdLine;
BOOL  StoppedOnly;
BOOL  RunningOnly;
CHAR  MachineName[256];
CHAR  ch;

int
__cdecl
main( void )
{
    CmdLine = GetCommandLine();

    //
    // skip the program name
    //
    while( *CmdLine && *CmdLine != ' ' ) {
        CmdLine += 1;
    }
    //
    // skip any white space
    //
    while( *CmdLine && *CmdLine == ' ' ) {
        CmdLine += 1;
    }
    //
    // get the command line options
    //
    while( *CmdLine && (*CmdLine == '-' || *CmdLine == '/') ) {
        CmdLine += 1;
        ch = (CHAR)tolower(*CmdLine);
        CmdLine += 1;
        switch( ch ) {
            case 's':
                StoppedOnly = TRUE;
                break;

            case 'r':
                RunningOnly = TRUE;
                break;

            default:
                fputs("\n"
                    "Microsoft (R) Windows NT (TM) Version 5.0 SCLIST\n"
                    "Copyright (C) Microsoft Corp. All rights reserved\n\n"
                    "usage: SCLIST [-?] [-r] [-s] [MachineName]\n"
                    "              [-?] Display this message\n"
                    "              [-r] Display only running services\n"
                    "              [-s] Display only stopped services\n"
                    "              [-MachineName] Machine name to list services\n",
                    stderr );
                exit(0);
        }
        while( *CmdLine == ' ' ) {
            CmdLine += 1;
        }
    }

    //
    // get the machine name
    //
    if (*CmdLine) {
        //
        // skip any white space
        //
        while( *CmdLine && *CmdLine == ' ' ) {
            CmdLine += 1;
        }
        //
        // get the machine name
        //
        p = MachineName;
        while( *CmdLine && *CmdLine != ' ' ) {
            *p++ = *CmdLine;
            CmdLine += 1;
        }
        *p = 0;
    }

    hSvc = OpenSCManager( MachineName, NULL,  SC_MANAGER_ENUMERATE_SERVICE );
    if (!hSvc) {
        printf( "could not open service manager for %s\n",
            MachineName[0] ? MachineName : "Local Machine" );
        return 1;
    }

    if (!EnumServicesStatus(
            hSvc,
            SERVICE_WIN32,
            SERVICE_ACTIVE | SERVICE_INACTIVE,
            SvcStat,
            sizeof(SvcStat),
            &i,
            &NumSvc,
            &Resume
            )) {
        printf( "could not enumerate services for %s\n",
            MachineName[0] ? MachineName : "Local Machine" );
        return 1;
    }

    printf( "\n" );
    printf( "--------------------------------------------\n" );
    printf( "- Service list for %s ", MachineName[0] ? MachineName : "Local Machine" );
    if (StoppedOnly || RunningOnly) {
        printf( "(" );
        if (RunningOnly) {
            printf( "running" );
        }
        if (StoppedOnly) {
            printf( "stopped" );
        }
        printf( ")" );
    }
    printf( "\n" );
    printf( "--------------------------------------------\n" );
    for (i=0; i<NumSvc; i++) {
        if (RunningOnly && SvcStat[i].ServiceStatus.dwCurrentState != SERVICE_RUNNING) {
            continue;
        }
        if (StoppedOnly && SvcStat[i].ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
            continue;
        }
        switch( SvcStat[i].ServiceStatus.dwCurrentState ) {
            case SERVICE_STOPPED:
                p = "stopped";
                break;

            case SERVICE_START_PENDING:
                p = "start pending";
                break;

            case SERVICE_STOP_PENDING:
                p = "stop pending";
                break;

            case SERVICE_RUNNING:
                p = "running";
                break;

            case SERVICE_CONTINUE_PENDING:
                p = "continue pending";
                break;

            case SERVICE_PAUSE_PENDING:
                p = "pause pending";
                break;

            case SERVICE_PAUSED:
                p = "paused";
                break;
        }
        printf( "%-16s %-32s %s\n", p, SvcStat[i].lpServiceName, SvcStat[i].lpDisplayName );
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\unicode\nlsdata.c ===
/****************************** Module Header ******************************\
* Module Name: nlsdata.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* This modules contains the translation tables used by system character
* translation routines.  These tables are TEMPORARY.  The boot loader
* will be modified to load in the ANSI Code Page (ACP) translation
* tables specified during system installation.  Until then we use these...
*
* History:
* 03-Jan-1992 gregoryw
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>

/*
 * Code Page 1252 (Win 3.1 ANSI) to Unicode translation table.
 * The ANSI code is used as the index into this table to get
 * the corresponding Unicode representation.
 *
 * NOTE: for those ANSI values that are undefined in the Win 3.1
 *       code page (e.g., 0x8d - 0x90 et. al.) the values are
 *       simply zero extended.
 *
 */
WCHAR TmpAnsiToUnicodeTable[256] = {
        0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
        0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
        0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
        0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
        0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
        0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
        0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
        0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
        0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
        0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
        0x0080, 0x0081, 0x201a, 0x0192, 0x201e, 0x2026, 0x2020, 0x2021,
        0x02c6, 0x2030, 0x0160, 0x2039, 0x0152, 0x008d, 0x008e, 0x008f,
        0x0090, 0x2018, 0x2019, 0x201c, 0x201d, 0x2022, 0x2013, 0x2014,
        0x02dc, 0x2122, 0x0161, 0x203a, 0x0153, 0x009d, 0x009e, 0x0178,
        0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
        0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
        0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
        0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
        0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
        0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
        0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
        0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
        0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
        0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
        0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
        0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
};

#ifdef DBCS

USHORT TmpUnicodeToAnsiTable[] = {

    //
    // The first 256 entries are indexed by the high byte of the
    // Unicode character.
    //

 0x100, 0x110, 0x120, 0x130, 0x140, 0x150, 0x160, 0x170,
 0x180, 0x190, 0x1a0, 0x1b0, 0x1c0, 0x1d0, 0x1e0, 0x1f0,
 0x200, 0x210, 0x220, 0x230, 0x240, 0x250, 0x260, 0x270,
 0x280, 0x290, 0x2a0, 0x2b0, 0x2c0, 0x2d0, 0x2e0, 0x2f0,
 0x300, 0x310, 0x320, 0x330, 0x340, 0x350, 0x360, 0x370,
 0x380, 0x390, 0x3a0, 0x3b0, 0x3c0, 0x3d0, 0x3e0, 0x3f0,
 0x400, 0x410, 0x420, 0x430, 0x440, 0x450, 0x460, 0x470,
 0x480, 0x490, 0x4a0, 0x4b0, 0x4c0, 0x4d0, 0x4e0, 0x4f0,
 0x500, 0x510, 0x520, 0x530, 0x540, 0x550, 0x560, 0x570,
 0x580, 0x590, 0x5a0, 0x5b0, 0x5c0, 0x5d0, 0x5e0, 0x5f0,
 0x600, 0x610, 0x620, 0x630, 0x640, 0x650, 0x660, 0x670,
 0x680, 0x690, 0x6a0, 0x6b0, 0x6c0, 0x6d0, 0x6e0, 0x6f0,
 0x700, 0x710, 0x720, 0x730, 0x740, 0x750, 0x760, 0x770,
 0x780, 0x790, 0x7a0, 0x7b0, 0x7c0, 0x7d0, 0x7e0, 0x7f0,
 0x800, 0x810, 0x820, 0x830, 0x840, 0x850, 0x860, 0x870,
 0x880, 0x890, 0x8a0, 0x8b0, 0x8c0, 0x8d0, 0x8e0, 0x8f0,
 0x900, 0x910, 0x920, 0x930, 0x940, 0x950, 0x960, 0x970,
 0x980, 0x990, 0x9a0, 0x9b0, 0x9c0, 0x9d0, 0x9e0, 0x9f0,
 0xa00, 0xa10, 0xa20, 0xa30, 0xa40, 0xa50, 0xa60, 0xa70,
 0xa80, 0xa90, 0xaa0, 0xab0, 0xac0, 0xad0, 0xae0, 0xaf0,
 0xb00, 0xb10, 0xb20, 0xb30, 0xb40, 0xb50, 0xb60, 0xb70,
 0xb80, 0xb90, 0xba0, 0xbb0, 0xbc0, 0xbd0, 0xbe0, 0xbf0,
 0xc00, 0xc10, 0xc20, 0xc30, 0xc40, 0xc50, 0xc60, 0xc70,
 0xc80, 0xc90, 0xca0, 0xcb0, 0xcc0, 0xcd0, 0xce0, 0xcf0,
 0xd00, 0xd10, 0xd20, 0xd30, 0xd40, 0xd50, 0xd60, 0xd70,
 0xd80, 0xd90, 0xda0, 0xdb0, 0xdc0, 0xdd0, 0xde0, 0xdf0,
 0xe00, 0xe10, 0xe20, 0xe30, 0xe40, 0xe50, 0xe60, 0xe70,
 0xe80, 0xe90, 0xea0, 0xeb0, 0xec0, 0xed0, 0xee0, 0xef0,
 0xf00, 0xf10, 0xf20, 0xf30, 0xf40, 0xf50, 0xf60, 0xf70,
 0xf80, 0xf90, 0xfa0, 0xfb0, 0xfc0, 0xfd0, 0xfe0, 0xff0,
 0x1000, 0x1010, 0x1020, 0x1030, 0x1040, 0x1050, 0x1060, 0x1070,
 0x1080, 0x1090, 0x10a0, 0x10b0, 0x10c0, 0x10d0, 0x10e0, 0x10f0,
    //
    // second level tables begin here.  They are indexed
    // by the high nibble of the low byte (bits 4-7) of
    // the Unicode character.
    //

 0x0, 0x0, 0x1100, 0x1110, 0x1120, 0x1130, 0x1140, 0x1150,
 0x0, 0x0, 0x1160, 0x1170, 0x0, 0x1180, 0x0, 0x1190,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x11a0, 0x11b0, 0x11c0, 0x11d0, 0x0, 0x0, 0x0,
 0x11e0, 0x11f0, 0x1200, 0x1210, 0x1220, 0x1230, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x1240, 0x1250, 0x1260, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x1270, 0x0, 0x0,
 0x1280, 0x0, 0x1290, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x12a0, 0x0, 0x0, 0x0, 0x12b0, 0x0, 0x0,
 0x12c0, 0x12d0, 0x12e0, 0x12f0, 0x0, 0x1300, 0x1310, 0x0,
 0x1320, 0x0, 0x1330, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x1340, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x1350, 0x1360, 0x1370, 0x1380, 0x1390, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x13a0, 0x13b0, 0x13c0, 0x0, 0x0, 0x0,
 0x13d0, 0x0, 0x0, 0x0, 0x13e0, 0x0, 0x13f0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x1400, 0x1410, 0x0, 0x0, 0x1420, 0x1430, 0x1440, 0x1450,
 0x1460, 0x1470, 0x1480, 0x1490, 0x14a0, 0x14b0, 0x14c0, 0x14d0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x14e0, 0x14f0, 0x1500, 0x1510, 0x1520, 0x1530, 0x1540, 0x1550,
 0x1560, 0x1570, 0x1580, 0x1590, 0x15a0, 0x15b0, 0x15c0, 0x15d0,
 0x15e0, 0x15f0, 0x1600, 0x1610, 0x1620, 0x1630, 0x1640, 0x1650,
 0x1660, 0x1670, 0x1680, 0x1690, 0x16a0, 0x16b0, 0x16c0, 0x16d0,
 0x16e0, 0x16f0, 0x1700, 0x1710, 0x1720, 0x1730, 0x1740, 0x1750,
 0x1760, 0x1770, 0x1780, 0x1790, 0x17a0, 0x17b0, 0x17c0, 0x17d0,
 0x17e0, 0x17f0, 0x1800, 0x1810, 0x1820, 0x1830, 0x1840, 0x1850,
 0x1860, 0x1870, 0x1880, 0x1890, 0x18a0, 0x18b0, 0x18c0, 0x18d0,
 0x18e0, 0x18f0, 0x1900, 0x1910, 0x1920, 0x1930, 0x1940, 0x1950,
 0x1960, 0x1970, 0x1980, 0x1990, 0x19a0, 0x19b0, 0x19c0, 0x19d0,
 0x19e0, 0x19f0, 0x1a00, 0x1a10, 0x1a20, 0x1a30, 0x1a40, 0x1a50,
 0x1a60, 0x1a70, 0x1a80, 0x1a90, 0x1aa0, 0x1ab0, 0x1ac0, 0x1ad0,
 0x1ae0, 0x1af0, 0x1b00, 0x1b10, 0x1b20, 0x1b30, 0x1b40, 0x1b50,
 0x1b60, 0x1b70, 0x1b80, 0x1b90, 0x1ba0, 0x1bb0, 0x1bc0, 0x1bd0,
 0x1be0, 0x1bf0, 0x0, 0x1c00, 0x1c10, 0x1c20, 0x1c30, 0x1c40,
 0x1c50, 0x1c60, 0x1c70, 0x1c80, 0x1c90, 0x1ca0, 0x1cb0, 0x1cc0,
 0x1cd0, 0x1ce0, 0x1cf0, 0x1d00, 0x1d10, 0x1d20, 0x1d30, 0x1d40,
 0x1d50, 0x1d60, 0x1d70, 0x1d80, 0x1d90, 0x1da0, 0x1db0, 0x1dc0,
 0x1dd0, 0x1de0, 0x1df0, 0x1e00, 0x1e10, 0x1e20, 0x1e30, 0x1e40,
 0x1e50, 0x1e60, 0x1e70, 0x1e80, 0x1e90, 0x1ea0, 0x1eb0, 0x1ec0,
 0x1ed0, 0x1ee0, 0x1ef0, 0x1f00, 0x1f10, 0x1f20, 0x1f30, 0x1f40,
 0x1f50, 0x1f60, 0x1f70, 0x1f80, 0x1f90, 0x1fa0, 0x1fb0, 0x1fc0,
 0x1fd0, 0x1fe0, 0x1ff0, 0x2000, 0x2010, 0x2020, 0x2030, 0x2040,
 0x2050, 0x2060, 0x2070, 0x2080, 0x2090, 0x20a0, 0x20b0, 0x20c0,
 0x20d0, 0x20e0, 0x20f0, 0x2100, 0x2110, 0x2120, 0x2130, 0x2140,
 0x0, 0x2150, 0x0, 0x2160, 0x2170, 0x2180, 0x2190, 0x21a0,
 0x21b0, 0x21c0, 0x21d0, 0x21e0, 0x21f0, 0x2200, 0x2210, 0x2220,
 0x2230, 0x2240, 0x2250, 0x2260, 0x2270, 0x2280, 0x2290, 0x22a0,
 0x22b0, 0x22c0, 0x22d0, 0x22e0, 0x22f0, 0x2300, 0x2310, 0x2320,
 0x2330, 0x2340, 0x2350, 0x2360, 0x2370, 0x2380, 0x2390, 0x23a0,
 0x23b0, 0x23c0, 0x23d0, 0x0, 0x23e0, 0x23f0, 0x2400, 0x2410,
 0x2420, 0x2430, 0x2440, 0x2450, 0x2460, 0x2470, 0x2480, 0x2490,
 0x24a0, 0x24b0, 0x24c0, 0x24d0, 0x24e0, 0x24f0, 0x2500, 0x2510,
 0x2520, 0x2530, 0x2540, 0x2550, 0x2560, 0x2570, 0x2580, 0x2590,
 0x25a0, 0x25b0, 0x25c0, 0x25d0, 0x25e0, 0x25f0, 0x2600, 0x2610,
 0x2620, 0x2630, 0x2640, 0x2650, 0x2660, 0x2670, 0x2680, 0x2690,
 0x26a0, 0x26b0, 0x26c0, 0x26d0, 0x26e0, 0x26f0, 0x2700, 0x2710,
 0x2720, 0x2730, 0x2740, 0x2750, 0x2760, 0x2770, 0x2780, 0x2790,
 0x27a0, 0x27b0, 0x27c0, 0x27d0, 0x27e0, 0x27f0, 0x2800, 0x2810,
 0x2820, 0x2830, 0x2840, 0x2850, 0x2860, 0x0, 0x2870, 0x2880,
 0x2890, 0x28a0, 0x28b0, 0x28c0, 0x28d0, 0x28e0, 0x28f0, 0x2900,
 0x2910, 0x2920, 0x2930, 0x2940, 0x2950, 0x2960, 0x2970, 0x2980,
 0x2990, 0x29a0, 0x29b0, 0x29c0, 0x29d0, 0x29e0, 0x29f0, 0x2a00,
 0x2a10, 0x2a20, 0x2a30, 0x2a40, 0x2a50, 0x2a60, 0x2a70, 0x2a80,
 0x2a90, 0x2aa0, 0x2ab0, 0x2ac0, 0x2ad0, 0x2ae0, 0x2af0, 0x2b00,
 0x2b10, 0x2b20, 0x2b30, 0x2b40, 0x2b50, 0x2b60, 0x2b70, 0x2b80,
 0x2b90, 0x2ba0, 0x2bb0, 0x2bc0, 0x2bd0, 0x2be0, 0x2bf0, 0x2c00,
 0x2c10, 0x2c20, 0x2c30, 0x2c40, 0x2c50, 0x2c60, 0x2c70, 0x2c80,
 0x2c90, 0x2ca0, 0x2cb0, 0x2cc0, 0x2cd0, 0x2ce0, 0x2cf0, 0x2d00,
 0x2d10, 0x2d20, 0x2d30, 0x2d40, 0x2d50, 0x2d60, 0x2d70, 0x2d80,
 0x2d90, 0x2da0, 0x2db0, 0x2dc0, 0x2dd0, 0x2de0, 0x2df0, 0x2e00,
 0x2e10, 0x2e20, 0x2e30, 0x2e40, 0x2e50, 0x2e60, 0x2e70, 0x2e80,
 0x2e90, 0x2ea0, 0x2eb0, 0x2ec0, 0x2ed0, 0x2ee0, 0x2ef0, 0x2f00,
 0x2f10, 0x2f20, 0x2f30, 0x2f40, 0x2f50, 0x2f60, 0x2f70, 0x2f80,
 0x2f90, 0x2fa0, 0x2fb0, 0x2fc0, 0x2fd0, 0x2fe0, 0x2ff0, 0x3000,
 0x3010, 0x3020, 0x3030, 0x3040, 0x3050, 0x3060, 0x3070, 0x3080,
 0x3090, 0x30a0, 0x30b0, 0x30c0, 0x30d0, 0x30e0, 0x30f0, 0x3100,
 0x3110, 0x3120, 0x3130, 0x3140, 0x3150, 0x3160, 0x3170, 0x3180,
 0x3190, 0x31a0, 0x31b0, 0x31c0, 0x31d0, 0x31e0, 0x31f0, 0x3200,
 0x3210, 0x3220, 0x3230, 0x3240, 0x3250, 0x3260, 0x3270, 0x3280,
 0x3290, 0x32a0, 0x32b0, 0x32c0, 0x32d0, 0x32e0, 0x32f0, 0x3300,
 0x3310, 0x3320, 0x3330, 0x3340, 0x3350, 0x3360, 0x3370, 0x3380,
 0x3390, 0x33a0, 0x33b0, 0x33c0, 0x33d0, 0x33e0, 0x33f0, 0x3400,
 0x3410, 0x3420, 0x3430, 0x3440, 0x3450, 0x3460, 0x3470, 0x3480,
 0x3490, 0x34a0, 0x34b0, 0x34c0, 0x34d0, 0x34e0, 0x34f0, 0x3500,
 0x3510, 0x3520, 0x3530, 0x3540, 0x3550, 0x3560, 0x3570, 0x3580,
 0x3590, 0x35a0, 0x35b0, 0x35c0, 0x35d0, 0x35e0, 0x35f0, 0x3600,
 0x3610, 0x3620, 0x3630, 0x3640, 0x3650, 0x3660, 0x3670, 0x3680,
 0x3690, 0x36a0, 0x36b0, 0x36c0, 0x36d0, 0x36e0, 0x36f0, 0x3700,
 0x3710, 0x3720, 0x3730, 0x3740, 0x3750, 0x3760, 0x0, 0x3770,
 0x3780, 0x3790, 0x37a0, 0x37b0, 0x37c0, 0x37d0, 0x37e0, 0x37f0,
 0x3800, 0x3810, 0x3820, 0x3830, 0x3840, 0x3850, 0x3860, 0x3870,
 0x3880, 0x3890, 0x38a0, 0x38b0, 0x38c0, 0x38d0, 0x38e0, 0x38f0,
 0x3900, 0x3910, 0x3920, 0x3930, 0x3940, 0x3950, 0x3960, 0x3970,
 0x3980, 0x3990, 0x39a0, 0x39b0, 0x39c0, 0x39d0, 0x39e0, 0x39f0,
 0x3a00, 0x3a10, 0x3a20, 0x3a30, 0x3a40, 0x3a50, 0x3a60, 0x3a70,
 0x3a80, 0x0, 0x3a90, 0x3aa0, 0x3ab0, 0x3ac0, 0x3ad0, 0x3ae0,
 0x3af0, 0x3b00, 0x3b10, 0x3b20, 0x3b30, 0x3b40, 0x3b50, 0x3b60,
 0x3b70, 0x3b80, 0x3b90, 0x3ba0, 0x3bb0, 0x3bc0, 0x3bd0, 0x3be0,
 0x3bf0, 0x3c00, 0x3c10, 0x3c20, 0x3c30, 0x3c40, 0x3c50, 0x3c60,
 0x3c70, 0x3c80, 0x3c90, 0x3ca0, 0x3cb0, 0x3cc0, 0x3cd0, 0x3ce0,
 0x3cf0, 0x3d00, 0x3d10, 0x3d20, 0x3d30, 0x3d40, 0x3d50, 0x3d60,
 0x3d70, 0x3d80, 0x3d90, 0x3da0, 0x3db0, 0x3dc0, 0x3dd0, 0x3de0,
 0x3df0, 0x3e00, 0x3e10, 0x3e20, 0x3e30, 0x3e40, 0x3e50, 0x3e60,
 0x3e70, 0x3e80, 0x3e90, 0x3ea0, 0x3eb0, 0x3ec0, 0x3ed0, 0x3ee0,
 0x3ef0, 0x3f00, 0x3f10, 0x3f20, 0x3f30, 0x3f40, 0x3f50, 0x3f60,
 0x3f70, 0x3f80, 0x3f90, 0x3fa0, 0x3fb0, 0x3fc0, 0x3fd0, 0x3fe0,
 0x3ff0, 0x4000, 0x4010, 0x4020, 0x4030, 0x4040, 0x4050, 0x4060,
 0x4070, 0x4080, 0x4090, 0x40a0, 0x40b0, 0x40c0, 0x40d0, 0x40e0,
 0x40f0, 0x4100, 0x4110, 0x4120, 0x4130, 0x4140, 0x4150, 0x4160,
 0x4170, 0x4180, 0x4190, 0x41a0, 0x41b0, 0x41c0, 0x41d0, 0x41e0,
 0x41f0, 0x4200, 0x4210, 0x4220, 0x4230, 0x4240, 0x4250, 0x4260,
 0x4270, 0x4280, 0x4290, 0x42a0, 0x42b0, 0x42c0, 0x42d0, 0x42e0,
 0x42f0, 0x4300, 0x4310, 0x4320, 0x4330, 0x4340, 0x4350, 0x4360,
 0x4370, 0x4380, 0x4390, 0x43a0, 0x43b0, 0x43c0, 0x43d0, 0x43e0,
 0x43f0, 0x4400, 0x4410, 0x4420, 0x4430, 0x4440, 0x4450, 0x4460,
 0x4470, 0x4480, 0x4490, 0x44a0, 0x44b0, 0x44c0, 0x44d0, 0x44e0,
 0x44f0, 0x4500, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x4510, 0x4520, 0x4530, 0x4540, 0x4550,
 0x4560, 0x4570, 0x4580, 0x4590, 0x45a0, 0x45b0, 0x45c0, 0x45d0,
 0x45e0, 0x45f0, 0x4600, 0x4610, 0x4620, 0x4630, 0x4640, 0x4650,
 0x4660, 0x4670, 0x4680, 0x4690, 0x46a0, 0x46b0, 0x46c0, 0x46d0,
 0x46e0, 0x46f0, 0x4700, 0x4710, 0x4720, 0x4730, 0x4740, 0x4750,
 0x4760, 0x4770, 0x4780, 0x4790, 0x47a0, 0x47b0, 0x47c0, 0x47d0,
 0x47e0, 0x47f0, 0x4800, 0x4810, 0x4820, 0x4830, 0x4840, 0x4850,
 0x4860, 0x4870, 0x4880, 0x4890, 0x48a0, 0x48b0, 0x48c0, 0x48d0,
 0x48e0, 0x48f0, 0x4900, 0x4910, 0x4920, 0x4930, 0x0, 0x4940,
 0x4950, 0x4960, 0x4970, 0x4980, 0x4990, 0x49a0, 0x49b0, 0x49c0,
 0x49d0, 0x49e0, 0x49f0, 0x4a00, 0x4a10, 0x4a20, 0x4a30, 0x4a40,
 0x4a50, 0x4a60, 0x4a70, 0x4a80, 0x4a90, 0x4aa0, 0x4ab0, 0x4ac0,
 0x4ad0, 0x4ae0, 0x4af0, 0x4b00, 0x4b10, 0x4b20, 0x4b30, 0x4b40,
 0x4b50, 0x4b60, 0x4b70, 0x4b80, 0x4b90, 0x4ba0, 0x4bb0, 0x4bc0,
 0x4bd0, 0x4be0, 0x4bf0, 0x4c00, 0x4c10, 0x4c20, 0x4c30, 0x4c40,
 0x4c50, 0x4c60, 0x4c70, 0x4c80, 0x4c90, 0x4ca0, 0x4cb0, 0x4cc0,
 0x4cd0, 0x4ce0, 0x4cf0, 0x4d00, 0x4d10, 0x4d20, 0x4d30, 0x4d40,
 0x4d50, 0x4d60, 0x4d70, 0x4d80, 0x4d90, 0x4da0, 0x4db0, 0x4dc0,
 0x4dd0, 0x4de0, 0x4df0, 0x4e00, 0x4e10, 0x4e20, 0x4e30, 0x4e40,
 0x4e50, 0x4e60, 0x4e70, 0x4e80, 0x4e90, 0x4ea0, 0x4eb0, 0x4ec0,
 0x4ed0, 0x4ee0, 0x4ef0, 0x4f00, 0x4f10, 0x4f20, 0x4f30, 0x4f40,
 0x4f50, 0x4f60, 0x4f70, 0x4f80, 0x4f90, 0x4fa0, 0x4fb0, 0x4fc0,
 0x4fd0, 0x4fe0, 0x4ff0, 0x5000, 0x5010, 0x5020, 0x5030, 0x5040,
 0x5050, 0x5060, 0x5070, 0x5080, 0x5090, 0x50a0, 0x50b0, 0x50c0,
 0x50d0, 0x50e0, 0x50f0, 0x5100, 0x5110, 0x5120, 0x5130, 0x5140,
 0x5150, 0x5160, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x5170, 0x5180, 0x5190, 0x51a0, 0x51b0,
 0x51c0, 0x51d0, 0x51e0, 0x51f0, 0x5200, 0x5210, 0x5220, 0x5230,
 0x5240, 0x5250, 0x0, 0x0, 0x0, 0x0, 0x5260, 0x5270,
 0x5280, 0x5290, 0x52a0, 0x52b0, 0x52c0, 0x52d0, 0x52e0, 0x52f0,
 0x5300, 0x5310, 0x5320, 0x5330, 0x5340, 0x5350, 0x5360, 0x5370,
 0x5380, 0x5390, 0x53a0, 0x53b0, 0x53c0, 0x53d0, 0x53e0, 0x53f0,
 0x5400, 0x5410, 0x5420, 0x5430, 0x5440, 0x5450, 0x5460, 0x0,
 0x0, 0x5470, 0x5480, 0x5490, 0x54a0, 0x54b0, 0x54c0, 0x54d0,
 0x54e0, 0x54f0, 0x5500, 0x5510, 0x5520, 0x5530, 0x5540, 0x5550,
 0x5560, 0x5570, 0x5580, 0x5590, 0x55a0, 0x55b0, 0x55c0, 0x55d0,
 0x55e0, 0x55f0, 0x5600, 0x5610, 0x5620, 0x5630, 0x5640, 0x5650,
 0x5660, 0x5670, 0x5680, 0x5690, 0x56a0, 0x56b0, 0x56c0, 0x56d0,
 0x56e0, 0x56f0, 0x5700, 0x5710, 0x5720, 0x5730, 0x5740, 0x5750,
 0x5760, 0x5770, 0x5780, 0x5790, 0x0, 0x57a0, 0x57b0, 0x57c0,
 0x57d0, 0x57e0, 0x57f0, 0x5800, 0x5810, 0x5820, 0x5830, 0x5840,
 0x5850, 0x5860, 0x5870, 0x5880, 0x5890, 0x58a0, 0x58b0, 0x0,
 0x58c0, 0x58d0, 0x58e0, 0x58f0, 0x5900, 0x5910, 0x5920, 0x5930,
 0x5940, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5950,
 0x5960, 0x5970, 0x5980, 0x5990, 0x59a0, 0x59b0, 0x59c0, 0x0,
 0x0, 0x59d0, 0x59e0, 0x59f0, 0x5a00, 0x5a10, 0x5a20, 0x5a30,
 0x5a40, 0x5a50, 0x5a60, 0x5a70, 0x5a80, 0x5a90, 0x5aa0, 0x5ab0,
 0x5ac0, 0x5ad0, 0x5ae0, 0x5af0, 0x5b00, 0x5b10, 0x5b20, 0x5b30,
 0x5b40, 0x5b50, 0x5b60, 0x5b70, 0x5b80, 0x5b90, 0x5ba0, 0x5bb0,
 0x5bc0, 0x5bd0, 0x5be0, 0x5bf0, 0x5c00, 0x5c10, 0x5c20, 0x5c30,
 0x0, 0x0, 0x5c40, 0x5c50, 0x5c60, 0x5c70, 0x5c80, 0x5c90,
 0x5ca0, 0x5cb0, 0x5cc0, 0x5cd0, 0x5ce0, 0x5cf0, 0x0, 0x0,
 0x0, 0x5d00, 0x5d10, 0x5d20, 0x5d30, 0x5d40, 0x5d50, 0x5d60,
 0x5d70, 0x5d80, 0x5d90, 0x5da0, 0x5db0, 0x5dc0, 0x5dd0, 0x0,
 0x0, 0x0, 0x5de0, 0x5df0, 0x5e00, 0x5e10, 0x5e20, 0x5e30,
 0x5e40, 0x5e50, 0x5e60, 0x5e70, 0x5e80, 0x5e90, 0x0, 0x5ea0,
 0x5eb0, 0x5ec0, 0x5ed0, 0x5ee0, 0x5ef0, 0x5f00, 0x5f10, 0x5f20,
 0x5f30, 0x5f40, 0x5f50, 0x5f60, 0x5f70, 0x5f80, 0x5f90, 0x5fa0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5fb0, 0x5fc0,
 0x5fd0, 0x5fe0, 0x5ff0, 0x6000, 0x6010, 0x6020, 0x6030, 0x6040,
 0x6050, 0x6060, 0x6070, 0x6080, 0x6090, 0x60a0, 0x60b0, 0x60c0,
 0x0, 0x60d0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60e0,
 0x60f0, 0x6100, 0x6110, 0x6120, 0x6130, 0x6140, 0x6150, 0x6160,
 0x6170, 0x6180, 0x6190, 0x61a0, 0x61b0, 0x61c0, 0x61d0, 0x61e0,
 0x61f0, 0x6200, 0x6210, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x6220, 0x6230, 0x6240, 0x6250, 0x6260, 0x6270, 0x6280, 0x6290,
 0x62a0, 0x62b0, 0x0, 0x0, 0x0, 0x0, 0x62c0, 0x0,
    //
    // third level tables begin here.  They are indexed
    // by the low nibble of the low byte (bits 0x0-3) of
    // the Unicode character.
    //

 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x0, 0x7f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8198,
 0x814e, 0x0, 0x0, 0x0, 0x0, 0x815d, 0x0, 0x7e,
 0x818b, 0x817d, 0x0, 0x0, 0x814c, 0x0, 0x81f7, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x817e,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8180,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x839f, 0x83a0, 0x83a1, 0x83a2, 0x83a3, 0x83a4, 0x83a5,
 0x83a6, 0x83a7, 0x83a8, 0x83a9, 0x83aa, 0x83ab, 0x83ac, 0x83ad,
 0x83ae, 0x83af, 0x0, 0x83b0, 0x83b1, 0x83b2, 0x83b3, 0x83b4,
 0x83b5, 0x83b6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x83bf, 0x83c0, 0x83c1, 0x83c2, 0x83c3, 0x83c4, 0x83c5,
 0x83c6, 0x83c7, 0x83c8, 0x83c9, 0x83ca, 0x83cb, 0x83cc, 0x83cd,
 0x83ce, 0x83cf, 0x0, 0x83d0, 0x83d1, 0x83d2, 0x83d3, 0x83d4,
 0x83d5, 0x83d6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8446, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8440, 0x8441, 0x8442, 0x8443, 0x8444, 0x8445, 0x8447, 0x8448,
 0x8449, 0x844a, 0x844b, 0x844c, 0x844d, 0x844e, 0x844f, 0x8450,
 0x8451, 0x8452, 0x8453, 0x8454, 0x8455, 0x8456, 0x8457, 0x8458,
 0x8459, 0x845a, 0x845b, 0x845c, 0x845d, 0x845e, 0x845f, 0x8460,
 0x8470, 0x8471, 0x8472, 0x8473, 0x8474, 0x8475, 0x8477, 0x8478,
 0x8479, 0x847a, 0x847b, 0x847c, 0x847d, 0x847e, 0x8480, 0x8481,
 0x8482, 0x8483, 0x8484, 0x8485, 0x8486, 0x8487, 0x8488, 0x8489,
 0x848a, 0x848b, 0x848c, 0x848d, 0x848e, 0x848f, 0x8490, 0x8491,
 0x0, 0x8476, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x815c, 0x0, 0x0,
 0x8165, 0x8166, 0x0, 0x0, 0x8167, 0x8168, 0x0, 0x0,
 0x81f5, 0x81f6, 0x0, 0x0, 0x0, 0x8164, 0x8163, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x81f1, 0x0, 0x818c, 0x818d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x81a6, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x81fc, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x818e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x81f0, 0x0, 0x0, 0x0, 0x0,
 0x81a9, 0x81aa, 0x81a8, 0x81ab, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81cb, 0x0, 0x81cc, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x81cd, 0x0, 0x81dd, 0x81ce, 0x0, 0x0, 0x0, 0x81de,
 0x81b8, 0x0, 0x0, 0x81b9, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81e3, 0x0, 0x0, 0x81e5, 0x8187, 0x0,
 0x81da, 0x0, 0x0, 0x0, 0x0, 0x8161, 0x0, 0x81c8,
 0x81c9, 0x81bf, 0x81be, 0x81e7, 0x81e8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8188, 0x81e6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x81e4, 0x0, 0x0,
 0x0, 0x0, 0x81e0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8182, 0x81df, 0x0, 0x0, 0x0, 0x0, 0x8185, 0x8186,
 0x0, 0x0, 0x81e1, 0x81e2, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81bc, 0x81bd, 0x0, 0x0, 0x81ba, 0x81bb,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x81db, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81dc, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x849f, 0x84aa, 0x84a0, 0x84ab, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x84a1, 0x0, 0x0, 0x84ac,
 0x84a2, 0x0, 0x0, 0x84ad, 0x84a4, 0x0, 0x0, 0x84af,
 0x84a3, 0x0, 0x0, 0x84ae, 0x84a5, 0x84ba, 0x0, 0x0,
 0x84b5, 0x0, 0x0, 0x84b0, 0x84a7, 0x84bc, 0x0, 0x0,
 0x84b7, 0x0, 0x0, 0x84b2, 0x84a6, 0x0, 0x0, 0x84b6,
 0x84bb, 0x0, 0x0, 0x84b1, 0x84a8, 0x0, 0x0, 0x84b8,
 0x84bd, 0x0, 0x0, 0x84b3, 0x84a9, 0x0, 0x0, 0x84b9,
 0x0, 0x0, 0x84be, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x84b4, 0x0, 0x0, 0x0, 0x0,
 0x81a1, 0x81a0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81a3, 0x81a2, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x81a5, 0x81a4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x819f, 0x819e,
 0x0, 0x0, 0x0, 0x819b, 0x0, 0x0, 0x819d, 0x819c,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x819a, 0x8199, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x818a, 0x0, 0x8189, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81f4, 0x0, 0x0, 0x81f3, 0x0, 0x81f2,
 0x8140, 0x8141, 0x8142, 0x8156, 0x8157, 0x8158, 0x8159, 0x815a,
 0x8171, 0x8172, 0x8173, 0x8174, 0x8175, 0x8176, 0x8177, 0x8178,
 0x8179, 0x817a, 0x81a7, 0x81ac, 0x816b, 0x816c, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x829f, 0x82a0, 0x82a1, 0x82a2, 0x82a3, 0x82a4, 0x82a5,
 0x82a6, 0x82a7, 0x82a8, 0x82a9, 0x82aa, 0x82ab, 0x82ac, 0x82ad,
 0x82ae, 0x82af, 0x82b0, 0x82b1, 0x82b2, 0x82b3, 0x82b4, 0x82b5,
 0x82b6, 0x82b7, 0x82b8, 0x82b9, 0x82ba, 0x82bb, 0x82bc, 0x82bd,
 0x82be, 0x82bf, 0x82c0, 0x82c1, 0x82c2, 0x82c3, 0x82c4, 0x82c5,
 0x82c6, 0x82c7, 0x82c8, 0x82c9, 0x82ca, 0x82cb, 0x82cc, 0x82cd,
 0x82ce, 0x82cf, 0x82d0, 0x82d1, 0x82d2, 0x82d3, 0x82d4, 0x82d5,
 0x82d6, 0x82d7, 0x82d8, 0x82d9, 0x82da, 0x82db, 0x82dc, 0x82dd,
 0x82de, 0x82df, 0x82e0, 0x82e1, 0x82e2, 0x82e3, 0x82e4, 0x82e5,
 0x82e6, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82eb, 0x82ec, 0x82ed,
 0x82ee, 0x82ef, 0x82f0, 0x82f1, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x814a, 0x814b, 0x8154, 0x8155, 0x0,
 0x0, 0x8340, 0x8341, 0x8342, 0x8343, 0x8344, 0x8345, 0x8346,
 0x8347, 0x8348, 0x8349, 0x834a, 0x834b, 0x834c, 0x834d, 0x834e,
 0x834f, 0x8350, 0x8351, 0x8352, 0x8353, 0x8354, 0x8355, 0x8356,
 0x8357, 0x8358, 0x8359, 0x835a, 0x835b, 0x835c, 0x835d, 0x835e,
 0x835f, 0x8360, 0x8361, 0x8362, 0x8363, 0x8364, 0x8365, 0x8366,
 0x8367, 0x8368, 0x8369, 0x836a, 0x836b, 0x836c, 0x836d, 0x836e,
 0x836f, 0x8370, 0x8371, 0x8372, 0x8373, 0x8374, 0x8375, 0x8376,
 0x8377, 0x8378, 0x8379, 0x837a, 0x837b, 0x837c, 0x837d, 0x837e,
 0x8380, 0x8381, 0x8382, 0x8383, 0x8384, 0x8385, 0x8386, 0x8387,
 0x8388, 0x8389, 0x838a, 0x838b, 0x838c, 0x838d, 0x838e, 0x838f,
 0x8390, 0x8391, 0x8392, 0x8393, 0x8394, 0x8395, 0x8396, 0x0,
 0x0, 0x0, 0x0, 0x8145, 0x815b, 0x8152, 0x8153, 0x0,
 0x88ea, 0x929a, 0x0, 0x8eb5, 0x0, 0x0, 0x0, 0x969c,
 0x8fe4, 0x8e4f, 0x8fe3, 0x89ba, 0x0, 0x9573, 0x975e, 0x0,
 0x98a0, 0x894e, 0x0, 0x0, 0x8a8e, 0x98a1, 0x90a2, 0x99c0,
 0x8b75, 0x95b8, 0x0, 0x0, 0x0, 0x0, 0x8fe5, 0x0,
 0x0, 0x97bc, 0x0, 0x0, 0x0, 0x0, 0x95c0, 0x0,
 0x0, 0x0, 0x98a2, 0x0, 0x0, 0x9286, 0x0, 0x0,
 0x0, 0x98a3, 0x8bf8, 0x0, 0x0, 0x0, 0x98a4, 0x0,
 0x8adb, 0x924f, 0x0, 0x8ee5, 0x98a5, 0x0, 0x0, 0x98a6,
 0x0, 0x0, 0x98a7, 0x9454, 0x0, 0x8b76, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9456, 0x0, 0x93e1, 0x8cc1, 0x9652,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe568, 0x98a8, 0x8fe6,
 0x98a9, 0x89b3, 0x0, 0x0, 0x0, 0x8be3, 0x8cee, 0x96e7,
 0x0, 0x0, 0x9ba4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9790, 0x0, 0x93fb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8aa3, 0x0,
 0x8b54, 0x0, 0x98aa, 0x0, 0x0, 0x98ab, 0x97b9, 0x0,
 0x975c, 0x9188, 0x98ad, 0x8e96, 0x93f1, 0x0, 0x98b0, 0x0,
 0x0, 0x895d, 0x8cdd, 0x0, 0x8cdc, 0x88e4, 0x0, 0x0,
 0x986a, 0x9869, 0x0, 0x8db1, 0x889f, 0x0, 0x98b1, 0x98b2,
 0x98b3, 0x9653, 0x98b4, 0x0, 0x8cf0, 0x88e5, 0x9692, 0x0,
 0x8b9c, 0x0, 0x0, 0x8b9d, 0x8b9e, 0x92e0, 0x97ba, 0x0,
 0x98b5, 0x0, 0x0, 0x98b6, 0x0, 0x0, 0x98b7, 0x0,
 0x0, 0x0, 0x906c, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8f59, 0x906d, 0x98bc, 0x0, 0x98ba, 0x0, 0x98bb, 0x8b77,
 0x0, 0x0, 0x8da1, 0x89ee, 0x0, 0x98b9, 0x98b8, 0x95a7,
 0x0, 0x0, 0x0, 0x0, 0x8e65, 0x8e64, 0x91bc, 0x98bd,
 0x9574, 0x90e5, 0x0, 0x0, 0x0, 0x0, 0x98be, 0x98c0,
 0x0, 0x0, 0x0, 0x91e3, 0x97df, 0x88c8, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x98bf, 0x89bc, 0x0,
 0x8bc2, 0x0, 0x9287, 0x0, 0x0, 0x0, 0x8c8f, 0x98c1,
 0x0, 0x0, 0x0, 0x9443, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8ae9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x98c2, 0x88c9, 0x0, 0x0, 0x8cde, 0x8aea, 0x959a,
 0x94b0, 0x8b78, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x89ef, 0x0, 0x98e5, 0x9360, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x948c,
 0x98c4, 0x0, 0x0, 0x0, 0x94ba, 0x0, 0x97e0, 0x0,
 0x904c, 0x0, 0x8e66, 0x0, 0x8e97, 0x89be, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x92cf, 0x0, 0x0, 0x9241, 0x98c8,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x88ca, 0x92e1, 0x8f5a,
 0x8db2, 0x9743, 0x0, 0x91cc, 0x0, 0x89bd, 0x0, 0x98c7,
 0x0, 0x975d, 0x98c3, 0x98c5, 0x8dec, 0x98c6, 0x9b43, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x98ce, 0x0, 0x0, 0x0, 0x0, 0x0, 0x98d1,
 0x98cf, 0x0, 0x0, 0x89c0, 0x0, 0x95b9, 0x98c9, 0x0,
 0x0, 0x0, 0x0, 0x98cd, 0x8cf1, 0x0, 0x0, 0x8e67,
 0x0, 0x0, 0x0, 0x8aa4, 0x0, 0x0, 0x98d2, 0x0,
 0x98ca, 0x0, 0x0, 0x97e1, 0x0, 0x8e98, 0x0, 0x98cb,
 0x0, 0x98d0, 0x0, 0x0, 0x0, 0x0, 0x98d3, 0x0,
 0x98cc, 0x0, 0x0, 0x8b9f, 0x0, 0x88cb, 0x0, 0x0,
 0x8ba0, 0x89bf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9b44, 0x0, 0x9699, 0x958e, 0x8cf2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x904e, 0x97b5, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x95d6,
 0x0, 0x0, 0x8c57, 0x91a3, 0x89e2, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8f72, 0x0, 0x0, 0x0, 0x98d7, 0x0,
 0x98dc, 0x98da, 0x0, 0x0, 0x98d5, 0x0, 0x0, 0x91ad,
 0x98d8, 0x0, 0x98db, 0x98d9, 0x0, 0x95db, 0x0, 0x98d6,
 0x0, 0x904d, 0x9693, 0x0, 0x98dd, 0x98de, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f43, 0x98eb,
 0x0, 0x0, 0x0, 0x946f, 0x0, 0x9555, 0x98e6, 0x0,
 0x95ee, 0x0, 0x89b4, 0x0, 0x0, 0x0, 0x98ea, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x98e4, 0x98ed, 0x0,
 0x0, 0x9171, 0x0, 0x8cc2, 0x0, 0x947b, 0x0, 0xe0c5,
 0x0, 0x98ec, 0x937c, 0x0, 0x98e1, 0x0, 0x8cf4, 0x0,
 0x0, 0x8cf3, 0x98df, 0x0, 0x0, 0x0, 0x0, 0x8ed8,
 0x0, 0x98e7, 0x0, 0x95ed, 0x926c, 0x98e3, 0x8c91, 0x0,
 0x98e0, 0x98e8, 0x98e2, 0x97cf, 0x98e9, 0x9860, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8be4, 0x0,
 0x0, 0x8c90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x98ee, 0x0, 0x0, 0x0, 0x98ef,
 0x98f3, 0x88cc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x95ce,
 0x98f2, 0x0, 0x0, 0x0, 0x0, 0x98f1, 0x98f5, 0x0,
 0x0, 0x0, 0x98f4, 0x0, 0x92e2, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c92, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x98f6, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8ec3, 0x0, 0x91a4, 0x92e3, 0x8bf4, 0x0,
 0x98f7, 0x0, 0x0, 0x0, 0x0, 0x8b55, 0x0, 0x0,
 0x98f8, 0x0, 0x0, 0x0, 0x0, 0x98fa, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9654, 0x0, 0x0,
 0x0, 0x8c86, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8e50, 0x94f5, 0x98f9, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8dc3, 0x9762, 0x0, 0x0,
 0x0, 0x0, 0x98fc, 0x9942, 0x98fb, 0x8dc2, 0x0, 0x8f9d,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c58, 0x0,
 0x0, 0x0, 0x9943, 0x0, 0x0, 0x8bcd, 0x0, 0x0,
 0x0, 0x9940, 0x9941, 0x0, 0x0, 0x93ad, 0x0, 0x919c,
 0x0, 0x8ba1, 0x0, 0x0, 0x0, 0x966c, 0x9944, 0x0,
 0x0, 0x0, 0x97bb, 0x0, 0x0, 0x0, 0x9945, 0x0,
 0x0, 0x0, 0x0, 0x9948, 0x0, 0x9946, 0x0, 0x916d,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9947, 0x9949, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x994b, 0x0, 0x0,
 0x0, 0x994a, 0x0, 0x95c6, 0x0, 0x0, 0x0, 0x0,
 0x8b56, 0x994d, 0x994e, 0x0, 0x89ad, 0x0, 0x0, 0x0,
 0x0, 0x994c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8ef2, 0x0, 0x9951, 0x9950, 0x994f, 0x0,
 0x98d4, 0x0, 0x9952, 0x0, 0x0, 0x0, 0x0, 0x8f9e,
 0x0, 0x9953, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9744, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x96d7, 0x0, 0x0, 0x0, 0x0, 0x9955,
 0x0, 0x0, 0x9954, 0x9957, 0x9956, 0x0, 0x0, 0x9958,
 0x9959, 0x88f2, 0x0, 0x8cb3, 0x8c5a, 0x8f5b, 0x929b, 0x8ba2,
 0x90e6, 0x8cf5, 0x0, 0x8d8e, 0x995b, 0x96c6, 0x9365, 0x0,
 0x8e99, 0x0, 0x995a, 0x0, 0x995c, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x937d, 0x0, 0x8a95, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x995d, 0x0, 0x0, 0x93fc, 0x0, 0x0,
 0x9153, 0x995f, 0x9960, 0x94aa, 0x8cf6, 0x985a, 0x9961, 0x0,
 0x0, 0x8ba4, 0x0, 0x0, 0x0, 0x95ba, 0x91b4, 0x8bef,
 0x9354, 0x0, 0x0, 0x0, 0x8c93, 0x0, 0x0, 0x0,
 0x9962, 0x0, 0x9963, 0x0, 0x0, 0x93e0, 0x897e, 0x0,
 0x0, 0x9966, 0x8dfb, 0x0, 0x9965, 0x8dc4, 0x0, 0x9967,
 0xe3ec, 0x9968, 0x9660, 0x0, 0x9969, 0x996a, 0x996b, 0x8fe7,
 0x0, 0x8eca, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8aa5, 0x0, 0x996e, 0x0, 0x996c, 0x96bb, 0x996d, 0x0,
 0x9579, 0x996f, 0x9970, 0x9971, 0x937e, 0x0, 0x0, 0x0,
 0x9975, 0x9973, 0x9974, 0x9972, 0x8de1, 0x9976, 0x96e8, 0x97e2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9977, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x90a6, 0x9978, 0x8f79, 0x0,
 0x0, 0x9979, 0x0, 0x929c, 0x97bd, 0x9380, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x99c3, 0x0,
 0x0, 0x0, 0x0, 0x997a, 0xeaa3, 0x8bc3, 0x0, 0x0,
 0x997b, 0x967d, 0x0, 0x0, 0x0, 0x0, 0x8f88, 0x91fa,
 0x0, 0x997d, 0x93e2, 0x0, 0x0, 0x997e, 0x0, 0x0,
 0x9980, 0x8a4d, 0x0, 0x0, 0x0, 0x9981, 0x8ba5, 0x0,
 0x93ca, 0x899a, 0x8f6f, 0x0, 0x0, 0x949f, 0x9982, 0x0,
 0x9381, 0x0, 0x0, 0x906e, 0x9983, 0x0, 0x95aa, 0x90d8,
 0x8aa0, 0x0, 0x8aa7, 0x9984, 0x0, 0x0, 0x9986, 0x0,
 0x0, 0x8c59, 0x0, 0x0, 0x9985, 0x0, 0x0, 0x97f1,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f89, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x94bb, 0x95ca, 0x0, 0x9987,
 0x0, 0x9798, 0x9988, 0x0, 0x0, 0x0, 0x9989, 0x0,
 0x939e, 0x0, 0x0, 0x998a, 0x0, 0x0, 0x90a7, 0x8dfc,
 0x8c94, 0x998b, 0x8e68, 0x8d8f, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x92e4, 0x998d, 0x0, 0x0, 0x91a5,
 0x0, 0x0, 0x8ded, 0x998e, 0x998f, 0x914f, 0x0, 0x998c,
 0x0, 0x0, 0x0, 0x0, 0x9991, 0x0, 0x9655, 0x0,
 0x0, 0x0, 0x0, 0x8d84, 0x0, 0x0, 0x9990, 0x0,
 0x0, 0x0, 0x0, 0x8c95, 0x8ddc, 0x948d, 0x0, 0x0,
 0x0, 0x9994, 0x9992, 0x0, 0x0, 0x0, 0x0, 0x959b,
 0x8fe8, 0x999b, 0x8a84, 0x9995, 0x9993, 0x916e, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9997, 0x0, 0x9996,
 0x0, 0x0, 0x0, 0x8a63, 0x0, 0x0, 0x0, 0x8c80,
 0x999c, 0x97ab, 0x0, 0x0, 0x0, 0x9998, 0x0, 0x0,
 0x0, 0x999d, 0x999a, 0x0, 0x9999, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x97cd, 0x0, 0x0, 0x0, 0x8cf7,
 0x89c1, 0x0, 0x0, 0x97f2, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8f95, 0x9377, 0x8d85, 0x99a0, 0x99a1, 0x0, 0x0,
 0x0, 0x97e3, 0x0, 0x0, 0x984a, 0x99a3, 0x0, 0x0,
 0x0, 0x8cf8, 0x0, 0x0, 0x99a2, 0x0, 0x8a4e, 0x0,
 0x0, 0x99a4, 0x0, 0x9675, 0x0, 0x92ba, 0x0, 0x9745,
 0x0, 0x95d7, 0x0, 0x0, 0x0, 0x99a5, 0x0, 0x0,
 0x0, 0x0, 0xe8d3, 0x0, 0x0, 0x93ae, 0x0, 0x99a6,
 0x8aa8, 0x96b1, 0x0, 0x0, 0x0, 0x8f9f, 0x99a7, 0x95e5,
 0x99ab, 0x0, 0x90a8, 0x99a8, 0x8bce, 0x0, 0x99a9, 0x8aa9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8c4d, 0x99ac, 0x0, 0x99ad, 0x0, 0x0,
 0x99ae, 0x99af, 0x8ed9, 0x0, 0x0, 0x0, 0x8cf9, 0x96dc,
 0x0, 0x96e6, 0x93f5, 0x0, 0x0, 0x95ef, 0x99b0, 0x0,
 0x99b1, 0x0, 0x0, 0x0, 0x0, 0x99b3, 0x0, 0x99b5,
 0x99b4, 0x0, 0x0, 0x0, 0x0, 0x99b6, 0x89bb, 0x966b,
 0x0, 0x8dfa, 0x99b7, 0x0, 0x0, 0x9178, 0x0, 0x0,
 0x8fa0, 0x8ba7, 0x0, 0x99b8, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x94d9, 0x0, 0x0, 0x0, 0x0, 0x99b9,
 0x0, 0x99ba, 0x0, 0x99bb, 0x0, 0x0, 0x0, 0x0,
 0x99bc, 0x9543, 0x8be6, 0x88e3, 0x0, 0x0, 0x0, 0x93bd,
 0x99bd, 0x8f5c, 0x0, 0x90e7, 0x0, 0x99bf, 0x99be, 0x8fa1,
 0x8cdf, 0x0, 0x99c1, 0x94bc, 0x0, 0x0, 0x99c2, 0x0,
 0x0, 0x0, 0x94da, 0x91b2, 0x91ec, 0x8ba6, 0x0, 0x93ec,
 0x9250, 0x0, 0x948e, 0x0, 0x966d, 0x0, 0x99c4, 0x0,
 0x90e8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c54, 0x0,
 0x0, 0x99c5, 0x0, 0x0, 0x0, 0x0, 0x99c6, 0x894b,
 0x88f3, 0x8aeb, 0x0, 0x91a6, 0x8b70, 0x9791, 0x0, 0x99c9,
 0x89b5, 0x0, 0x0, 0x99c8, 0x0, 0x0, 0x0, 0x8ba8,
 0x0, 0x0, 0x99ca, 0x0, 0x96ef, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x99cb, 0x0,
 0x97d0, 0x0, 0x8cfa, 0x0, 0x0, 0x0, 0x0, 0x8cb4,
 0x99cc, 0x0, 0x0, 0x0, 0x0, 0x99ce, 0x99cd, 0x0,
 0x907e, 0x8958, 0x0, 0x0, 0x0, 0x897d, 0x99cf, 0x0,
 0x99d0, 0x0, 0x0, 0x8cb5, 0x0, 0x0, 0x99d1, 0x0,
 0x0, 0x0, 0x0, 0x8b8e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8e51, 0x99d2, 0x0, 0x0, 0x0, 0x0,
 0x9694, 0x8db3, 0x8b79, 0x9746, 0x916f, 0x94bd, 0x8efb, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8f66, 0x0, 0x8ee6, 0x8ef3,
 0x0, 0x8f96, 0x0, 0x94be, 0x0, 0x0, 0x0, 0x99d5,
 0x0, 0x8962, 0x0, 0x9170, 0x8cfb, 0x8cc3, 0x8be5, 0x0,
 0x0, 0x99d9, 0x9240, 0x91fc, 0x8ba9, 0x8fa2, 0x99da, 0x99d8,
 0x89c2, 0x91e4, 0x8eb6, 0x8e6a, 0x8945, 0x0, 0x0, 0x8a90,
 0x8d86, 0x8e69, 0x0, 0x99db, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x99dc, 0x0, 0x8b68, 0x8a65, 0x0, 0x0,
 0x0, 0x8d87, 0x8b67, 0x92dd, 0x8944, 0x93af, 0x96bc, 0x8d40,
 0x9799, 0x9366, 0x8cfc, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8c4e, 0x0, 0x99e5, 0x0,
 0x8be1, 0x9669, 0x0, 0x0, 0x0, 0x0, 0x0, 0x94db,
 0x0, 0x0, 0x99e4, 0x0, 0x8adc, 0x99df, 0x99e0, 0x99e2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x99e3,
 0x0, 0x8b7a, 0x9081, 0x0, 0x95ab, 0x99e1, 0x99dd, 0x8ce1,
 0x0, 0x99de, 0x8d90, 0x0, 0x9843, 0x0, 0x0, 0x0,
 0x95f0, 0x0, 0x92e6, 0x8ce0, 0x0, 0x0, 0x0, 0x99e6,
 0x0, 0x0, 0x93db, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x99ea, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8efc, 0x0, 0x8ef4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x99ed, 0x99eb, 0x0, 0x96a1, 0x0, 0x99e8, 0x99f1,
 0x99ec, 0x0, 0x0, 0x0, 0x99ef, 0x8cc4, 0x96bd, 0x0,
 0x0, 0x99f0, 0x0, 0x0, 0x0, 0x99f2, 0x0, 0x99f4,
 0x0, 0x0, 0x0, 0x0, 0x8dee, 0x8cec, 0x9861, 0x0,
 0x99e9, 0x99e7, 0x99f3, 0x0, 0x99ee, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x99f6, 0x0, 0x9a42, 0x99f8,
 0x0, 0x0, 0x99fc, 0x0, 0x0, 0x9a40, 0x99f9, 0x0,
 0x0, 0x9a5d, 0x0, 0x0, 0x8de7, 0x8a50, 0x0, 0x0,
 0x0, 0x0, 0x99f7, 0x0, 0x0, 0x0, 0x9a44, 0x88f4,
 0x9a43, 0x0, 0x88a3, 0x9569, 0x9a41, 0x0, 0x99fa, 0x0,
 0x0, 0x99f5, 0x99fb, 0x8dc6, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9a45, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x88f5, 0x9a4e, 0x0, 0x0, 0x9a46,
 0x9a47, 0x0, 0x8fa3, 0x9689, 0x0, 0x0, 0x0, 0x9a4c,
 0x9a4b, 0x0, 0x0, 0x0, 0x934e, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9a4d, 0x0, 0x0, 0x9a4a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8953, 0x0,
 0x8db4, 0x904f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9a48, 0x9382, 0x0, 0x0, 0x9a49, 0x0, 0x88a0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a53, 0x9742, 0x0, 0x8fa5, 0x0, 0x9a59, 0x0, 0x0,
 0x0, 0x0, 0x9a58, 0x9a4f, 0x0, 0x0, 0x0, 0x0,
 0x91c1, 0x0, 0x9a50, 0x0, 0x0, 0x0, 0x91ed, 0x9a55,
 0x8fa4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a52, 0x0,
 0x0, 0x96e2, 0x0, 0x0, 0x0, 0x8c5b, 0x0, 0x0,
 0x9a56, 0x9a57, 0x0, 0x0, 0x0, 0x0, 0x9a54, 0x9a5a,
 0x0, 0x0, 0x0, 0x0, 0x9a51, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9a60, 0x9a65, 0x0, 0x9a61, 0x0,
 0x9a5c, 0x0, 0x0, 0x9a66, 0x9150, 0x0, 0x0, 0x9a68,
 0x0, 0x8d41, 0x9a5e, 0x929d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a62, 0x9a5b, 0x8aab, 0x0, 0x8aec, 0x8a85, 0x9a63, 0x9a5f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c96,
 0x9a69, 0x9a67, 0x9172, 0x8b69, 0x8baa, 0x0, 0x9a64, 0x0,
 0x8bf2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8963, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a6d, 0x9a6b, 0x0,
 0x9aa5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a70, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9a6a, 0x0, 0x9a6e, 0x0, 0x0,
 0x9a6c, 0x0, 0x0, 0x0, 0x8e6b, 0x9a6f, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a72, 0x0, 0x9a77, 0x0, 0x0, 0x0, 0x9a75, 0x9a74,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9251,
 0x0, 0x0, 0x89c3, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a71, 0x0, 0x9a73,
 0x8fa6, 0x8952, 0x0, 0x0, 0x9a76, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x89dc, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a82, 0x0, 0x8ffa, 0x9a7d, 0x0, 0x9a7b, 0x0, 0x9a7c,
 0x0, 0x9a7e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x895c, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9158, 0x0, 0x9a78,
 0x0, 0x9a79, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8a9a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9a81, 0x0, 0x0, 0x0,
 0x8aed, 0x0, 0x9a84, 0x9a80, 0x9a83, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x95ac, 0x0, 0x0, 0x0,
 0x93d3, 0x0, 0x94b6, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a86, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a85, 0x8a64,
 0x0, 0x0, 0x9a87, 0x0, 0x0, 0x0, 0x0, 0x9a8a,
 0x0, 0x0, 0x0, 0x0, 0x9a89, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a88, 0x0, 0x9458, 0x0, 0x0, 0x9a8b, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a8c, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9a8e, 0x0, 0x9a8d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9a90, 0x0, 0x0, 0x0,
 0x9a93, 0x9a91, 0x9a8f, 0x9a92, 0x0, 0x0, 0x0, 0x0,
 0x9a94, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a95, 0x0,
 0x0, 0x9a96, 0x0, 0x9a97, 0x0, 0x0, 0x0, 0x9a98,
 0x9964, 0x0, 0x8efa, 0x8e6c, 0x0, 0x0, 0x89f1, 0x0,
 0x88f6, 0x0, 0x0, 0x9263, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a99, 0x0,
 0x8da2, 0x0, 0x88cd, 0x907d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9a9a, 0x8cc5, 0x0, 0x0, 0x8d91, 0x0, 0x9a9c,
 0x9a9b, 0x0, 0x0, 0x95de, 0x9a9d, 0x0, 0x0, 0x0,
 0x9a9f, 0x9a9e, 0x0, 0x9aa0, 0x8c97, 0x0, 0x9aa1, 0x0,
 0x0, 0x0, 0x8980, 0x9aa2, 0x0, 0x0, 0x9aa4, 0x0,
 0x9aa3, 0x0, 0x0, 0x0, 0x9aa6, 0x0, 0x0, 0x9379,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9aa7, 0x88b3,
 0x8ddd, 0x0, 0x0, 0x0, 0x0, 0x8c5c, 0x0, 0x0,
 0x926e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9aa8,
 0x9aa9, 0x0, 0x0, 0x9aab, 0x0, 0x0, 0x0, 0x0,
 0x9aac, 0x0, 0x8de2, 0x0, 0x0, 0x0, 0x0, 0x8bcf,
 0x0, 0x0, 0x9656, 0x0, 0x0, 0x0, 0x9aaa, 0x9aad,
 0x8dbf, 0x8d42, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9ab1, 0x0, 0x0, 0x8da3, 0x0, 0x9252, 0x0,
 0x0, 0x9aae, 0x92d8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9ab2,
 0x0, 0x0, 0x9082, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9ab0, 0x9ab3, 0x0, 0x8c5e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ab4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9ab5, 0x0, 0x8d43, 0x8a5f, 0x9ab7, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9ab8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9ab9, 0x0, 0x0, 0x9ab6, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9aaf, 0x0, 0x0, 0x9aba, 0x0, 0x0, 0x9abb, 0x0,
 0x0, 0x0, 0x0, 0x9684, 0x0, 0x0, 0x8fe9, 0x0,
 0x0, 0x0, 0x9abd, 0x9abe, 0x9abc, 0x0, 0x9ac0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9457, 0x0, 0x0, 0x88e6,
 0x9575, 0x0, 0x0, 0x9ac1, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8ffb, 0x0, 0x0, 0x8eb7,
 0x0, 0x947c, 0x8aee, 0x0, 0x8de9, 0x0, 0x0, 0x0,
 0x9678, 0x0, 0x93b0, 0x0, 0x0, 0x8c98, 0x91cd, 0x0,
 0x0, 0x0, 0x9abf, 0x9ac2, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x91c2, 0x0, 0x0,
 0x0, 0x9ac3, 0x0, 0x0, 0x0, 0x9ac4, 0x0, 0x0,
 0x0, 0x9ac6, 0x0, 0x0, 0x92e7, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8aac, 0x0, 0x0, 0x0, 0x0, 0xea9f,
 0x8981, 0x95f1, 0x0, 0x0, 0x8fea, 0x9367, 0x0, 0x0,
 0x0, 0x0, 0x8de4, 0x0, 0x0, 0x9acc, 0x0, 0x0,
 0x95bb, 0x97db, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x89f2, 0x9ac8, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9159, 0x9acb, 0x0, 0x9383, 0x0, 0x0, 0x9368,
 0x9384, 0x94b7, 0x92cb, 0x0, 0x0, 0x0, 0x8dc7, 0x0,
 0x0, 0x0, 0x9ac7, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8996, 0x0, 0x9355, 0x0, 0x0, 0x0, 0x0,
 0x9ac9, 0x0, 0x9ac5, 0x0, 0x0, 0x906f, 0x0, 0x0,
 0x0, 0x9acd, 0x0, 0x0, 0x0, 0x0, 0x8f6d, 0x0,
 0x0, 0x0, 0x0, 0x8bab, 0x0, 0x9ace, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x95e6, 0x0, 0x0, 0x0, 0x919d,
 0x0, 0x0, 0x0, 0x0, 0x92c4, 0x0, 0x0, 0x9ad0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x966e, 0x0, 0x0, 0x9ad1, 0x0, 0x0, 0x9ad6, 0x0,
 0x0, 0x0, 0x0, 0x95ad, 0x0, 0x0, 0x0, 0x0,
 0x9ad5, 0x9acf, 0x9ad2, 0x9ad4, 0x0, 0x0, 0x8da4, 0x0,
 0x0, 0x95c7, 0x0, 0x0, 0x0, 0x9ad7, 0x0, 0x9264,
 0x0, 0x0, 0x89f3, 0x0, 0x8feb, 0x0, 0x0, 0x0,
 0x0, 0x9ad9, 0x0, 0x9ad8, 0x0, 0x8d88, 0x0, 0x9ada,
 0x9adc, 0x9adb, 0x0, 0x0, 0x9ade, 0x0, 0x9ad3, 0x9ae0,
 0x0, 0x0, 0x0, 0x9adf, 0x9add, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8e6d, 0x9070, 0x0, 0x9173, 0x9ae1, 0x90ba,
 0x88eb, 0x9484, 0x0, 0x0, 0x0, 0x0, 0x92d9, 0x0,
 0x9ae3, 0x9ae2, 0x9ae4, 0x9ae5, 0x9ae6, 0x0, 0x0, 0x0,
 0x0, 0x9ae7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9ae8, 0x0, 0x0, 0x95cf, 0x0, 0x0, 0x89c4, 0x9ae9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x975b, 0x8a4f, 0x0,
 0x99c7, 0x8f67, 0x91bd, 0x9aea, 0x96e9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x96b2, 0x0, 0x0, 0x9aec, 0x0, 0x91e5,
 0x0, 0x9356, 0x91be, 0x9576, 0x9aed, 0x9aee, 0x899b, 0x0,
 0x0, 0x8eb8, 0x9aef, 0x0, 0x0, 0x0, 0x0, 0x88ce,
 0x9af0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9af1, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8982, 0x0, 0x0, 0x8aef,
 0x93de, 0x95f2, 0x0, 0x0, 0x0, 0x0, 0x9af5, 0x9174,
 0x9af4, 0x8c5f, 0x0, 0x0, 0x967a, 0x9af3, 0x0, 0x9385,
 0x9af7, 0x0, 0x9af6, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9af9, 0x0, 0x9af8, 0x0, 0x0, 0x899c, 0x0, 0x9afa,
 0x8fa7, 0x9afc, 0x9244, 0x0, 0x9afb, 0x0, 0x95b1, 0x0,
 0x0, 0x0, 0x0, 0x8f97, 0x937a, 0x0, 0x0, 0x0,
 0x9b40, 0x0, 0x0, 0x0, 0x0, 0x8d44, 0x0, 0x0,
 0x0, 0x9b41, 0x9440, 0x94dc, 0x96cf, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9444, 0x0, 0x0, 0x9b4a, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8b57, 0x0, 0x0, 0x9764, 0x0,
 0x0, 0x96ad, 0x0, 0x9baa, 0x0, 0x9b42, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9b45, 0x0, 0x91c3, 0x0, 0x0,
 0x9657, 0x0, 0x0, 0x0, 0x9369, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9b46, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9685, 0x0, 0x8dc8, 0x0, 0x0, 0x8fa8, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b47, 0x0,
 0x0, 0x8e6f, 0x0, 0x8e6e, 0x0, 0x0, 0x0, 0x0,
 0x88b7, 0x8cc6, 0x0, 0x90a9, 0x88cf, 0x0, 0x0, 0x0,
 0x0, 0x9b4b, 0x9b4c, 0x0, 0x9b49, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8957, 0x8aad, 0x0,
 0x9b48, 0x0, 0x96c3, 0x9550, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88a6, 0x0,
 0x0, 0x0, 0x0, 0x88f7, 0x0, 0x0, 0x0, 0x8e70,
 0x0, 0x88d0, 0x0, 0x88a1, 0x0, 0x0, 0x0, 0x0,
 0x9b51, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9b4f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x96ba,
 0x0, 0x9b52, 0x0, 0x9b50, 0x0, 0x0, 0x9b4e, 0x9050,
 0x0, 0x0, 0x0, 0x0, 0x9b4d, 0x0, 0x0, 0x0,
 0x95d8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ce2, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b56, 0x9b57, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8fa9, 0x0, 0x0, 0x0,
 0x9b53, 0x984b, 0x0, 0x0, 0x0, 0x0, 0x946b, 0x0,
 0x0, 0x9b55, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8da5, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9b58, 0x0, 0x0, 0x0, 0x9577, 0x0,
 0x0, 0x0, 0x9b59, 0x0, 0x9b54, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x96b9, 0x0,
 0x0, 0x947d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9b5a, 0x9551, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9b5b, 0x9b5f, 0x9b5c, 0x0, 0x0,
 0x89c5, 0x9b5e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8eb9, 0x0, 0x9b5d, 0x8c99, 0x0, 0x0, 0x0, 0x9b6b,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b64, 0x9b61, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9284, 0x0, 0x9b60, 0x0, 0x0, 0x9b62, 0x0, 0x0,
 0x9b63, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9b65, 0x9b66, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8af0, 0x0, 0x9b68, 0x9b67, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b69, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8fec, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9b6c, 0x0, 0x92da, 0x0, 0x0, 0x0, 0x8964,
 0x0, 0x9b6a, 0x0, 0x0, 0x0, 0x9b6d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b6e, 0x0, 0x9b71,
 0x0, 0x0, 0x9b6f, 0x0, 0x9b70, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e71,
 0x9b72, 0x0, 0x8d45, 0x0, 0x9b73, 0x0, 0x8e9a, 0x91b6,
 0x0, 0x9b74, 0x9b75, 0x8e79, 0x8d46, 0x0, 0x96d0, 0x0,
 0x0, 0x0, 0x8b47, 0x8cc7, 0x9b76, 0x8a77, 0x0, 0x0,
 0x9b77, 0x0, 0x91b7, 0x0, 0x0, 0x0, 0x0, 0x9b78,
 0x9ba1, 0x0, 0x9b79, 0x0, 0x9b7a, 0x0, 0x0, 0x9b7b,
 0x0, 0x9b7d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b7e,
 0x0, 0x0, 0x9b80, 0x0, 0x91ee, 0x0, 0x8946, 0x8ee7,
 0x88c0, 0x0, 0x9176, 0x8aae, 0x8eb3, 0x0, 0x8d47, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9386, 0x0, 0x8f40, 0x8aaf,
 0x9288, 0x92e8, 0x88b6, 0x8b58, 0x95f3, 0x0, 0x8ec0, 0x0,
 0x0, 0x8b71, 0x90e9, 0x8eba, 0x9747, 0x9b81, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b7b, 0x0, 0x8dc9,
 0x0, 0x0, 0x8a51, 0x8983, 0x8faa, 0x89c6, 0x0, 0x9b82,
 0x9765, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f68, 0x0,
 0x0, 0x8ee2, 0x9b83, 0x8af1, 0x93d0, 0x96a7, 0x9b84, 0x0,
 0x9b85, 0x0, 0x0, 0x9578, 0x0, 0x0, 0x0, 0x9b87,
 0x0, 0x8aa6, 0x8bf5, 0x9b86, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8ab0, 0x0, 0x9051, 0x9b8b, 0x8e40, 0x0,
 0x89c7, 0x9b8a, 0x0, 0x9b88, 0x9b8c, 0x9b89, 0x944a, 0x9ecb,
 0x9052, 0x0, 0x9b8d, 0x0, 0x0, 0x97be, 0x0, 0x9b8e,
 0x0, 0x0, 0x9b90, 0x0, 0x929e, 0x9b8f, 0x0, 0x90a1,
 0x0, 0x8e9b, 0x0, 0x0, 0x0, 0x91ce, 0x8ef5, 0x0,
 0x9595, 0x8fab, 0x90ea, 0x0, 0x8ecb, 0x9b91, 0x9b92, 0x9b93,
 0x88d1, 0x91b8, 0x9071, 0x0, 0x9b94, 0x93b1, 0x8fac, 0x0,
 0x8fad, 0x0, 0x9b95, 0x0, 0x0, 0x90eb, 0x0, 0x0,
 0x0, 0x8fae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b96,
 0x0, 0x9b97, 0x0, 0x96de, 0x0, 0x0, 0x0, 0x9b98,
 0x0, 0x0, 0x0, 0x0, 0x8bc4, 0x0, 0x0, 0x0,
 0x8f41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b99,
 0x9b9a, 0x8eda, 0x904b, 0x93f2, 0x9073, 0x94f6, 0x9441, 0x8bc7,
 0x9b9b, 0x0, 0x0, 0x0, 0x8b8f, 0x9b9c, 0x0, 0x8bfc,
 0x0, 0x93cd, 0x89ae, 0x0, 0x8e72, 0x9b9d, 0x9ba0, 0x9b9f,
 0x8bfb, 0x0, 0x9b9e, 0x0, 0x9357, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x91ae, 0x0, 0x936a,
 0x8ec6, 0x0, 0x0, 0x9177, 0x979a, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ba2, 0x0, 0x9ba3, 0x93d4, 0x0,
 0x8e52, 0x0, 0x0, 0x0, 0x0, 0x9ba5, 0x0, 0x0,
 0x9ba6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ba7, 0x0, 0x0, 0x0, 0x8af2,
 0x9ba8, 0x0, 0x0, 0x9ba9, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x89aa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x915a,
 0x8ae2, 0x0, 0x9bab, 0x96a6, 0x0, 0x0, 0x0, 0x0,
 0x91d0, 0x0, 0x8a78, 0x0, 0x0, 0x9bad, 0x9baf, 0x8add,
 0x0, 0x0, 0x9bac, 0x9bae, 0x0, 0x9bb1, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9bb0, 0x0, 0x9bb2, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9bb3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x93bb,
 0x8bac, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x89e3,
 0x9bb4, 0x9bb9, 0x0, 0x0, 0x9bb7, 0x0, 0x95f5, 0x95f4,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9387, 0x0, 0x0,
 0x0, 0x9bb6, 0x8f73, 0x0, 0x9bb5, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9092, 0x0,
 0x0, 0x0, 0x9bba, 0x0, 0x0, 0x8de8, 0x0, 0x0,
 0x9bc0, 0x0, 0x0, 0x9bc1, 0x9bbb, 0x8a52, 0x9bbc, 0x9bc5,
 0x9bc4, 0x9bc3, 0x9bbf, 0x0, 0x0, 0x0, 0x9bbe, 0x0,
 0x0, 0x9bc2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x95f6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9bc9, 0x9bc6, 0x0, 0x9bc8, 0x0, 0x9792,
 0x0, 0x9bc7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9bbd, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9093, 0x0, 0x0, 0x9bca, 0x0, 0x0, 0x8db5, 0x0,
 0x0, 0x0, 0x9bcb, 0x0, 0x0, 0x9bcc, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9bcf, 0x0, 0x9bce, 0x0, 0x0, 0x9bcd, 0x0,
 0x0, 0x0, 0x9388, 0x9bb8, 0x0, 0x0, 0x0, 0x9bd5,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9bd1, 0x0, 0x0, 0x0,
 0x0, 0x9bd0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9bd2, 0x0, 0x9bd3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9bd6, 0x0,
 0x0, 0x97e4, 0x0, 0x9bd7, 0x9bd4, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9bd8, 0x0, 0x0, 0x8ade, 0x9bd9, 0x0, 0x0, 0x0,
 0x0, 0x9bdb, 0x9bda, 0x0, 0x0, 0x9bdc, 0x0, 0x0,
 0x0, 0x0, 0x9bdd, 0x0, 0x90ec, 0x8f42, 0x0, 0x0,
 0x8f84, 0x0, 0x9183, 0x0, 0x8d48, 0x8db6, 0x8d49, 0x8b90,
 0x0, 0x0, 0x9bde, 0x0, 0x0, 0x8db7, 0x0, 0x0,
 0x8cc8, 0x9bdf, 0x96a4, 0x9462, 0x9be0, 0x0, 0x8d4a, 0x0,
 0x0, 0x0, 0x8aaa, 0x0, 0x9246, 0x8bd0, 0x0, 0x0,
 0x0, 0x8e73, 0x957a, 0x0, 0x0, 0x94bf, 0x0, 0x0,
 0x0, 0x0, 0x9be1, 0x8af3, 0x0, 0x0, 0x0, 0x0,
 0x9be4, 0x0, 0x0, 0x0, 0x0, 0x929f, 0x0, 0x0,
 0x9be3, 0x9be2, 0x9be5, 0x0, 0x92e9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9083, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8e74, 0x0, 0x90c8, 0x0, 0x91d1, 0x8b41,
 0x0, 0x0, 0x92a0, 0x0, 0x0, 0x9be6, 0x9be7, 0x8fed,
 0x0, 0x0, 0x0, 0x0, 0x9658, 0x0, 0x0, 0x9bea,
 0x0, 0x0, 0x9be9, 0x9be8, 0x959d, 0x0, 0x9bf1, 0x0,
 0x0, 0x0, 0x0, 0x9679, 0x0, 0x9beb, 0x0, 0x0,
 0x0, 0x0, 0x9bed, 0x968b, 0x0, 0x9bec, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9bee, 0x0, 0x94a6,
 0x9bef, 0x95bc, 0x9bf0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8ab1, 0x95bd, 0x944e, 0x9bf2, 0x9bf3, 0x0, 0x8d4b, 0x8ab2,
 0x9bf4, 0x8cb6, 0x9763, 0x9748, 0x8af4, 0x9bf6, 0x0, 0x92a1,
 0x0, 0x8d4c, 0x8faf, 0x0, 0x0, 0x94dd, 0x0, 0x0,
 0x8fb0, 0x0, 0x0, 0x0, 0x0, 0x8f98, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x92ea, 0x95f7, 0x9358, 0x0, 0x0,
 0x8d4d, 0x0, 0x957b, 0x0, 0x0, 0x0, 0x9bf7, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9378, 0x8dc0, 0x0, 0x0,
 0x0, 0x8cc9, 0x0, 0x92eb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x88c1, 0x8f8e, 0x8d4e, 0x9766, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9bf8,
 0x9bf9, 0x9470, 0x0, 0x0, 0x0, 0x0, 0x9bfa, 0x97f5,
 0x984c, 0x0, 0x0, 0x0, 0x0, 0x9bfc, 0x9bfb, 0x0,
 0x0, 0x8a66, 0x0, 0x0, 0x9c40, 0x0, 0x0, 0x0,
 0x9c43, 0x9c44, 0x0, 0x9c42, 0x0, 0x955f, 0x8fb1, 0x9c46,
 0x9c45, 0x9c41, 0x0, 0x0, 0x0, 0x0, 0x9c47, 0x9c48,
 0x0, 0x0, 0x9c49, 0x0, 0x0, 0x0, 0x9c4c, 0x9c4a,
 0x0, 0x9c4b, 0x9c4d, 0x0, 0x8984, 0x92ec, 0x9c4e, 0x0,
 0x8c9a, 0x89f4, 0x9455, 0x0, 0x9c4f, 0x93f9, 0x0, 0x95d9,
 0x0, 0x9c50, 0x984d, 0x0, 0x0, 0x0, 0x0, 0x9c51,
 0x95be, 0x9c54, 0x989f, 0x98af, 0x0, 0x8eae, 0x93f3, 0x9c55,
 0x0, 0x8b7c, 0x92a2, 0x88f8, 0x9c56, 0x95a4, 0x8d4f, 0x0,
 0x0, 0x926f, 0x0, 0x0, 0x0, 0x92ed, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x96ed, 0x8cb7, 0x8cca, 0x0, 0x9c57,
 0x0, 0x0, 0x0, 0x9c58, 0x0, 0x9c5e, 0x0, 0x8ee3,
 0x0, 0x0, 0x0, 0x92a3, 0x0, 0x8bad, 0x9c59, 0x0,
 0x0, 0x0, 0x954a, 0x0, 0x9265, 0x0, 0x0, 0x9c5a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9c5b, 0x0,
 0x8bae, 0x0, 0x9c5c, 0x0, 0x9c5d, 0x0, 0x0, 0x9c5f,
 0x0, 0x9396, 0x0, 0x0, 0x9c60, 0x9c61, 0x0, 0x9c62,
 0x0, 0x0, 0x9c53, 0x9c52, 0x0, 0x0, 0x0, 0x9c63,
 0x8c60, 0x0, 0x0, 0x0, 0x9546, 0x0, 0x0, 0x8dca,
 0x9556, 0x92a4, 0x956a, 0x9c64, 0x0, 0x0, 0x8fb2, 0x8965,
 0x0, 0x9c65, 0x0, 0x0, 0x0, 0x9c66, 0x0, 0x96f0,
 0x0, 0x0, 0x94de, 0x0, 0x0, 0x9c69, 0x899d, 0x90aa,
 0x9c68, 0x9c67, 0x8c61, 0x91d2, 0x0, 0x9c6d, 0x9c6b, 0x0,
 0x9c6a, 0x97a5, 0x8ce3, 0x0, 0x0, 0x0, 0x8f99, 0x9c6c,
 0x936b, 0x8f5d, 0x0, 0x0, 0x0, 0x93be, 0x9c70, 0x9c6f,
 0x0, 0x0, 0x0, 0x0, 0x9c6e, 0x0, 0x9c71, 0x8ce4,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9c72, 0x959c,
 0x8f7a, 0x0, 0x0, 0x9c73, 0x94f7, 0x0, 0x0, 0x0,
 0x0, 0x93bf, 0x92a5, 0x0, 0x0, 0x0, 0x0, 0x934f,
 0x0, 0x0, 0x9c74, 0x8b4a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9053, 0x0, 0x954b, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8af5, 0x9445, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9c75, 0x8e75, 0x9659, 0x965a,
 0x0, 0x0, 0x899e, 0x9c7a, 0x0, 0x0, 0x9289, 0x0,
 0x0, 0x0, 0x9c77, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x89f5, 0x0, 0x0, 0x0, 0x0, 0x9cab, 0x9c79,
 0x0, 0x0, 0x0, 0x944f, 0x0, 0x0, 0x9c78, 0x0,
 0x0, 0x9c76, 0x0, 0x8d9a, 0x0, 0x9c7c, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9c83, 0x9c89, 0x9c81, 0x0,
 0x937b, 0x0, 0x0, 0x9c86, 0x957c, 0x0, 0x0, 0x9c80,
 0x0, 0x9c85, 0x97e5, 0x8e76, 0x0, 0x0, 0x91d3, 0x9c7d,
 0x0, 0x0, 0x0, 0x8b7d, 0x9c88, 0x90ab, 0x8985, 0x9c82,
 0x89f6, 0x9c87, 0x0, 0x0, 0x0, 0x8baf, 0x0, 0x9c84,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9c8a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9c8c,
 0x9c96, 0x9c94, 0x0, 0x0, 0x9c91, 0x0, 0x0, 0x0,
 0x9c90, 0x97f6, 0x0, 0x9c92, 0x0, 0x0, 0x8bb0, 0x0,
 0x8d50, 0x0, 0x0, 0x8f9a, 0x0, 0x0, 0x0, 0x9c99,
 0x9c8b, 0x0, 0x0, 0x0, 0x0, 0x9c8f, 0x9c7e, 0x0,
 0x89f8, 0x9c93, 0x9c95, 0x9270, 0x0, 0x0, 0x8da6, 0x89b6,
 0x9c8d, 0x9c98, 0x9c97, 0x8bb1, 0x0, 0x91a7, 0x8a86, 0x0,
 0x0, 0x0, 0x0, 0x8c62, 0x0, 0x9c8e, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9c9a,
 0x0, 0x9c9d, 0x9c9f, 0x0, 0x0, 0x0, 0x0, 0x8ebb,
 0x0, 0x9ca5, 0x92ee, 0x9c9b, 0x0, 0x0, 0x0, 0x0,
 0x9ca3, 0x0, 0x89f7, 0x0, 0x9ca1, 0x9ca2, 0x0, 0x0,
 0x9c9e, 0x9ca0, 0x0, 0x0, 0x0, 0x8ce5, 0x9749, 0x0,
 0x0, 0x8ab3, 0x0, 0x0, 0x8978, 0x9ca4, 0x0, 0x9459,
 0x88ab, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x94df, 0x9c7b, 0x9caa, 0x9cae, 0x96e3, 0x0, 0x9ca7, 0x0,
 0x0, 0x0, 0x9389, 0x9cac, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8fee, 0x9cad, 0x93d5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9866,
 0x0, 0x9ca9, 0x0, 0x0, 0x0, 0x0, 0x9caf, 0x0,
 0x8d9b, 0x0, 0x90c9, 0x0, 0x0, 0x88d2, 0x9ca8, 0x9ca6,
 0x0, 0x9179, 0x0, 0x0, 0x0, 0x9c9c, 0x8e53, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x91c4, 0x9cbb,
 0x0, 0x917a, 0x9cb6, 0x0, 0x9cb3, 0x9cb4, 0x0, 0x8ee4,
 0x9cb7, 0x9cba, 0x0, 0x0, 0x0, 0x0, 0x9cb5, 0x8f44,
 0x0, 0x9cb8, 0x0, 0x0, 0x9cb2, 0x0, 0x96fa, 0x96f9,
 0x0, 0x0, 0x0, 0x9cbc, 0x9cbd, 0x88d3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9cb1, 0x0, 0x0, 0x0, 0x0,
 0x8bf0, 0x88a4, 0x0, 0x0, 0x0, 0x8ab4, 0x0, 0x9cb9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9cc1, 0x9cc0, 0x0,
 0x0, 0x0, 0x9cc5, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9cc6, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9cc4, 0x9cc7, 0x9cbf, 0x9cc3, 0x0, 0x0,
 0x9cc8, 0x0, 0x9cc9, 0x0, 0x0, 0x9cbe, 0x8e9c, 0x0,
 0x9cc2, 0x91d4, 0x8d51, 0x9cb0, 0x9054, 0x0, 0x0, 0x0,
 0x0, 0x9cd6, 0x0, 0x95e7, 0x0, 0x0, 0x9ccc, 0x9ccd,
 0x9cce, 0x0, 0x0, 0x9cd5, 0x0, 0x9cd4, 0x0, 0x0,
 0x969d, 0x8ab5, 0x0, 0x9cd2, 0x0, 0x8c64, 0x8a53, 0x0,
 0x0, 0x9ccf, 0x0, 0x0, 0x97b6, 0x9cd1, 0x88d4, 0x9cd3,
 0x0, 0x9cca, 0x9cd0, 0x9cd7, 0x8c63, 0x9ccb, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x977c, 0x0, 0x0, 0x0,
 0x974a, 0x0, 0x0, 0x0, 0x0, 0x9cda, 0x0, 0x0,
 0x9cde, 0x0, 0x0, 0x0, 0x919e, 0x0, 0x97f7, 0x9cdf,
 0x0, 0x0, 0x9cdc, 0x0, 0x9cd9, 0x0, 0x0, 0x9cd8,
 0x9cdd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x95ae, 0x0, 0x0, 0x93b2, 0x0, 0x8c65,
 0x0, 0x9ce0, 0x9cdb, 0x0, 0x9ce1, 0x0, 0x0, 0x0,
 0x8c9b, 0x0, 0x0, 0x0, 0x89af, 0x0, 0x0, 0x0,
 0x9ce9, 0x0, 0x0, 0x0, 0x8ab6, 0x0, 0x0, 0x0,
 0x0, 0x9ce7, 0x0, 0x0, 0x9ce8, 0x8da7, 0x9ce6, 0x9ce4,
 0x9ce3, 0x9cea, 0x9ce2, 0x9cec, 0x0, 0x0, 0x89f9, 0x0,
 0x0, 0x9cee, 0x0, 0x0, 0x9ced, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x92a6, 0x0, 0x9cf1, 0x0, 0x9cef, 0x9ce5, 0x8c9c, 0x0,
 0x9cf0, 0x0, 0x9cf4, 0x9cf3, 0x9cf5, 0x9cf2, 0x9cf6, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9cf7, 0x9cf8,
 0x95e8, 0x0, 0x9cfa, 0x9cf9, 0x8f5e, 0x0, 0x90ac, 0x89e4,
 0x89fa, 0x0, 0x9cfb, 0x0, 0x88bd, 0x0, 0x0, 0x0,
 0x90ca, 0x9cfc, 0x0, 0xe6c1, 0x9d40, 0x8c81, 0x0, 0x9d41,
 0x0, 0x0, 0x0, 0x0, 0x90ed, 0x0, 0x0, 0x0,
 0x9d42, 0x0, 0x0, 0x0, 0x9d43, 0x8b59, 0x9d44, 0x0,
 0x9d45, 0x9d46, 0x91d5, 0x0, 0x0, 0x0, 0x8ccb, 0x0,
 0x0, 0x96df, 0x0, 0x0, 0x0, 0x965b, 0x8f8a, 0x9d47,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x90ee, 0xe7bb, 0x94e0,
 0x0, 0x8ee8, 0x0, 0x8dcb, 0x9d48, 0x0, 0x0, 0x0,
 0x0, 0x91c5, 0x0, 0x95a5, 0x0, 0x0, 0x91ef, 0x0,
 0x0, 0x9d4b, 0x0, 0x0, 0x9d49, 0x0, 0x9d4c, 0x0,
 0x0, 0x9d4a, 0x0, 0x0, 0x0, 0x0, 0x9d4d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x95af, 0x0, 0x0, 0x88b5,
 0x0, 0x0, 0x0, 0x0, 0x957d, 0x0, 0x0, 0x94e1,
 0x0, 0x0, 0x9d4e, 0x0, 0x9d51, 0x8fb3, 0x8b5a, 0x0,
 0x9d4f, 0x9d56, 0x8fb4, 0x0, 0x0, 0x0, 0x0, 0x9d50,
 0x9463, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x977d,
 0x9d52, 0x9d53, 0x9d57, 0x938a, 0x9d54, 0x8d52, 0x90dc, 0x0,
 0x0, 0x9d65, 0x94b2, 0x0, 0x91f0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x94e2, 0x9dab, 0x0, 0x0, 0x0, 0x0, 0x95f8,
 0x0, 0x0, 0x0, 0x92ef, 0x0, 0x0, 0x0, 0x9695,
 0x0, 0x9d5a, 0x899f, 0x928a, 0x0, 0x0, 0x0, 0x0,
 0x9d63, 0x0, 0x0, 0x9253, 0x9d5d, 0x9d64, 0x9d5f, 0x9d66,
 0x9d62, 0x0, 0x9d61, 0x948f, 0x0, 0x9d5b, 0x89fb, 0x9d59,
 0x8b91, 0x91f1, 0x9d55, 0x0, 0x0, 0x9d58, 0x8d53, 0x90d9,
 0x0, 0x8fb5, 0x9d60, 0x9471, 0x0, 0x0, 0x8b92, 0x8a67,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8a87, 0x9040, 0x9d68, 0x9d6d, 0x0, 0x9d69,
 0x0, 0x8c9d, 0x0, 0x9d6e, 0x8e41, 0x8d89, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8f45, 0x9d5c, 0x0, 0x8e9d,
 0x9d6b, 0x0, 0x0, 0x0, 0x0, 0x8e77, 0x9d6c, 0x88c2,
 0x0, 0x0, 0x9d67, 0x0, 0x0, 0x0, 0x0, 0x92a7,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b93,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8bb2, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d6a, 0x88a5, 0x0,
 0x0, 0x8dc1, 0x0, 0x0, 0x0, 0x9055, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x92f0, 0x0, 0x0, 0x94d2, 0x9d70, 0x917d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x91a8,
 0x0, 0x0, 0x8e4a, 0x9d71, 0x0, 0x9d73, 0x9d6f, 0x0,
 0x0, 0x0, 0x0, 0x95df, 0x0, 0x92bb, 0x0, 0x0,
 0x0, 0x0, 0x917b, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x95f9, 0x8ecc, 0x9d80,
 0x0, 0x9d7e, 0x0, 0x0, 0x9098, 0x0, 0x0, 0x0,
 0x8c9e, 0x0, 0x0, 0x0, 0x9d78, 0x8fb7, 0x0, 0x0,
 0x93e6, 0x9450, 0x0, 0x0, 0x0, 0x0, 0x9d76, 0x0,
 0x0, 0x917c, 0x0, 0x0, 0x0, 0x0, 0x8ef6, 0x9d7b,
 0x0, 0x0, 0x8fb6, 0x0, 0x9d75, 0x9d7a, 0x0, 0x0,
 0x9472, 0x0, 0x0, 0x0, 0x9d74, 0x0, 0x8c40, 0x0,
 0x0, 0x8a7c, 0x0, 0x0, 0x0, 0x9d7c, 0x97a9, 0x8dcc,
 0x9254, 0x9d79, 0x0, 0x90da, 0x0, 0x8d54, 0x9084, 0x8986,
 0x915b, 0x9d77, 0x8b64, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8c66, 0x0, 0x92cd, 0x9d7d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x917e, 0x0, 0x0, 0x9d81, 0x0, 0x9d83, 0x0,
 0x0, 0x91b5, 0x9d89, 0x0, 0x9d84, 0x0, 0x0, 0x9d86,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9560, 0x92f1, 0x0,
 0x9d87, 0x0, 0x0, 0x0, 0x974b, 0x0, 0x0, 0x0,
 0x9767, 0x8ab7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88ac,
 0x0, 0x9d85, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d82,
 0x0, 0x0, 0x0, 0x0, 0x8af6, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8987, 0x0, 0x9d88, 0x0, 0x0, 0x0,
 0x9768, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d8c, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x91b9, 0x0, 0x9d93, 0x0,
 0x0, 0x0, 0x9d8d, 0x0, 0x0, 0x9d8a, 0x9d91, 0x0,
 0x0, 0x0, 0x0, 0x9d72, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d8e, 0x0, 0x9d92,
 0x0, 0x0, 0x0, 0x94c0, 0x938b, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9d8b, 0x0, 0x9d8f, 0x0, 0x0,
 0x0, 0x8c67, 0x0, 0x0, 0x8def, 0x0, 0x0, 0x0,
 0x90db, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9d97, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9345, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d94, 0x0, 0x9680,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d95, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9d96, 0x0, 0x96cc, 0x0,
 0x90a0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8c82, 0x0, 0x0, 0x0, 0x0, 0x9d9d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8e54, 0x9d9a, 0x0, 0x9d99, 0x0, 0x0, 0x0, 0x0,
 0x9451, 0x0, 0x0, 0x0, 0x93b3, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9350, 0x9d9b, 0x0, 0x0, 0x0, 0x9d9c,
 0x0, 0x958f, 0x0, 0x9464, 0x8e42, 0x0, 0x90ef, 0x0,
 0x966f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8a68,
 0x0, 0x9da3, 0x9d9e, 0x0, 0x0, 0x0, 0x0, 0x9769,
 0x9da5, 0x0, 0x0, 0x9da1, 0x0, 0x9da2, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9180, 0x0, 0x0, 0x0, 0x0,
 0x9da0, 0x0, 0x9d5e, 0x0, 0x0, 0x0, 0x9da4, 0x0,
 0x9d9f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9da9, 0x9daa,
 0x9346, 0x9dac, 0x0, 0x0, 0x8e43, 0x9da7, 0x0, 0x0,
 0x0, 0x0, 0x8b5b, 0x0, 0x0, 0x9dad, 0x0, 0x9da6,
 0x9db1, 0x0, 0x9db0, 0x0, 0x9daf, 0x0, 0x0, 0x0,
 0x9db2, 0x0, 0x0, 0x9db4, 0x8fef, 0x0, 0x9db3, 0x0,
 0x0, 0x0, 0x0, 0x9db7, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9db5, 0x0,
 0x0, 0x0, 0x9db6, 0x9d90, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9db9, 0x9db8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9d98, 0x9dba, 0x9dae, 0x0, 0x0, 0x8e78, 0x0, 0x0,
 0x0, 0x0, 0x9dbb, 0x9dbc, 0x9dbe, 0x9dbd, 0x9dbf, 0x89fc,
 0x0, 0x8d55, 0x0, 0x0, 0x95fa, 0x90ad, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8ccc, 0x0, 0x0, 0x9dc1, 0x0,
 0x0, 0x0, 0x0, 0x9dc4, 0x0, 0x9571, 0x0, 0x8b7e,
 0x0, 0x0, 0x0, 0x9dc3, 0x9dc2, 0x9473, 0x0, 0x9dc5,
 0x8bb3, 0x0, 0x0, 0x0, 0x9dc7, 0x9dc6, 0x0, 0x0,
 0x0, 0x8ab8, 0x8e55, 0x0, 0x0, 0x93d6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8c68, 0x0, 0x0, 0x0, 0x9094,
 0x0, 0x9dc8, 0x0, 0x90ae, 0x9347, 0x0, 0x957e, 0x9dc9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9dca, 0x9dcb, 0x0, 0x0, 0x0, 0x0, 0x95b6, 0x9b7c,
 0x90c4, 0x0, 0x0, 0x956b, 0x0, 0x8dd6, 0x0, 0x94e3,
 0x94c1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x936c, 0x0,
 0x97bf, 0x0, 0x9dcd, 0x8ece, 0x0, 0x0, 0x9dce, 0x0,
 0x88b4, 0x0, 0x0, 0x8bd2, 0x90cb, 0x0, 0x9580, 0x0,
 0x0, 0x0, 0x9dcf, 0x8e61, 0x9266, 0x0, 0x8e7a, 0x9056,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9dd0, 0x0,
 0x95fb, 0x0, 0x0, 0x8997, 0x8e7b, 0x0, 0x0, 0x0,
 0x9dd3, 0x0, 0x9dd1, 0x9dd4, 0x97b7, 0x9dd2, 0x0, 0x0,
 0x0, 0x0, 0x90f9, 0x9dd5, 0x0, 0x0, 0x91b0, 0x0,
 0x0, 0x9dd6, 0x0, 0x0, 0x0, 0x0, 0x8af8, 0x0,
 0x9dd8, 0x0, 0x9dd7, 0x0, 0x0, 0x0, 0x0, 0x9dd9,
 0x9dda, 0x8af9, 0x0, 0x0, 0x93fa, 0x9255, 0x8b8c, 0x8e7c,
 0x9181, 0x0, 0x0, 0x8f7b, 0x88ae, 0x0, 0x0, 0x0,
 0x9ddb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x89a0, 0x9ddf, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8d56, 0x9dde, 0x0, 0x0, 0x8da9, 0x8fb8, 0x0,
 0x0, 0x9ddd, 0x0, 0x8fb9, 0x0, 0x96be, 0x8da8, 0x0,
 0x0, 0x0, 0x88d5, 0x90cc, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9de4, 0x0, 0x0, 0x90af, 0x8966,
 0x0, 0x0, 0x0, 0x0, 0x8f74, 0x0, 0x9686, 0x8df0,
 0x0, 0x0, 0x0, 0x0, 0x8fba, 0x0, 0x90a5, 0x0,
 0x0, 0x0, 0x0, 0x9de3, 0x9de1, 0x9de2, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x928b, 0x0, 0x0, 0x9e45, 0x0,
 0x9de8, 0x8e9e, 0x8d57, 0x9de6, 0x0, 0x0, 0x0, 0x0,
 0x9de7, 0x0, 0x9057, 0x0, 0x0, 0x0, 0x9de5, 0x0,
 0x0, 0x8e4e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9dea, 0x9de9, 0x9dee, 0x0,
 0x0, 0x9def, 0x0, 0x9deb, 0x0, 0x8a41, 0x9dec, 0x9ded,
 0x94d3, 0x0, 0x0, 0x0, 0x0, 0x9581, 0x8c69, 0x9df0,
 0x0, 0x0, 0x0, 0x90b0, 0x0, 0x8fbb, 0x0, 0x0,
 0x0, 0x9271, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8bc5, 0x0, 0x9df1, 0x9df5, 0x0, 0x0, 0x89c9, 0x9df2,
 0x9df4, 0x0, 0x0, 0x0, 0x0, 0x9df3, 0x0, 0x0,
 0x8f8b, 0x0, 0x0, 0x0, 0x0, 0x9267, 0x88c3, 0x9df6,
 0x0, 0x0, 0x0, 0x0, 0x9df7, 0x0, 0x0, 0x0,
 0x0, 0x92a8, 0x0, 0x0, 0x0, 0x97ef, 0x0, 0x0,
 0x0, 0x0, 0x8e62, 0x0, 0x0, 0x95e9, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x965c, 0x0, 0x0, 0x0, 0x9e41,
 0x9df9, 0x0, 0x0, 0x9dfc, 0x0, 0x9dfb, 0x0, 0x0,
 0x9df8, 0x0, 0x0, 0x9e40, 0x0, 0x0, 0x93dc, 0x0,
 0x9dfa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e42, 0x0, 0x0,
 0x8f8c, 0x9e43, 0x0, 0x976a, 0x9498, 0x0, 0x0, 0x9e44,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e46, 0x0, 0x0,
 0x9e47, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e48,
 0x0, 0x8bc8, 0x8967, 0x8d58, 0x9e49, 0x0, 0x9e4a, 0x8f91,
 0x9182, 0x0, 0x0, 0x99d6, 0x915d, 0x915c, 0x91d6, 0x8dc5,
 0x0, 0x0, 0x98f0, 0x0, 0x0, 0x0, 0x0, 0x8c8e,
 0x974c, 0x0, 0x95fc, 0x0, 0x959e, 0x0, 0x9e4b, 0x0,
 0x0, 0x0, 0x0, 0x8df1, 0x92bd, 0x9e4c, 0x984e, 0x0,
 0x0, 0x0, 0x965d, 0x0, 0x92a9, 0x9e4d, 0x8afa, 0x0,
 0x0, 0x0, 0xe452, 0x0, 0x0, 0x0, 0x9e4e, 0x9e4f,
 0x96d8, 0x0, 0x96a2, 0x9696, 0x967b, 0x8e44, 0x9e51, 0x0,
 0x0, 0x8ee9, 0x0, 0x0, 0x9670, 0x0, 0x9e53, 0x9e56,
 0x9e55, 0x0, 0x8af7, 0x0, 0x0, 0x8b80, 0x0, 0x9e52,
 0x0, 0x9e54, 0x0, 0x0, 0x0, 0x0, 0x9e57, 0x0,
 0x0, 0x9099, 0x0, 0x0, 0x0, 0x0, 0x979b, 0x88c7,
 0x8dde, 0x91ba, 0x0, 0x8edb, 0x0, 0x0, 0x8ff1, 0x0,
 0x0, 0x9e5a, 0x0, 0x0, 0x936d, 0x0, 0x9e58, 0x91a9,
 0x9e59, 0x8ff0, 0x96db, 0x9e5b, 0x9e5c, 0x9788, 0x0, 0x0,
 0x0, 0x0, 0x9e61, 0x0, 0x0, 0x8d59, 0x0, 0x9474,
 0x9e5e, 0x938c, 0x9ddc, 0x9de0, 0x0, 0x8b6e, 0x0, 0x9466,
 0x0, 0x0, 0x0, 0x0, 0x9e60, 0x0, 0x8fbc, 0x94c2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e66, 0x0, 0x94f8,
 0x0, 0x9e5d, 0x0, 0x9e63, 0x9e62, 0x0, 0x0, 0x0,
 0x90cd, 0x0, 0x0, 0x0, 0x0, 0x968d, 0x0, 0x97d1,
 0x0, 0x0, 0x9687, 0x0, 0x89ca, 0x8e7d, 0x0, 0x0,
 0x9867, 0x9e65, 0x9095, 0x0, 0x0, 0x0, 0x9e64, 0x0,
 0x0, 0x9e5f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ccd,
 0x0, 0x0, 0x0, 0x9e6b, 0x9e69, 0x0, 0x89cb, 0x9e67,
 0x9e6d, 0x9e73, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x91c6, 0x0, 0x0, 0x95bf, 0x0, 0x9e75, 0x0,
 0x0, 0x0, 0x9541, 0x0, 0x0, 0x0, 0x9e74, 0x9490,
 0x965e, 0x8ab9, 0x0, 0x90f5, 0x8f5f, 0x0, 0x0, 0x0,
 0x92d1, 0x0, 0x974d, 0x0, 0x0, 0x9e70, 0x9e6f, 0x0,
 0x0, 0x0, 0x9e71, 0x0, 0x9e6e, 0x0, 0x0, 0x9e76,
 0x0, 0x9e6c, 0x0, 0x0, 0x9e6a, 0x0, 0x9e72, 0x9e68,
 0x0, 0x928c, 0x0, 0x96f6, 0x8ec4, 0x8df2, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8db8, 0x0, 0x0, 0x968f, 0x8a60,
 0x0, 0x0, 0x92cc, 0x93c8, 0x8968, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x90f0, 0x0, 0x0, 0x90b2, 0x8c49,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e78, 0x0,
 0x0, 0x8d5a, 0x8a9c, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9e7a, 0x8a94, 0x9e81, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9e7d, 0x0, 0x90f1, 0x0, 0x0, 0x0,
 0x8a6a, 0x8daa, 0x0, 0x0, 0x8a69, 0x8dcd, 0x0, 0x0,
 0x9e7b, 0x8c85, 0x8c6a, 0x938d, 0x0, 0x0, 0x9e79, 0x0,
 0x88c4, 0x0, 0x0, 0x0, 0x0, 0x9e7c, 0x9e7e, 0x0,
 0x8bcb, 0x8c4b, 0x0, 0x8aba, 0x8b6a, 0x0, 0x0, 0x0,
 0x0, 0x9e82, 0x0, 0x0, 0x8df7, 0x9691, 0x0, 0x8e56,
 0x0, 0x0, 0x0, 0x9e83, 0x0, 0x0, 0x0, 0x954f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9e8f, 0x0, 0x89b1, 0x9e84,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e95, 0x9e85,
 0x0, 0x97c0, 0x0, 0x9e8c, 0x0, 0x947e, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e94, 0x0, 0x9e87,
 0x0, 0x0, 0x0, 0x88b2, 0x9e89, 0x0, 0x0, 0x8d5b,
 0x0, 0x0, 0x0, 0x9e8b, 0x0, 0x9e8a, 0x0, 0x9e86,
 0x9e91, 0x0, 0x8fbd, 0x0, 0x0, 0x0, 0x9aeb, 0x8ce6,
 0x979c, 0x0, 0x0, 0x0, 0x0, 0x9e88, 0x0, 0x92f2,
 0x8a42, 0x8dab, 0x0, 0x9e80, 0x0, 0x9e90, 0x8a81, 0x0,
 0x0, 0x9e8e, 0x9e92, 0x0, 0x8a91, 0x938e, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8afc, 0x0, 0x9eb0,
 0x0, 0x0, 0x96c7, 0x9e97, 0x8afb, 0x0, 0x9e9e, 0x0,
 0x0, 0x0, 0x0, 0x965f, 0x0, 0x9e9f, 0x9ea1, 0x0,
 0x9ea5, 0x9e99, 0x0, 0x9249, 0x0, 0x0, 0x0, 0x0,
 0x938f, 0x9ea9, 0x9e9c, 0x0, 0x9ea6, 0x0, 0x0, 0x0,
 0x9ea0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9058,
 0x9eaa, 0x0, 0x0, 0x90b1, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9ea8, 0x8abb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x986f, 0x9e96, 0x0, 0x0, 0x9ea4, 0x88d6, 0x0,
 0x0, 0x9e98, 0x0, 0x0, 0x96b8, 0x9e9d, 0x9041, 0x92c5,
 0x9e93, 0x0, 0x0, 0x9ea3, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x909a, 0x9ead, 0x8c9f, 0x0, 0x0, 0x0,
 0x0, 0x9eaf, 0x9e9a, 0x9eae, 0x0, 0x9ea7, 0x9e9b, 0x0,
 0x9eab, 0x0, 0x9eac, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9ebd, 0x0, 0x0, 0x0, 0x93cc, 0x0, 0x9ea2, 0x0,
 0x0, 0x9eb9, 0x0, 0x0, 0x0, 0x9ebb, 0x0, 0x92d6,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x976b, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9596, 0x9eb6, 0x91c8, 0x0, 0x0,
 0x0, 0x9ebc, 0x915e, 0x0, 0x9eb3, 0x9ec0, 0x9ebf, 0x0,
 0x93ed, 0x9ebe, 0x93e8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9ec2, 0x9eb5, 0x0, 0x8bc6, 0x9eb8, 0x8f7c,
 0x0, 0x0, 0x0, 0x9480, 0x9eba, 0x8bc9, 0x0, 0x9eb2,
 0x9eb4, 0x9eb1, 0x0, 0x0, 0x984f, 0x8a79, 0x9eb7, 0x0,
 0x0, 0x9ec1, 0x8a54, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8de5, 0x0, 0x0, 0x0, 0x897c, 0x0,
 0x0, 0x9ed2, 0x0, 0x0, 0x9850, 0x9ed5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9059, 0x9ed4, 0x0, 0x0, 0x0,
 0x9ed3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9ed0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9ec4, 0x0,
 0x0, 0x9ee1, 0x9ec3, 0x0, 0x9ed6, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ece, 0x0, 0x0, 0x9ec9, 0x9ec6,
 0x0, 0x9ec7, 0x0, 0x9ecf, 0x0, 0x0, 0x0, 0xeaa0,
 0x0, 0x0, 0x9ecc, 0x8d5c, 0x92c6, 0x9184, 0x9eca, 0x0,
 0x9ec5, 0x0, 0x0, 0x9ec8, 0x0, 0x0, 0x0, 0x0,
 0x976c, 0x968a, 0x0, 0x0, 0x0, 0x9ecd, 0x9ed7, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9edf,
 0x9ed8, 0x0, 0x0, 0x9ee5, 0x0, 0x9ee3, 0x0, 0x0,
 0x0, 0x0, 0x9ede, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9edd, 0x0, 0x92ce, 0x0, 0x9185, 0x0, 0x9edb,
 0x0, 0x0, 0x9ed9, 0x0, 0x0, 0x9ee0, 0x0, 0x0,
 0x0, 0x0, 0x9ee6, 0x94f3, 0x9eec, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9ee7, 0x9eea, 0x9ee4, 0x0, 0x0, 0x9294,
 0x0, 0x9557, 0x0, 0x9eda, 0x0, 0x0, 0x9ee2, 0x8fbe,
 0x0, 0x96cd, 0x9ef6, 0x9ee9, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8ca0, 0x89a1, 0x8a7e, 0x0, 0x0, 0x9ed1, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8fbf, 0x9eee, 0x0,
 0x9ef5, 0x8ef7, 0x8a92, 0x0, 0x0, 0x924d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9eeb, 0x0, 0x0, 0x9ef0,
 0x9ef4, 0x0, 0x0, 0x8bb4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8b6b, 0x9ef2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b40,
 0x0, 0x93c9, 0x9ef1, 0x0, 0x0, 0x0, 0x9ef3, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9eed, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9eef, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8a80,
 0x9268, 0x0, 0x0, 0x0, 0x9efa, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9ef8, 0x8ce7, 0x0,
 0x9ef7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9f40,
 0x0, 0x0, 0x0, 0x0, 0x9e77, 0x0, 0x0, 0x0,
 0x9ef9, 0x0, 0x9efb, 0x9efc, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9f4b, 0x0, 0x9f47, 0x0, 0x9e8d, 0x0,
 0x0, 0x0, 0x0, 0x9f46, 0x0, 0x0, 0x0, 0x0,
 0x9f45, 0x0, 0x0, 0x9f42, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9ee8, 0x9f44, 0x9f43, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9f49, 0x0, 0x9845, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9f4c, 0x8bf9, 0x0, 0x0, 0x9f48, 0x9f4a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x94a5, 0x0, 0x9f4d, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9f51, 0x9f4e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9793, 0x9f4f, 0x0, 0x0,
 0x0, 0x0, 0x9edc, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9f52, 0x0, 0x0, 0x0, 0x9f53, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8954, 0x0, 0x9f55,
 0x8c87, 0x8e9f, 0x0, 0x8bd3, 0x0, 0x0, 0x0, 0x89a2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x977e, 0x0, 0x0, 0x0, 0x0, 0x9f57,
 0x9f56, 0x9f59, 0x8b5c, 0x0, 0x0, 0x8bd4, 0x8abc, 0x0,
 0x0, 0x0, 0x0, 0x9f5c, 0x0, 0x0, 0x0, 0x9f5b,
 0x0, 0x9f5d, 0x0, 0x0, 0x89cc, 0x0, 0x9256, 0x0,
 0x9f5e, 0x0, 0x0, 0x8abd, 0x9f60, 0x0, 0x0, 0x0,
 0x0, 0x9f5f, 0x0, 0x9f61, 0x0, 0x0, 0x0, 0x9f62,
 0x0, 0x9f63, 0x8e7e, 0x90b3, 0x8d9f, 0x0, 0x9590, 0x0,
 0x0, 0x95e0, 0x9863, 0x0, 0x0, 0x0, 0x0, 0x8e95,
 0x0, 0x0, 0x0, 0x8dce, 0x97f0, 0x0, 0x0, 0x0,
 0x9f64, 0x9f65, 0x0, 0x8e80, 0x0, 0x0, 0x0, 0x9f66,
 0x9f67, 0x0, 0x0, 0x9f69, 0x9f68, 0x0, 0x9677, 0x0,
 0x0, 0x8f7d, 0x8eea, 0x8e63, 0x0, 0x9f6a, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9f6c, 0x9042, 0x0,
 0x9f6b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9f6d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9f6e, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9f6f, 0x9f70, 0x0, 0x0, 0x0, 0x9f71,
 0x0, 0x9f73, 0x9f72, 0x9f74, 0x89a3, 0x9269, 0x0, 0x9f75,
 0x0, 0x0, 0x8e45, 0x8a6b, 0x9f76, 0x0, 0x0, 0x9361,
 0x9aca, 0x0, 0x0, 0x0, 0x0, 0x8b42, 0x9f77, 0x0,
 0x0, 0x0, 0x0, 0x9f78, 0x0, 0x95ea, 0x9688, 0x0,
 0x0, 0x0, 0x93c5, 0x9f79, 0x94e4, 0x0, 0x0, 0x0,
 0x94f9, 0x0, 0x0, 0x96d1, 0x0, 0x0, 0x0, 0x9f7a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9f7c, 0x9f7b, 0x0, 0x0, 0x9f7e,
 0x0, 0x0, 0x0, 0x9f7d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9f81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e81,
 0x0, 0x96af, 0x0, 0x9f82, 0x9f83, 0x0, 0x0, 0x8b43,
 0x0, 0x0, 0x0, 0x9f84, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9f86, 0x9f85, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9085, 0x0, 0x0, 0x9558,
 0x8969, 0x0, 0x0, 0x0, 0x0, 0x0, 0x94c3, 0x0,
 0x92f3, 0x8f60, 0x8b81, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x94c4, 0x0,
 0x8eac, 0x0, 0x0, 0x0, 0x0, 0x9f88, 0x0, 0x8abe,
 0x0, 0x0, 0x8998, 0x0, 0x0, 0x93f0, 0x9f87, 0x8d5d,
 0x9272, 0x0, 0x9f89, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9f91, 0x0, 0x9f8a, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x91bf, 0x0, 0x8b82, 0x9f92, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8c88, 0x0, 0x0, 0x8b44, 0x9f90, 0x0,
 0x0, 0x9f8e, 0x9f8b, 0x9780, 0x0, 0x0, 0x0, 0x0,
 0x92be, 0x0, 0x0, 0x0, 0x93d7, 0x9f8c, 0x0, 0x0,
 0x9f94, 0x0, 0x9f93, 0x8c42, 0x0, 0x0, 0x89ab, 0x0,
 0x0, 0x8db9, 0x9f8d, 0x9f8f, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9676, 0x91f2, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9697, 0x0, 0x0, 0x9f9c, 0x0,
 0x0, 0x9f9d, 0x0, 0x89cd, 0x0, 0x0, 0x0, 0x0,
 0x95a6, 0x96fb, 0x9f9f, 0x8ea1, 0x8fc0, 0x9f98, 0x9f9e, 0x8988,
 0x0, 0x8bb5, 0x0, 0x0, 0x9f95, 0x9f9a, 0x0, 0x0,
 0x0, 0x90f2, 0x9491, 0x0, 0x94e5, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9f97, 0x0, 0x9640, 0x0, 0x9f99,
 0x0, 0x9fa2, 0x0, 0x9fa0, 0x0, 0x9f9b, 0x0, 0x0,
 0x0, 0x9641, 0x9467, 0x8b83, 0x0, 0x9344, 0x0, 0x0,
 0x928d, 0x0, 0x9fa3, 0x0, 0x0, 0x0, 0x0, 0x9fa1,
 0x91d7, 0x9f96, 0x0, 0x896a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x976d, 0x9fae, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9fad, 0x0, 0x0, 0x0, 0x0, 0x90f4, 0x0,
 0x9faa, 0x0, 0x978c, 0x0, 0x0, 0x93b4, 0x9fa4, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x92c3, 0x0, 0x0, 0x0,
 0x896b, 0x8d5e, 0x9fa7, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8f46, 0x9fac, 0x0, 0x9fab, 0x9fa6, 0x0, 0x9fa9,
 0x0, 0x0, 0x8a88, 0x0, 0x9fa8, 0x9468, 0x0, 0x0,
 0x97ac, 0x0, 0x0, 0x8ff2, 0x90f3, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9fb4, 0x9fb2, 0x0, 0x956c, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9faf, 0x9fb1, 0x0, 0x8959, 0x0, 0x0,
 0x8d5f, 0x9851, 0x0, 0x8a5c, 0x0, 0x9582, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9781, 0x0, 0x0, 0x8a43, 0x905a,
 0x9fb3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9fb8, 0x0, 0x0, 0x8fc1,
 0x0, 0x0, 0x0, 0x974f, 0x0, 0x9fb5, 0x0, 0x0,
 0x0, 0x0, 0x9fb0, 0x0, 0x9fb6, 0x0, 0x0, 0x0,
 0x97dc, 0x0, 0x9393, 0x93c0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8a55, 0x0,
 0x0, 0x8974, 0x0, 0x0, 0x9fbc, 0x0, 0x0, 0x9fbf,
 0x0, 0x0, 0x0, 0x97c1, 0x0, 0x0, 0x0, 0x9784,
 0x0, 0x0, 0x0, 0x0, 0x9fc6, 0x9fc0, 0x9fbd, 0x0,
 0x0, 0x0, 0x97d2, 0x9fc3, 0x0, 0x0, 0x0, 0x0,
 0x8f69, 0x9fc5, 0x0, 0x0, 0x9fca, 0x0, 0x0, 0x9391,
 0x9fc8, 0x0, 0x0, 0x0, 0x0, 0x9fc2, 0x0, 0x0,
 0x9257, 0x0, 0x0, 0x9fc9, 0x0, 0x9fbe, 0x0, 0x9fc4,
 0x0, 0x9fcb, 0x88fa, 0x9fc1, 0x0, 0x9fcc, 0x0, 0x0,
 0x905b, 0x0, 0x8f7e, 0x0, 0x95a3, 0x0, 0x8dac, 0x0,
 0x9fb9, 0x9fc7, 0x9359, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x90b4, 0x0, 0x8a89, 0x8dcf,
 0x8fc2, 0x9fbb, 0x8f61, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8c6b, 0x0, 0x9fba, 0x0, 0x0, 0x0,
 0x9fd0, 0x8f8d, 0x8cb8, 0x0, 0x9fdf, 0x0, 0x9fd9, 0x8b94,
 0x936e, 0x0, 0x9fd4, 0x9fdd, 0x88ad, 0x8951, 0x0, 0x0,
 0x89b7, 0x0, 0x9fd6, 0x91aa, 0x9fcd, 0x9fcf, 0x8d60, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9fe0,
 0x0, 0x9fdb, 0x0, 0x0, 0x0, 0x9fd3, 0x0, 0x0,
 0x0, 0x0, 0x9fda, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x96a9, 0x0, 0x0, 0x9fd8, 0x9fdc, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8cce, 0x0, 0x8fc3,
 0x0, 0x0, 0x9258, 0x0, 0x0, 0x0, 0x9fd2, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x974e, 0x0,
 0x0, 0x0, 0x9fd5, 0x0, 0x0, 0x9fce, 0x9392, 0x0,
 0x0, 0x9fd1, 0x0, 0x0, 0x0, 0x9fd7, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9870, 0x8ebc, 0x969e,
 0x0, 0x9fe1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x94ac, 0x0, 0x0, 0x9fed, 0x8cb9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f80, 0x0, 0x9fe3,
 0x0, 0x0, 0x0, 0x97ad, 0x8d61, 0x0, 0x9ff0, 0x0,
 0x0, 0x88ec, 0x0, 0x0, 0x9fee, 0x0, 0x0, 0x0,
 0x0, 0x9fe2, 0x0, 0x0, 0x0, 0x0, 0x9fe8, 0x0,
 0x0, 0x9fea, 0x0, 0x0, 0x0, 0x976e, 0x9fe5, 0x0,
 0x0, 0x934d, 0x0, 0x0, 0x9fe7, 0x0, 0x0, 0x0,
 0x0, 0x9fef, 0x0, 0x9fe9, 0x96c5, 0x0, 0x0, 0x0,
 0x9fe4, 0x0, 0x8ea0, 0x9ffc, 0x0, 0x0, 0x0, 0x0,
 0x8a8a, 0x0, 0x9fe6, 0x9feb, 0x9fec, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x91ea, 0x91d8, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ff4, 0x0, 0x0, 0x9ffa, 0x0,
 0x0, 0x9ff8, 0x0, 0x9348, 0x0, 0x0, 0xe042, 0x9ff5,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9ff6, 0x9fde, 0x0,
 0x8b99, 0x9559, 0x0, 0x0, 0x0, 0x8ebd, 0x0, 0x0,
 0x8d97, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9852, 0x0,
 0x9ff2, 0x0, 0xe041, 0x8989, 0x9186, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9499,
 0x0, 0x8abf, 0x97f8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x969f, 0x92d0, 0x0, 0x0, 0x0, 0x0,
 0x9ff9, 0x9ffb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9151,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe040, 0x9ff7, 0x0,
 0x9ff1, 0x0, 0x0, 0x0, 0x8ac1, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8c89, 0x0, 0x0, 0x0, 0xe04e,
 0x0, 0x0, 0xe049, 0x90f6, 0x0, 0x0, 0x8a83, 0x0,
 0x0, 0x0, 0x0, 0x8f81, 0x0, 0xe052, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe04b, 0x92aa, 0xe048, 0x92d7,
 0x0, 0x0, 0x0, 0xe06b, 0x0, 0x0, 0x0, 0xe045,
 0x0, 0xe044, 0x0, 0xe04d, 0x0, 0x0, 0x0, 0xe047,
 0xe046, 0xe04c, 0x0, 0x909f, 0x0, 0xe043, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe04f, 0x0, 0x0,
 0xe050, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ac0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe055, 0x0, 0xe054, 0xe056, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe059, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9362, 0x0, 0xe053, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe057, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c83,
 0x91f7, 0xe051, 0x945a, 0x0, 0x0, 0xe058, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe05d, 0xe05b, 0x0, 0x0, 0xe05e,
 0x0, 0x0, 0xe061, 0x0, 0x0, 0x0, 0xe05a, 0x8d8a,
 0x9447, 0x0, 0x0, 0x9fb7, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9794, 0xe05c, 0x0, 0xe060, 0x91f3, 0x0,
 0xe05f, 0x0, 0xe04a, 0x0, 0x0, 0xe889, 0x0, 0x0,
 0x0, 0xe064, 0x0, 0x0, 0x0, 0xe068, 0x0, 0x0,
 0xe066, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe062, 0x0, 0xe063, 0x0, 0x0, 0x0, 0xe067, 0x0,
 0xe065, 0x0, 0x0, 0x0, 0x956d, 0x0, 0x0, 0xe06d,
 0x0, 0xe06a, 0xe069, 0x0, 0xe06c, 0x93d2, 0xe06e, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9295, 0x91eb, 0x0,
 0x0, 0x0, 0x0, 0x90a3, 0x0, 0x0, 0x0, 0xe06f,
 0x0, 0xe071, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe070, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ff3, 0x0, 0x0, 0x0, 0x0,
 0xe072, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x93e5,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe073, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x89ce, 0x0, 0x0, 0x0, 0x9394, 0x8a44,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b84,
 0x0, 0x0, 0x0, 0x8edc, 0x8dd0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9846, 0x9086, 0x0, 0x0, 0x0, 0x898a, 0x0, 0x0,
 0x0, 0xe075, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe074, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe078, 0x9259, 0xe07b, 0xe076, 0x0,
 0x0, 0x0, 0xe07a, 0x0, 0x0, 0x0, 0x0, 0xe079,
 0x935f, 0x88d7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x97f3,
 0x0, 0x0, 0xe07d, 0x0, 0x0, 0x0, 0x8947, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe080, 0x0, 0x0, 0x0, 0xe07e, 0x0, 0xe07c, 0x0,
 0xe077, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9642, 0x0, 0x0, 0x0, 0xe082, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe081, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x898b, 0x0, 0x0, 0x0, 0x0,
 0xe084, 0x95b0, 0x0, 0xe083, 0x0, 0x0, 0x0, 0x0,
 0x96b3, 0x0, 0x0, 0x0, 0x0, 0x8fc5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9152, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8fc4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x97f9, 0x0, 0x0, 0xe08a, 0x0, 0x90f7, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe086, 0xe08b, 0x0, 0x0,
 0x898c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe089, 0x0, 0x9481, 0xe085, 0xe088, 0x8fc6, 0x0,
 0x94cf, 0x0, 0x0, 0xe08c, 0x0, 0x8ecf, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x90f8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe08f, 0x0, 0x0, 0x0, 0xe087,
 0x0, 0x8c46, 0x0, 0x0, 0x0, 0x0, 0xe08d, 0x0,
 0x0, 0x0, 0x0, 0x976f, 0xe090, 0x0, 0x0, 0x0,
 0xeaa4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f6e, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe091,
 0x0, 0x0, 0x0, 0xe092, 0x0, 0x0, 0x0, 0x0,
 0x944d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe094, 0x0, 0x0, 0x0, 0x0, 0xe095, 0x0, 0x0,
 0x0, 0x0, 0x9452, 0x0, 0x0, 0x0, 0x0, 0x9395,
 0xe097, 0x0, 0x0, 0x0, 0x0, 0xe099, 0x0, 0x97d3,
 0x0, 0xe096, 0x0, 0xe098, 0x898d, 0x0, 0xe093, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a7a, 0xe09a,
 0x0, 0x0, 0x0, 0x0, 0x9187, 0x8e57, 0xe09c, 0x0,
 0x0, 0x0, 0x0, 0xe09b, 0x9043, 0x99d7, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe09d, 0x0, 0x0, 0x0,
 0xe09f, 0x0, 0xe08e, 0xe09e, 0x0, 0x0, 0xe0a0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x949a, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe0a1, 0x0, 0x0, 0xe0a2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe0a3, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0a4,
 0x0, 0x92dc, 0x0, 0xe0a6, 0xe0a5, 0x0, 0x0, 0xe0a7,
 0x0, 0xe0a8, 0x0, 0x0, 0x0, 0x8edd, 0x9583, 0x0,
 0x0, 0x0, 0x96ea, 0xe0a9, 0xe0aa, 0x9175, 0x8ea2, 0xe0ab,
 0xe0ac, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0ad, 0x95d0,
 0x94c5, 0x0, 0x0, 0xe0ae, 0x9476, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x92ab, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe0af, 0x89e5, 0x0, 0x8b8d, 0x0, 0x96c4, 0x0, 0x96b4,
 0x0, 0x89b2, 0x9853, 0x0, 0x0, 0x0, 0x0, 0x9671,
 0x0, 0x95a8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x90b5, 0x0, 0xe0b0, 0x0, 0x0, 0x0,
 0x0, 0x93c1, 0x0, 0x0, 0x0, 0x8ca1, 0xe0b1, 0x0,
 0x8dd2, 0xe0b3, 0xe0b2, 0x0, 0x0, 0x0, 0x0, 0xe0b4,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe0b5, 0x0, 0x0, 0x0, 0xe0b6, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8b5d, 0x0, 0xe0b7, 0x0, 0x0, 0x0, 0x0, 0xe0b8,
 0x0, 0x0, 0x0, 0x0, 0x8ca2, 0x0, 0x0, 0x94c6,
 0x0, 0x0, 0xe0ba, 0x0, 0x0, 0x0, 0x8ff3, 0x0,
 0x0, 0xe0b9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8bb6, 0xe0bb, 0xe0bd, 0x0, 0xe0bc, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0be, 0x0,
 0x8ccf, 0x0, 0xe0bf, 0x0, 0x0, 0x0, 0x0, 0x8be7,
 0x0, 0x915f, 0x0, 0x8d9d, 0x0, 0x0, 0x0, 0x0,
 0xe0c1, 0xe0c2, 0xe0c0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8eeb, 0x0, 0x0, 0x93c6, 0x8bb7, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0c4,
 0x924b, 0xe0c3, 0x0, 0x0, 0x9854, 0x9482, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe0c7, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0c9, 0xe0c6,
 0x0, 0x0, 0x0, 0x96d2, 0xe0c8, 0xe0ca, 0x0, 0x97c2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0ce, 0x0, 0x0,
 0x0, 0xe0cd, 0x9296, 0x944c, 0x0, 0x0, 0x8ca3, 0xe0cc,
 0x0, 0x0, 0x0, 0x0, 0xe0cb, 0x0, 0x9750, 0x9751,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0cf, 0x898e,
 0x0, 0x0, 0x0, 0x0, 0x8d96, 0x8e82, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0d0, 0xe0d1,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0d3,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8f62, 0x0, 0x0, 0x0, 0x0,
 0xe0d5, 0x0, 0xe0d4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe0d6, 0x0, 0x8a6c, 0x0, 0x0, 0xe0d8, 0x0, 0x0,
 0xe0d7, 0x0, 0xe0da, 0xe0d9, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8cba, 0x0, 0x0, 0x97a6,
 0x0, 0x8bca, 0x0, 0x89a4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8be8, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8adf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x97e6, 0xe0dc, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe0de, 0x0, 0x0, 0x0, 0x0,
 0xe0df, 0x0, 0x89cf, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe0db, 0x0, 0x8e58, 0x0, 0x0, 0x92bf, 0xe0dd, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0e2, 0x0,
 0x8eec, 0x0, 0x0, 0x0, 0x0, 0xe0e0, 0x0, 0x0,
 0x0, 0x0, 0x8c5d, 0x0, 0x0, 0x94c7, 0xe0e1, 0x0,
 0x0, 0xe0fc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe0e7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8cbb, 0x0,
 0x0, 0x0, 0x0, 0x8b85, 0x0, 0xe0e4, 0x979d, 0x0,
 0x0, 0x97ae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x91f4, 0x0, 0x0, 0xe0e6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe0e8, 0x97d4, 0x8bd5, 0x94fa, 0x9469, 0x0,
 0x0, 0x0, 0xe0e9, 0x0, 0x0, 0x0, 0x0, 0xe0eb,
 0x0, 0xe0ee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0ea, 0x0, 0x0,
 0x0, 0xe0ed, 0x8ce8, 0x896c, 0xe0ef, 0x0, 0x9090, 0xe0ec,
 0x97da, 0x0, 0x0, 0xe0f2, 0xeaa2, 0x0, 0x0, 0x0,
 0x0, 0xe0f0, 0xe0f3, 0x0, 0x0, 0x0, 0x0, 0xe0e5,
 0xe0f1, 0x0, 0x0, 0x8dba, 0x0, 0x0, 0xe0f4, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0f5, 0x0,
 0x0, 0x0, 0x0, 0x979e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe0f6, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0f7, 0x0,
 0x0, 0x0, 0xe0e3, 0x0, 0x0, 0x0, 0x0, 0xe0f8,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8ac2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ea3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe0f9, 0x0, 0x0, 0x0, 0x0, 0xe0fa,
 0x0, 0x0, 0x0, 0x0, 0xe0fb, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x895a, 0x0, 0x0, 0x0,
 0xe140, 0x0, 0x955a, 0xe141, 0x0, 0x0, 0x8aa2, 0xe142,
 0x0, 0xe143, 0x0, 0x0, 0x0, 0x0, 0xe144, 0x0,
 0xe146, 0xe147, 0xe145, 0x0, 0x0, 0x0, 0x9572, 0xe149,
 0xe148, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe14b, 0xe14a, 0xe14c, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe14d, 0xe14f, 0xe14e, 0x0,
 0x0, 0x8d99, 0x0, 0xe151, 0x0, 0xe150, 0x0, 0x0,
 0x8ac3, 0x0, 0x9072, 0x0, 0x935b, 0x0, 0xe152, 0x90b6,
 0x0, 0x0, 0x0, 0x8e59, 0x0, 0x8999, 0xe153, 0x0,
 0x9770, 0x0, 0x0, 0x95e1, 0xe154, 0x0, 0x0, 0x0,
 0x9363, 0x9752, 0x8d62, 0x905c, 0x0, 0x0, 0x0, 0x926a,
 0x99b2, 0x0, 0x92ac, 0x89e6, 0xe155, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe156, 0x0, 0xe15b, 0x0,
 0x0, 0xe159, 0xe158, 0x9dc0, 0x8a45, 0xe157, 0x0, 0x88d8,
 0x0, 0x94a8, 0x0, 0x0, 0x94c8, 0x0, 0x0, 0x0,
 0x0, 0x97af, 0xe15c, 0xe15a, 0x927b, 0x90a4, 0x0, 0x0,
 0x0, 0x954c, 0x0, 0xe15e, 0x97aa, 0x8c6c, 0xe15f, 0xe15d,
 0x94d4, 0xe160, 0x0, 0xe161, 0x0, 0x0, 0x88d9, 0x0,
 0x0, 0x8ff4, 0xe166, 0x0, 0xe163, 0x93eb, 0xe162, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b45, 0x0, 0x0,
 0xe169, 0x0, 0x0, 0x0, 0xe164, 0xe165, 0x0, 0xe168,
 0xe167, 0x9544, 0x0, 0x0, 0x9161, 0x9160, 0x0, 0x8b5e,
 0x0, 0x0, 0xe16a, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe16b, 0x0, 0x0, 0xe16c, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe16e, 0x0, 0xe16d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8975, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe176,
 0x94e6, 0xe170, 0x0, 0xe172, 0x0, 0x0, 0xe174, 0x905d,
 0x0, 0x0, 0xe175, 0xe173, 0x8ebe, 0x0, 0x0, 0x0,
 0xe16f, 0xe171, 0x0, 0x9561, 0x0, 0x8fc7, 0x0, 0x0,
 0xe178, 0x0, 0x0, 0xe177, 0x0, 0x0, 0x0, 0x0,
 0xe179, 0x0, 0x8ea4, 0x8dad, 0x0, 0x0, 0x9397, 0xe17a,
 0x0, 0x92c9, 0x0, 0x0, 0xe17c, 0x0, 0x0, 0x0,
 0x979f, 0xe17b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9189,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe182, 0x0,
 0xe184, 0xe185, 0x9273, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe183, 0x0, 0xe180, 0x0, 0xe17d, 0xe17e, 0x0, 0xe181,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe188,
 0x0, 0xe186, 0x0, 0xe187, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe189, 0xe18b,
 0xe18c, 0xe18d, 0x0, 0xe18e, 0x0, 0x0, 0xe18a, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe190, 0x0,
 0x0, 0x0, 0xe18f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe191, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x97c3, 0x0, 0x0, 0x0, 0xe194, 0xe192, 0xe193, 0x0,
 0x0, 0x0, 0x8ae0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x96fc, 0x0, 0x0, 0x0, 0x95c8, 0x0, 0xe196, 0x0,
 0x0, 0x0, 0xe195, 0x0, 0x0, 0x0, 0x0, 0xe197,
 0xe198, 0x0, 0x0, 0x0, 0x0, 0xe19c, 0xe199, 0xe19a,
 0xe19b, 0x0, 0xe19d, 0x0, 0x0, 0x0, 0xe19e, 0x0,
 0xe19f, 0x0, 0x0, 0x0, 0xe1a0, 0x0, 0xe1a1, 0x0,
 0x94ad, 0x936f, 0xe1a2, 0x9492, 0x9553, 0x0, 0xe1a3, 0x0,
 0x0, 0xe1a4, 0x9349, 0x0, 0x8a46, 0x8d63, 0xe1a5, 0x0,
 0x0, 0xe1a6, 0x0, 0x0, 0x94a9, 0xe1a7, 0x0, 0x8e48,
 0x0, 0x0, 0xe1a9, 0x0, 0x0, 0xe1a8, 0x0, 0x0,
 0xe1aa, 0xe1ab, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x94e7, 0x0, 0xe1ac,
 0x0, 0x0, 0x0, 0xe1ad, 0x0, 0x0, 0xea89, 0xe1ae,
 0xe1af, 0xe1b0, 0x0, 0x0, 0x0, 0x0, 0x8e4d, 0x0,
 0x0, 0xe1b1, 0x9475, 0x0, 0x0, 0x967e, 0x0, 0x896d,
 0x0, 0x8976, 0x0, 0x0, 0xe1b2, 0x0, 0x0, 0x0,
 0x0, 0xe1b4, 0x0, 0x0, 0x0, 0xe1b3, 0x9390, 0x0,
 0x0, 0x0, 0x90b7, 0x9f58, 0x0, 0xe1b5, 0x96bf, 0x0,
 0xe1b6, 0x0, 0x8ac4, 0x94d5, 0xe1b7, 0x0, 0xe1b8, 0x0,
 0x0, 0xe1b9, 0x0, 0x0, 0x0, 0x96da, 0x0, 0x0,
 0x0, 0x96d3, 0x0, 0x92bc, 0x0, 0x0, 0x0, 0x918a,
 0x0, 0x0, 0xe1bb, 0x0, 0x0, 0x8f82, 0x0, 0x0,
 0x8fc8, 0x0, 0x0, 0xe1be, 0x0, 0x0, 0xe1bd, 0xe1bc,
 0x94fb, 0x0, 0x8ac5, 0x8ca7, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe1c4, 0x0, 0x0, 0xe1c1, 0x905e, 0x96b0,
 0x0, 0x0, 0x0, 0xe1c0, 0xe1c2, 0xe1c3, 0x0, 0x0,
 0xe1bf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1c5, 0xe1c6,
 0x0, 0x92ad, 0x0, 0x8ae1, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1c7, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe1c8, 0xe1cb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9087,
 0x0, 0x93c2, 0x0, 0xe1cc, 0x9672, 0x0, 0xe1c9, 0x0,
 0x0, 0xe1ca, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe1cf, 0x0, 0x0, 0x0, 0x0, 0xe1ce, 0xe1cd, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe1d1, 0x0, 0x0, 0xe1d0, 0x0, 0x0, 0xe1d2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe1d4, 0x0, 0xe1d3, 0x0,
 0x0, 0x0, 0x0, 0x95cb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8f75, 0x97c4, 0x0, 0x0, 0xe1d5, 0x0,
 0x0, 0x93b5, 0x0, 0x0, 0xe1d6, 0x0, 0x0, 0xe1d7,
 0x0, 0xe1db, 0xe1d9, 0xe1da, 0x0, 0xe1d8, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1dc, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe1dd, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1de, 0x0, 0x0,
 0xe1df, 0x96b5, 0xe1e0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x96ee, 0xe1e1, 0x0, 0x926d, 0x0, 0x948a, 0x0, 0x8be9,
 0x0, 0x0, 0x0, 0x925a, 0xe1e2, 0x8bb8, 0x0, 0x0,
 0x0, 0x90ce, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe1e3, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8dbb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe1e4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe1e5, 0x0, 0x0, 0x8ca4, 0x8dd3, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1e7,
 0x0, 0x0, 0x0, 0x0, 0x9375, 0x8dd4, 0x8b6d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9643, 0x0, 0x946a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9376, 0x0, 0x0, 0x0, 0x0, 0x8d7b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe1e9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8fc9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x97b0, 0x8d64, 0x0, 0x0, 0x8ca5, 0x0,
 0x0, 0x94a1, 0x0, 0xe1eb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe1ed, 0x0, 0x0, 0x0, 0x0,
 0x8ce9, 0x0, 0x0, 0x0, 0x0, 0xe1ec, 0x92f4, 0x0,
 0x0, 0x0, 0x0, 0xe1ef, 0x8a56, 0xe1ea, 0x0, 0x0,
 0x94e8, 0x0, 0x894f, 0x0, 0x8dea, 0x0, 0x9871, 0x0,
 0x0, 0xe1ee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe1f0, 0x0, 0x0, 0x0, 0x95c9,
 0x0, 0x90d7, 0xe1f2, 0x0, 0x0, 0x0, 0x0, 0xe1f3,
 0x0, 0x0, 0x0, 0x0, 0xe1f1, 0x0, 0x0, 0x0,
 0x0, 0x8a6d, 0x0, 0xe1f9, 0x0, 0xe1f8, 0x0, 0x0,
 0x8ea5, 0x0, 0x0, 0x0, 0xe1fa, 0xe1f5, 0x0, 0x0,
 0x0, 0xe1fb, 0xe1f6, 0x0, 0x0, 0x0, 0x0, 0x94d6,
 0xe1f4, 0x0, 0x0, 0xe1f7, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe241, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe240, 0x9681,
 0x0, 0x0, 0x0, 0xe1fc, 0x0, 0x0, 0x88e9, 0x0,
 0x0, 0x0, 0x0, 0xe243, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe242, 0x0, 0x0, 0x0,
 0x8fca, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe244, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9162, 0x0, 0x0,
 0xe246, 0xe245, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe247, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1e6, 0x0, 0x0,
 0x0, 0xe1e8, 0xe249, 0xe248, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8ea6, 0x0, 0x97e7, 0x0, 0x8ed0, 0x0, 0xe24a,
 0x8c56, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b5f, 0x8b46,
 0x8e83, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9753, 0x0, 0x0, 0xe250, 0x0, 0xe24f, 0x9163, 0xe24c,
 0x0, 0x0, 0xe24e, 0x0, 0x0, 0x8f6a, 0x905f, 0xe24d,
 0xe24b, 0x0, 0x9449, 0x0, 0x0, 0x8fcb, 0x0, 0x0,
 0x955b, 0x0, 0x0, 0x0, 0x0, 0x8dd5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9398,
 0x0, 0x0, 0xe251, 0x0, 0x0, 0x0, 0x0, 0xe252,
 0xe268, 0x8bd6, 0x0, 0x0, 0x985c, 0x9154, 0x0, 0x0,
 0x0, 0x0, 0xe253, 0x0, 0x0, 0x89d0, 0x92f5, 0x959f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe254, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b9a, 0xe255,
 0x0, 0x0, 0xe257, 0x0, 0x0, 0x0, 0xe258, 0x0,
 0x9448, 0x0, 0x0, 0xe259, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe25a, 0xe25b, 0x0, 0x0, 0x8bd7, 0x89d1, 0x93c3,
 0x8f47, 0x8e84, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe25c, 0x0, 0x8f48, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x89c8, 0x9562, 0x0, 0x0, 0xe25d, 0x0, 0x0,
 0x94e9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9164,
 0x0, 0xe260, 0x0, 0xe261, 0x9489, 0x0, 0x9060, 0xe25e,
 0x0, 0x9281, 0x0, 0x0, 0xe25f, 0x0, 0x0, 0x0,
 0x8fcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x88da, 0x0, 0x0, 0x0, 0x0,
 0x8b48, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe262, 0x0, 0x0, 0x92f6, 0x0, 0xe263, 0x90c5, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x96ab, 0x0, 0x0, 0x9542,
 0xe264, 0xe265, 0x9274, 0x0, 0x97c5, 0x0, 0x0, 0xe267,
 0xe266, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8eed, 0x0,
 0x0, 0xe269, 0x88ee, 0x0, 0x0, 0x0, 0x0, 0xe26c,
 0x0, 0x0, 0x0, 0xe26a, 0x89d2, 0x8c6d, 0xe26b, 0x8d65,
 0x8d92, 0x0, 0x95e4, 0xe26d, 0x0, 0x0, 0x9673, 0x0,
 0x0, 0xe26f, 0x0, 0x0, 0x0, 0x90cf, 0x896e, 0x89b8,
 0x88aa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe26e,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe270, 0xe271, 0x8ff5, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe272, 0x0, 0x8a6e, 0x0, 0x0, 0x0, 0x0,
 0xe274, 0x0, 0x0, 0x0, 0x8c8a, 0x0, 0x8b86, 0x0,
 0x0, 0xe275, 0x8bf3, 0x0, 0x0, 0xe276, 0x0, 0x90fa,
 0x0, 0x93cb, 0x0, 0x90de, 0x8df3, 0x0, 0x0, 0x0,
 0xe277, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9282, 0x918b, 0x0, 0xe279, 0xe27b, 0xe278,
 0xe27a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c41,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe27c, 0x8c45, 0x0, 0x0, 0x0, 0x8b87, 0x9771,
 0xe27e, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe280, 0x0,
 0x0, 0x0, 0x894d, 0x0, 0x0, 0x0, 0x0, 0xe283,
 0x0, 0x0, 0x0, 0x8a96, 0xe282, 0xe281, 0x0, 0xe285,
 0xe27d, 0x0, 0xe286, 0x97a7, 0x0, 0xe287, 0x0, 0xe288,
 0x0, 0x0, 0x9af2, 0xe28a, 0x0, 0xe289, 0x0, 0x0,
 0x0, 0xe28b, 0xe28c, 0x0, 0x97b3, 0xe28d, 0x0, 0xe8ed,
 0x8fcd, 0xe28e, 0xe28f, 0x8f76, 0x0, 0x93b6, 0xe290, 0x0,
 0x0, 0x0, 0x9247, 0x0, 0x0, 0xe291, 0x0, 0x925b,
 0xe292, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ba3, 0x0,
 0x995e, 0x927c, 0x8eb1, 0x0, 0x0, 0x0, 0x0, 0x8ac6,
 0x0, 0x0, 0xe293, 0x0, 0xe2a0, 0x0, 0xe296, 0x0,
 0x8b88, 0x0, 0xe295, 0xe2a2, 0x0, 0x0, 0x0, 0xe294,
 0x0, 0x8fce, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe298, 0xe299, 0x0, 0x934a, 0x0, 0x0, 0xe29a, 0x0,
 0x8a7d, 0x0, 0x0, 0x0, 0x0, 0x9079, 0x9584, 0x0,
 0xe29c, 0x0, 0x0, 0x0, 0x91e6, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe297, 0x0, 0xe29b, 0xe29d, 0x0,
 0x0, 0x8df9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2a4, 0x954d, 0x0,
 0x94a4, 0x9399, 0x0, 0x8bd8, 0xe2a3, 0xe2a1, 0x0, 0x94b3,
 0xe29e, 0x927d, 0x939b, 0x0, 0x939a, 0x0, 0x8df4, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2b6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2a6, 0x0, 0xe2a8,
 0x0, 0x0, 0x0, 0x0, 0xe2ab, 0x0, 0xe2ac, 0x0,
 0xe2a9, 0xe2aa, 0x0, 0x0, 0xe2a7, 0xe2a5, 0x0, 0x0,
 0x0, 0x0, 0xe29f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x95cd, 0x89d3,
 0x0, 0x0, 0x0, 0xe2b3, 0x0, 0xe2b0, 0x0, 0xe2b5,
 0x0, 0x0, 0xe2b4, 0x0, 0x9493, 0x96a5, 0x0, 0x8e5a,
 0xe2ae, 0xe2b7, 0xe2b2, 0x0, 0xe2b1, 0xe2ad, 0x0, 0xe2af,
 0x0, 0x8ac7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x925c, 0x0, 0x0, 0x90fb, 0x0, 0x0,
 0x0, 0x94a0, 0x0, 0x0, 0xe2bc, 0x0, 0x0, 0x0,
 0x94a2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x90df, 0xe2b9, 0x0, 0x0, 0x94cd, 0x0, 0xe2bd, 0x95d1,
 0x0, 0x927a, 0x0, 0xe2b8, 0xe2ba, 0x0, 0x0, 0xe2bb,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2be, 0x0, 0x0,
 0x8ec2, 0x0, 0x0, 0x0, 0x93c4, 0xe2c3, 0xe2c2, 0x0,
 0x0, 0xe2bf, 0x0, 0x0, 0x0, 0x9855, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe2c8, 0x0, 0x0, 0xe2cc, 0xe2c9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe2c5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2c6,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2cb, 0x0, 0x0,
 0x0, 0xe2c0, 0x99d3, 0xe2c7, 0xe2c1, 0x0, 0x0, 0xe2ca,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2d0,
 0x0, 0x8ac8, 0x0, 0xe2cd, 0x0, 0x0, 0x0, 0xe2ce,
 0x0, 0x0, 0xe2cf, 0xe2d2, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2d1,
 0x94f4, 0x0, 0x0, 0x0, 0x0, 0xe2d3, 0x97fa, 0x95eb,
 0xe2d8, 0x0, 0x0, 0xe2d5, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe2d4, 0x90d0, 0x0, 0xe2d7,
 0xe2d9, 0x0, 0x0, 0x0, 0xe2d6, 0x0, 0xe2dd, 0x0,
 0xe2da, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2db,
 0xe2c4, 0x0, 0x0, 0x0, 0xe2dc, 0xe2de, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe2df, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x95c4, 0x0, 0xe2e0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x96e0,
 0x0, 0x0, 0x8bcc, 0x8c48, 0xe2e1, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x95b2, 0x0, 0x9088, 0x0, 0x96ae, 0x0,
 0x0, 0xe2e2, 0x0, 0x97b1, 0x0, 0x0, 0x9494, 0x0,
 0x9165, 0x9453, 0x0, 0x0, 0x8f6c, 0x0, 0x0, 0x0,
 0x0, 0x88be, 0x0, 0xe2e7, 0xe2e5, 0x0, 0xe2e3, 0x8a9f,
 0x0, 0x8fcf, 0xe2e8, 0x0, 0x0, 0xe2e6, 0x0, 0xe2e4,
 0xe2ec, 0x0, 0x0, 0xe2eb, 0xe2ea, 0xe2e9, 0x0, 0xe2ef,
 0x0, 0x0, 0x0, 0x0, 0xe2ed, 0x0, 0x0, 0x0,
 0xe2ee, 0x90b8, 0x0, 0x0, 0xe2f1, 0x0, 0x0, 0xe2f0,
 0x0, 0x0, 0x0, 0x0, 0x8cd0, 0x0, 0x0, 0x0,
 0x9157, 0x0, 0x0, 0x0, 0xe2f3, 0x0, 0x0, 0x0,
 0x939c, 0x0, 0xe2f2, 0x0, 0x0, 0x0, 0xe2f4, 0x0,
 0x95b3, 0x918c, 0x8d66, 0x0, 0xe2f5, 0x0, 0x0, 0x0,
 0x0, 0x97c6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe2f7, 0x0, 0x0, 0xe2f8, 0x0, 0xe2f9, 0x0,
 0xe2fa, 0x0, 0x8e85, 0x0, 0xe2fb, 0x8c6e, 0x0, 0x0,
 0x8b8a, 0x0, 0x8b49, 0x0, 0xe340, 0x0, 0x96f1, 0x8d67,
 0xe2fc, 0x0, 0x0, 0x0, 0xe343, 0x96e4, 0x0, 0x945b,
 0x0, 0x0, 0x9552, 0x0, 0x0, 0x0, 0x8f83, 0xe342,
 0x0, 0x8ed1, 0x8d68, 0x8e86, 0x8b89, 0x95b4, 0xe341, 0x0,
 0x0, 0x0, 0x9166, 0x9661, 0x8df5, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e87, 0x92db, 0x0,
 0xe346, 0x97dd, 0x8dd7, 0x0, 0xe347, 0x9061, 0x0, 0xe349,
 0x0, 0x0, 0x0, 0x8fd0, 0x8dae, 0x0, 0x0, 0x0,
 0x0, 0xe348, 0x0, 0x0, 0x8f49, 0x8cbc, 0x9167, 0xe344,
 0xe34a, 0x0, 0x0, 0x0, 0x0, 0xe345, 0x8c6f, 0x0,
 0xe34d, 0xe351, 0x8c8b, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe34c, 0x0, 0x0, 0x0, 0x0, 0xe355, 0x0, 0x0,
 0x8d69, 0x0, 0x0, 0x978d, 0x88ba, 0xe352, 0x0, 0x0,
 0x8b8b, 0x0, 0xe34f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe350, 0x0, 0x0, 0x939d, 0xe34e, 0xe34b, 0x0, 0x8a47,
 0x90e2, 0x0, 0x0, 0x8ca6, 0x0, 0x0, 0x0, 0xe357,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe354, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe356, 0x0, 0x0, 0x0, 0xe353, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8c70, 0x91b1, 0xe358, 0x918e, 0x0,
 0x0, 0xe365, 0x0, 0x0, 0xe361, 0xe35b, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe35f, 0x8ef8, 0x88db,
 0xe35a, 0xe362, 0xe366, 0x8d6a, 0x96d4, 0x0, 0x92d4, 0xe35c,
 0x0, 0x0, 0xe364, 0x0, 0xe359, 0x925d, 0x0, 0xe35e,
 0x88bb, 0x96c8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe35d, 0x0, 0x0, 0x8bd9, 0x94ea, 0x0, 0x0,
 0x0, 0x918d, 0x0, 0x97ce, 0x8f8f, 0x0, 0x0, 0xe38e,
 0x0, 0x0, 0xe367, 0x0, 0x90fc, 0x0, 0xe363, 0xe368,
 0xe36a, 0x0, 0x92f7, 0xe36d, 0x0, 0x0, 0xe369, 0x0,
 0x0, 0x0, 0x95d2, 0x8ac9, 0x0, 0x0, 0x96c9, 0x0,
 0x0, 0x88dc, 0x0, 0x0, 0xe36c, 0x0, 0x97fb, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe36b, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x898f, 0x0, 0x0, 0x93ea, 0xe36e,
 0x0, 0x0, 0x0, 0xe375, 0xe36f, 0xe376, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe372, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x949b, 0x0, 0x0,
 0x8ec8, 0xe374, 0x0, 0xe371, 0xe377, 0xe370, 0x0, 0x0,
 0x8f63, 0x0, 0x0, 0x0, 0x0, 0x9644, 0x0, 0x0,
 0x8f6b, 0x0, 0x0, 0xe373, 0xe380, 0x0, 0x0, 0xe37b,
 0x0, 0xe37e, 0x0, 0xe37c, 0xe381, 0xe37a, 0x0, 0xe360,
 0x90d1, 0x0, 0x0, 0x94c9, 0x0, 0xe37d, 0x0, 0x0,
 0xe378, 0x0, 0x0, 0x0, 0x9140, 0x8c71, 0x0, 0x8f4a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9044, 0x9155,
 0xe384, 0x0, 0x0, 0xe386, 0xe387, 0x0, 0x0, 0xe383,
 0xe385, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe379, 0xe382, 0x0, 0xe38a, 0xe389, 0x0, 0x0, 0x969a,
 0x0, 0x0, 0x8c4a, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe388, 0x0, 0xe38c, 0xe38b, 0xe38f,
 0x0, 0xe391, 0x0, 0x0, 0x8e5b, 0xe38d, 0x0, 0x0,
 0x0, 0x0, 0xe392, 0xe393, 0x0, 0x0, 0xe394, 0x0,
 0xe39a, 0x935a, 0xe396, 0x0, 0xe395, 0xe397, 0xe398, 0x0,
 0xe399, 0x0, 0x0, 0x0, 0x0, 0xe39b, 0xe39c, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8aca, 0x0, 0xe39d, 0x0, 0xe39e, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe39f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe3a0, 0xe3a1,
 0xe3a2, 0x0, 0xe3a3, 0xe3a4, 0x0, 0x0, 0xe3a6, 0xe3a5,
 0x0, 0x0, 0xe3a7, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe3a8, 0xe3a9, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe3ac, 0xe3aa, 0xe3ab, 0x8ddf, 0x8c72, 0x0, 0x0,
 0x9275, 0x0, 0x94b1, 0x0, 0x8f90, 0x0, 0x0, 0x946c,
 0x0, 0x94eb, 0xe3ad, 0x9ceb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe3ae, 0xe3b0, 0x0, 0x9785,
 0xe3af, 0xe3b2, 0xe3b1, 0x0, 0x9772, 0x0, 0xe3b3, 0x0,
 0x94fc, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe3b4, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe3b7, 0x0, 0x0, 0xe3b6,
 0xe3b5, 0x9285, 0x0, 0x0, 0x0, 0x0, 0xe3b8, 0x8c51,
 0x0, 0x0, 0x0, 0x9141, 0x8b60, 0x0, 0x0, 0x0,
 0x0, 0xe3bc, 0xe3b9, 0x0, 0x0, 0xe3ba, 0x0, 0x0,
 0x0, 0xe3bd, 0x0, 0xe3be, 0xe3bb, 0x0, 0x0, 0x0,
 0x8948, 0x0, 0x0, 0x0, 0x89a5, 0x0, 0x0, 0x0,
 0xe3c0, 0xe3c1, 0x0, 0x0, 0x0, 0xe3c2, 0x0, 0x9782,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f4b, 0x0, 0xe3c4,
 0xe3c3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9089, 0xe3c5, 0x0, 0x0, 0x0,
 0x0, 0xe3c6, 0x0, 0x0, 0xe3c7, 0x0, 0x8ae3, 0x0,
 0x0, 0x0, 0x0, 0x8acb, 0x0, 0x0, 0xe3c8, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe3c9, 0x0, 0x967c, 0x9783,
 0x0, 0x0, 0x0, 0x9773, 0x9856, 0x0, 0x8d6c, 0xe3cc,
 0x8ed2, 0xe3cb, 0x0, 0x0, 0x0, 0x0, 0xe3cd, 0x8ea7,
 0x0, 0x0, 0x0, 0x91cf, 0x0, 0xe3ce, 0x0, 0x0,
 0x8d6b, 0x0, 0x96d5, 0xe3cf, 0xe3d0, 0x0, 0x0, 0xe3d1,
 0x0, 0x0, 0x0, 0x0, 0xe3d2, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe3d3, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ea8, 0x0,
 0x0, 0x96eb, 0x0, 0x0, 0x0, 0x0, 0xe3d5, 0x0,
 0x925e, 0x0, 0xe3d4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe3d7, 0x0, 0x0, 0x0, 0xe3d6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe3d8, 0x0, 0x0,
 0x0, 0x90b9, 0x0, 0xe3d9, 0x0, 0xe3da, 0x0, 0x0,
 0x0, 0x95b7, 0xe3db, 0x0, 0x918f, 0xe3dc, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe3dd, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x97fc, 0xe3e0, 0x0, 0xe3df, 0xe3de, 0x92ae,
 0x0, 0xe3e1, 0x9045, 0x0, 0xe3e2, 0x0, 0x0, 0x0,
 0xe3e3, 0x9857, 0xe3e4, 0x0, 0x0, 0x0, 0x0, 0xe3e5,
 0xe3e7, 0xe3e6, 0x94a3, 0x0, 0x93f7, 0x0, 0x985d, 0x94a7,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe3e9, 0x0,
 0x0, 0x8fd1, 0x0, 0x9549, 0x0, 0xe3ea, 0xe3e8, 0x0,
 0x8acc, 0x0, 0x0, 0x0, 0x8cd2, 0x8e88, 0x0, 0x0,
 0x94ec, 0x0, 0x0, 0x0, 0x8ca8, 0x9662, 0x0, 0xe3ed,
 0xe3eb, 0x0, 0x8d6d, 0x0, 0x8d6e, 0x88e7, 0x0, 0x8de6,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9478, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88dd, 0xe3f2,
 0x0, 0x925f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9477,
 0x0, 0x91d9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe3f4, 0x0, 0x0, 0xe3f0, 0xe3f3, 0xe3ee, 0x0,
 0xe3f1, 0x9645, 0x0, 0x0, 0x8cd3, 0x0, 0x0, 0x88fb,
 0xe3ef, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe3f6, 0x0, 0xe3f7, 0x0, 0x0, 0x93b7,
 0x0, 0x0, 0x0, 0x8bb9, 0x0, 0x0, 0x0, 0xe445,
 0x945c, 0x0, 0x0, 0x0, 0x0, 0x8e89, 0x0, 0x0,
 0x8bba, 0x90c6, 0x9865, 0x96ac, 0xe3f5, 0x90d2, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b72, 0xe3f8, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe3fa, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe3f9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe3fb, 0x0, 0x9245, 0x0, 0x945d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x92af, 0x0, 0x0, 0x0,
 0x0, 0xe442, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe441, 0x0, 0x0, 0x0, 0x0, 0xe3fc, 0x0,
 0x0, 0x9074, 0x0, 0x9585, 0xe444, 0x0, 0xe443, 0x8d6f,
 0x9872, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe454, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe448, 0xe449, 0x0, 0x0, 0x0, 0x0, 0x8eee, 0x0,
 0x0, 0xe447, 0x0, 0x8d98, 0xe446, 0x0, 0x0, 0xe44a,
 0x0, 0x0, 0x0, 0x92b0, 0x95a0, 0x0, 0x9142, 0x0,
 0x0, 0x0, 0x0, 0x91da, 0xe44e, 0x0, 0xe44f, 0xe44b,
 0x0, 0x0, 0x0, 0x0, 0xe44c, 0x0, 0xe44d, 0x0,
 0x0, 0x0, 0x0, 0x8d70, 0x0, 0x0, 0x0, 0xe455,
 0x0, 0xe451, 0x0, 0x0, 0x0, 0x0, 0x9586, 0x0,
 0x968c, 0x9547, 0x0, 0x0, 0xe450, 0x0, 0x0, 0xe453,
 0xe458, 0x0, 0x0, 0x0, 0x9663, 0xe456, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe457, 0x0, 0x0, 0x9156,
 0x0, 0x0, 0x0, 0xe45a, 0x0, 0xe45e, 0x0, 0x0,
 0xe45b, 0xe459, 0x945e, 0xe45c, 0x0, 0xe45d, 0x0, 0x0,
 0x0, 0x89b0, 0x0, 0xe464, 0xe45f, 0x0, 0x0, 0x0,
 0xe460, 0x0, 0x0, 0x0, 0xe461, 0x0, 0x919f, 0x0,
 0x0, 0x0, 0x0, 0xe463, 0xe462, 0xe465, 0x0, 0x0,
 0x0, 0x0, 0xe466, 0xe467, 0x0, 0x0, 0x9062, 0x0,
 0x89e7, 0x0, 0xe468, 0x97d5, 0x0, 0x8ea9, 0x0, 0x0,
 0x8f4c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e8a, 0x9276,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe469, 0xe46a, 0x8950,
 0x0, 0xe46b, 0x0, 0x0, 0xe46c, 0xe46d, 0x0, 0x0,
 0xe46e, 0x0, 0xe46f, 0x8bbb, 0x9da8, 0xe470, 0x0, 0x90e3,
 0xe471, 0x8ec9, 0x0, 0xe472, 0x0, 0x98ae, 0x0, 0x0,
 0x0, 0xe473, 0x95dc, 0x8ada, 0x0, 0x0, 0x9143, 0x8f77,
 0x0, 0x9591, 0x8f4d, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe474, 0x8d71, 0xe475, 0x94ca,
 0x0, 0xe484, 0x0, 0x0, 0x0, 0x0, 0xe477, 0x0,
 0x91c7, 0x9495, 0x8cbd, 0xe476, 0x9144, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe478, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x92f8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe47a, 0xe479, 0xe47c, 0x0, 0x0,
 0xe47b, 0x0, 0xe47d, 0x0, 0x0, 0xe480, 0x0, 0xe47e,
 0x0, 0x8acd, 0x0, 0xe481, 0x0, 0xe482, 0xe483, 0x0,
 0x0, 0x8daf, 0x97c7, 0x0, 0xe485, 0x9046, 0x0, 0x0,
 0x0, 0x8990, 0xe486, 0xe487, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe488, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88f0, 0x0,
 0xe489, 0x0, 0x0, 0x0, 0x0, 0xe48a, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9587, 0x0, 0x0, 0x0,
 0x8ec5, 0x0, 0xe48c, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8a48, 0x88b0, 0x0, 0x0, 0x0, 0x0, 0xe48b, 0xe48e,
 0x946d, 0x0, 0x9063, 0x0, 0x89d4, 0x0, 0x9646, 0x0,
 0x0, 0x0, 0x0, 0x8c7c, 0x8bda, 0x0, 0xe48d, 0x0,
 0x89e8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8aa1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8991, 0xe492, 0x97e8, 0x91db,
 0x0, 0x0, 0x9563, 0x0, 0xe49e, 0x0, 0x89d5, 0xe49c,
 0x0, 0xe49a, 0xe491, 0x0, 0xe48f, 0x0, 0xe490, 0x0,
 0x8ee1, 0x8bea, 0x9297, 0x0, 0x0, 0x0, 0x93cf, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8970, 0x0, 0xe494, 0xe493,
 0x0, 0x0, 0x0, 0x0, 0xe499, 0xe495, 0xe498, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x96ce, 0xe497, 0x89d6,
 0x8a9d, 0xe49b, 0x0, 0x0, 0xe49d, 0x0, 0x0, 0x0,
 0x0, 0x8c73, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe4a1, 0xe4aa, 0xe4ab, 0x0, 0x0, 0x0, 0x88a9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4b2, 0x0,
 0x0, 0x0, 0x0, 0x88ef, 0x0, 0x0, 0xe4a9, 0x0,
 0x0, 0x0, 0xe4a8, 0x0, 0xe4a3, 0xe4a2, 0x0, 0xe4a0,
 0xe49f, 0x9283, 0x0, 0x91f9, 0xe4a5, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe4a4, 0x0, 0x0, 0x0, 0x0,
 0xe4a7, 0x0, 0x0, 0x0, 0x9190, 0x8c74, 0x0, 0x0,
 0x0, 0x0, 0x8960, 0xe4a6, 0x0, 0x8d72, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9191, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4b8, 0x0,
 0xe4b9, 0x0, 0x89d7, 0x0, 0x0, 0x0, 0x89ac, 0xe4b6,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe4ac, 0x0, 0xe4b4, 0x0, 0xe4bb, 0xe4b5, 0x0, 0x0,
 0x0, 0xe4b3, 0x0, 0x0, 0x0, 0x0, 0xe496, 0x0,
 0x0, 0xe4b1, 0x0, 0x0, 0x0, 0xe4ad, 0x0, 0x0,
 0x0, 0x8ace, 0xe4af, 0xe4ba, 0x0, 0xe4b0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe4bc, 0x0, 0xe4ae, 0x949c, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9789, 0x0, 0x0, 0x0,
 0xe4b7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe4cd, 0x0, 0x0, 0x0, 0xe4c5, 0x0, 0x0, 0x0,
 0x909b, 0x0, 0x0, 0x0, 0x0, 0x8b65, 0x0, 0x8bdb,
 0x0, 0xe4c0, 0x0, 0x0, 0x0, 0x0, 0x89d9, 0x0,
 0x0, 0x8fd2, 0x0, 0xe4c3, 0x0, 0x0, 0x0, 0x8dd8,
 0x0, 0x0, 0x9370, 0xe4c8, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x95ec, 0x0, 0xe4bf, 0x0,
 0x0, 0x0, 0x89d8, 0x8cd4, 0x9548, 0xe4c9, 0x0, 0xe4bd,
 0x0, 0x0, 0xe4c6, 0x0, 0x0, 0x0, 0xe4d0, 0x0,
 0xe4c1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4c2, 0x93b8,
 0x0, 0x0, 0xe4c7, 0x0, 0x0, 0x0, 0xe4c4, 0x9647,
 0xe4ca, 0x88de, 0x0, 0x0, 0x0, 0x0, 0xe4be, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe4cc, 0x0, 0xe4cb, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x948b, 0xe4d2, 0x0, 0xe4dd,
 0x0, 0x0, 0x0, 0x0, 0x8a9e, 0x0, 0x0, 0x0,
 0xe4e0, 0x0, 0x0, 0xe4ce, 0x0, 0x0, 0x0, 0xe4d3,
 0x978e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe4dc, 0x0, 0x0, 0x9774, 0x0, 0x0, 0x0,
 0x0, 0x97a8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9298, 0x0, 0x0, 0x0, 0x8a8b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9592, 0xe4e2, 0x939f, 0x0,
 0x0, 0x88af, 0x0, 0x0, 0xe4db, 0x0, 0xe4d7, 0x9192,
 0xe4d1, 0xe4d9, 0xe4de, 0x0, 0x944b, 0x0, 0x0, 0x0,
 0x88a8, 0x0, 0xe4d6, 0x0, 0xe4df, 0x9598, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4da, 0x0, 0xe4d5,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8fd3, 0x0,
 0x0, 0x0, 0x0, 0x8f4e, 0x0, 0x0, 0x0, 0x8eaa,
 0x0, 0x0, 0x0, 0x0, 0x96d6, 0x0, 0x0, 0x9566,
 0x0, 0x0, 0xe4e5, 0x0, 0xe4ee, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe4d8, 0x0, 0x0, 0x0, 0x0, 0x8a97, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8ff6, 0xe4e3, 0x0, 0xe4e8, 0x9193,
 0x0, 0x0, 0xe4e4, 0x0, 0xe4eb, 0x0, 0x0, 0x927e,
 0x0, 0xe4ec, 0x0, 0x0, 0x9775, 0xe4e1, 0x8a57, 0x0,
 0xe4e7, 0x0, 0x0, 0xe4ea, 0x96aa, 0x0, 0x0, 0x0,
 0x0, 0xe4ed, 0x0, 0x0, 0xe4e6, 0xe4e9, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9648,
 0x0, 0x9840, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4f1,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4f8,
 0x0, 0x0, 0xe4f0, 0x8ec1, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe4cf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x95cc, 0x0, 0x96a0, 0xe4f7,
 0xe4f6, 0x0, 0xe4f2, 0xe4f3, 0x0, 0x8955, 0x0, 0x0,
 0x0, 0x0, 0xe4f5, 0x0, 0xe4ef, 0x0, 0x0, 0x0,
 0x0, 0x92d3, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4f4,
 0x88fc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x91a0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x95c1, 0x0, 0x0, 0xe4f9, 0xe540, 0x0, 0x94d7, 0x0,
 0x0, 0x0, 0x0, 0xe4fc, 0x8fd4, 0x8ec7, 0xe542, 0x0,
 0x0, 0x8bbc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe543, 0x0, 0x9599, 0xe4fb, 0x0, 0xe4d4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4fa, 0x0,
 0x0, 0x0, 0x0, 0x986e, 0x93a0, 0x9593, 0x0, 0x0,
 0xe54a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe550, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe551, 0x0, 0xe544, 0x0, 0x0, 0x0, 0x9496,
 0x0, 0x0, 0xe54e, 0xe546, 0x0, 0xe548, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe552, 0xe547, 0x0, 0x0, 0xe54b,
 0x0, 0x0, 0x8992, 0x0, 0x93e3, 0x0, 0xe54c, 0xe54f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe545,
 0x0, 0x9145, 0x0, 0xe549, 0x8e46, 0x9064, 0x8c4f, 0x96f2,
 0x0, 0x96f7, 0x8f92, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe556, 0xe554, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x986d, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe553, 0x0, 0x0, 0x0,
 0x9795, 0x0, 0xe555, 0xe557, 0x0, 0x0, 0x0, 0x0,
 0xe558, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe55b,
 0xe559, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x93a1,
 0xe55a, 0x0, 0x0, 0x0, 0x94cb, 0xe54d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8f93, 0x0, 0xe55c, 0xe561, 0x9194, 0x0,
 0x0, 0xe560, 0x0, 0x0, 0x0, 0xe541, 0x0, 0x0,
 0x0, 0xe562, 0x9168, 0x0, 0x0, 0xe55d, 0xe55f, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe55e, 0x0,
 0x0, 0x9f50, 0x9f41, 0x0, 0x0, 0xe564, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe563, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9796, 0x0, 0xe1ba, 0xe565, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe566, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe567, 0x8cd5, 0x0, 0x8b73, 0x0, 0x0, 0x0, 0xe569,
 0x997c, 0x0, 0x0, 0x0, 0x0, 0x8b95, 0x0, 0x97b8,
 0x0, 0x8bf1, 0xe56a, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe56b, 0x0, 0x0, 0x0, 0x928e, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe56c, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x93f8, 0x0, 0x88b8, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x89e1, 0xe571, 0xe572,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe56d, 0x0,
 0x8e5c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe56e, 0x9461,
 0x0, 0x0, 0x0, 0x0, 0xe56f, 0xe570, 0xe57a, 0x0,
 0x0, 0x0, 0xe574, 0xe577, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe573, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe575,
 0x0, 0xe576, 0x8ed6, 0x0, 0xe578, 0x0, 0x9260, 0x0,
 0x8c75, 0x8a61, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe57b,
 0x0, 0x0, 0x0, 0x0, 0x8a5e, 0x0, 0xe581, 0x0,
 0x0, 0xe57c, 0xe580, 0x0, 0x0, 0x0, 0x0, 0x94b8,
 0x0, 0x0, 0x0, 0x0, 0xe57d, 0x0, 0x0, 0xe57e,
 0x9567, 0x94d8, 0xe582, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x91fb, 0xe58c, 0x0, 0xe588, 0x0,
 0x0, 0x89e9, 0x0, 0xe586, 0x0, 0x9649, 0xe587, 0x0,
 0x0, 0xe584, 0x0, 0xe585, 0xe58a, 0xe58d, 0x0, 0x0,
 0xe58b, 0x0, 0x0, 0x0, 0xe589, 0xe583, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9277, 0x0, 0xe594, 0x0, 0x96a8,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe592, 0x0, 0x0, 0x0, 0xe593, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe58e,
 0x0, 0x0, 0xe590, 0x0, 0x0, 0x0, 0xe591, 0x0,
 0x0, 0x0, 0xe58f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x90e4, 0x0, 0x9858, 0xe598,
 0x0, 0xe599, 0x0, 0x0, 0x0, 0x0, 0xe59f, 0x0,
 0x9049, 0x0, 0xe59b, 0x0, 0xe59e, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe596, 0xe595, 0x0, 0x0, 0xe5a0, 0x0,
 0x0, 0x89da, 0x0, 0xe59c, 0x0, 0xe5a1, 0x0, 0x0,
 0x0, 0xe59d, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe59a,
 0x0, 0x92b1, 0x0, 0xe597, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9488, 0x0, 0x0, 0xe5a5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x975a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe5a4, 0x0, 0x0, 0xe5a3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe5ac, 0x0,
 0x0, 0x0, 0xe5a6, 0x0, 0x0, 0x0, 0xe5ae, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9786, 0xe5b1, 0x0,
 0xe5a8, 0x0, 0x0, 0xe5a9, 0x0, 0x0, 0x0, 0xe5ad,
 0x0, 0xe5b0, 0xe5af, 0x0, 0x0, 0x0, 0xe5a7, 0x0,
 0x0, 0x0, 0x0, 0xe5aa, 0x0, 0xe5bb, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe5b4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe5b2, 0x0, 0x0, 0xe5b3, 0x0, 0x0,
 0x0, 0xe5b8, 0xe5b9, 0x0, 0x8a49, 0x0, 0x8b61, 0x0,
 0x0, 0xe5b7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe5a2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe5b6, 0xe5ba, 0xe5b5, 0x0, 0xe5bc, 0x0, 0x0, 0x0,
 0xe5be, 0xe5bd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe5c0, 0xe5bf, 0xe579, 0x0,
 0x0, 0x0, 0xe5c4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe5c1, 0x0, 0x0, 0x0,
 0x0, 0xe5c2, 0x0, 0x0, 0xe5c3, 0x0, 0xe5c5, 0x0,
 0x0, 0x0, 0x0, 0x8c8c, 0x0, 0xe5c7, 0x0, 0xe5c6,
 0x0, 0x8f4f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8d73,
 0x9fa5, 0x0, 0x0, 0x0, 0x0, 0xe5c8, 0x8f70, 0x0,
 0x0, 0x0, 0x8a58, 0x0, 0xe5c9, 0x0, 0x8971, 0x0,
 0x8fd5, 0xe5ca, 0x0, 0x0, 0x8d74, 0xe5cb, 0x88df, 0x0,
 0x0, 0x0, 0x0, 0x955c, 0x0, 0x0, 0xe5cc, 0x0,
 0x0, 0x0, 0x0, 0x908a, 0x0, 0xe5d3, 0x0, 0x0,
 0xe5d0, 0x0, 0x928f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe5d1, 0xe5ce, 0x8bdc, 0x0, 0xe5cd, 0xe5d4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8c55, 0x0, 0x0, 0x91dc, 0x0,
 0xe5da, 0x0, 0x0, 0x0, 0x0, 0xe5d6, 0x0, 0x0,
 0x0, 0x91b3, 0xe5d5, 0x0, 0xe5d8, 0x0, 0x0, 0x0,
 0x0, 0xe5cf, 0x0, 0x0, 0x0, 0xe5d9, 0x0, 0xe5db,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x94ed, 0x0,
 0x0, 0xe5d7, 0x0, 0xe5dc, 0xe5de, 0x0, 0x0, 0x8cd1,
 0xe5d2, 0x0, 0x88bf, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe5dd, 0x0, 0x8dd9, 0x97f4, 0xe5df, 0xe5e0,
 0x9195, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x97a0, 0x0, 0x0, 0x0, 0x0, 0xe5e1,
 0x9754, 0x0, 0x0, 0xe5e2, 0xe5e3, 0x0, 0x0, 0x95e2,
 0xe5e4, 0x0, 0x8dbe, 0x0, 0x97a1, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe5e9, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe5ea, 0x8fd6, 0xe5e8,
 0x0, 0x0, 0x0, 0x9787, 0xe5e5, 0x0, 0x0, 0xe5e7,
 0x90bb, 0x909e, 0x0, 0x0, 0x0, 0xe5e6, 0x0, 0xe5eb,
 0x0, 0x0, 0x95a1, 0x0, 0x0, 0xe5ed, 0x0, 0xe5ec,
 0x0, 0x0, 0x0, 0x8a8c, 0x0, 0x964a, 0xe5ee, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe5fa, 0xe5f0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe5f1, 0x0, 0x0, 0x0, 0x0, 0xe5f2, 0xe5f3, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe5f7, 0x0, 0xe5f8, 0x0, 0x0, 0xe5f6, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe5f4, 0x0, 0xe5ef, 0xe5f5,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe5f9,
 0xe8b5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x89a6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe5fc, 0x8bdd, 0xe5fb, 0x0, 0x0, 0x0, 0xe641,
 0x0, 0xe640, 0x0, 0x0, 0x0, 0xe643, 0x0, 0x0,
 0xe642, 0x0, 0xe644, 0x0, 0x0, 0x8f50, 0x0, 0xe645,
 0x0, 0x0, 0xe646, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe647, 0x90bc, 0x0, 0x9776, 0x0, 0xe648, 0x0,
 0x0, 0x95a2, 0x9465, 0xe649, 0x0, 0xe64a, 0x8ca9, 0x0,
 0x0, 0x0, 0x8b4b, 0x0, 0x0, 0x0, 0xe64b, 0x0,
 0x0, 0x8e8b, 0x9460, 0xe64c, 0x0, 0x8a6f, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe64d, 0x0, 0x0, 0x0,
 0x0, 0xe64f, 0x9797, 0x0, 0xe64e, 0x9065, 0x0, 0xe650,
 0x0, 0x0, 0xe651, 0x0, 0x0, 0xe652, 0x8acf, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe653, 0x0, 0x0,
 0xe654, 0x0, 0xe655, 0xe656, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8a70, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe657, 0x0, 0xe658, 0xe659,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x89f0, 0x0, 0x0,
 0x9047, 0xe65a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe65b, 0xea42,
 0x0, 0x0, 0x0, 0xe65c, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8cbe, 0x0, 0x92f9, 0xe65d, 0x0,
 0x0, 0x0, 0x0, 0x8c76, 0x0, 0x9075, 0x0, 0xe660,
 0x0, 0x93a2, 0x0, 0xe65f, 0x0, 0x0, 0x8c50, 0x0,
 0x0, 0xe65e, 0x91f5, 0x8b4c, 0x0, 0x0, 0xe661, 0x0,
 0xe662, 0x0, 0x8fd7, 0x0, 0x0, 0x0, 0x8c8d, 0x0,
 0xe663, 0x0, 0x0, 0x0, 0x0, 0x964b, 0x0, 0x0,
 0x90dd, 0x0, 0x0, 0x0, 0x8b96, 0x0, 0x96f3, 0x9169,
 0x0, 0xe664, 0x0, 0x0, 0x0, 0x9066, 0x9290, 0x8fd8,
 0x0, 0x0, 0x0, 0x0, 0xe665, 0x0, 0x0, 0x0,
 0x0, 0xe668, 0x0, 0xe669, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8dbc, 0x91c0, 0xe667, 0x0, 0x8fd9,
 0x955d, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe666, 0x0,
 0x0, 0x8e8c, 0x0, 0x8972, 0x0, 0xe66d, 0x8c77, 0x0,
 0x0, 0x8e8e, 0x0, 0x0, 0x8e8d, 0x0, 0x986c, 0xe66c,
 0xe66b, 0x9146, 0x0, 0x8b6c, 0x9862, 0x8a59, 0x8fda, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe66a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe66f, 0x0, 0xe670,
 0xe66e, 0x0, 0x8cd6, 0x0, 0x975f, 0x0, 0x0, 0x8e8f,
 0x9446, 0x0, 0x0, 0x0, 0xe673, 0x0, 0x90be, 0x0,
 0x9261, 0x0, 0x0, 0x9755, 0x0, 0xe676, 0x0, 0x0,
 0x0, 0x8cea, 0x0, 0x90bd, 0xe672, 0x0, 0xe677, 0x8ceb,
 0xe674, 0xe675, 0x0, 0xe671, 0x0, 0x0, 0x0, 0x90e0,
 0x93c7, 0x0, 0x0, 0x924e, 0x0, 0x89db, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x94ee, 0x0, 0x0, 0x8b62,
 0x0, 0x0, 0x92b2, 0x0, 0x0, 0xe67a, 0x0, 0xe678,
 0x0, 0x0, 0x926b, 0x0, 0x0, 0x0, 0x90bf, 0x8ad0,
 0xe679, 0x0, 0x907a, 0x0, 0x0, 0x97c8, 0x0, 0x0,
 0x0, 0x985f, 0x0, 0x0, 0x0, 0xe67b, 0xe687, 0x92b3,
 0x0, 0xe686, 0x0, 0xe683, 0xe68b, 0xe684, 0x0, 0xe680,
 0x0, 0x92fa, 0xe67e, 0x0, 0x0, 0x0, 0xe67c, 0x0,
 0x9740, 0x8e90, 0x0, 0x0, 0xe681, 0x0, 0xe67d, 0x0,
 0x0, 0x0, 0xe685, 0x8f94, 0x0, 0x8cbf, 0x0, 0x0,
 0x0, 0x91f8, 0x0, 0x9664, 0x8979, 0x88e0, 0x0, 0x93a3,
 0x0, 0x0, 0xe689, 0x0, 0x0, 0x0, 0x0, 0xe688,
 0x0, 0x93e4, 0x0, 0xe68d, 0x0, 0x0, 0x0, 0xe682,
 0x0, 0xe68c, 0xe68e, 0x0, 0x8caa, 0xe68a, 0x8d75, 0x0,
 0x8ed3, 0x0, 0x0, 0xe68f, 0x9777, 0x0, 0x0, 0x0,
 0x0, 0xe692, 0x0, 0xe695, 0x0, 0x0, 0xe693, 0x9554,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe690, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8bde, 0x0, 0x0, 0x0,
 0x0, 0xe694, 0x0, 0x0, 0xe696, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe69a, 0x0, 0x0, 0xe697,
 0x0, 0xe699, 0xe698, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe69b, 0x0, 0x8eaf, 0x0, 0xe69d, 0xe69c, 0x9588,
 0x0, 0x0, 0xe69f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8c78, 0x0, 0x0, 0x0, 0x0, 0xe69e, 0xe6a0,
 0x0, 0x0, 0xe6a1, 0x8b63, 0xe3bf, 0x8ff7, 0x0, 0xe6a2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6a3,
 0x0, 0x0, 0xe6a4, 0x0, 0x0, 0x8e5d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9dcc, 0x0, 0xe6a5, 0x0,
 0xe6a6, 0x0, 0x8f51, 0x0, 0xe6a7, 0xe6a8, 0x0, 0x0,
 0xe6a9, 0x0, 0x0, 0xe6aa, 0xe6ab, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x924a, 0x0, 0x0, 0xe6ac, 0x0, 0x0, 0x0,
 0x0, 0xe6ae, 0x0, 0xe6ad, 0x0, 0x0, 0x0, 0x0,
 0x93a4, 0x0, 0xe6af, 0x0, 0x964c, 0x0, 0xe6b0, 0x0,
 0xe6b1, 0x0, 0xe6b2, 0x0, 0x0, 0x0, 0x0, 0xe6b3,
 0x0, 0x0, 0x0, 0x0, 0x93d8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8fdb, 0xe6b4, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8d8b, 0x98ac, 0xe6b5, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe6b6, 0x955e, 0xe6b7, 0x0, 0xe6bf, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe6b8, 0x0, 0x0, 0xe6ba,
 0x0, 0x0, 0x0, 0xe6b9, 0xe6bb, 0x0, 0x9665, 0xe6bc,
 0xe6bd, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6be, 0x0,
 0x0, 0x0, 0xe6c0, 0x0, 0x0, 0x0, 0x0, 0x8a4c,
 0x92e5, 0x0, 0x9589, 0x8de0, 0x8d76, 0x0, 0x0, 0x0,
 0x0, 0x956e, 0x89dd, 0x94cc, 0xe6c3, 0x8ad1, 0x90d3, 0xe6c2,
 0xe6c7, 0x9299, 0x96e1, 0x0, 0xe6c5, 0xe6c6, 0x8b4d, 0x0,
 0xe6c8, 0x9483, 0x91dd, 0x0, 0x0, 0x94ef, 0x935c, 0xe6c4,
 0x0, 0x9666, 0x89ea, 0xe6ca, 0x9847, 0x92c0, 0x9864, 0x0,
 0x0, 0x8e91, 0xe6c9, 0x0, 0x91af, 0x0, 0x0, 0xe6da,
 0x9147, 0x0, 0x0, 0x93f6, 0x0, 0x956f, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe6cd, 0x8e5e, 0x8e92, 0x0,
 0x8fdc, 0x0, 0x9485, 0x0, 0x8cab, 0xe6cc, 0xe6cb, 0x0,
 0x958a, 0x0, 0x0, 0x0, 0x8ebf, 0x0, 0x0, 0x9371,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe6cf, 0xe6d0, 0x8d77, 0xe6ce,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6d1, 0xe6d2, 0x0,
 0xe6d4, 0x91a1, 0x0, 0xe6d3, 0x8ae4, 0x0, 0xe6d6, 0x0,
 0xe6d5, 0xe6d7, 0x0, 0x0, 0xe6d9, 0xe6db, 0x0, 0xe6dc,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x90d4, 0x0, 0x8ecd,
 0xe6dd, 0x0, 0x0, 0x0, 0x8a71, 0x0, 0xe6de, 0x0,
 0x0, 0x9196, 0xe6df, 0x0, 0xe6e0, 0x958b, 0x0, 0x0,
 0x8b4e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe6e1, 0x0, 0x0, 0x0, 0x92b4, 0x0,
 0x0, 0x0, 0x0, 0x897a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe6e2, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8eef, 0x0, 0x0, 0x0,
 0x0, 0x9096, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x91ab, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe6e5, 0x0, 0x0, 0x0, 0xe6e4,
 0x0, 0x0, 0x0, 0xe6e3, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe6eb, 0xe6e9, 0x0, 0x0,
 0xe6e6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6e8,
 0x0, 0x0, 0x0, 0xe6e7, 0xe6ea, 0x0, 0x8b97, 0x0,
 0xe6ee, 0x0, 0x90d5, 0x0, 0xe6ef, 0x0, 0x0, 0x0,
 0x0, 0x8cd7, 0x0, 0xe6ec, 0xe6ed, 0x0, 0x0, 0x0,
 0x9848, 0x0, 0x0, 0x0, 0x92b5, 0x0, 0x9148, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6f0, 0x0, 0x0,
 0xe6f3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe6f1, 0xe6f2, 0x9778, 0x0, 0x0, 0x0, 0x0,
 0x93a5, 0xe6f6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6f4, 0xe6f5,
 0xe6f7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe748, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe6fa, 0x0, 0x0, 0x0, 0xe6fb, 0xe6f9, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe6f8, 0x0, 0x92fb, 0x0, 0x0,
 0xe740, 0xe744, 0xe741, 0xe6fc, 0x0, 0xe742, 0x0, 0x0,
 0x0, 0xe743, 0x0, 0x0, 0x0, 0x0, 0xe74a, 0x0,
 0x0, 0x0, 0xe745, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x90d6, 0xe747, 0x0, 0x0, 0xe749, 0xe746, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe74c, 0x0, 0x8f52, 0x0, 0xe74b,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe74d, 0x0, 0x0,
 0x0, 0x0, 0xe74e, 0x0, 0x0, 0xe751, 0xe750, 0x0,
 0xe74f, 0x0, 0x0, 0xe753, 0xe752, 0x0, 0x96f4, 0x0,
 0x0, 0x0, 0xe755, 0x0, 0xe754, 0xe756, 0x0, 0x0,
 0x0, 0x0, 0xe757, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe759, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe758, 0x9067, 0xe75a, 0x0, 0x0,
 0x8beb, 0xe75b, 0xe75d, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe75e,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe75f, 0xe75c,
 0x0, 0xe760, 0x0, 0x8ed4, 0xe761, 0x8b4f, 0x8c52, 0x0,
 0x0, 0x0, 0x0, 0x8cac, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe762, 0x0, 0x0, 0x0,
 0x93ee, 0x0, 0x0, 0x935d, 0xe763, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe766, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8eb2, 0x0, 0x0, 0xe765, 0xe764, 0x8c79, 0xe767,
 0x0, 0x0, 0x0, 0x0, 0x8a72, 0x0, 0xe769, 0x0,
 0x0, 0x0, 0x8dda, 0xe768, 0x0, 0xe771, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe76b, 0xe76d, 0x95e3, 0xe76a, 0x0,
 0x0, 0x0, 0xe76c, 0x0, 0xe770, 0xe76e, 0x8b50, 0x0,
 0xe76f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe772,
 0x0, 0x0, 0x9479, 0x97d6, 0x0, 0x0, 0x0, 0x0,
 0x8f53, 0x0, 0x0, 0x0, 0xe773, 0x0, 0x0, 0x0,
 0x0, 0x9741, 0xe775, 0x0, 0xe774, 0x0, 0x0, 0xe778,
 0x9760, 0x0, 0x0, 0xe777, 0x0, 0x8a8d, 0xe776, 0xe77b,
 0x0, 0x0, 0xe77a, 0x0, 0x0, 0xe779, 0x9351, 0xe77c,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe77d, 0x0, 0x0, 0x0, 0x0, 0xe77e, 0x0, 0x0,
 0x8d8c, 0x0, 0x8c44, 0xe780, 0xe781, 0xe782, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9068, 0xe783, 0x0, 0x8eab,
 0xe784, 0x0, 0x0, 0x0, 0xe785, 0x0, 0x0, 0x0,
 0x999f, 0x999e, 0x0, 0x0, 0x0, 0x0, 0xe786, 0xe390,
 0xe787, 0x9243, 0x904a, 0x945f, 0x0, 0x0, 0x0, 0x0,
 0xe788, 0x0, 0x0, 0x95d3, 0x92d2, 0x8d9e, 0x0, 0x0,
 0x9248, 0x0, 0x0, 0x8949, 0x0, 0x9698, 0x9076, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c7d,
 0x0, 0x0, 0x8bdf, 0x0, 0x0, 0x95d4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe789, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe78b, 0x0, 0x0, 0xe78a, 0x89de,
 0x0, 0x0, 0x93f4, 0xe78c, 0x9497, 0x0, 0x9352, 0x0,
 0xe78d, 0x8f71, 0x0, 0x0, 0x0, 0xe78f, 0x0, 0x0,
 0x96c0, 0xe79e, 0xe791, 0xe792, 0x0, 0x0, 0x92c7, 0x0,
 0x0, 0x91de, 0x9197, 0x0, 0x93a6, 0x0, 0xe790, 0x8b74,
 0x0, 0x0, 0x0, 0x0, 0xe799, 0x0, 0xe796, 0xe7a3,
 0x93a7, 0x9280, 0xe793, 0x0, 0x92fc, 0x9372, 0xe794, 0xe798,
 0x9080, 0x0, 0x9487, 0x92ca, 0x0, 0x0, 0x90c0, 0xe797,
 0x91ac, 0x91a2, 0xe795, 0x88a7, 0x9841, 0x0, 0x0, 0x0,
 0xe79a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x91df,
 0x0, 0x0, 0x8f54, 0x9069, 0x0, 0x0, 0xe79c, 0xe79b,
 0x0, 0x88ed, 0xe79d, 0x0, 0x0, 0x954e, 0x0, 0xe7a5,
 0x0, 0x0, 0x93d9, 0x908b, 0x0, 0x0, 0x9278, 0x0,
 0x8bf6, 0x0, 0xe7a4, 0x9756, 0x895e, 0x0, 0x95d5, 0x89df,
 0xe79f, 0xe7a0, 0xe7a1, 0xe7a2, 0x93b9, 0x9242, 0x88e1, 0xe7a6,
 0x0, 0xe7a7, 0xeaa1, 0x0, 0x0, 0x91bb, 0x0, 0xe7a8,
 0x0, 0x8993, 0x916b, 0x0, 0x8cad, 0x0, 0x9779, 0x0,
 0x0, 0xe7a9, 0x934b, 0x0, 0x0, 0x0, 0x9198, 0x8ed5,
 0xe7aa, 0x0, 0x0, 0xe7ad, 0x0, 0x0, 0x8f85, 0xe7ab,
 0x914a, 0x9149, 0x0, 0x88e2, 0x0, 0x97c9, 0xe7af, 0x0,
 0x94f0, 0xe7b1, 0xe7b0, 0xe7ae, 0xe284, 0x8ad2, 0x0, 0x0,
 0xe78e, 0x0, 0xe7b3, 0xe7b2, 0x0, 0x0, 0x0, 0x0,
 0xe7b4, 0x0, 0x9757, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x93df, 0x0, 0x0, 0x964d,
 0x0, 0xe7b5, 0x0, 0x8ed7, 0x0, 0x0, 0x0, 0x0,
 0xe7b6, 0x0, 0xe7b7, 0x0, 0x0, 0x0, 0xe7b8, 0x0,
 0x0, 0x9340, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x88e8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8d78, 0x0, 0x0, 0x0, 0x9859,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe7bc, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8c53, 0xe7b9, 0x0, 0xe7ba, 0x0, 0x0,
 0x0, 0x9594, 0x0, 0x0, 0x0, 0x0, 0x8a73, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9758, 0x0,
 0x8bbd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9373, 0x0,
 0x0, 0x0, 0x0, 0xe7bd, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe7be, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe7bf, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9341, 0x0,
 0x0, 0xe7c1, 0x0, 0xe7c0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x93d1, 0xe7c2, 0x8f55, 0x8ede, 0x947a, 0x9291,
 0x0, 0x0, 0x0, 0x8ef0, 0x0, 0x908c, 0x0, 0xe7c3,
 0x0, 0xe7c4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x907c, 0xe7c5, 0x0, 0xe7c6, 0x0,
 0x0, 0x0, 0xe7c7, 0x978f, 0x0, 0x8f56, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe7c9, 0xe7c8, 0x0, 0x8d79, 0x0,
 0x8d93, 0x8e5f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe7cc, 0x0, 0x0, 0x0, 0x0,
 0x8f86, 0x0, 0xe7cb, 0x0, 0xe7ca, 0x0, 0x91e7, 0x0,
 0x0, 0x8ced, 0x0, 0x90c1, 0x0, 0x0, 0x0, 0x0,
 0x94ae, 0x0, 0x0, 0x0, 0x0, 0x8f58, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe7cd, 0x0, 0x8fdd, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe7d0, 0xe7ce, 0x0, 0x0, 0x0,
 0xe7cf, 0x0, 0x0, 0x0, 0x0, 0xe7d2, 0xe7d1, 0x0,
 0x0, 0x8ff8, 0x0, 0xe7d3, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe7d4, 0xe7d5, 0x0, 0x0, 0x0, 0x0, 0x94ce,
 0x8dd1, 0x8edf, 0xe7d6, 0x0, 0xe7d7, 0x97a2, 0x8f64, 0x96ec,
 0x97ca, 0xe7d8, 0x8be0, 0x0, 0x0, 0x0, 0x0, 0xe7d9,
 0x0, 0x9342, 0x0, 0x0, 0xe7dc, 0x8a98, 0x906a, 0x0,
 0xe7da, 0x0, 0xe7db, 0x0, 0x92de, 0x0, 0x0, 0x9674,
 0x8bfa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe7de, 0xe7df,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe7dd, 0x0, 0x0,
 0xe7e1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x93dd, 0x8a62,
 0x0, 0x0, 0xe7e5, 0x0, 0x0, 0xe7e2, 0xe7e4, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe7e0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe86e, 0x0, 0x0, 0xe7e3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x97e9, 0x0, 0x0,
 0x8cd8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe7ed, 0x0, 0x0, 0x0, 0x0, 0x9353, 0xe7e8, 0x0,
 0x0, 0xe7eb, 0xe7e9, 0x0, 0xe7ee, 0x0, 0x0, 0x0,
 0x0, 0xe7ef, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe7e7, 0x0, 0x0, 0xe7f4, 0x8994, 0x0, 0x0, 0xe7e6,
 0x0, 0x0, 0x0, 0x94ab, 0x0, 0xe7ea, 0x0, 0x8fde,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8d7a, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9667,
 0x0, 0x8be2, 0x0, 0x0, 0x8f65, 0x0, 0x93ba, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x914c, 0x0, 0xe7f2, 0x0, 0xe7ec, 0xe7f1,
 0x0, 0x96c1, 0x0, 0x92b6, 0xe7f3, 0xe7f0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x914b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe7f7, 0x0, 0xe7f6, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe7f5, 0x0, 0x0, 0x964e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f9b, 0x0, 0x0,
 0x0, 0x0, 0xe7f8, 0x95dd, 0x0, 0x0, 0x8973, 0x0,
 0x0, 0x0, 0x0, 0x9565, 0x9292, 0xe844, 0x0, 0x0,
 0x0, 0x0, 0x8b98, 0x0, 0xe7fa, 0x0, 0x8d7c, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8e4b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe7f9, 0x908d, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x908e, 0xe840, 0xe842, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8ff9, 0x0, 0xe841, 0xe843, 0x0, 0x0,
 0x8bd1, 0x0, 0x9564, 0x0, 0x0, 0x8ee0, 0x9842, 0x0,
 0xe7fc, 0x8df6, 0x0, 0x0, 0x985e, 0x0, 0x0, 0xe845,
 0x0, 0x0, 0x0, 0x0, 0xe846, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe7fb, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x93e7, 0x0, 0x9374, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x92d5, 0x0, 0xe84b,
 0x0, 0x0, 0x0, 0x0, 0x9262, 0xe847, 0x0, 0x0,
 0x0, 0xe848, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c4c, 0x0, 0xe84a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8cae, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe849, 0x0, 0x8fdf,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8a99, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe84f, 0x0, 0x8dbd,
 0x9199, 0x0, 0x0, 0x92c8, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8a5a, 0x0, 0x0, 0x0, 0xe84d, 0xe84e, 0x92c1, 0x0,
 0xe84c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe850, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe856, 0x0, 0x0, 0x0,
 0x0, 0xe859, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe858, 0x934c, 0x0, 0x0, 0x0, 0x0, 0xe851,
 0xe852, 0xe855, 0x0, 0x0, 0x0, 0x0, 0xe857, 0x0,
 0x0, 0x0, 0x8bbe, 0x0, 0x0, 0xe85a, 0xe854, 0x0,
 0x0, 0xe853, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe85e, 0x0, 0x0, 0x0,
 0xe85f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe860, 0x0, 0x0, 0xe85d, 0xe85c, 0x0, 0x0,
 0x0, 0x8fe0, 0x93a8, 0xe85b, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe864, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe862, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe863, 0xe861,
 0x0, 0x91f6, 0x0, 0xe865, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe866, 0x0, 0x0, 0xe868, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8ad3, 0xe867, 0x96f8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe873, 0xe869, 0x0, 0x0, 0xe86c,
 0x0, 0xe86a, 0x0, 0xe86b, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe86d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe86f, 0x0, 0x0, 0x0, 0x0, 0xe870, 0x0,
 0xe871, 0x0, 0x0, 0x0, 0x0, 0xe874, 0xe872, 0xe875,
 0xe877, 0x0, 0xe876, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x92b7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x96e5, 0x0, 0xe878, 0x914d, 0x0, 0x0, 0x0,
 0xe879, 0x0, 0x95c2, 0xe87a, 0x8a4a, 0x0, 0x0, 0x0,
 0x895b, 0x0, 0x8ad5, 0x0, 0x8ad4, 0xe87b, 0x0, 0xe87c,
 0x0, 0xe87d, 0xe87e, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe880, 0x0, 0x8ad6, 0x8a74, 0x8d7d, 0x94b4, 0x0,
 0xe882, 0xe881, 0x0, 0x0, 0x0, 0x0, 0xe883, 0x0,
 0x0, 0x0, 0x0, 0x897b, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe886, 0x0, 0xe885, 0xe884, 0x0, 0xe887,
 0x0, 0x0, 0x0, 0x0, 0xe88a, 0x0, 0x0, 0x0,
 0x88c5, 0x0, 0x0, 0xe888, 0x0, 0xe88c, 0xe88b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe88e, 0xe88d, 0xe88f,
 0x0, 0x93ac, 0x0, 0x0, 0x0, 0xe890, 0x0, 0x0,
 0x0, 0x0, 0xe891, 0xe893, 0x0, 0x0, 0xe892, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x958c, 0x0, 0x0,
 0x0, 0x0, 0xe894, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe895, 0x0, 0x8de3, 0x0, 0x0, 0x0, 0xe896,
 0xe897, 0x0, 0x0, 0x9668, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x916a, 0x0, 0x0, 0x0,
 0x88a2, 0x91c9, 0x0, 0xe898, 0x0, 0x958d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe89b, 0xe899, 0x8d7e, 0x0,
 0xe89a, 0x8cc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x95c3, 0xe89d, 0xe89f, 0xe89e,
 0xe8a0, 0x0, 0x0, 0x8940, 0x9077, 0x8f9c, 0x8ad7, 0xe8a1,
 0x0, 0x0, 0x0, 0x9486, 0x0, 0xe8a3, 0x0, 0x0,
 0x0, 0x8941, 0x0, 0xe8a2, 0x92c2, 0x0, 0x97cb, 0x93a9,
 0xe89c, 0x97a4, 0x0, 0x8caf, 0x0, 0x0, 0x977a, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8bf7, 0x97b2,
 0x0, 0x8c47, 0x0, 0x91e0, 0xe440, 0x0, 0xe8a4, 0x8a4b,
 0x908f, 0x0, 0x0, 0x0, 0x0, 0x8a75, 0xe8a6, 0x0,
 0xe8a7, 0xe8a5, 0x8c84, 0x0, 0x8ddb, 0x8fe1, 0x0, 0x0,
 0x0, 0x8942, 0x0, 0x0, 0x97d7, 0x0, 0x0, 0x0,
 0xe8a9, 0xe7ac, 0x0, 0xe8a8, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe8ac, 0xe8aa, 0xe8ab, 0x0, 0xe8ad, 0x0, 0xe8ae,
 0x97ea, 0xe8af, 0xe8b0, 0x0, 0x90c7, 0x94b9, 0x0, 0x0,
 0x0, 0x909d, 0x8ae5, 0x0, 0x0, 0x9759, 0x89eb, 0x8f57,
 0x8cd9, 0x0, 0xe8b3, 0x0, 0xe8b2, 0x8e93, 0xe8b4, 0xe8b1,
 0x0, 0x0, 0x8e47, 0x0, 0x0, 0x0, 0xe8b8, 0xe5ab,
 0x0, 0x0, 0x99d4, 0x0, 0x9097, 0xe8b6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x97a3, 0x93ef, 0x0, 0x0, 0x0,
 0x0, 0x894a, 0x0, 0x90e1, 0x8eb4, 0x0, 0x0, 0x0,
 0x0, 0x95b5, 0x0, 0x895f, 0x0, 0x0, 0x0, 0x97eb,
 0x978b, 0x0, 0xe8b9, 0x0, 0x9364, 0x0, 0x0, 0x0,
 0x0, 0x8ef9, 0x0, 0x0, 0x0, 0xe8ba, 0x0, 0xe8bb,
 0x906b, 0xe8bc, 0x0, 0x97ec, 0x0, 0x0, 0xe8b7, 0xe8be,
 0xe8c0, 0x0, 0xe8bf, 0x0, 0xe8bd, 0x0, 0x0, 0xe8c1,
 0x0, 0x0, 0xe8c2, 0x0, 0x0, 0x919a, 0x0, 0x89e0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe8c3, 0x0, 0x0,
 0x96b6, 0x0, 0x0, 0xe8c4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe8c5, 0x0, 0x9849, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9e50, 0xe8c6, 0x0, 0x0, 0xe8c7, 0xe8c8, 0x0,
 0x0, 0x0, 0x0, 0xe8cc, 0x0, 0xe8c9, 0x0, 0xe8ca,
 0x0, 0xe8cb, 0xe8cd, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x90c2, 0x0, 0x0, 0x0, 0x90c3,
 0x96f5, 0x0, 0x0, 0x0, 0x0, 0xe8ce, 0x0, 0x94f1,
 0x0, 0xe8cf, 0xea72, 0x96ca, 0x0, 0xe8d0, 0x0, 0xe8d1,
 0x0, 0xe8d2, 0x8a76, 0x0, 0xe8d4, 0x0, 0x9078, 0x0,
 0x0, 0x0, 0xe8d5, 0x0, 0x0, 0x8c43, 0x0, 0x0,
 0x0, 0x0, 0xe8d6, 0xe8da, 0x0, 0xe8d8, 0x0, 0x0,
 0x0, 0x0, 0xe8d9, 0x0, 0x0, 0x8a93, 0xe8d7, 0xe8db,
 0x0, 0x0, 0x0, 0x0, 0xe8dc, 0x0, 0x88c6, 0x0,
 0xe8dd, 0xe8de, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8fe2, 0x0, 0x0, 0x0, 0xe8df, 0x0, 0x0,
 0x0, 0x8b66, 0x0, 0x0, 0xe8e2, 0x0, 0x0, 0xe8e1,
 0x0, 0xe8e0, 0x0, 0x0, 0xe691, 0x0, 0x95da, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe8e3, 0xe8e4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe8e5, 0x0, 0x0, 0xe8e6,
 0x0, 0xe8e7, 0x0, 0x0, 0xe8e8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8ad8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe8e9, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe8ea, 0x9442,
 0x0, 0x0, 0x0, 0xe8ec, 0x89b9, 0x0, 0xe8ef, 0xe8ee,
 0x0, 0x0, 0x0, 0x0, 0x8943, 0x0, 0x0, 0x0,
 0x8bbf, 0x0, 0x95c5, 0x92b8, 0x8da0, 0x0, 0x8d80, 0x8f87,
 0x0, 0x907b, 0x0, 0x0, 0x0, 0xe8f1, 0x0, 0x0,
 0xe8f0, 0x9761, 0x8ae6, 0x94d0, 0x93da, 0x0, 0x0, 0x0,
 0x909c, 0x97cc, 0x0, 0x8c7a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe8f4, 0x0, 0x0, 0xe8f3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x966a, 0x93aa, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x896f, 0x0, 0x0,
 0xe8f5, 0xe8f2, 0x0, 0x0, 0x9570, 0x978a, 0xe8f6, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe8f7,
 0x0, 0x0, 0x0, 0x0, 0xe8f9, 0x91e8, 0x8a7a, 0x8a7b,
 0xe8f8, 0x0, 0x0, 0x0, 0x0, 0x8ae7, 0x8cb0, 0x0,
 0x0, 0x8ae8, 0x0, 0x0, 0x935e, 0x0, 0x0, 0x97de,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8cda, 0x0, 0x0, 0x0, 0xe8fa, 0x0, 0x0, 0x0,
 0xe8fb, 0xe8fc, 0xe940, 0x0, 0xe942, 0xe941, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9597, 0x0, 0xe943, 0x0, 0x0, 0x0, 0x0,
 0xe944, 0x0, 0xe945, 0x0, 0x0, 0x0, 0x0, 0xe946,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe948, 0xe947, 0x0, 0xe949,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x94f2, 0xe3ca, 0x0, 0x0,
 0x9048, 0x0, 0x0, 0x8b51, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe94a, 0x0, 0xe94b, 0x0, 0x99aa, 0x9f5a,
 0x94d1, 0x0, 0x0, 0x88f9, 0x0, 0x88b9, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e94, 0x964f, 0x8ffc,
 0x0, 0x0, 0x0, 0x0, 0xe94c, 0x0, 0x96dd, 0x0,
 0x0, 0x0, 0xe94d, 0x977b, 0x0, 0x8961, 0x0, 0x0,
 0x0, 0x8e60, 0x0, 0xe94e, 0x89ec, 0xe94f, 0x0, 0x0,
 0x0, 0xe950, 0x0, 0x0, 0x0, 0x0, 0xe952, 0xe953,
 0x0, 0xe955, 0xe951, 0x0, 0x0, 0xe954, 0x0, 0x0,
 0x0, 0x8ad9, 0x0, 0x0, 0x0, 0xe956, 0x0, 0xe957,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe958, 0xe959,
 0x0, 0x0, 0x0, 0xe95a, 0x0, 0x0, 0xe95c, 0x0,
 0x0, 0x0, 0xe95b, 0x0, 0xe95e, 0xe961, 0x0, 0x0,
 0x0, 0xe95d, 0xe95f, 0xe960, 0x0, 0x0, 0xe962, 0x0,
 0x8bc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ef1,
 0xe963, 0xe964, 0x8d81, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe965, 0x0,
 0x0, 0x8a5d, 0x0, 0x0, 0x0, 0x946e, 0xe966, 0xe967,
 0x0, 0x0, 0x0, 0x0, 0x9279, 0x93e9, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe968, 0x0, 0x0,
 0x0, 0x0, 0x949d, 0x0, 0x0, 0x91ca, 0x8977, 0x8bec,
 0x0, 0x8bed, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9293, 0xe96d, 0x8bee, 0x0, 0x0, 0x89ed, 0x0,
 0x0, 0xe96c, 0x0, 0x0, 0xe96a, 0x0, 0xe96b, 0x0,
 0xe969, 0x0, 0x0, 0xe977, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe96e, 0xe96f,
 0x0, 0x0, 0xe970, 0xe971, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe973, 0x0, 0x0, 0xe972, 0x0, 0x0, 0x0,
 0x8f78, 0x0, 0xe974, 0x0, 0x0, 0x0, 0xe976, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b52,
 0xe975, 0x0, 0x0, 0x919b, 0x8cb1, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe978, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x91cb, 0x0, 0x0, 0xe979, 0x0, 0x0, 0x0,
 0x0, 0x93ab, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe97a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe980,
 0x0, 0xe97d, 0x0, 0xe97c, 0xe97e, 0x0, 0xe97b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe982, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe981, 0x0,
 0xe984, 0x0, 0x0, 0x8bc1, 0xe983, 0x0, 0x0, 0x0,
 0xe985, 0x0, 0x0, 0xe986, 0x0, 0xe988, 0xe987, 0x0,
 0x0, 0x0, 0xe989, 0xe98b, 0xe98a, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8d9c, 0x0, 0x0, 0x0, 0x0, 0xe98c, 0x0,
 0x0, 0xe98d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8a5b, 0x0, 0x0, 0x0, 0xe98e, 0x0, 0x0,
 0x0, 0xe98f, 0x0, 0x0, 0x0, 0x9091, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe990, 0x0, 0xe991, 0x0, 0xe992, 0xe993, 0x0, 0x0,
 0x0, 0x8d82, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe994,
 0xe995, 0x0, 0x0, 0xe996, 0xe997, 0x0, 0x0, 0xe998,
 0x0, 0x0, 0x0, 0x94af, 0xe99a, 0x0, 0x9545, 0xe99b,
 0xe999, 0x0, 0xe99d, 0x0, 0x0, 0xe99c, 0x0, 0x0,
 0xe99e, 0x0, 0x0, 0x0, 0xe99f, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9a0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe9a1, 0x0, 0xe9a2, 0x0, 0x0, 0x0, 0x0,
 0xe9a3, 0x0, 0x0, 0xe9a4, 0xe9a5, 0x0, 0xe9a6, 0x0,
 0xe9a7, 0xe9a8, 0xe9a9, 0xe9aa, 0x0, 0x0, 0x0, 0xe9ab,
 0xe9ac, 0x0, 0x9f54, 0xe9ad, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe2f6, 0x8b53, 0x0, 0x0,
 0x0, 0x0, 0x8a40, 0x8db0, 0xe9af, 0xe9ae, 0x96a3, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9b1, 0xe9b2,
 0xe9b0, 0x0, 0xe9b3, 0x0, 0x0, 0x9682, 0x0, 0x0,
 0x0, 0xe9b4, 0x0, 0x8b9b, 0x0, 0x0, 0x0, 0x0,
 0x9844, 0x0, 0x0, 0x0, 0x0, 0xe9b5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe9b7, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88bc,
 0x0, 0x0, 0xe9b8, 0x95a9, 0xe9b6, 0x0, 0x0, 0xe9b9,
 0xe9ba, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe9bb, 0xe9bc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe9bd, 0x0, 0x968e, 0x8e4c, 0x0, 0x8df8, 0x914e,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9be, 0x0, 0x0,
 0x0, 0x0, 0xe9c1, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe9bf, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9c2,
 0x0, 0x0, 0x8cef, 0xe9c0, 0x0, 0x0, 0x0, 0x0,
 0xe9c3, 0x0, 0xe9c4, 0xe9c5, 0x0, 0xe9c9, 0x0, 0x8e49,
 0x0, 0x0, 0x0, 0x0, 0x91e2, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe9ca, 0xe9c7, 0xe9c6, 0xe9c8, 0x0, 0x0,
 0x0, 0x8c7e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe9ce, 0xe9cd, 0xe9cc, 0x0, 0x0, 0x88b1, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9d8, 0x0, 0xe9d4,
 0x0, 0xe9d5, 0xe9d1, 0xe9d7, 0x0, 0xe9d3, 0x8a82, 0x0,
 0x0, 0x986b, 0x0, 0xe9d6, 0xe9d2, 0xe9d0, 0xe9cf, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9da, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe9dd, 0x0, 0x0, 0xe9dc, 0xe9db,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9568, 0xe9d9,
 0x88f1, 0xe9de, 0x0, 0xe9e0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8a8f, 0xe9cb, 0x8956, 0x0, 0x0, 0xe9e2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9e1,
 0xe9df, 0x924c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9690, 0x0, 0x0, 0x0,
 0x0, 0x97d8, 0x0, 0x0, 0xe9e3, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe9e4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe9e5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe9e6, 0x0, 0xe9e7, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x92b9,
 0x0, 0xe9e8, 0x0, 0x94b5, 0x0, 0xe9ed, 0xe9e9, 0x0,
 0x0, 0x0, 0xe9ea, 0x0, 0x0, 0x9650, 0x96c2, 0x0,
 0x93ce, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9ee, 0x0, 0x0,
 0xe9ef, 0x93bc, 0xe9ec, 0xe9eb, 0x0, 0x0, 0x0, 0x0,
 0x89a8, 0x0, 0x0, 0x0, 0xe9f7, 0x0, 0x0, 0xe9f6,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8995, 0x0, 0x0,
 0x0, 0xe9f4, 0x0, 0x0, 0x0, 0xe9f3, 0x0, 0x0,
 0xe9f1, 0x0, 0x8a9b, 0x0, 0xe9f0, 0x8eb0, 0x89a7, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8d83, 0x0, 0x0,
 0xe9fa, 0xe9f9, 0x0, 0xe9f8, 0x0, 0x0, 0xe9f5, 0x0,
 0xe9fb, 0x0, 0xe9fc, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea44, 0xea43, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xea45, 0x0, 0x0, 0x894c, 0xea40,
 0xea41, 0x0, 0x8d94, 0x96b7, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9651, 0x0, 0x0,
 0xea4a, 0x0, 0x0, 0xea46, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xea4b, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xea48, 0x0, 0xea47, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8c7b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xea4c, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea4d, 0x0, 0x0,
 0x0, 0x0, 0xea4e, 0x0, 0xea49, 0x0, 0x0, 0x0,
 0xe9f2, 0x0, 0x0, 0xea4f, 0x0, 0x92df, 0x0, 0x0,
 0x0, 0xea53, 0x0, 0xea54, 0xea52, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea51, 0xea57, 0x0, 0xea50, 0x0, 0xea55,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xea56, 0x0, 0x0, 0x0, 0xea59, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea58, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xea5b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea5c, 0x0, 0xea5d,
 0x0, 0x0, 0x9868, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xea5a, 0x91e9, 0x8deb, 0x0, 0x0, 0xea5e, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea5f, 0xea60, 0x0, 0x0, 0xea61, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea62, 0x0, 0x0,
 0x8cb2, 0xea63, 0x0, 0x0, 0x0, 0xea64, 0x0, 0x8ead,
 0x0, 0xea65, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xea66, 0x0, 0x0, 0xea67, 0xea68, 0x0, 0x0, 0x0,
 0x0, 0xea6b, 0xea69, 0x985b, 0x0, 0xea6a, 0x0, 0x97ed,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea6c, 0x0, 0x97d9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea6d, 0x949e, 0x0,
 0x0, 0xea6e, 0xea70, 0x0, 0x0, 0xea71, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xea6f, 0x8d8d, 0x96cb, 0x9683, 0x9bf5, 0x0, 0x9f80, 0x969b,
 0x0, 0x0, 0x0, 0x0, 0x89a9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xea73, 0x8b6f, 0xea74, 0xea75,
 0xea76, 0x0, 0x8d95, 0x0, 0xea77, 0x0, 0x0, 0x0,
 0xe0d2, 0x96d9, 0x0, 0x91e1, 0xea78, 0xea7a, 0xea79, 0x0,
 0xea7b, 0x0, 0x0, 0x0, 0x0, 0xea7c, 0x0, 0x0,
 0xea7d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xea7e,
 0x0, 0x0, 0x0, 0x0, 0xea80, 0x0, 0xea81, 0xea82,
 0x0, 0xea83, 0x0, 0xea84, 0xea85, 0xea86, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xea87,
 0xea88, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9343, 0x0,
 0x0, 0x0, 0x0, 0x8cdb, 0x0, 0xea8a, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x916c, 0xea8b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xea8c, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9540, 0x0, 0x0, 0xea8d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea8e, 0xe256, 0x0, 0x0, 0xe6d8, 0xe8eb,
 0x0, 0x0, 0xea8f, 0x0, 0xea90, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xea92,
 0xea93, 0xea94, 0x97ee, 0xea91, 0x0, 0x0, 0xea95, 0xea96,
 0x0, 0x0, 0xea98, 0x0, 0xea97, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea9a, 0x0, 0x0, 0x0, 0xea9b, 0xea99,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x97b4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea9c, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xea9d, 0xe273, 0x0, 0x0,
 0xea9e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8149, 0x0, 0x8194, 0x8190, 0x8193, 0x8195, 0x0,
 0x8169, 0x816a, 0x8196, 0x817b, 0x8143, 0x817c, 0x8144, 0x815e,
 0x824f, 0x8250, 0x8251, 0x8252, 0x8253, 0x8254, 0x8255, 0x8256,
 0x8257, 0x8258, 0x8146, 0x8147, 0x8183, 0x8181, 0x8184, 0x8148,
 0x8197, 0x8260, 0x8261, 0x8262, 0x8263, 0x8264, 0x8265, 0x8266,
 0x8267, 0x8268, 0x8269, 0x826a, 0x826b, 0x826c, 0x826d, 0x826e,
 0x826f, 0x8270, 0x8271, 0x8272, 0x8273, 0x8274, 0x8275, 0x8276,
 0x8277, 0x8278, 0x8279, 0x816d, 0x815f, 0x816e, 0x814f, 0x8151,
 0x814d, 0x8281, 0x8282, 0x8283, 0x8284, 0x8285, 0x8286, 0x8287,
 0x8288, 0x8289, 0x828a, 0x828b, 0x828c, 0x828d, 0x828e, 0x828f,
 0x8290, 0x8291, 0x8292, 0x8293, 0x8294, 0x8295, 0x8296, 0x8297,
 0x8298, 0x8299, 0x829a, 0x816f, 0x8162, 0x8170, 0x8160, 0x0,
 0x0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
 0x8191, 0x8192, 0x81ca, 0x8150, 0x0, 0x818f, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
0x0000,    };

#define DBCS_LeadingStart1    ((UCHAR)0x81)
#define DBCS_LeadingEnd1      ((UCHAR)0x9f)
#define DBCS_LeadingStart2    ((UCHAR)0xe0)
#define DBCS_LeadingEnd2      ((UCHAR)0xfc)
#define DBCS_TrailingStart    ((UCHAR)0x40)
#define DBCS_TrailingEnd      ((UCHAR)0xfc)
#define LeadingRange1       ( DBCS_LeadingEnd1 - DBCS_LeadingStart1 )
#define LeadingRange2       ( DBCS_LeadingEnd2 - DBCS_LeadingStart2 )
#define TrailingRange      ( DBCS_TrailingEnd - DBCS_TrailingStart )

#define LOBYTE(w)           ((UCHAR)(w))
#define HIBYTE(w)           ((UCHAR)(((USHORT)(w) >> 8) & 0xFF))
#define LEADING_BYTE(w)	      HIBYTE(w)
#define TRAILING_BYTE(w)      LOBYTE(w)

typedef struct _SJ_TO_UNICODE
{
    WCHAR SBCS_Table[256];
    WCHAR DBCS_Table1[LeadingRange1 + 1][TrailingRange + 1];
    WCHAR DBCS_Table2[LeadingRange2 + 1][TrailingRange + 1];
} SJ_TO_UNICODE;

SJ_TO_UNICODE sj_to_unicode = {

{ /////////////////////////////////////////// SBCS_Table

/* 0x0-0x7 */ 0x0,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
/* 0x8-0xf */ 0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
/* 0x10-0x17 */ 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
/* 0x18-0x1f */ 0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
/* 0x20-0x27 */ 0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
/* 0x28-0x2f */ 0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
/* 0x30-0x37 */ 0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
/* 0x38-0x3f */ 0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
/* 0x40-0x47 */ 0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,
/* 0x48-0x4f */ 0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
/* 0x50-0x57 */ 0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,
/* 0x58-0x5f */ 0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
/* 0x60-0x67 */ 0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
/* 0x68-0x6f */ 0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
/* 0x70-0x77 */ 0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
/* 0x78-0x7f */ 0x78,0x79,0x7a,0x7b,0x7c,0x7d,0xaf,0x7f,
/* 0x80-0x87 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x88-0x8f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x90-0x97 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x98-0x9f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xa0-0xa7 */ 0x0,0xff61,0xff62,0xff63,0xff64,0xff65,0xff66,0xff67,
/* 0xa8-0xaf */ 0xff68,0xff69,0xff6a,0xff6b,0xff6c,0xff6d,0xff6e,0xff6f,
/* 0xb0-0xb7 */ 0xff70,0xff71,0xff72,0xff73,0xff74,0xff75,0xff76,0xff77,
/* 0xb8-0xbf */ 0xff78,0xff79,0xff7a,0xff7b,0xff7c,0xff7d,0xff7e,0xff7f,
/* 0xc0-0xc7 */ 0xff80,0xff81,0xff82,0xff83,0xff84,0xff85,0xff86,0xff87,
/* 0xc8-0xcf */ 0xff88,0xff89,0xff8a,0xff8b,0xff8c,0xff8d,0xff8e,0xff8f,
/* 0xd0-0xd7 */ 0xff90,0xff91,0xff92,0xff93,0xff94,0xff95,0xff96,0xff97,
/* 0xd8-0xdf */ 0xff98,0xff99,0xff9a,0xff9b,0xff9c,0xff9d,0xff9e,0xff9f,
/* 0xe0-0xe7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xe8-0xef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xf0-0xf7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xf8-0xff */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
}, /////////////////////////////////////// SBCS_Table

{ //////////////////////////////////////// DBCS_Table1

{ /* 0x81 */
/* 0x8140 - 0x8147 */ 0x3000,0x3001,0x3002,0xff0c,0xff0e,0x30fb,0xff1a,0xff1b,
/* 0x8148 - 0x814f */ 0xff1f,0xff01,0x309b,0x309c,0xb4,0xff40,0xa8,0xff3e,
/* 0x8150 - 0x8157 */ 0xffe3,0xff3f,0x30fd,0x30fe,0x309d,0x309e,0x3003,0x3004,
/* 0x8158 - 0x815f */ 0x3005,0x3006,0x3007,0x30fc,0x2015,0xad,0xff0f,0xff3c,
/* 0x8160 - 0x8167 */ 0xff5e,0x2225,0xff5c,0x2026,0x2025,0x2018,0x2019,0x201c,
/* 0x8168 - 0x816f */ 0x201d,0xff08,0xff09,0x3014,0x3015,0xff3b,0xff3d,0xff5b,
/* 0x8170 - 0x8177 */ 0xff5d,0x3008,0x3009,0x300a,0x300b,0x300c,0x300d,0x300e,
/* 0x8178 - 0x817f */ 0x300f,0x3010,0x3011,0xff0b,0xff0d,0xb1,0xd7,0x0,
/* 0x8180 - 0x8187 */ 0xf7,0xff1d,0x2260,0xff1c,0xff1e,0x2266,0x2267,0x221e,
/* 0x8188 - 0x818f */ 0x2234,0x2642,0x2640,0xb0,0x2032,0x2033,0x2103,0xffe5,
/* 0x8190 - 0x8197 */ 0xff04,0xffe0,0xffe1,0xff05,0xff03,0xff06,0xff0a,0xff20,
/* 0x8198 - 0x819f */ 0xa7,0x2606,0x2605,0x25cb,0x25cf,0x25ce,0x25c7,0x25c6,
/* 0x81a0 - 0x81a7 */ 0x25a1,0x25a0,0x25b3,0x25b2,0x25bd,0x25bc,0x203b,0x3012,
/* 0x81a8 - 0x81af */ 0x2192,0x2190,0x2191,0x2193,0x3013,0x0,0x0,0x0,
/* 0x81b0 - 0x81b7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x81b8 - 0x81bf */ 0x2208,0x220b,0x2286,0x2287,0x2282,0x2283,0x222a,0x2229,
/* 0x81c0 - 0x81c7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x81c8 - 0x81cf */ 0x2227,0x2228,0xffe2,0x21d2,0x21d4,0x2200,0x2203,0x0,
/* 0x81d0 - 0x81d7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x81d8 - 0x81df */ 0x0,0x0,0x2220,0x22a5,0x2312,0x2202,0x2207,0x2261,
/* 0x81e0 - 0x81e7 */ 0x2252,0x226a,0x226b,0x221a,0x223d,0x221d,0x2235,0x222b,
/* 0x81e8 - 0x81ef */ 0x222c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x81f0 - 0x81f7 */ 0x212b,0x2030,0x266f,0x266d,0x266a,0x2020,0x2021,0xb6,
/* 0x81f8 - 0x81ff */ 0x0,0x0,0x0,0x0,0x20dd
}, /* 0x81 */

{ /* 0x82 */
/* 0x8240 - 0x8247 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8248 - 0x824f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff10,
/* 0x8250 - 0x8257 */ 0xff11,0xff12,0xff13,0xff14,0xff15,0xff16,0xff17,0xff18,
/* 0x8258 - 0x825f */ 0xff19,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8260 - 0x8267 */ 0xff21,0xff22,0xff23,0xff24,0xff25,0xff26,0xff27,0xff28,
/* 0x8268 - 0x826f */ 0xff29,0xff2a,0xff2b,0xff2c,0xff2d,0xff2e,0xff2f,0xff30,
/* 0x8270 - 0x8277 */ 0xff31,0xff32,0xff33,0xff34,0xff35,0xff36,0xff37,0xff38,
/* 0x8278 - 0x827f */ 0xff39,0xff3a,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8280 - 0x8287 */ 0x0,0xff41,0xff42,0xff43,0xff44,0xff45,0xff46,0xff47,
/* 0x8288 - 0x828f */ 0xff48,0xff49,0xff4a,0xff4b,0xff4c,0xff4d,0xff4e,0xff4f,
/* 0x8290 - 0x8297 */ 0xff50,0xff51,0xff52,0xff53,0xff54,0xff55,0xff56,0xff57,
/* 0x8298 - 0x829f */ 0xff58,0xff59,0xff5a,0x0,0x0,0x0,0x0,0x3041,
/* 0x82a0 - 0x82a7 */ 0x3042,0x3043,0x3044,0x3045,0x3046,0x3047,0x3048,0x3049,
/* 0x82a8 - 0x82af */ 0x304a,0x304b,0x304c,0x304d,0x304e,0x304f,0x3050,0x3051,
/* 0x82b0 - 0x82b7 */ 0x3052,0x3053,0x3054,0x3055,0x3056,0x3057,0x3058,0x3059,
/* 0x82b8 - 0x82bf */ 0x305a,0x305b,0x305c,0x305d,0x305e,0x305f,0x3060,0x3061,
/* 0x82c0 - 0x82c7 */ 0x3062,0x3063,0x3064,0x3065,0x3066,0x3067,0x3068,0x3069,
/* 0x82c8 - 0x82cf */ 0x306a,0x306b,0x306c,0x306d,0x306e,0x306f,0x3070,0x3071,
/* 0x82d0 - 0x82d7 */ 0x3072,0x3073,0x3074,0x3075,0x3076,0x3077,0x3078,0x3079,
/* 0x82d8 - 0x82df */ 0x307a,0x307b,0x307c,0x307d,0x307e,0x307f,0x3080,0x3081,
/* 0x82e0 - 0x82e7 */ 0x3082,0x3083,0x3084,0x3085,0x3086,0x3087,0x3088,0x3089,
/* 0x82e8 - 0x82ef */ 0x308a,0x308b,0x308c,0x308d,0x308e,0x308f,0x3090,0x3091,
/* 0x82f0 - 0x82f7 */ 0x3092,0x3093,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x82f8 - 0x82ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x82 */

{ /* 0x83 */
/* 0x8340 - 0x8347 */ 0x30a1,0x30a2,0x30a3,0x30a4,0x30a5,0x30a6,0x30a7,0x30a8,
/* 0x8348 - 0x834f */ 0x30a9,0x30aa,0x30ab,0x30ac,0x30ad,0x30ae,0x30af,0x30b0,
/* 0x8350 - 0x8357 */ 0x30b1,0x30b2,0x30b3,0x30b4,0x30b5,0x30b6,0x30b7,0x30b8,
/* 0x8358 - 0x835f */ 0x30b9,0x30ba,0x30bb,0x30bc,0x30bd,0x30be,0x30bf,0x30c0,
/* 0x8360 - 0x8367 */ 0x30c1,0x30c2,0x30c3,0x30c4,0x30c5,0x30c6,0x30c7,0x30c8,
/* 0x8368 - 0x836f */ 0x30c9,0x30ca,0x30cb,0x30cc,0x30cd,0x30ce,0x30cf,0x30d0,
/* 0x8370 - 0x8377 */ 0x30d1,0x30d2,0x30d3,0x30d4,0x30d5,0x30d6,0x30d7,0x30d8,
/* 0x8378 - 0x837f */ 0x30d9,0x30da,0x30db,0x30dc,0x30dd,0x30de,0x30df,0x0,
/* 0x8380 - 0x8387 */ 0x30e0,0x30e1,0x30e2,0x30e3,0x30e4,0x30e5,0x30e6,0x30e7,
/* 0x8388 - 0x838f */ 0x30e8,0x30e9,0x30ea,0x30eb,0x30ec,0x30ed,0x30ee,0x30ef,
/* 0x8390 - 0x8397 */ 0x30f0,0x30f1,0x30f2,0x30f3,0x30f4,0x30f5,0x30f6,0x0,
/* 0x8398 - 0x839f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x391,
/* 0x83a0 - 0x83a7 */ 0x392,0x393,0x394,0x395,0x396,0x397,0x398,0x399,
/* 0x83a8 - 0x83af */ 0x39a,0x39b,0x39c,0x39d,0x39e,0x39f,0x3a0,0x3a1,
/* 0x83b0 - 0x83b7 */ 0x3a3,0x3a4,0x3a5,0x3a6,0x3a7,0x3a8,0x3a9,0x0,
/* 0x83b8 - 0x83bf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3b1,
/* 0x83c0 - 0x83c7 */ 0x3b2,0x3b3,0x3b4,0x3b5,0x3b6,0x3b7,0x3b8,0x3b9,
/* 0x83c8 - 0x83cf */ 0x3ba,0x3bb,0x3bc,0x3bd,0x3be,0x3bf,0x3c0,0x3c1,
/* 0x83d0 - 0x83d7 */ 0x3c3,0x3c4,0x3c5,0x3c6,0x3c7,0x3c8,0x3c9,0x0,
/* 0x83d8 - 0x83df */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x83e0 - 0x83e7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x83e8 - 0x83ef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x83f0 - 0x83f7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x83f8 - 0x83ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x83 */

{ /* 0x84 */
/* 0x8440 - 0x8447 */ 0x410,0x411,0x412,0x413,0x414,0x415,0x401,0x416,
/* 0x8448 - 0x844f */ 0x417,0x418,0x419,0x41a,0x41b,0x41c,0x41d,0x41e,
/* 0x8450 - 0x8457 */ 0x41f,0x420,0x421,0x422,0x423,0x424,0x425,0x426,
/* 0x8458 - 0x845f */ 0x427,0x428,0x429,0x42a,0x42b,0x42c,0x42d,0x42e,
/* 0x8460 - 0x8467 */ 0x42f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8468 - 0x846f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8470 - 0x8477 */ 0x430,0x431,0x432,0x433,0x434,0x435,0x451,0x436,
/* 0x8478 - 0x847f */ 0x437,0x438,0x439,0x43a,0x43b,0x43c,0x43d,0x0,
/* 0x8480 - 0x8487 */ 0x43e,0x43f,0x440,0x441,0x442,0x443,0x444,0x445,
/* 0x8488 - 0x848f */ 0x446,0x447,0x448,0x449,0x44a,0x44b,0x44c,0x44d,
/* 0x8490 - 0x8497 */ 0x44e,0x44f,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8498 - 0x849f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2500,
/* 0x84a0 - 0x84a7 */ 0x2502,0x250c,0x2510,0x2518,0x2514,0x251c,0x252c,0x2524,
/* 0x84a8 - 0x84af */ 0x2534,0x253c,0x2501,0x2503,0x250f,0x2513,0x251b,0x2517,
/* 0x84b0 - 0x84b7 */ 0x2523,0x2533,0x252b,0x253b,0x254b,0x2520,0x252f,0x2528,
/* 0x84b8 - 0x84bf */ 0x2537,0x253f,0x251d,0x2530,0x2525,0x2538,0x2542,0x0,
/* 0x84c0 - 0x84c7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84c8 - 0x84cf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84d0 - 0x84d7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84d8 - 0x84df */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84e0 - 0x84e7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84e8 - 0x84ef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84f0 - 0x84f7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84f8 - 0x84ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x84 */

{ /* 0x85 */
/* 0x8540 - 0x8547 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8548 - 0x854f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8550 - 0x8557 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8558 - 0x855f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8560 - 0x8567 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8568 - 0x856f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8570 - 0x8577 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8578 - 0x857f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8580 - 0x8587 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8588 - 0x858f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8590 - 0x8597 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8598 - 0x859f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85a0 - 0x85a7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85a8 - 0x85af */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85b0 - 0x85b7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85b8 - 0x85bf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85c0 - 0x85c7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85c8 - 0x85cf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85d0 - 0x85d7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85d8 - 0x85df */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85e0 - 0x85e7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85e8 - 0x85ef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85f0 - 0x85f7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85f8 - 0x85ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x85 */

{ /* 0x86 */
/* 0x8640 - 0x8647 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8648 - 0x864f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8650 - 0x8657 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8658 - 0x865f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8660 - 0x8667 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8668 - 0x866f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8670 - 0x8677 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8678 - 0x867f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8680 - 0x8687 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8688 - 0x868f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8690 - 0x8697 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8698 - 0x869f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86a0 - 0x86a7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86a8 - 0x86af */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86b0 - 0x86b7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86b8 - 0x86bf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86c0 - 0x86c7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86c8 - 0x86cf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86d0 - 0x86d7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86d8 - 0x86df */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86e0 - 0x86e7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86e8 - 0x86ef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86f0 - 0x86f7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86f8 - 0x86ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x86 */

{ /* 0x87 */
/* 0x8740 - 0x8747 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8748 - 0x874f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8750 - 0x8757 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8758 - 0x875f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8760 - 0x8767 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8768 - 0x876f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8770 - 0x8777 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8778 - 0x877f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8780 - 0x8787 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8788 - 0x878f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8790 - 0x8797 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8798 - 0x879f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87a0 - 0x87a7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87a8 - 0x87af */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87b0 - 0x87b7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87b8 - 0x87bf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87c0 - 0x87c7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87c8 - 0x87cf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87d0 - 0x87d7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87d8 - 0x87df */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87e0 - 0x87e7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87e8 - 0x87ef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87f0 - 0x87f7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87f8 - 0x87ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x87 */

{ /* 0x88 */
/* 0x8840 - 0x8847 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8848 - 0x884f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8850 - 0x8857 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8858 - 0x885f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8860 - 0x8867 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8868 - 0x886f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8870 - 0x8877 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8878 - 0x887f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8880 - 0x8887 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8888 - 0x888f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8890 - 0x8897 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8898 - 0x889f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e9c,
/* 0x88a0 - 0x88a7 */ 0x5516,0x5a03,0x963f,0x54c0,0x611b,0x6328,0x59f6,0x9022,
/* 0x88a8 - 0x88af */ 0x8475,0x831c,0x7a50,0x60aa,0x63e1,0x6e25,0x65ed,0x8466,
/* 0x88b0 - 0x88b7 */ 0x82a6,0x9bf5,0x6893,0x5727,0x65a1,0x6271,0x5b9b,0x59d0,
/* 0x88b8 - 0x88bf */ 0x867b,0x98f4,0x7d62,0x7dbe,0x9b8e,0x6216,0x7c9f,0x88b7,
/* 0x88c0 - 0x88c7 */ 0x5b89,0x5eb5,0x6309,0x6697,0x6848,0x95c7,0x978d,0x674f,
/* 0x88c8 - 0x88cf */ 0x4ee5,0x4f0a,0x4f4d,0x4f9d,0x5049,0x56f2,0x5937,0x59d4,
/* 0x88d0 - 0x88d7 */ 0x5a01,0x5c09,0x60df,0x610f,0x6170,0x6613,0x6905,0x70ba,
/* 0x88d8 - 0x88df */ 0x754f,0x7570,0x79fb,0x7dad,0x7def,0x80c3,0x840e,0x8863,
/* 0x88e0 - 0x88e7 */ 0x8b02,0x9055,0x907a,0x533b,0x4e95,0x4ea5,0x57df,0x80b2,
/* 0x88e8 - 0x88ef */ 0x90c1,0x78ef,0x4e00,0x58f1,0x6ea2,0x9038,0x7a32,0x8328,
/* 0x88f0 - 0x88f7 */ 0x828b,0x9c2f,0x5141,0x5370,0x54bd,0x54e1,0x56e0,0x59fb,
/* 0x88f8 - 0x88ff */ 0x5f15,0x98f2,0x6deb,0x80e4,0x852d
}, /* 0x88 */

{ /* 0x89 */
/* 0x8940 - 0x8947 */ 0x9662,0x9670,0x96a0,0x97fb,0x540b,0x53f3,0x5b87,0x70cf,
/* 0x8948 - 0x894f */ 0x7fbd,0x8fc2,0x96e8,0x536f,0x9d5c,0x7aba,0x4e11,0x7893,
/* 0x8950 - 0x8957 */ 0x81fc,0x6e26,0x5618,0x5504,0x6b1d,0x851a,0x9c3b,0x59e5,
/* 0x8958 - 0x895f */ 0x53a9,0x6d66,0x74dc,0x958f,0x5642,0x4e91,0x904b,0x96f2,
/* 0x8960 - 0x8967 */ 0x834f,0x990c,0x53e1,0x55b6,0x5b30,0x5f71,0x6620,0x66f3,
/* 0x8968 - 0x896f */ 0x6804,0x6c38,0x6cf3,0x6d29,0x745b,0x76c8,0x7a4e,0x9834,
/* 0x8970 - 0x8977 */ 0x82f1,0x885b,0x8a60,0x92ed,0x6db2,0x75ab,0x76ca,0x99c5,
/* 0x8978 - 0x897f */ 0x60a6,0x8b01,0x8d8a,0x95b2,0x698e,0x53ad,0x5186,0x0,
/* 0x8980 - 0x8987 */ 0x5712,0x5830,0x5944,0x5bb4,0x5ef6,0x6028,0x63a9,0x63f4,
/* 0x8988 - 0x898f */ 0x6cbf,0x6f14,0x708e,0x7114,0x7159,0x71d5,0x733f,0x7e01,
/* 0x8990 - 0x8997 */ 0x8276,0x82d1,0x8597,0x9060,0x925b,0x9d1b,0x5869,0x65bc,
/* 0x8998 - 0x899f */ 0x6c5a,0x7525,0x51f9,0x592e,0x5965,0x5f80,0x5fdc,0x62bc,
/* 0x89a0 - 0x89a7 */ 0x65fa,0x6a2a,0x6b27,0x6bb4,0x738b,0x7fc1,0x8956,0x9d2c,
/* 0x89a8 - 0x89af */ 0x9d0e,0x9ec4,0x5ca1,0x6c96,0x837b,0x5104,0x5c4b,0x61b6,
/* 0x89b0 - 0x89b7 */ 0x81c6,0x6876,0x7261,0x4e59,0x4ffa,0x5378,0x6069,0x6e29,
/* 0x89b8 - 0x89bf */ 0x7a4f,0x97f3,0x4e0b,0x5316,0x4eee,0x4f55,0x4f3d,0x4fa1,
/* 0x89c0 - 0x89c7 */ 0x4f73,0x52a0,0x53ef,0x5609,0x590f,0x5ac1,0x5bb6,0x5be1,
/* 0x89c8 - 0x89cf */ 0x79d1,0x6687,0x679c,0x67b6,0x6b4c,0x6cb3,0x706b,0x73c2,
/* 0x89d0 - 0x89d7 */ 0x798d,0x79be,0x7a3c,0x7b87,0x82b1,0x82db,0x8304,0x8377,
/* 0x89d8 - 0x89df */ 0x83ef,0x83d3,0x8766,0x8ab2,0x5629,0x8ca8,0x8fe6,0x904e,
/* 0x89e0 - 0x89e7 */ 0x971e,0x868a,0x4fc4,0x5ce8,0x6211,0x7259,0x753b,0x81e5,
/* 0x89e8 - 0x89ef */ 0x82bd,0x86fe,0x8cc0,0x96c5,0x9913,0x99d5,0x4ecb,0x4f1a,
/* 0x89f0 - 0x89f7 */ 0x89e3,0x56de,0x584a,0x58ca,0x5efb,0x5feb,0x602a,0x6094,
/* 0x89f8 - 0x89ff */ 0x6062,0x61d0,0x6212,0x62d0,0x6539
}, /* 0x89 */

{ /* 0x8a */
/* 0x8a40 - 0x8a47 */ 0x9b41,0x6666,0x68b0,0x6d77,0x7070,0x754c,0x7686,0x7d75,
/* 0x8a48 - 0x8a4f */ 0x82a5,0x87f9,0x958b,0x968e,0x8c9d,0x51f1,0x52be,0x5916,
/* 0x8a50 - 0x8a57 */ 0x54b3,0x5bb3,0x5d16,0x6168,0x6982,0x6daf,0x788d,0x84cb,
/* 0x8a58 - 0x8a5f */ 0x8857,0x8a72,0x93a7,0x9ab8,0x6d6c,0x99a8,0x86d9,0x57a3,
/* 0x8a60 - 0x8a67 */ 0x67ff,0x86ce,0x920e,0x5283,0x5687,0x5404,0x5ed3,0x62e1,
/* 0x8a68 - 0x8a6f */ 0x64b9,0x683c,0x6838,0x6bbb,0x7372,0x78ba,0x7a6b,0x899a,
/* 0x8a70 - 0x8a77 */ 0x89d2,0x8d6b,0x8f03,0x90ed,0x95a3,0x9694,0x9769,0x5b66,
/* 0x8a78 - 0x8a7f */ 0x5cb3,0x697d,0x984d,0x984e,0x639b,0x7b20,0x6a2b,0x0,
/* 0x8a80 - 0x8a87 */ 0x6a7f,0x68b6,0x9c0d,0x6f5f,0x5272,0x559d,0x6070,0x62ec,
/* 0x8a88 - 0x8a8f */ 0x6d3b,0x6e07,0x6ed1,0x845b,0x8910,0x8f44,0x4e14,0x9c39,
/* 0x8a90 - 0x8a97 */ 0x53f6,0x691b,0x6a3a,0x9784,0x682a,0x515c,0x7ac3,0x84b2,
/* 0x8a98 - 0x8a9f */ 0x91dc,0x938c,0x565b,0x9d28,0x6822,0x8305,0x8431,0x7ca5,
/* 0x8aa0 - 0x8aa7 */ 0x5208,0x82c5,0x74e6,0x4e7e,0x4f83,0x51a0,0x5bd2,0x520a,
/* 0x8aa8 - 0x8aaf */ 0x52d8,0x52e7,0x5dfb,0x559a,0x582a,0x59e6,0x5b8c,0x5b98,
/* 0x8ab0 - 0x8ab7 */ 0x5bdb,0x5e72,0x5e79,0x60a3,0x611f,0x6163,0x61be,0x63db,
/* 0x8ab8 - 0x8abf */ 0x6562,0x67d1,0x6853,0x68fa,0x6b3e,0x6b53,0x6c57,0x6f22,
/* 0x8ac0 - 0x8ac7 */ 0x6f97,0x6f45,0x74b0,0x7518,0x76e3,0x770b,0x7aff,0x7ba1,
/* 0x8ac8 - 0x8acf */ 0x7c21,0x7de9,0x7f36,0x7ff0,0x809d,0x8266,0x839e,0x89b3,
/* 0x8ad0 - 0x8ad7 */ 0x8acc,0x8cab,0x9084,0x9451,0x9593,0x9591,0x95a2,0x9665,
/* 0x8ad8 - 0x8adf */ 0x97d3,0x9928,0x8218,0x4e38,0x542b,0x5cb8,0x5dcc,0x73a9,
/* 0x8ae0 - 0x8ae7 */ 0x764c,0x773c,0x5ca9,0x7feb,0x8d0b,0x96c1,0x9811,0x9854,
/* 0x8ae8 - 0x8aef */ 0x9858,0x4f01,0x4f0e,0x5371,0x559c,0x5668,0x57fa,0x5947,
/* 0x8af0 - 0x8af7 */ 0x5b09,0x5bc4,0x5c90,0x5e0c,0x5e7e,0x5fcc,0x63ee,0x673a,
/* 0x8af8 - 0x8aff */ 0x65d7,0x65e2,0x671f,0x68cb,0x68c4
}, /* 0x8a */

{ /* 0x8b */
/* 0x8b40 - 0x8b47 */ 0x6a5f,0x5e30,0x6bc5,0x6c17,0x6c7d,0x757f,0x7948,0x5b63,
/* 0x8b48 - 0x8b4f */ 0x7a00,0x7d00,0x5fbd,0x898f,0x8a18,0x8cb4,0x8d77,0x8ecc,
/* 0x8b50 - 0x8b57 */ 0x8f1d,0x98e2,0x9a0e,0x9b3c,0x4e80,0x507d,0x5100,0x5993,
/* 0x8b58 - 0x8b5f */ 0x5b9c,0x622f,0x6280,0x64ec,0x6b3a,0x72a0,0x7591,0x7947,
/* 0x8b60 - 0x8b67 */ 0x7fa9,0x87fb,0x8abc,0x8b70,0x63ac,0x83ca,0x97a0,0x5409,
/* 0x8b68 - 0x8b6f */ 0x5403,0x55ab,0x6854,0x6a58,0x8a70,0x7827,0x6775,0x9ecd,
/* 0x8b70 - 0x8b77 */ 0x5374,0x5ba2,0x811a,0x8650,0x9006,0x4e18,0x4e45,0x4ec7,
/* 0x8b78 - 0x8b7f */ 0x4f11,0x53ca,0x5438,0x5bae,0x5f13,0x6025,0x6551,0x0,
/* 0x8b80 - 0x8b87 */ 0x673d,0x6c42,0x6c72,0x6ce3,0x7078,0x7403,0x7a76,0x7aae,
/* 0x8b88 - 0x8b8f */ 0x7b08,0x7d1a,0x7cfe,0x7d66,0x65e7,0x725b,0x53bb,0x5c45,
/* 0x8b90 - 0x8b97 */ 0x5de8,0x62d2,0x62e0,0x6319,0x6e20,0x865a,0x8a31,0x8ddd,
/* 0x8b98 - 0x8b9f */ 0x92f8,0x6f01,0x79a6,0x9b5a,0x4ea8,0x4eab,0x4eac,0x4f9b,
/* 0x8ba0 - 0x8ba7 */ 0x4fa0,0x50d1,0x5147,0x7af6,0x5171,0x51f6,0x5354,0x5321,
/* 0x8ba8 - 0x8baf */ 0x537f,0x53eb,0x55ac,0x5883,0x5ce1,0x5f37,0x5f4a,0x602f,
/* 0x8bb0 - 0x8bb7 */ 0x6050,0x606d,0x631f,0x6559,0x6a4b,0x6cc1,0x72c2,0x72ed,
/* 0x8bb8 - 0x8bbf */ 0x77ef,0x80f8,0x8105,0x8208,0x854e,0x90f7,0x93e1,0x97ff,
/* 0x8bc0 - 0x8bc7 */ 0x9957,0x9a5a,0x4ef0,0x51dd,0x5c2d,0x6681,0x696d,0x5c40,
/* 0x8bc8 - 0x8bcf */ 0x66f2,0x6975,0x7389,0x6850,0x7c81,0x50c5,0x52e4,0x5747,
/* 0x8bd0 - 0x8bd7 */ 0x5dfe,0x9326,0x65a4,0x6b23,0x6b3d,0x7434,0x7981,0x79bd,
/* 0x8bd8 - 0x8bdf */ 0x7b4b,0x7dca,0x82b9,0x83cc,0x887f,0x895f,0x8b39,0x8fd1,
/* 0x8be0 - 0x8be7 */ 0x91d1,0x541f,0x9280,0x4e5d,0x5036,0x53e5,0x533a,0x72d7,
/* 0x8be8 - 0x8bef */ 0x7396,0x77e9,0x82e6,0x8eaf,0x99c6,0x99c8,0x99d2,0x5177,
/* 0x8bf0 - 0x8bf7 */ 0x611a,0x865e,0x55b0,0x7a7a,0x5076,0x5bd3,0x9047,0x9685,
/* 0x8bf8 - 0x8bff */ 0x4e32,0x6adb,0x91e7,0x5c51,0x5c48
}, /* 0x8b */

{ /* 0x8c */
/* 0x8c40 - 0x8c47 */ 0x6398,0x7a9f,0x6c93,0x9774,0x8f61,0x7aaa,0x718a,0x9688,
/* 0x8c48 - 0x8c4f */ 0x7c82,0x6817,0x7e70,0x6851,0x936c,0x52f2,0x541b,0x85ab,
/* 0x8c50 - 0x8c57 */ 0x8a13,0x7fa4,0x8ecd,0x90e1,0x5366,0x8888,0x7941,0x4fc2,
/* 0x8c58 - 0x8c5f */ 0x50be,0x5211,0x5144,0x5553,0x572d,0x73ea,0x578b,0x5951,
/* 0x8c60 - 0x8c67 */ 0x5f62,0x5f84,0x6075,0x6176,0x6167,0x61a9,0x63b2,0x643a,
/* 0x8c68 - 0x8c6f */ 0x656c,0x666f,0x6842,0x6e13,0x7566,0x7a3d,0x7cfb,0x7d4c,
/* 0x8c70 - 0x8c77 */ 0x7d99,0x7e4b,0x7f6b,0x830e,0x834a,0x86cd,0x8a08,0x8a63,
/* 0x8c78 - 0x8c7f */ 0x8b66,0x8efd,0x981a,0x9d8f,0x82b8,0x8fce,0x9be8,0x0,
/* 0x8c80 - 0x8c87 */ 0x5287,0x621f,0x6483,0x6fc0,0x9699,0x6841,0x5091,0x6b20,
/* 0x8c88 - 0x8c8f */ 0x6c7a,0x6f54,0x7a74,0x7d50,0x8840,0x8a23,0x6708,0x4ef6,
/* 0x8c90 - 0x8c97 */ 0x5039,0x5026,0x5065,0x517c,0x5238,0x5263,0x55a7,0x570f,
/* 0x8c98 - 0x8c9f */ 0x5805,0x5acc,0x5efa,0x61b2,0x61f8,0x62f3,0x6372,0x691c,
/* 0x8ca0 - 0x8ca7 */ 0x6a29,0x727d,0x72ac,0x732e,0x7814,0x786f,0x7d79,0x770c,
/* 0x8ca8 - 0x8caf */ 0x80a9,0x898b,0x8b19,0x8ce2,0x8ed2,0x9063,0x9375,0x967a,
/* 0x8cb0 - 0x8cb7 */ 0x9855,0x9a13,0x9e78,0x5143,0x539f,0x53b3,0x5e7b,0x5f26,
/* 0x8cb8 - 0x8cbf */ 0x6e1b,0x6e90,0x7384,0x73fe,0x7d43,0x8237,0x8a00,0x8afa,
/* 0x8cc0 - 0x8cc7 */ 0x9650,0x4e4e,0x500b,0x53e4,0x547c,0x56fa,0x59d1,0x5b64,
/* 0x8cc8 - 0x8ccf */ 0x5df1,0x5eab,0x5f27,0x6238,0x6545,0x67af,0x6e56,0x72d0,
/* 0x8cd0 - 0x8cd7 */ 0x7cca,0x88b4,0x80a1,0x80e1,0x83f0,0x864e,0x8a87,0x8de8,
/* 0x8cd8 - 0x8cdf */ 0x9237,0x96c7,0x9867,0x9f13,0x4e94,0x4e92,0x4f0d,0x5348,
/* 0x8ce0 - 0x8ce7 */ 0x5449,0x543e,0x5a2f,0x5f8c,0x5fa1,0x609f,0x68a7,0x6a8e,
/* 0x8ce8 - 0x8cef */ 0x745a,0x7881,0x8a9e,0x8aa4,0x8b77,0x9190,0x4e5e,0x9bc9,
/* 0x8cf0 - 0x8cf7 */ 0x4ea4,0x4f7c,0x4faf,0x5019,0x5016,0x5149,0x516c,0x529f,
/* 0x8cf8 - 0x8cff */ 0x52b9,0x52fe,0x539a,0x53e3,0x5411
}, /* 0x8c */

{ /* 0x8d */
/* 0x8d40 - 0x8d47 */ 0x540e,0x5589,0x5751,0x57a2,0x597d,0x5b54,0x5b5d,0x5b8f,
/* 0x8d48 - 0x8d4f */ 0x5de5,0x5de7,0x5df7,0x5e78,0x5e83,0x5e9a,0x5eb7,0x5f18,
/* 0x8d50 - 0x8d57 */ 0x6052,0x614c,0x6297,0x62d8,0x63a7,0x653b,0x6602,0x6643,
/* 0x8d58 - 0x8d5f */ 0x66f4,0x676d,0x6821,0x6897,0x69cb,0x6c5f,0x6d2a,0x6d69,
/* 0x8d60 - 0x8d67 */ 0x6e2f,0x6e9d,0x7532,0x7687,0x786c,0x7a3f,0x7ce0,0x7d05,
/* 0x8d68 - 0x8d6f */ 0x7d18,0x7d5e,0x7db1,0x8015,0x8003,0x80af,0x80b1,0x8154,
/* 0x8d70 - 0x8d77 */ 0x818f,0x822a,0x8352,0x884c,0x8861,0x8b1b,0x8ca2,0x8cfc,
/* 0x8d78 - 0x8d7f */ 0x90ca,0x9175,0x9271,0x783f,0x92fc,0x95a4,0x964d,0x0,
/* 0x8d80 - 0x8d87 */ 0x9805,0x9999,0x9ad8,0x9d3b,0x525b,0x52ab,0x53f7,0x5408,
/* 0x8d88 - 0x8d8f */ 0x58d5,0x62f7,0x6fe0,0x8c6a,0x8f5f,0x9eb9,0x514b,0x523b,
/* 0x8d90 - 0x8d97 */ 0x544a,0x56fd,0x7a40,0x9177,0x9d60,0x9ed2,0x7344,0x6f09,
/* 0x8d98 - 0x8d9f */ 0x8170,0x7511,0x5ffd,0x60da,0x9aa8,0x72db,0x8fbc,0x6b64,
/* 0x8da0 - 0x8da7 */ 0x9803,0x4eca,0x56f0,0x5764,0x58be,0x5a5a,0x6068,0x61c7,
/* 0x8da8 - 0x8daf */ 0x660f,0x6606,0x6839,0x68b1,0x6df7,0x75d5,0x7d3a,0x826e,
/* 0x8db0 - 0x8db7 */ 0x9b42,0x4e9b,0x4f50,0x53c9,0x5506,0x5d6f,0x5de6,0x5dee,
/* 0x8db8 - 0x8dbf */ 0x67fb,0x6c99,0x7473,0x7802,0x8a50,0x9396,0x88df,0x5750,
/* 0x8dc0 - 0x8dc7 */ 0x5ea7,0x632b,0x50b5,0x50ac,0x518d,0x6700,0x54c9,0x585e,
/* 0x8dc8 - 0x8dcf */ 0x59bb,0x5bb0,0x5f69,0x624d,0x63a1,0x683d,0x6b73,0x6e08,
/* 0x8dd0 - 0x8dd7 */ 0x707d,0x91c7,0x7280,0x7815,0x7826,0x796d,0x658e,0x7d30,
/* 0x8dd8 - 0x8ddf */ 0x83dc,0x88c1,0x8f09,0x969b,0x5264,0x5728,0x6750,0x7f6a,
/* 0x8de0 - 0x8de7 */ 0x8ca1,0x51b4,0x5742,0x962a,0x583a,0x698a,0x80b4,0x54b2,
/* 0x8de8 - 0x8def */ 0x5d0e,0x57fc,0x7895,0x9dfa,0x4f5c,0x524a,0x548b,0x643e,
/* 0x8df0 - 0x8df7 */ 0x6628,0x6714,0x67f5,0x7a84,0x7b56,0x7d22,0x932f,0x685c,
/* 0x8df8 - 0x8dff */ 0x9bad,0x7b39,0x5319,0x518a,0x5237
}, /* 0x8d */

{ /* 0x8e */
/* 0x8e40 - 0x8e47 */ 0x5bdf,0x62f6,0x64ae,0x64e6,0x672d,0x6bba,0x85a9,0x96d1,
/* 0x8e48 - 0x8e4f */ 0x7690,0x9bd6,0x634c,0x9306,0x9bab,0x76bf,0x6652,0x4e09,
/* 0x8e50 - 0x8e57 */ 0x5098,0x53c2,0x5c71,0x60e8,0x6492,0x6563,0x685f,0x71e6,
/* 0x8e58 - 0x8e5f */ 0x73ca,0x7523,0x7b97,0x7e82,0x8695,0x8b83,0x8cdb,0x9178,
/* 0x8e60 - 0x8e67 */ 0x9910,0x65ac,0x66ab,0x6b8b,0x4ed5,0x4ed4,0x4f3a,0x4f7f,
/* 0x8e68 - 0x8e6f */ 0x523a,0x53f8,0x53f2,0x55e3,0x56db,0x58eb,0x59cb,0x59c9,
/* 0x8e70 - 0x8e77 */ 0x59ff,0x5b50,0x5c4d,0x5e02,0x5e2b,0x5fd7,0x601d,0x6307,
/* 0x8e78 - 0x8e7f */ 0x652f,0x5b5c,0x65af,0x65bd,0x65e8,0x679d,0x6b62,0x0,
/* 0x8e80 - 0x8e87 */ 0x6b7b,0x6c0f,0x7345,0x7949,0x79c1,0x7cf8,0x7d19,0x7d2b,
/* 0x8e88 - 0x8e8f */ 0x80a2,0x8102,0x81f3,0x8996,0x8a5e,0x8a69,0x8a66,0x8a8c,
/* 0x8e90 - 0x8e97 */ 0x8aee,0x8cc7,0x8cdc,0x96cc,0x98fc,0x6b6f,0x4e8b,0x4f3c,
/* 0x8e98 - 0x8e9f */ 0x4f8d,0x5150,0x5b57,0x5bfa,0x6148,0x6301,0x6642,0x6b21,
/* 0x8ea0 - 0x8ea7 */ 0x6ecb,0x6cbb,0x723e,0x74bd,0x75d4,0x78c1,0x793a,0x800c,
/* 0x8ea8 - 0x8eaf */ 0x8033,0x81ea,0x8494,0x8f9e,0x6c50,0x9e7f,0x5f0f,0x8b58,
/* 0x8eb0 - 0x8eb7 */ 0x9d2b,0x7afa,0x8ef8,0x5b8d,0x96eb,0x4e03,0x53f1,0x57f7,
/* 0x8eb8 - 0x8ebf */ 0x5931,0x5ac9,0x5ba4,0x6089,0x6e7f,0x6f06,0x75be,0x8cea,
/* 0x8ec0 - 0x8ec7 */ 0x5b9f,0x8500,0x7be0,0x5072,0x67f4,0x829d,0x5c61,0x854a,
/* 0x8ec8 - 0x8ecf */ 0x7e1e,0x820e,0x5199,0x5c04,0x6368,0x8d66,0x659c,0x716e,
/* 0x8ed0 - 0x8ed7 */ 0x793e,0x7d17,0x8005,0x8b1d,0x8eca,0x906e,0x86c7,0x90aa,
/* 0x8ed8 - 0x8edf */ 0x501f,0x52fa,0x5c3a,0x6753,0x707c,0x7235,0x914c,0x91c8,
/* 0x8ee0 - 0x8ee7 */ 0x932b,0x82e5,0x5bc2,0x5f31,0x60f9,0x4e3b,0x53d6,0x5b88,
/* 0x8ee8 - 0x8eef */ 0x624b,0x6731,0x6b8a,0x72e9,0x73e0,0x7a2e,0x816b,0x8da3,
/* 0x8ef0 - 0x8ef7 */ 0x9152,0x9996,0x5112,0x53d7,0x546a,0x5bff,0x6388,0x6a39,
/* 0x8ef8 - 0x8eff */ 0x7dac,0x9700,0x56da,0x53ce,0x5468
}, /* 0x8e */

{ /* 0x8f */
/* 0x8f40 - 0x8f47 */ 0x5b97,0x5c31,0x5dde,0x4fee,0x6101,0x62fe,0x6d32,0x79c0,
/* 0x8f48 - 0x8f4f */ 0x79cb,0x7d42,0x7e4d,0x7fd2,0x81ed,0x821f,0x8490,0x8846,
/* 0x8f50 - 0x8f57 */ 0x8972,0x8b90,0x8e74,0x8f2f,0x9031,0x914b,0x916c,0x96c6,
/* 0x8f58 - 0x8f5f */ 0x919c,0x4ec0,0x4f4f,0x5145,0x5341,0x5f93,0x620e,0x67d4,
/* 0x8f60 - 0x8f67 */ 0x6c41,0x6e0b,0x7363,0x7e26,0x91cd,0x9283,0x53d4,0x5919,
/* 0x8f68 - 0x8f6f */ 0x5bbf,0x6dd1,0x795d,0x7e2e,0x7c9b,0x587e,0x719f,0x51fa,
/* 0x8f70 - 0x8f77 */ 0x8853,0x8ff0,0x4fca,0x5cfb,0x6625,0x77ac,0x7ae3,0x821c,
/* 0x8f78 - 0x8f7f */ 0x99ff,0x51c6,0x5faa,0x65ec,0x696f,0x6b89,0x6df3,0x0,
/* 0x8f80 - 0x8f87 */ 0x6e96,0x6f64,0x76fe,0x7d14,0x5de1,0x9075,0x9187,0x9806,
/* 0x8f88 - 0x8f8f */ 0x51e6,0x521d,0x6240,0x6691,0x66d9,0x6e1a,0x5eb6,0x7dd2,
/* 0x8f90 - 0x8f97 */ 0x7f72,0x66f8,0x85af,0x85f7,0x8af8,0x52a9,0x53d9,0x5973,
/* 0x8f98 - 0x8f9f */ 0x5e8f,0x5f90,0x6055,0x92e4,0x9664,0x50b7,0x511f,0x52dd,
/* 0x8fa0 - 0x8fa7 */ 0x5320,0x5347,0x53ec,0x54e8,0x5546,0x5531,0x5617,0x5968,
/* 0x8fa8 - 0x8faf */ 0x59be,0x5a3c,0x5bb5,0x5c06,0x5c0f,0x5c11,0x5c1a,0x5e84,
/* 0x8fb0 - 0x8fb7 */ 0x5e8a,0x5ee0,0x5f70,0x627f,0x6284,0x62db,0x638c,0x6377,
/* 0x8fb8 - 0x8fbf */ 0x6607,0x660c,0x662d,0x6676,0x677e,0x68a2,0x6a1f,0x6a35,
/* 0x8fc0 - 0x8fc7 */ 0x6cbc,0x6d88,0x6e09,0x6e58,0x713c,0x7126,0x7167,0x75c7,
/* 0x8fc8 - 0x8fcf */ 0x7701,0x785d,0x7901,0x7965,0x79f0,0x7ae0,0x7b11,0x7ca7,
/* 0x8fd0 - 0x8fd7 */ 0x7d39,0x8096,0x83d6,0x848b,0x8549,0x885d,0x88f3,0x8a1f,
/* 0x8fd8 - 0x8fdf */ 0x8a3c,0x8a54,0x8a73,0x8c61,0x8cde,0x91a4,0x9266,0x937e,
/* 0x8fe0 - 0x8fe7 */ 0x9418,0x969c,0x9798,0x4e0a,0x4e08,0x4e1e,0x4e57,0x5197,
/* 0x8fe8 - 0x8fef */ 0x5270,0x57ce,0x5834,0x58cc,0x5b22,0x5e38,0x60c5,0x64fe,
/* 0x8ff0 - 0x8ff7 */ 0x6761,0x6756,0x6d44,0x72b6,0x7573,0x7a63,0x84b8,0x8b72,
/* 0x8ff8 - 0x8fff */ 0x91b8,0x9320,0x5631,0x57f4,0x98fe
}, /* 0x8f */

{ /* 0x90 */
/* 0x9040 - 0x9047 */ 0x62ed,0x690d,0x6b96,0x71ed,0x7e54,0x8077,0x8272,0x89e6,
/* 0x9048 - 0x904f */ 0x98df,0x8755,0x8fb1,0x5c3b,0x4f38,0x4fe1,0x4fb5,0x5507,
/* 0x9050 - 0x9057 */ 0x5a20,0x5bdd,0x5be9,0x5fc3,0x614e,0x632f,0x65b0,0x664b,
/* 0x9058 - 0x905f */ 0x68ee,0x699b,0x6d78,0x6df1,0x7533,0x75b9,0x771f,0x795e,
/* 0x9060 - 0x9067 */ 0x79e6,0x7d33,0x81e3,0x82af,0x85aa,0x89aa,0x8a3a,0x8eab,
/* 0x9068 - 0x906f */ 0x8f9b,0x9032,0x91dd,0x9707,0x4eba,0x4ec1,0x5203,0x5875,
/* 0x9070 - 0x9077 */ 0x58ec,0x5c0b,0x751a,0x5c3d,0x814e,0x8a0a,0x8fc5,0x9663,
/* 0x9078 - 0x907f */ 0x976d,0x7b25,0x8acf,0x9808,0x9162,0x56f3,0x53a8,0x0,
/* 0x9080 - 0x9087 */ 0x9017,0x5439,0x5782,0x5e25,0x63a8,0x6c34,0x708a,0x7761,
/* 0x9088 - 0x908f */ 0x7c8b,0x7fe0,0x8870,0x9042,0x9154,0x9310,0x9318,0x968f,
/* 0x9090 - 0x9097 */ 0x745e,0x9ac4,0x5d07,0x5d69,0x6570,0x67a2,0x8da8,0x96db,
/* 0x9098 - 0x909f */ 0x636e,0x6749,0x6919,0x83c5,0x9817,0x96c0,0x88fe,0x6f84,
/* 0x90a0 - 0x90a7 */ 0x647a,0x5bf8,0x4e16,0x702c,0x755d,0x662f,0x51c4,0x5236,
/* 0x90a8 - 0x90af */ 0x52e2,0x59d3,0x5f81,0x6027,0x6210,0x653f,0x6574,0x661f,
/* 0x90b0 - 0x90b7 */ 0x6674,0x68f2,0x6816,0x6b63,0x6e05,0x7272,0x751f,0x76db,
/* 0x90b8 - 0x90bf */ 0x7cbe,0x8056,0x58f0,0x88fd,0x897f,0x8aa0,0x8a93,0x8acb,
/* 0x90c0 - 0x90c7 */ 0x901d,0x9192,0x9752,0x9759,0x6589,0x7a0e,0x8106,0x96bb,
/* 0x90c8 - 0x90cf */ 0x5e2d,0x60dc,0x621a,0x65a5,0x6614,0x6790,0x77f3,0x7a4d,
/* 0x90d0 - 0x90d7 */ 0x7c4d,0x7e3e,0x810a,0x8cac,0x8d64,0x8de1,0x8e5f,0x78a9,
/* 0x90d8 - 0x90df */ 0x5207,0x62d9,0x63a5,0x6442,0x6298,0x8a2d,0x7a83,0x7bc0,
/* 0x90e0 - 0x90e7 */ 0x8aac,0x96ea,0x7d76,0x820c,0x8749,0x4ed9,0x5148,0x5343,
/* 0x90e8 - 0x90ef */ 0x5360,0x5ba3,0x5c02,0x5c16,0x5ddd,0x6226,0x6247,0x64b0,
/* 0x90f0 - 0x90f7 */ 0x6813,0x6834,0x6cc9,0x6d45,0x6d17,0x67d3,0x6f5c,0x714e,
/* 0x90f8 - 0x90ff */ 0x717d,0x65cb,0x7a7f,0x7bad,0x7dda
}, /* 0x90 */

{ /* 0x91 */
/* 0x9140 - 0x9147 */ 0x7e4a,0x7fa8,0x817a,0x821b,0x8239,0x85a6,0x8a6e,0x8cce,
/* 0x9148 - 0x914f */ 0x8df5,0x9078,0x9077,0x92ad,0x9291,0x9583,0x9bae,0x524d,
/* 0x9150 - 0x9157 */ 0x5584,0x6f38,0x7136,0x5168,0x7985,0x7e55,0x81b3,0x7cce,
/* 0x9158 - 0x915f */ 0x564c,0x5851,0x5ca8,0x63aa,0x66fe,0x66fd,0x695a,0x72d9,
/* 0x9160 - 0x9167 */ 0x758f,0x758e,0x790e,0x7956,0x79df,0x7c97,0x7d20,0x7d44,
/* 0x9168 - 0x916f */ 0x8607,0x8a34,0x963b,0x9061,0x9f20,0x50e7,0x5275,0x53cc,
/* 0x9170 - 0x9177 */ 0x53e2,0x5009,0x55aa,0x58ee,0x594f,0x723d,0x5b8b,0x5c64,
/* 0x9178 - 0x917f */ 0x531d,0x60e3,0x60f3,0x635c,0x6383,0x633f,0x63bb,0x0,
/* 0x9180 - 0x9187 */ 0x64cd,0x65e9,0x66f9,0x5de3,0x69cd,0x69fd,0x6f15,0x71e5,
/* 0x9188 - 0x918f */ 0x4e89,0x75e9,0x76f8,0x7a93,0x7cdf,0x7dcf,0x7d9c,0x8061,
/* 0x9190 - 0x9197 */ 0x8349,0x8358,0x846c,0x84bc,0x85fb,0x88c5,0x8d70,0x9001,
/* 0x9198 - 0x919f */ 0x906d,0x9397,0x971c,0x9a12,0x50cf,0x5897,0x618e,0x81d3,
/* 0x91a0 - 0x91a7 */ 0x8535,0x8d08,0x9020,0x4fc3,0x5074,0x5247,0x5373,0x606f,
/* 0x91a8 - 0x91af */ 0x6349,0x675f,0x6e2c,0x8db3,0x901f,0x4fd7,0x5c5e,0x8cca,
/* 0x91b0 - 0x91b7 */ 0x65cf,0x7d9a,0x5352,0x8896,0x5176,0x63c3,0x5b58,0x5b6b,
/* 0x91b8 - 0x91bf */ 0x5c0a,0x640d,0x6751,0x905c,0x4ed6,0x591a,0x592a,0x6c70,
/* 0x91c0 - 0x91c7 */ 0x8a51,0x553e,0x5815,0x59a5,0x60f0,0x6253,0x67c1,0x8235,
/* 0x91c8 - 0x91cf */ 0x6955,0x9640,0x99c4,0x9a28,0x4f53,0x5806,0x5bfe,0x8010,
/* 0x91d0 - 0x91d7 */ 0x5cb1,0x5e2f,0x5f85,0x6020,0x614b,0x6234,0x66ff,0x6cf0,
/* 0x91d8 - 0x91df */ 0x6ede,0x80ce,0x817f,0x82d4,0x888b,0x8cb8,0x9000,0x902e,
/* 0x91e0 - 0x91e7 */ 0x968a,0x9edb,0x9bdb,0x4ee3,0x53f0,0x5927,0x7b2c,0x918d,
/* 0x91e8 - 0x91ef */ 0x984c,0x9df9,0x6edd,0x7027,0x5353,0x5544,0x5b85,0x6258,
/* 0x91f0 - 0x91f7 */ 0x629e,0x62d3,0x6ca2,0x6fef,0x7422,0x8a17,0x9438,0x6fc1,
/* 0x91f8 - 0x91ff */ 0x8afe,0x8338,0x51e7,0x86f8,0x53ea
}, /* 0x91 */

{ /* 0x92 */
/* 0x9240 - 0x9247 */ 0x53e9,0x4f46,0x9054,0x8fb0,0x596a,0x8131,0x5dfd,0x7aea,
/* 0x9248 - 0x924f */ 0x8fbf,0x68da,0x8c37,0x72f8,0x9c48,0x6a3d,0x8ab0,0x4e39,
/* 0x9250 - 0x9257 */ 0x5358,0x5606,0x5766,0x62c5,0x63a2,0x65e6,0x6b4e,0x6de1,
/* 0x9258 - 0x925f */ 0x6e5b,0x70ad,0x77ed,0x7aef,0x7baa,0x7dbb,0x803d,0x80c6,
/* 0x9260 - 0x9267 */ 0x86cb,0x8a95,0x935b,0x56e3,0x58c7,0x5f3e,0x65ad,0x6696,
/* 0x9268 - 0x926f */ 0x6a80,0x6bb5,0x7537,0x8ac7,0x5024,0x77e5,0x5730,0x5f1b,
/* 0x9270 - 0x9277 */ 0x6065,0x667a,0x6c60,0x75f4,0x7a1a,0x7f6e,0x81f4,0x8718,
/* 0x9278 - 0x927f */ 0x9045,0x99b3,0x7bc9,0x755c,0x7af9,0x7b51,0x84c4,0x0,
/* 0x9280 - 0x9287 */ 0x9010,0x79e9,0x7a92,0x8336,0x5ae1,0x7740,0x4e2d,0x4ef2,
/* 0x9288 - 0x928f */ 0x5b99,0x5fe0,0x62bd,0x663c,0x67f1,0x6ce8,0x866b,0x8877,
/* 0x9290 - 0x9297 */ 0x8a3b,0x914e,0x92f3,0x99d0,0x6a17,0x7026,0x732a,0x82e7,
/* 0x9298 - 0x929f */ 0x8457,0x8caf,0x4e01,0x5146,0x51cb,0x558b,0x5bf5,0x5e16,
/* 0x92a0 - 0x92a7 */ 0x5e33,0x5e81,0x5f14,0x5f35,0x5f6b,0x5fb4,0x61f2,0x6311,
/* 0x92a8 - 0x92af */ 0x66a2,0x671d,0x6f6e,0x7252,0x753a,0x773a,0x8074,0x8139,
/* 0x92b0 - 0x92b7 */ 0x8178,0x8776,0x8abf,0x8adc,0x8d85,0x8df3,0x929a,0x9577,
/* 0x92b8 - 0x92bf */ 0x9802,0x9ce5,0x52c5,0x6357,0x76f4,0x6715,0x6c88,0x73cd,
/* 0x92c0 - 0x92c7 */ 0x8cc3,0x93ae,0x9673,0x6d25,0x589c,0x690e,0x69cc,0x8ffd,
/* 0x92c8 - 0x92cf */ 0x939a,0x75db,0x901a,0x585a,0x6802,0x63b4,0x69fb,0x4f43,
/* 0x92d0 - 0x92d7 */ 0x6f2c,0x67d8,0x8fbb,0x8526,0x7db4,0x9354,0x693f,0x6f70,
/* 0x92d8 - 0x92df */ 0x576a,0x58f7,0x5b2c,0x7d2c,0x722a,0x540a,0x91e3,0x9db4,
/* 0x92e0 - 0x92e7 */ 0x4ead,0x4f4e,0x505c,0x5075,0x5243,0x8c9e,0x5448,0x5824,
/* 0x92e8 - 0x92ef */ 0x5b9a,0x5e1d,0x5e95,0x5ead,0x5ef7,0x5f1f,0x608c,0x62b5,
/* 0x92f0 - 0x92f7 */ 0x633a,0x63d0,0x68af,0x6c40,0x7887,0x798e,0x7a0b,0x7de0,
/* 0x92f8 - 0x92ff */ 0x8247,0x8a02,0x8ae6,0x8e44,0x9013
}, /* 0x92 */

{ /* 0x93 */
/* 0x9340 - 0x9347 */ 0x90b8,0x912d,0x91d8,0x9f0e,0x6ce5,0x6458,0x64e2,0x6575,
/* 0x9348 - 0x934f */ 0x6ef4,0x7684,0x7b1b,0x9069,0x93d1,0x6eba,0x54f2,0x5fb9,
/* 0x9350 - 0x9357 */ 0x64a4,0x8f4d,0x8fed,0x9244,0x5178,0x586b,0x5929,0x5c55,
/* 0x9358 - 0x935f */ 0x5e97,0x6dfb,0x7e8f,0x751c,0x8cbc,0x8ee2,0x985b,0x70b9,
/* 0x9360 - 0x9367 */ 0x4f1d,0x6bbf,0x6fb1,0x7530,0x96fb,0x514e,0x5410,0x5835,
/* 0x9368 - 0x936f */ 0x5857,0x59ac,0x5c60,0x5f92,0x6597,0x675c,0x6e21,0x767b,
/* 0x9370 - 0x9377 */ 0x83df,0x8ced,0x9014,0x90fd,0x934d,0x7825,0x783a,0x52aa,
/* 0x9378 - 0x937f */ 0x5ea6,0x571f,0x5974,0x6012,0x5012,0x515a,0x51ac,0x0,
/* 0x9380 - 0x9387 */ 0x51cd,0x5200,0x5510,0x5854,0x5858,0x5957,0x5b95,0x5cf6,
/* 0x9388 - 0x938f */ 0x5d8b,0x60bc,0x6295,0x642d,0x6771,0x6843,0x68bc,0x68df,
/* 0x9390 - 0x9397 */ 0x76d7,0x6dd8,0x6e6f,0x6d9b,0x706f,0x71c8,0x5f53,0x75d8,
/* 0x9398 - 0x939f */ 0x7977,0x7b49,0x7b54,0x7b52,0x7cd6,0x7d71,0x5230,0x8463,
/* 0x93a0 - 0x93a7 */ 0x8569,0x85e4,0x8a0e,0x8b04,0x8c46,0x8e0f,0x9003,0x900f,
/* 0x93a8 - 0x93af */ 0x9419,0x9676,0x982d,0x9a30,0x95d8,0x50cd,0x52d5,0x540c,
/* 0x93b0 - 0x93b7 */ 0x5802,0x5c0e,0x61a7,0x649e,0x6d1e,0x77b3,0x7ae5,0x80f4,
/* 0x93b8 - 0x93bf */ 0x8404,0x9053,0x9285,0x5ce0,0x9d07,0x533f,0x5f97,0x5fb3,
/* 0x93c0 - 0x93c7 */ 0x6d9c,0x7279,0x7763,0x79bf,0x7be4,0x6bd2,0x72ec,0x8aad,
/* 0x93c8 - 0x93cf */ 0x6803,0x6a61,0x51f8,0x7a81,0x6934,0x5c4a,0x9cf6,0x82eb,
/* 0x93d0 - 0x93d7 */ 0x5bc5,0x9149,0x701e,0x5678,0x5c6f,0x60c7,0x6566,0x6c8c,
/* 0x93d8 - 0x93df */ 0x8c5a,0x9041,0x9813,0x5451,0x66c7,0x920d,0x5948,0x90a3,
/* 0x93e0 - 0x93e7 */ 0x5185,0x4e4d,0x51ea,0x8599,0x8b0e,0x7058,0x637a,0x934b,
/* 0x93e8 - 0x93ef */ 0x6962,0x99b4,0x7e04,0x7577,0x5357,0x6960,0x8edf,0x96e3,
/* 0x93f0 - 0x93f7 */ 0x6c5d,0x4e8c,0x5c3c,0x5f10,0x8fe9,0x5302,0x8cd1,0x8089,
/* 0x93f8 - 0x93ff */ 0x8679,0x5eff,0x65e5,0x4e73,0x5165
}, /* 0x93 */

{ /* 0x94 */
/* 0x9440 - 0x9447 */ 0x5982,0x5c3f,0x97ee,0x4efb,0x598a,0x5fcd,0x8a8d,0x6fe1,
/* 0x9448 - 0x944f */ 0x79b0,0x7962,0x5be7,0x8471,0x732b,0x71b1,0x5e74,0x5ff5,
/* 0x9450 - 0x9457 */ 0x637b,0x649a,0x71c3,0x7c98,0x4e43,0x5efc,0x4e4b,0x57dc,
/* 0x9458 - 0x945f */ 0x56a2,0x60a9,0x6fc3,0x7d0d,0x80fd,0x8133,0x81bf,0x8fb2,
/* 0x9460 - 0x9467 */ 0x8997,0x86a4,0x5df4,0x628a,0x64ad,0x8987,0x6777,0x6ce2,
/* 0x9468 - 0x946f */ 0x6d3e,0x7436,0x7834,0x5a46,0x7f75,0x82ad,0x99ac,0x4ff3,
/* 0x9470 - 0x9477 */ 0x5ec3,0x62dd,0x6392,0x6557,0x676f,0x76c3,0x724c,0x80cc,
/* 0x9478 - 0x947f */ 0x80ba,0x8f29,0x914d,0x500d,0x57f9,0x5a92,0x6885,0x0,
/* 0x9480 - 0x9487 */ 0x6973,0x7164,0x72fd,0x8cb7,0x58f2,0x8ce0,0x966a,0x9019,
/* 0x9488 - 0x948f */ 0x877f,0x79e4,0x77e7,0x8429,0x4f2f,0x5265,0x535a,0x62cd,
/* 0x9490 - 0x9497 */ 0x67cf,0x6cca,0x767d,0x7b94,0x7c95,0x8236,0x8584,0x8feb,
/* 0x9498 - 0x949f */ 0x66dd,0x6f20,0x7206,0x7e1b,0x83ab,0x99c1,0x9ea6,0x51fd,
/* 0x94a0 - 0x94a7 */ 0x7bb1,0x7872,0x7bb8,0x8087,0x7b48,0x6ae8,0x5e61,0x808c,
/* 0x94a8 - 0x94af */ 0x7551,0x7560,0x516b,0x9262,0x6e8c,0x767a,0x9197,0x9aea,
/* 0x94b0 - 0x94b7 */ 0x4f10,0x7f70,0x629c,0x7b4f,0x95a5,0x9ce9,0x567a,0x5859,
/* 0x94b8 - 0x94bf */ 0x86e4,0x96bc,0x4f34,0x5224,0x534a,0x53cd,0x53db,0x5e06,
/* 0x94c0 - 0x94c7 */ 0x642c,0x6591,0x677f,0x6c3e,0x6c4e,0x7248,0x72af,0x73ed,
/* 0x94c8 - 0x94cf */ 0x7554,0x7e41,0x822c,0x85e9,0x8ca9,0x7bc4,0x91c6,0x7169,
/* 0x94d0 - 0x94d7 */ 0x9812,0x98ef,0x633d,0x6669,0x756a,0x76e4,0x78d0,0x8543,
/* 0x94d8 - 0x94df */ 0x86ee,0x532a,0x5351,0x5426,0x5983,0x5e87,0x5f7c,0x60b2,
/* 0x94e0 - 0x94e7 */ 0x6249,0x6279,0x62ab,0x6590,0x6bd4,0x6ccc,0x75b2,0x76ae,
/* 0x94e8 - 0x94ef */ 0x7891,0x79d8,0x7dcb,0x7f77,0x80a5,0x88ab,0x8ab9,0x8cbb,
/* 0x94f0 - 0x94f7 */ 0x907f,0x975e,0x98db,0x6a0b,0x7c38,0x5099,0x5c3e,0x5fae,
/* 0x94f8 - 0x94ff */ 0x6787,0x6bd8,0x7435,0x7709,0x7f8e
}, /* 0x94 */

{ /* 0x95 */
/* 0x9540 - 0x9547 */ 0x9f3b,0x67ca,0x7a17,0x5339,0x758b,0x9aed,0x5f66,0x819d,
/* 0x9548 - 0x954f */ 0x83f1,0x8098,0x5f3c,0x5fc5,0x7562,0x7b46,0x903c,0x6867,
/* 0x9550 - 0x9557 */ 0x59eb,0x5a9b,0x7d10,0x767e,0x8b2c,0x4ff5,0x5f6a,0x6a19,
/* 0x9558 - 0x955f */ 0x6c37,0x6f02,0x74e2,0x7968,0x8868,0x8a55,0x8c79,0x5edf,
/* 0x9560 - 0x9567 */ 0x63cf,0x75c5,0x79d2,0x82d7,0x9328,0x92f2,0x849c,0x86ed,
/* 0x9568 - 0x956f */ 0x9c2d,0x54c1,0x5f6c,0x658c,0x6d5c,0x7015,0x8ca7,0x8cd3,
/* 0x9570 - 0x9577 */ 0x983b,0x654f,0x74f6,0x4e0d,0x4ed8,0x57e0,0x592b,0x5a66,
/* 0x9578 - 0x957f */ 0x5bcc,0x51a8,0x5e03,0x5e9c,0x6016,0x6276,0x6577,0x0,
/* 0x9580 - 0x9587 */ 0x65a7,0x666e,0x6d6e,0x7236,0x7b26,0x8150,0x819a,0x8299,
/* 0x9588 - 0x958f */ 0x8b5c,0x8ca0,0x8ce6,0x8d74,0x961c,0x9644,0x4fae,0x64ab,
/* 0x9590 - 0x9597 */ 0x6b66,0x821e,0x8461,0x856a,0x90e8,0x5c01,0x6953,0x98a8,
/* 0x9598 - 0x959f */ 0x847a,0x8557,0x4f0f,0x526f,0x5fa9,0x5e45,0x670d,0x798f,
/* 0x95a0 - 0x95a7 */ 0x8179,0x8907,0x8986,0x6df5,0x5f17,0x6255,0x6cb8,0x4ecf,
/* 0x95a8 - 0x95af */ 0x7269,0x9b92,0x5206,0x543b,0x5674,0x58b3,0x61a4,0x626e,
/* 0x95b0 - 0x95b7 */ 0x711a,0x596e,0x7c89,0x7cde,0x7d1b,0x96f0,0x6587,0x805e,
/* 0x95b8 - 0x95bf */ 0x4e19,0x4f75,0x5175,0x5840,0x5e63,0x5e73,0x5f0a,0x67c4,
/* 0x95c0 - 0x95c7 */ 0x4e26,0x853d,0x9589,0x965b,0x7c73,0x9801,0x50fb,0x58c1,
/* 0x95c8 - 0x95cf */ 0x7656,0x78a7,0x5225,0x77a5,0x8511,0x7b86,0x504f,0x5909,
/* 0x95d0 - 0x95d7 */ 0x7247,0x7bc7,0x7de8,0x8fba,0x8fd4,0x904d,0x4fbf,0x52c9,
/* 0x95d8 - 0x95df */ 0x5a29,0x5f01,0x97ad,0x4fdd,0x8217,0x92ea,0x5703,0x6355,
/* 0x95e0 - 0x95e7 */ 0x6b69,0x752b,0x88dc,0x8f14,0x7a42,0x52df,0x5893,0x6155,
/* 0x95e8 - 0x95ef */ 0x620a,0x66ae,0x6bcd,0x7c3f,0x83e9,0x5023,0x4ff8,0x5305,
/* 0x95f0 - 0x95f7 */ 0x5446,0x5831,0x5949,0x5b9d,0x5cf0,0x5cef,0x5d29,0x5e96,
/* 0x95f8 - 0x95ff */ 0x62b1,0x6367,0x653e,0x65b9,0x670b
}, /* 0x95 */

{ /* 0x96 */
/* 0x9640 - 0x9647 */ 0x6cd5,0x6ce1,0x70f9,0x7832,0x7e2b,0x80de,0x82b3,0x840c,
/* 0x9648 - 0x964f */ 0x84ec,0x8702,0x8912,0x8a2a,0x8c4a,0x90a6,0x92d2,0x98fd,
/* 0x9650 - 0x9657 */ 0x9cf3,0x9d6c,0x4e4f,0x4ea1,0x508d,0x5256,0x574a,0x59a8,
/* 0x9658 - 0x965f */ 0x5e3d,0x5fd8,0x5fd9,0x623f,0x66b4,0x671b,0x67d0,0x68d2,
/* 0x9660 - 0x9667 */ 0x5192,0x7d21,0x80aa,0x81a8,0x8b00,0x8c8c,0x8cbf,0x927e,
/* 0x9668 - 0x966f */ 0x9632,0x5420,0x982c,0x5317,0x50d5,0x535c,0x58a8,0x64b2,
/* 0x9670 - 0x9677 */ 0x6734,0x7267,0x7766,0x7a46,0x91e6,0x52c3,0x6ca1,0x6b86,
/* 0x9678 - 0x967f */ 0x5800,0x5e4c,0x5954,0x672c,0x7ffb,0x51e1,0x76c6,0x0,
/* 0x9680 - 0x9687 */ 0x6469,0x78e8,0x9b54,0x9ebb,0x57cb,0x59b9,0x6627,0x679a,
/* 0x9688 - 0x968f */ 0x6bce,0x54e9,0x69d9,0x5e55,0x819c,0x6795,0x9baa,0x67fe,
/* 0x9690 - 0x9697 */ 0x9c52,0x685d,0x4ea6,0x4fe3,0x53c8,0x62b9,0x672b,0x6cab,
/* 0x9698 - 0x969f */ 0x8fc4,0x4fad,0x7e6d,0x9ebf,0x4e07,0x6162,0x6e80,0x6f2b,
/* 0x96a0 - 0x96a7 */ 0x8513,0x5473,0x672a,0x9b45,0x5df3,0x7b95,0x5cac,0x5bc6,
/* 0x96a8 - 0x96af */ 0x871c,0x6e4a,0x84d1,0x7a14,0x8108,0x5999,0x7c8d,0x6c11,
/* 0x96b0 - 0x96b7 */ 0x7720,0x52d9,0x5922,0x7121,0x725f,0x77db,0x9727,0x9d61,
/* 0x96b8 - 0x96bf */ 0x690b,0x5a7f,0x5a18,0x51a5,0x540d,0x547d,0x660e,0x76df,
/* 0x96c0 - 0x96c7 */ 0x8ff7,0x9298,0x9cf4,0x59ea,0x725d,0x6ec5,0x514d,0x68c9,
/* 0x96c8 - 0x96cf */ 0x7dbf,0x7dec,0x9762,0x9eba,0x6478,0x6a21,0x8302,0x5984,
/* 0x96d0 - 0x96d7 */ 0x5b5f,0x6bdb,0x731b,0x76f2,0x7db2,0x8017,0x8499,0x5132,
/* 0x96d8 - 0x96df */ 0x6728,0x9ed9,0x76ee,0x6762,0x52ff,0x9905,0x5c24,0x623b,
/* 0x96e0 - 0x96e7 */ 0x7c7e,0x8cb0,0x554f,0x60b6,0x7d0b,0x9580,0x5301,0x4e5f,
/* 0x96e8 - 0x96ef */ 0x51b6,0x591c,0x723a,0x8036,0x91ce,0x5f25,0x77e2,0x5384,
/* 0x96f0 - 0x96f7 */ 0x5f79,0x7d04,0x85ac,0x8a33,0x8e8d,0x9756,0x67f3,0x85ae,
/* 0x96f8 - 0x96ff */ 0x9453,0x6109,0x6108,0x6cb9,0x7652
}, /* 0x96 */

{ /* 0x97 */
/* 0x9740 - 0x9747 */ 0x8aed,0x8f38,0x552f,0x4f51,0x512a,0x52c7,0x53cb,0x5ba5,
/* 0x9748 - 0x974f */ 0x5e7d,0x60a0,0x6182,0x63d6,0x6709,0x67da,0x6e67,0x6d8c,
/* 0x9750 - 0x9757 */ 0x7336,0x7337,0x7531,0x7950,0x88d5,0x8a98,0x904a,0x9091,
/* 0x9758 - 0x975f */ 0x90f5,0x96c4,0x878d,0x5915,0x4e88,0x4f59,0x4e0e,0x8a89,
/* 0x9760 - 0x9767 */ 0x8f3f,0x9810,0x50ad,0x5e7c,0x5996,0x5bb9,0x5eb8,0x63da,
/* 0x9768 - 0x976f */ 0x63fa,0x64c1,0x66dc,0x694a,0x69d8,0x6d0b,0x6eb6,0x7194,
/* 0x9770 - 0x9777 */ 0x7528,0x7aaf,0x7f8a,0x8000,0x8449,0x84c9,0x8981,0x8b21,
/* 0x9778 - 0x977f */ 0x8e0a,0x9065,0x967d,0x990a,0x617e,0x6291,0x6b32,0x0,
/* 0x9780 - 0x9787 */ 0x6c83,0x6d74,0x7fcc,0x7ffc,0x6dc0,0x7f85,0x87ba,0x88f8,
/* 0x9788 - 0x978f */ 0x6765,0x83b1,0x983c,0x96f7,0x6d1b,0x7d61,0x843d,0x916a,
/* 0x9790 - 0x9797 */ 0x4e71,0x5375,0x5d50,0x6b04,0x6feb,0x85cd,0x862d,0x89a7,
/* 0x9798 - 0x979f */ 0x5229,0x540f,0x5c65,0x674e,0x68a8,0x7406,0x7483,0x75e2,
/* 0x97a0 - 0x97a7 */ 0x88cf,0x88e1,0x91cc,0x96e2,0x9678,0x5f8b,0x7387,0x7acb,
/* 0x97a8 - 0x97af */ 0x844e,0x63a0,0x7565,0x5289,0x6d41,0x6e9c,0x7409,0x7559,
/* 0x97b0 - 0x97b7 */ 0x786b,0x7c92,0x9686,0x7adc,0x9f8d,0x4fb6,0x616e,0x65c5,
/* 0x97b8 - 0x97bf */ 0x865c,0x4e86,0x4eae,0x50da,0x4e21,0x51cc,0x5bee,0x6599,
/* 0x97c0 - 0x97c7 */ 0x6881,0x6dbc,0x731f,0x7642,0x77ad,0x7a1c,0x7ce7,0x826f,
/* 0x97c8 - 0x97cf */ 0x8ad2,0x907c,0x91cf,0x9675,0x9818,0x529b,0x7dd1,0x502b,
/* 0x97d0 - 0x97d7 */ 0x5398,0x6797,0x6dcb,0x71d0,0x7433,0x81e8,0x8f2a,0x96a3,
/* 0x97d8 - 0x97df */ 0x9c57,0x9e9f,0x7460,0x5841,0x6d99,0x7d2f,0x985e,0x4ee4,
/* 0x97e0 - 0x97e7 */ 0x4f36,0x4f8b,0x51b7,0x52b1,0x5dba,0x601c,0x73b2,0x793c,
/* 0x97e8 - 0x97ef */ 0x82d3,0x9234,0x96b7,0x96f6,0x970a,0x9e97,0x9f62,0x66a6,
/* 0x97f0 - 0x97f7 */ 0x6b74,0x5217,0x52a3,0x70c8,0x88c2,0x5ec9,0x604b,0x6190,
/* 0x97f8 - 0x97ff */ 0x6f23,0x7149,0x7c3e,0x7df4,0x806f
}, /* 0x97 */

{ /* 0x98 */
/* 0x9840 - 0x9847 */ 0x84ee,0x9023,0x932c,0x5442,0x9b6f,0x6ad3,0x7089,0x8cc2,
/* 0x9848 - 0x984f */ 0x8def,0x9732,0x52b4,0x5a41,0x5eca,0x5f04,0x6717,0x697c,
/* 0x9850 - 0x9857 */ 0x6994,0x6d6a,0x6f0f,0x7262,0x72fc,0x7bed,0x8001,0x807e,
/* 0x9858 - 0x985f */ 0x874b,0x90ce,0x516d,0x9e93,0x7984,0x808b,0x9332,0x8ad6,
/* 0x9860 - 0x9867 */ 0x502d,0x548c,0x8a71,0x6b6a,0x8cc4,0x8107,0x60d1,0x67a0,
/* 0x9868 - 0x986f */ 0x9df2,0x4e99,0x4e98,0x9c10,0x8a6b,0x85c1,0x8568,0x6900,
/* 0x9870 - 0x9877 */ 0x6e7e,0x7897,0x8155,0x0,0x0,0x0,0x0,0x0,
/* 0x9878 - 0x987f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x9880 - 0x9887 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x9888 - 0x988f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x9890 - 0x9897 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x9898 - 0x989f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5f0c,
/* 0x98a0 - 0x98a7 */ 0x4e10,0x4e15,0x4e2a,0x4e31,0x4e36,0x4e3c,0x4e3f,0x4e42,
/* 0x98a8 - 0x98af */ 0x4e56,0x4e58,0x4e82,0x4e85,0x8c6b,0x4e8a,0x8212,0x5f0d,
/* 0x98b0 - 0x98b7 */ 0x4e8e,0x4e9e,0x4e9f,0x4ea0,0x4ea2,0x4eb0,0x4eb3,0x4eb6,
/* 0x98b8 - 0x98bf */ 0x4ece,0x4ecd,0x4ec4,0x4ec6,0x4ec2,0x4ed7,0x4ede,0x4eed,
/* 0x98c0 - 0x98c7 */ 0x4edf,0x4ef7,0x4f09,0x4f5a,0x4f30,0x4f5b,0x4f5d,0x4f57,
/* 0x98c8 - 0x98cf */ 0x4f47,0x4f76,0x4f88,0x4f8f,0x4f98,0x4f7b,0x4f69,0x4f70,
/* 0x98d0 - 0x98d7 */ 0x4f91,0x4f6f,0x4f86,0x4f96,0x5118,0x4fd4,0x4fdf,0x4fce,
/* 0x98d8 - 0x98df */ 0x4fd8,0x4fdb,0x4fd1,0x4fda,0x4fd0,0x4fe4,0x4fe5,0x501a,
/* 0x98e0 - 0x98e7 */ 0x5028,0x5014,0x502a,0x5025,0x5005,0x4f1c,0x4ff6,0x5021,
/* 0x98e8 - 0x98ef */ 0x5029,0x502c,0x4ffe,0x4fef,0x5011,0x5006,0x5043,0x5047,
/* 0x98f0 - 0x98f7 */ 0x6703,0x5055,0x5050,0x5048,0x505a,0x5056,0x506c,0x5078,
/* 0x98f8 - 0x98ff */ 0x5080,0x509a,0x5085,0x50b4,0x50b2
}, /* 0x98 */

{ /* 0x99 */
/* 0x9940 - 0x9947 */ 0x50c9,0x50ca,0x50b3,0x50c2,0x50d6,0x50de,0x50e5,0x50ed,
/* 0x9948 - 0x994f */ 0x50e3,0x50ee,0x50f9,0x50f5,0x5109,0x5101,0x5102,0x5116,
/* 0x9950 - 0x9957 */ 0x5115,0x5114,0x511a,0x5121,0x513a,0x5137,0x513c,0x513b,
/* 0x9958 - 0x995f */ 0x513f,0x5140,0x5152,0x514c,0x5154,0x5162,0x7af8,0x5169,
/* 0x9960 - 0x9967 */ 0x516a,0x516e,0x5180,0x5182,0x56d8,0x518c,0x5189,0x518f,
/* 0x9968 - 0x996f */ 0x5191,0x5193,0x5195,0x5196,0x51a4,0x51a6,0x51a2,0x51a9,
/* 0x9970 - 0x9977 */ 0x51aa,0x51ab,0x51b3,0x51b1,0x51b2,0x51b0,0x51b5,0x51bd,
/* 0x9978 - 0x997f */ 0x51c5,0x51c9,0x51db,0x51e0,0x8655,0x51e9,0x51ed,0x0,
/* 0x9980 - 0x9987 */ 0x51f0,0x51f5,0x51fe,0x5204,0x520b,0x5214,0x520e,0x5227,
/* 0x9988 - 0x998f */ 0x522a,0x522e,0x5233,0x5239,0x524f,0x5244,0x524b,0x524c,
/* 0x9990 - 0x9997 */ 0x525e,0x5254,0x526a,0x5274,0x5269,0x5273,0x527f,0x527d,
/* 0x9998 - 0x999f */ 0x528d,0x5294,0x5292,0x5271,0x5288,0x5291,0x8fa8,0x8fa7,
/* 0x99a0 - 0x99a7 */ 0x52ac,0x52ad,0x52bc,0x52b5,0x52c1,0x52cd,0x52d7,0x52de,
/* 0x99a8 - 0x99af */ 0x52e3,0x52e6,0x98ed,0x52e0,0x52f3,0x52f5,0x52f8,0x52f9,
/* 0x99b0 - 0x99b7 */ 0x5306,0x5308,0x7538,0x530d,0x5310,0x530f,0x5315,0x531a,
/* 0x99b8 - 0x99bf */ 0x5323,0x532f,0x5331,0x5333,0x5338,0x5340,0x5346,0x5345,
/* 0x99c0 - 0x99c7 */ 0x4e17,0x5349,0x534d,0x51d6,0x535e,0x5369,0x536e,0x5918,
/* 0x99c8 - 0x99cf */ 0x537b,0x5377,0x5382,0x5396,0x53a0,0x53a6,0x53a5,0x53ae,
/* 0x99d0 - 0x99d7 */ 0x53b0,0x53b6,0x53c3,0x7c12,0x96d9,0x53df,0x66fc,0x71ee,
/* 0x99d8 - 0x99df */ 0x53ee,0x53e8,0x53ed,0x53fa,0x5401,0x543d,0x5440,0x542c,
/* 0x99e0 - 0x99e7 */ 0x542d,0x543c,0x542e,0x5436,0x5429,0x541d,0x544e,0x548f,
/* 0x99e8 - 0x99ef */ 0x5475,0x548e,0x545f,0x5471,0x5477,0x5470,0x5492,0x547b,
/* 0x99f0 - 0x99f7 */ 0x5480,0x5476,0x5484,0x5490,0x5486,0x54c7,0x54a2,0x54b8,
/* 0x99f8 - 0x99ff */ 0x54a5,0x54ac,0x54c4,0x54c8,0x54a8
}, /* 0x99 */

{ /* 0x9a */
/* 0x9a40 - 0x9a47 */ 0x54ab,0x54c2,0x54a4,0x54be,0x54bc,0x54d8,0x54e5,0x54e6,
/* 0x9a48 - 0x9a4f */ 0x550f,0x5514,0x54fd,0x54ee,0x54ed,0x54fa,0x54e2,0x5539,
/* 0x9a50 - 0x9a57 */ 0x5540,0x5563,0x554c,0x552e,0x555c,0x5545,0x5556,0x5557,
/* 0x9a58 - 0x9a5f */ 0x5538,0x5533,0x555d,0x5599,0x5580,0x54af,0x558a,0x559f,
/* 0x9a60 - 0x9a67 */ 0x557b,0x557e,0x5598,0x559e,0x55ae,0x557c,0x5583,0x55a9,
/* 0x9a68 - 0x9a6f */ 0x5587,0x55a8,0x55da,0x55c5,0x55df,0x55c4,0x55dc,0x55e4,
/* 0x9a70 - 0x9a77 */ 0x55d4,0x5614,0x55f7,0x5616,0x55fe,0x55fd,0x561b,0x55f9,
/* 0x9a78 - 0x9a7f */ 0x564e,0x5650,0x71df,0x5634,0x5636,0x5632,0x5638,0x0,
/* 0x9a80 - 0x9a87 */ 0x566b,0x5664,0x562f,0x566c,0x566a,0x5686,0x5680,0x568a,
/* 0x9a88 - 0x9a8f */ 0x56a0,0x5694,0x568f,0x56a5,0x56ae,0x56b6,0x56b4,0x56c2,
/* 0x9a90 - 0x9a97 */ 0x56bc,0x56c1,0x56c3,0x56c0,0x56c8,0x56ce,0x56d1,0x56d3,
/* 0x9a98 - 0x9a9f */ 0x56d7,0x56ee,0x56f9,0x5700,0x56ff,0x5704,0x5709,0x5708,
/* 0x9aa0 - 0x9aa7 */ 0x570b,0x570d,0x5713,0x5718,0x5716,0x55c7,0x571c,0x5726,
/* 0x9aa8 - 0x9aaf */ 0x5737,0x5738,0x574e,0x573b,0x5740,0x574f,0x5769,0x57c0,
/* 0x9ab0 - 0x9ab7 */ 0x5788,0x5761,0x577f,0x5789,0x5793,0x57a0,0x57b3,0x57a4,
/* 0x9ab8 - 0x9abf */ 0x57aa,0x57b0,0x57c3,0x57c6,0x57d4,0x57d2,0x57d3,0x580a,
/* 0x9ac0 - 0x9ac7 */ 0x57d6,0x57e3,0x580b,0x5819,0x581d,0x5872,0x5821,0x5862,
/* 0x9ac8 - 0x9acf */ 0x584b,0x5870,0x6bc0,0x5852,0x583d,0x5879,0x5885,0x58b9,
/* 0x9ad0 - 0x9ad7 */ 0x589f,0x58ab,0x58ba,0x58de,0x58bb,0x58b8,0x58ae,0x58c5,
/* 0x9ad8 - 0x9adf */ 0x58d3,0x58d1,0x58d7,0x58d9,0x58d8,0x58e5,0x58dc,0x58e4,
/* 0x9ae0 - 0x9ae7 */ 0x58df,0x58ef,0x58fa,0x58f9,0x58fb,0x58fc,0x58fd,0x5902,
/* 0x9ae8 - 0x9aef */ 0x590a,0x5910,0x591b,0x68a6,0x5925,0x592c,0x592d,0x5932,
/* 0x9af0 - 0x9af7 */ 0x5938,0x593e,0x7ad2,0x5955,0x5950,0x594e,0x595a,0x5958,
/* 0x9af8 - 0x9aff */ 0x5962,0x5960,0x5967,0x596c,0x5969
}, /* 0x9a */

{ /* 0x9b */
/* 0x9b40 - 0x9b47 */ 0x5978,0x5981,0x599d,0x4f5e,0x4fab,0x59a3,0x59b2,0x59c6,
/* 0x9b48 - 0x9b4f */ 0x59e8,0x59dc,0x598d,0x59d9,0x59da,0x5a25,0x5a1f,0x5a11,
/* 0x9b50 - 0x9b57 */ 0x5a1c,0x5a09,0x5a1a,0x5a40,0x5a6c,0x5a49,0x5a35,0x5a36,
/* 0x9b58 - 0x9b5f */ 0x5a62,0x5a6a,0x5a9a,0x5abc,0x5abe,0x5acb,0x5ac2,0x5abd,
/* 0x9b60 - 0x9b67 */ 0x5ae3,0x5ad7,0x5ae6,0x5ae9,0x5ad6,0x5afa,0x5afb,0x5b0c,
/* 0x9b68 - 0x9b6f */ 0x5b0b,0x5b16,0x5b32,0x5ad0,0x5b2a,0x5b36,0x5b3e,0x5b43,
/* 0x9b70 - 0x9b77 */ 0x5b45,0x5b40,0x5b51,0x5b55,0x5b5a,0x5b5b,0x5b65,0x5b69,
/* 0x9b78 - 0x9b7f */ 0x5b70,0x5b73,0x5b75,0x5b78,0x6588,0x5b7a,0x5b80,0x0,
/* 0x9b80 - 0x9b87 */ 0x5b83,0x5ba6,0x5bb8,0x5bc3,0x5bc7,0x5bc9,0x5bd4,0x5bd0,
/* 0x9b88 - 0x9b8f */ 0x5be4,0x5be6,0x5be2,0x5bde,0x5be5,0x5beb,0x5bf0,0x5bf6,
/* 0x9b90 - 0x9b97 */ 0x5bf3,0x5c05,0x5c07,0x5c08,0x5c0d,0x5c13,0x5c20,0x5c22,
/* 0x9b98 - 0x9b9f */ 0x5c28,0x5c38,0x5c39,0x5c41,0x5c46,0x5c4e,0x5c53,0x5c50,
/* 0x9ba0 - 0x9ba7 */ 0x5c4f,0x5b71,0x5c6c,0x5c6e,0x4e62,0x5c76,0x5c79,0x5c8c,
/* 0x9ba8 - 0x9baf */ 0x5c91,0x5c94,0x599b,0x5cab,0x5cbb,0x5cb6,0x5cbc,0x5cb7,
/* 0x9bb0 - 0x9bb7 */ 0x5cc5,0x5cbe,0x5cc7,0x5cd9,0x5ce9,0x5cfd,0x5cfa,0x5ced,
/* 0x9bb8 - 0x9bbf */ 0x5d8c,0x5cea,0x5d0b,0x5d15,0x5d17,0x5d5c,0x5d1f,0x5d1b,
/* 0x9bc0 - 0x9bc7 */ 0x5d11,0x5d14,0x5d22,0x5d1a,0x5d19,0x5d18,0x5d4c,0x5d52,
/* 0x9bc8 - 0x9bcf */ 0x5d4e,0x5d4b,0x5d6c,0x5d73,0x5d76,0x5d87,0x5d84,0x5d82,
/* 0x9bd0 - 0x9bd7 */ 0x5da2,0x5d9d,0x5dac,0x5dae,0x5dbd,0x5d90,0x5db7,0x5dbc,
/* 0x9bd8 - 0x9bdf */ 0x5dc9,0x5dcd,0x5dd3,0x5dd2,0x5dd6,0x5ddb,0x5deb,0x5df2,
/* 0x9be0 - 0x9be7 */ 0x5df5,0x5e0b,0x5e1a,0x5e19,0x5e11,0x5e1b,0x5e36,0x5e37,
/* 0x9be8 - 0x9bef */ 0x5e44,0x5e43,0x5e40,0x5e4e,0x5e57,0x5e54,0x5e5f,0x5e62,
/* 0x9bf0 - 0x9bf7 */ 0x5e64,0x5e47,0x5e75,0x5e76,0x5e7a,0x9ebc,0x5e7f,0x5ea0,
/* 0x9bf8 - 0x9bff */ 0x5ec1,0x5ec2,0x5ec8,0x5ed0,0x5ecf
}, /* 0x9b */

{ /* 0x9c */
/* 0x9c40 - 0x9c47 */ 0x5ed6,0x5ee3,0x5edd,0x5eda,0x5edb,0x5ee2,0x5ee1,0x5ee8,
/* 0x9c48 - 0x9c4f */ 0x5ee9,0x5eec,0x5ef1,0x5ef3,0x5ef0,0x5ef4,0x5ef8,0x5efe,
/* 0x9c50 - 0x9c57 */ 0x5f03,0x5f09,0x5f5d,0x5f5c,0x5f0b,0x5f11,0x5f16,0x5f29,
/* 0x9c58 - 0x9c5f */ 0x5f2d,0x5f38,0x5f41,0x5f48,0x5f4c,0x5f4e,0x5f2f,0x5f51,
/* 0x9c60 - 0x9c67 */ 0x5f56,0x5f57,0x5f59,0x5f61,0x5f6d,0x5f73,0x5f77,0x5f83,
/* 0x9c68 - 0x9c6f */ 0x5f82,0x5f7f,0x5f8a,0x5f88,0x5f91,0x5f87,0x5f9e,0x5f99,
/* 0x9c70 - 0x9c77 */ 0x5f98,0x5fa0,0x5fa8,0x5fad,0x5fbc,0x5fd6,0x5ffb,0x5fe4,
/* 0x9c78 - 0x9c7f */ 0x5ff8,0x5ff1,0x5fdd,0x60b3,0x5fff,0x6021,0x6060,0x0,
/* 0x9c80 - 0x9c87 */ 0x6019,0x6010,0x6029,0x600e,0x6031,0x601b,0x6015,0x602b,
/* 0x9c88 - 0x9c8f */ 0x6026,0x600f,0x603a,0x605a,0x6041,0x606a,0x6077,0x605f,
/* 0x9c90 - 0x9c97 */ 0x604a,0x6046,0x604d,0x6063,0x6043,0x6064,0x6042,0x606c,
/* 0x9c98 - 0x9c9f */ 0x606b,0x6059,0x6081,0x608d,0x60e7,0x6083,0x609a,0x6084,
/* 0x9ca0 - 0x9ca7 */ 0x609b,0x6096,0x6097,0x6092,0x60a7,0x608b,0x60e1,0x60b8,
/* 0x9ca8 - 0x9caf */ 0x60e0,0x60d3,0x60b4,0x5ff0,0x60bd,0x60c6,0x60b5,0x60d8,
/* 0x9cb0 - 0x9cb7 */ 0x614d,0x6115,0x6106,0x60f6,0x60f7,0x6100,0x60f4,0x60fa,
/* 0x9cb8 - 0x9cbf */ 0x6103,0x6121,0x60fb,0x60f1,0x610d,0x610e,0x6147,0x613e,
/* 0x9cc0 - 0x9cc7 */ 0x6128,0x6127,0x614a,0x613f,0x613c,0x612c,0x6134,0x613d,
/* 0x9cc8 - 0x9ccf */ 0x6142,0x6144,0x6173,0x6177,0x6158,0x6159,0x615a,0x616b,
/* 0x9cd0 - 0x9cd7 */ 0x6174,0x616f,0x6165,0x6171,0x615f,0x615d,0x6153,0x6175,
/* 0x9cd8 - 0x9cdf */ 0x6199,0x6196,0x6187,0x61ac,0x6194,0x619a,0x618a,0x6191,
/* 0x9ce0 - 0x9ce7 */ 0x61ab,0x61ae,0x61cc,0x61ca,0x61c9,0x61f7,0x61c8,0x61c3,
/* 0x9ce8 - 0x9cef */ 0x61c6,0x61ba,0x61cb,0x7f79,0x61cd,0x61e6,0x61e3,0x61f6,
/* 0x9cf0 - 0x9cf7 */ 0x61fa,0x61f4,0x61ff,0x61fd,0x61fc,0x61fe,0x6200,0x6208,
/* 0x9cf8 - 0x9cff */ 0x6209,0x620d,0x620c,0x6214,0x621b
}, /* 0x9c */

{ /* 0x9d */
/* 0x9d40 - 0x9d47 */ 0x621e,0x6221,0x622a,0x622e,0x6230,0x6232,0x6233,0x6241,
/* 0x9d48 - 0x9d4f */ 0x624e,0x625e,0x6263,0x625b,0x6260,0x6268,0x627c,0x6282,
/* 0x9d50 - 0x9d57 */ 0x6289,0x627e,0x6292,0x6293,0x6296,0x62d4,0x6283,0x6294,
/* 0x9d58 - 0x9d5f */ 0x62d7,0x62d1,0x62bb,0x62cf,0x62ff,0x62c6,0x64d4,0x62c8,
/* 0x9d60 - 0x9d67 */ 0x62dc,0x62cc,0x62ca,0x62c2,0x62c7,0x629b,0x62c9,0x630c,
/* 0x9d68 - 0x9d6f */ 0x62ee,0x62f1,0x6327,0x6302,0x6308,0x62ef,0x62f5,0x6350,
/* 0x9d70 - 0x9d77 */ 0x633e,0x634d,0x641c,0x634f,0x6396,0x638e,0x6380,0x63ab,
/* 0x9d78 - 0x9d7f */ 0x6376,0x63a3,0x638f,0x6389,0x639f,0x63b5,0x636b,0x0,
/* 0x9d80 - 0x9d87 */ 0x6369,0x63be,0x63e9,0x63c0,0x63c6,0x63e3,0x63c9,0x63d2,
/* 0x9d88 - 0x9d8f */ 0x63f6,0x63c4,0x6416,0x6434,0x6406,0x6413,0x6426,0x6436,
/* 0x9d90 - 0x9d97 */ 0x651d,0x6417,0x6428,0x640f,0x6467,0x646f,0x6476,0x644e,
/* 0x9d98 - 0x9d9f */ 0x652a,0x6495,0x6493,0x64a5,0x64a9,0x6488,0x64bc,0x64da,
/* 0x9da0 - 0x9da7 */ 0x64d2,0x64c5,0x64c7,0x64bb,0x64d8,0x64c2,0x64f1,0x64e7,
/* 0x9da8 - 0x9daf */ 0x8209,0x64e0,0x64e1,0x62ac,0x64e3,0x64ef,0x652c,0x64f6,
/* 0x9db0 - 0x9db7 */ 0x64f4,0x64f2,0x64fa,0x6500,0x64fd,0x6518,0x651c,0x6505,
/* 0x9db8 - 0x9dbf */ 0x6524,0x6523,0x652b,0x6534,0x6535,0x6537,0x6536,0x6538,
/* 0x9dc0 - 0x9dc7 */ 0x754b,0x6548,0x6556,0x6555,0x654d,0x6558,0x655e,0x655d,
/* 0x9dc8 - 0x9dcf */ 0x6572,0x6578,0x6582,0x6583,0x8b8a,0x659b,0x659f,0x65ab,
/* 0x9dd0 - 0x9dd7 */ 0x65b7,0x65c3,0x65c6,0x65c1,0x65c4,0x65cc,0x65d2,0x65db,
/* 0x9dd8 - 0x9ddf */ 0x65d9,0x65e0,0x65e1,0x65f1,0x6772,0x660a,0x6603,0x65fb,
/* 0x9de0 - 0x9de7 */ 0x6773,0x6635,0x6636,0x6634,0x661c,0x664f,0x6644,0x6649,
/* 0x9de8 - 0x9def */ 0x6641,0x665e,0x665d,0x6664,0x6667,0x6668,0x665f,0x6662,
/* 0x9df0 - 0x9df7 */ 0x6670,0x6683,0x6688,0x668e,0x6689,0x6684,0x6698,0x669d,
/* 0x9df8 - 0x9dff */ 0x66c1,0x66b9,0x66c9,0x66be,0x66bc
}, /* 0x9d */

{ /* 0x9e */
/* 0x9e40 - 0x9e47 */ 0x66c4,0x66b8,0x66d6,0x66da,0x66e0,0x663f,0x66e6,0x66e9,
/* 0x9e48 - 0x9e4f */ 0x66f0,0x66f5,0x66f7,0x670f,0x6716,0x671e,0x6726,0x6727,
/* 0x9e50 - 0x9e57 */ 0x9738,0x672e,0x673f,0x6736,0x6741,0x6738,0x6737,0x6746,
/* 0x9e58 - 0x9e5f */ 0x675e,0x6760,0x6759,0x6763,0x6764,0x6789,0x6770,0x67a9,
/* 0x9e60 - 0x9e67 */ 0x677c,0x676a,0x678c,0x678b,0x67a6,0x67a1,0x6785,0x67b7,
/* 0x9e68 - 0x9e6f */ 0x67ef,0x67b4,0x67ec,0x67b3,0x67e9,0x67b8,0x67e4,0x67de,
/* 0x9e70 - 0x9e77 */ 0x67dd,0x67e2,0x67ee,0x67b9,0x67ce,0x67c6,0x67e7,0x6a9c,
/* 0x9e78 - 0x9e7f */ 0x681e,0x6846,0x6829,0x6840,0x684d,0x6832,0x684e,0x0,
/* 0x9e80 - 0x9e87 */ 0x68b3,0x682b,0x6859,0x6863,0x6877,0x687f,0x689f,0x688f,
/* 0x9e88 - 0x9e8f */ 0x68ad,0x6894,0x689d,0x689b,0x6883,0x6aae,0x68b9,0x6874,
/* 0x9e90 - 0x9e97 */ 0x68b5,0x68a0,0x68ba,0x690f,0x688d,0x687e,0x6901,0x68ca,
/* 0x9e98 - 0x9e9f */ 0x6908,0x68d8,0x6922,0x6926,0x68e1,0x690c,0x68cd,0x68d4,
/* 0x9ea0 - 0x9ea7 */ 0x68e7,0x68d5,0x6936,0x6912,0x6904,0x68d7,0x68e3,0x6925,
/* 0x9ea8 - 0x9eaf */ 0x68f9,0x68e0,0x68ef,0x6928,0x692a,0x691a,0x6923,0x6921,
/* 0x9eb0 - 0x9eb7 */ 0x68c6,0x6979,0x6977,0x695c,0x6978,0x696b,0x6954,0x697e,
/* 0x9eb8 - 0x9ebf */ 0x696e,0x6939,0x6974,0x693d,0x6959,0x6930,0x6961,0x695e,
/* 0x9ec0 - 0x9ec7 */ 0x695d,0x6981,0x696a,0x69b2,0x69ae,0x69d0,0x69bf,0x69c1,
/* 0x9ec8 - 0x9ecf */ 0x69d3,0x69be,0x69ce,0x5be8,0x69ca,0x69dd,0x69bb,0x69c3,
/* 0x9ed0 - 0x9ed7 */ 0x69a7,0x6a2e,0x6991,0x69a0,0x699c,0x6995,0x69b4,0x69de,
/* 0x9ed8 - 0x9edf */ 0x69e8,0x6a02,0x6a1b,0x69ff,0x6b0a,0x69f9,0x69f2,0x69e7,
/* 0x9ee0 - 0x9ee7 */ 0x6a05,0x69b1,0x6a1e,0x69ed,0x6a14,0x69eb,0x6a0a,0x6a12,
/* 0x9ee8 - 0x9eef */ 0x6ac1,0x6a23,0x6a13,0x6a44,0x6a0c,0x6a72,0x6a36,0x6a78,
/* 0x9ef0 - 0x9ef7 */ 0x6a47,0x6a62,0x6a59,0x6a66,0x6a48,0x6a38,0x6a22,0x6a90,
/* 0x9ef8 - 0x9eff */ 0x6a8d,0x6aa0,0x6a84,0x6aa2,0x6aa3
}, /* 0x9e */

{ /* 0x9f */
/* 0x9f40 - 0x9f47 */ 0x6a97,0x8617,0x6abb,0x6ac3,0x6ac2,0x6ab8,0x6ab3,0x6aac,
/* 0x9f48 - 0x9f4f */ 0x6ade,0x6ad1,0x6adf,0x6aaa,0x6ada,0x6aea,0x6afb,0x6b05,
/* 0x9f50 - 0x9f57 */ 0x8616,0x6afa,0x6b12,0x6b16,0x9b31,0x6b1f,0x6b38,0x6b37,
/* 0x9f58 - 0x9f5f */ 0x76dc,0x6b39,0x98ee,0x6b47,0x6b43,0x6b49,0x6b50,0x6b59,
/* 0x9f60 - 0x9f67 */ 0x6b54,0x6b5b,0x6b5f,0x6b61,0x6b78,0x6b79,0x6b7f,0x6b80,
/* 0x9f68 - 0x9f6f */ 0x6b84,0x6b83,0x6b8d,0x6b98,0x6b95,0x6b9e,0x6ba4,0x6baa,
/* 0x9f70 - 0x9f77 */ 0x6bab,0x6baf,0x6bb2,0x6bb1,0x6bb3,0x6bb7,0x6bbc,0x6bc6,
/* 0x9f78 - 0x9f7f */ 0x6bcb,0x6bd3,0x6bdf,0x6bec,0x6beb,0x6bf3,0x6bef,0x0,
/* 0x9f80 - 0x9f87 */ 0x9ebe,0x6c08,0x6c13,0x6c14,0x6c1b,0x6c24,0x6c23,0x6c5e,
/* 0x9f88 - 0x9f8f */ 0x6c55,0x6c62,0x6c6a,0x6c82,0x6c8d,0x6c9a,0x6c81,0x6c9b,
/* 0x9f90 - 0x9f97 */ 0x6c7e,0x6c68,0x6c73,0x6c92,0x6c90,0x6cc4,0x6cf1,0x6cd3,
/* 0x9f98 - 0x9f9f */ 0x6cbd,0x6cd7,0x6cc5,0x6cdd,0x6cae,0x6cb1,0x6cbe,0x6cba,
/* 0x9fa0 - 0x9fa7 */ 0x6cdb,0x6cef,0x6cd9,0x6cea,0x6d1f,0x884d,0x6d36,0x6d2b,
/* 0x9fa8 - 0x9faf */ 0x6d3d,0x6d38,0x6d19,0x6d35,0x6d33,0x6d12,0x6d0c,0x6d63,
/* 0x9fb0 - 0x9fb7 */ 0x6d93,0x6d64,0x6d5a,0x6d79,0x6d59,0x6d8e,0x6d95,0x6fe4,
/* 0x9fb8 - 0x9fbf */ 0x6d85,0x6df9,0x6e15,0x6e0a,0x6db5,0x6dc7,0x6de6,0x6db8,
/* 0x9fc0 - 0x9fc7 */ 0x6dc6,0x6dec,0x6dde,0x6dcc,0x6de8,0x6dd2,0x6dc5,0x6dfa,
/* 0x9fc8 - 0x9fcf */ 0x6dd9,0x6de4,0x6dd5,0x6dea,0x6dee,0x6e2d,0x6e6e,0x6e2e,
/* 0x9fd0 - 0x9fd7 */ 0x6e19,0x6e72,0x6e5f,0x6e3e,0x6e23,0x6e6b,0x6e2b,0x6e76,
/* 0x9fd8 - 0x9fdf */ 0x6e4d,0x6e1f,0x6e43,0x6e3a,0x6e4e,0x6e24,0x6eff,0x6e1d,
/* 0x9fe0 - 0x9fe7 */ 0x6e38,0x6e82,0x6eaa,0x6e98,0x6ec9,0x6eb7,0x6ed3,0x6ebd,
/* 0x9fe8 - 0x9fef */ 0x6eaf,0x6ec4,0x6eb2,0x6ed4,0x6ed5,0x6e8f,0x6ea5,0x6ec2,
/* 0x9ff0 - 0x9ff7 */ 0x6e9f,0x6f41,0x6f11,0x704c,0x6eec,0x6ef8,0x6efe,0x6f3f,
/* 0x9ff8 - 0x9fff */ 0x6ef2,0x6f31,0x6eef,0x6f32,0x6ecc
} /* 0x9f */

}, //////////////////////////////////////// DBCS_Table1

{ //////////////////////////////////////// DBCS_Table2

{ /* 0xe0 */
/* 0xe040 - 0xe047 */ 0x6f3e,0x6f13,0x6ef7,0x6f86,0x6f7a,0x6f78,0x6f81,0x6f80,
/* 0xe048 - 0xe04f */ 0x6f6f,0x6f5b,0x6ff3,0x6f6d,0x6f82,0x6f7c,0x6f58,0x6f8e,
/* 0xe050 - 0xe057 */ 0x6f91,0x6fc2,0x6f66,0x6fb3,0x6fa3,0x6fa1,0x6fa4,0x6fb9,
/* 0xe058 - 0xe05f */ 0x6fc6,0x6faa,0x6fdf,0x6fd5,0x6fec,0x6fd4,0x6fd8,0x6ff1,
/* 0xe060 - 0xe067 */ 0x6fee,0x6fdb,0x7009,0x700b,0x6ffa,0x7011,0x7001,0x700f,
/* 0xe068 - 0xe06f */ 0x6ffe,0x701b,0x701a,0x6f74,0x701d,0x7018,0x701f,0x7030,
/* 0xe070 - 0xe077 */ 0x703e,0x7032,0x7051,0x7063,0x7099,0x7092,0x70af,0x70f1,
/* 0xe078 - 0xe07f */ 0x70ac,0x70b8,0x70b3,0x70ae,0x70df,0x70cb,0x70dd,0x0,
/* 0xe080 - 0xe087 */ 0x70d9,0x7109,0x70fd,0x711c,0x7119,0x7165,0x7155,0x7188,
/* 0xe088 - 0xe08f */ 0x7166,0x7162,0x714c,0x7156,0x716c,0x718f,0x71fb,0x7184,
/* 0xe090 - 0xe097 */ 0x7195,0x71a8,0x71ac,0x71d7,0x71b9,0x71be,0x71d2,0x71c9,
/* 0xe098 - 0xe09f */ 0x71d4,0x71ce,0x71e0,0x71ec,0x71e7,0x71f5,0x71fc,0x71f9,
/* 0xe0a0 - 0xe0a7 */ 0x71ff,0x720d,0x7210,0x721b,0x7228,0x722d,0x722c,0x7230,
/* 0xe0a8 - 0xe0af */ 0x7232,0x723b,0x723c,0x723f,0x7240,0x7246,0x724b,0x7258,
/* 0xe0b0 - 0xe0b7 */ 0x7274,0x727e,0x7282,0x7281,0x7287,0x7292,0x7296,0x72a2,
/* 0xe0b8 - 0xe0bf */ 0x72a7,0x72b9,0x72b2,0x72c3,0x72c6,0x72c4,0x72ce,0x72d2,
/* 0xe0c0 - 0xe0c7 */ 0x72e2,0x72e0,0x72e1,0x72f9,0x72f7,0x500f,0x7317,0x730a,
/* 0xe0c8 - 0xe0cf */ 0x731c,0x7316,0x731d,0x7334,0x732f,0x7329,0x7325,0x733e,
/* 0xe0d0 - 0xe0d7 */ 0x734e,0x734f,0x9ed8,0x7357,0x736a,0x7368,0x7370,0x7378,
/* 0xe0d8 - 0xe0df */ 0x7375,0x737b,0x737a,0x73c8,0x73b3,0x73ce,0x73bb,0x73c0,
/* 0xe0e0 - 0xe0e7 */ 0x73e5,0x73ee,0x73de,0x74a2,0x7405,0x746f,0x7425,0x73f8,
/* 0xe0e8 - 0xe0ef */ 0x7432,0x743a,0x7455,0x743f,0x745f,0x7459,0x7441,0x745c,
/* 0xe0f0 - 0xe0f7 */ 0x7469,0x7470,0x7463,0x746a,0x7476,0x747e,0x748b,0x749e,
/* 0xe0f8 - 0xe0ff */ 0x74a7,0x74ca,0x74cf,0x74d4,0x73f1
}, /* 0xe0 */

{ /* 0xe1 */
/* 0xe140 - 0xe147 */ 0x74e0,0x74e3,0x74e7,0x74e9,0x74ee,0x74f2,0x74f0,0x74f1,
/* 0xe148 - 0xe14f */ 0x74f8,0x74f7,0x7504,0x7503,0x7505,0x750c,0x750e,0x750d,
/* 0xe150 - 0xe157 */ 0x7515,0x7513,0x751e,0x7526,0x752c,0x753c,0x7544,0x754d,
/* 0xe158 - 0xe15f */ 0x754a,0x7549,0x755b,0x7546,0x755a,0x7569,0x7564,0x7567,
/* 0xe160 - 0xe167 */ 0x756b,0x756d,0x7578,0x7576,0x7586,0x7587,0x7574,0x758a,
/* 0xe168 - 0xe16f */ 0x7589,0x7582,0x7594,0x759a,0x759d,0x75a5,0x75a3,0x75c2,
/* 0xe170 - 0xe177 */ 0x75b3,0x75c3,0x75b5,0x75bd,0x75b8,0x75bc,0x75b1,0x75cd,
/* 0xe178 - 0xe17f */ 0x75ca,0x75d2,0x75d9,0x75e3,0x75de,0x75fe,0x75ff,0x0,
/* 0xe180 - 0xe187 */ 0x75fc,0x7601,0x75f0,0x75fa,0x75f2,0x75f3,0x760b,0x760d,
/* 0xe188 - 0xe18f */ 0x7609,0x761f,0x7627,0x7620,0x7621,0x7622,0x7624,0x7634,
/* 0xe190 - 0xe197 */ 0x7630,0x763b,0x7647,0x7648,0x7646,0x765c,0x7658,0x7661,
/* 0xe198 - 0xe19f */ 0x7662,0x7668,0x7669,0x766a,0x7667,0x766c,0x7670,0x7672,
/* 0xe1a0 - 0xe1a7 */ 0x7676,0x7678,0x767c,0x7680,0x7683,0x7688,0x768b,0x768e,
/* 0xe1a8 - 0xe1af */ 0x7696,0x7693,0x7699,0x769a,0x76b0,0x76b4,0x76b8,0x76b9,
/* 0xe1b0 - 0xe1b7 */ 0x76ba,0x76c2,0x76cd,0x76d6,0x76d2,0x76de,0x76e1,0x76e5,
/* 0xe1b8 - 0xe1bf */ 0x76e7,0x76ea,0x862f,0x76fb,0x7708,0x7707,0x7704,0x7729,
/* 0xe1c0 - 0xe1c7 */ 0x7724,0x771e,0x7725,0x7726,0x771b,0x7737,0x7738,0x7747,
/* 0xe1c8 - 0xe1cf */ 0x775a,0x7768,0x776b,0x775b,0x7765,0x777f,0x777e,0x7779,
/* 0xe1d0 - 0xe1d7 */ 0x778e,0x778b,0x7791,0x77a0,0x779e,0x77b0,0x77b6,0x77b9,
/* 0xe1d8 - 0xe1df */ 0x77bf,0x77bc,0x77bd,0x77bb,0x77c7,0x77cd,0x77d7,0x77da,
/* 0xe1e0 - 0xe1e7 */ 0x77dc,0x77e3,0x77ee,0x77fc,0x780c,0x7812,0x7926,0x7820,
/* 0xe1e8 - 0xe1ef */ 0x792a,0x7845,0x788e,0x7874,0x7886,0x787c,0x789a,0x788c,
/* 0xe1f0 - 0xe1f7 */ 0x78a3,0x78b5,0x78aa,0x78af,0x78d1,0x78c6,0x78cb,0x78d4,
/* 0xe1f8 - 0xe1ff */ 0x78be,0x78bc,0x78c5,0x78ca,0x78ec
}, /* 0xe1 */

{ /* 0xe2 */
/* 0xe240 - 0xe247 */ 0x78e7,0x78da,0x78fd,0x78f4,0x7907,0x7912,0x7911,0x7919,
/* 0xe248 - 0xe24f */ 0x792c,0x792b,0x7940,0x7960,0x7957,0x795f,0x795a,0x7955,
/* 0xe250 - 0xe257 */ 0x7953,0x797a,0x797f,0x798a,0x799d,0x79a7,0x9f4b,0x79aa,
/* 0xe258 - 0xe25f */ 0x79ae,0x79b3,0x79b9,0x79ba,0x79c9,0x79d5,0x79e7,0x79ec,
/* 0xe260 - 0xe267 */ 0x79e1,0x79e3,0x7a08,0x7a0d,0x7a18,0x7a19,0x7a20,0x7a1f,
/* 0xe268 - 0xe26f */ 0x7980,0x7a31,0x7a3b,0x7a3e,0x7a37,0x7a43,0x7a57,0x7a49,
/* 0xe270 - 0xe277 */ 0x7a61,0x7a62,0x7a69,0x9f9d,0x7a70,0x7a79,0x7a7d,0x7a88,
/* 0xe278 - 0xe27f */ 0x7a97,0x7a95,0x7a98,0x7a96,0x7aa9,0x7ac8,0x7ab0,0x0,
/* 0xe280 - 0xe287 */ 0x7ab6,0x7ac5,0x7ac4,0x7abf,0x9083,0x7ac7,0x7aca,0x7acd,
/* 0xe288 - 0xe28f */ 0x7acf,0x7ad5,0x7ad3,0x7ad9,0x7ada,0x7add,0x7ae1,0x7ae2,
/* 0xe290 - 0xe297 */ 0x7ae6,0x7aed,0x7af0,0x7b02,0x7b0f,0x7b0a,0x7b06,0x7b33,
/* 0xe298 - 0xe29f */ 0x7b18,0x7b19,0x7b1e,0x7b35,0x7b28,0x7b36,0x7b50,0x7b7a,
/* 0xe2a0 - 0xe2a7 */ 0x7b04,0x7b4d,0x7b0b,0x7b4c,0x7b45,0x7b75,0x7b65,0x7b74,
/* 0xe2a8 - 0xe2af */ 0x7b67,0x7b70,0x7b71,0x7b6c,0x7b6e,0x7b9d,0x7b98,0x7b9f,
/* 0xe2b0 - 0xe2b7 */ 0x7b8d,0x7b9c,0x7b9a,0x7b8b,0x7b92,0x7b8f,0x7b5d,0x7b99,
/* 0xe2b8 - 0xe2bf */ 0x7bcb,0x7bc1,0x7bcc,0x7bcf,0x7bb4,0x7bc6,0x7bdd,0x7be9,
/* 0xe2c0 - 0xe2c7 */ 0x7c11,0x7c14,0x7be6,0x7be5,0x7c60,0x7c00,0x7c07,0x7c13,
/* 0xe2c8 - 0xe2cf */ 0x7bf3,0x7bf7,0x7c17,0x7c0d,0x7bf6,0x7c23,0x7c27,0x7c2a,
/* 0xe2d0 - 0xe2d7 */ 0x7c1f,0x7c37,0x7c2b,0x7c3d,0x7c4c,0x7c43,0x7c54,0x7c4f,
/* 0xe2d8 - 0xe2df */ 0x7c40,0x7c50,0x7c58,0x7c5f,0x7c64,0x7c56,0x7c65,0x7c6c,
/* 0xe2e0 - 0xe2e7 */ 0x7c75,0x7c83,0x7c90,0x7ca4,0x7cad,0x7ca2,0x7cab,0x7ca1,
/* 0xe2e8 - 0xe2ef */ 0x7ca8,0x7cb3,0x7cb2,0x7cb1,0x7cae,0x7cb9,0x7cbd,0x7cc0,
/* 0xe2f0 - 0xe2f7 */ 0x7cc5,0x7cc2,0x7cd8,0x7cd2,0x7cdc,0x7ce2,0x9b3b,0x7cef,
/* 0xe2f8 - 0xe2ff */ 0x7cf2,0x7cf4,0x7cf6,0x7cfa,0x7d06
}, /* 0xe2 */

{ /* 0xe3 */
/* 0xe340 - 0xe347 */ 0x7d02,0x7d1c,0x7d15,0x7d0a,0x7d45,0x7d4b,0x7d2e,0x7d32,
/* 0xe348 - 0xe34f */ 0x7d3f,0x7d35,0x7d46,0x7d73,0x7d56,0x7d4e,0x7d72,0x7d68,
/* 0xe350 - 0xe357 */ 0x7d6e,0x7d4f,0x7d63,0x7d93,0x7d89,0x7d5b,0x7d8f,0x7d7d,
/* 0xe358 - 0xe35f */ 0x7d9b,0x7dba,0x7dae,0x7da3,0x7db5,0x7dc7,0x7dbd,0x7dab,
/* 0xe360 - 0xe367 */ 0x7e3d,0x7da2,0x7daf,0x7ddc,0x7db8,0x7d9f,0x7db0,0x7dd8,
/* 0xe368 - 0xe36f */ 0x7ddd,0x7de4,0x7dde,0x7dfb,0x7df2,0x7de1,0x7e05,0x7e0a,
/* 0xe370 - 0xe377 */ 0x7e23,0x7e21,0x7e12,0x7e31,0x7e1f,0x7e09,0x7e0b,0x7e22,
/* 0xe378 - 0xe37f */ 0x7e46,0x7e66,0x7e3b,0x7e35,0x7e39,0x7e43,0x7e37,0x0,
/* 0xe380 - 0xe387 */ 0x7e32,0x7e3a,0x7e67,0x7e5d,0x7e56,0x7e5e,0x7e59,0x7e5a,
/* 0xe388 - 0xe38f */ 0x7e79,0x7e6a,0x7e69,0x7e7c,0x7e7b,0x7e83,0x7dd5,0x7e7d,
/* 0xe390 - 0xe397 */ 0x8fae,0x7e7f,0x7e88,0x7e89,0x7e8c,0x7e92,0x7e90,0x7e93,
/* 0xe398 - 0xe39f */ 0x7e94,0x7e96,0x7e8e,0x7e9b,0x7e9c,0x7f38,0x7f3a,0x7f45,
/* 0xe3a0 - 0xe3a7 */ 0x7f4c,0x7f4d,0x7f4e,0x7f50,0x7f51,0x7f55,0x7f54,0x7f58,
/* 0xe3a8 - 0xe3af */ 0x7f5f,0x7f60,0x7f68,0x7f69,0x7f67,0x7f78,0x7f82,0x7f86,
/* 0xe3b0 - 0xe3b7 */ 0x7f83,0x7f88,0x7f87,0x7f8c,0x7f94,0x7f9e,0x7f9d,0x7f9a,
/* 0xe3b8 - 0xe3bf */ 0x7fa3,0x7faf,0x7fb2,0x7fb9,0x7fae,0x7fb6,0x7fb8,0x8b71,
/* 0xe3c0 - 0xe3c7 */ 0x7fc5,0x7fc6,0x7fca,0x7fd5,0x7fd4,0x7fe1,0x7fe6,0x7fe9,
/* 0xe3c8 - 0xe3cf */ 0x7ff3,0x7ff9,0x98dc,0x8006,0x8004,0x800b,0x8012,0x8018,
/* 0xe3d0 - 0xe3d7 */ 0x8019,0x801c,0x8021,0x8028,0x803f,0x803b,0x804a,0x8046,
/* 0xe3d8 - 0xe3df */ 0x8052,0x8058,0x805a,0x805f,0x8062,0x8068,0x8073,0x8072,
/* 0xe3e0 - 0xe3e7 */ 0x8070,0x8076,0x8079,0x807d,0x807f,0x8084,0x8086,0x8085,
/* 0xe3e8 - 0xe3ef */ 0x809b,0x8093,0x809a,0x80ad,0x5190,0x80ac,0x80db,0x80e5,
/* 0xe3f0 - 0xe3f7 */ 0x80d9,0x80dd,0x80c4,0x80da,0x80d6,0x8109,0x80ef,0x80f1,
/* 0xe3f8 - 0xe3ff */ 0x811b,0x8129,0x8123,0x812f,0x814b
}, /* 0xe3 */

{ /* 0xe4 */
/* 0xe440 - 0xe447 */ 0x968b,0x8146,0x813e,0x8153,0x8151,0x80fc,0x8171,0x816e,
/* 0xe448 - 0xe44f */ 0x8165,0x8166,0x8174,0x8183,0x8188,0x818a,0x8180,0x8182,
/* 0xe450 - 0xe457 */ 0x81a0,0x8195,0x81a4,0x81a3,0x815f,0x8193,0x81a9,0x81b0,
/* 0xe458 - 0xe45f */ 0x81b5,0x81be,0x81b8,0x81bd,0x81c0,0x81c2,0x81ba,0x81c9,
/* 0xe460 - 0xe467 */ 0x81cd,0x81d1,0x81d9,0x81d8,0x81c8,0x81da,0x81df,0x81e0,
/* 0xe468 - 0xe46f */ 0x81e7,0x81fa,0x81fb,0x81fe,0x8201,0x8202,0x8205,0x8207,
/* 0xe470 - 0xe477 */ 0x820a,0x820d,0x8210,0x8216,0x8229,0x822b,0x8238,0x8233,
/* 0xe478 - 0xe47f */ 0x8240,0x8259,0x8258,0x825d,0x825a,0x825f,0x8264,0x0,
/* 0xe480 - 0xe487 */ 0x8262,0x8268,0x826a,0x826b,0x822e,0x8271,0x8277,0x8278,
/* 0xe488 - 0xe48f */ 0x827e,0x828d,0x8292,0x82ab,0x829f,0x82bb,0x82ac,0x82e1,
/* 0xe490 - 0xe497 */ 0x82e3,0x82df,0x82d2,0x82f4,0x82f3,0x82fa,0x8393,0x8303,
/* 0xe498 - 0xe49f */ 0x82fb,0x82f9,0x82de,0x8306,0x82dc,0x8309,0x82d9,0x8335,
/* 0xe4a0 - 0xe4a7 */ 0x8334,0x8316,0x8332,0x8331,0x8340,0x8339,0x8350,0x8345,
/* 0xe4a8 - 0xe4af */ 0x832f,0x832b,0x8317,0x8318,0x8385,0x839a,0x83aa,0x839f,
/* 0xe4b0 - 0xe4b7 */ 0x83a2,0x8396,0x8323,0x838e,0x8387,0x838a,0x837c,0x83b5,
/* 0xe4b8 - 0xe4bf */ 0x8373,0x8375,0x83a0,0x8389,0x83a8,0x83f4,0x8413,0x83eb,
/* 0xe4c0 - 0xe4c7 */ 0x83ce,0x83fd,0x8403,0x83d8,0x840b,0x83c1,0x83f7,0x8407,
/* 0xe4c8 - 0xe4cf */ 0x83e0,0x83f2,0x840d,0x8422,0x8420,0x83bd,0x8438,0x8506,
/* 0xe4d0 - 0xe4d7 */ 0x83fb,0x846d,0x842a,0x843c,0x855a,0x8484,0x8477,0x846b,
/* 0xe4d8 - 0xe4df */ 0x84ad,0x846e,0x8482,0x8469,0x8446,0x842c,0x846f,0x8479,
/* 0xe4e0 - 0xe4e7 */ 0x8435,0x84ca,0x8462,0x84b9,0x84bf,0x849f,0x84d9,0x84cd,
/* 0xe4e8 - 0xe4ef */ 0x84bb,0x84da,0x84d0,0x84c1,0x84c6,0x84d6,0x84a1,0x8521,
/* 0xe4f0 - 0xe4f7 */ 0x84ff,0x84f4,0x8517,0x8518,0x852c,0x851f,0x8515,0x8514,
/* 0xe4f8 - 0xe4ff */ 0x84fc,0x8540,0x8563,0x8558,0x8548
}, /* 0xe4 */

{ /* 0xe5 */
/* 0xe540 - 0xe547 */ 0x8541,0x8602,0x854b,0x8555,0x8580,0x85a4,0x8588,0x8591,
/* 0xe548 - 0xe54f */ 0x858a,0x85a8,0x856d,0x8594,0x859b,0x85ea,0x8587,0x859c,
/* 0xe550 - 0xe557 */ 0x8577,0x857e,0x8590,0x85c9,0x85ba,0x85cf,0x85b9,0x85d0,
/* 0xe558 - 0xe55f */ 0x85d5,0x85dd,0x85e5,0x85dc,0x85f9,0x860a,0x8613,0x860b,
/* 0xe560 - 0xe567 */ 0x85fe,0x85fa,0x8606,0x8622,0x861a,0x8630,0x863f,0x864d,
/* 0xe568 - 0xe56f */ 0x4e55,0x8654,0x865f,0x8667,0x8671,0x8693,0x86a3,0x86a9,
/* 0xe570 - 0xe577 */ 0x86aa,0x868b,0x868c,0x86b6,0x86af,0x86c4,0x86c6,0x86b0,
/* 0xe578 - 0xe57f */ 0x86c9,0x8823,0x86ab,0x86d4,0x86de,0x86e9,0x86ec,0x0,
/* 0xe580 - 0xe587 */ 0x86df,0x86db,0x86ef,0x8712,0x8706,0x8708,0x8700,0x8703,
/* 0xe588 - 0xe58f */ 0x86fb,0x8711,0x8709,0x870d,0x86f9,0x870a,0x8734,0x873f,
/* 0xe590 - 0xe597 */ 0x8737,0x873b,0x8725,0x8729,0x871a,0x8760,0x875f,0x8778,
/* 0xe598 - 0xe59f */ 0x874c,0x874e,0x8774,0x8757,0x8768,0x876e,0x8759,0x8753,
/* 0xe5a0 - 0xe5a7 */ 0x8763,0x876a,0x8805,0x87a2,0x879f,0x8782,0x87af,0x87cb,
/* 0xe5a8 - 0xe5af */ 0x87bd,0x87c0,0x87d0,0x96d6,0x87ab,0x87c4,0x87b3,0x87c7,
/* 0xe5b0 - 0xe5b7 */ 0x87c6,0x87bb,0x87ef,0x87f2,0x87e0,0x880f,0x880d,0x87fe,
/* 0xe5b8 - 0xe5bf */ 0x87f6,0x87f7,0x880e,0x87d2,0x8811,0x8816,0x8815,0x8822,
/* 0xe5c0 - 0xe5c7 */ 0x8821,0x8831,0x8836,0x8839,0x8827,0x883b,0x8844,0x8842,
/* 0xe5c8 - 0xe5cf */ 0x8852,0x8859,0x885e,0x8862,0x886b,0x8881,0x887e,0x889e,
/* 0xe5d0 - 0xe5d7 */ 0x8875,0x887d,0x88b5,0x8872,0x8882,0x8897,0x8892,0x88ae,
/* 0xe5d8 - 0xe5df */ 0x8899,0x88a2,0x888d,0x88a4,0x88b0,0x88bf,0x88b1,0x88c3,
/* 0xe5e0 - 0xe5e7 */ 0x88c4,0x88d4,0x88d8,0x88d9,0x88dd,0x88f9,0x8902,0x88fc,
/* 0xe5e8 - 0xe5ef */ 0x88f4,0x88e8,0x88f2,0x8904,0x890c,0x890a,0x8913,0x8943,
/* 0xe5f0 - 0xe5f7 */ 0x891e,0x8925,0x892a,0x892b,0x8941,0x8944,0x893b,0x8936,
/* 0xe5f8 - 0xe5ff */ 0x8938,0x894c,0x891d,0x8960,0x895e
}, /* 0xe5 */

{ /* 0xe6 */
/* 0xe640 - 0xe647 */ 0x8966,0x8964,0x896d,0x896a,0x896f,0x8974,0x8977,0x897e,
/* 0xe648 - 0xe64f */ 0x8983,0x8988,0x898a,0x8993,0x8998,0x89a1,0x89a9,0x89a6,
/* 0xe650 - 0xe657 */ 0x89ac,0x89af,0x89b2,0x89ba,0x89bd,0x89bf,0x89c0,0x89da,
/* 0xe658 - 0xe65f */ 0x89dc,0x89dd,0x89e7,0x89f4,0x89f8,0x8a03,0x8a16,0x8a10,
/* 0xe660 - 0xe667 */ 0x8a0c,0x8a1b,0x8a1d,0x8a25,0x8a36,0x8a41,0x8a5b,0x8a52,
/* 0xe668 - 0xe66f */ 0x8a46,0x8a48,0x8a7c,0x8a6d,0x8a6c,0x8a62,0x8a85,0x8a82,
/* 0xe670 - 0xe677 */ 0x8a84,0x8aa8,0x8aa1,0x8a91,0x8aa5,0x8aa6,0x8a9a,0x8aa3,
/* 0xe678 - 0xe67f */ 0x8ac4,0x8acd,0x8ac2,0x8ada,0x8aeb,0x8af3,0x8ae7,0x0,
/* 0xe680 - 0xe687 */ 0x8ae4,0x8af1,0x8b14,0x8ae0,0x8ae2,0x8af7,0x8ade,0x8adb,
/* 0xe688 - 0xe68f */ 0x8b0c,0x8b07,0x8b1a,0x8ae1,0x8b16,0x8b10,0x8b17,0x8b20,
/* 0xe690 - 0xe697 */ 0x8b33,0x97ab,0x8b26,0x8b2b,0x8b3e,0x8b28,0x8b41,0x8b4c,
/* 0xe698 - 0xe69f */ 0x8b4f,0x8b4e,0x8b49,0x8b56,0x8b5b,0x8b5a,0x8b6b,0x8b5f,
/* 0xe6a0 - 0xe6a7 */ 0x8b6c,0x8b6f,0x8b74,0x8b7d,0x8b80,0x8b8c,0x8b8e,0x8b92,
/* 0xe6a8 - 0xe6af */ 0x8b93,0x8b96,0x8b99,0x8b9a,0x8c3a,0x8c41,0x8c3f,0x8c48,
/* 0xe6b0 - 0xe6b7 */ 0x8c4c,0x8c4e,0x8c50,0x8c55,0x8c62,0x8c6c,0x8c78,0x8c7a,
/* 0xe6b8 - 0xe6bf */ 0x8c82,0x8c89,0x8c85,0x8c8a,0x8c8d,0x8c8e,0x8c94,0x8c7c,
/* 0xe6c0 - 0xe6c7 */ 0x8c98,0x621d,0x8cad,0x8caa,0x8cbd,0x8cb2,0x8cb3,0x8cae,
/* 0xe6c8 - 0xe6cf */ 0x8cb6,0x8cc8,0x8cc1,0x8ce4,0x8ce3,0x8cda,0x8cfd,0x8cfa,
/* 0xe6d0 - 0xe6d7 */ 0x8cfb,0x8d04,0x8d05,0x8d0a,0x8d07,0x8d0f,0x8d0d,0x8d10,
/* 0xe6d8 - 0xe6df */ 0x9f4e,0x8d13,0x8ccd,0x8d14,0x8d16,0x8d67,0x8d6d,0x8d71,
/* 0xe6e0 - 0xe6e7 */ 0x8d73,0x8d81,0x8d99,0x8dc2,0x8dbe,0x8dba,0x8dcf,0x8dda,
/* 0xe6e8 - 0xe6ef */ 0x8dd6,0x8dcc,0x8ddb,0x8dcb,0x8dea,0x8deb,0x8ddf,0x8de3,
/* 0xe6f0 - 0xe6f7 */ 0x8dfc,0x8e08,0x8e09,0x8dff,0x8e1d,0x8e1e,0x8e10,0x8e1f,
/* 0xe6f8 - 0xe6ff */ 0x8e42,0x8e35,0x8e30,0x8e34,0x8e4a
}, /* 0xe6 */

{ /* 0xe7 */
/* 0xe740 - 0xe747 */ 0x8e47,0x8e49,0x8e4c,0x8e50,0x8e48,0x8e59,0x8e64,0x8e60,
/* 0xe748 - 0xe74f */ 0x8e2a,0x8e63,0x8e55,0x8e76,0x8e72,0x8e7c,0x8e81,0x8e87,
/* 0xe750 - 0xe757 */ 0x8e85,0x8e84,0x8e8b,0x8e8a,0x8e93,0x8e91,0x8e94,0x8e99,
/* 0xe758 - 0xe75f */ 0x8eaa,0x8ea1,0x8eac,0x8eb0,0x8ec6,0x8eb1,0x8ebe,0x8ec5,
/* 0xe760 - 0xe767 */ 0x8ec8,0x8ecb,0x8edb,0x8ee3,0x8efc,0x8efb,0x8eeb,0x8efe,
/* 0xe768 - 0xe76f */ 0x8f0a,0x8f05,0x8f15,0x8f12,0x8f19,0x8f13,0x8f1c,0x8f1f,
/* 0xe770 - 0xe777 */ 0x8f1b,0x8f0c,0x8f26,0x8f33,0x8f3b,0x8f39,0x8f45,0x8f42,
/* 0xe778 - 0xe77f */ 0x8f3e,0x8f4c,0x8f49,0x8f46,0x8f4e,0x8f57,0x8f5c,0x0,
/* 0xe780 - 0xe787 */ 0x8f62,0x8f63,0x8f64,0x8f9c,0x8f9f,0x8fa3,0x8fad,0x8faf,
/* 0xe788 - 0xe78f */ 0x8fb7,0x8fda,0x8fe5,0x8fe2,0x8fea,0x8fef,0x9087,0x8ff4,
/* 0xe790 - 0xe797 */ 0x9005,0x8ff9,0x8ffa,0x9011,0x9015,0x9021,0x900d,0x901e,
/* 0xe798 - 0xe79f */ 0x9016,0x900b,0x9027,0x9036,0x9035,0x9039,0x8ff8,0x904f,
/* 0xe7a0 - 0xe7a7 */ 0x9050,0x9051,0x9052,0x900e,0x9049,0x903e,0x9056,0x9058,
/* 0xe7a8 - 0xe7af */ 0x905e,0x9068,0x906f,0x9076,0x96a8,0x9072,0x9082,0x907d,
/* 0xe7b0 - 0xe7b7 */ 0x9081,0x9080,0x908a,0x9089,0x908f,0x90a8,0x90af,0x90b1,
/* 0xe7b8 - 0xe7bf */ 0x90b5,0x90e2,0x90e4,0x6248,0x90db,0x9102,0x9112,0x9119,
/* 0xe7c0 - 0xe7c7 */ 0x9132,0x9130,0x914a,0x9156,0x9158,0x9163,0x9165,0x9169,
/* 0xe7c8 - 0xe7cf */ 0x9173,0x9172,0x918b,0x9189,0x9182,0x91a2,0x91ab,0x91af,
/* 0xe7d0 - 0xe7d7 */ 0x91aa,0x91b5,0x91b4,0x91ba,0x91c0,0x91c1,0x91c9,0x91cb,
/* 0xe7d8 - 0xe7df */ 0x91d0,0x91d6,0x91df,0x91e1,0x91db,0x91fc,0x91f5,0x91f6,
/* 0xe7e0 - 0xe7e7 */ 0x921e,0x91ff,0x9214,0x922c,0x9215,0x9211,0x925e,0x9257,
/* 0xe7e8 - 0xe7ef */ 0x9245,0x9249,0x9264,0x9248,0x9295,0x923f,0x924b,0x9250,
/* 0xe7f0 - 0xe7f7 */ 0x929c,0x9296,0x9293,0x929b,0x925a,0x92cf,0x92b9,0x92b7,
/* 0xe7f8 - 0xe7ff */ 0x92e9,0x930f,0x92fa,0x9344,0x932e
}, /* 0xe7 */

{ /* 0xe8 */
/* 0xe840 - 0xe847 */ 0x9319,0x9322,0x931a,0x9323,0x933a,0x9335,0x933b,0x935c,
/* 0xe848 - 0xe84f */ 0x9360,0x937c,0x936e,0x9356,0x93b0,0x93ac,0x93ad,0x9394,
/* 0xe850 - 0xe857 */ 0x93b9,0x93d6,0x93d7,0x93e8,0x93e5,0x93d8,0x93c3,0x93dd,
/* 0xe858 - 0xe85f */ 0x93d0,0x93c8,0x93e4,0x941a,0x9414,0x9413,0x9403,0x9407,
/* 0xe860 - 0xe867 */ 0x9410,0x9436,0x942b,0x9435,0x9421,0x943a,0x9441,0x9452,
/* 0xe868 - 0xe86f */ 0x9444,0x945b,0x9460,0x9462,0x945e,0x946a,0x9229,0x9470,
/* 0xe870 - 0xe877 */ 0x9475,0x9477,0x947d,0x945a,0x947c,0x947e,0x9481,0x947f,
/* 0xe878 - 0xe87f */ 0x9582,0x9587,0x958a,0x9594,0x9596,0x9598,0x9599,0x0,
/* 0xe880 - 0xe887 */ 0x95a0,0x95a8,0x95a7,0x95ad,0x95bc,0x95bb,0x95b9,0x95be,
/* 0xe888 - 0xe88f */ 0x95ca,0x6ff6,0x95c3,0x95cd,0x95cc,0x95d5,0x95d4,0x95d6,
/* 0xe890 - 0xe897 */ 0x95dc,0x95e1,0x95e5,0x95e2,0x9621,0x9628,0x962e,0x962f,
/* 0xe898 - 0xe89f */ 0x9642,0x964c,0x964f,0x964b,0x9677,0x965c,0x965e,0x965d,
/* 0xe8a0 - 0xe8a7 */ 0x965f,0x9666,0x9672,0x966c,0x968d,0x9698,0x9695,0x9697,
/* 0xe8a8 - 0xe8af */ 0x96aa,0x96a7,0x96b1,0x96b2,0x96b0,0x96b4,0x96b6,0x96b8,
/* 0xe8b0 - 0xe8b7 */ 0x96b9,0x96ce,0x96cb,0x96c9,0x96cd,0x894d,0x96dc,0x970d,
/* 0xe8b8 - 0xe8bf */ 0x96d5,0x96f9,0x9704,0x9706,0x9708,0x9713,0x970e,0x9711,
/* 0xe8c0 - 0xe8c7 */ 0x970f,0x9716,0x9719,0x9724,0x972a,0x9730,0x9739,0x973d,
/* 0xe8c8 - 0xe8cf */ 0x973e,0x9744,0x9746,0x9748,0x9742,0x9749,0x975c,0x9760,
/* 0xe8d0 - 0xe8d7 */ 0x9764,0x9766,0x9768,0x52d2,0x976b,0x9771,0x9779,0x9785,
/* 0xe8d8 - 0xe8df */ 0x977c,0x9781,0x977a,0x9786,0x978b,0x978f,0x9790,0x979c,
/* 0xe8e0 - 0xe8e7 */ 0x97a8,0x97a6,0x97a3,0x97b3,0x97b4,0x97c3,0x97c6,0x97c8,
/* 0xe8e8 - 0xe8ef */ 0x97cb,0x97dc,0x97ed,0x9f4f,0x97f2,0x7adf,0x97f6,0x97f5,
/* 0xe8f0 - 0xe8f7 */ 0x980f,0x980c,0x9838,0x9824,0x9821,0x9837,0x983d,0x9846,
/* 0xe8f8 - 0xe8ff */ 0x984f,0x984b,0x986b,0x986f,0x9870
}, /* 0xe8 */

{ /* 0xe9 */
/* 0xe940 - 0xe947 */ 0x9871,0x9874,0x9873,0x98aa,0x98af,0x98b1,0x98b6,0x98c4,
/* 0xe948 - 0xe94f */ 0x98c3,0x98c6,0x98e9,0x98eb,0x9903,0x9909,0x9912,0x9914,
/* 0xe950 - 0xe957 */ 0x9918,0x9921,0x991d,0x991e,0x9924,0x9920,0x992c,0x992e,
/* 0xe958 - 0xe95f */ 0x993d,0x993e,0x9942,0x9949,0x9945,0x9950,0x994b,0x9951,
/* 0xe960 - 0xe967 */ 0x9952,0x994c,0x9955,0x9997,0x9998,0x99a5,0x99ad,0x99ae,
/* 0xe968 - 0xe96f */ 0x99bc,0x99df,0x99db,0x99dd,0x99d8,0x99d1,0x99ed,0x99ee,
/* 0xe970 - 0xe977 */ 0x99f1,0x99f2,0x99fb,0x99f8,0x9a01,0x9a0f,0x9a05,0x99e2,
/* 0xe978 - 0xe97f */ 0x9a19,0x9a2b,0x9a37,0x9a45,0x9a42,0x9a40,0x9a43,0x0,
/* 0xe980 - 0xe987 */ 0x9a3e,0x9a55,0x9a4d,0x9a5b,0x9a57,0x9a5f,0x9a62,0x9a65,
/* 0xe988 - 0xe98f */ 0x9a64,0x9a69,0x9a6b,0x9a6a,0x9aad,0x9ab0,0x9abc,0x9ac0,
/* 0xe990 - 0xe997 */ 0x9acf,0x9ad1,0x9ad3,0x9ad4,0x9ade,0x9adf,0x9ae2,0x9ae3,
/* 0xe998 - 0xe99f */ 0x9ae6,0x9aef,0x9aeb,0x9aee,0x9af4,0x9af1,0x9af7,0x9afb,
/* 0xe9a0 - 0xe9a7 */ 0x9b06,0x9b18,0x9b1a,0x9b1f,0x9b22,0x9b23,0x9b25,0x9b27,
/* 0xe9a8 - 0xe9af */ 0x9b28,0x9b29,0x9b2a,0x9b2e,0x9b2f,0x9b32,0x9b44,0x9b43,
/* 0xe9b0 - 0xe9b7 */ 0x9b4f,0x9b4d,0x9b4e,0x9b51,0x9b58,0x9b74,0x9b93,0x9b83,
/* 0xe9b8 - 0xe9bf */ 0x9b91,0x9b96,0x9b97,0x9b9f,0x9ba0,0x9ba8,0x9bb4,0x9bc0,
/* 0xe9c0 - 0xe9c7 */ 0x9bca,0x9bb9,0x9bc6,0x9bcf,0x9bd1,0x9bd2,0x9be3,0x9be2,
/* 0xe9c8 - 0xe9cf */ 0x9be4,0x9bd4,0x9be1,0x9c3a,0x9bf2,0x9bf1,0x9bf0,0x9c15,
/* 0xe9d0 - 0xe9d7 */ 0x9c14,0x9c09,0x9c13,0x9c0c,0x9c06,0x9c08,0x9c12,0x9c0a,
/* 0xe9d8 - 0xe9df */ 0x9c04,0x9c2e,0x9c1b,0x9c25,0x9c24,0x9c21,0x9c30,0x9c47,
/* 0xe9e0 - 0xe9e7 */ 0x9c32,0x9c46,0x9c3e,0x9c5a,0x9c60,0x9c67,0x9c76,0x9c78,
/* 0xe9e8 - 0xe9ef */ 0x9ce7,0x9cec,0x9cf0,0x9d09,0x9d08,0x9ceb,0x9d03,0x9d06,
/* 0xe9f0 - 0xe9f7 */ 0x9d2a,0x9d26,0x9daf,0x9d23,0x9d1f,0x9d44,0x9d15,0x9d12,
/* 0xe9f8 - 0xe9ff */ 0x9d41,0x9d3f,0x9d3e,0x9d46,0x9d48
}, /* 0xe9 */

{ /* 0xea */
/* 0xea40 - 0xea47 */ 0x9d5d,0x9d5e,0x9d64,0x9d51,0x9d50,0x9d59,0x9d72,0x9d89,
/* 0xea48 - 0xea4f */ 0x9d87,0x9dab,0x9d6f,0x9d7a,0x9d9a,0x9da4,0x9da9,0x9db2,
/* 0xea50 - 0xea57 */ 0x9dc4,0x9dc1,0x9dbb,0x9db8,0x9dba,0x9dc6,0x9dcf,0x9dc2,
/* 0xea58 - 0xea5f */ 0x9dd9,0x9dd3,0x9df8,0x9de6,0x9ded,0x9def,0x9dfd,0x9e1a,
/* 0xea60 - 0xea67 */ 0x9e1b,0x9e1e,0x9e75,0x9e79,0x9e7d,0x9e81,0x9e88,0x9e8b,
/* 0xea68 - 0xea6f */ 0x9e8c,0x9e92,0x9e95,0x9e91,0x9e9d,0x9ea5,0x9ea9,0x9eb8,
/* 0xea70 - 0xea77 */ 0x9eaa,0x9ead,0x9761,0x9ecc,0x9ece,0x9ecf,0x9ed0,0x9ed4,
/* 0xea78 - 0xea7f */ 0x9edc,0x9ede,0x9edd,0x9ee0,0x9ee5,0x9ee8,0x9eef,0x0,
/* 0xea80 - 0xea87 */ 0x9ef4,0x9ef6,0x9ef7,0x9ef9,0x9efb,0x9efc,0x9efd,0x9f07,
/* 0xea88 - 0xea8f */ 0x9f08,0x76b7,0x9f15,0x9f21,0x9f2c,0x9f3e,0x9f4a,0x9f52,
/* 0xea90 - 0xea97 */ 0x9f54,0x9f63,0x9f5f,0x9f60,0x9f61,0x9f66,0x9f67,0x9f6c,
/* 0xea98 - 0xea9f */ 0x9f6a,0x9f77,0x9f72,0x9f76,0x9f95,0x9f9c,0x9fa0,0x582f,
/* 0xeaa0 - 0xeaa7 */ 0x69c7,0x9059,0x7464,0x51dc,0x7199,0x0,0x0,0x0,
/* 0xeaa8 - 0xeaaf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeab0 - 0xeab7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeab8 - 0xeabf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeac0 - 0xeac7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeac8 - 0xeacf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xead0 - 0xead7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xead8 - 0xeadf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeae0 - 0xeae7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeae8 - 0xeaef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeaf0 - 0xeaf7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeaf8 - 0xeaff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0xea */

{ /* 0xeb */
/* 0xeb40 - 0xeb47 */ 0xeac8,0xeac9,0xeaca,0xeacb,0xeacc,0xeacd,0xeace,0xeacf,
/* 0xeb48 - 0xeb4f */ 0xead0,0xead1,0xead2,0xead3,0xead4,0xead5,0xead6,0xead7,
/* 0xeb50 - 0xeb57 */ 0xead8,0xead9,0xeada,0xeadb,0xeadc,0xeadd,0xeade,0xeadf,
/* 0xeb58 - 0xeb5f */ 0xeae0,0xeae1,0xeae2,0xeae3,0xeae4,0xeae5,0xeae6,0xeae7,
/* 0xeb60 - 0xeb67 */ 0xeae8,0xeae9,0xeaea,0xeaeb,0xeaec,0xeaed,0xeaee,0xeaef,
/* 0xeb68 - 0xeb6f */ 0xeaf0,0xeaf1,0xeaf2,0xeaf3,0xeaf4,0xeaf5,0xeaf6,0xeaf7,
/* 0xeb70 - 0xeb77 */ 0xeaf8,0xeaf9,0xeafa,0xeafb,0xeafc,0xeafd,0xeafe,0xeaff,
/* 0xeb78 - 0xeb7f */ 0xeb00,0xeb01,0xeb02,0xeb03,0xeb04,0xeb05,0xeb06,0x0,
/* 0xeb80 - 0xeb87 */ 0xeb07,0xeb08,0xeb09,0xeb0a,0xeb0b,0xeb0c,0xeb0d,0xeb0e,
/* 0xeb88 - 0xeb8f */ 0xeb0f,0xeb10,0xeb11,0xeb12,0xeb13,0xeb14,0xeb15,0xeb16,
/* 0xeb90 - 0xeb97 */ 0xeb17,0xeb18,0xeb19,0xeb1a,0xeb1b,0xeb1c,0xeb1d,0xeb1e,
/* 0xeb98 - 0xeb9f */ 0xeb1f,0xeb20,0xeb21,0xeb22,0xeb23,0xeb24,0xeb25,0xeb26,
/* 0xeba0 - 0xeba7 */ 0xeb27,0xeb28,0xeb29,0xeb2a,0xeb2b,0xeb2c,0xeb2d,0xeb2e,
/* 0xeba8 - 0xebaf */ 0xeb2f,0xeb30,0xeb31,0xeb32,0xeb33,0xeb34,0xeb35,0xeb36,
/* 0xebb0 - 0xebb7 */ 0xeb37,0xeb38,0xeb39,0xeb3a,0xeb3b,0xeb3c,0xeb3d,0xeb3e,
/* 0xebb8 - 0xebbf */ 0xeb3f,0xeb40,0xeb41,0xeb42,0xeb43,0xeb44,0xeb45,0xeb46,
/* 0xebc0 - 0xebc7 */ 0xeb47,0xeb48,0xeb49,0xeb4a,0xeb4b,0xeb4c,0xeb4d,0xeb4e,
/* 0xebc8 - 0xebcf */ 0xeb4f,0xeb50,0xeb51,0xeb52,0xeb53,0xeb54,0xeb55,0xeb56,
/* 0xebd0 - 0xebd7 */ 0xeb57,0xeb58,0xeb59,0xeb5a,0xeb5b,0xeb5c,0xeb5d,0xeb5e,
/* 0xebd8 - 0xebdf */ 0xeb5f,0xeb60,0xeb61,0xeb62,0xeb63,0xeb64,0xeb65,0xeb66,
/* 0xebe0 - 0xebe7 */ 0xeb67,0xeb68,0xeb69,0xeb6a,0xeb6b,0xeb6c,0xeb6d,0xeb6e,
/* 0xebe8 - 0xebef */ 0xeb6f,0xeb70,0xeb71,0xeb72,0xeb73,0xeb74,0xeb75,0xeb76,
/* 0xebf0 - 0xebf7 */ 0xeb77,0xeb78,0xeb79,0xeb7a,0xeb7b,0xeb7c,0xeb7d,0xeb7e,
/* 0xebf8 - 0xebff */ 0xeb7f,0xeb80,0xeb81,0xeb82,0xeb83
}, /* 0xeb */

{ /* 0xec */
/* 0xec40 - 0xec47 */ 0xeb84,0xeb85,0xeb86,0xeb87,0xeb88,0xeb89,0xeb8a,0xeb8b,
/* 0xec48 - 0xec4f */ 0xeb8c,0xeb8d,0xeb8e,0xeb8f,0xeb90,0xeb91,0xeb92,0xeb93,
/* 0xec50 - 0xec57 */ 0xeb94,0xeb95,0xeb96,0xeb97,0xeb98,0xeb99,0xeb9a,0xeb9b,
/* 0xec58 - 0xec5f */ 0xeb9c,0xeb9d,0xeb9e,0xeb9f,0xeba0,0xeba1,0xeba2,0xeba3,
/* 0xec60 - 0xec67 */ 0xeba4,0xeba5,0xeba6,0xeba7,0xeba8,0xeba9,0xebaa,0xebab,
/* 0xec68 - 0xec6f */ 0xebac,0xebad,0xebae,0xebaf,0xebb0,0xebb1,0xebb2,0xebb3,
/* 0xec70 - 0xec77 */ 0xebb4,0xebb5,0xebb6,0xebb7,0xebb8,0xebb9,0xebba,0xebbb,
/* 0xec78 - 0xec7f */ 0xebbc,0xebbd,0xebbe,0xebbf,0xebc0,0xebc1,0xebc2,0x0,
/* 0xec80 - 0xec87 */ 0xebc3,0xebc4,0xebc5,0xebc6,0xebc7,0xebc8,0xebc9,0xebca,
/* 0xec88 - 0xec8f */ 0xebcb,0xebcc,0xebcd,0xebce,0xebcf,0xebd0,0xebd1,0xebd2,
/* 0xec90 - 0xec97 */ 0xebd3,0xebd4,0xebd5,0xebd6,0xebd7,0xebd8,0xebd9,0xebda,
/* 0xec98 - 0xec9f */ 0xebdb,0xebdc,0xebdd,0xebde,0xebdf,0xebe0,0xebe1,0xebe2,
/* 0xeca0 - 0xeca7 */ 0xebe3,0xebe4,0xebe5,0xebe6,0xebe7,0xebe8,0xebe9,0xebea,
/* 0xeca8 - 0xecaf */ 0xebeb,0xebec,0xebed,0xebee,0xebef,0xebf0,0xebf1,0xebf2,
/* 0xecb0 - 0xecb7 */ 0xebf3,0xebf4,0xebf5,0xebf6,0xebf7,0xebf8,0xebf9,0xebfa,
/* 0xecb8 - 0xecbf */ 0xebfb,0xebfc,0xebfd,0xebfe,0xebff,0xec00,0xec01,0xec02,
/* 0xecc0 - 0xecc7 */ 0xec03,0xec04,0xec05,0xec06,0xec07,0xec08,0xec09,0xec0a,
/* 0xecc8 - 0xeccf */ 0xec0b,0xec0c,0xec0d,0xec0e,0xec0f,0xec10,0xec11,0xec12,
/* 0xecd0 - 0xecd7 */ 0xec13,0xec14,0xec15,0xec16,0xec17,0xec18,0xec19,0xec1a,
/* 0xecd8 - 0xecdf */ 0xec1b,0xec1c,0xec1d,0xec1e,0xec1f,0xec20,0xec21,0xec22,
/* 0xece0 - 0xece7 */ 0xec23,0xec24,0xec25,0xec26,0xec27,0xec28,0xec29,0xec2a,
/* 0xece8 - 0xecef */ 0xec2b,0xec2c,0xec2d,0xec2e,0xec2f,0xec30,0xec31,0xec32,
/* 0xecf0 - 0xecf7 */ 0xec33,0xec34,0xec35,0xec36,0xec37,0xec38,0xec39,0xec3a,
/* 0xecf8 - 0xecff */ 0xec3b,0xec3c,0xec3d,0xec3e,0xec3f
}, /* 0xec */

{ /* 0xed */
/* 0xed40 - 0xed47 */ 0xec40,0xec41,0xec42,0xec43,0xec44,0xec45,0xec46,0xec47,
/* 0xed48 - 0xed4f */ 0xec48,0xec49,0xec4a,0xec4b,0xec4c,0xec4d,0xec4e,0xec4f,
/* 0xed50 - 0xed57 */ 0xec50,0xec51,0xec52,0xec53,0xec54,0xec55,0xec56,0xec57,
/* 0xed58 - 0xed5f */ 0xec58,0xec59,0xec5a,0xec5b,0xec5c,0xec5d,0xec5e,0xec5f,
/* 0xed60 - 0xed67 */ 0xec60,0xec61,0xec62,0xec63,0xec64,0xec65,0xec66,0xec67,
/* 0xed68 - 0xed6f */ 0xec68,0xec69,0xec6a,0xec6b,0xec6c,0xec6d,0xec6e,0xec6f,
/* 0xed70 - 0xed77 */ 0xec70,0xec71,0xec72,0xec73,0xec74,0xec75,0xec76,0xec77,
/* 0xed78 - 0xed7f */ 0xec78,0xec79,0xec7a,0xec7b,0xec7c,0xec7d,0xec7e,0x0,
/* 0xed80 - 0xed87 */ 0xec7f,0xec80,0xec81,0xec82,0xec83,0xec84,0xec85,0xec86,
/* 0xed88 - 0xed8f */ 0xec87,0xec88,0xec89,0xec8a,0xec8b,0xec8c,0xec8d,0xec8e,
/* 0xed90 - 0xed97 */ 0xec8f,0xec90,0xec91,0xec92,0xec93,0xec94,0xec95,0xec96,
/* 0xed98 - 0xed9f */ 0xec97,0xec98,0xec99,0xec9a,0xec9b,0xec9c,0xec9d,0xec9e,
/* 0xeda0 - 0xeda7 */ 0xec9f,0xeca0,0xeca1,0xeca2,0xeca3,0xeca4,0xeca5,0xeca6,
/* 0xeda8 - 0xedaf */ 0xeca7,0xeca8,0xeca9,0xecaa,0xecab,0xecac,0xecad,0xecae,
/* 0xedb0 - 0xedb7 */ 0xecaf,0xecb0,0xecb1,0xecb2,0xecb3,0xecb4,0xecb5,0xecb6,
/* 0xedb8 - 0xedbf */ 0xecb7,0xecb8,0xecb9,0xecba,0xecbb,0xecbc,0xecbd,0xecbe,
/* 0xedc0 - 0xedc7 */ 0xecbf,0xecc0,0xecc1,0xecc2,0xecc3,0xecc4,0xecc5,0xecc6,
/* 0xedc8 - 0xedcf */ 0xecc7,0xecc8,0xecc9,0xecca,0xeccb,0xeccc,0xeccd,0xecce,
/* 0xedd0 - 0xedd7 */ 0xeccf,0xecd0,0xecd1,0xecd2,0xecd3,0xecd4,0xecd5,0xecd6,
/* 0xedd8 - 0xeddf */ 0xecd7,0xecd8,0xecd9,0xecda,0xecdb,0xecdc,0xecdd,0xecde,
/* 0xede0 - 0xede7 */ 0xecdf,0xece0,0xece1,0xece2,0xece3,0xece4,0xece5,0xece6,
/* 0xede8 - 0xedef */ 0xece7,0xece8,0xece9,0xecea,0xeceb,0xecec,0xeced,0xecee,
/* 0xedf0 - 0xedf7 */ 0xecef,0xecf0,0xecf1,0xecf2,0xecf3,0xecf4,0xecf5,0xecf6,
/* 0xedf8 - 0xedff */ 0xecf7,0xecf8,0xecf9,0xecfa,0xecfb
}, /* 0xed */

{ /* 0xee */
/* 0xee40 - 0xee47 */ 0xecfc,0xecfd,0xecfe,0xecff,0xed00,0xed01,0xed02,0xed03,
/* 0xee48 - 0xee4f */ 0xed04,0xed05,0xed06,0xed07,0xed08,0xed09,0xed0a,0xed0b,
/* 0xee50 - 0xee57 */ 0xed0c,0xed0d,0xed0e,0xed0f,0xed10,0xed11,0xed12,0xed13,
/* 0xee58 - 0xee5f */ 0xed14,0xed15,0xed16,0xed17,0xed18,0xed19,0xed1a,0xed1b,
/* 0xee60 - 0xee67 */ 0xed1c,0xed1d,0xed1e,0xed1f,0xed20,0xed21,0xed22,0xed23,
/* 0xee68 - 0xee6f */ 0xed24,0xed25,0xed26,0xed27,0xed28,0xed29,0xed2a,0xed2b,
/* 0xee70 - 0xee77 */ 0xed2c,0xed2d,0xed2e,0xed2f,0xed30,0xed31,0xed32,0xed33,
/* 0xee78 - 0xee7f */ 0xed34,0xed35,0xed36,0xed37,0xed38,0xed39,0xed3a,0x0,
/* 0xee80 - 0xee87 */ 0xed3b,0xed3c,0xed3d,0xed3e,0xed3f,0xed40,0xed41,0xed42,
/* 0xee88 - 0xee8f */ 0xed43,0xed44,0xed45,0xed46,0xed47,0xed48,0xed49,0xed4a,
/* 0xee90 - 0xee97 */ 0xed4b,0xed4c,0xed4d,0xed4e,0xed4f,0xed50,0xed51,0xed52,
/* 0xee98 - 0xee9f */ 0xed53,0xed54,0xed55,0xed56,0xed57,0xed58,0xed59,0xed5a,
/* 0xeea0 - 0xeea7 */ 0xed5b,0xed5c,0xed5d,0xed5e,0xed5f,0xed60,0xed61,0xed62,
/* 0xeea8 - 0xeeaf */ 0xed63,0xed64,0xed65,0xed66,0xed67,0xed68,0xed69,0xed6a,
/* 0xeeb0 - 0xeeb7 */ 0xed6b,0xed6c,0xed6d,0xed6e,0xed6f,0xed70,0xed71,0xed72,
/* 0xeeb8 - 0xeebf */ 0xed73,0xed74,0xed75,0xed76,0xed77,0xed78,0xed79,0xed7a,
/* 0xeec0 - 0xeec7 */ 0xed7b,0xed7c,0xed7d,0xed7e,0xed7f,0xed80,0xed81,0xed82,
/* 0xeec8 - 0xeecf */ 0xed83,0xed84,0xed85,0xed86,0xed87,0xed88,0xed89,0xed8a,
/* 0xeed0 - 0xeed7 */ 0xed8b,0xed8c,0xed8d,0xed8e,0xed8f,0xed90,0xed91,0xed92,
/* 0xeed8 - 0xeedf */ 0xed93,0xed94,0xed95,0xed96,0xed97,0xed98,0xed99,0xed9a,
/* 0xeee0 - 0xeee7 */ 0xed9b,0xed9c,0xed9d,0xed9e,0xed9f,0xeda0,0xeda1,0xeda2,
/* 0xeee8 - 0xeeef */ 0xeda3,0xeda4,0xeda5,0xeda6,0xeda7,0xeda8,0xeda9,0xedaa,
/* 0xeef0 - 0xeef7 */ 0xedab,0xedac,0xedad,0xedae,0xedaf,0xedb0,0xedb1,0xedb2,
/* 0xeef8 - 0xeeff */ 0xedb3,0xedb4,0xedb5,0xedb6,0xedb7
}, /* 0xee */

{ /* 0xef */
/* 0xef40 - 0xef47 */ 0xedb8,0xedb9,0xedba,0xedbb,0xedbc,0xedbd,0xedbe,0xedbf,
/* 0xef48 - 0xef4f */ 0xedc0,0xedc1,0xedc2,0xedc3,0xedc4,0xedc5,0xedc6,0xedc7,
/* 0xef50 - 0xef57 */ 0xedc8,0xedc9,0xedca,0xedcb,0xedcc,0xedcd,0xedce,0xedcf,
/* 0xef58 - 0xef5f */ 0xedd0,0xedd1,0xedd2,0xedd3,0xedd4,0xedd5,0xedd6,0xedd7,
/* 0xef60 - 0xef67 */ 0xedd8,0xedd9,0xedda,0xeddb,0xeddc,0xeddd,0xedde,0xeddf,
/* 0xef68 - 0xef6f */ 0xede0,0xede1,0xede2,0xede3,0xede4,0xede5,0xede6,0xede7,
/* 0xef70 - 0xef77 */ 0xede8,0xede9,0xedea,0xedeb,0xedec,0xeded,0xedee,0xedef,
/* 0xef78 - 0xef7f */ 0xedf0,0xedf1,0xedf2,0xedf3,0xedf4,0xedf5,0xedf6,0x0,
/* 0xef80 - 0xef87 */ 0xedf7,0xedf8,0xedf9,0xedfa,0xedfb,0xedfc,0xedfd,0xedfe,
/* 0xef88 - 0xef8f */ 0xedff,0xee00,0xee01,0xee02,0xee03,0xee04,0xee05,0xee06,
/* 0xef90 - 0xef97 */ 0xee07,0xee08,0xee09,0xee0a,0xee0b,0xee0c,0xee0d,0xee0e,
/* 0xef98 - 0xef9f */ 0xee0f,0xee10,0xee11,0xee12,0xee13,0xee14,0xee15,0xee16,
/* 0xefa0 - 0xefa7 */ 0xee17,0xee18,0xee19,0xee1a,0xee1b,0xee1c,0xee1d,0xee1e,
/* 0xefa8 - 0xefaf */ 0xee1f,0xee20,0xee21,0xee22,0xee23,0xee24,0xee25,0xee26,
/* 0xefb0 - 0xefb7 */ 0xee27,0xee28,0xee29,0xee2a,0xee2b,0xee2c,0xee2d,0xee2e,
/* 0xefb8 - 0xefbf */ 0xee2f,0xee30,0xee31,0xee32,0xee33,0xee34,0xee35,0xee36,
/* 0xefc0 - 0xefc7 */ 0xee37,0xee38,0xee39,0xee3a,0xee3b,0xee3c,0xee3d,0xee3e,
/* 0xefc8 - 0xefcf */ 0xee3f,0xee40,0xee41,0xee42,0xee43,0xee44,0xee45,0xee46,
/* 0xefd0 - 0xefd7 */ 0xee47,0xee48,0xee49,0xee4a,0xee4b,0xee4c,0xee4d,0xee4e,
/* 0xefd8 - 0xefdf */ 0xee4f,0xee50,0xee51,0xee52,0xee53,0xee54,0xee55,0xee56,
/* 0xefe0 - 0xefe7 */ 0xee57,0xee58,0xee59,0xee5a,0xee5b,0xee5c,0xee5d,0xee5e,
/* 0xefe8 - 0xefef */ 0xee5f,0xee60,0xee61,0xee62,0xee63,0xee64,0xee65,0xee66,
/* 0xeff0 - 0xeff7 */ 0xee67,0xee68,0xee69,0xee6a,0xee6b,0xee6c,0xee6d,0xee6e,
/* 0xeff8 - 0xefff */ 0xee6f,0xee70,0xee71,0xee72,0xee73
}, /* 0xef */

{ /* 0xf0 */
/* 0xf040 - 0xf047 */ 0xee74,0xee75,0xee76,0xee77,0xee78,0xee79,0xee7a,0xee7b,
/* 0xf048 - 0xf04f */ 0xee7c,0xee7d,0xee7e,0xee7f,0xee80,0xee81,0xee82,0xee83,
/* 0xf050 - 0xf057 */ 0xee84,0xee85,0xee86,0xee87,0xee88,0xee89,0xee8a,0xee8b,
/* 0xf058 - 0xf05f */ 0xee8c,0xee8d,0xee8e,0xee8f,0xee90,0xee91,0xee92,0xee93,
/* 0xf060 - 0xf067 */ 0xee94,0xee95,0xee96,0xee97,0xee98,0xee99,0xee9a,0xee9b,
/* 0xf068 - 0xf06f */ 0xee9c,0xee9d,0xee9e,0xee9f,0xeea0,0xeea1,0xeea2,0xeea3,
/* 0xf070 - 0xf077 */ 0xeea4,0xeea5,0xeea6,0xeea7,0xeea8,0xeea9,0xeeaa,0xeeab,
/* 0xf078 - 0xf07f */ 0xeeac,0xeead,0xeeae,0xeeaf,0xeeb0,0xeeb1,0xeeb2,0x0,
/* 0xf080 - 0xf087 */ 0xeeb3,0xeeb4,0xeeb5,0xeeb6,0xeeb7,0xeeb8,0xeeb9,0xeeba,
/* 0xf088 - 0xf08f */ 0xeebb,0xeebc,0xeebd,0xeebe,0xeebf,0xeec0,0xeec1,0xeec2,
/* 0xf090 - 0xf097 */ 0xeec3,0xeec4,0xeec5,0xeec6,0xeec7,0xeec8,0xeec9,0xeeca,
/* 0xf098 - 0xf09f */ 0xeecb,0xeecc,0xeecd,0xeece,0xeecf,0xeed0,0xeed1,0xeed2,
/* 0xf0a0 - 0xf0a7 */ 0xeed3,0xeed4,0xeed5,0xeed6,0xeed7,0xeed8,0xeed9,0xeeda,
/* 0xf0a8 - 0xf0af */ 0xeedb,0xeedc,0xeedd,0xeede,0xeedf,0xeee0,0xeee1,0xeee2,
/* 0xf0b0 - 0xf0b7 */ 0xeee3,0xeee4,0xeee5,0xeee6,0xeee7,0xeee8,0xeee9,0xeeea,
/* 0xf0b8 - 0xf0bf */ 0xeeeb,0xeeec,0xeeed,0xeeee,0xeeef,0xeef0,0xeef1,0xeef2,
/* 0xf0c0 - 0xf0c7 */ 0xeef3,0xeef4,0xeef5,0xeef6,0xeef7,0xeef8,0xeef9,0xeefa,
/* 0xf0c8 - 0xf0cf */ 0xeefb,0xeefc,0xeefd,0xeefe,0xeeff,0xef00,0xef01,0xef02,
/* 0xf0d0 - 0xf0d7 */ 0xef03,0xef04,0xef05,0xef06,0xef07,0xef08,0xef09,0xef0a,
/* 0xf0d8 - 0xf0df */ 0xef0b,0xef0c,0xef0d,0xef0e,0xef0f,0xef10,0xef11,0xef12,
/* 0xf0e0 - 0xf0e7 */ 0xef13,0xef14,0xef15,0xef16,0xef17,0xef18,0xef19,0xef1a,
/* 0xf0e8 - 0xf0ef */ 0xef1b,0xef1c,0xef1d,0xef1e,0xef1f,0xef20,0xef21,0xef22,
/* 0xf0f0 - 0xf0f7 */ 0xef23,0xef24,0xef25,0xef26,0xef27,0xef28,0xef29,0xef2a,
/* 0xf0f8 - 0xf0ff */ 0xef2b,0xef2c,0xef2d,0xef2e,0xef2f
}, /* 0xf0 */

{ /* 0xf1 */
/* 0xf140 - 0xf147 */ 0xef30,0xef31,0xef32,0xef33,0xef34,0xef35,0xef36,0xef37,
/* 0xf148 - 0xf14f */ 0xef38,0xef39,0xef3a,0xef3b,0xef3c,0xef3d,0xef3e,0xef3f,
/* 0xf150 - 0xf157 */ 0xef40,0xef41,0xef42,0xef43,0xef44,0xef45,0xef46,0xef47,
/* 0xf158 - 0xf15f */ 0xef48,0xef49,0xef4a,0xef4b,0xef4c,0xef4d,0xef4e,0xef4f,
/* 0xf160 - 0xf167 */ 0xef50,0xef51,0xef52,0xef53,0xef54,0xef55,0xef56,0xef57,
/* 0xf168 - 0xf16f */ 0xef58,0xef59,0xef5a,0xef5b,0xef5c,0xef5d,0xef5e,0xef5f,
/* 0xf170 - 0xf177 */ 0xef60,0xef61,0xef62,0xef63,0xef64,0xef65,0xef66,0xef67,
/* 0xf178 - 0xf17f */ 0xef68,0xef69,0xef6a,0xef6b,0xef6c,0xef6d,0xef6e,0x0,
/* 0xf180 - 0xf187 */ 0xef6f,0xef70,0xef71,0xef72,0xef73,0xef74,0xef75,0xef76,
/* 0xf188 - 0xf18f */ 0xef77,0xef78,0xef79,0xef7a,0xef7b,0xef7c,0xef7d,0xef7e,
/* 0xf190 - 0xf197 */ 0xef7f,0xef80,0xef81,0xef82,0xef83,0xef84,0xef85,0xef86,
/* 0xf198 - 0xf19f */ 0xef87,0xef88,0xef89,0xef8a,0xef8b,0xef8c,0xef8d,0xef8e,
/* 0xf1a0 - 0xf1a7 */ 0xef8f,0xef90,0xef91,0xef92,0xef93,0xef94,0xef95,0xef96,
/* 0xf1a8 - 0xf1af */ 0xef97,0xef98,0xef99,0xef9a,0xef9b,0xef9c,0xef9d,0xef9e,
/* 0xf1b0 - 0xf1b7 */ 0xef9f,0xefa0,0xefa1,0xefa2,0xefa3,0xefa4,0xefa5,0xefa6,
/* 0xf1b8 - 0xf1bf */ 0xefa7,0xefa8,0xefa9,0xefaa,0xefab,0xefac,0xefad,0xefae,
/* 0xf1c0 - 0xf1c7 */ 0xefaf,0xefb0,0xefb1,0xefb2,0xefb3,0xefb4,0xefb5,0xefb6,
/* 0xf1c8 - 0xf1cf */ 0xefb7,0xefb8,0xefb9,0xefba,0xefbb,0xefbc,0xefbd,0xefbe,
/* 0xf1d0 - 0xf1d7 */ 0xefbf,0xefc0,0xefc1,0xefc2,0xefc3,0xefc4,0xefc5,0xefc6,
/* 0xf1d8 - 0xf1df */ 0xefc7,0xefc8,0xefc9,0xefca,0xefcb,0xefcc,0xefcd,0xefce,
/* 0xf1e0 - 0xf1e7 */ 0xefcf,0xefd0,0xefd1,0xefd2,0xefd3,0xefd4,0xefd5,0xefd6,
/* 0xf1e8 - 0xf1ef */ 0xefd7,0xefd8,0xefd9,0xefda,0xefdb,0xefdc,0xefdd,0xefde,
/* 0xf1f0 - 0xf1f7 */ 0xefdf,0xefe0,0xefe1,0xefe2,0xefe3,0xefe4,0xefe5,0xefe6,
/* 0xf1f8 - 0xf1ff */ 0xefe7,0xefe8,0xefe9,0xefea,0xefeb
}, /* 0xf1 */

{ /* 0xf2 */
/* 0xf240 - 0xf247 */ 0xefec,0xefed,0xefee,0xefef,0xeff0,0xeff1,0xeff2,0xeff3,
/* 0xf248 - 0xf24f */ 0xeff4,0xeff5,0xeff6,0xeff7,0xeff8,0xeff9,0xeffa,0xeffb,
/* 0xf250 - 0xf257 */ 0xeffc,0xeffd,0xeffe,0xefff,0xf000,0xf001,0xf002,0xf003,
/* 0xf258 - 0xf25f */ 0xf004,0xf005,0xf006,0xf007,0xf008,0xf009,0xf00a,0xf00b,
/* 0xf260 - 0xf267 */ 0xf00c,0xf00d,0xf00e,0xf00f,0xf010,0xf011,0xf012,0xf013,
/* 0xf268 - 0xf26f */ 0xf014,0xf015,0xf016,0xf017,0xf018,0xf019,0xf01a,0xf01b,
/* 0xf270 - 0xf277 */ 0xf01c,0xf01d,0xf01e,0xf01f,0xf020,0xf021,0xf022,0xf023,
/* 0xf278 - 0xf27f */ 0xf024,0xf025,0xf026,0xf027,0xf028,0xf029,0xf02a,0x0,
/* 0xf280 - 0xf287 */ 0xf02b,0xf02c,0xf02d,0xf02e,0xf02f,0xf030,0xf031,0xf032,
/* 0xf288 - 0xf28f */ 0xf033,0xf034,0xf035,0xf036,0xf037,0xf038,0xf039,0xf03a,
/* 0xf290 - 0xf297 */ 0xf03b,0xf03c,0xf03d,0xf03e,0xf03f,0xf040,0xf041,0xf042,
/* 0xf298 - 0xf29f */ 0xf043,0xf044,0xf045,0xf046,0xf047,0xf048,0xf049,0xf04a,
/* 0xf2a0 - 0xf2a7 */ 0xf04b,0xf04c,0xf04d,0xf04e,0xf04f,0xf050,0xf051,0xf052,
/* 0xf2a8 - 0xf2af */ 0xf053,0xf054,0xf055,0xf056,0xf057,0xf058,0xf059,0xf05a,
/* 0xf2b0 - 0xf2b7 */ 0xf05b,0xf05c,0xf05d,0xf05e,0xf05f,0xf060,0xf061,0xf062,
/* 0xf2b8 - 0xf2bf */ 0xf063,0xf064,0xf065,0xf066,0xf067,0xf068,0xf069,0xf06a,
/* 0xf2c0 - 0xf2c7 */ 0xf06b,0xf06c,0xf06d,0xf06e,0xf06f,0xf070,0xf071,0xf072,
/* 0xf2c8 - 0xf2cf */ 0xf073,0xf074,0xf075,0xf076,0xf077,0xf078,0xf079,0xf07a,
/* 0xf2d0 - 0xf2d7 */ 0xf07b,0xf07c,0xf07d,0xf07e,0xf07f,0xf080,0xf081,0xf082,
/* 0xf2d8 - 0xf2df */ 0xf083,0xf084,0xf085,0xf086,0xf087,0xf088,0xf089,0xf08a,
/* 0xf2e0 - 0xf2e7 */ 0xf08b,0xf08c,0xf08d,0xf08e,0xf08f,0xf090,0xf091,0xf092,
/* 0xf2e8 - 0xf2ef */ 0xf093,0xf094,0xf095,0xf096,0xf097,0xf098,0xf099,0xf09a,
/* 0xf2f0 - 0xf2f7 */ 0xf09b,0xf09c,0xf09d,0xf09e,0xf09f,0xf0a0,0xf0a1,0xf0a2,
/* 0xf2f8 - 0xf2ff */ 0xf0a3,0xf0a4,0xf0a5,0xf0a6,0xf0a7
}, /* 0xf2 */

{ /* 0xf3 */
/* 0xf340 - 0xf347 */ 0xf0a8,0xf0a9,0xf0aa,0xf0ab,0xf0ac,0xf0ad,0xf0ae,0xf0af,
/* 0xf348 - 0xf34f */ 0xf0b0,0xf0b1,0xf0b2,0xf0b3,0xf0b4,0xf0b5,0xf0b6,0xf0b7,
/* 0xf350 - 0xf357 */ 0xf0b8,0xf0b9,0xf0ba,0xf0bb,0xf0bc,0xf0bd,0xf0be,0xf0bf,
/* 0xf358 - 0xf35f */ 0xf0c0,0xf0c1,0xf0c2,0xf0c3,0xf0c4,0xf0c5,0xf0c6,0xf0c7,
/* 0xf360 - 0xf367 */ 0xf0c8,0xf0c9,0xf0ca,0xf0cb,0xf0cc,0xf0cd,0xf0ce,0xf0cf,
/* 0xf368 - 0xf36f */ 0xf0d0,0xf0d1,0xf0d2,0xf0d3,0xf0d4,0xf0d5,0xf0d6,0xf0d7,
/* 0xf370 - 0xf377 */ 0xf0d8,0xf0d9,0xf0da,0xf0db,0xf0dc,0xf0dd,0xf0de,0xf0df,
/* 0xf378 - 0xf37f */ 0xf0e0,0xf0e1,0xf0e2,0xf0e3,0xf0e4,0xf0e5,0xf0e6,0x0,
/* 0xf380 - 0xf387 */ 0xf0e7,0xf0e8,0xf0e9,0xf0ea,0xf0eb,0xf0ec,0xf0ed,0xf0ee,
/* 0xf388 - 0xf38f */ 0xf0ef,0xf0f0,0xf0f1,0xf0f2,0xf0f3,0xf0f4,0xf0f5,0xf0f6,
/* 0xf390 - 0xf397 */ 0xf0f7,0xf0f8,0xf0f9,0xf0fa,0xf0fb,0xf0fc,0xf0fd,0xf0fe,
/* 0xf398 - 0xf39f */ 0xf0ff,0xf100,0xf101,0xf102,0xf103,0xf104,0xf105,0xf106,
/* 0xf3a0 - 0xf3a7 */ 0xf107,0xf108,0xf109,0xf10a,0xf10b,0xf10c,0xf10d,0xf10e,
/* 0xf3a8 - 0xf3af */ 0xf10f,0xf110,0xf111,0xf112,0xf113,0xf114,0xf115,0xf116,
/* 0xf3b0 - 0xf3b7 */ 0xf117,0xf118,0xf119,0xf11a,0xf11b,0xf11c,0xf11d,0xf11e,
/* 0xf3b8 - 0xf3bf */ 0xf11f,0xf120,0xf121,0xf122,0xf123,0xf124,0xf125,0xf126,
/* 0xf3c0 - 0xf3c7 */ 0xf127,0xf128,0xf129,0xf12a,0xf12b,0xf12c,0xf12d,0xf12e,
/* 0xf3c8 - 0xf3cf */ 0xf12f,0xf130,0xf131,0xf132,0xf133,0xf134,0xf135,0xf136,
/* 0xf3d0 - 0xf3d7 */ 0xf137,0xf138,0xf139,0xf13a,0xf13b,0xf13c,0xf13d,0xf13e,
/* 0xf3d8 - 0xf3df */ 0xf13f,0xf140,0xf141,0xf142,0xf143,0xf144,0xf145,0xf146,
/* 0xf3e0 - 0xf3e7 */ 0xf147,0xf148,0xf149,0xf14a,0xf14b,0xf14c,0xf14d,0xf14e,
/* 0xf3e8 - 0xf3ef */ 0xf14f,0xf150,0xf151,0xf152,0xf153,0xf154,0xf155,0xf156,
/* 0xf3f0 - 0xf3f7 */ 0xf157,0xf158,0xf159,0xf15a,0xf15b,0xf15c,0xf15d,0xf15e,
/* 0xf3f8 - 0xf3ff */ 0xf15f,0xf160,0xf161,0xf162,0xf163
}, /* 0xf3 */

{ /* 0xf4 */
/* 0xf440 - 0xf447 */ 0xf164,0xf165,0xf166,0xf167,0xf168,0xf169,0xf16a,0xf16b,
/* 0xf448 - 0xf44f */ 0xf16c,0xf16d,0xf16e,0xf16f,0xf170,0xf171,0xf172,0xf173,
/* 0xf450 - 0xf457 */ 0xf174,0xf175,0xf176,0xf177,0xf178,0xf179,0xf17a,0xf17b,
/* 0xf458 - 0xf45f */ 0xf17c,0xf17d,0xf17e,0xf17f,0xf180,0xf181,0xf182,0xf183,
/* 0xf460 - 0xf467 */ 0xf184,0xf185,0xf186,0xf187,0xf188,0xf189,0xf18a,0xf18b,
/* 0xf468 - 0xf46f */ 0xf18c,0xf18d,0xf18e,0xf18f,0xf190,0xf191,0xf192,0xf193,
/* 0xf470 - 0xf477 */ 0xf194,0xf195,0xf196,0xf197,0xf198,0xf199,0xf19a,0xf19b,
/* 0xf478 - 0xf47f */ 0xf19c,0xf19d,0xf19e,0xf19f,0xf1a0,0xf1a1,0xf1a2,0x0,
/* 0xf480 - 0xf487 */ 0xf1a3,0xf1a4,0xf1a5,0xf1a6,0xf1a7,0xf1a8,0xf1a9,0xf1aa,
/* 0xf488 - 0xf48f */ 0xf1ab,0xf1ac,0xf1ad,0xf1ae,0xf1af,0xf1b0,0xf1b1,0xf1b2,
/* 0xf490 - 0xf497 */ 0xf1b3,0xf1b4,0xf1b5,0xf1b6,0xf1b7,0xf1b8,0xf1b9,0xf1ba,
/* 0xf498 - 0xf49f */ 0xf1bb,0xf1bc,0xf1bd,0xf1be,0xf1bf,0xf1c0,0xf1c1,0xf1c2,
/* 0xf4a0 - 0xf4a7 */ 0xf1c3,0xf1c4,0xf1c5,0xf1c6,0xf1c7,0xf1c8,0xf1c9,0xf1ca,
/* 0xf4a8 - 0xf4af */ 0xf1cb,0xf1cc,0xf1cd,0xf1ce,0xf1cf,0xf1d0,0xf1d1,0xf1d2,
/* 0xf4b0 - 0xf4b7 */ 0xf1d3,0xf1d4,0xf1d5,0xf1d6,0xf1d7,0xf1d8,0xf1d9,0xf1da,
/* 0xf4b8 - 0xf4bf */ 0xf1db,0xf1dc,0xf1dd,0xf1de,0xf1df,0xf1e0,0xf1e1,0xf1e2,
/* 0xf4c0 - 0xf4c7 */ 0xf1e3,0xf1e4,0xf1e5,0xf1e6,0xf1e7,0xf1e8,0xf1e9,0xf1ea,
/* 0xf4c8 - 0xf4cf */ 0xf1eb,0xf1ec,0xf1ed,0xf1ee,0xf1ef,0xf1f0,0xf1f1,0xf1f2,
/* 0xf4d0 - 0xf4d7 */ 0xf1f3,0xf1f4,0xf1f5,0xf1f6,0xf1f7,0xf1f8,0xf1f9,0xf1fa,
/* 0xf4d8 - 0xf4df */ 0xf1fb,0xf1fc,0xf1fd,0xf1fe,0xf1ff,0xf200,0xf201,0xf202,
/* 0xf4e0 - 0xf4e7 */ 0xf203,0xf204,0xf205,0xf206,0xf207,0xf208,0xf209,0xf20a,
/* 0xf4e8 - 0xf4ef */ 0xf20b,0xf20c,0xf20d,0xf20e,0xf20f,0xf210,0xf211,0xf212,
/* 0xf4f0 - 0xf4f7 */ 0xf213,0xf214,0xf215,0xf216,0xf217,0xf218,0xf219,0xf21a,
/* 0xf4f8 - 0xf4ff */ 0xf21b,0xf21c,0xf21d,0xf21e,0xf21f
}, /* 0xf4 */

{ /* 0xf5 */
/* 0xf540 - 0xf547 */ 0xf220,0xf221,0xf222,0xf223,0xf224,0xf225,0xf226,0xf227,
/* 0xf548 - 0xf54f */ 0xf228,0xf229,0xf22a,0xf22b,0xf22c,0xf22d,0xf22e,0xf22f,
/* 0xf550 - 0xf557 */ 0xf230,0xf231,0xf232,0xf233,0xf234,0xf235,0xf236,0xf237,
/* 0xf558 - 0xf55f */ 0xf238,0xf239,0xf23a,0xf23b,0xf23c,0xf23d,0xf23e,0xf23f,
/* 0xf560 - 0xf567 */ 0xf240,0xf241,0xf242,0xf243,0xf244,0xf245,0xf246,0xf247,
/* 0xf568 - 0xf56f */ 0xf248,0xf249,0xf24a,0xf24b,0xf24c,0xf24d,0xf24e,0xf24f,
/* 0xf570 - 0xf577 */ 0xf250,0xf251,0xf252,0xf253,0xf254,0xf255,0xf256,0xf257,
/* 0xf578 - 0xf57f */ 0xf258,0xf259,0xf25a,0xf25b,0xf25c,0xf25d,0xf25e,0x0,
/* 0xf580 - 0xf587 */ 0xf25f,0xf260,0xf261,0xf262,0xf263,0xf264,0xf265,0xf266,
/* 0xf588 - 0xf58f */ 0xf267,0xf268,0xf269,0xf26a,0xf26b,0xf26c,0xf26d,0xf26e,
/* 0xf590 - 0xf597 */ 0xf26f,0xf270,0xf271,0xf272,0xf273,0xf274,0xf275,0xf276,
/* 0xf598 - 0xf59f */ 0xf277,0xf278,0xf279,0xf27a,0xf27b,0xf27c,0xf27d,0xf27e,
/* 0xf5a0 - 0xf5a7 */ 0xf27f,0xf280,0xf281,0xf282,0xf283,0xf284,0xf285,0xf286,
/* 0xf5a8 - 0xf5af */ 0xf287,0xf288,0xf289,0xf28a,0xf28b,0xf28c,0xf28d,0xf28e,
/* 0xf5b0 - 0xf5b7 */ 0xf28f,0xf290,0xf291,0xf292,0xf293,0xf294,0xf295,0xf296,
/* 0xf5b8 - 0xf5bf */ 0xf297,0xf298,0xf299,0xf29a,0xf29b,0xf29c,0xf29d,0xf29e,
/* 0xf5c0 - 0xf5c7 */ 0xf29f,0xf2a0,0xf2a1,0xf2a2,0xf2a3,0xf2a4,0xf2a5,0xf2a6,
/* 0xf5c8 - 0xf5cf */ 0xf2a7,0xf2a8,0xf2a9,0xf2aa,0xf2ab,0xf2ac,0xf2ad,0xf2ae,
/* 0xf5d0 - 0xf5d7 */ 0xf2af,0xf2b0,0xf2b1,0xf2b2,0xf2b3,0xf2b4,0xf2b5,0xf2b6,
/* 0xf5d8 - 0xf5df */ 0xf2b7,0xf2b8,0xf2b9,0xf2ba,0xf2bb,0xf2bc,0xf2bd,0xf2be,
/* 0xf5e0 - 0xf5e7 */ 0xf2bf,0xf2c0,0xf2c1,0xf2c2,0xf2c3,0xf2c4,0xf2c5,0xf2c6,
/* 0xf5e8 - 0xf5ef */ 0xf2c7,0xf2c8,0xf2c9,0xf2ca,0xf2cb,0xf2cc,0xf2cd,0xf2ce,
/* 0xf5f0 - 0xf5f7 */ 0xf2cf,0xf2d0,0xf2d1,0xf2d2,0xf2d3,0xf2d4,0xf2d5,0xf2d6,
/* 0xf5f8 - 0xf5ff */ 0xf2d7,0xf2d8,0xf2d9,0xf2da,0xf2db
}, /* 0xf5 */

{ /* 0xf6 */
/* 0xf640 - 0xf647 */ 0xf2dc,0xf2dd,0xf2de,0xf2df,0xf2e0,0xf2e1,0xf2e2,0xf2e3,
/* 0xf648 - 0xf64f */ 0xf2e4,0xf2e5,0xf2e6,0xf2e7,0xf2e8,0xf2e9,0xf2ea,0xf2eb,
/* 0xf650 - 0xf657 */ 0xf2ec,0xf2ed,0xf2ee,0xf2ef,0xf2f0,0xf2f1,0xf2f2,0xf2f3,
/* 0xf658 - 0xf65f */ 0xf2f4,0xf2f5,0xf2f6,0xf2f7,0xf2f8,0xf2f9,0xf2fa,0xf2fb,
/* 0xf660 - 0xf667 */ 0xf2fc,0xf2fd,0xf2fe,0xf2ff,0xf300,0xf301,0xf302,0xf303,
/* 0xf668 - 0xf66f */ 0xf304,0xf305,0xf306,0xf307,0xf308,0xf309,0xf30a,0xf30b,
/* 0xf670 - 0xf677 */ 0xf30c,0xf30d,0xf30e,0xf30f,0xf310,0xf311,0xf312,0xf313,
/* 0xf678 - 0xf67f */ 0xf314,0xf315,0xf316,0xf317,0xf318,0xf319,0xf31a,0x0,
/* 0xf680 - 0xf687 */ 0xf31b,0xf31c,0xf31d,0xf31e,0xf31f,0xf320,0xf321,0xf322,
/* 0xf688 - 0xf68f */ 0xf323,0xf324,0xf325,0xf326,0xf327,0xf328,0xf329,0xf32a,
/* 0xf690 - 0xf697 */ 0xf32b,0xf32c,0xf32d,0xf32e,0xf32f,0xf330,0xf331,0xf332,
/* 0xf698 - 0xf69f */ 0xf333,0xf334,0xf335,0xf336,0xf337,0xf338,0xf339,0xf33a,
/* 0xf6a0 - 0xf6a7 */ 0xf33b,0xf33c,0xf33d,0xf33e,0xf33f,0xf340,0xf341,0xf342,
/* 0xf6a8 - 0xf6af */ 0xf343,0xf344,0xf345,0xf346,0xf347,0xf348,0xf349,0xf34a,
/* 0xf6b0 - 0xf6b7 */ 0xf34b,0xf34c,0xf34d,0xf34e,0xf34f,0xf350,0xf351,0xf352,
/* 0xf6b8 - 0xf6bf */ 0xf353,0xf354,0xf355,0xf356,0xf357,0xf358,0xf359,0xf35a,
/* 0xf6c0 - 0xf6c7 */ 0xf35b,0xf35c,0xf35d,0xf35e,0xf35f,0xf360,0xf361,0xf362,
/* 0xf6c8 - 0xf6cf */ 0xf363,0xf364,0xf365,0xf366,0xf367,0xf368,0xf369,0xf36a,
/* 0xf6d0 - 0xf6d7 */ 0xf36b,0xf36c,0xf36d,0xf36e,0xf36f,0xf370,0xf371,0xf372,
/* 0xf6d8 - 0xf6df */ 0xf373,0xf374,0xf375,0xf376,0xf377,0xf378,0xf379,0xf37a,
/* 0xf6e0 - 0xf6e7 */ 0xf37b,0xf37c,0xf37d,0xf37e,0xf37f,0xf380,0xf381,0xf382,
/* 0xf6e8 - 0xf6ef */ 0xf383,0xf384,0xf385,0xf386,0xf387,0xf388,0xf389,0xf38a,
/* 0xf6f0 - 0xf6f7 */ 0xf38b,0xf38c,0xf38d,0xf38e,0xf38f,0xf390,0xf391,0xf392,
/* 0xf6f8 - 0xf6ff */ 0xf393,0xf394,0xf395,0xf396,0xf397
}, /* 0xf6 */

{ /* 0xf7 */
/* 0xf740 - 0xf747 */ 0xf398,0xf399,0xf39a,0xf39b,0xf39c,0xf39d,0xf39e,0xf39f,
/* 0xf748 - 0xf74f */ 0xf3a0,0xf3a1,0xf3a2,0xf3a3,0xf3a4,0xf3a5,0xf3a6,0xf3a7,
/* 0xf750 - 0xf757 */ 0xf3a8,0xf3a9,0xf3aa,0xf3ab,0xf3ac,0xf3ad,0xf3ae,0xf3af,
/* 0xf758 - 0xf75f */ 0xf3b0,0xf3b1,0xf3b2,0xf3b3,0xf3b4,0xf3b5,0xf3b6,0xf3b7,
/* 0xf760 - 0xf767 */ 0xf3b8,0xf3b9,0xf3ba,0xf3bb,0xf3bc,0xf3bd,0xf3be,0xf3bf,
/* 0xf768 - 0xf76f */ 0xf3c0,0xf3c1,0xf3c2,0xf3c3,0xf3c4,0xf3c5,0xf3c6,0xf3c7,
/* 0xf770 - 0xf777 */ 0xf3c8,0xf3c9,0xf3ca,0xf3cb,0xf3cc,0xf3cd,0xf3ce,0xf3cf,
/* 0xf778 - 0xf77f */ 0xf3d0,0xf3d1,0xf3d2,0xf3d3,0xf3d4,0xf3d5,0xf3d6,0x0,
/* 0xf780 - 0xf787 */ 0xf3d7,0xf3d8,0xf3d9,0xf3da,0xf3db,0xf3dc,0xf3dd,0xf3de,
/* 0xf788 - 0xf78f */ 0xf3df,0xf3e0,0xf3e1,0xf3e2,0xf3e3,0xf3e4,0xf3e5,0xf3e6,
/* 0xf790 - 0xf797 */ 0xf3e7,0xf3e8,0xf3e9,0xf3ea,0xf3eb,0xf3ec,0xf3ed,0xf3ee,
/* 0xf798 - 0xf79f */ 0xf3ef,0xf3f0,0xf3f1,0xf3f2,0xf3f3,0xf3f4,0xf3f5,0xf3f6,
/* 0xf7a0 - 0xf7a7 */ 0xf3f7,0xf3f8,0xf3f9,0xf3fa,0xf3fb,0xf3fc,0xf3fd,0xf3fe,
/* 0xf7a8 - 0xf7af */ 0xf3ff,0xf400,0xf401,0xf402,0xf403,0xf404,0xf405,0xf406,
/* 0xf7b0 - 0xf7b7 */ 0xf407,0xf408,0xf409,0xf40a,0xf40b,0xf40c,0xf40d,0xf40e,
/* 0xf7b8 - 0xf7bf */ 0xf40f,0xf410,0xf411,0xf412,0xf413,0xf414,0xf415,0xf416,
/* 0xf7c0 - 0xf7c7 */ 0xf417,0xf418,0xf419,0xf41a,0xf41b,0xf41c,0xf41d,0xf41e,
/* 0xf7c8 - 0xf7cf */ 0xf41f,0xf420,0xf421,0xf422,0xf423,0xf424,0xf425,0xf426,
/* 0xf7d0 - 0xf7d7 */ 0xf427,0xf428,0xf429,0xf42a,0xf42b,0xf42c,0xf42d,0xf42e,
/* 0xf7d8 - 0xf7df */ 0xf42f,0xf430,0xf431,0xf432,0xf433,0xf434,0xf435,0xf436,
/* 0xf7e0 - 0xf7e7 */ 0xf437,0xf438,0xf439,0xf43a,0xf43b,0xf43c,0xf43d,0xf43e,
/* 0xf7e8 - 0xf7ef */ 0xf43f,0xf440,0xf441,0xf442,0xf443,0xf444,0xf445,0xf446,
/* 0xf7f0 - 0xf7f7 */ 0xf447,0xf448,0xf449,0xf44a,0xf44b,0xf44c,0xf44d,0xf44e,
/* 0xf7f8 - 0xf7ff */ 0xf44f,0xf450,0xf451,0xf452,0xf453
}, /* 0xf7 */

{ /* 0xf8 */
/* 0xf840 - 0xf847 */ 0xf454,0xf455,0xf456,0xf457,0xf458,0xf459,0xf45a,0xf45b,
/* 0xf848 - 0xf84f */ 0xf45c,0xf45d,0xf45e,0xf45f,0xf460,0xf461,0xf462,0xf463,
/* 0xf850 - 0xf857 */ 0xf464,0xf465,0xf466,0xf467,0xf468,0xf469,0xf46a,0xf46b,
/* 0xf858 - 0xf85f */ 0xf46c,0xf46d,0xf46e,0xf46f,0xf470,0xf471,0xf472,0xf473,
/* 0xf860 - 0xf867 */ 0xf474,0xf475,0xf476,0xf477,0xf478,0xf479,0xf47a,0xf47b,
/* 0xf868 - 0xf86f */ 0xf47c,0xf47d,0xf47e,0xf47f,0xf480,0xf481,0xf482,0xf483,
/* 0xf870 - 0xf877 */ 0xf484,0xf485,0xf486,0xf487,0xf488,0xf489,0xf48a,0xf48b,
/* 0xf878 - 0xf87f */ 0xf48c,0xf48d,0xf48e,0xf48f,0xf490,0xf491,0xf492,0x0,
/* 0xf880 - 0xf887 */ 0xf493,0xf494,0xf495,0xf496,0xf497,0xf498,0xf499,0xf49a,
/* 0xf888 - 0xf88f */ 0xf49b,0xf49c,0xf49d,0xf49e,0xf49f,0xf4a0,0xf4a1,0xf4a2,
/* 0xf890 - 0xf897 */ 0xf4a3,0xf4a4,0xf4a5,0xf4a6,0xf4a7,0xf4a8,0xf4a9,0xf4aa,
/* 0xf898 - 0xf89f */ 0xf4ab,0xf4ac,0xf4ad,0xf4ae,0xf4af,0xf4b0,0xf4b1,0xf4b2,
/* 0xf8a0 - 0xf8a7 */ 0xf4b3,0xf4b4,0xf4b5,0xf4b6,0xf4b7,0xf4b8,0xf4b9,0xf4ba,
/* 0xf8a8 - 0xf8af */ 0xf4bb,0xf4bc,0xf4bd,0xf4be,0xf4bf,0xf4c0,0xf4c1,0xf4c2,
/* 0xf8b0 - 0xf8b7 */ 0xf4c3,0xf4c4,0xf4c5,0xf4c6,0xf4c7,0xf4c8,0xf4c9,0xf4ca,
/* 0xf8b8 - 0xf8bf */ 0xf4cb,0xf4cc,0xf4cd,0xf4ce,0xf4cf,0xf4d0,0xf4d1,0xf4d2,
/* 0xf8c0 - 0xf8c7 */ 0xf4d3,0xf4d4,0xf4d5,0xf4d6,0xf4d7,0xf4d8,0xf4d9,0xf4da,
/* 0xf8c8 - 0xf8cf */ 0xf4db,0xf4dc,0xf4dd,0xf4de,0xf4df,0xf4e0,0xf4e1,0xf4e2,
/* 0xf8d0 - 0xf8d7 */ 0xf4e3,0xf4e4,0xf4e5,0xf4e6,0xf4e7,0xf4e8,0xf4e9,0xf4ea,
/* 0xf8d8 - 0xf8df */ 0xf4eb,0xf4ec,0xf4ed,0xf4ee,0xf4ef,0xf4f0,0xf4f1,0xf4f2,
/* 0xf8e0 - 0xf8e7 */ 0xf4f3,0xf4f4,0xf4f5,0xf4f6,0xf4f7,0xf4f8,0xf4f9,0xf4fa,
/* 0xf8e8 - 0xf8ef */ 0xf4fb,0xf4fc,0xf4fd,0xf4fe,0xf4ff,0xf500,0xf501,0xf502,
/* 0xf8f0 - 0xf8f7 */ 0xf503,0xf504,0xf505,0xf506,0xf507,0xf508,0xf509,0xf50a,
/* 0xf8f8 - 0xf8ff */ 0xf50b,0xf50c,0xf50d,0xf50e,0xf50f
}, /* 0xf8 */

{ /* 0xf9 */
/* 0xf940 - 0xf947 */ 0xf510,0xf511,0xf512,0xf513,0xf514,0xf515,0xf516,0xf517,
/* 0xf948 - 0xf94f */ 0xf518,0xf519,0xf51a,0xf51b,0xf51c,0xf51d,0xf51e,0xf51f,
/* 0xf950 - 0xf957 */ 0xf520,0xf521,0xf522,0xf523,0xf524,0xf525,0xf526,0xf527,
/* 0xf958 - 0xf95f */ 0xf528,0xf529,0xf52a,0xf52b,0xf52c,0xf52d,0xf52e,0xf52f,
/* 0xf960 - 0xf967 */ 0xf530,0xf531,0xf532,0xf533,0xf534,0xf535,0xf536,0xf537,
/* 0xf968 - 0xf96f */ 0xf538,0xf539,0xf53a,0xf53b,0xf53c,0xf53d,0xf53e,0xf53f,
/* 0xf970 - 0xf977 */ 0xf540,0xf541,0xf542,0xf543,0xf544,0xf545,0xf546,0xf547,
/* 0xf978 - 0xf97f */ 0xf548,0xf549,0xf54a,0xf54b,0xf54c,0xf54d,0xf54e,0x0,
/* 0xf980 - 0xf987 */ 0xf54f,0xf550,0xf551,0xf552,0xf553,0xf554,0xf555,0xf556,
/* 0xf988 - 0xf98f */ 0xf557,0xf558,0xf559,0xf55a,0xf55b,0xf55c,0xf55d,0xf55e,
/* 0xf990 - 0xf997 */ 0xf55f,0xf560,0xf561,0xf562,0xf563,0xf564,0xf565,0xf566,
/* 0xf998 - 0xf99f */ 0xf567,0xf568,0xf569,0xf56a,0xf56b,0xf56c,0xf56d,0xf56e,
/* 0xf9a0 - 0xf9a7 */ 0xf56f,0xf570,0xf571,0xf572,0xf573,0xf574,0xf575,0xf576,
/* 0xf9a8 - 0xf9af */ 0xf577,0xf578,0xf579,0xf57a,0xf57b,0xf57c,0xf57d,0xf57e,
/* 0xf9b0 - 0xf9b7 */ 0xf57f,0xf580,0xf581,0xf582,0xf583,0xf584,0xf585,0xf586,
/* 0xf9b8 - 0xf9bf */ 0xf587,0xf588,0xf589,0xf58a,0xf58b,0xf58c,0xf58d,0xf58e,
/* 0xf9c0 - 0xf9c7 */ 0xf58f,0xf590,0xf591,0xf592,0xf593,0xf594,0xf595,0xf596,
/* 0xf9c8 - 0xf9cf */ 0xf597,0xf598,0xf599,0xf59a,0xf59b,0xf59c,0xf59d,0xf59e,
/* 0xf9d0 - 0xf9d7 */ 0xf59f,0xf5a0,0xf5a1,0xf5a2,0xf5a3,0xf5a4,0xf5a5,0xf5a6,
/* 0xf9d8 - 0xf9df */ 0xf5a7,0xf5a8,0xf5a9,0xf5aa,0xf5ab,0xf5ac,0xf5ad,0xf5ae,
/* 0xf9e0 - 0xf9e7 */ 0xf5af,0xf5b0,0xf5b1,0xf5b2,0xf5b3,0xf5b4,0xf5b5,0xf5b6,
/* 0xf9e8 - 0xf9ef */ 0xf5b7,0xf5b8,0xf5b9,0xf5ba,0xf5bb,0xf5bc,0xf5bd,0xf5be,
/* 0xf9f0 - 0xf9f7 */ 0xf5bf,0xf5c0,0xf5c1,0xf5c2,0xf5c3,0xf5c4,0xf5c5,0xf5c6,
/* 0xf9f8 - 0xf9ff */ 0xf5c7,0xf5c8,0xf5c9,0xf5ca,0xf5cb
}, /* 0xf9 */

{ /* 0xfa */
/* 0xfa40 - 0xfa47 */ 0xf5cc,0xf5cd,0xf5ce,0xf5cf,0xf5d0,0xf5d1,0xf5d2,0xf5d3,
/* 0xfa48 - 0xfa4f */ 0xf5d4,0xf5d5,0xf5d6,0xf5d7,0xf5d8,0xf5d9,0xf5da,0xf5db,
/* 0xfa50 - 0xfa57 */ 0xf5dc,0xf5dd,0xf5de,0xf5df,0xf5e0,0xf5e1,0xf5e2,0xf5e3,
/* 0xfa58 - 0xfa5f */ 0xf5e4,0xf5e5,0xf5e6,0xf5e7,0xf5e8,0xf5e9,0xf5ea,0xf5eb,
/* 0xfa60 - 0xfa67 */ 0xf5ec,0xf5ed,0xf5ee,0xf5ef,0xf5f0,0xf5f1,0xf5f2,0xf5f3,
/* 0xfa68 - 0xfa6f */ 0xf5f4,0xf5f5,0xf5f6,0xf5f7,0xf5f8,0xf5f9,0xf5fa,0xf5fb,
/* 0xfa70 - 0xfa77 */ 0xf5fc,0xf5fd,0xf5fe,0xf5ff,0xf600,0xf601,0xf602,0xf603,
/* 0xfa78 - 0xfa7f */ 0xf604,0xf605,0xf606,0xf607,0xf608,0xf609,0xf60a,0x0,
/* 0xfa80 - 0xfa87 */ 0xf60b,0xf60c,0xf60d,0xf60e,0xf60f,0xf610,0xf611,0xf612,
/* 0xfa88 - 0xfa8f */ 0xf613,0xf614,0xf615,0xf616,0xf617,0xf618,0xf619,0xf61a,
/* 0xfa90 - 0xfa97 */ 0xf61b,0xf61c,0xf61d,0xf61e,0xf61f,0xf620,0xf621,0xf622,
/* 0xfa98 - 0xfa9f */ 0xf623,0xf624,0xf625,0xf626,0xf627,0xf628,0xf629,0xf62a,
/* 0xfaa0 - 0xfaa7 */ 0xf62b,0xf62c,0xf62d,0xf62e,0xf62f,0xf630,0xf631,0xf632,
/* 0xfaa8 - 0xfaaf */ 0xf633,0xf634,0xf635,0xf636,0xf637,0xf638,0xf639,0xf63a,
/* 0xfab0 - 0xfab7 */ 0xf63b,0xf63c,0xf63d,0xf63e,0xf63f,0xf640,0xf641,0xf642,
/* 0xfab8 - 0xfabf */ 0xf643,0xf644,0xf645,0xf646,0xf647,0xf648,0xf649,0xf64a,
/* 0xfac0 - 0xfac7 */ 0xf64b,0xf64c,0xf64d,0xf64e,0xf64f,0xf650,0xf651,0xf652,
/* 0xfac8 - 0xfacf */ 0xf653,0xf654,0xf655,0xf656,0xf657,0xf658,0xf659,0xf65a,
/* 0xfad0 - 0xfad7 */ 0xf65b,0xf65c,0xf65d,0xf65e,0xf65f,0xf660,0xf661,0xf662,
/* 0xfad8 - 0xfadf */ 0xf663,0xf664,0xf665,0xf666,0xf667,0xf668,0xf669,0xf66a,
/* 0xfae0 - 0xfae7 */ 0xf66b,0xf66c,0xf66d,0xf66e,0xf66f,0xf670,0xf671,0xf672,
/* 0xfae8 - 0xfaef */ 0xf673,0xf674,0xf675,0xf676,0xf677,0xf678,0xf679,0xf67a,
/* 0xfaf0 - 0xfaf7 */ 0xf67b,0xf67c,0xf67d,0xf67e,0xf67f,0xf680,0xf681,0xf682,
/* 0xfaf8 - 0xfaff */ 0xf683,0xf684,0xf685,0xf686,0xf687
}, /* 0xfa */

{ /* 0xfb */
/* 0xfb40 - 0xfb47 */ 0xf688,0xf689,0xf68a,0xf68b,0xf68c,0xf68d,0xf68e,0xf68f,
/* 0xfb48 - 0xfb4f */ 0xf690,0xf691,0xf692,0xf693,0xf694,0xf695,0xf696,0xf697,
/* 0xfb50 - 0xfb57 */ 0xf698,0xf699,0xf69a,0xf69b,0xf69c,0xf69d,0xf69e,0xf69f,
/* 0xfb58 - 0xfb5f */ 0xf6a0,0xf6a1,0xf6a2,0xf6a3,0xf6a4,0xf6a5,0xf6a6,0xf6a7,
/* 0xfb60 - 0xfb67 */ 0xf6a8,0xf6a9,0xf6aa,0xf6ab,0xf6ac,0xf6ad,0xf6ae,0xf6af,
/* 0xfb68 - 0xfb6f */ 0xf6b0,0xf6b1,0xf6b2,0xf6b3,0xf6b4,0xf6b5,0xf6b6,0xf6b7,
/* 0xfb70 - 0xfb77 */ 0xf6b8,0xf6b9,0xf6ba,0xf6bb,0xf6bc,0xf6bd,0xf6be,0xf6bf,
/* 0xfb78 - 0xfb7f */ 0xf6c0,0xf6c1,0xf6c2,0xf6c3,0xf6c4,0xf6c5,0xf6c6,0x0,
/* 0xfb80 - 0xfb87 */ 0xf6c7,0xf6c8,0xf6c9,0xf6ca,0xf6cb,0xf6cc,0xf6cd,0xf6ce,
/* 0xfb88 - 0xfb8f */ 0xf6cf,0xf6d0,0xf6d1,0xf6d2,0xf6d3,0xf6d4,0xf6d5,0xf6d6,
/* 0xfb90 - 0xfb97 */ 0xf6d7,0xf6d8,0xf6d9,0xf6da,0xf6db,0xf6dc,0xf6dd,0xf6de,
/* 0xfb98 - 0xfb9f */ 0xf6df,0xf6e0,0xf6e1,0xf6e2,0xf6e3,0xf6e4,0xf6e5,0xf6e6,
/* 0xfba0 - 0xfba7 */ 0xf6e7,0xf6e8,0xf6e9,0xf6ea,0xf6eb,0xf6ec,0xf6ed,0xf6ee,
/* 0xfba8 - 0xfbaf */ 0xf6ef,0xf6f0,0xf6f1,0xf6f2,0xf6f3,0xf6f4,0xf6f5,0xf6f6,
/* 0xfbb0 - 0xfbb7 */ 0xf6f7,0xf6f8,0xf6f9,0xf6fa,0xf6fb,0xf6fc,0xf6fd,0xf6fe,
/* 0xfbb8 - 0xfbbf */ 0xf6ff,0xf700,0xf701,0xf702,0xf703,0xf704,0xf705,0xf706,
/* 0xfbc0 - 0xfbc7 */ 0xf707,0xf708,0xf709,0xf70a,0xf70b,0xf70c,0xf70d,0xf70e,
/* 0xfbc8 - 0xfbcf */ 0xf70f,0xf710,0xf711,0xf712,0xf713,0xf714,0xf715,0xf716,
/* 0xfbd0 - 0xfbd7 */ 0xf717,0xf718,0xf719,0xf71a,0xf71b,0xf71c,0xf71d,0xf71e,
/* 0xfbd8 - 0xfbdf */ 0xf71f,0xf720,0xf721,0xf722,0xf723,0xf724,0xf725,0xf726,
/* 0xfbe0 - 0xfbe7 */ 0xf727,0xf728,0xf729,0xf72a,0xf72b,0xf72c,0xf72d,0xf72e,
/* 0xfbe8 - 0xfbef */ 0xf72f,0xf730,0xf731,0xf732,0xf733,0xf734,0xf735,0xf736,
/* 0xfbf0 - 0xfbf7 */ 0xf737,0xf738,0xf739,0xf73a,0xf73b,0xf73c,0xf73d,0xf73e,
/* 0xfbf8 - 0xfbff */ 0xf73f,0xf740,0xf741,0xf742,0xf743
}, /* 0xfb */

{ /* 0xfc */
/* 0xfc40 - 0xfc47 */ 0xf744,0xf745,0xf746,0xf747,0xf748,0xf749,0xf74a,0xf74b,
/* 0xfc48 - 0xfc4f */ 0xf74c,0xf74d,0xf74e,0xf74f,0xf750,0xf751,0xf752,0xf753,
/* 0xfc50 - 0xfc57 */ 0xf754,0xf755,0xf756,0xf757,0xf758,0xf759,0xf75a,0xf75b,
/* 0xfc58 - 0xfc5f */ 0xf75c,0xf75d,0xf75e,0xf75f,0xf760,0xf761,0xf762,0xf763,
/* 0xfc60 - 0xfc67 */ 0xf764,0xf765,0xf766,0xf767,0xf768,0xf769,0xf76a,0xf76b,
/* 0xfc68 - 0xfc6f */ 0xf76c,0xf76d,0xf76e,0xf76f,0xf770,0xf771,0xf772,0xf773,
/* 0xfc70 - 0xfc77 */ 0xf774,0xf775,0xf776,0xf777,0xf778,0xf779,0xf77a,0xf77b,
/* 0xfc78 - 0xfc7f */ 0xf77c,0xf77d,0xf77e,0xf77f,0xf780,0xf781,0xf782,0x0,
/* 0xfc80 - 0xfc87 */ 0xf783,0xf784,0xf785,0xf786,0xf787,0xf788,0xf789,0xf78a,
/* 0xfc88 - 0xfc8f */ 0xf78b,0xf78c,0xf78d,0xf78e,0xf78f,0xf790,0xf791,0xf792,
/* 0xfc90 - 0xfc97 */ 0xf793,0xf794,0xf795,0xf796,0xf797,0xf798,0xf799,0xf79a,
/* 0xfc98 - 0xfc9f */ 0xf79b,0xf79c,0xf79d,0xf79e,0xf79f,0xf7a0,0xf7a1,0xf7a2,
/* 0xfca0 - 0xfca7 */ 0xf7a3,0xf7a4,0xf7a5,0xf7a6,0xf7a7,0xf7a8,0xf7a9,0xf7aa,
/* 0xfca8 - 0xfcaf */ 0xf7ab,0xf7ac,0xf7ad,0xf7ae,0xf7af,0xf7b0,0xf7b1,0xf7b2,
/* 0xfcb0 - 0xfcb7 */ 0xf7b3,0xf7b4,0xf7b5,0xf7b6,0xf7b7,0xf7b8,0xf7b9,0xf7ba,
/* 0xfcb8 - 0xfcbf */ 0xf7bb,0xf7bc,0xf7bd,0xf7be,0xf7bf,0xf7c0,0xf7c1,0xf7c2,
/* 0xfcc0 - 0xfcc7 */ 0xf7c3,0xf7c4,0xf7c5,0xf7c6,0xf7c7,0xf7c8,0xf7c9,0xf7ca,
/* 0xfcc8 - 0xfccf */ 0xf7cb,0xf7cc,0xf7cd,0xf7ce,0xf7cf,0xf7d0,0xf7d1,0xf7d2,
/* 0xfcd0 - 0xfcd7 */ 0xf7d3,0xf7d4,0xf7d5,0xf7d6,0xf7d7,0xf7d8,0xf7d9,0xf7da,
/* 0xfcd8 - 0xfcdf */ 0xf7db,0xf7dc,0xf7dd,0xf7de,0xf7df,0xf7e0,0xf7e1,0xf7e2,
/* 0xfce0 - 0xfce7 */ 0xf7e3,0xf7e4,0xf7e5,0xf7e6,0xf7e7,0xf7e8,0xf7e9,0xf7ea,
/* 0xfce8 - 0xfcef */ 0xf7eb,0xf7ec,0xf7ed,0xf7ee,0xf7ef,0xf7f0,0xf7f1,0xf7f2,
/* 0xfcf0 - 0xfcf7 */ 0xf7f3,0xf7f4,0xf7f5,0xf7f6,0xf7f7,0xf7f8,0xf7f9,0xf7fa,
/* 0xfcf8 - 0xfcff */ 0xf7fb,0xf7fc,0xf7fd,0xf7fe,0xf7ff
} /* 0xfc */
} ///////////////////////////////////////// DBCS_Table2
}; // sj_to_unicode

WCHAR sjtouni( USHORT code )
{
   USHORT ch1, ch2;
   USHORT usReturn = 0;

   if ( code <= (USHORT)0xff )
   {
       usReturn = sj_to_unicode.SBCS_Table[code];
       if ( usReturn == 0 )
           usReturn = code;
   }
   else
   {
       ch1 = LEADING_BYTE( code );
       ch2 = TRAILING_BYTE( code );

       if ( ch1 >= DBCS_LeadingStart1 &&
            ch1 <= DBCS_LeadingEnd1   &&
            ch2 >= DBCS_TrailingStart &&
            ch2 <= DBCS_TrailingEnd )
       {
           usReturn = sj_to_unicode.DBCS_Table1[ ch1 - DBCS_LeadingStart1 ][ ch2 - DBCS_TrailingStart ] ;
       }
       else if ( ch1 >= DBCS_LeadingStart2 &&
                 ch1 <= DBCS_LeadingEnd2   &&
                 ch2 >= DBCS_TrailingStart &&
                 ch2 <= DBCS_TrailingEnd )
       {
           usReturn =  sj_to_unicode.DBCS_Table2[ ch1 - DBCS_LeadingStart2 ][ ch2 - DBCS_TrailingStart ] ;
       }
       if ( usReturn == 0 )
           usReturn = 0x0020;
   }
   return ( usReturn );
}
#else

/*
 * Unicode to code page 1252 (Windows 3.1 ANSI) translation table.
 *
 * The table is indexed using an 8:4:4 scheme.  The first 256 entries
 * of this table are indexed by the high byte of the Unicode character.
 * If a non-zero value is found this value is used as an offset into
 * the table from which to begin the lookup using the high nibble of
 * the low byte of the Unicode character.  Again, if a non-zero value
 * is found that value is used as an offset into the table from which
 * to begin the last lookup.  This offset is then combined with the low
 * nibble of the low byte of the Unicode character to form the final
 * index into the table.  The value contained at that location is the
 * value of the ANSI character.
 */

USHORT TmpUnicodeToAnsiTable[] = {

    //
    // The first 256 entries are indexed by the high byte of the
    // Unicode character.
    //

    0x0100, 0x0110, 0x0120, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0130, 0x0140, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    //
    // second level tables begin here.  They are indexed
    // by the high nibble of the low byte (bits 4-7) of
    // the Unicode character.
    //

    0x0150, 0x0160, 0x0170, 0x0180, 0x0190, 0x01a0, 0x01b0, 0x01c0,
    0x0000, 0x0000, 0x01d0, 0x01e0, 0x01f0, 0x0200, 0x0210, 0x0220,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0230, 0x0240, 0x0250,
    0x0000, 0x0260, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0270, 0x0280, 0x0000, 0x0000,

    0x0000, 0x0290, 0x02a0, 0x02b0, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x02c0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    //
    // third level tables begin here.  They are indexed
    // by the low nibble of the low byte (bits 0x0-3) of
    // the Unicode character.
    //

    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,

    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,

    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,

    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,

    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,

    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,

    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,

    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,

    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,

    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,

    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,

    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,

    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,

    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff,

    0x0000, 0x0000, 0x008c, 0x009c, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x008a, 0x009a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x009f, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0083, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0088, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0098, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0096, 0x0097, 0x0000, 0x0000, 0x0000,
    0x0091, 0x0092, 0x0082, 0x0000, 0x0093, 0x0094, 0x0084, 0x0000,

    0x0086, 0x0087, 0x0095, 0x0000, 0x0000, 0x0000, 0x0085, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0089, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x008b, 0x009b, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0099, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
    };
#endif // DBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\unicode\rcunicod.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.c

Abstract:

    Routines added to rcpp to support 16-bit unicode file parsing.
	Note that as of Aug 91, rcpp will not fully transfer the unicode
	characters but only the string constants are guaranteed to be passed
	cleanly.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <process.h>
#include "rcunicod.h"

#ifdef DBCS

//
// Prototypes for conversion routines between Unicode and 932.
//

NTSTATUS
xxxRtlMultiByteToUnicodeN(
    PWSTR UnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR MultiByteString,
    ULONG BytesInMultiByteString
    );

NTSTATUS
xxxRtlUnicodeToMultiByteN(
    PCHAR MultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

#endif // DBCS

#ifndef DBCS
// SHUNK: A_fwrite is not called from RC. Remove this for now.

INT
A_fwrite (
IN		CHAR	*pchMBString,
IN		INT		nSizeOfItem,
IN		INT		nCountToWrite,
IN      FILE	*fpOutputFile
)

/*++

Routine Description:

    This function will write out an 8-bit string as a unicode string.
	Note, this function is very slow, but hey, I don't have time to optimize
	it now.
	As of Aug 91, only codepage 1252 is being supported.

Arguments:

    pchMBString		    - This is a 8-bit multi byte string to write to the file
					  	  as a unicode string.

    nSizeOfItem			- Ignored, we always use sizeof (CHAR).

    nCountToWrite		- How long is this string.

    fpOutputFile		- File pointer to send the character.

Return Value:
  
	The number of bytes written.
	If the return does not equal nCountToWrite than an error has occured at
	some point in the write.

--*/

{
    WCHAR	wchUniCharToWrite;
    INT		cCountWritten = 0;

    UNREFERENCED_PARAMETER(nSizeOfItem);

    //
    // Write the string out as a two byte unicode string.
    // For now do this with multiple calls to U_fputc.
    //

    while (nCountToWrite--) {

	wchUniCharToWrite = RtlAnsiCharToUnicodeChar(&pchMBString);

	//
	// Write the current unicode char, break if an error occured.
	//

	if (U_fputc (wchUniCharToWrite, fpOutputFile) == 
	    (INT)wchUniCharToWrite) {

	    break;
	}

	cCountWritten++;
    }

    return (cCountWritten);
}

#endif	// DBCS


#ifndef DBCS
// SHUNK: U_fwrite is not called from RC. Remove this for now.

INT
U_fwrite (
IN		WCHAR	*pwchUnicodeString,
IN		INT		nSizeOfItem,
IN		INT		nCountToWrite,
IN      FILE	*fpOutputFile
)

/*++

Routine Description:

    This function will write out a 16-bit string directly.  It does no
	translation on the string as it is written.

Arguments:

    pchUnicodeString    - This is a 16-bit unicode string to write to the file.

    nSizeOfItem			- Ignored.  We always use sizeof (WCHAR).

    nCountToWrite		- How long is this string.

    fpOutputFile		- File pointer to send the character.

Return Value:
  
	The number of bytes written.
	If the return does not equal nCountToWrite than an error has occured at
	some point in the write.

--*/

{
    UNREFERENCED_PARAMETER(nSizeOfItem);
    //
    // Write the string out as a two byte unicode string.
    //

    return (fwrite (pwchUnicodeString, sizeof (WCHAR), nCountToWrite,
        fpOutputFile));
}

#endif	// DBCS


#ifndef DBCS
// SHUNK: A_fputc is not called from RC. Remove this for now.

INT
A_fputc (
IN		CHAR	chCharToWrite,
IN      FILE	*fpOutputFile
)

/*++

Routine Description:

    This function is translates the character passed to it using the 1252
	codepage and then sends it to U_fputc.
	As of Aug 91, only codepage 1252 is being supported.

Arguments:

    chCharToWrite	    - This is a 8-bit character to be output.

    fpOutputFile		- File pointer to send the character.

Return Value:
  
    The character written.
    EOF = There was some sort of error writing the data out.

--*/

{
    WCHAR	wchUniCharToWrite;
    PUCHAR	puch;

    //
    // Translate the char and write it as it's unicode equivalent.
    //

    puch = &chCharToWrite;
    wchUniCharToWrite = RtlAnsiCharToUnicodeChar(&puch);

    if (U_fputc (wchUniCharToWrite, fpOutputFile) == (INT)wchUniCharToWrite) {

	return ((INT)chCharToWrite);
    }
    else {

	return (EOF);
    }
}

#endif	// DBCS


#ifndef DBCS
// SHUNK: U_fputc is not called from RC. Remove this for now.

INT
U_fputc (
IN		WCHAR	wcCharToWrite,
IN      FILE	*fpOutputFile
)

/*++

Routine Description:

    This function is simply the unicode version of fputc.  It will output
	a two byte character instead of the standard byte.

Arguments:

    wcCharToWrite	- This is a 16-bit unicode character to be output.
			It is assumed that any codepage translation has
			already been done to the character.

    fpOutputFile	- File pointer to send the character.

Return Value:
  
    The character written.
    EOF = There was some sort of error writing the data out.

--*/

{
    INT		cCountWritten;

    //
    // Write the char out as a two byte unicode character.
    //

    cCountWritten = fwrite (&wcCharToWrite, sizeof (WCHAR), 1, fpOutputFile);

    if (cCountWritten == sizeof (WCHAR)) {

	return (wcCharToWrite);		// Successful write.

    }
    else {

#ifdef ASSERT_ERRORS
	printf ("Error writing character in U_fputc\n");
	exit (1);
#endif
	return (EOF);				// Some sort of error occured.

    }
}

#endif	// DBCS


BOOL
UnicodeFromMBString (
OUT		WCHAR	*pwchUnicodeString,
IN		CHAR	*pchMBString,
IN		INT	nCountStrLength
)

/*++

Routine Description:

    This function will translate a multi-byte string into it's unicode
	equivalent.  Note that the destination unicode string must be large
	enough to hold the translated bytes.
	As of Aug 91, only codepage 1252 is being supported.

Arguments:

    pwchUnicodeString	- This is a pointer to storage for the destination
			  unicode string.  Note it must be nCountStrLength
			  large.

    pchMBString		- Pointer to the input multi-byte string to convert.

    nCountStrLength	- Count of bytes to translate.

Return Value:
  
	TRUE - All of the characters mapped correctly into Unicode.
	FALSE - One or more characters did not map.  These characters have
			been translated to 0xFFFF.  The rest of the string has been
			converted correctly.

--*/

{
#ifdef DBCS
    NTSTATUS Status;
    
    //
    // Convert ANSI string to Unicode string based on ACP.
    //
    Status = xxxRtlMultiByteToUnicodeN(pwchUnicodeString,
                                    NULL,
                                    pchMBString,
                                    nCountStrLength);

    return(NT_SUCCESS(Status)? TRUE : FALSE);
#else // !DBCS
    UNICODE_STRING	Unicode;
    ANSI_STRING		Ansi;

    Ansi.MaximumLength = Ansi.Length = nCountStrLength;
    Unicode.MaximumLength = nCountStrLength*sizeof(WCHAR) + sizeof(WCHAR);
    Ansi.Buffer = pchMBString;
    Unicode.Buffer = pwchUnicodeString;
    return RtlAnsiStringToUnicodeString(&Unicode,&Ansi,FALSE)==STATUS_SUCCESS;
#endif // !DBCS

}



BOOL
MBStringFromUnicode (
OUT		CHAR	*pchMBString,
IN		WCHAR	*pwchUnicodeString,
IN		INT		nCountStrLength
)

/*++

Routine Description:

    This function will translate a unicode string into a multi-byte string.
	Note that the destination string must be large enough to hold the
	translated bytes.
	As of Aug 91, only the translation is simply done by truncating the 
	unicode character.  We do this because we are not expecting anything
	strange.

Arguments:

    pwchUnicodeString	- This is a pointer to storage for the destination
			  unicode string.  Note it must be nCountStrLength
						  large.

    pchMBString		- Pointer to the input multi-byte string to convert.

    nCountStrLength	- Count of bytes to translate.

Return Value:
  
	TRUE - All of the characters mapped correctly into the MB string.
	FALSE - One or more characters did not map.  As of Aug 91, this will
			never happen.

--*/

{
#ifdef DBCS
    NTSTATUS Status;

    //
    // Convert Unicode string to ANSI string based on ACP.
    //
    Status = xxxRtlUnicodeToMultiByteN(pchMBString,
                                    NULL,
                                    pwchUnicodeString,
                                    nCountStrLength);

    return(NT_SUCCESS(Status)? TRUE : FALSE);
#else // !DBCS
    UNICODE_STRING	Unicode;
    ANSI_STRING		Ansi;

    Unicode.Length = nCountStrLength*sizeof(WCHAR);
    Unicode.MaximumLength = nCountStrLength*sizeof(WCHAR)+sizeof(WCHAR);
    Ansi.MaximumLength = Unicode.MaximumLength / sizeof(WCHAR);
    Ansi.Buffer = pchMBString;
    Unicode.Buffer = pwchUnicodeString;
    return RtlUnicodeStringToAnsiString(&Ansi,&Unicode,FALSE)==STATUS_SUCCESS;
#endif // !DBCS
}



#ifndef DBCS
// SHUNK:  Char1252FromUnicode() is not called any more.

INT
Char1252FromUnicode (
IN		WCHAR	wchUnicodeChar
)

/*++

Routine Description:

    This function will translate a unicode character into it's equivalent
	codepage 1252 character.  If the character does not map correctly,
	then 0xFFFF is returned.

Arguments:

    wchUnicodeChar		- This is a 16-bit unicode character.

Return Value:
  
	Value <= 0xFF - Codepage 1252 equivalent for this string.
	0xFFFF - The character did not translate properly.

--*/

{
    UNICODE_STRING	Unicode;
    ANSI_STRING		Ansi;
    UCHAR		c;
    INT			s;

    Ansi.Length = Unicode.Length = 1;
    Ansi.MaximumLength = Unicode.MaximumLength = 1;
    Ansi.Buffer = &c;
    Unicode.Buffer = &wchUnicodeChar;
    s = RtlUnicodeStringToAnsiString(&Ansi,&Unicode,FALSE);
    if (s != STATUS_SUCCESS)
	return 0xffff;
    return (INT)c;

}

#endif // DBCS


INT
DetermineFileType (
IN      FILE	*fpInputFile
)

/*++

Routine Description:

    This function is used to determine what type of file is being read. 
	Note that it assumes that the first few bytes of the given file contain
	mostly ascii characters.  This routine was originally intended for use
	on .rc files and include files.
	Note, the file is returned to it's proper position after function.

Arguments:

    fpInputFile			- File pointer to file we are checking, must be
						  open with read permissions.

Return Value:
  
	DFT_FILE_IS_UNKNOWN     - It was impossible to determine what type of file
							  we were checking.  This usually happens when EOF
							  is unexpectedly reached.
	DFT_FILE_IS_8_BIT       - File was determined to be in standard 8-bit
							  format.
	DFT_FILE_IS_16_BIT      - File was determined to be a 16 bit unicode file
							  which can be directly read into a WCHAR array.
	DFT_FILE_IS_16_BIT_REV  - File was*/

{
    CHAR	rgchTestBytes [DFT_TEST_SIZE << 2];	// Storage for test data.

    INT		cNumberBytesTested = 0;			// Test information.

    INT		cNumberOddZerosFound = 0;
    INT		cNumberEvenZerosFound = 0;
    INT		cNumberAsciiFound = 0;
    INT		cCountRead;						// Temp storage for count read.

    LONG	lStartFilePos;					// Storage for file position.

    INT		fSysEndianType;					// System endian type.

    INT		fFileType = DFT_FILE_IS_UNKNOWN;// File type, when found.

    fSysEndianType = DetermineSysEndianType ();

    //
    // Store position so we can get back to it.
    //
    	lStartFilePos = ftell (fpInputFile);

    // 
    // Make sure we start on an even byte to simplify routines.
    //
    	if (lStartFilePos % 2) {

	fgetc (fpInputFile);
    }

    do {
	INT		wT;

	//
	// Read in the first test segment.
	//

	cCountRead = fread (rgchTestBytes, sizeof (CHAR), DFT_TEST_SIZE << 2,
	    fpInputFile);

	//
	// Determine results and add to totals.
	//

	for (wT = 0; wT < cCountRead; wT++) {

	    if (rgchTestBytes [wT] == 0) {

		if (wT % 2) {

		    cNumberOddZerosFound++;

		}
		else {

		    cNumberEvenZerosFound++;
		}
	    }

	    if (isprint (rgchTestBytes [wT]) ||
		rgchTestBytes[wT] == '\t' ||
		rgchTestBytes[wT] == '\n' ||
		rgchTestBytes[wT] == '\r') {

		cNumberAsciiFound++;
	    }
	}

	cNumberBytesTested += cCountRead;

	//
	// Check if we have a definite pattern.
	//

	 {
	    INT		cMajorityTested;		// 80% of the bytes tested.

	    cMajorityTested = cNumberBytesTested << 2;
	    cMajorityTested /= 5;

	    if (cNumberAsciiFound > cMajorityTested) {

		fFileType = DFT_FILE_IS_8_BIT;

	    }
	    else if (cNumberOddZerosFound > (cMajorityTested >> 1)) {

		//
		// File type was determined to be little endian.
		// If system is also little endian, byte order is correct.
				//
		fFileType = (fSysEndianType == DSE_SYS_LITTLE_ENDIAN) ? 
		    DFT_FILE_IS_16_BIT : DFT_FILE_IS_16_BIT_REV;

	    }
	    else if (cNumberEvenZerosFound > (cMajorityTested >> 1)) {

		//
		// File type was determined to be big endian.
		// If system is also big endian, byte order is correct.
				//
		fFileType = (fSysEndianType == DSE_SYS_LITTLE_ENDIAN) ? 
		    DFT_FILE_IS_16_BIT_REV : DFT_FILE_IS_16_BIT;

	    }
	}

    } while (cCountRead == (DFT_TEST_SIZE << 2) && 
        fFileType == DFT_FILE_IS_UNKNOWN);

    //
    // Return to starting file position.  (usually beginning)
    //

    fseek (fpInputFile, lStartFilePos, SEEK_SET);

    return (fFileType);
}



INT
DetermineSysEndianType (
VOID
)

/*++

Routine Description:

    This function is used to determine how the current system stores its
	integers in memory.  

    For those of us who are confused by little endian and big endian formats,
	here is a breif recap.
    
    Little Endian:  (This is used on Intel 80x86 chips.  The MIPS RS4000 chip
		 is switchable, but will run in little endian format for NT.)
       This is where the high order bytes of a short or long are stored higher
       in memory.  For example the number 0x80402010 is stored as follows.
         Address:        Value:
             00            10
             01            20
             02            40
             03            80
       This looks backwards when memory is dumped in order: 10 20 40 80
    
    Big Endian:  (This is not currently used on any NT systems but hey, this
         is supposed to be portable!!)
       This is where the high*/

{
    INT		nCheckInteger;
    CHAR	rgchTestBytes [sizeof (INT)];

    //
    // Clear the test bytes to zero.
    //

    *((INT * )rgchTestBytes) = 0;

    //
    // Set first to some value.
    //

    rgchTestBytes [0] = (CHAR)0xFF;

    //
    // Map it to an integer.
    //

    nCheckInteger = *((INT * )rgchTestBytes);

    //
    // See if value was stored in low order of integer. 
    // If so then system is little endian.
    //

    if (nCheckInteger == 0xFF) {

	return (DSE_SYS_LITTLE_ENDIAN);
    }
    else {

	return (DSE_SYS_LITTLE_ENDIAN);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\buffer.cpp ===
/*****************************************************************************
 *
 *  buffer.cpp
 *
 *      Lame buffering implementation.
 *
 *****************************************************************************/

#include "sdview.h"

BOOL IOBuffer::NextLine(String &str)
{
    str.Reset();

    do {

        /*
         *  Drain what we can from the current buffer.
         */
        int i = 0;

        while (i < _cchBufUsed && _rgchBuf[i++] != TEXT('\n')) {
            /* Keep looking */
        }

        if (i) {
            /* _rgchBuf[i] is the first char not to append */
            str.Append(_rgchBuf, i);

            memcpy(_rgchBuf, _rgchBuf+i, _cchBufUsed - i);
            _cchBufUsed -= i;

            /* Stop if we copied a \n */
            if (str[str.Length()-1] == TEXT('\n')) {
                return TRUE;
            }
        }

        /*
         *  Refill from the file until it's all gone.
         */
        if (_hRead)
        {
            DWORD dwBytesRead;
            if (!ReadFile(_hRead, _rgchBuf, _cchBuf, &dwBytesRead, NULL)) {
                _hRead = NULL;
            }
#ifdef UNICODE
    #error Need to convert from ANSI to UNICODE here
#endif
            _cchBufUsed = dwBytesRead;
        }

    } while (_hRead);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\roshare\roshare.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    roshare.c

Abstract:

    This program is a quick-and-dirty app that allows a readonly ACL to
    be placed on a local server share.  The ACL allows everyone Read
    access only.

Author:

    Chuck Lenzmeier (chuckl) 20-Sep-1992

Revision History:

--*/

#define UNICODE 1
#define VERBOSE 0

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <lm.h>

#include <stdio.h>
//#include <string.h>

#define MAX_NAMES 60

BOOL
FindSid(
    LPTSTR Name,
    PSID *Sid
    );

VOID
DumpSid(
    LPTSTR   String,
    PISID    Sid
    );

BOOL
ConstructAcl( 
    PACL *acl, 
    LPTSTR Names[], 
    ULONG Index 
    );

__cdecl
main (
    int argc,
    char *argv[]
    )
{
    ANSI_STRING ansiShareName;
    UNICODE_STRING shareName;
    LPSHARE_INFO_502 shi502;
    SECURITY_DESCRIPTOR desc;
    DWORD aclBuffer[256/4];
    PACL acl = (PACL)aclBuffer;
    SID_IDENTIFIER_AUTHORITY worldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID sid;
    ACCESS_MASK mask;
    int i;
    BOOL ok;
    NTSTATUS status;
    DWORD error;
    DWORD parmerr;
    LPTSTR Names[MAX_NAMES];
    BOOL ExplicitNames = FALSE;
    ULONG Index;

    //
    // Make sure at least one share name was specified.
    //

    if ( argc < 2 ) goto usage;

    //
    // Initialize the security descriptor and the ACL.
    //

    ok = InitializeSecurityDescriptor( &desc, SECURITY_DESCRIPTOR_REVISION );
    if ( !ok ) {
        error = GetLastError();
        printf( "InitializeSecurityDescriptor failed: %d\n", error );
        return error;
    }

    ok = InitializeAcl( acl, 256, ACL_REVISION );
    if ( !ok ) {
        error = GetLastError();
        printf( "InitializeAcl failed: %d\n", error );
        return error;
    }

    //
    // Check to see if there are any usernames specified for
    // the ACL.
    //

    if ( _stricmp( argv[1], "-u") == 0 ) {

#if VERBOSE
        printf("Processing names\n");
#endif

        ExplicitNames = TRUE;
        i=2;  // skip the argument
        Index = 0;

        while ( (_stricmp(argv[i], "-s") != 0) && (Index < MAX_NAMES)) {
            Names[Index++] = (LPTSTR)argv[i++];
        }

        if ( Index > 0 ) {
            ok = ConstructAcl( &acl, Names, Index );
            if ( !ok ) {
                fprintf(stderr, "Unable to create ACL, quitting\n");
                return( ERROR_INVALID_PARAMETER );
            }
        } else {
            goto usage;
        }

    } else {
#if VERBOSE
        printf("No names\n");
#endif

        //
        // Get the SID for World (aka Everyone).
        //
    
        ok = AllocateAndInitializeSid(
                &worldSidAuthority,
                1,
                SECURITY_WORLD_RID,
                0, 0, 0, 0, 0, 0, 0,
                &sid
                );

        if ( !ok ) {
            error = GetLastError();
            printf( "AllocateAndInitializeSid failed: %d\n", error );
            return error;
        }
    
        //
        // Add an ACE that allows World read access.
        //
    
        mask = GENERIC_READ | GENERIC_EXECUTE;
        ok = AddAccessAllowedAce( acl, ACL_REVISION, mask, sid );

        if ( !ok ) {
            error = GetLastError();
            printf( "AddAccessAllowedAce failed: %d\n", error );
            return error;
        }
    }

    //
    // Associate the ACL with the security descriptor.
    //

    ok = SetSecurityDescriptorDacl( &desc, TRUE, acl, FALSE );

    if ( !ok ) {
        error = GetLastError();
        printf( "SetSecurityDescriptorDacl failed: %d\n", error );
        return error;
    }

    //
    // For each share in the argument list, add the ACL to the share.
    // Note that this will override a preexisting ACL.
    //

    for ( i = (ExplicitNames ? i+1 : 1) ; i < argc; i++ ) {

        //
        // Convert the share name to Unicode.
        //

        RtlInitAnsiString( &ansiShareName, argv[i] );
        status = RtlAnsiStringToUnicodeString(
                    &shareName,
                    &ansiShareName,
                    TRUE
                    );
        if ( !NT_SUCCESS(status) ) {
            printf( "Error converting string %s to Unicode: %x\n",
                    argv[i], status );
            continue;
        }

        //
        // Get the current share information.  If the share doesn't
        // exist, continue with the next one in the list.
        //

        error = NetShareGetInfo(
                    NULL,
                    shareName.Buffer,
                    502,
                    (LPBYTE *)&shi502 );
        if ( error == NERR_NetNameNotFound ) {
            printf( "Share %s doesn't exist\n", argv[i] );
            continue;
        }
        if ( error == ERROR_ACCESS_DENIED ) {
            printf( "Access denied.  Log in as an admin or power user\n" );
            break;
        }
        if ( error != NO_ERROR ) {
            printf( "Unable to get info for share %s: %d\n",
                    argv[i], error );
            continue;
        }

        //
        // Change the security descriptor for the share and set the new
        // information.
        //

        shi502->shi502_security_descriptor = &desc;

        error = NetShareSetInfo(
                    NULL,
                    shareName.Buffer,
                    502,
                    (LPBYTE)shi502,
                    &parmerr
                    );
        if ( error == NERR_NetNameNotFound ) {
            printf( "Share %s doesn't exist\n", argv[i] );
            continue;
        }
        if ( error == ERROR_ACCESS_DENIED ) {
            printf( "Access denied.  Log in as an admin or power user\n" );
            break;
        }
        if ( error != NO_ERROR ) {
            printf( "Unable to set info for share %s: %d, %d\n",
                    argv[i], error, parmerr );
            continue;
        }

        printf( "Readonly ACL added to share %s\n", argv[i] );

    } // for ( i = 1; i < argc; i++ )

    return NO_ERROR;

usage:

    printf( "Usage: %s [-u domain\\name1 [domain\\name2]... -s ] share [share]...\n", argv[0] );
    return ERROR_INVALID_PARAMETER;

}


BOOL
FindSid(
    LPTSTR Name,
    PSID *Sid
    )
{
    DWORD SidLength = 0;
    TCHAR DomainName[256];
    DWORD DomainNameLength = 256;
    SID_NAME_USE Use;
    BOOL Result;
    UNICODE_STRING UName;
    ANSI_STRING AName;
    NTSTATUS status;

    printf("\nName: %s\n",Name);

    //
    // Convert name to unicode
    //

    RtlInitAnsiString( &AName, (PCSZ)Name );
    status = RtlAnsiStringToUnicodeString(
                &UName,
                &AName,
                TRUE
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Error converting string %s to Unicode: %x\n",
                Name, status );
        return( FALSE );
    }


    Result = LookupAccountName(
                 NULL,
                 UName.Buffer,
                 (PSID)NULL,
                 &SidLength,
                 DomainName,
                 &DomainNameLength,
                 &Use
                 );

    if ( !Result && (GetLastError() == ERROR_INSUFFICIENT_BUFFER) ) {

        *Sid = LocalAlloc( 0, SidLength );

        Result = LookupAccountName(
                     NULL,
                     UName.Buffer,
                     *Sid,
                     &SidLength,
                     DomainName,
                     &DomainNameLength,
                     &Use
                     );

        if ( !Result) {
            printf("2nd Lookup %s failed, error = %d\n",Name,GetLastError());
        } else {
#if VERBOSE
            DumpSid( "2nd Lookup worked\n", (PISID)(*Sid) );
#endif
        }

    } else {
        printf("1st Lookup %s failed, error = %d\n",Name,GetLastError());
    }

    return( Result );
}   

#if VERBOSE

VOID
DumpSid(
    LPTSTR   String,
    PISID    Sid
    )
{
    char    tab[80];
    int     i;
    PULONG  psa;

    printf(String);
    memset(tab, ' ', strlen(String));
    tab[strlen(String)] = 0;
    printf(   "Revision            : %d\n"
                "%s"
                "SubAuthorityCount   : %d\n"
                "%s"
                "IdentifierAuthority : %d-%d-%d-%d-%d-%d\n",
                Sid->Revision,
                tab,
                Sid->SubAuthorityCount,
                tab,
                ((PUCHAR)&Sid->IdentifierAuthority)[0],
                ((PUCHAR)&Sid->IdentifierAuthority)[1],
                ((PUCHAR)&Sid->IdentifierAuthority)[2],
                ((PUCHAR)&Sid->IdentifierAuthority)[3],
                ((PUCHAR)&Sid->IdentifierAuthority)[4],
                ((PUCHAR)&Sid->IdentifierAuthority)[5]
                );
    psa = (PULONG)&Sid->SubAuthority;
    for (i=0; i<(int)Sid->SubAuthorityCount; ++i) {
        printf(
                "%s"
                "SubAuthority        : %d\n",
                tab,
                *psa++
                );
    }
}

#endif

BOOL
ConstructAcl( 
    PACL *acl, 
    LPTSTR Names[],
    ULONG Index 
    )
{
    ULONG i;
    PSID Sids[MAX_NAMES];
    ULONG TotalSidLength = 0;
    ULONG TotalAclLength = 0;
    BOOL Result;
    DWORD error;

    for ( i=0; i<Index ; i++) {

        Result = FindSid( Names[i], &Sids[i] );          

        if ( !Result ) {
            fprintf(stderr, "Unable to map name %s, quitting\n", Names[i]);
            return( FALSE );
        } else {
            TotalSidLength += GetLengthSid( Sids[i] );
        }
    }

    //
    // This is a slight overestimate
    //

    TotalAclLength = TotalSidLength + 
                     sizeof( ACL )  + 
                     Index * sizeof( ACCESS_ALLOWED_ACE );

    *acl = LocalAlloc( 0, TotalAclLength );

    if ( *acl == NULL ) {
        fprintf(stderr, "Out of memory\n");
        return( FALSE );
    }

    Result = InitializeAcl( *acl, TotalAclLength, ACL_REVISION );

    //
    // This should not fail
    //

    if ( !Result ) {
        error = GetLastError();
        fprintf( stderr, "InitializeAcl failed: %d\n", error );
        return FALSE;
    }

    for ( i=0; i<Index ; i++) {

        Result = AddAccessAllowedAce( *acl, 
                                      ACL_REVISION, 
                                      GENERIC_READ | GENERIC_EXECUTE, 
                                      Sids[i]
                                      );
        if ( !Result ) {
            error = GetLastError();
            fprintf( stderr, "AddAccessAllowedAce failed: %d\n", error );
            return FALSE;
        }
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\sdv\changes.cpp ===
/*****************************************************************************
 *
 *  changes.cpp
 *
 *      View the result of a change query.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  class CChanges
 *
 *****************************************************************************/

class CChanges : public LVFrame, public BGTask {

    friend DWORD CALLBACK CChanges_ThreadProc(LPVOID lpParameter);

protected:
    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:

    typedef LVFrame super;

    LRESULT ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_GETINFOTIP(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_DELETEITEM(UINT uiMsg, WPARAM wParam, LPARAM lParam);

    int     GetChangelist(int iItem);

private:                            /* Helpers */
    CChanges()
    {
        SetAcceleratorTable(MAKEINTRESOURCE(IDA_CHANGES));
    }

    void _AdjustMenu(HMENU hmenu, int iItem, BOOL fContextMenu);

    static DWORD CALLBACK s_BGInvoke(LPVOID lpParam);
    DWORD _BGInvoke();
    BOOL _BGGetSdCommandLine(String &str);
    void _BuildHint();
    void _ViewBug();
    int  _GetBugNumber(int iItem);

private:
    StringCache _scQuery;
    StringCache _scHint;
    StringCache _scUser;
};

int _CChanges_AddError(HWND hwndChild, LPCTSTR psz)
{
    LVITEM lvi;
    lvi.mask = LVIF_TEXT;
    lvi.iItem = MAXLONG;
    lvi.iSubItem = 0;
    lvi.pszText = CCAST(LPTSTR, psz);
    lvi.iItem = ListView_InsertItem(hwndChild, &lvi);

    if (lvi.iItem == 0) {
        ListView_SetCurSel(hwndChild, 0);   /* Select the first item */
    }
    return lvi.iItem;
}

int CChanges::GetChangelist(int iItem)
{
    if (iItem == -1) {
        iItem = GetCurSel();
    }
    if (iItem >= 0) {

        LVITEM lvi;
        TCHAR sz[64];

        if (ListView_GetItemText(_hwndChild, iItem, sz, ARRAYSIZE(sz))) {
            Substring ss;
            if (Parse(TEXT("$d$e"), sz, &ss)) {
                return StrToInt(sz);
            }
        }
    }
    return -1;
}

LRESULT CChanges::ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    static const LVFCOLUMN s_rgcol[] = {
        {  7 ,IDS_COL_CHANGE    ,LVCFMT_RIGHT   },
        { 15 ,IDS_COL_DATE      ,LVCFMT_LEFT    },
        { 10 ,IDS_COL_DEV       ,LVCFMT_LEFT    },
        { 30 ,IDS_COL_COMMENT   ,LVCFMT_LEFT    },
        {  0 ,0                 ,0              },
    };

    LRESULT lres = super::HandleMessage(uiMsg, wParam, lParam);
    if (lres == 0 &&
        SetWindowMenu(MAKEINTRESOURCE(IDM_CHANGES)) &&
        CreateChild(LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                    LVS_NOSORTHEADER,
                    LVS_EX_LABELTIP | LVS_EX_HEADERDRAGDROP |
                    LVS_EX_INFOTIP | LVS_EX_FULLROWSELECT) &&
        AddColumns(s_rgcol) &&
        BGStartTask(s_BGInvoke, this)) {

        String str;
        str << TEXT("sdv changes ") << _pszQuery;
        SetWindowText(_hwnd, str);
        lres = 0;
    } else {
        lres = -1;
    }
    return lres;
}

LRESULT CChanges::ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return BGFilterSetCursor(super::HandleMessage(uiMsg, wParam, lParam));
}

int CChanges::_GetBugNumber(int iItem)
{
    // 3 = checkin comment
    return ParseBugNumberFromSubItem(_hwndChild, iItem, 3);
}

LRESULT CChanges::ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iChange, iBug;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case IDM_VIEWDESC:
        ON_LM_ITEMACTIVATE(LM_ITEMACTIVATE, GetCurSel(), 0);
        return 0;

    case IDM_VIEWWINDIFF:
        WindiffChangelist(GetChangelist(GetCurSel()));
        return 0;

    case IDM_VIEWBUG:
        iBug = _GetBugNumber(GetCurSel());
        if (iBug) {
            OpenBugWindow(_hwnd, iBug);
        }
        return 0;
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

void CChanges::_AdjustMenu(HMENU hmenu, int iItem, BOOL fContextMenu)
{
    AdjustBugMenu(hmenu, _GetBugNumber(iItem), fContextMenu);
}

LRESULT CChanges::ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _AdjustMenu(RECAST(HMENU, wParam), GetCurSel(), FALSE);
    return 0;
}

LRESULT CChanges::ON_LM_GETINFOTIP(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPTSTR pszInfoTip = RECAST(LPTSTR, GetLVItem((int)wParam));
    if (pszInfoTip) {
        NMLVGETINFOTIP *pgit = RECAST(NMLVGETINFOTIP *, lParam);
        pgit->pszText = pszInfoTip;
    }
    return 0;
}

LRESULT CChanges::ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iChange = GetChangelist((int)wParam);
    if (iChange > 0) {
        if (_scHint.IsEmpty()) {
            _BuildHint();
        }
        String str;
        str << iChange << _scHint;
        LaunchThreadTask(CDescribe_ThreadProc, str);
    }

