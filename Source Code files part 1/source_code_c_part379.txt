ISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateSidEnumeration(
    IN PSAMPR_SID_ENUMERATION SidEnum
    )
{
    BEGIN_FUNCTION( SidEnum )

        if( !SampValidateRpcSID( (PRPC_SID) SidEnum->Sid ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( SidEnum->Name ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateEnumerationBuffer(
    IN PSAMPR_ENUMERATION_BUFFER EnumBuff
    )
{
    BEGIN_FUNCTION( EnumBuff )

        ULONG i;

        LENGTH_BUFFER_CONSISTENCY_CHECK( EnumBuff->EntriesRead, EnumBuff->Buffer );

        for( i = 0; i < EnumBuff->EntriesRead; ++i ) {
            if( !SampValidateRidEnumeration( EnumBuff->Buffer + i ) )
                RAISE_ERROR;
        }

    END_FUNCTION
}

BOOLEAN
SampValidateSD(
    IN PSAMPR_SR_SECURITY_DESCRIPTOR SD
    )
{
    BEGIN_FUNCTION( SD )

        LENGTH_BUFFER_CONSISTENCY_CHECK( SD->Length, SD->SecurityDescriptor );

        if( !NT_SUCCESS( SampValidatePassedSD( SD->Length, ( PISECURITY_DESCRIPTOR_RELATIVE ) SD->SecurityDescriptor ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateGroupMembership(
    IN PGROUP_MEMBERSHIP GroupMembership
    )
{
    BEGIN_FUNCTION( GroupMembership )

        // ISSUE: any possible checks?

    END_FUNCTION
}

BOOLEAN
SampValidateGroupsBuffer(
    IN PSAMPR_GET_GROUPS_BUFFER GroupsBuffer
    )
{
    BEGIN_FUNCTION( GroupsBuffer )

        ULONG i;

        LENGTH_BUFFER_CONSISTENCY_CHECK( GroupsBuffer->MembershipCount, GroupsBuffer->Groups );

        for( i = 0; i < GroupsBuffer->MembershipCount; ++i )
            if( !SampValidateGroupMembership( GroupsBuffer->Groups + i ) )
                RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateMembersBuffer(
    IN PSAMPR_GET_MEMBERS_BUFFER MembersBuffer
    )
{
    BEGIN_FUNCTION( MembersBuffer )

        LENGTH_BUFFER_CONSISTENCY_CHECK( MembersBuffer->MemberCount, MembersBuffer->Members );

        LENGTH_BUFFER_CONSISTENCY_CHECK( MembersBuffer->MemberCount, MembersBuffer->Attributes );

    END_FUNCTION
}

BOOLEAN
SampValidateLogonHours(
    IN PSAMPR_LOGON_HOURS LogonHours
    )
{
    BEGIN_FUNCTION( LogonHours )

        LENGTH_BUFFER_CONSISTENCY_CHECK( LogonHours->UnitsPerWeek, LogonHours->LogonHours );

    END_FUNCTION
}

BOOLEAN
SampValidateULongArray(
    IN PSAMPR_ULONG_ARRAY UlongArray
    )
{
    BEGIN_FUNCTION( UlongArray )

        LENGTH_BUFFER_CONSISTENCY_CHECK( UlongArray->Count, UlongArray->Element );

    END_FUNCTION
}


BOOLEAN
SampValidateSIDInformation(
    IN PSAMPR_SID_INFORMATION SIDInformation
    )
{
    BEGIN_FUNCTION( SIDInformation );

        if( !SampValidateRpcSID( ( PRPC_SID ) SIDInformation->SidPointer ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateSIDArray(
    IN PSAMPR_PSID_ARRAY SIDArray
    )
{
    BEGIN_FUNCTION( SIDArray )

        ULONG i;

        LENGTH_BUFFER_CONSISTENCY_CHECK( SIDArray->Count, SIDArray->Sids );

        for( i = 0; i < SIDArray->Count; ++i )
            if( !SampValidateSIDInformation( SIDArray->Sids + i ) )
                RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateUnicodeStringArray(
    IN PSAMPR_UNICODE_STRING_ARRAY UStringArray
    )
{
    BEGIN_FUNCTION( UStringArray )

        ULONG i;

        LENGTH_BUFFER_CONSISTENCY_CHECK( UStringArray->Count, UStringArray->Element );

        for( i = 0; i < UStringArray->Count; ++i )
            if( !SampValidateRpcUnicodeString( UStringArray->Element + i ) )
                RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateReturnedString(
    IN PSAMPR_RETURNED_STRING String
    )
{
    return SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) String );
}

BOOLEAN
SampValidateReturnedNormalString(
    IN PSAMPR_RETURNED_NORMAL_STRING String
    )
{
    return SampValidateRpcString( ( PRPC_STRING ) String );
}

BOOLEAN
SampValidateReturnedUStringArray(
    IN PSAMPR_RETURNED_USTRING_ARRAY UStringArray
    )
{
    return SampValidateUnicodeStringArray( ( PSAMPR_UNICODE_STRING_ARRAY ) UStringArray );
}

BOOLEAN
SampValidateRevisionInfoV1(
    IN PSAMPR_REVISION_INFO_V1 RevisionInfo
    )
{
    BEGIN_FUNCTION( RevisionInfo )

        // ISSUE: any possible checks?

    END_FUNCTION
}

NTSTATUS
SampValidateRevisionInfo(
    IN PSAMPR_REVISION_INFO RevisionInfo,
    IN ULONG RevisionVersion,
    IN BOOLEAN Trusted
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    NULL_CHECK( RevisionInfo );

    __try {

        switch( RevisionVersion ) {

            case 1:

                if( !SampValidateRevisionInfoV1( &( RevisionInfo->V1 ) ) )
                    RAISE_ERROR;

                break;

            default:
//                ASSERT( !"Unknown revision version" );
                RAISE_ERROR;
                break;
        }

        Status = STATUS_SUCCESS;

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        ASSERT( Status == STATUS_INVALID_PARAMETER );
    }

Error:
//    ASSERT( NT_SUCCESS( Status ) && "You called this function with invalid parameter." );

    return Status;

    UNREFERENCED_PARAMETER( Trusted );
}

BOOLEAN
SampValidateDomainGeneralInformation(
    IN PSAMPR_DOMAIN_GENERAL_INFORMATION GeneralInfo
    )
{
    BEGIN_FUNCTION( GeneralInfo )

        if( !SampValidateRpcUnicodeString( &( GeneralInfo->OemInformation ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( GeneralInfo->DomainName ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( GeneralInfo->ReplicaSourceNodeName ) ) )
            RAISE_ERROR;

        // ISSUE: what other checks can be done?

    END_FUNCTION
}

BOOLEAN
SampValidateDomainGeneralInformation2(
    IN PSAMPR_DOMAIN_GENERAL_INFORMATION2 GeneralInfo
    )
{
    BEGIN_FUNCTION( GeneralInfo )

        if( !SampValidateDomainGeneralInformation( &( GeneralInfo->I1 ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateDomainOemInformation(
    IN PSAMPR_DOMAIN_OEM_INFORMATION OemInfo
    )
{
    BEGIN_FUNCTION( OemInfo )

        if( !SampValidateRpcUnicodeString( &( OemInfo->OemInformation ) ) )
            RAISE_ERROR;

    END_FUNCTION
}



BOOLEAN
SampValidateDomainNameInformation(
    IN PSAMPR_DOMAIN_NAME_INFORMATION DomainNameInfo
    )
{
    BEGIN_FUNCTION( DomainNameInfo )

        if( !SampValidateRpcUnicodeString( &( DomainNameInfo->DomainName ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateDomainReplicationInformation(
    IN PSAMPR_DOMAIN_REPLICATION_INFORMATION DomainRepInfo
    )
{
    BEGIN_FUNCTION( DomainRepInfo )

        if( !SampValidateRpcUnicodeString( &( DomainRepInfo->ReplicaSourceNodeName ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateDomainLockoutInformation(
    IN PSAMPR_DOMAIN_LOCKOUT_INFORMATION DomainLockoutInfo
    )
{
    BEGIN_FUNCTION( DomainLockoutInfo )

        // ISSUE: any possible checks?

    END_FUNCTION
}

BOOLEAN
SampValidateDomainPasswordInformation(
    IN PDOMAIN_PASSWORD_INFORMATION DomainPassInfo
    )
{
    BEGIN_FUNCTION( DomainPassInfo )

        // ISSUE: any possible checks?

    END_FUNCTION
}

BOOLEAN
SampValidateDomainLogoffInformation(
    IN PDOMAIN_LOGOFF_INFORMATION DomainLogoffInfo
    )
{
    BEGIN_FUNCTION( DomainLogoffInfo );

        // ISSUE: any possible checks?

    END_FUNCTION
}

BOOLEAN
SampValidateDomainServerRoleInformation(
    IN PDOMAIN_SERVER_ROLE_INFORMATION DomainServerRoleInfo
    )
{
    BEGIN_FUNCTION( DomainServerRoleInfo )

        // ISSUE: any possible checks?

    END_FUNCTION
}

BOOLEAN
SampValidateDomainModifiedInformation(
    IN PDOMAIN_MODIFIED_INFORMATION DomainModifiedInfo
    )
{
    BEGIN_FUNCTION( DomainModifiedInfo )

        // ISSUE: any possible checks?

    END_FUNCTION
}

BOOLEAN
SampValidateDomainStateInformation(
    IN PDOMAIN_STATE_INFORMATION DomainStateInfo
    )
{
    BEGIN_FUNCTION( DomainStateInfo )

        // ISSUE: any possible checks?

    END_FUNCTION
}

BOOLEAN
SampValidateDomainModifiedInformation2(
    IN PDOMAIN_MODIFIED_INFORMATION2 DomainModifiedInfo2
    )
{
    BEGIN_FUNCTION( DomainModifiedInfo2 )

        // ISSUE: any possible checks?

    END_FUNCTION
}

NTSTATUS
SampValidateDomainInfoBuffer(
    IN PSAMPR_DOMAIN_INFO_BUFFER DomainInfoBuf,
    IN DOMAIN_INFORMATION_CLASS InfoClass,
    IN BOOLEAN Trusted
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    NULL_CHECK( DomainInfoBuf );

    __try {

        switch( InfoClass ) {

            case DomainPasswordInformation:

                if( !SampValidateDomainPasswordInformation( &( DomainInfoBuf->Password ) ) )
                    RAISE_ERROR;

                break;

            case DomainUasInformation:

                if( !Trusted )
                    RAISE_ERROR;

                //
                // Fall to DomainGeneralInformation
                //
            case DomainGeneralInformation:

                if( !SampValidateDomainGeneralInformation( &( DomainInfoBuf->General ) ) )
                    RAISE_ERROR;

                break;

            case DomainLogoffInformation:

                if( !SampValidateDomainLogoffInformation( &( DomainInfoBuf->Logoff ) ) )
                    RAISE_ERROR;

                break;

            case DomainOemInformation:

                if( !SampValidateDomainOemInformation( &( DomainInfoBuf->Oem ) ) )
                    RAISE_ERROR;

                break;

            case DomainNameInformation:

                if( !SampValidateDomainNameInformation( &( DomainInfoBuf->Name ) ) )
                    RAISE_ERROR;

                break;

            case DomainReplicationInformation:

                if( !SampValidateDomainReplicationInformation( &( DomainInfoBuf->Replication ) ) )
                    RAISE_ERROR;

                break;

            case DomainServerRoleInformation:

                if( !SampValidateDomainServerRoleInformation( &( DomainInfoBuf->Role ) ) )
                    RAISE_ERROR;

                break;

            case DomainModifiedInformation:

                if( !SampValidateDomainModifiedInformation( &( DomainInfoBuf->Modified ) ) )
                    RAISE_ERROR;

                break;

            case DomainStateInformation:

                if( !SampValidateDomainStateInformation( &( DomainInfoBuf->State ) ) )
                    RAISE_ERROR;

                break;

            case DomainGeneralInformation2:

                if( !SampValidateDomainGeneralInformation2( &( DomainInfoBuf->General2 ) ) )
                    RAISE_ERROR;

                break;

            case DomainLockoutInformation:

                if( !SampValidateDomainLockoutInformation( &( DomainInfoBuf->Lockout ) ) )
                    RAISE_ERROR;

                break;

            case DomainModifiedInformation2:

                if( !SampValidateDomainModifiedInformation2( &( DomainInfoBuf->Modified2 ) ) )
                    RAISE_ERROR;

                break;

            default:
                Status = STATUS_INVALID_INFO_CLASS;
                RAISE_ERROR;
                break;
        }

        Status = STATUS_SUCCESS;

    } __except( EXCEPTION_EXECUTE_HANDLER ) { }

Error:
//    ASSERT( NT_SUCCESS( Status ) && "You called this function with invalid parameter." );

    return Status;
}

BOOLEAN
SampValidateGroupGeneralInformation(
    IN PSAMPR_GROUP_GENERAL_INFORMATION GroupGeneralInfo
    )
{
    BEGIN_FUNCTION( GroupGeneralInfo )

        if( !SampValidateRpcUnicodeString( &( GroupGeneralInfo->Name ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( GroupGeneralInfo->AdminComment ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateGroupNameInformation(
    IN PSAMPR_GROUP_NAME_INFORMATION GroupNameInfo
    )
{
    BEGIN_FUNCTION( GroupNameInfo )

        if( !SampValidateRpcUnicodeString( &( GroupNameInfo->Name ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateGroupAdmCommentInformation(
    IN PSAMPR_GROUP_ADM_COMMENT_INFORMATION AdmCommentInfo
    )
{
    BEGIN_FUNCTION( AdmCommentInfo )

        if( !SampValidateRpcUnicodeString( &( AdmCommentInfo->AdminComment ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateGroupAttributeInformation(
    IN PGROUP_ATTRIBUTE_INFORMATION GroupAttrInfo
    )
{
    BEGIN_FUNCTION( GroupAttrInfo )

        // ISSUE: Any possible checks?

    END_FUNCTION
}

NTSTATUS
SampValidateGroupInfoBuffer(
    IN PSAMPR_GROUP_INFO_BUFFER GroupInfoBuf,
    IN GROUP_INFORMATION_CLASS GroupInfoClass,
    IN BOOLEAN Trusted
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    NULL_CHECK( GroupInfoBuf );

    __try {

        switch( GroupInfoClass ) {

            case GroupGeneralInformation:

                if( !SampValidateGroupGeneralInformation( &( GroupInfoBuf->General ) ) )
                    RAISE_ERROR;

                break;

            case GroupNameInformation:

                if( !SampValidateGroupNameInformation( &( GroupInfoBuf->Name ) ) )
                    RAISE_ERROR;

                break;

            case GroupAttributeInformation:

                if( !SampValidateGroupAttributeInformation( &( GroupInfoBuf->Attribute ) ) )
                    RAISE_ERROR;

                break;

            case GroupAdminCommentInformation:

                if( !SampValidateGroupAdmCommentInformation( &( GroupInfoBuf->AdminComment ) ) )
                    RAISE_ERROR;

                break;

            case GroupReplicationInformation:

                if( !SampValidateGroupGeneralInformation( &( GroupInfoBuf->DoNotUse ) ) )
                    RAISE_ERROR;

                if( GroupInfoBuf->DoNotUse.MemberCount != 0 )
                    RAISE_ERROR;

                break;

            default:

//                ASSERT( !"Unknown group information class" );
                Status = STATUS_INVALID_INFO_CLASS;
                RAISE_ERROR;
                break;
        }

        Status = STATUS_SUCCESS;

    } __except( EXCEPTION_EXECUTE_HANDLER ) { }

Error:
//    ASSERT( NT_SUCCESS( Status ) && "You called this function with invalid parameter." );

    return Status;

    UNREFERENCED_PARAMETER( Trusted );
}

BOOLEAN
SampValidateAliasGeneralInformation(
    IN PSAMPR_ALIAS_GENERAL_INFORMATION AliasGeneralInfo
    )
{
    BEGIN_FUNCTION( AliasGeneralInfo )

        if( !SampValidateRpcUnicodeString( &( AliasGeneralInfo->Name ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( AliasGeneralInfo->AdminComment ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateAliasNameInformation(
    IN PSAMPR_ALIAS_NAME_INFORMATION AliasNameInfo
    )
{
    BEGIN_FUNCTION( AliasNameInfo )

        if( !SampValidateRpcUnicodeString( &( AliasNameInfo->Name ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateAliasAdmCommentInformation(
    IN PSAMPR_ALIAS_ADM_COMMENT_INFORMATION AliasAdmCommentInfo
    )
{
    BEGIN_FUNCTION( AliasAdmCommentInfo )

        if( !SampValidateRpcUnicodeString( &( AliasAdmCommentInfo->AdminComment ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

NTSTATUS
SampValidateAliasInfoBuffer(
    IN PSAMPR_ALIAS_INFO_BUFFER AliasInfoBuf,
    IN ALIAS_INFORMATION_CLASS AliasInfoClass,
    IN BOOLEAN Trusted
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    NULL_CHECK( AliasInfoBuf );

    __try {

        switch( AliasInfoClass ) {

            case AliasReplicationInformation:

                if( !Trusted )
                    RAISE_ERROR;

                //
                // Fall to AliasGeneralInformation
                //
            case AliasGeneralInformation:

                if( !SampValidateAliasGeneralInformation( &( AliasInfoBuf->General ) ) )
                    RAISE_ERROR;

                break;

            case AliasNameInformation:

                if( !SampValidateAliasNameInformation( &( AliasInfoBuf->Name ) ) )
                    RAISE_ERROR;

                break;

            case AliasAdminCommentInformation:

                if( !SampValidateAliasAdmCommentInformation( &( AliasInfoBuf->AdminComment ) ) )
                    RAISE_ERROR;

                break;

            default:

                Status = STATUS_INVALID_INFO_CLASS;
                RAISE_ERROR;
                break;
        }

        Status = STATUS_SUCCESS;

    } __except( EXCEPTION_EXECUTE_HANDLER ) { }

Error:
//    ASSERT( NT_SUCCESS( Status ) && "You called this function with invalid parameter." );

    return Status;
}

BOOLEAN
SampValidateUserAllInformation(
    IN PSAMPR_USER_ALL_INFORMATION UserAllInfo
    )
{
    BEGIN_FUNCTION( UserAllInfo )

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->UserName ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->FullName ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->HomeDirectory ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->HomeDirectoryDrive ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->ScriptPath ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->ProfilePath ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->AdminComment ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->WorkStations ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->UserComment ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->Parameters ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->LmOwfPassword ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->NtOwfPassword ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAllInfo->PrivateData ) ) )
            RAISE_ERROR;


        if( UserAllInfo->SecurityDescriptor.Length != 0 ||
            UserAllInfo->SecurityDescriptor.SecurityDescriptor != NULL )
            if( !SampValidateSD( &( UserAllInfo->SecurityDescriptor ) ) )
                RAISE_ERROR;

        if( !SampValidateLogonHours( &( UserAllInfo->LogonHours ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserInternal3Information(
    IN PSAMPR_USER_INTERNAL3_INFORMATION UserInternal3Info
    )
{
    BEGIN_FUNCTION( UserInternal3Info )

        if( !SampValidateUserAllInformation( &( UserInternal3Info->I1 ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserGeneralInformation(
    IN PSAMPR_USER_GENERAL_INFORMATION UserGeneralInfo
    )
{
    BEGIN_FUNCTION( UserGeneralInfo )

        if( !SampValidateRpcUnicodeString( &( UserGeneralInfo->UserName ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserGeneralInfo->FullName ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserGeneralInfo->AdminComment ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserGeneralInfo->UserComment ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserPreferencesInformation(
    IN PSAMPR_USER_PREFERENCES_INFORMATION UserPrefInfo
    )
{

    BEGIN_FUNCTION( UserPrefInfo )

        if( !SampValidateRpcUnicodeString( &( UserPrefInfo->UserComment ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserPrefInfo->Reserved1 ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserParametersInformation(
    IN PSAMPR_USER_PARAMETERS_INFORMATION UserParametersInfo
    )
{
    BEGIN_FUNCTION( UserParametersInfo )

        if( !SampValidateRpcUnicodeString( &( UserParametersInfo->Parameters ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserLogonInformation(
    IN PSAMPR_USER_LOGON_INFORMATION UserLogonInfo
    )
{
    BEGIN_FUNCTION( UserLogonInfo )

        if( !SampValidateRpcUnicodeString( &( UserLogonInfo->UserName ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserLogonInfo->FullName ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserLogonInfo->HomeDirectory ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserLogonInfo->HomeDirectoryDrive ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserLogonInfo->ScriptPath ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserLogonInfo->ProfilePath ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserLogonInfo->WorkStations ) ) )
            RAISE_ERROR;

        if( !SampValidateLogonHours( &( UserLogonInfo->LogonHours ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserAccountInformation(
    IN PSAMPR_USER_ACCOUNT_INFORMATION UserAccountInfo
    )
{
    BEGIN_FUNCTION( UserAccountInfo )

        if( !SampValidateRpcUnicodeString( &( UserAccountInfo->UserName ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAccountInfo->FullName ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAccountInfo->HomeDirectory ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAccountInfo->HomeDirectoryDrive ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAccountInfo->ScriptPath ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAccountInfo->ProfilePath ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAccountInfo->AdminComment ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserAccountInfo->WorkStations ) ) )
            RAISE_ERROR;

        if( !SampValidateLogonHours( &( UserAccountInfo->LogonHours ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserANameInformation(
    IN PSAMPR_USER_A_NAME_INFORMATION UserANameInfo
    )
{
    BEGIN_FUNCTION( UserANameInfo )

        if( !SampValidateRpcUnicodeString( &( UserANameInfo->UserName ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserFNameInformation(
    IN PSAMPR_USER_F_NAME_INFORMATION UserFNameInfo
    )
{
    BEGIN_FUNCTION( UserFNameInfo )

        if( !SampValidateRpcUnicodeString( &( UserFNameInfo->FullName ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserNameInformation(
    IN PSAMPR_USER_NAME_INFORMATION UserNameInfo
    )
{
    BEGIN_FUNCTION( UserNameInfo )

        if( !SampValidateRpcUnicodeString( &( UserNameInfo->UserName ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserNameInfo->FullName ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateUserHomeInformation(
    IN PSAMPR_USER_HOME_INFORMATION UserHomeInfo
    )
{
    BEGIN_FUNCTION( UserHomeInfo )

        if( !SampValidateRpcUnicodeString( &( UserHomeInfo->HomeDirectory ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( &( UserHomeInfo->HomeDirectoryDrive ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserScriptInformation(
    IN PSAMPR_USER_SCRIPT_INFORMATION UserScriptInfo
    )
{
    BEGIN_FUNCTION( UserScriptInfo )

        if( !SampValidateRpcUnicodeString( &( UserScriptInfo->ScriptPath ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserProfileInformation(
    IN PSAMPR_USER_PROFILE_INFORMATION UserProfileInfo
    )
{
    BEGIN_FUNCTION( UserProfileInfo )

        if( !SampValidateRpcUnicodeString( &( UserProfileInfo->ProfilePath ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserAdminCommentInformation(
    IN PSAMPR_USER_ADMIN_COMMENT_INFORMATION UserAdmCommentInfo
    )
{
    BEGIN_FUNCTION( UserAdmCommentInfo );

        if( !SampValidateRpcUnicodeString( &( UserAdmCommentInfo->AdminComment ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserWorkstationsInformation(
    IN PSAMPR_USER_WORKSTATIONS_INFORMATION UserWorkstationsInfo
    )
{
    BEGIN_FUNCTION( UserWorkstationsInfo )

        if( !SampValidateRpcUnicodeString( &( UserWorkstationsInfo->WorkStations ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserLogonHoursInformation(
    IN PSAMPR_USER_LOGON_HOURS_INFORMATION UserLogonHoursInfo
    )
{
    BEGIN_FUNCTION( UserLogonHoursInfo )

        if( !SampValidateLogonHours( &( UserLogonHoursInfo->LogonHours ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserInternal1Information(
    IN PSAMPR_USER_INTERNAL1_INFORMATION UserInternal1Info
    )
{
    BEGIN_FUNCTION( UserInternal1Info )

        // ISSUE: any possible checks?

    END_FUNCTION
}


BOOLEAN
SampValidateUserInternal4Information(
    IN PSAMPR_USER_INTERNAL4_INFORMATION UserInternal4Info
    )
{
    BEGIN_FUNCTION( UserInternal4Info )

        if( !SampValidateUserAllInformation( &( UserInternal4Info->I1 ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserInternal4InformationNew(
    IN PSAMPR_USER_INTERNAL4_INFORMATION_NEW UserInternal4InfoNew
    )
{
    BEGIN_FUNCTION( UserInternal4InfoNew )

        if( !SampValidateUserAllInformation( &( UserInternal4InfoNew->I1 ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateUserInternal5Information(
    IN PSAMPR_USER_INTERNAL5_INFORMATION UserInternal5Info
    )
{
    BEGIN_FUNCTION( UserInternal5Info )

        // ISSUE: any possible checks?

    END_FUNCTION
}


BOOLEAN
SampValidateUserInternal5InformationNew(
    IN PSAMPR_USER_INTERNAL5_INFORMATION_NEW UserInternal5InfoNew
    )
{
    BEGIN_FUNCTION( UserInternal5InfoNew )

        // ISSUE: any possible checks?

    END_FUNCTION
}

BOOLEAN
SampValidateUserPrimaryGroupInformation(
    IN PUSER_PRIMARY_GROUP_INFORMATION UserPrimaryGroupInfo
    )
{
    BEGIN_FUNCTION( UserPrimaryGroupInfo )

        // ISSUE: any possible checks?

    END_FUNCTION
}

BOOLEAN
SampValidateUserControlInformation(
    IN PUSER_CONTROL_INFORMATION UserControlInfo
    )
{
    BEGIN_FUNCTION( UserControlInfo )

        // ISSUE: any possible checks?

    END_FUNCTION
}

BOOLEAN
SampValidateUserExpiresInformation(
    IN PUSER_EXPIRES_INFORMATION UserExpiresInfo
    )
{
    BEGIN_FUNCTION( UserExpiresInfo )

        // ISSUE: any possible checks?

    END_FUNCTION
}

BOOLEAN
SampValidateUserInternal2Information(
    IN USER_INTERNAL2_INFORMATION *UserInternal2Info
    )
{
    BEGIN_FUNCTION( UserInternal2Info )

        // ISSUE: any possible checks?

    END_FUNCTION
}

NTSTATUS
SampValidateUserInfoBuffer(
    IN PSAMPR_USER_INFO_BUFFER UserInfoBuf,
    IN USER_INFORMATION_CLASS UserInfoClass,
    IN BOOLEAN Trusted
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    NULL_CHECK( UserInfoBuf );

    __try {

        switch( UserInfoClass ) {

            case UserGeneralInformation:

                if( !SampValidateUserGeneralInformation( &( UserInfoBuf->General ) ) )
                    RAISE_ERROR;

                break;

            case UserPreferencesInformation:

                if( !SampValidateUserPreferencesInformation( &( UserInfoBuf->Preferences ) ) )
                    RAISE_ERROR;

                break;

            case UserLogonInformation:

                if( !SampValidateUserLogonInformation( &( UserInfoBuf->Logon ) ) )
                    RAISE_ERROR;

                break;

            case UserLogonHoursInformation:

                if( !SampValidateUserLogonHoursInformation( &( UserInfoBuf->LogonHours ) ) )
                    RAISE_ERROR;

                break;

            case UserAccountInformation:

                if( !SampValidateUserAccountInformation( &( UserInfoBuf->Account ) ) )
                    RAISE_ERROR;

                break;

            case UserNameInformation:

                if( !SampValidateUserNameInformation( &( UserInfoBuf->Name ) ) )
                    RAISE_ERROR;

                break;

            case UserAccountNameInformation:

                if( !SampValidateUserANameInformation( &( UserInfoBuf->AccountName ) ) )
                    RAISE_ERROR;

                break;

            case UserFullNameInformation:

                if( !SampValidateUserFNameInformation( &( UserInfoBuf->FullName ) ) )
                    RAISE_ERROR;

                break;

            case UserPrimaryGroupInformation:

                if( !SampValidateUserPrimaryGroupInformation( &( UserInfoBuf->PrimaryGroup ) ) )
                    RAISE_ERROR;

                break;

            case UserHomeInformation:

                if( !SampValidateUserHomeInformation( &( UserInfoBuf->Home ) ) )
                    RAISE_ERROR;

                break;

            case UserScriptInformation:

                if( !SampValidateUserScriptInformation( &( UserInfoBuf->Script ) ) )
                    RAISE_ERROR;

                break;

            case UserProfileInformation:

                if( !SampValidateUserProfileInformation( &( UserInfoBuf->Profile ) ) )
                    RAISE_ERROR;

                break;

            case UserAdminCommentInformation:

                if( !SampValidateUserAdminCommentInformation( &( UserInfoBuf->AdminComment ) ) )
                    RAISE_ERROR;

                break;

            case UserWorkStationsInformation:

                if( !SampValidateUserWorkstationsInformation( &( UserInfoBuf->WorkStations ) ) )
                    RAISE_ERROR;

                break;

            case UserSetPasswordInformation:

                //
                //  This type cannot be queried or set
                //
                RAISE_ERROR;
                break;

            case UserControlInformation:

                if( !SampValidateUserControlInformation( &( UserInfoBuf->Control ) ) )
                    RAISE_ERROR;

                break;

            case UserExpiresInformation:

                if( !SampValidateUserExpiresInformation( &( UserInfoBuf->Expires ) ) )
                    RAISE_ERROR;

                break;

            case UserInternal1Information:

                if( !SampValidateUserInternal1Information( &( UserInfoBuf->Internal1 ) ) )
                    RAISE_ERROR;

                break;

            case UserInternal2Information:

                if( !SampValidateUserInternal2Information( &( UserInfoBuf->Internal2 ) ) )
                    RAISE_ERROR;

                break;

            case UserParametersInformation:

                if( !SampValidateUserParametersInformation( &( UserInfoBuf->Parameters ) ) )
                    RAISE_ERROR;

                break;

            case UserAllInformation:

                if( !SampValidateUserAllInformation( &( UserInfoBuf->All ) ) )
                    RAISE_ERROR;

                break;

            case UserInternal3Information:

                if( !Trusted ) {
                    Status = STATUS_INVALID_INFO_CLASS;
                    RAISE_ERROR;
                }

                if( !SampValidateUserInternal3Information( &( UserInfoBuf->Internal3 ) ) )
                    RAISE_ERROR;

                break;

            case UserInternal4Information:

                if( !SampValidateUserInternal4Information( &( UserInfoBuf->Internal4 ) ) )
                    RAISE_ERROR;

                break;

            case UserInternal5Information:

                if( !SampValidateUserInternal5Information( &( UserInfoBuf->Internal5 ) ) )
                    RAISE_ERROR;

                break;

            case UserInternal4InformationNew:

                if( !SampValidateUserInternal4InformationNew( &( UserInfoBuf->Internal4New ) ) )
                    RAISE_ERROR;

                break;

            case UserInternal5InformationNew:

                if( !SampValidateUserInternal5InformationNew( &( UserInfoBuf->Internal5New ) ) )
                    RAISE_ERROR;

                break;

            case UserInternal6Information:

                if( !Trusted ) {
                    Status = STATUS_INVALID_INFO_CLASS;
                    RAISE_ERROR;
                }

                //
                // ISSUE: Needs additional checks
                //
                break;

            default:

                Status = STATUS_INVALID_INFO_CLASS;
                RAISE_ERROR;
                break;
        }

        Status = STATUS_SUCCESS;

    } __except( EXCEPTION_EXECUTE_HANDLER ) { }

Error:
//    ASSERT( NT_SUCCESS( Status ) && "You called this function with invalid parameter." );

    return Status;
}


BOOLEAN
SampValidateDomainDisplayUser(
    IN PSAMPR_DOMAIN_DISPLAY_USER DomainDisplayUser
    )
{
    BEGIN_FUNCTION( DomainDisplayUser )

        if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &( DomainDisplayUser->LogonName ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &( DomainDisplayUser->AdminComment ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &( DomainDisplayUser->FullName ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateDomainDisplayMachine(
    IN PSAMPR_DOMAIN_DISPLAY_MACHINE DomainDisplayMachine
    )
{
    BEGIN_FUNCTION( DomainDisplayMachine )

        if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &( DomainDisplayMachine->Machine ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &( DomainDisplayMachine->Comment ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateDomainDisplayGroup(
    IN PSAMPR_DOMAIN_DISPLAY_GROUP DomainDisplayGroup
    )
{
    BEGIN_FUNCTION( DomainDisplayGroup )

        if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &( DomainDisplayGroup->Group ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &( DomainDisplayGroup->Comment ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateDomainDisplayOemUser(
    IN PSAMPR_DOMAIN_DISPLAY_OEM_USER DomainDisplayOemUser
    )
{
    BEGIN_FUNCTION( DomainDisplayOemUser )

        if( !SampValidateRpcString( ( PRPC_STRING ) &( DomainDisplayOemUser->OemUser ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateDomainDisplayOemGroup(
    IN PSAMPR_DOMAIN_DISPLAY_OEM_GROUP DomainDisplayOemGroup
    )
{
    BEGIN_FUNCTION( DomainDisplayOemGroup )

        if( !SampValidateRpcString( ( PRPC_STRING ) &( DomainDisplayOemGroup->OemGroup ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateDomainDisplayUserBuffer(
    IN PSAMPR_DOMAIN_DISPLAY_USER_BUFFER DomainDisplayUserBuffer
    )
{
    BEGIN_FUNCTION( DomainDisplayUserBuffer )

        ULONG i;

        LENGTH_BUFFER_CONSISTENCY_CHECK( DomainDisplayUserBuffer->EntriesRead, DomainDisplayUserBuffer->Buffer );

        for( i = 0; i < DomainDisplayUserBuffer->EntriesRead; ++i )
            if( !SampValidateDomainDisplayUser( DomainDisplayUserBuffer->Buffer + i ) )
                RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateDomainDisplayMachineBuffer(
    IN PSAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER DomainDisplayMachineBuffer
    )
{
    BEGIN_FUNCTION( DomainDisplayMachineBuffer )

        ULONG i;

        LENGTH_BUFFER_CONSISTENCY_CHECK( DomainDisplayMachineBuffer->EntriesRead, DomainDisplayMachineBuffer->Buffer );

        for( i = 0; i < DomainDisplayMachineBuffer->EntriesRead; ++i )
            if( !SampValidateDomainDisplayMachine( DomainDisplayMachineBuffer->Buffer + i ) )
                RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateDomainDisplayGroupBuffer(
    IN PSAMPR_DOMAIN_DISPLAY_GROUP_BUFFER DomainDisplayGroupBuffer
    )
{
    BEGIN_FUNCTION( DomainDisplayGroupBuffer )

        ULONG i;

        LENGTH_BUFFER_CONSISTENCY_CHECK( DomainDisplayGroupBuffer->EntriesRead, DomainDisplayGroupBuffer->Buffer );

        for( i = 0; i < DomainDisplayGroupBuffer->EntriesRead; ++i )
            if( !SampValidateDomainDisplayGroup( DomainDisplayGroupBuffer->Buffer + i ) )
                RAISE_ERROR;

    END_FUNCTION
}


BOOLEAN
SampValidateDomainDisplayOemUserBuffer(
    IN PSAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER DomainDisplayOemUserBuffer
    )
{
    BEGIN_FUNCTION( DomainDisplayOemUserBuffer )

        ULONG i;

        LENGTH_BUFFER_CONSISTENCY_CHECK( DomainDisplayOemUserBuffer->EntriesRead, DomainDisplayOemUserBuffer->Buffer );

        for( i = 0; i < DomainDisplayOemUserBuffer->EntriesRead; ++i )
            if( !SampValidateDomainDisplayOemUser( DomainDisplayOemUserBuffer->Buffer + i ) )
                RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateDomainDisplayOemGroupBuffer(
    IN PSAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER DomainDisplayOemGroupBuffer
    )
{
    BEGIN_FUNCTION( DomainDisplayOemGroupBuffer )

        ULONG i;

        LENGTH_BUFFER_CONSISTENCY_CHECK( DomainDisplayOemGroupBuffer->EntriesRead, DomainDisplayOemGroupBuffer->Buffer );

        for( i = 0; i < DomainDisplayOemGroupBuffer->EntriesRead; ++i )
            if( !SampValidateDomainDisplayOemGroup( DomainDisplayOemGroupBuffer->Buffer + i ) )
                RAISE_ERROR;

    END_FUNCTION
}


NTSTATUS
SampValidateDisplayInfoBuffer(
    IN PSAMPR_DISPLAY_INFO_BUFFER DisplayInfoBuff,
    IN DOMAIN_DISPLAY_INFORMATION DomainDisplayInfoClass,
    IN BOOLEAN Trusted
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    NULL_CHECK( DisplayInfoBuff );

    __try {

        switch( DomainDisplayInfoClass ) {

            case DomainDisplayUser:

                if( !SampValidateDomainDisplayUserBuffer( &( DisplayInfoBuff->UserInformation ) ) )
                    RAISE_ERROR;

                break;

            case DomainDisplayServer:

                if( !Trusted ) {

                    Status = STATUS_INVALID_INFO_CLASS;
                    RAISE_ERROR;
                }

                //
                // Fall into DisplayMachine
                //
            case DomainDisplayMachine:

                if( !SampValidateDomainDisplayMachineBuffer( &( DisplayInfoBuff->MachineInformation ) ) )
                    RAISE_ERROR;

                break;

            case DomainDisplayGroup:

                if( !SampValidateDomainDisplayGroupBuffer( &( DisplayInfoBuff->GroupInformation ) ) )
                    RAISE_ERROR;

                break;

            case DomainDisplayOemUser:

                if( !SampValidateDomainDisplayOemUserBuffer( &( DisplayInfoBuff->OemUserInformation ) ) )
                    RAISE_ERROR;

                break;

            case DomainDisplayOemGroup:

                if( !SampValidateDomainDisplayOemGroupBuffer( &( DisplayInfoBuff->OemGroupInformation ) ) )
                    RAISE_ERROR;

                break;

            default:

                Status = STATUS_INVALID_INFO_CLASS;
                RAISE_ERROR;
                break;

        }

        Status = STATUS_SUCCESS;

    } __except( EXCEPTION_EXECUTE_HANDLER ) { }

Error:
//    ASSERT( NT_SUCCESS( Status ) && "You called this function with invalid parameter." );

    return Status;
}

BOOLEAN
SampValidateValidatePasswordHash(
    IN PSAM_VALIDATE_PASSWORD_HASH PassHash
    )
{
    BEGIN_FUNCTION( PassHash )

        LENGTH_BUFFER_CONSISTENCY_CHECK( PassHash->Length, PassHash->Hash );

    END_FUNCTION
}

BOOLEAN
SampValidateValidatePersistedFields(
    IN PSAM_VALIDATE_PERSISTED_FIELDS PersistedFields
    )
{
    BEGIN_FUNCTION( PersistedFields )

        ULONG i;

        LENGTH_BUFFER_CONSISTENCY_CHECK( PersistedFields->PasswordHistoryLength, PersistedFields->PasswordHistory );

        for( i = 0; i < PersistedFields->PasswordHistoryLength; ++i )
            if( !SampValidateValidatePasswordHash( PersistedFields->PasswordHistory + i ) )
                RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateValidateAuthenticationInputArg(
    IN PSAM_VALIDATE_AUTHENTICATION_INPUT_ARG AuthenticationInputArg
    )
{
    BEGIN_FUNCTION( AuthenticationInputArg )

        if( !SampValidateValidatePersistedFields( &( AuthenticationInputArg->InputPersistedFields ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateValidatePasswordChangeInputArg(
    IN PSAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG PassChangeInputArg
    )
{
    BEGIN_FUNCTION( PassChangeInputArg )

        if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &( PassChangeInputArg->ClearPassword ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &( PassChangeInputArg->UserAccountName ) ) )
            RAISE_ERROR;

        if( !SampValidateValidatePasswordHash( &( PassChangeInputArg->HashedPassword ) ) )
            RAISE_ERROR;

        if( !SampValidateValidatePersistedFields( &( PassChangeInputArg->InputPersistedFields ) ) )
            RAISE_ERROR;

    END_FUNCTION
}

BOOLEAN
SampValidateValidatePasswordResetInputArg(
    IN PSAM_VALIDATE_PASSWORD_RESET_INPUT_ARG PassResetInputArg
    )
{
    BEGIN_FUNCTION( PassResetInputArg )

        if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &( PassResetInputArg->ClearPassword ) ) )
            RAISE_ERROR;

        if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &( PassResetInputArg->UserAccountName ) ) )
            RAISE_ERROR;

        if( !SampValidateValidatePasswordHash( &( PassResetInputArg->HashedPassword ) ) )
            RAISE_ERROR;

        if( !SampValidateValidatePersistedFields( &( PassResetInputArg->InputPersistedFields ) ) )
            RAISE_ERROR;

    END_FUNCTION
}


NTSTATUS
SampValidateValidateInputArg(
    IN PSAM_VALIDATE_INPUT_ARG ValidateInputArg,
    IN PASSWORD_POLICY_VALIDATION_TYPE ValidationType,
    IN BOOLEAN Trusted
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    NULL_CHECK( ValidateInputArg );

    __try{

        switch( ValidationType ) {

            case SamValidateAuthentication:

                if( !SampValidateValidateAuthenticationInputArg( &( ValidateInputArg->ValidateAuthenticationInput ) ) )
                    RAISE_ERROR;
                break;

            case SamValidatePasswordChange:

                if( !SampValidateValidatePasswordChangeInputArg( &( ValidateInputArg->ValidatePasswordChangeInput ) ) )
                    RAISE_ERROR;
                break;

            case SamValidatePasswordReset:

                if( !SampValidateValidatePasswordResetInputArg( &( ValidateInputArg->ValidatePasswordResetInput ) ) )
                    RAISE_ERROR;
                break;

            default:

                Status = STATUS_INVALID_INFO_CLASS;
                RAISE_ERROR;
                break;
        }
        Status = STATUS_SUCCESS;

    } __except( EXCEPTION_EXECUTE_HANDLER ) { }

Error:
//    ASSERT( NT_SUCCESS( Status ) && "You called this function with invalid parameter." );

    return Status;

    UNREFERENCED_PARAMETER( Trusted );
}

BOOLEAN
SampValidateValidateStandartOutputArg(
    IN PSAM_VALIDATE_STANDARD_OUTPUT_ARG StOutputArg
    )
{
    BEGIN_FUNCTION( StOutputArg )

        if( !SampValidateValidatePersistedFields( &(StOutputArg->ChangedPersistedFields) ) )
            RAISE_ERROR;

    END_FUNCTION
}

NTSTATUS
SampValidateValidateOutputArg(
    IN PSAM_VALIDATE_OUTPUT_ARG ValidateOutputArg,
    IN PASSWORD_POLICY_VALIDATION_TYPE ValidationType,
    IN BOOLEAN Trusted
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    NULL_CHECK( ValidateOutputArg );

    __try{

        switch( ValidationType ) {

            case SamValidateAuthentication:

                if( !SampValidateValidateStandartOutputArg( &( ValidateOutputArg->ValidateAuthenticationOutput ) ) )
                    RAISE_ERROR;
                break;

            case SamValidatePasswordChange:

                if( !SampValidateValidateStandartOutputArg( &( ValidateOutputArg->ValidatePasswordChangeOutput ) ) )
                    RAISE_ERROR;
                break;

            case SamValidatePasswordReset:

                if( !SampValidateValidateStandartOutputArg( &( ValidateOutputArg->ValidatePasswordResetOutput ) ) )
                    RAISE_ERROR;
                break;

            default:
                Status = STATUS_INVALID_INFO_CLASS;
                RAISE_ERROR;
                break;
        }
        Status = STATUS_SUCCESS;

    } __except( EXCEPTION_EXECUTE_HANDLER ) { }

Error:
//    ASSERT( NT_SUCCESS( Status ) && "You called this function with invalid parameter." );

    return Status;

    UNREFERENCED_PARAMETER( Trusted );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsupgrad\interfac.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    interfac.c

Abstract:

    Interface routine to transfer SAM information in Registry to DS


Author:

    ColinBr 30-Jul-1996

Environment:

    User Mode - Win32

Revision History:

--*/

#include <samsrvp.h>
#include <util.h>

ULONG DebugInfoLevel = _DEB_ERROR | _DEB_WARNING;

NTSTATUS
TransferSamObjects(
    WCHAR *wcszSamRegPath
);

NTSTATUS
SampRegistryToDsUpgrade(
    WCHAR *wcszSamRegLocation
    )

/*++

Routine Description:

    This routine is the interface function for the routines to transfer
    SAM objects from the registry to to the directory service


Parameters:

    wcszSamLocation  - this is the location of the SAM repository in the registry

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    Note all exceptions are caught so the return value will relfect any unsual
    exceptions

--*/
{

    ASSERT(wcszSamRegLocation);

    return TransferSamObjects(wcszSamRegLocation);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsupgrad\interfc1.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    interfac.c

Abstract:

    Interface routine to transfer SAM information in Registry to DS


Author:

    ColinBr 30-Jul-1996

Environment:

    User Mode - Win32

Revision History:

--*/

extern "C" {
#include <samsrvp.h>
#include <util.h>
}
#include <convobj.hxx>

extern CDomainObject *pRootDomainObject;

ULONG DebugInfoLevel = _DEB_ERROR | _DEB_WARNING;

extern "C"
NTSTATUS
TransferSamObjects(
    WCHAR *wcszSamRegPath
);

extern "C"
NTSTATUS
SampRegistryToDsUpgrade(
    WCHAR *wcszSamRegLocation
    )

/*++

Routine Description:

    This routine is the interface function for the routines to transfer
    SAM objects from the registry to to the directory service


Parameters:

    wcszSamLocation  - this is the location of the SAM repository in the registry

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    Note all exceptions are caught so the return value will relfect any unsual
    exceptions

--*/
{
    CDomainObject RootDomainObject;

    ASSERT(wcszSamRegLocation);

    pRootDomainObject = &RootDomainObject;

    return TransferSamObjects(wcszSamRegLocation);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\crack\crack.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsapi.h>
#include <ntdsapip.h>
#include <winsock2.h>

// test from ds side

// Not all formats are legal for both input and output.  The first example
// of this is DS_SID_OR_SID_HISTORY_NAME which is legal for input, but not
// output.  So we map to the best equivalent output format.

typedef struct _Format
{
    DWORD   offered;
    DWORD   desired;
} Format;

Format rFormats[] = 
{
    { DS_FQDN_1779_NAME,            DS_FQDN_1779_NAME },
    { DS_NT4_ACCOUNT_NAME,          DS_NT4_ACCOUNT_NAME },
    { DS_DISPLAY_NAME,              DS_DISPLAY_NAME },
    { DS_UNIQUE_ID_NAME,            DS_UNIQUE_ID_NAME },
    { DS_CANONICAL_NAME,            DS_CANONICAL_NAME },
    { DS_USER_PRINCIPAL_NAME,       DS_USER_PRINCIPAL_NAME },
    { DS_CANONICAL_NAME_EX,         DS_CANONICAL_NAME_EX },
    { DS_SERVICE_PRINCIPAL_NAME,    DS_SERVICE_PRINCIPAL_NAME },
    { DS_SID_OR_SID_HISTORY_NAME,   DS_STRING_SID_NAME }
};

#define cFormats        9
#define iFqdn           0
#define iCanonical      4
#define iCanonicalEx    6

CHAR status_buffer[100];

CHAR * Status(
    DWORD status)
{
    switch ( status )
    {
    // from sdk\inc\ntdsapi.h
    case DS_NAME_NO_ERROR:          
        return("DS_NAME_NO_ERROR");
    case DS_NAME_ERROR_RESOLVING:   
        return("DS_NAME_ERROR_RESOLVING");
    case DS_NAME_ERROR_NOT_FOUND:   
        return("DS_NAME_ERROR_NOT_FOUND");
    case DS_NAME_ERROR_NOT_UNIQUE:  
        return("DS_NAME_ERROR_NOT_UNIQUE");
    case DS_NAME_ERROR_NO_MAPPING:  
        return("DS_NAME_ERROR_NO_MAPPING");
    case DS_NAME_ERROR_DOMAIN_ONLY: 
        return("DS_NAME_ERROR_DOMAIN_ONLY");
    case DS_NAME_ERROR_TRUST_REFERRAL:
        return ("DS_NAME_ERROR_TRUST_REFERRAL");
    case DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING:
        return("DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING");
    // from src\dsamain\include\ntdsapip.h
    case DS_NAME_ERROR_IS_FPO:
        return("DS_NAME_ERROR_IS_FPO");
    case DS_NAME_ERROR_IS_SID_USER:
        return("DS_NAME_ERROR_IS_SID_USER");
    case DS_NAME_ERROR_IS_SID_GROUP:
        return("DS_NAME_ERROR_IS_SID_GROUP");
    case DS_NAME_ERROR_IS_SID_ALIAS:
        return("DS_NAME_ERROR_IS_SID_ALIAS");
    case DS_NAME_ERROR_IS_SID_UNKNOWN:
        return("DS_NAME_ERROR_IS_SID_UNKNOWN");
    case DS_NAME_ERROR_IS_SID_HISTORY_USER:
        return("DS_NAME_ERROR_IS_SID_HISTORY_USER");
    case DS_NAME_ERROR_IS_SID_HISTORY_GROUP:
        return("DS_NAME_ERROR_IS_SID_HISTORY_GROUP");
    case DS_NAME_ERROR_IS_SID_HISTORY_ALIAS:
        return("DS_NAME_ERROR_IS_SID_HISTORY_ALIAS");
    case DS_NAME_ERROR_IS_SID_HISTORY_UNKNOWN:
        return("DS_NAME_ERROR_IS_SID_HISTORY_UNKNOWN");
    }

    sprintf(status_buffer, "unknown status - 0x%x", status);

    return(status_buffer);
}

BOOL CrackNameStatusSuccess(
    DWORD s)
{
    switch ( s ) 
    {
    case DS_NAME_NO_ERROR:
    case DS_NAME_ERROR_IS_SID_USER:
    case DS_NAME_ERROR_IS_SID_GROUP:
    case DS_NAME_ERROR_IS_SID_ALIAS:
    case DS_NAME_ERROR_IS_SID_UNKNOWN:
    case DS_NAME_ERROR_IS_SID_HISTORY_USER:
    case DS_NAME_ERROR_IS_SID_HISTORY_GROUP:
    case DS_NAME_ERROR_IS_SID_HISTORY_ALIAS:
    case DS_NAME_ERROR_IS_SID_HISTORY_UNKNOWN:

        return TRUE;
    }

    return FALSE;
}

CHAR * pszFormat(
    DWORD format)
{
    switch ( format )
    {
    case DS_UNKNOWN_NAME:               return("DS_UNKNOWN_NAME");
    case DS_FQDN_1779_NAME:             return("DS_FQDN_1779_NAME");
    case DS_NT4_ACCOUNT_NAME:           return("DS_NT4_ACCOUNT_NAME");
    case DS_DISPLAY_NAME:               return("DS_DISPLAY_NAME");
    case DS_UNIQUE_ID_NAME:             return("DS_UNIQUE_ID_NAME");
    case DS_CANONICAL_NAME:             return("DS_CANONICAL_NAME");
    case DS_USER_PRINCIPAL_NAME:        return("DS_USER_PRINCIPAL_NAME");
    case DS_CANONICAL_NAME_EX:          return("DS_CANONICAL_NAME_EX");
    case DS_SERVICE_PRINCIPAL_NAME:     return("DS_SERVICE_PRINCIPAL_NAME");
    case DS_STRING_SID_NAME:            return("DS_STRING_SID_NAME");
    case DS_SID_OR_SID_HISTORY_NAME:    return("DS_SID_OR_SID_HISTORY_NAME");
    }

    return("unknown format");
}

extern VOID SiteInfo(HANDLE hDS);
extern VOID LdapInfo(HANDLE hDS, CHAR *pszDomain);
extern VOID GuidInfo(HANDLE hDS);
extern VOID DomainInfo1(HANDLE hDS, CHAR *pszDomain);
extern VOID DomainInfo2(HANDLE hDS, CHAR *pszDomain);
extern VOID CheckInternationalDN(HANDLE hDS, CHAR *pszName);
extern VOID GCInfo(HANDLE hDS);
extern VOID QuoteRdn(CHAR *pszUnquotedRdn);
extern VOID UnquoteRdn(CHAR *pszQuotedRdn);
extern VOID GetRdn(CHAR *psDN);

void _cdecl
main(
    int     argc, 
    char    **argv)
{
    DWORD                       dwErr;
    DS_NAME_RESULTA             *rpResult[cFormats];
    DS_NAME_RESULTA             *pResult;
    DWORD                       i;
    HANDLE                      hDS;
    CHAR                        *pchar = NULL;
    BOOL                        fDoSyntacticTest = TRUE;
    RPC_AUTH_IDENTITY_HANDLE    hAuth = NULL;
    CHAR                        *bindArg1, *bindArg2;
    DWORD                       knownFormatOffered;
    DWORD                       cKnownFormatOffered = 0;
    CHAR                        *pszSpn;
    CHAR                        *pDom, *pUser, *pPwd;

    if ( 8 == argc )
    {
        // First 3 args are domain user and password.
        pDom = _stricmp(argv[1], "null") ? argv[1] : NULL;
        pUser = _stricmp(argv[2], "null") ? argv[2] : NULL;
        pPwd = _stricmp(argv[3], "null") ? argv[3] : NULL;

        dwErr = DsMakePasswordCredentialsA(pUser, pDom, pPwd, &hAuth);

        if ( 0 != dwErr )
        {
            printf("DsMakePasswordCredentialsA error 0x%x\n", dwErr);
            goto Usage;
        }

        // Advance argc and argv so as not to have to rewrite all code
        // which pre-existed {dom user pwd} support.

        argc -= 3;
        argv = &argv[3];
    }

    if ( 5 != argc && 3 != argc )
    {
Usage:
        printf("usage:\n");
        printf("\tcrack {dom user pwd} DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL name\n");
        printf("\tcrack {dom user pwd} -siteInfo DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL\n");
        printf("\tcrack {dom user pwd} -schemaGuid DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL\n");
        printf("\tcrack {dom user pwd} -domInfo1:domainName DottedIpAddress/NULL DnsDomainName/NULLSPN/NULL \n");
        printf("\tcrack {dom user pwd} -domInfo2:domainName DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL\n");
        printf("\tcrack {dom user pwd} -intlDN:objName DottedIpAddress/NULL DnsDomainName/NULLSPN/NULL\n");
        printf("\tcrack {dom user pwd} -ldapInfo:domainName DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL\n");
        printf("\tcrack {dom user pwd} -gcInfo DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL\n");
        printf("\tcrack                -quote UnquotedRdnValue\n");
        printf("\tcrack                -unquote QuotedRdnValue\n");
        printf("\tcrack                -getrdn DN\n");
        return;
    }

    //
    // crack ...
    //
    if ( (_stricmp("-quote", argv[1]) == 0) ||
         (_stricmp("-unquote", argv[1]) == 0) ||
         (_stricmp("-getrdn", argv[1]) == 0) )
    {
        //
        // Make quoted Rdn
        //
        if ( argc != 3 )
        {
            goto Usage;
        }
    }
    else
    {
        if (    _stricmp("-siteInfo", argv[1]) 
             && _strnicmp("-ldapInfo:", argv[1], 10) 
             && _strnicmp("-domInfo1:", argv[1], 10) 
             && _strnicmp("-domInfo2:", argv[1], 10) 
             && _strnicmp("-intlDN:", argv[1], 8) 
             && _stricmp("-schemaGuid", argv[1]) 
             && _stricmp("-gcInfo", argv[1]) )
        {
            bindArg1 = _stricmp(argv[1], "null") ? argv[1] : NULL;
            bindArg2 = _stricmp(argv[2], "null") ? argv[2] : NULL;
            pszSpn   = _stricmp(argv[3], "null") ? argv[3] : NULL;
        }
        else
        {
            bindArg1 = _stricmp(argv[2], "null") ? argv[2] : NULL;
            bindArg2 = _stricmp(argv[3], "null") ? argv[3] : NULL;
            pszSpn   = _stricmp(argv[4], "null") ? argv[4] : NULL;
        }

        if ( pszSpn )
        {
            dwErr = DsBindWithSpnA(bindArg1, bindArg2, hAuth, pszSpn, &hDS);
            if ( hAuth ) DsFreePasswordCredentials(hAuth);
        }
        else if ( hAuth )
        {
            dwErr = DsBindWithCredA(bindArg1, bindArg2, hAuth, &hDS);
            DsFreePasswordCredentials(hAuth);
        }
        else
        {
            dwErr = DsBindA(bindArg1, bindArg2, &hDS);
        }

        if ( 0 != dwErr )
        {
            printf("%s error 0x%x\n", 
                   ( pszSpn 
                        ? "DsBindWithSpnA"
                        : ( hAuth
                                ? "DsBindWithCredA"
                                : "DsBindA" ) ),
                   dwErr);
            return;
        }
    }

    if ( !_stricmp("-getrdn", argv[1]) )
    {
        GetRdn(argv[2]);

        return;
    } else if ( !_stricmp("-quote", argv[1]) )
    {
        QuoteRdn(argv[2]);

        return;
    }
    else if ( !_stricmp("-unquote", argv[1]) )
        {
            UnquoteRdn(argv[2]);
    
            return;
    }
    else if ( !_stricmp("-siteInfo", argv[1]) )
    {
        SiteInfo(hDS);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_strnicmp("-ldapInfo:", argv[1],10) )
    {
        LdapInfo(hDS, &argv[1][10]);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_strnicmp("-intlDN:", argv[1], 8) )
    {
        CheckInternationalDN(hDS, &argv[1][8]);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_strnicmp("-domInfo1:", argv[1], 10) )
    {
        DomainInfo1(hDS, &argv[1][10]);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_strnicmp("-domInfo2:", argv[1], 10) )
    {
        DomainInfo2(hDS, &argv[1][10]);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_stricmp("-schemaGuid", argv[1]) )
    {
        GuidInfo(hDS);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_stricmp("-gcInfo", argv[1]) )
    {
        GCInfo(hDS);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
        
    // Since the client side implementation is really in WCHAR, we call
    // the ANSI version thereby also testing ANSI<-->UNICODE conversion.

    memset(rpResult, 0, sizeof(rpResult));

    for ( i = 0; i < cFormats; i++ )
    {
        dwErr = DsCrackNamesA(
                hDS,
                DS_NAME_FLAG_TRUST_REFERRAL,// flags
                DS_UNKNOWN_NAME,        // format offered
                rFormats[i].desired,    // format desired
                1,                      // name count
                &argv[4],
                &rpResult[i]);

        if ( (0 != dwErr)  ||
             (1 != rpResult[i]->cItems) ||
             (NULL == rpResult[i]->rItems) )
        {
            printf("DsCrackNamesA error 0x%x\n", dwErr);
            fDoSyntacticTest = FALSE;
            break;
        }

        printf("%s\n", pszFormat(rFormats[i].desired));
        printf("\tstatus          %s\n", Status(rpResult[i]->rItems[0].status));

        if (    (DS_NAME_NO_ERROR == rpResult[i]->rItems[0].status)
             || (DS_NAME_ERROR_DOMAIN_ONLY == rpResult[i]->rItems[0].status) 
             || (DS_NAME_ERROR_TRUST_REFERRAL == rpResult[i]->rItems[0].status) )
        {
            printf("\tDNS domain      %s\n", rpResult[i]->rItems[0].pDomain);
        }

        if ( CrackNameStatusSuccess(rpResult[i]->rItems[0].status) )
        {
            if ( DS_CANONICAL_NAME_EX == rFormats[i].desired )
            {
                pchar = strrchr(rpResult[i]->rItems[0].pName, '\n');

                if ( NULL == pchar )
                {
                    printf("\t*** Extended canonical form missing '\\n'\n");
                }
                else
                {
                    *pchar = '!';
                }
            }

            printf("\tcracked name    %s\n", rpResult[i]->rItems[0].pName);

            if ( NULL != pchar )
            {
                *pchar = '\n';
            }

            // Current mapping was from UNKNOWN to formatDesired.  Infer
            // a known formatOffered if the input and output string compare.

            if ( !_stricmp(argv[4], rpResult[i]->rItems[0].pName) )
            {
                knownFormatOffered = rFormats[i].offered;
                cKnownFormatOffered += 1;
            }
        }
        else
        {
            if (    (DS_FQDN_1779_NAME == rFormats[i].desired)
                 || (DS_CANONICAL_NAME == rFormats[i].desired)
                 || (DS_CANONICAL_NAME_EX == rFormats[i].desired) )
            {
                // One of the formats we need for later syntactical checking
                // failed - therefore turn off client side syntactic testing.

                fDoSyntacticTest = FALSE;
            }
        }
    }

    printf("\n");

    // There was a bug in the client side syntactical mapping logic whereby 
    // cracking a name from DS_UNKNOWN_NAME format would succeed yet cracking
    // from a known format would fail.  So we retry all calls again from the 
    // inferred known input format and see if we get the same result.

    if ( 0 == cKnownFormatOffered )
    {
        printf("Unable to infer format offered - skipping test\n");
    }
    else if ( cKnownFormatOffered > 1 )
    {
        printf("Too many inferred format offered (%d) - skipping test\n",
               cKnownFormatOffered);
    }
    else
    {
        DS_NAME_RESULTA *pRes;

        printf("Inferred format offered is %s - testing ...\n",
               pszFormat(knownFormatOffered));

        for ( i = 0; i < cFormats; i++ )
        {
            dwErr = DsCrackNamesA(
                        hDS,
                        DS_NAME_FLAG_TRUST_REFERRAL,// flags
                        knownFormatOffered,     // format offered
                        rFormats[i].desired,    // format desired
                        1,                      // name count
                        &argv[4],
                        &pRes);
        
            if ( (0 != dwErr)  ||
                 (1 != pRes->cItems) ||
                 (NULL == pRes->rItems) )
            {
                printf("DsCrackNamesA error 0x%x\n", dwErr);
                break;
            }

            // Test for complete result equivalence.  Special case
            // DS_STRING_SID_NAME which can return DS_NAME_ERROR_IS_SID_*
            // values while original call we're checking against offered
            // DS_UNKNOWN_NAME but matched against DS_SID_OR_SID_HISTORY_NAME
            // which does *not* return DS_NAME_ERROR_IS_SID_* values.

            if (    (pRes->rItems[0].status != rpResult[i]->rItems[0].status)
                 && !(    (DS_STRING_SID_NAME == rFormats[i].desired)
                       && CrackNameStatusSuccess(pRes->rItems[0].status)
                       && (DS_NAME_NO_ERROR == rpResult[i]->rItems[0].status)))
            {
                printf("\tStatus mismatch: %s => %s\n",
                        pszFormat(knownFormatOffered),
                        pszFormat(rFormats[i].desired));
                printf("\t\tinferred(%s) original(%s)\n",
                       Status(pRes->rItems[0].status),
                       Status(rpResult[i]->rItems[0].status));
                DsFreeNameResultA(pRes);
                continue;
            }

            if (    (    CrackNameStatusSuccess(pRes->rItems[0].status)
                      || (DS_NAME_ERROR_DOMAIN_ONLY == pRes->rItems[0].status) )
                 && _stricmp(pRes->rItems[0].pDomain,
                             rpResult[i]->rItems[0].pDomain) )
            {
                printf("\tDomain mismatch: %s ==> %s\n",
                        pszFormat(knownFormatOffered),
                        pszFormat(rFormats[i].desired));
                printf("\t\tinferred(%s)\n\t\toriginal(%s)\n",
                       pRes->rItems[0].pDomain,
                       rpResult[i]->rItems[0].pDomain);
                DsFreeNameResultA(pRes);
                continue;
            }

            if (    CrackNameStatusSuccess(pRes->rItems[0].status)
                 && _stricmp(pRes->rItems[0].pName, 
                             rpResult[i]->rItems[0].pName) )
            {
                printf("\tName mismatch: %s ==> %s\n",
                        pszFormat(knownFormatOffered),
                        pszFormat(rFormats[i].desired));
                printf("\t\tinferred(%s)\n\t\toriginal(%s)\n",
                       pRes->rItems[0].pName,
                       rpResult[i]->rItems[0].pName);
                DsFreeNameResultA(pRes);
                continue;
            }

            DsFreeNameResultA(pRes);
        }
    }

    // We're done with the official work, now let's test client side 
    // syntactic mapping if that makes sense.  

    if ( fDoSyntacticTest )
    {
        for ( i = 0; i <= 1; i++ )
        {
            pResult = NULL;

            dwErr = DsCrackNamesA(
                    // syntactic map shouldn't required valid handle
                    INVALID_HANDLE_VALUE,
                    DS_NAME_FLAG_SYNTACTICAL_ONLY,
                    DS_FQDN_1779_NAME,
                    i ? DS_CANONICAL_NAME : DS_CANONICAL_NAME_EX,
                    1,
                    &rpResult[iFqdn]->rItems[0].pName,
                    &pResult);

            if (    (0 == dwErr) 
                 && (DS_NAME_NO_ERROR == pResult->rItems[0].status) )
            {
                if ( 0 == i )
                {
                    pchar = strrchr(pResult->rItems[0].pName, '\n');

                    if ( NULL == pchar )
                    {
                        printf("\t*** Extended canonical form missing '\\n'\n");
                    }
                    else
                    {
                        *pchar = '!';
                    }
                }

                printf("syntactic %d ==> %s\n", i, pResult->rItems[0].pName);

                if ( 0 == i )
                {
                    *pchar = L'\n';
                }
            }
            else if ( 0 != dwErr )
            {
                printf("syntactic %d ==> dwErr 0x%x\n", i, dwErr);
            }
            else
            {
                printf("syntactic %d ==> status %s\n", 
                       i, Status(pResult->rItems[0].status));
            }
    
            if (    (0 != dwErr)
                 || (1 != pResult->cItems)
                 || (NULL == pResult->rItems)
                 || (DS_NAME_NO_ERROR != pResult->rItems[0].status)
                 || (_stricmp(
                     pResult->rItems[0].pName,
                     rpResult[i?iCanonical:iCanonicalEx]->rItems[0].pName)) )
            {
                printf("crack.exe - Syntactic mapping %d failed\n", i);
            }

            DsFreeNameResultA(pResult);
        }
    }

    for ( i = 0; i < cFormats; i++ )
    {
        DsFreeNameResultA(rpResult[i]);
    }

    dwErr = DsUnBindA(&hDS);

    if ( 0 != dwErr )
    {
        printf("DsUnbindA error 0x%x\n", dwErr);
        return;
    }
}

VOID
GetRdn(
    CHAR *paDN)
{
    DWORD   dwErr;
    WCHAR   *pwDN;
    WCHAR   *pwDNSav;
    DWORD   ccDN;
    DWORD   ccDNSav;
    WCHAR   *pwKey;
    DWORD   ccKey;
    WCHAR   *pwVal;
    DWORD   ccVal;
    WCHAR   c;

    ccDN = strlen(paDN);
    pwDN = malloc((ccDN + 1) * sizeof(WCHAR));
    swprintf(pwDN, L"%hs", paDN);
    printf("%ws\n", pwDN);

    pwDNSav = pwDN;
    ccDNSav = ccDN;
    while (ccDN) {
        dwErr = DsGetRdnW(&pwDN,
                          &ccDN,
                          &pwKey,
                          &ccKey,
                          &pwVal,
                          &ccVal);
        if (dwErr) {
            printf("DsGetRdnW(%d:%ws:) error 0x%x\n",
                   ccDN,
                   pwDN,
                   dwErr);
            return;
        } else {
            printf("DsGetRdnW(%d:%ws:)\n", ccDNSav, pwDNSav);
            printf("   DN : %d:%ws:\n", ccDN, pwDN);
            if (ccKey) {
                c = pwKey[ccKey];
                pwKey[ccKey] = 0;
                printf("   Key: %d:%ws:\n", ccKey, pwKey);
                pwKey[ccKey] = c;
            }
            if (ccVal) {
                c = pwVal[ccVal];
                pwVal[ccVal] = 0;
                printf("   Val: %d:%ws:\n", ccVal, pwVal);
                pwVal[ccVal] = c;
            }
        }
    }
}

VOID
QuoteRdn(
    CHAR *pszUnquotedRdn)
{
    DWORD   dwErr;
    DWORD   QuotedLength;
    DWORD   UnquotedLength;
    CHAR    QuotedRdn[MAX_PATH+1];
    CHAR    UnquotedRdn[MAX_PATH+1];

    //
    // UnquotedRdn -> QuotedRdn
    //
    QuotedLength = MAX_PATH;
    dwErr = DsQuoteRdnValueA(strlen(pszUnquotedRdn),
                        pszUnquotedRdn,
                        &QuotedLength,
                        QuotedRdn);
    if ( 0 != dwErr ) {
        printf("DsQuotedRdnValueA(%s) error 0x%x\n",
               pszUnquotedRdn,
               dwErr);
    } else {
        QuotedRdn[QuotedLength] = L'\0';
        printf("DsQuoteRdnValueA(%s) -> %s\n",
               pszUnquotedRdn,
               QuotedRdn);
    }

    //
    // Quoted Rdn -> Unquoted Rdn
    //
    if (dwErr == ERROR_SUCCESS) {
        UnquotedLength = MAX_PATH;
        dwErr = DsUnquoteRdnValueA(QuotedLength,
                                   QuotedRdn,
                                   &UnquotedLength,
                                   UnquotedRdn);
        if ( 0 != dwErr ) {
            printf("DsUnquoteRdnValueA(%s) error 0x%x\n",
                   QuotedRdn,
                   dwErr);
        }
        else {
            UnquotedRdn[UnquotedLength] = L'\0';
            printf("DsUnquoteRdnValueA(%s) -> %s\n",
                   QuotedRdn,
                   UnquotedRdn);
        }
    }
}

VOID
UnquoteRdn(
    CHAR *pszQuotedRdn)
{
    DWORD   dwErr;
    DWORD   QuotedLength;
    DWORD   UnquotedLength;
    CHAR    QuotedRdn[MAX_PATH+1];
    CHAR    UnquotedRdn[MAX_PATH+1];

    //
    // Quoted Rdn -> Unquoted Rdn
    //
    UnquotedLength = MAX_PATH;
    dwErr = DsUnquoteRdnValueA(strlen(pszQuotedRdn),
                               pszQuotedRdn,
                               &UnquotedLength,
                               UnquotedRdn);
    if ( 0 != dwErr ) {
        printf("DsUnquoteRdnValueA(%s) error 0x%x\n",
               pszQuotedRdn,
               dwErr);
    }
    else {
        UnquotedRdn[UnquotedLength] = L'\0';
        printf("DsUnquoteRdnValueA(%s) -> %s\n",
               pszQuotedRdn,
               UnquotedRdn);
    }

    //
    // UnquotedRdn -> QuotedRdn
    //
    if (dwErr == ERROR_SUCCESS) {
        QuotedLength = MAX_PATH;
        dwErr = DsQuoteRdnValueA(UnquotedLength,
                                 UnquotedRdn,
                                 &QuotedLength,
                                 QuotedRdn);
        if ( 0 != dwErr ) {
            printf("DsQuotedRdnValueA(%s) error 0x%x\n",
                   UnquotedRdn,
                   dwErr);
        } else {
            QuotedRdn[QuotedLength] = L'\0';
            printf("DsQuoteRdnValueA(%s) -> %s\n",
                   UnquotedRdn,
                   QuotedRdn);
        }
    }
}

VOID
SiteInfo(
    HANDLE hDS)
{
    DWORD               dwErr;
    PDS_NAME_RESULTA    sites;
    PDS_NAME_RESULTA    servers;
    PDS_NAME_RESULTA    domains;
    PDS_NAME_RESULTA    info;
    PDS_NAME_RESULTA    roles;
    DWORD               i, j, k;

    // Try out all the site info APIs.

    if ( dwErr = DsListRolesA(hDS, &roles) )
    {
        printf("DsListRolesA error 0x%x\n", dwErr);
        return;
    }

    printf("*** Found %d roles ***\n", roles->cItems);

    for ( i = 0; i < roles->cItems; i++ )
    {
        if ( DS_NAME_NO_ERROR != roles->rItems[i].status )
        {
            printf("Role item[%d] error %s\n", 
                   i, Status(roles->rItems[i].status));
            continue;
        }

        switch ( i )
        {
        case DS_ROLE_INFRASTRUCTURE_OWNER:

            printf("Schema - %s\n", roles->rItems[i].pName);
            break;

        case DS_ROLE_SCHEMA_OWNER:

            printf("Schema - %s\n", roles->rItems[i].pName);
            break;
            
        case DS_ROLE_DOMAIN_OWNER:

            printf("Domain - %s\n", roles->rItems[i].pName);
            break;

        case DS_ROLE_PDC_OWNER:

            printf("PDC - %s\n", roles->rItems[i].pName);
            break;

        case DS_ROLE_RID_OWNER:

            printf("RID - %s\n", roles->rItems[i].pName);
            break;

        default:

            printf("Unknown item %d ==> %s\n",
                   i, Status(roles->rItems[i].status));
            break;
        }
    }

    DsFreeNameResultA(roles);

    if ( dwErr = DsListSitesA(hDS, &sites) )
    {
        printf("DsListSitesA error 0x%x\n", dwErr);
        return;
    }

    printf("*** Found 0x%x sites ***\n", sites->cItems);

    for ( i = 0; i < sites->cItems; i++ )
    {
        if ( DS_NAME_NO_ERROR != sites->rItems[i].status )
        {
            printf("DsSitesA status[0x%x] ==> %s\n", 
                   i, Status(sites->rItems[i].status));
            return;
        }

        printf("0x%x - %s(%s)\n", 
               i,
               sites->rItems[i].pName,
               sites->rItems[i].pDomain);

        dwErr = DsListServersInSiteA(hDS, sites->rItems[i].pName, &servers);

        if ( dwErr ) 
        {
            printf("DsListServersInSiteA error 0x%x\n", dwErr);
            return;
        }

        printf("\t*** Found 0x%x servers in site 0x%x ***\n", 
               servers->cItems, i);

        for ( j = 0; j < servers->cItems; j++ )
        {
            if ( DS_NAME_NO_ERROR != servers->rItems[j].status )
            {
                printf("DsListServersInSiteA status[0x%x] ==> %s\n", 
                       j, Status(servers->rItems[j].status));
                return;
            }

            printf("\t0x%x - %s(%s)\n",
                   j,
                   servers->rItems[j].pName,
                   servers->rItems[j].pDomain);

            dwErr = DsListInfoForServerA(hDS, servers->rItems[j].pName, &info);

            if ( dwErr ) 
            {
                printf("DsListInfoForServerA error 0x%x\n", dwErr);
                return;
            }
            else if ( 3 != info->cItems )
            {
                printf("DsListInfoForServerA error - 0x%x items returned\n",
                       info->cItems);
                return;
            }

            printf("\t\t*** Found 0x%x info items for server 0x%x ***\n",
                   info->cItems, j);

            for ( k = 0; k < info->cItems; k++ )
            {
                switch ( k )
                {
                    case DS_LIST_DSA_OBJECT_FOR_SERVER:
                        printf("\t\tNTDS-DSA: ");         break;
                    case DS_LIST_DNS_HOST_NAME_FOR_SERVER:
                        printf("\t\tDNS host name: ");    break;
                    case DS_LIST_ACCOUNT_OBJECT_FOR_SERVER:
                        printf("\t\tAccount object: ");   break;
                }

                if ( DS_NAME_NO_ERROR != info->rItems[k].status )
                {
                    printf("%s\n", Status(info->rItems[k].status));
                }
                else
                {
                    printf("%s(%s)\n",
                           info->rItems[k].pName,
                           info->rItems[k].pDomain);
                }
            }

            DsFreeNameResultA(info);
        }

        DsFreeNameResultA(servers);

        dwErr = DsListDomainsInSiteA(hDS, sites->rItems[i].pName, &domains);

        if ( dwErr ) 
        {
            printf("DsListDomainsInSiteA error 0x%x\n", dwErr);
            return;
        }

        printf("\t*** Found 0x%x domains in site 0x%x ***\n", 
               domains->cItems, i);

        for ( j = 0; j < domains->cItems; j++ )
        {
            if ( DS_NAME_NO_ERROR != domains->rItems[i].status )
            {
                printf("DsListDomainsInSiteA status[0x%x] ==> %s\n", 
                       i, Status(domains->rItems[i].status));
                return;
            }

            printf("\t0x%x - %s(%s)\n",
                   j,
                   domains->rItems[j].pName,
                   domains->rItems[j].pDomain);

        }
    }

    for ( i = 0; i < sites->cItems; i++ )
    {
        for ( j = 0; j < domains->cItems; j++ )
        {
            dwErr = DsListServersForDomainInSiteA(
                                hDS,
                                domains->rItems[j].pName,
                                sites->rItems[i].pName,
                                &servers);

            if ( dwErr ) 
            {
                printf("DsListServersForDomainInSite error 0x%x\n", dwErr);
                return;
            }

            printf("*** Found 0x%x servers for domain 0x%x in site 0x%x ***\n",
                   servers->cItems, j, i);

            for ( k = 0; k < servers->cItems; k++ )
            {
                if ( DS_NAME_NO_ERROR != servers->rItems[i].status )
                {
                    printf("DsListServersForDomainInSiteA status[0x%x] ==> %s\n", 
                           i, Status(servers->rItems[i].status));
                    return;
                }

                printf("0x%x - %s(%s)\n",
                       k,
                       servers->rItems[k].pName,
                       servers->rItems[k].pDomain);
            }

            DsFreeNameResultA(servers);
        }
    }

    DsFreeNameResultA(sites);
    DsFreeNameResultA(domains);
}

VOID
LdapInfo(
    HANDLE hDS,
    CHAR    *pszDomain)
{

    DWORD err;
    DWORD nRead;
    PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFF Buffer = NULL;

    err = DsGetDomainControllerInfo(hDS,
                                    pszDomain,
                                    DS_DCINFO_LEVEL_FFFFFFFF,
                                    &nRead,
                                    &Buffer
                                    );

    if ( err == NO_ERROR ) {

        DWORD i;

        printf("*** Found %d LDAP connections ***\n", nRead);

        for (i=0;i<nRead;i++) {

            IN_ADDR addr;
            
            addr.s_addr = Buffer[i].IPAddress;

            printf("Client %s. ",inet_ntoa(addr));

            printf("Flags: ");
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_BOUND ) {
                printf("Bound");
            } else {
                printf("Not Bound");
            }

            if ( Buffer[i].Flags & LDAP_CONN_FLAG_SSL ) {
                printf(";SSL");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_UDP ) {
                printf(";UDP");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_GC ) {
                printf(";GC Port");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_SIMPLE ) {
                printf(";Simple Bind");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_GSSAPI ) {
                printf(";GSSAPI Bind");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_SPNEGO ) {
                printf(";SPNEGO Bind");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_SIGN ) {
                printf(";Sign");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_SEAL ) {
                printf(";Seal");
            }

            printf("\nTime connected %d sec.\n",Buffer[i].secTimeConnected);

            if ( Buffer[i].NotificationCount != 0 ) {
                printf("%d notifications outstanding\n",Buffer[i].NotificationCount);
            }

            if ( Buffer[i].UserName != NULL ) {
                printf("UserName: %s\n",Buffer[i].UserName);
            }
            printf("\n");
        }

        DsFreeDomainControllerInfo(DS_DCINFO_LEVEL_FFFFFFFF,nRead,Buffer);
    } else {
        printf("DsGetDomainControlerInfoA(VFFFFFFFF) error 0x%x\n", err);
    }
    return;
}


VOID
GuidInfo(
    HANDLE hDS)
{
    // Lookup a known GUID in each category as well as a bogus GUID 
    // and verify the results.

    DWORD               i;
    DWORD               dwErr;
    DS_SCHEMA_GUID_MAPA *pMap = NULL;
    GUID                rGuids[5] = {
        // 0 == DS_SCHEMA_GUID_NOT_FOUND
        { 0x00000000,0x0000,0x0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },

        // 1 == DS_SCHEMA_GUID_ATTR ==> Common-Name, aka "cn"
        { 0xbf96793f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2 },

        // 2 == DS_SCHEMA_GUID_ATTR_SET ==> Common-Name's prop set
        { 0xe48d0154,0xbcf8,0x11d1,0x87,0x02,0x00,0xc0,0x4f,0xb9,0x60,0x50 },

        // 3 == DS_SCHEMA_GUID_CLASS ==> "user"
        { 0xbf967aba,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2 },

        // 4 == DS_SCHEMA_GUID_CONTROL_RIGHT ==> "Change Schema Master"
        { 0xe12b56b6,0x0a95,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd } };
    PCHAR               rNames[5] = {   NULL,
                                        "cn",
    // See comments in SchemaGuidCrackNames in src\dsamain\src\cracknam.c
    // to understand where the following string comes from.
                                        "Public Information",
                                        "user",
                                        "Change Schema Master" };
    PCHAR               rLabels[5] = {  "DS_SCHEMA_GUID_NOT_FOUND",
                                        "DS_SCHEMA_GUID_ATTR",
                                        "DS_SCHEMA_GUID_ATTR_SET",
                                        "DS_SCHEMA_GUID_CLASS",
                                        "DS_SCHEMA_GUID_CONTROL_RIGHT" };

    if ( dwErr = DsMapSchemaGuidsA(hDS, 5, rGuids, &pMap) )
    {
        printf("DsMapSchemaGuidsA error 0x%x\n", dwErr);
        return;
    }

    if ( !pMap )
    {
        printf("DsMapSchemaGuidsA returned NULL DS_SCHEMA_GUID_MAPA\n");
        return;
    }
    
    for ( i = 0; i < 5; i++ )
    {
        // Test DS_SCHEMA_GUID_MAPA.guid.

        if ( memcmp(&rGuids[i], &pMap[i].guid, sizeof(GUID)) )
        {
            printf("Output missing guid # 0x%x\n", i);
            return;
        }

        // Test DS_SCHEMA_GUID_MAPA.guidType.

        // Note that control data was contrived such that array offset
        // is also the expected guid type.

        if ( i != pMap[i].guidType )
        {
            printf("Guid type mismatch - expected(0x%x) received(0x%x)\n",
                   i, pMap[i].guidType);
            if (    (DS_SCHEMA_GUID_NOT_FOUND != pMap[i].guidType)
                 && pMap[i].pName )
            {
                printf("\tname is: %s\n", pMap[i].pName);
            }
            return;
        }

        // Test DS_SCHEMA_GUID_MAPA.pName.

        if ( !rNames[i] && pMap[i].pName )
        {
            printf("%s name error - expected NULL name, but got \"%s\"\n",
                   rLabels[i], pMap[i].pName);
            return;
        }
        else if ( rNames[i] && !pMap[i].pName )
        {
            printf("%s name error - expected \"%s\", but got NULL\n",
                   rLabels[i], rNames[i]);
            return;
        }
        else if (    rNames[i] && pMap[i].pName 
                  && _stricmp(rNames[i], pMap[i].pName) )
        {
            printf("%s name error - expected \"%s\", but got \"%s\"\n",
                   rNames[i], pMap[i].pName, rNames[i]);
            return;
        }
    }

    DsFreeSchemaGuidMapA(pMap);
    printf("Schema guid map tests passed!\n");
}

VOID
DomainInfo1(
    HANDLE  hDS,
    CHAR    *pszDomain)
{
    DS_DOMAIN_CONTROLLER_INFO_1A    *pInfo;
    DWORD                           cInfo;
    DWORD                           dwErr;
    DWORD                           i;

    dwErr = DsGetDomainControllerInfoA( hDS,
                                        pszDomain,
                                        1,
                                        &cInfo,
                                        &pInfo);

    if ( dwErr )
    {
        printf("DsGetDomainControlerInfoA(V1) error 0x%x\n", dwErr);
        return;
    }

    printf("0x%x domain controllers found\n", cInfo);

    for ( i = 0; i < cInfo; i++ )
    {
        printf("*** %d ***\n", i);
        printf("\tNetbiosName           %s\n", pInfo[i].NetbiosName);
        printf("\tDnsHostName           %s\n", pInfo[i].DnsHostName);
        printf("\tSiteName              %s\n", pInfo[i].SiteName);
        printf("\tComputerObjectName    %s\n", pInfo[i].ComputerObjectName);
        printf("\tServerObjectName      %s\n", pInfo[i].ServerObjectName);
        printf("\tfIsPdc                0x%x\n", pInfo[i].fIsPdc);
        printf("\tfDsEnabled            0x%x\n", pInfo[i].fDsEnabled);
    }

    DsFreeDomainControllerInfoA(1, cInfo, pInfo);
}

VOID
DomainInfo2(
    HANDLE  hDS,
    CHAR    *pszDomain)
{
    DS_DOMAIN_CONTROLLER_INFO_2A    *pInfo;
    DWORD                           cInfo;
    DWORD                           dwErr;
    DWORD                           i;
    CHAR                            *pszGuid;

    dwErr = DsGetDomainControllerInfoA( hDS,
                                        pszDomain,
                                        2,
                                        &cInfo,
                                        &pInfo);

    if ( dwErr )
    {
        printf("DsGetDomainControlerInfoA(V2) error 0x%x\n", dwErr);
        return;
    }

    printf("0x%x domain controllers found\n", cInfo);

    for ( i = 0; i < cInfo; i++ )
    {
        printf("*** %d ***\n", i);
        printf("\tNetbiosName           %s\n", pInfo[i].NetbiosName);
        printf("\tDnsHostName           %s\n", pInfo[i].DnsHostName);
        printf("\tSiteName              %s\n", pInfo[i].SiteName);

        printf("\tSiteObjectName        %s\n", pInfo[i].SiteObjectName);
        UuidToStringA(&pInfo[i].SiteObjectGuid, &pszGuid);
        printf("\tSiteObjectGuid        %s\n", pszGuid);
        RpcStringFreeA(&pszGuid);

        printf("\tComputerObjectName    %s\n", pInfo[i].ComputerObjectName);
        UuidToStringA(&pInfo[i].ComputerObjectGuid, &pszGuid);
        printf("\tComputerObjectGuid    %s\n", pszGuid);
        RpcStringFreeA(&pszGuid);

        printf("\tServerObjectName      %s\n", pInfo[i].ServerObjectName);
        UuidToStringA(&pInfo[i].ServerObjectGuid, &pszGuid);
        printf("\tServerObjectGuid      %s\n", pszGuid);
        RpcStringFreeA(&pszGuid);

        printf("\tNtdsDsaObjectName     %s\n", pInfo[i].NtdsDsaObjectName);
        UuidToStringA(&pInfo[i].NtdsDsaObjectGuid, &pszGuid);
        printf("\tNtdsDsaObjectGuid     %s\n", pszGuid);
        RpcStringFreeA(&pszGuid);

        printf("\tfIsPdc                0x%x\n", pInfo[i].fIsPdc);
        printf("\tfDsEnabled            0x%x\n", pInfo[i].fDsEnabled);
        printf("\tfIsGc                 0x%x\n", pInfo[i].fIsGc);
    }

    DsFreeDomainControllerInfoA(2, cInfo, pInfo);
}

VOID
CheckInternationalDN(
    HANDLE  hDS,
    CHAR    *pszName)
{
    DWORD           dwErr;
    WCHAR           *pwszName;
    DS_NAME_RESULTW *pResultGuid1;
    DS_NAME_RESULTW *pResultDN;
    DS_NAME_RESULTW *pResultGuid2;
    DS_NAME_RESULTW *pResultCanonical;

    pwszName = (WCHAR *) alloca(sizeof(WCHAR) * (strlen(pszName) + 1));
    mbstowcs(pwszName, pszName, strlen(pszName) + 1);

    // Crack to GUID.

    dwErr = DsCrackNamesW(
                hDS,
                DS_NAME_FLAG_TRUST_REFERRAL,
                DS_UNKNOWN_NAME,
                DS_UNIQUE_ID_NAME,
                1,
                &pwszName,
                &pResultGuid1);

    if ( dwErr )
    {
        printf("Error 0x%x on initial GUID crack\n", dwErr);
        return;
    }
    else if ( DS_NAME_NO_ERROR != pResultGuid1->rItems[0].status )
    {
        printf("Status %s on initial GUID crack\n", 
               Status(pResultGuid1->rItems[0].status));
        return;
    }

    printf("GUID is %ws\n", pResultGuid1->rItems[0].pName);
    
    // Crack to (international) DN.

    dwErr = DsCrackNamesW(
                hDS,
                DS_NAME_FLAG_TRUST_REFERRAL,
                DS_UNIQUE_ID_NAME,
                DS_FQDN_1779_NAME,
                1,
                &pResultGuid1->rItems[0].pName,
                &pResultDN);

    if ( dwErr )
    {
        printf("Error 0x%x on DN crack\n", dwErr);
        return;
    }
    else if ( DS_NAME_NO_ERROR != pResultDN->rItems[0].status )
    {
        printf("Status %s on DN crack\n", 
               Status(pResultDN->rItems[0].status));
        return;
    }

    printf("DN is \"%ws\"\n", pResultDN->rItems[0].pName);

    // Crack this (presumed) international DN back to the GUID.

    dwErr = DsCrackNamesW(
                hDS,
                DS_NAME_FLAG_TRUST_REFERRAL,
                DS_FQDN_1779_NAME,
                DS_UNIQUE_ID_NAME,
                1,
                &pResultDN->rItems[0].pName,
                &pResultGuid2);

    if ( dwErr )
    {
        printf("Error 0x%x on DN to GUID crack\n", dwErr);
        return;
    }
    else if ( DS_NAME_NO_ERROR != pResultGuid2->rItems[0].status )
    {
        printf("Status %s on DN to GUID crack\n", 
               Status(pResultGuid2->rItems[0].status));
        return;
    }

    if ( wcscmp(pResultGuid1->rItems[0].pName, pResultGuid2->rItems[0].pName) )
    {
        printf("Guid mismatch: %ws *** %ws\n",
               pResultGuid1->rItems[0].pName,
               pResultGuid2->rItems[0].pName);
    }
    else
    {
        printf("Guids matched OK\n");
    }

    // Crack DN to GUID using DS_UNKNOWN_NAME.

    printf("Cracking DN to canonical using DS_UNKNOWN_NAME ...\n");
    dwErr = DsCrackNamesW(
                hDS,
                DS_NAME_FLAG_TRUST_REFERRAL,
                DS_UNKNOWN_NAME,
                DS_CANONICAL_NAME,
                1,
                &pResultDN->rItems[0].pName,
                &pResultCanonical);

    if ( dwErr )
    {
        printf("Error 0x%x on DN to CANONICAL crack\n", dwErr);
        return;
    }
    else if ( DS_NAME_NO_ERROR != pResultCanonical->rItems[0].status )
    {
        printf("Status %s on DN to CANONICAL crack\n", 
               Status(pResultCanonical->rItems[0].status));
        return;
    }

    printf("CANONICAL name is \"%ws\"\n", pResultCanonical->rItems[0].pName);

    DsFreeNameResultW(pResultGuid1);
    DsFreeNameResultW(pResultGuid2);
    DsFreeNameResultW(pResultDN);
    DsFreeNameResultW(pResultCanonical);
}

VOID
GCInfo(
    HANDLE  hDS)
{
    DWORD           i, dwErr;
    LPSTR           dummy = "dummy";
    DS_NAME_RESULTA *pGC;

    dwErr = DsCrackNamesA(hDS,
                          DS_NAME_FLAG_TRUST_REFERRAL,
                          DS_LIST_GLOBAL_CATALOG_SERVERS,
                          DS_FQDN_1779_NAME,
                          1,
                          &dummy,
                          &pGC);

    if ( dwErr )
    {
        printf("DsCrackNamesA(DS_LIST_GLOBAL_CATALOG_SERVERS) error 0x%x\n", 
                dwErr);
        return;
    }

    printf("0x%x GCs found\n", pGC->cItems);

    for ( i = 0; i < pGC->cItems; i++ )
    {
        printf("*** %d ***\n", i);

        if ( DS_NAME_NO_ERROR != pGC->rItems[i].status )
        {
            printf("\tStatus %s\n", Status(pGC->rItems[i].status));
        }
        else
        {
            printf("\tSite:          %s\n", pGC->rItems[i].pName);
            printf("\tDNS Host Name: %s\n", pGC->rItems[i].pDomain);
        }
    }

    DsFreeNameResultA(pGC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\ldaprepltest\auth.h ===
#ifndef T_CHRISK_AUTH_H
#define T_CHRISK_AUTH_H

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <winerror.h>
#include <stdio.h>
#include <ntdsapi.h>

#define CR 0xD
#define BACKSPACE 0x8

// Global DRS RPC call flags.  Should hold 0 or DRS_ASYNC_OP.
extern ULONG gulDrsFlags;

// Global credentials.
extern SEC_WINNT_AUTH_IDENTITY_W   gCreds;
extern SEC_WINNT_AUTH_IDENTITY_W * gpCreds;

int
PreProcessGlobalParams(
    int *    pargc,
    LPWSTR **pargv
    );
/*++

Routine Description:

    Scan command arguments for user-supplied credentials of the form
        [/-](u|user):({domain\username}|{username})
        [/-](p|pw|pass|password):{password}
    Set credentials used for future DRS RPC calls and LDAP binds appropriately.
    A password of * will prompt the user for a secure password from the console.

    Also scan args for /async, which adds the DRS_ASYNC_OP flag to all DRS RPC
    calls.

    CODE.IMPROVEMENT: The code to build a credential is also available in
    ntdsapi.dll\DsMakePasswordCredential().

Arguments:

    pargc
    pargv

Return Values:

    ERROR_Success - success
    other - failure

--*/


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\ldaprepltest\auth.c ===
#include <NTDSpch.h>
#pragma hdrstop


#include "auth.h"

// Global DRS RPC call flags.  Should hold 0 or DRS_ASYNC_OP.
ULONG gulDrsFlags = 0;

// Global credentials.
SEC_WINNT_AUTH_IDENTITY_W   gCreds = { 0 };
SEC_WINNT_AUTH_IDENTITY_W * gpCreds = NULL;
void DoAssert( char *a, unsigned long b, char *c)
{
    printf("ASSERT %s, %d, %d\n",a,b,c);
    exit(-1);
}

int
GetPassword(
    WCHAR *     pwszBuf, 
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    )  
/*++ 

Routine Description: 

    Retrieve password from command line (without echo).
    Code stolen from LUI_GetPasswdStr (net\netcmd\common\lui.c).

Arguments:

    pwszBuf - buffer to fill with password
    cchBufMax - buffer size (incl. space for terminating null)
    pcchBufUsed - on return holds number of characters used in password

Return Values:

    DRAERR_Success - success
    other - failure
 
--*/
{
    WCHAR   ch;
    WCHAR * bufPtr = pwszBuf;
    DWORD   c;
    int     err;
    int     mode;

    cchBufMax -= 1;    /* make space for null terminator */
    *pcchBufUsed = 0;               /* GP fault probe (a la API's) */
    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode);
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
        if (!err || c != 1)
            ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) {  /* back up one or two */
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != pwszBuf) {
                bufPtr--;
                (*pcchBufUsed)--;
            }
        }
        else {

            *bufPtr = ch;

            if (*pcchBufUsed < cchBufMax)
                bufPtr++ ;                   /* don't overflow buf */
            (*pcchBufUsed)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = L'\0';         /* null terminate the string */
    putchar('\n');

    if (*pcchBufUsed > cchBufMax)
    {
        printf("Password too long!\n");
        //PrintMsg( REPADMIN_PASSWORD_TOO_LONG );
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}

int
PreProcessGlobalParams(
    int *    pargc,
    LPWSTR **pargv
    )
/*++

Routine Description:

    Scan command arguments for user-supplied credentials of the form
        [/-](u|user):({domain\username}|{username})
        [/-](p|pw|pass|password):{password}
    Set credentials used for future DRS RPC calls and LDAP binds appropriately.
    A password of * will prompt the user for a secure password from the console.

    Also scan args for /async, which adds the DRS_ASYNC_OP flag to all DRS RPC
    calls.

    CODE.IMPROVEMENT: The code to build a credential is also available in
    ntdsapi.dll\DsMakePasswordCredential().

Arguments:

    pargc
    pargv

Return Values:

    ERROR_Success - success
    other - failure

--*/
{
    int     ret = 0;
    int     iArg;
    LPWSTR  pszOption;
    DWORD   cchOption;
    LPWSTR  pszDelim;
    LPWSTR  pszValue;
    DWORD   cchValue;

    for (iArg = 1; iArg < *pargc; )
    {
        if (((*pargv)[iArg][0] != L'/') && ((*pargv)[iArg][0] != L'-'))
        {
            // Not an argument we care about -- next!
            iArg++;
        }
        else
        {
            pszOption = &(*pargv)[iArg][1];
            pszDelim = wcschr(pszOption, L':');

            if (NULL == pszDelim)
            {
                if (0 == _wcsicmp(L"async", pszOption))
                {
                    // This constant is the same for all operations
                    gulDrsFlags |= DS_REPADD_ASYNCHRONOUS_OPERATION;

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else
                {
                    // Not an argument we care about -- next!
                    iArg++;
                }
            }
            else
            {
                cchOption = (DWORD)(pszDelim - (*pargv)[iArg]);

                if (    (0 == _wcsnicmp(L"p:",        pszOption, cchOption))
                     || (0 == _wcsnicmp(L"pw:",       pszOption, cchOption))
                     || (0 == _wcsnicmp(L"pass:",     pszOption, cchOption))
                     || (0 == _wcsnicmp(L"password:", pszOption, cchOption)) )
                {
                    // User-supplied password.
                    pszValue = pszDelim + 1;
                    cchValue = 1 + wcslen(pszValue);

                    if ((2 == cchValue) && ('*' == pszValue[0]))
                    {
                        // Get hidden password from console.
                        cchValue = 64;

                        gCreds.Password = malloc(sizeof(WCHAR) * cchValue);

                        if (NULL == gCreds.Password)
                        {
                            printf( "No memory.\n" );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        printf("Password: ");

                        ret = GetPassword(gCreds.Password, cchValue, &cchValue);
                    }
                    else
                    {
                        // Get password specified on command line.
                        gCreds.Password = pszValue;
                    }

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else if (    (0 == _wcsnicmp(L"u:",    pszOption, cchOption))
                          || (0 == _wcsnicmp(L"user:", pszOption, cchOption)) )
                {
                    // User-supplied user name (and perhaps domain name).
                    pszValue = pszDelim + 1;
                    cchValue = 1 + wcslen(pszValue);

                    pszDelim = wcschr(pszValue, L'\\');

                    if (NULL == pszDelim)
                    {
                        // No domain name, only user name supplied.
                        printf("User name must be prefixed by domain name.\n");
                        //PrintMsg( REPADMIN_DOMAIN_BEFORE_USER );
                        return ERROR_INVALID_PARAMETER;
                    }

                    *pszDelim = L'\0';
                    gCreds.Domain = pszValue;
                    gCreds.User = pszDelim + 1;

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else
                {
                    iArg++;
                }
            }
        }
    }

    if (NULL == gCreds.User)
    {
        if (NULL != gCreds.Password)
        {
            // Password supplied w/o user name.
            printf( "Password must be accompanied by user name.\n" );
            //PrintMsg( REPADMIN_PASSWORD_NEEDS_USERNAME );
            ret = ERROR_INVALID_PARAMETER;
        }
        else
        {
            // No credentials supplied; use default credentials.
            ret = ERROR_SUCCESS;
        }
    }
    else
    {
        gCreds.PasswordLength = gCreds.Password ? wcslen(gCreds.Password) : 0;
        gCreds.UserLength   = wcslen(gCreds.User);
        gCreds.DomainLength = gCreds.Domain ? wcslen(gCreds.Domain) : 0;
        gCreds.Flags        = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        // CODE.IMP: The code to build a SEC_WINNT_AUTH structure also exists
        // in DsMakePasswordCredentials.  Someday use it

        // Use credentials in DsBind and LDAP binds
        gpCreds = &gCreds;
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsupgrad\util.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.h

Abstract:

    This file contains define's for hardcoded values used in dsupgrad and
    useful debug output

Author:

    ColinBr 26-Aug-1996

Environment:

    User Mode - Win32

Revision History:

--*/
#ifndef __UTIL_H
#define __UTIL_H

#define _DEB_INFO             0x0001
#define _DEB_WARNING          0x0002
#define _DEB_ERROR            0x0004
#define _DEB_TRACE            0x0008

// Defined in interfac.c
extern ULONG DebugInfoLevel;

#define DebugWarning(x) if ((DebugInfoLevel & _DEB_WARNING) == _DEB_WARNING) {KdPrint(x);}
#define DebugError(x)   if ((DebugInfoLevel & _DEB_ERROR) == _DEB_ERROR)     {KdPrint(x);}
#define DebugTrace(x)   if ((DebugInfoLevel & _DEB_TRACE) == _DEB_TRACE)     {KdPrint(x);}
#define DebugInfo(x)    if ((DebugInfoLevel & _DEB_INFO) == _DEB_INFO)       {KdPrint(x);}

#define MAX_REGISTRY_NAME_LENGTH      SAMP_MAXIMUM_NAME_LENGTH
#define MAX_REGISTRY_KEY_NAME_LENGTH  512

#endif // __UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\test\main.c ===
/*++

Copyright (c) 1990 - 1996 Microsoft Corporation

Module Name:

    main.c

Abstract:

    This file contains a set of test routines that constitute the SAM DS
    developer regression test. The test routines call the public SAM API
    as would any client of SAM. This test should always be run as a pre-
    requisite to checking in any changes to the SAM module, and is intended
    to serve as the primary developer regression test for SAM.

    The final test status should only display either "PASSED" or "FAILED"
    to stdout. All other output should optionally go to stdout or to a
    debugger as appropriate.

Author:

    Chris Mayhall (ChrisMay) 19-Jun-1996

Environment:

    User Mode - Win32

Revision History:

    ChrisMay        28-Sep-1996
        Picked up original version from MikeSw's unit tests and updated it.
        Converted any C++ specific code to C for easier debugging in ntsd,
        and removed obsolete Cairo code.
    ChrisMay        06-Oct-1996
        Fixed buffer lengths in alias routines, got -gam working again.
        Removed redundant #include files.

--*/

#include <ntdspch.h> // Apparently required to correctly binplace DS files.
#pragma hdrstop

#include <ntsam.h>
#include <ntlsa.h>
#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <samrpc.h>
#include <samisrv.h>    
#include <lsarpc.h>
#include <lsaisrv.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <wxlpc.h>

// Since kdprint doesn't seem to be exported anymore, define a private macro
// for debugging. Currently set to display to stdout if SAM_DRT_DBG is 1.

#define SAM_DRT_DBG 0

#if SAM_DRT_DBG == 1
#define kdprint(x) printf x
#else
#define kdprint(x)
#endif

typedef NTSTATUS (TestFunc)( WCHAR *Parameter[]);

typedef struct _Commands
{
    PSTR Name;
    ULONG Parameter; // TRUE = yes, FALSE = no
    TestFunc *Function;
} CommandPair, *PCommandPair;


typedef struct _Action
{
    ULONG CommandNumber;
    LPWSTR Parameter[8];
} Action, *PAction;

/*
NTSTATUS
WxReadSysKey(
    IN OUT PULONG BufferLength,
    OUT PVOID  Key
    );
*/
TestFunc Help;

//
// TEST                         SAM ROUTINES CALLED IN THE TEST
//

TestFunc OpenDomain;                // SamOpenDomain
TestFunc EnumDomains;               // SamEnumerateDomainsInSamServer
                                    // SamFreeMemory
TestFunc EnumAccounts;              // SamEnumerateUsersInDomain
                                    // SamEnumerateGroupsInDomain
                                    // SamEnumerateAliasesInDomain
                                    // SamFreeMemory
TestFunc QueryDisplay;              // SamQueryDisplayInformation
                                    // SamFreeMemory
TestFunc OpenGroup;                 // SamLookupNamesInDomain
                                    // SamOpenGroup
                                    // SamFreeMemory
TestFunc GroupMembers;              // SamGetMembersInGroup
                                    // SamFreeMemory
TestFunc OpenAlias;                 // SamLookupNamesInDomain
                                    // SamFreeMemory
TestFunc AliasMembers;              // SamGetMembersInAlias
                                    // SamFreeMemory
TestFunc GetAliasMembership;        // SamGetAliasMembership
                                    // SamFreeMemory
TestFunc OpenUser;                  // SamOpenUser
TestFunc GetGroupsForUser;          // SamGetGroupsForUser
                                    // SamFreeMemory
TestFunc DumpAllUsers;              // SamEnumerateUsersInDomain
                                    // SamCloseHandle
                                    // SamFreeMemory
TestFunc DumpAllGroups;             // SamEnumerateGroupsInDomain
                                    // SamCloseHandle
                                    // SamFreeMemory
TestFunc DumpUser;                  // SamQueryInformationUser
                                    // SamFreeMemory
TestFunc DumpGroup;                 // SamQueryInformationGroup
                                    // SamFreeMemory
TestFunc CreateUser;                // SamCreateUser2InDomain
TestFunc AddAliasMember;            // SamAddMemberToAlias
TestFunc CreateGroup;               // SamCreateGroupInDomain
TestFunc CreateAlias;               // SamCreateAliasInDomain
TestFunc DumpDomain;                // SamQueryInformationDomain
                                    // SamFreeMemory
TestFunc Connect;                   // SamConnect
TestFunc DelUser;                   // SamDeleteUser
TestFunc DelAlias;                  // SamDeleteAlias
TestFunc DelGroup;                  // SamDeleteGroup
TestFunc SetLogonHours;             // SamSetLogonHours
TestFunc SetPassword;               // SamSetInformationUser
TestFunc ChangeKey;                 // SamiSetBootKeyInformation
//
// SAM ROUTINES NOT CALLED IN ANY TEST (but work in usrmgr, boot, etc.).
//

// BUG: The remaining SAM API should be added to the samdsdrt test.

// SamSetSecurityObject
// SamQuerySecurityObject
// SamShutdownSamServer
// SamLookupDomainInSamServer
// SamSetInformationDomain
// SamCreateUserInDomain
// SamLookupIdsInDomain
// SamGetDisplayEnumerationIndex
// SamSetInformationGroup
// SamAddMemberToGroup
// SamRemoveMemberFromGroup
// SamSetMemberAttributesOfGroup
// SamQueryInformationAlias
// SamSetInformationAlias
// SamRemoveMemberFromAlias
// SamRemoveMemberFromForeignDomain
// SamAddMulitpleMembersToAlias
// SamRemoveMultipleMembersFromAlias
// SamSetInformationUser
// SamChangePasswordUser
// SamChangePasswordUser2

// SamiLmChangePasswordUser
// SamiChangePasswordUser
// SamiChangePasswordUser2
// SamiOemChangePasswordUser2
// SamiEncryptPasswords

// Command-line switch, parameter, and test routine table. New tests are
// added to this table.

CommandPair Commands[] =
{
    // TEST                                         CURRENT STATUS

    // switch   # params    test routine

    {"-od",     1,          OpenDomain},            // passed
    {"-ed",     0,          EnumDomains},           // passed
    {"-ea",     1,          EnumAccounts},          // passed
    {"-qd",     1,          QueryDisplay},          // passed
    {"-og",     1,          OpenGroup},             // passed
    {"-gm",     0,          GroupMembers},          // passed
    {"-oa",     1,          OpenAlias},             // passed
    {"-am",     0,          AliasMembers},          // passed
    {"-gam",    1,          GetAliasMembership},    // passed
    {"-ou",     1,          OpenUser},              // passed
    {"-ggu",    0,          GetGroupsForUser},      // passed
    {"-dau",    0,          DumpAllUsers},          // passed
    {"-dag",    0,          DumpAllGroups},         // passed
    {"-du",     0,          DumpUser},              // passed
    {"-dg",     0,          DumpGroup},             // passed
    {"-cu",     1,          CreateUser},            // passed
    {"-aam",    1,          AddAliasMember},        // passed
    {"-cg",     1,          CreateGroup},           // passed
    {"-ca",     1,          CreateAlias},           // passed
    {"-dd",     0,          DumpDomain},            // passed
    {"-c",      1,          Connect},               // passed
    {"-delu",   0,          DelUser},               // passed
    {"-dela",   0,          DelAlias},              // passed
    {"-delg",   0,          DelGroup},              // passed
    {"-slh",    0,          SetLogonHours},         // passed
    {"-spwd",   0,          SetPassword},           // passed
    {"-chgk",   0,          ChangeKey},
    {"-?",      0,          Help}
};

#define NUM_COMMANDS (sizeof(Commands) / sizeof(CommandPair))

// Global Data

SAM_HANDLE SamHandle;
SAM_HANDLE DomainHandle;
SAM_HANDLE GroupHandle;
SAM_HANDLE AliasHandle;
SAM_HANDLE UserHandle;
UNICODE_STRING ServerName;

NTSTATUS
Help(
    LPWSTR *Parameter
    )
{
    // BUG: Work in progress -- need better help message for samdsdrt.

    printf("Usage:\n");
    printf("\t-od       Open a domain\n");
    printf("\t-ed       Enumerate domains\n");
    printf("\t-ea       Enumerate accounts\n");
    printf("\t-qd       Show display information\n");
    printf("\t-og       Open a group\n");
    printf("\t-gm       Show group members\n");
    printf("\t-oa       Open an alias\n");
    printf("\t-am       Show alias members\n");
    printf("\t-gam      Show alias membership\n");
    printf("\t-ou       Open a user\n");
    printf("\t-ggu      Show a user's groups\n");
    printf("\t-dau      Show all users\n");
    printf("\t-dag      Show all groups\n");
    printf("\t-du       Show a user's attributes\n");
    printf("\t-dg       Show a group's attributes\n");
    printf("\t-cu       Create a user\n");
    printf("\t-aam      Add a member to an alias\n");
    printf("\t-cg       Create a group\n");
    printf("\t-ca       Create an alias\n");
    printf("\t-dd       Show a domain\n");
    printf("\t-c        Connect to a SAM server\n");
    printf("\t-delu     Delete a user\n");
    printf("\t-dela     Delete an alias\n");
    printf("\t-delg     Delete a group\n");
    printf("\t-slh      Set a user's logon hours\n");
    printf("\t-spwd     Set a user's password\n");
    printf("\t-?        This message, also see samdrt.cmd\n");

    return(STATUS_SUCCESS);
}

VOID
PrintTime (
    CHAR * String,
    PVOID Time
    )
{
    SYSTEMTIME st;

    FileTimeToSystemTime((PFILETIME)Time, &st);

    kdprint(("%s %d-%d-%d %d:%2.2d:%2.2d\n",
           String,
           st.wMonth,
           st.wDay,
           st.wYear,
           st.wHour,
           st.wMinute,
           st.wSecond));
}

VOID
PrintDeltaTime(
    IN LPSTR Message,
    IN PLARGE_INTEGER Time
    )
{
    ULONG Seconds;
    ULONG Minutes;
    ULONG Hours;
    ULONG Days;
    ULONG Chars;
    CHAR TimeBuffer[256] = "";
    LPSTR TimeString = TimeBuffer;
    LARGE_INTEGER DeltaTime;

    DeltaTime.QuadPart = -Time->QuadPart;

    Seconds = (ULONG) (DeltaTime.QuadPart / 10000000);

    Minutes = Seconds / 60;
    Hours = Minutes / 60;
    Days = Hours / 24;

    Hours = Hours % 24;
    Minutes = Minutes % 60;
    Seconds = Seconds % 60;

    if (Days >= 1)
    {
        Chars = sprintf(TimeString,"%d days ",Days);
        TimeString += Chars;
    }
    if (Hours >= 1 )
    {
        Chars = sprintf(TimeString,"%d hours ",Hours);
        TimeString += Chars;
    }

    if (Minutes >= 1 && Days == 0)
    {
        Chars = sprintf(TimeString,"%d minutes ",Minutes);
        TimeString += Chars;
    }

    if (Seconds >= 1 && (Days == 0) && (Hours == 0) )
    {
        Chars = sprintf(TimeString,"%d seconds ",Seconds);
        TimeString += Chars;
    }

    kdprint(("%s %s\n",Message,TimeBuffer));

}


NTSTATUS
Connect( LPWSTR * Parameter)
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS Status;

    RtlInitUnicodeString(
        &ServerName,
        Parameter[0]
        );

    InitializeObjectAttributes(&oa,NULL,0,NULL,NULL);

    Status = SamConnect(
                &ServerName,
                &SamHandle,
                MAXIMUM_ALLOWED,
                &oa);
    return(Status);
}

NTSTATUS
CloseSam()
{
    return(SamCloseHandle(SamHandle));
}



NTSTATUS
EnumDomains(
                LPWSTR * Parameter )
{
    NTSTATUS Status;
    SHORT Language;
    SAM_ENUMERATE_HANDLE Context = 0;
    PSAM_RID_ENUMERATION Buffer = NULL;
    ULONG Count = 0;
    ULONG i;

    Status = SamEnumerateDomainsInSamServer(
                    SamHandle,
                    &Context,
                    (PVOID *) &Buffer,
                    2000,
                    &Count
                    );

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }


    for (i = 0; i < Count ; i++ )
    {
        kdprint(("Domain = %wZ\n",&Buffer[i].Name));
    }
    SamFreeMemory(Buffer);
    return(STATUS_SUCCESS);
}

NTSTATUS
OpenDomain( LPWSTR * Parameter )
{
    GUID DomainGuid;
    BOOLEAN fBuiltin;
    NTSTATUS Status;
    SID *DomainSid = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!_wcsicmp(Parameter[0],L"Builtin"))
    {
        fBuiltin = TRUE;
    }
    else if (!_wcsicmp(Parameter[0],L"Account"))
    {
        fBuiltin = FALSE;
    }
    else
    {
        kdprint(("Invalid domain to open: %ws\n",Parameter[0]));
        return(STATUS_UNSUCCESSFUL);
    }

    // Maximum SID size is 28 bytes, although domain SIDs are 24 bytes.

    DomainSid = (SID *)malloc(28);

    if (NULL == DomainSid)
    {
        return(STATUS_NO_MEMORY);
    }

    if (fBuiltin)
    {
        DomainSid->Revision = SID_REVISION;
        DomainSid->SubAuthorityCount = 1;
        DomainSid->IdentifierAuthority = NtAuthority;
        //DomainSid->ZerothSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;
        DomainSid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
    }
    else
    {
        LSA_HANDLE LsaHandle = NULL;
        OBJECT_ATTRIBUTES Oa;
        PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;

        RtlZeroMemory(&Oa, sizeof(OBJECT_ATTRIBUTES));
        Status = LsaOpenPolicy(
                    &ServerName,
                    &Oa,
                    POLICY_VIEW_LOCAL_INFORMATION,
                    &LsaHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to open policy: 0x%x\n",Status));
            return(Status);
        }
        Status = LsaQueryInformationPolicy(
                    LsaHandle,
                    PolicyAccountDomainInformation,
                    (PVOID *) &DomainInfo
                    );
        LsaClose(LsaHandle);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to query account domain: 0x%x\n",Status));
            return(Status);
        }
        RtlCopyMemory(
            DomainSid,
            DomainInfo->DomainSid,
            RtlLengthSid(DomainInfo->DomainSid)
            );
        LsaFreeMemory(DomainInfo);
    }

    Status = SamOpenDomain(
                SamHandle,
                MAXIMUM_ALLOWED,
                (PSID)DomainSid,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to open domain: 0x%x\n",Status));
    }

    free(DomainSid);

    return(Status);

}

NTSTATUS
EnumAccounts(   LPWSTR * Parameter )
{
    ULONG PreferedMax = 100;
    NTSTATUS Status;
    SAM_ENUMERATE_HANDLE EnumContext = 0;
    ULONG CountReturned;

    PSAM_RID_ENUMERATION Accounts = NULL;

    swscanf(Parameter[0],L"%d",&PreferedMax);

    kdprint(("EnumAccounts: %d\n",PreferedMax));


    EnumContext = 0;
    ASSERT(DomainHandle != NULL);
    do
    {
        Status = SamEnumerateUsersInDomain(
                        DomainHandle,
                        &EnumContext,
                        0,
                        (PVOID *) &Accounts,
                        PreferedMax,
                        &CountReturned
                        );

        if (NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES))
        {
            ULONG Index;
            UNICODE_STRING SidString;

            for (Index = 0; Index < CountReturned; Index++)
            {
                kdprint(("Account : %wZ 0x%x\n",&Accounts[Index].Name, Accounts[Index].RelativeId));
            }
            SamFreeMemory(Accounts);
        }
        else kdprint(("Failed to enumerate users: 0x%x\n",Status));
    } while (NT_SUCCESS(Status) && (Status != STATUS_SUCCESS) && (CountReturned != 0) );

    EnumContext = 0;
    do
    {
        Status = SamEnumerateGroupsInDomain(
                        DomainHandle,
                        &EnumContext,
                        (PVOID *) &Accounts,
                        PreferedMax,
                        &CountReturned
                        );

        if (NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES))
        {
            ULONG Index;
            UNICODE_STRING SidString;

            for (Index = 0; Index < CountReturned; Index++)
            {
                kdprint(("Group : %wZ 0x%x\n",&Accounts[Index].Name, Accounts[Index].RelativeId));
            }
            SamFreeMemory(Accounts);
        }
        else kdprint(("Failed to enumerate Groups: 0x%x\n",Status));
    } while (NT_SUCCESS(Status)  && (CountReturned != 0) ); // && (Status != STATUS_SUCCESS)


    EnumContext = 0;
    do
    {
        Status = SamEnumerateAliasesInDomain(
                        DomainHandle,
                        &EnumContext,
                        (PVOID *) &Accounts,
                        PreferedMax,
                        &CountReturned
                        );

        if (NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES))
        {
            ULONG Index;
            UNICODE_STRING SidString;

            for (Index = 0; Index < CountReturned; Index++)
            {
                kdprint(("Alias : %wZ 0x%x\n",&Accounts[Index].Name, Accounts[Index].RelativeId));
            }
            SamFreeMemory(Accounts);
        }
        else kdprint(("Failed to enumerate aliases: 0x%x\n",Status));
    } while (NT_SUCCESS(Status)  && (CountReturned != 0) ); // && (Status != STATUS_SUCCESS)



    return(Status);
}


NTSTATUS
QueryDisplay(   LPWSTR * Parameter )
{
    NTSTATUS Status;
    DOMAIN_DISPLAY_INFORMATION Type;
    PVOID Buffer = NULL;
    ULONG TotalAvailable = 0;
    ULONG TotalReturned = 0;
    ULONG ReturnedCount = 0;
    ULONG Index;
    ULONG SamIndex = 0;

    if (!_wcsicmp(Parameter[0],L"user"))
    {
        Type = DomainDisplayUser;
    } else if (!_wcsicmp(Parameter[0],L"Machine"))
    {
        Type = DomainDisplayMachine;
    } else if (!_wcsicmp(Parameter[0],L"Group"))
    {
        Type = DomainDisplayGroup;
    } else if (!_wcsicmp(Parameter[0],L"OemUser"))
    {
        Type = DomainDisplayOemUser;
    } else if (!_wcsicmp(Parameter[0],L"OemGroup"))
    {
        Type = DomainDisplayOemGroup;
    } else {
        kdprint(("Invalid parameter %ws\n", Parameter[0]));
        return(STATUS_INVALID_PARAMETER);
    }

    do
    {
        Status = SamQueryDisplayInformation(
                    DomainHandle,
                    Type,
                    SamIndex,
                    5,
                    1000,
                    &TotalAvailable,
                    &TotalReturned,
                    &ReturnedCount,
                    &Buffer
                    );

        if (NT_SUCCESS(Status) && (ReturnedCount > 0))
        {
            kdprint(("Total returned = %d\t total available = %d\n",
                TotalReturned, TotalAvailable));
            switch(Type) {
            case DomainDisplayUser:
                {
                    PDOMAIN_DISPLAY_USER Users = (PDOMAIN_DISPLAY_USER) Buffer;
                    for (Index = 0; Index < ReturnedCount ; Index++ )
                    {
                        kdprint(("User %d: Index %d\n Rid 0x%x\n Control 0x%x\n name %wZ\n Comment %wZ\n Full Name %wZ\n",
                            Index,
                            Users[Index].Index,
                            Users[Index].Rid,
                            Users[Index].AccountControl,
                            &Users[Index].LogonName,
                            &Users[Index].AdminComment,
                            &Users[Index].FullName
                            ));
                    }
                    break;
                }
            case DomainDisplayGroup:
                {
                    PDOMAIN_DISPLAY_GROUP Groups = (PDOMAIN_DISPLAY_GROUP) Buffer;
                    for (Index = 0; Index < ReturnedCount ; Index++ )
                    {
                        kdprint(("Group %d\n Index %d\n Rid 0x%x\n Attributes 0x%x\n name %wZ\n Comment %wZ\n",
                            Index,
                            Groups[Index].Index,
                            Groups[Index].Rid,
                            Groups[Index].Attributes,
                            &Groups[Index].Group,
                            &Groups[Index].Comment
                            ));

                    }
                    break;
                }
            case DomainDisplayMachine:
                {
                    PDOMAIN_DISPLAY_MACHINE Machines = (PDOMAIN_DISPLAY_MACHINE) Buffer;
                    for (Index = 0; Index < ReturnedCount ; Index++ )
                    {
                        kdprint(("Machine %d\n Index %d\n Rid 0x%x\n Control 0x%x\n Name %wZ\n Comment %wZ\n",
                            Index,
                            Machines[Index].Index,
                            Machines[Index].Rid,
                            Machines[Index].AccountControl,
                            &Machines[Index].Machine,
                            &Machines[Index].Comment
                            ));
                    }
                    break;
                }
            case DomainDisplayOemUser:
                {
                    PDOMAIN_DISPLAY_OEM_USER OemUsers = (PDOMAIN_DISPLAY_OEM_USER) Buffer;
                    for (Index = 0; Index < ReturnedCount ; Index++ )
                    {
                        kdprint(("OemUser %d\n Index %d\n Name %Z\n",
                            Index,
                            OemUsers[Index].Index,
                            &OemUsers[Index].User
                            ));
                    }
                    break;
                }
            case DomainDisplayOemGroup:
                {
                    PDOMAIN_DISPLAY_OEM_GROUP OemGroups = (PDOMAIN_DISPLAY_OEM_GROUP) Buffer;
                    for (Index = 0; Index < ReturnedCount ; Index++ )
                    {
                        kdprint(("OemGroup %d\n Index %d\n Name %Z\n",
                            Index,
                            OemGroups[Index].Index,
                            &OemGroups[Index].Group
                            ));
                    }
                    break;
                }

            }
            SamFreeMemory(Buffer);
            SamIndex += ReturnedCount;
        }


    } while (NT_SUCCESS(Status) && (ReturnedCount > 0));
    kdprint(("QDI returned 0x%x\n",Status));

    return(Status);


}

NTSTATUS
OpenGroup(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING GroupName;
    ULONG RelativeId = 0;

//    swscanf(Parameter[0],L"%x",&RelativeId);
    if (RelativeId == 0)
    {
        RtlInitUnicodeString(
            &GroupName,
            Parameter[0]
            );

        kdprint(("Looking up group %wZ\n",&GroupName));

        Status = SamLookupNamesInDomain(
                    DomainHandle,
                    1,
                    &GroupName,
                    &Rid,
                    &Use
                    );
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to lookup group: 0x%x\n",Status));
            return(Status);
        }
        RelativeId = *Rid;
        SamFreeMemory(Rid);
        SamFreeMemory(Use);
    }

    kdprint(("Opening Group 0x%x\n",RelativeId));
    Status= SamOpenGroup(
                DomainHandle,
                MAXIMUM_ALLOWED, // GROUP_LIST_MEMBERS | GROUP_READ_INFORMATION,
                RelativeId,
                &GroupHandle
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to open group: 0x%x\n",Status));
    }
    return(Status);
}

NTSTATUS
GroupMembers(LPWSTR * Parameter)
{
    NTSTATUS Status;
    ULONG MembershipCount;
    PULONG Attributes = NULL;
    PULONG Rids = NULL;
    ULONG Index;

    Status = SamGetMembersInGroup(
                GroupHandle,
                &Rids,
                &Attributes,
                &MembershipCount
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get members in group: 0x%x\n",Status));
        return(Status);
    }

    for (Index = 0; Index < MembershipCount ; Index++ )
    {
        kdprint(("Member %d: rid 0x%x, attributes 0x%x\n",
                Index,Rids[Index],Attributes[Index]));
    }
    SamFreeMemory(Rids);
    SamFreeMemory(Attributes);
    return(STATUS_SUCCESS);

}


NTSTATUS
OpenAlias(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING AliasName;
    ULONG RelativeId;

    #if 0
    swscanf(Parameter[0],L"%x",&RelativeId);
    if (RelativeId == 0)
    {
        RtlInitUnicodeString(
            &AliasName,
            Parameter[0]
            );

        kdprint(("Looking up Alias %wZ\n",&AliasName));

        // Find Alias RIDs for each name passed in.

        Status = SamLookupNamesInDomain(
                    DomainHandle,
                    1,
                    &AliasName, // IN
                    &Rid,       // OUT
                    &Use        // OUT
                    );
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to lookup Alias: 0x%x\n",Status));
            return(Status);
        }
        RelativeId = *Rid;
        SamFreeMemory(Rid);
        SamFreeMemory(Use);
    }

    kdprint(("Opening Alias 0x%x\n",RelativeId));
    #endif

    RtlInitUnicodeString(
        &AliasName,
        Parameter[0]
        );

    kdprint(("Looking up Alias %wZ\n",&AliasName));

    // Find Alias RIDs for each name passed in.

    Status = SamLookupNamesInDomain(
                DomainHandle,
                1,
                &AliasName, // IN
                &Rid,       // OUT
                &Use        // OUT
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to lookup Alias: 0x%x\n",Status));
        return(Status);
    }
    RelativeId = *Rid;
    SamFreeMemory(Rid);
    SamFreeMemory(Use);

    Status= SamOpenAlias(
                DomainHandle,

                // The alias was created with MAXIMUM_ALLOWED, which must be
                // the same access specified in the open call.

                // ALIAS_LIST_MEMBERS | ALIAS_ADD_MEMBER | ALIAS_REMOVE_MEMBER,
                MAXIMUM_ALLOWED,
                RelativeId,
                &AliasHandle
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to open alias: 0x%x\n",Status));
    }
    return(Status);
}

NTSTATUS
AliasMembers(LPWSTR * Parameter)
{
    NTSTATUS Status;
    ULONG MembershipCount;
    PSID * Members = NULL;
    ULONG Index;
    UNICODE_STRING Sid;

    Status = SamGetMembersInAlias(
                AliasHandle,
                &Members,
                &MembershipCount
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get members in Alias: 0x%x\n",Status));
        return(Status);
    }

    for (Index = 0; Index < MembershipCount ; Index++ )
    {
        RtlConvertSidToUnicodeString(
            &Sid,
            Members[Index],
            TRUE
            );
        kdprint(("Member %d: sid %wZ\n",
                Index,&Sid));
        RtlFreeUnicodeString(&Sid);
    }
    SamFreeMemory(Members);
    return(STATUS_SUCCESS);

}


NTSTATUS
GetAliasMembership(LPWSTR * Parameter)
{
    NTSTATUS Status;

    // NT5 SIDs are a maximum of 28 bytes.

    BYTE Buffer[28];
    PSID SidAddress = (PSID) Buffer;
    ULONG SidLength = sizeof(Buffer);
    WCHAR ReferencedDomainName[256];
    ULONG DomainNameLength = 256;
    SID_NAME_USE SidUse;
    ULONG Index;
    UNICODE_STRING Name;
    OBJECT_ATTRIBUTES Oa;
    LSA_HANDLE LsaHandle = NULL;
    ULONG MembershipCount;
    PULONG AliasList = NULL;

    kdprint(("Looking up groups for user %ws\n",Parameter[0]));

    if (!LookupAccountNameW(NULL,
                            Parameter[0],
                            SidAddress,
                            &SidLength,
                            ReferencedDomainName,
                            &DomainNameLength,
                            &SidUse))
    {
        kdprint(("Failed to lookup account sid: %d\n",GetLastError()));
        return(STATUS_UNSUCCESSFUL);
    }

    Status = SamGetAliasMembership(DomainHandle,
                                   1,
                                   &SidAddress,
                                   &MembershipCount,
                                   &AliasList);

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get alises : 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Alias membership count = %lu\n", MembershipCount));

    for (Index = 0; Index < MembershipCount ; Index++ )
    {
        kdprint(("Alias Member %d: rid 0x%x\n", Index, AliasList[Index]));
    }

    SamFreeMemory(AliasList);
    return(STATUS_SUCCESS);
}

NTSTATUS
GetAccountRid( LPWSTR Parameter,
               PULONG RelativeId)
{

    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING UserName;

    RtlInitUnicodeString(
        &UserName,
        Parameter
        );

    kdprint(("Looking up User %wZ\n",&UserName));

    Status = SamLookupNamesInDomain(
                DomainHandle,
                1,
                &UserName,
                &Rid,
                &Use
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to lookup User: 0x%x\n",Status));
        return(Status);
    }
    *RelativeId = *Rid;
    SamFreeMemory(Rid);
    SamFreeMemory(Use);

    return(STATUS_SUCCESS);
}
NTSTATUS
OpenUser(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING UserName;
    ULONG RelativeId = 0;

    Status = GetAccountRid(Parameter[0],&RelativeId);
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get account rid: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Opening User 0x%x\n",RelativeId));
    Status= SamOpenUser(
                DomainHandle,
                MAXIMUM_ALLOWED,
                RelativeId,
                &UserHandle
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to open User: 0x%x\n",Status));
    }
    return(Status);
}

NTSTATUS
DelUser( LPWSTR * Parameter)
{
    NTSTATUS Status;

    Status = SamDeleteUser(UserHandle);
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to delete user: 0x%x\n",Status));
    }
    else
    {
        // If successfully deleted, set the handle to NULL so that the
        // cleanup routine at the end of the test won't try to close an
        // invalid handle.

        UserHandle = NULL;
    }
    return(Status);
}

NTSTATUS
DelGroup( LPWSTR * Parameter)
{
    NTSTATUS Status;

    Status = SamDeleteGroup(GroupHandle);
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to delete group: 0x%x\n",Status));
    }
    else
    {
        // If successfully deleted, set the handle to NULL so that the
        // cleanup routine at the end of the test won't try to close an
        // invalid handle.

        GroupHandle = NULL;
    }
    return(Status);
}

NTSTATUS
DelAlias( LPWSTR * Parameter)
{
    NTSTATUS Status;

    Status = SamDeleteAlias(AliasHandle);
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to delete alias: 0x%x\n",Status));
    }
    else
    {
        // If successfully deleted, set the handle to NULL so that the
        // cleanup routine at the end of the test won't try to close an
        // invalid handle.

        AliasHandle = NULL;
    }
    return(Status);
}

NTSTATUS
CreateUser(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING UserName;
    ULONG RelativeId = 0;
    ACCESS_MASK GrantedAccess;


    RtlInitUnicodeString(
        &UserName,
        Parameter[0]
        );

    kdprint(("Creating User %wZ\n",&UserName));

    Status= SamCreateUser2InDomain(
                DomainHandle,
                &UserName,
                USER_NORMAL_ACCOUNT,
                MAXIMUM_ALLOWED,
                &UserHandle,
                &GrantedAccess,
                &RelativeId
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to create User: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Created user with rid 0x%x, access 0x%x\n",
        RelativeId, GrantedAccess));
    return(Status);
}

NTSTATUS
CreateGroup(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING GroupName;
    ULONG RelativeId = 0;


    RtlInitUnicodeString(
        &GroupName,
        Parameter[0]
        );

    kdprint(("Creating Group %wZ\n",&GroupName));

    Status= SamCreateGroupInDomain(
                DomainHandle,
                &GroupName,
                MAXIMUM_ALLOWED,
                &GroupHandle,
                &RelativeId
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to create Group: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Created Group with rid 0x%x, access 0x%x\n",
        RelativeId));
    return(Status);
}

NTSTATUS
CreateAlias(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING AliasName;
    ULONG RelativeId = 0;


    RtlInitUnicodeString(
        &AliasName,
        Parameter[0]
        );

    kdprint(("Creating Alias %wZ\n",&AliasName));

    Status= SamCreateAliasInDomain(
                DomainHandle,
                &AliasName,
                MAXIMUM_ALLOWED,
                &AliasHandle,
                &RelativeId
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to create Alias: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Created Alias with rid 0x%x, access 0x%x\n", RelativeId));
    return(Status);
}



NTSTATUS
GetGroupsForUser(LPWSTR * Parameter)
{
    NTSTATUS Status;
    ULONG MembershipCount;
    PULONG Attributes = NULL;
    PULONG Rids = NULL;
    ULONG Index;
    PGROUP_MEMBERSHIP Groups = NULL;

    Status = SamGetGroupsForUser(
                UserHandle,
                &Groups,
                &MembershipCount
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get groups for user: 0x%x\n",Status));
        return(Status);
    }

    for (Index = 0; Index < MembershipCount ; Index++ )
    {
        kdprint(("Member %d: rid 0x%x, attributes 0x%x\n",
                Index,Groups[Index].RelativeId, Groups[Index].Attributes ));
    }
    SamFreeMemory(Groups);
    return(STATUS_SUCCESS);

}

VOID
PrintLogonHours(
    CHAR * String,
    PLOGON_HOURS LogonHours
    )
{
    int Index;
    kdprint(("%s",String));
    for (Index = 0; Index < (LogonHours->UnitsPerWeek + 7) / 8 ;Index++ )
    {
        kdprint(("0x%2.2x ",LogonHours->LogonHours[Index]));
    }
    kdprint(("\n"));
}


NTSTATUS
DumpUser(LPWSTR * Parameter)
{
    NTSTATUS Status;
    PUSER_ALL_INFORMATION UserAll = NULL;
    PUSER_GENERAL_INFORMATION UserGeneral = NULL;
    PUSER_PREFERENCES_INFORMATION UserPreferences = NULL;
    PUSER_LOGON_INFORMATION UserLogon = NULL;
    PUSER_ACCOUNT_INFORMATION UserAccount = NULL;
    PUSER_ACCOUNT_NAME_INFORMATION UserAccountName = NULL;
    PUSER_FULL_NAME_INFORMATION UserFullName = NULL;
    PUSER_NAME_INFORMATION UserName = NULL;
    PUSER_PRIMARY_GROUP_INFORMATION UserPrimary = NULL;
    PUSER_HOME_INFORMATION UserHome = NULL;
    PUSER_SCRIPT_INFORMATION UserScript = NULL;
    PUSER_PROFILE_INFORMATION UserProfile = NULL;
    PUSER_ADMIN_COMMENT_INFORMATION UserAdminComment = NULL;
    PUSER_WORKSTATIONS_INFORMATION UserWksta = NULL;
    PUSER_CONTROL_INFORMATION UserControl = NULL;
    PUSER_EXPIRES_INFORMATION UserExpires = NULL;
    PUSER_LOGON_HOURS_INFORMATION UserLogonHours = NULL;

    kdprint(("\nDumpUser.\n"));
    Status = SamQueryInformationUser(
                UserHandle,
                UserAllInformation,
                (PVOID *) &UserAll
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user all: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserAll:\n"));
    PrintTime("\tLastLogon = ",&UserAll->LastLogon);
    PrintTime("\tLastLogoff = ",&UserAll->LastLogoff);
    PrintTime("\tPasswordLastSet = ",&UserAll->PasswordLastSet);
    PrintTime("\tAccountExpires = ",&UserAll->AccountExpires);
    PrintTime("\tPasswordCanChange = ",&UserAll->PasswordCanChange);
    PrintTime("\tPasswordMustChange = ",&UserAll->PasswordMustChange);
    kdprint(("\tUserName = %wZ\n",&UserAll->UserName));
    kdprint(("\tFullName = %wZ\n",&UserAll->FullName));
    kdprint(("\tHomeDirectory = %wZ\n",&UserAll->HomeDirectory));
    kdprint(("\tHomeDirectoryDrive = %wZ\n",&UserAll->HomeDirectoryDrive));
    kdprint(("\tScriptPath = %wZ\n",&UserAll->ScriptPath));
    kdprint(("\tProfilePath = %wZ\n",&UserAll->ProfilePath));
    kdprint(("\tAdminComment = %wZ\n",&UserAll->AdminComment));
    kdprint(("\tWorkStations = %wZ\n",&UserAll->WorkStations));
    kdprint(("\tUserComment = %wZ\n",&UserAll->UserComment));
    kdprint(("\tParameters = %wZ\n",&UserAll->Parameters));
    kdprint(("\tUserId = 0x%x\n",UserAll->UserId));
    kdprint(("\tPrimaryGroupId = 0x%x\n",UserAll->PrimaryGroupId));
    kdprint(("\tUserAccountControl = 0x%x\n",UserAll->UserAccountControl));
    kdprint(("\tWhichFields = 0x%x\n",UserAll->WhichFields));
    PrintLogonHours("\tLogonHours = ",&UserAll->LogonHours);
    kdprint(("\tLogonCount = %d\n",UserAll->LogonCount));
    kdprint(("\tCountryCode = %d\n",UserAll->CountryCode));
    kdprint(("\tCodePage = %d\n",UserAll->CodePage));

    SamFreeMemory(UserAll);

    Status = SamQueryInformationUser(
                UserHandle,
                UserGeneralInformation,
                (PVOID *) &UserGeneral
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user general: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserGeneral:\n"));
    kdprint(("\tUserName = %wZ\n",&UserGeneral->UserName));
    kdprint(("\tFullName = %wZ\n",&UserGeneral->FullName));
    kdprint(("\tPrimaryGroupId = 0x%x\n",UserGeneral->PrimaryGroupId));
    kdprint(("\tAdminComment = 0x%x\n",&UserGeneral->AdminComment));
    kdprint(("\tUserComment = 0x%x\n",&UserGeneral->UserComment));

    SamFreeMemory(UserGeneral);

    Status = SamQueryInformationUser(
                UserHandle,
                UserPreferencesInformation,
                (PVOID *) &UserPreferences
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user preferences: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserPreferences:\n"));
    kdprint(("\tUserComment = %wZ\n",&UserPreferences->UserComment));
    kdprint(("\tReserved1 = %wZ\n",&UserPreferences->Reserved1));
    kdprint(("\tCountryCode = %d\n",&UserPreferences->CountryCode));
    kdprint(("\tCodePage = %d\n",&UserPreferences->CodePage));

    SamFreeMemory(UserPreferences);

    Status = SamQueryInformationUser(
                UserHandle,
                UserLogonInformation,
                (PVOID *) &UserLogon
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user Logon: 0x%x\n",Status));
        return(Status);
    }


    kdprint(("UserLogon:\n"));
    kdprint(("\tUserName = %wZ\n",&UserLogon->UserName));
    kdprint(("\tFullName = %wZ\n",&UserLogon->FullName));
    kdprint(("\tUserId = 0x%x\n",UserLogon->UserId));
    kdprint(("\tPrimaryGroupId = 0x%x\n",UserLogon->PrimaryGroupId));
    kdprint(("\tHomeDirectory = %wZ\n",&UserLogon->HomeDirectory));
    kdprint(("\tHomeDirectoryDrive = %wZ\n",&UserLogon->HomeDirectoryDrive));
    kdprint(("\tScriptPath = %wZ\n",&UserLogon->ScriptPath));
    kdprint(("\tProfilePath = %wZ\n",&UserLogon->ProfilePath));
    kdprint(("\tWorkStations = %wZ\n",&UserLogon->WorkStations));
    PrintTime("\tLastLogon = ",&UserLogon->LastLogon);
    PrintTime("\tLastLogoff = ",&UserLogon->LastLogoff);
    PrintTime("\tPasswordLastSet = ",&UserLogon->PasswordLastSet);
    PrintTime("\tPasswordCanChange = ",&UserLogon->PasswordCanChange);
    PrintTime("\tPasswordMustChange = ",&UserLogon->PasswordMustChange);
    PrintLogonHours("\tLogonHours = ",&UserLogon->LogonHours);
    kdprint(("\tBadPasswordCount = %d\n",UserLogon->BadPasswordCount));
    kdprint(("\tLogonCount = %d\n",UserLogon->LogonCount));
    kdprint(("\tUserAccountControl = 0x%x\n",UserLogon->UserAccountControl));

    SamFreeMemory(UserLogon);

    Status = SamQueryInformationUser(
                UserHandle,
                UserAccountInformation,
                (PVOID *) &UserAccount
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user account: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserAccount:\n"));
    kdprint(("\tUserName = %wZ\n",&UserAccount->UserName));
    kdprint(("\tFullName = %wZ\n",&UserAccount->FullName));
    kdprint(("\tUserId = 0x%x\n",UserAccount->UserId));
    kdprint(("\tPrimaryGroupId = 0x%x\n",UserAccount->PrimaryGroupId));
    kdprint(("\tHomeDirectory = %wZ\n",&UserAccount->HomeDirectory));
    kdprint(("\tHomeDirectoryDrive = %wZ\n",&UserAccount->HomeDirectoryDrive));
    kdprint(("\tScriptPath = %wZ\n",&UserAccount->ScriptPath));
    kdprint(("\tProfilePath = %wZ\n",&UserAccount->ProfilePath));
    kdprint(("\tAdminComment = %wZ\n",&UserAccount->AdminComment));
    kdprint(("\tWorkStations = %wZ\n",&UserAccount->WorkStations));
    PrintTime("\tLastLogon = ",&UserAccount->LastLogon);
    PrintTime("\tLastLogoff = ",&UserAccount->LastLogoff);
    PrintLogonHours("\tLogonHours = ",&UserAccount->LogonHours);
    kdprint(("\tBadPasswordCount = %d\n",UserAccount->BadPasswordCount));
    kdprint(("\tLogonCount = %d\n",UserAccount->LogonCount));
    PrintTime("\tPasswordLastSet = ",&UserAccount->PasswordLastSet);
    PrintTime("\tAccountExpires = ",&UserAccount->AccountExpires);
    kdprint(("\tUserAccountControl = 0x%x\n",UserAccount->UserAccountControl));

    SamFreeMemory(UserAccount);

    Status = SamQueryInformationUser(
                UserHandle,
                UserAccountNameInformation,
                (PVOID *) &UserAccountName
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user account name: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserAccountName:\n"));
    kdprint(("\tUserName = %wZ\n",&UserAccountName->UserName));
    SamFreeMemory(UserAccountName);

    Status = SamQueryInformationUser(
                UserHandle,
                UserFullNameInformation,
                (PVOID *) &UserFullName
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user full name: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserFullName:\n"));
    kdprint(("\tFullName = %wZ\n",&UserFullName->FullName));
    SamFreeMemory(UserFullName);

    Status = SamQueryInformationUser(
                UserHandle,
                UserNameInformation,
                (PVOID *) &UserName
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user name: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserName:\n"));
    kdprint(("\tUserName = %wZ\n",&UserName->UserName));
    kdprint(("\tFullName = %wZ\n",&UserName->FullName));
    SamFreeMemory(UserName);

    Status = SamQueryInformationUser(
                UserHandle,
                UserPrimaryGroupInformation,
                (PVOID *) &UserPrimary
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user all: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserPrimaryGroup:\n"));
    kdprint(("PrimaryGroupid = 0x%x\n",UserPrimary->PrimaryGroupId));
    SamFreeMemory(UserPrimary);

    Status = SamQueryInformationUser(
                UserHandle,
                UserHomeInformation,
                (PVOID *) &UserHome
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user home: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserHome:\n"));
    kdprint(("\tHomeDirectory = %wZ\n",&UserHome->HomeDirectory));
    kdprint(("\tHomeDirectoryDrive = %wZ\n",&UserHome->HomeDirectoryDrive));

    SamFreeMemory(UserHome);

    Status = SamQueryInformationUser(
                UserHandle,
                UserScriptInformation,
                (PVOID *) &UserScript
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user Script: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserScript:\n"));
    kdprint(("\tScriptPath = %wZ\n",&UserScript->ScriptPath));

    SamFreeMemory(UserScript);

    Status = SamQueryInformationUser(
                UserHandle,
                UserProfileInformation,
                (PVOID *) &UserProfile
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user Profile: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserProfile:\n"));
    kdprint(("\tProfilePath = %wZ\n",&UserProfile->ProfilePath));

    SamFreeMemory(UserProfile);
    Status = SamQueryInformationUser(
                UserHandle,
                UserAdminCommentInformation,
                (PVOID *) &UserAdminComment
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user AdminComment: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserAdminComment:\n"));
    kdprint(("\tAdminComment = %wZ\n",&UserAdminComment->AdminComment));
    SamFreeMemory(UserAdminComment);

    Status = SamQueryInformationUser(
                UserHandle,
                UserWorkStationsInformation,
                (PVOID *) &UserWksta
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user wksta: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserWorkStations:\n"));
    kdprint(("\tWorkStations = %wZ\n",&UserWksta->WorkStations));
    SamFreeMemory(UserWksta);

    Status = SamQueryInformationUser(
                UserHandle,
                UserControlInformation,
                (PVOID *) &UserControl
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user Control: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserControl:\n"));
    kdprint(("\tUserAccountControl = 0x%x\n",UserControl->UserAccountControl));
    SamFreeMemory(UserControl);

    Status = SamQueryInformationUser(
                UserHandle,
                UserExpiresInformation,
                (PVOID *) &UserExpires
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user Expires: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserExpires:\n"));
    PrintTime("\tAccountExpires = ",&UserExpires->AccountExpires);
    SamFreeMemory(UserExpires);

    Status = SamQueryInformationUser(
                UserHandle,
                UserLogonHoursInformation,
                (PVOID *) &UserLogonHours
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user LogonHours: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserLogonHours:\n"));
    PrintLogonHours("\tLogonHours = ",&UserLogonHours->LogonHours);

    SamFreeMemory(UserLogonHours);


    return(STATUS_SUCCESS);
}

NTSTATUS
DumpGroup(LPWSTR * Parameter)
{
    NTSTATUS Status;
    PGROUP_GENERAL_INFORMATION General = NULL;
    PGROUP_NAME_INFORMATION Name = NULL;
    PGROUP_ATTRIBUTE_INFORMATION Attribute = NULL;
    PGROUP_ADM_COMMENT_INFORMATION AdmComment = NULL;

    kdprint(("\nDumpGroup.\n"));
    Status = SamQueryInformationGroup(
                GroupHandle,
                GroupGeneralInformation,
                (PVOID *) &General
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get group general information: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Group General.Name = %wZ\n",&General->Name));
    kdprint(("Group General.Attributes = 0x%x\n",General->Attributes));
    kdprint(("Group general.memberCount = %d\n",General->MemberCount));
    kdprint(("Group general.AdminComment = %wZ\n",&General->AdminComment));
    SamFreeMemory(General);

    Status = SamQueryInformationGroup(
                GroupHandle,
                GroupNameInformation,
                (PVOID *) &Name
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get group name information: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Group Name.Name = %wZ\n",&Name->Name));
    SamFreeMemory(Name);

    Status = SamQueryInformationGroup(
                GroupHandle,
                GroupAttributeInformation,
                (PVOID *) &Attribute
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get group Attribute information: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Group Attribute.Attributes = 0x%x\n",Attribute->Attributes));
    SamFreeMemory(Attribute);

    Status = SamQueryInformationGroup(
                GroupHandle,
                GroupAdminCommentInformation,
                (PVOID *) &AdmComment
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get group admin comment information: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Group Admin comment.AdminComment = %wZ\n",&AdmComment->AdminComment));
    SamFreeMemory(AdmComment);

    return(STATUS_SUCCESS);
}

NTSTATUS
DumpAllGroups(LPWSTR * Parameter)
{
    // ULONG PreferedMax = 1000;
    ULONG PreferedMax = 36;
    NTSTATUS Status,EnumStatus;
    SAM_ENUMERATE_HANDLE EnumContext = 0;
    ULONG CountReturned;
    LPWSTR GroupName[1];

    PSAM_RID_ENUMERATION Accounts = NULL;


    GroupName[0] = (LPWSTR) malloc(128);
    if (NULL == GroupName[0])
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    kdprint(("DumpAllGroups:\n"));


    EnumContext = 0;
    ASSERT(DomainHandle != NULL);
    do
    {
        EnumStatus = SamEnumerateGroupsInDomain(
                        DomainHandle,
                        &EnumContext,
                        (PVOID *) &Accounts,
                        PreferedMax,
                        &CountReturned
                        );

        if (NT_SUCCESS(EnumStatus) && (EnumStatus != STATUS_NO_MORE_ENTRIES))
        {
            ULONG Index;
            UNICODE_STRING SidString;

            for (Index = 0; Index < CountReturned; Index++)
            {
                RtlCopyMemory(
                    GroupName[0],
                    Accounts[Index].Name.Buffer,
                    Accounts[Index].Name.Length
                    );
                GroupName[0][Accounts[Index].Name.Length/sizeof(WCHAR)] = L'\0';

                Status = OpenGroup(GroupName);
                if (!NT_SUCCESS(Status))
                {
                    break;
                }
                Status = DumpGroup(NULL);
                SamCloseHandle(GroupHandle);
                GroupHandle = NULL;

            }
            SamFreeMemory(Accounts);
        }
        else kdprint(("Failed to enumerate Groups: 0x%x\n",Status));
    } while (NT_SUCCESS(EnumStatus) && (EnumStatus != STATUS_SUCCESS) && (CountReturned != 0) );

    free(GroupName[0]);
    return(STATUS_SUCCESS);
}

NTSTATUS
DumpAllUsers(LPWSTR * Parameter)
{
    ULONG PreferedMax = 1000;
    NTSTATUS Status,EnumStatus;
    SAM_ENUMERATE_HANDLE EnumContext = 0;
    ULONG CountReturned;
    LPWSTR UserName[1];

    PSAM_RID_ENUMERATION Accounts = NULL;


    UserName[0] = (LPWSTR) malloc(128);
    if (NULL == UserName[0])
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    kdprint(("DumpAllUsers:\n"));


    EnumContext = 0;
    ASSERT(DomainHandle != NULL);
    do
    {
        EnumStatus = SamEnumerateUsersInDomain(
                        DomainHandle,
                        &EnumContext,
                        0,
                        (PVOID *) &Accounts,
                        PreferedMax,
                        &CountReturned
                        );

        if (NT_SUCCESS(EnumStatus) && (EnumStatus != STATUS_NO_MORE_ENTRIES))
        {
            ULONG Index;
            UNICODE_STRING SidString;

            for (Index = 0; Index < CountReturned; Index++)
            {
                RtlCopyMemory(
                    UserName[0],
                    Accounts[Index].Name.Buffer,
                    Accounts[Index].Name.Length
                    );
                UserName[0][Accounts[Index].Name.Length/sizeof(WCHAR)] = L'\0';

                Status = OpenUser(UserName);
                if (!NT_SUCCESS(Status))
                {
                    break;
                }
                Status = DumpUser(NULL);
                Status = GetGroupsForUser(NULL);
                SamCloseHandle(UserHandle);
                UserHandle = NULL;

            }
            SamFreeMemory(Accounts);
        }
        else kdprint(("Failed to enumerate users: 0x%x\n",Status));
    } while (NT_SUCCESS(EnumStatus) && (EnumStatus != STATUS_SUCCESS) && (CountReturned != 0) );

    free(UserName[0]);
    return(STATUS_SUCCESS);
}

NTSTATUS
AddAliasMember( LPWSTR * Parameter )
{
    BYTE Buffer[100];
    PSID AccountSid = Buffer;
    ULONG SidLen = 100;
    SID_NAME_USE Use;
    WCHAR ReferencedDomain[100];
    ULONG DomainLen = 100;
    NTSTATUS Status;

    kdprint(("Adding account %ws to alias\n",Parameter[0]));
    if (!LookupAccountNameW(
            NULL,
            Parameter[0],
            AccountSid,
            &SidLen,
            ReferencedDomain,
            &DomainLen,
            &Use))
    {
        kdprint(("Failed to lookup account name: %d\n",GetLastError()));
        return(STATUS_UNSUCCESSFUL);
    }

    Status = SamAddMemberToAlias(
                AliasHandle,
                AccountSid
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to add member to alias: 0x%x\n",Status));
    }
    return(Status);
}

NTSTATUS
DumpDomain( LPWSTR * Parameter )
{
    NTSTATUS Status;
    PDOMAIN_PASSWORD_INFORMATION Password = NULL;
    PDOMAIN_GENERAL_INFORMATION General = NULL;
    PDOMAIN_LOGOFF_INFORMATION Logoff = NULL;
    PDOMAIN_OEM_INFORMATION Oem = NULL;
    PDOMAIN_NAME_INFORMATION Name = NULL;
    PDOMAIN_REPLICATION_INFORMATION Replica = NULL;
    PDOMAIN_SERVER_ROLE_INFORMATION ServerRole = NULL;
    PDOMAIN_MODIFIED_INFORMATION Modified = NULL;
    PDOMAIN_STATE_INFORMATION State = NULL;
    PDOMAIN_GENERAL_INFORMATION2 General2 = NULL;
    PDOMAIN_LOCKOUT_INFORMATION Lockout = NULL;
    PDOMAIN_MODIFIED_INFORMATION2 Modified2 = NULL;


    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainPasswordInformation,
                (PVOID *) &Password
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query password information: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Password:\n"));
    kdprint(("\tMinPasswordLength = %d\n",Password->MinPasswordLength));
    kdprint(("\tPasswordHistoryLength = %d\n",Password->PasswordHistoryLength));
    kdprint(("\tPasswordProperties = 0x%x\n",Password->PasswordProperties));
    PrintDeltaTime("\tMaxPasswordAge = ",&Password->MaxPasswordAge);
    PrintDeltaTime("\tMinPasswordAge = ",&Password->MinPasswordAge);

    SamFreeMemory(Password);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainGeneralInformation,
                (PVOID *) &General
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query general: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("General:\n"));
    PrintDeltaTime("\t ForceLogoff = ",&General->ForceLogoff);
    kdprint(("\t OemInformation = %wZ\n",&General->OemInformation));
    kdprint(("\t DomainName = %wZ\n",&General->DomainName));
    kdprint(("\t ReplicaSourceNodeName =%wZ\n",&General->ReplicaSourceNodeName));
    kdprint(("\t DomainModifiedCount = 0x%x,0x%x\n",
        General->DomainModifiedCount.HighPart,
        General->DomainModifiedCount.LowPart ));
    kdprint(("\t DomainServerState = %d\n",General->DomainServerState));
    kdprint(("\t DomainServerRole = %d\n",General->DomainServerRole));
    kdprint(("\t UasCompatibilityRequired = %d\n",General->UasCompatibilityRequired));
    kdprint(("\t UserCount = %d\n",General->UserCount));
    kdprint(("\t GroupCount = %d\n",General->GroupCount));
    kdprint(("\t AliasCount = %d\n",General->AliasCount));

    SamFreeMemory(General);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainLogoffInformation,
                (PVOID *) &Logoff
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query logoff: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Logoff:\n"));
    PrintDeltaTime("\t ForceLogoff = ",&Logoff->ForceLogoff);
    SamFreeMemory(Logoff);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainOemInformation,
                (PVOID *) &Oem
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Oem: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Oem:\n\t OemInformation = %wZ\n",&Oem->OemInformation));

    SamFreeMemory(Oem);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainNameInformation,
                (PVOID *) &Name
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Name: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Name:\n\t DomainName = %wZ\n",&Name->DomainName));

    SamFreeMemory(Name);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainReplicationInformation,
                (PVOID *) &Replica
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Replica: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Replica:\n\t ReplicaSourceNodeName = %wZ\n", &Replica->ReplicaSourceNodeName));
    SamFreeMemory(Replica);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainServerRoleInformation,
                (PVOID *) &ServerRole
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query ServerRole: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("ServerRole:\n\t DomainServerRole = %d\n",ServerRole->DomainServerRole));
    SamFreeMemory(ServerRole);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainModifiedInformation,
                (PVOID *) &Modified
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Modified: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Modified:\n"));
    kdprint(("\t DomainModifiedCount = 0x%x,0x%x\n",
        Modified->DomainModifiedCount.HighPart,
        Modified->DomainModifiedCount.LowPart ));
    PrintTime("\t CreationTime = ",&Modified->CreationTime);



    SamFreeMemory(Modified);


    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainStateInformation,
                (PVOID *) &State
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query State: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("State:\n\t DomainServerState = %d\n",State->DomainServerState));
    SamFreeMemory(State);


    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainGeneralInformation2,
                (PVOID *) &General2
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query General2: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("General2:\n"));
    General = &General2->I1;
    PrintDeltaTime("\t ForceLogoff = ",&General->ForceLogoff);
    kdprint(("\t OemInformation = %wZ\n",&General->OemInformation));
    kdprint(("\t DomainName = %wZ\n",&General->DomainName));
    kdprint(("\t ReplicaSourceNodeName =%wZ\n",&General->ReplicaSourceNodeName));
    kdprint(("\t DomainModifiedCount = 0x%x,0x%x\n",
        General->DomainModifiedCount.HighPart,
        General->DomainModifiedCount.LowPart ));
    kdprint(("\t DomainServerState = %d\n",General->DomainServerState));
    kdprint(("\t DomainServerRole = %d\n",General->DomainServerRole));
    kdprint(("\t UasCompatibilityRequired = %d\n",General->UasCompatibilityRequired));
    kdprint(("\t UserCount = %d\n",General->UserCount));
    kdprint(("\t GroupCount = %d\n",General->GroupCount));
    kdprint(("\t AliasCount = %d\n",General->AliasCount));
    PrintDeltaTime("\t LockoutDuration = ",&General2->LockoutDuration);
    PrintDeltaTime("\t LockoutObservationWindow = ",&General2->LockoutObservationWindow);
    kdprint(("\t LockoutThreshold = %d\n",General2->LockoutThreshold));

    SamFreeMemory(General2);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainLockoutInformation,
                (PVOID *) &Lockout
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Lockout: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Lockout:\n"));
    PrintDeltaTime("\t LockoutDuration = ",&Lockout->LockoutDuration);
    PrintDeltaTime("\t LockoutObservationWindow = ",&Lockout->LockoutObservationWindow);
    kdprint(("\t LockoutThreshold = %d\n",Lockout->LockoutThreshold));

    SamFreeMemory(Lockout);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainModifiedInformation2,
                (PVOID *) &Modified2
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Modified2: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Modified2:\n"));
    PrintTime("\t CreationTime = ",&Modified->CreationTime);
    kdprint(("\t DomainModifiedCount = 0x%x,0x%x\n",
        Modified2->DomainModifiedCount.HighPart,
        Modified2->DomainModifiedCount.LowPart ));

    kdprint(("\t ModifiedCountAtLastPromotion = 0x%x,0x%x\n",
        Modified2->ModifiedCountAtLastPromotion.HighPart,
        Modified2->ModifiedCountAtLastPromotion.LowPart ));

    SamFreeMemory(Modified2);

    return(STATUS_SUCCESS);

}


NTSTATUS
SetLogonHours( LPWSTR * Parameter )
{
    // The purpose of this test is to verify that attempts to change the
    // logon hours time units will cause SAM to return STATUS_NOT_SUPPORTED
    // in the NT5 Beta Release. By default, SAM sets the time units to
    // SAM_HOURS_PER_WEEK, the most natural value of the three possible
    // settings. This test tries to reset the logon hours to the other two
    // values (minutes per week and days per week). These cases should fail
    // and return STATUS_NOT_SUPPORTED. Setting the value to the default
    // SAM_HOURS_PER_WEEK REQUIRES THAT MORE OF THE SAM USER-INFORMATION
    // DATA ALSO BE SET, otherwise garbage values for group membership, etc.
    // will be set (with unpredictable results).

    NTSTATUS NtStatus = STATUS_SUCCESS;
    LOGON_HOURS LogonHours;
    UCHAR Allow = 0xFF;

    // One bit per chosen time unit in the logon-hours bitmask.

    UCHAR DaysPerWeek[1];                           // 7 bits, 1 byte
    UCHAR HoursPerWeek[SAM_HOURS_PER_WEEK / 8];     // 168 bits, 21 bytes
    UCHAR MinutesPerWeek[SAM_MINUTES_PER_WEEK / 8]; // 10080 bits, 1260 bytes

    // Try each of the two alternative time units allowed. For now, since
    // accounts are created with NULL logon hours (implying always allow
    // logon initially), these two attempts to reset the time units to
    // some other value will fail with STATUS_NOT_SUPPORTED, which is the
    // desired result until DS-SAM supports the ability to modify logon
    // hours TIME UNITS.

    RtlCopyMemory(&DaysPerWeek, &Allow, sizeof(DaysPerWeek));
    LogonHours.UnitsPerWeek = SAM_DAYS_PER_WEEK;
    LogonHours.LogonHours = (PUCHAR)&DaysPerWeek;

    NtStatus = SamSetInformationUser(UserHandle,
                                     UserLogonHoursInformation,
                                     &LogonHours);

    kdprint(("SetLogonHours [Days Per Week] status = 0x%lx\n", NtStatus));

    if (STATUS_NOT_SUPPORTED != NtStatus)
    {
        return(NtStatus);
    }

    RtlCopyMemory(&MinutesPerWeek, &Allow, sizeof(MinutesPerWeek));
    LogonHours.UnitsPerWeek = SAM_MINUTES_PER_WEEK;
    LogonHours.LogonHours = (PUCHAR)&MinutesPerWeek;

    NtStatus = SamSetInformationUser(UserHandle,
                                     UserLogonHoursInformation,
                                     &LogonHours);

    kdprint(("SetLogonHours [Minutes Per Week] status = 0x%lx\n", NtStatus));

    if (STATUS_NOT_SUPPORTED != NtStatus)
    {
        return(NtStatus);
    }

    // If the test has made it this far, STATUS_NOT_SUPPORTED has been re-
    // turned from all test cases. This is the desired result for now.

    NtStatus = STATUS_SUCCESS;

    return(NtStatus);
}

NTSTATUS
SetPassword( LPWSTR * Parameter )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    USER_SET_PASSWORD_INFORMATION PasswordInfo;

    RtlZeroMemory(&PasswordInfo, sizeof(USER_SET_PASSWORD_INFORMATION));

    RtlInitUnicodeString(&(PasswordInfo.Password), L"Password");
    PasswordInfo.PasswordExpired = FALSE;

    NtStatus = SamSetInformationUser(UserHandle,
                                     UserSetPasswordInformation,
                                     &PasswordInfo);

    if (!NT_SUCCESS(NtStatus))
    {
        kdprint(("SamSetInformationUser status = 0x%lx\n", NtStatus));
    }

    return(NtStatus);
}

NTSTATUS
ChangeKey( LPWSTR * Parameter )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UCHAR    SyskeyBuffer[16];
    ULONG    len = sizeof(SyskeyBuffer);

    NtStatus = WxReadSysKey(&len,SyskeyBuffer);
    if (NT_SUCCESS(NtStatus))
    {
        UNICODE_STRING Syskey;

        Syskey.Length = Syskey.MaximumLength = (USHORT)len;
        Syskey.Buffer = (WCHAR * )SyskeyBuffer;

        NtStatus = SamiSetBootKeyInformation(
                        DomainHandle,
                        SamBootChangePasswordEncryptionKey,
                        &Syskey,
                        &Syskey
                        );

        printf("SamiSetBootKeyInformation status = 0x%lx\n", NtStatus);
    }
    else
    {
        printf("WxReadSyskey status = 0x%lx\n", NtStatus);
    }

    return(NtStatus);
}

VOID
_cdecl
main(INT argc, CHAR *argv[])
{
    ULONG Command = 0;
    ULONG i,j,k;
    BOOLEAN Found;
    NTSTATUS Status;
    Action Actions[20];
    ULONG ActionCount = 0;

    BOOLEAN TestStatus = TRUE;

    for (i = 1; i < (ULONG) argc ; i++ )
    {
        Found = FALSE;
        for (j = 0; j < NUM_COMMANDS ; j++ )
        {
            if (!_stricmp(argv[i],Commands[j].Name))
            {
                Actions[ActionCount].CommandNumber = j;

                if (Commands[j].Parameter != 0)
                {
                    for (k = 0; k < Commands[j].Parameter ;k++ )
                    {
                        Actions[ActionCount].Parameter[k] = (LPWSTR) malloc(128);
                        if ((ULONG) argc > i)
                        {
                            mbstowcs(Actions[ActionCount].Parameter[k],argv[++i],128);
                        }
                        else
                        {
                            Actions[ActionCount].Parameter[k][0] = L'\0';
                        }
                    }
                }
                Found = TRUE;
                ActionCount++;
                break;
            }
        }
        if (!Found)
        {
            kdprint(("Switch %s not found\n", argv[i]));
            exit(2);
        }
    }

    for (i = 0; i < ActionCount ; i++ )
    {
        Status = Commands[Actions[i].CommandNumber].Function(Actions[i].Parameter);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed test %s : 0x%x\n",Commands[Actions[i].CommandNumber].Name,Status));
            TestStatus = FALSE;
            goto Cleanup;

        }
    }

Cleanup:
    if (DomainHandle != NULL)
    {
        Status = SamCloseHandle(DomainHandle);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to close domain handle: 0x%x\n",Status));
        }
    }
    if (GroupHandle != NULL)
    {
        Status = SamCloseHandle(GroupHandle);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to close group handle: 0x%x\n",Status));
        }
    }
    if (AliasHandle != NULL)
    {
        Status = SamCloseHandle(AliasHandle);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to close alias handle: 0x%x\n",Status));
        }
    }
    if (UserHandle != NULL)
    {
        Status = SamCloseHandle(UserHandle);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to close user handle: 0x%x\n",Status));
        }
    }
    Status = CloseSam();
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to close lsa: 0x%x\n",Status));
    }

    // This test should always conclude by displaying its status to stdout.
    // All other output should optionally go to stdout or a debugger, but
    // should not display to stdout by default (so that this test can be
    // used in the BVT lab tests if needed).

    if (TRUE == TestStatus)
    {
        printf("PASSED\n");
        exit(0);
    }
    else
    {
        printf("FAILED\n");
        exit(1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\ldaprepltest\replcompare.hpp ===
#ifndef _T_CHRISK_REPLCOMPARE_
#define _T_CHRISK_REPLCOMPARE_

DWORD
Repl_ArrayComp(DS_REPL_STRUCT_TYPE structId,
                   puReplStructArray pStructArrayA,
                   puReplStructArray pStructArrayB);

DWORD
Repl_StructComp(DS_REPL_STRUCT_TYPE structId,
                    puReplStruct pStructA,
                    puReplStruct pStructB);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\ldaprepltest\main.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>

#include "ldaprepltest.hpp"
#include "auth.h"
#include "ReplStructInfo.hxx"
#include "ReplCompare.hpp"

// Globals
LPWSTR gpszDomainDn = NULL;
LPWSTR gpszDns = NULL;
LPWSTR gpszBaseDn = NULL;
LPWSTR gpszGroupDn = NULL;


int __cdecl
wmain( int argc, LPWSTR argv[] ) {

    PreProcessGlobalParams(&argc, &argv);

    if (argc < 4) {
        printf( "usage: %ls <domaindn> <domaindns> <groupdn>\n", argv[0] );
        return 0;
    }

    gpszDomainDn = argv[1];
    gpszDns = argv[2];
    gpszBaseDn = argv[1];
    gpszGroupDn = argv[3];

    testMarshaler(NULL, gpszDns, (RPC_AUTH_IDENTITY_HANDLE)gpCreds, gpszBaseDn);
    testRPCSpoof(NULL, gpszDns, (RPC_AUTH_IDENTITY_HANDLE)gpCreds, gpszBaseDn);
    testXml((RPC_AUTH_IDENTITY_HANDLE)gpCreds);
    testRange(gpCreds);
    testSingle(gpCreds);
    sample((PWCHAR)gpCreds, gpszDomainDn, gpszDns, gpszBaseDn, gpszGroupDn);
    printf("\n * Testing complete *\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\ldaprepltest\ldaprepltest.hpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ldaprepltest.hpp

Abstract:

    abstract

Author:

    Will Lees (wlees) 10-Oct-2000

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _LDAPREPLTEST__
#define _LDAPREPLTEST_

// Extern
extern LPWSTR gpszDomainDn;
extern LPWSTR gpszDns;
extern LPWSTR gpszBaseDn;
extern LPWSTR gpszGroupDn;

#define whine(pred) if (!(pred)) { printf("\n\n***************Failed in file %s line %d\n\n\n", __FILE__, __LINE__); return; }

BOOL
testRPCSpoof(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPWSTR pczNC); 

BOOL
testMarshaler(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPWSTR pczNC); 
void
testXml(RPC_AUTH_IDENTITY_HANDLE AuthIdentity);

void
testRange(RPC_AUTH_IDENTITY_HANDLE AuthIdentity);

void
testSingle(RPC_AUTH_IDENTITY_HANDLE AuthIdentity);

void
sample(PWCHAR AuthIdentity,
       LPWSTR szDomain,
       LPWSTR szDns,
       LPWSTR szBase,
       LPWSTR szGroup);

#endif /* _LDAPREPLTEST.H_ */

/* end ldaprepltest.hpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\ldaprepltest\testmarshaler.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <winldap.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>


#include "ldaprepltest.hpp"
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplCompare.hpp"

#define THSTATE DWORD
#define DSNAME PWCHAR
DWORD
Repl_DeMarshalBerval(DS_REPL_STRUCT_TYPE dsReplStructType, 
                     berval * ldapValue[], OPTIONAL
                     DWORD dwNumValues,
                     puReplStructArray pReplStructArray, OPTIONAL
                     PDWORD pdwReplStructArrayLen);

extern "C" {
HANDLE ghRPC;
LPWSTR gpObjDSName;
DWORD 
draGetLDAPReplInfo(IN THSTATE * pTHS,
			  IN ATTRTYP attrId, 
			  IN DSNAME * pObjDSName,
			  IN DWORD dwBaseIndex,
			  IN PDWORD pdwNumRequested,
			  OUT ATTR * pAttr);
}

void
testAttribute(HANDLE hRPC, DS_REPL_INFO_TYPE dsReplInfoType, LPWSTR pczNC);

BOOL
testMarshaler(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPWSTR pczNC)
{
    HANDLE hRPC;
    DWORD err;

    err = DsBindWithCredW(DomainControllerName,
                          DnsDomainName,
                          (RPC_AUTH_IDENTITY_HANDLE)AuthIdentity,
                          &hRPC);
	if (err != NO_ERROR) {
            printf( "failed to bind to dc %ls dns %ls\n",
                    DomainControllerName, DnsDomainName );
        return err;
	}




    printf("\n* Testing struct marshaler - spoofing ntdsa.dll with RPC calls *\n");
    testAttribute(hRPC, DS_REPL_INFO_NEIGHBORS, pczNC);
    testAttribute(hRPC, (DS_REPL_INFO_TYPE)DS_REPL_INFO_REPSTO, pczNC);
    testAttribute(hRPC, DS_REPL_INFO_CURSORS_3_FOR_NC, pczNC);
    testAttribute(hRPC, DS_REPL_INFO_METADATA_2_FOR_OBJ, pczNC);
    testAttribute(hRPC, DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE, gpszGroupDn);
    testAttribute(hRPC, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, NULL);
    testAttribute(hRPC, DS_REPL_INFO_KCC_DSA_LINK_FAILURES, NULL);
    testAttribute(hRPC, DS_REPL_INFO_PENDING_OPS, NULL);
    testAttribute(hRPC, DS_REPL_INFO_NEIGHBORS, NULL);
    testAttribute(hRPC, (DS_REPL_INFO_TYPE)DS_REPL_INFO_REPSTO, NULL);

    return 0;
}

void
testAttribute(HANDLE hRPC, DS_REPL_INFO_TYPE dsReplInfoType, LPWSTR pczNC)
{
    ATTR attr;
    DWORD err, i, replStructArrayLen, dwBufferSize; 
    PCHAR pBuffer;
    ATTRTYP attrId = Repl_Info2AttrTyp(dsReplInfoType);
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);
    puReplStructArray pReplStructArray;
    puReplStructArray pBaseReplStructArray;

    printf("%ws\n", Repl_GetLdapCommonName(attrId, TRUE));

    // Base casls
    err = DsReplicaGetInfo2W(hRPC, dsReplInfoType, pczNC, NULL, NULL, NULL, 0, 0, (void **)&pBaseReplStructArray);
    if (err) {
        printf( "call to DsReplicaGetInfo2W, object=%ls, failed with error %d\n",
                pczNC, err );
    }
    whine(err == ERROR_SUCCESS);

    // Emulate dra functionality
    ghRPC = hRPC;
    gpObjDSName = pczNC;
    
    err = DsReplicaGetInfo2W(hRPC, dsReplInfoType, pczNC, NULL, NULL, NULL, 0, 0, (void **)&pReplStructArray);
    whine(!err);

    // See if we get the same result
    err = Repl_ArrayComp(structId, pReplStructArray, pBaseReplStructArray);
    whine(!err);

    err = Repl_StructArray2Attr(Repl_Attr2StructTyp(attrId), pReplStructArray, &dwBufferSize, NULL, &attr);
    whine(!err);
    if (dwBufferSize)
    {
        pBuffer = (PCHAR)malloc(dwBufferSize);
        err = Repl_StructArray2Attr(Repl_Attr2StructTyp(attrId), pReplStructArray, &dwBufferSize, pBuffer, &attr);
        whine(!err);
    }

    // internal attr to external berval
    berval * rBerval = NULL;
    berval ** rpBerval = NULL;
    rBerval = (berval *)malloc(attr.AttrVal.valCount * sizeof(berval));
    rpBerval = (berval **)malloc(attr.AttrVal.valCount * sizeof(berval *));
    for(i = 0; i < attr.AttrVal.valCount; i ++)
    {
        rpBerval[i] = &rBerval[i];
        rpBerval[i]->bv_len = attr.AttrVal.pAVal[i].valLen;
        rpBerval[i]->bv_val = (PCHAR)attr.AttrVal.pAVal[i].pVal;
    }

    // Emulate client demarshaling
    err = Repl_DeMarshalBerval(structId, rpBerval, attr.AttrVal.valCount, 
        NULL, &replStructArrayLen);
    pReplStructArray = (puReplStructArray)malloc(replStructArrayLen);
    err = Repl_DeMarshalBerval(structId, rpBerval, attr.AttrVal.valCount, 
        pReplStructArray, &replStructArrayLen);
    whine(!err);

    // See if we get the same result
    err = Repl_ArrayComp(structId, pReplStructArray, pBaseReplStructArray);
    whine(!err);

    puReplStruct pReplStruct;
    PWCHAR szXml;
    DWORD dwXmlLen;

    if (Repl_GetArrayLength(structId, pReplStructArray))
    {
        Repl_GetElemArray(structId, pReplStructArray, (PCHAR*)&pReplStruct);
        Repl_MarshalXml(pReplStruct, attrId, NULL, &dwXmlLen);
        szXml = (PWCHAR)malloc(dwXmlLen);
        Repl_MarshalXml(pReplStruct, attrId, szXml, &dwXmlLen);
        wprintf(L"%ws", szXml);
    }

    // See if we get the same result
    err = Repl_ArrayComp(structId, pReplStructArray, pBaseReplStructArray);
    whine(!err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\ldaprepltest\testrange.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <winldap.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>
#include <attids.h>
#define DSID(x,y)    (y)
#define FILENO       (0)
#include <debug.h>

#include "ldaprepltest.hpp"
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplCompare.hpp"

DWORD
Repl_DeMarshalBerval(DS_REPL_STRUCT_TYPE dsReplStructType, 
                     berval * ldapValue[], OPTIONAL
                     DWORD dwNumValues,
                     puReplStructArray pReplStructArray, OPTIONAL
                     PDWORD pdwReplStructArrayLen);

void
vCheckRangeResult(DWORD dwBaseIndex, 
                  DWORD dwUpperReqBound, 
                  DWORD dwUpperRetBound, 
                  DWORD dwNumRet);
void
testAttributeRange(LDAP * pLdap,
                   PWCHAR szBase, 
                   ATTRTYP attrId);
void
ldapCall(LDAP * pLdap, 
         ATTRTYP attrId, 
         PWCHAR szBase, 
         DWORD dwBaseIndex, 
         PDWORD pdwUpperIndex, 
         berval ** ppBerval);

puReplStructArray gpReplStructArray;
DWORD gdwMaxIndex;

void
testRange(RPC_AUTH_IDENTITY_HANDLE AuthIdentity)
{
    LDAP * pLdap;
    DWORD err;

    // Open
    pLdap = ldap_openW(gpszDns, LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to %ls.\n", gpszDns);
        return;
    }
    
    // Bind
    err = ldap_bind_sW(pLdap, gpszDns, (PWCHAR)AuthIdentity, LDAP_AUTH_SSPI);
    if (err != LDAP_SUCCESS)
    {
        err = LdapMapErrorToWin32(err);
    }

    
    printf("\n* Testing range support * \n");
    testAttributeRange(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS);
    testAttributeRange(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS);
    testAttributeRange(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_CURSORS);
    testAttributeRange(pLdap, gpszBaseDn, ATT_MS_DS_REPL_ATTRIBUTE_META_DATA);
    testAttributeRange(pLdap, gpszGroupDn, ATT_MS_DS_REPL_VALUE_META_DATA);

    // Range support for Root DSE attrs added Oct 2000
    testAttributeRange(pLdap, NULL, ROOT_DSE_MS_DS_REPL_PENDING_OPS);
    testAttributeRange(pLdap, NULL, ROOT_DSE_MS_DS_REPL_LINK_FAILURES);
    testAttributeRange(pLdap, NULL, ROOT_DSE_MS_DS_REPL_CONNECTION_FAILURES);
    testAttributeRange(pLdap, NULL, ROOT_DSE_MS_DS_REPL_ALL_INBOUND_NEIGHBORS);
    testAttributeRange(pLdap, NULL, ROOT_DSE_MS_DS_REPL_ALL_OUTBOUND_NEIGHBORS);
}

void
testAttributeRange(LDAP * pLdap, PWCHAR szBase, ATTRTYP attrId)
{
    berval * pBerval;
    DWORD dwUpperReqBound, dwUpperRetBound;
    DWORD dwBaseIndex;
    DWORD i;
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);

    LDAPMessage * pLDAPMsg = NULL; 
    WCHAR buf[256];
    LPCWSTR szAttribute = Repl_GetLdapCommonName(attrId, TRUE);
    swprintf(buf, L"%s;Range=0-*", szAttribute);
    LPCWSTR aAttributes[2] = { buf, NULL, };
    ldap_search_sW(pLdap, szBase, LDAP_SCOPE_BASE, L"(objectclass=*)", (LPWSTR*)aAttributes , FALSE, &pLDAPMsg);

    // Get values
    berval ** ppBerval;
    PWCHAR szRetAttribute;
    berelement * pCookie;
    szRetAttribute = ldap_first_attributeW(pLdap, pLDAPMsg, &pCookie);
    ppBerval = ldap_get_values_lenW(pLdap, pLDAPMsg, szRetAttribute);
    ldap_memfreeW(szRetAttribute);
    gdwMaxIndex = ldap_count_values_len(ppBerval) - 1;
    if (gdwMaxIndex == -1)
    {
        printf("No data set\n");
        return;
    }

    DWORD cb;
    Repl_DeMarshalBerval(structId, ppBerval, gdwMaxIndex + 1, NULL, &cb);
    gpReplStructArray = (puReplStructArray)malloc(cb);
    Repl_DeMarshalBerval(structId, ppBerval, gdwMaxIndex + 1, gpReplStructArray, &cb);

    DWORD aaTest[][2] = { 
        { 0, 0 }, { 0, gdwMaxIndex-1 }, { 0, gdwMaxIndex }, { 0, gdwMaxIndex+1 }, 
        { 1, 1 }, { 1, gdwMaxIndex-1 }, { 1, gdwMaxIndex }, { 1, gdwMaxIndex+1 }, 
        { gdwMaxIndex-1, gdwMaxIndex-1 }, { gdwMaxIndex-1, gdwMaxIndex}, { gdwMaxIndex-1, gdwMaxIndex+1 }, 
        { gdwMaxIndex, gdwMaxIndex}, { gdwMaxIndex, gdwMaxIndex+1 }, 
        { gdwMaxIndex+1, gdwMaxIndex+1 },
        { 0, -1 }, { 1, -1 }, { gdwMaxIndex-1, -1 }, { gdwMaxIndex, -1 }, { gdwMaxIndex+1, -1 },
        {0xfffffffe, 0xfffffffe }, {0xffffffff, 0xffffffff },
        // add any additional test cases here.. Did I miss any?!?
    };

    printf("** dwMaxIndex for %ws = %u **\n", aAttributes[0], gdwMaxIndex);

    for (i = 0; i < sizeof(aaTest)/2/sizeof(DWORD); i ++)
    {
        dwBaseIndex = aaTest[i][0];
        dwUpperReqBound =  aaTest[i][1];

        if (dwBaseIndex <= dwUpperReqBound)
        {
            dwUpperRetBound = dwUpperReqBound;
            ldapCall(pLdap, attrId, szBase, dwBaseIndex, &dwUpperRetBound, &pBerval);
        }
    }

    printf("\n");
}

void
ldapCall(LDAP * pLdap, ATTRTYP attrId, PWCHAR szBase, DWORD dwBaseIndex, PDWORD pdwUpperIndex, berval ** ppBerval)
{
    Assert(pdwUpperIndex);
    DWORD dwUpperRetIndex;
    DWORD dwUpperReqIndex = *pdwUpperIndex;

    LDAPMessage * pLDAPMsg = NULL; 
    LPCWSTR szAttribute = NULL;
    LPCWSTR aAttributes[2] = {
        NULL, 
        NULL,
    };

    // Construct name
    DWORD dwNumValues = 0;
    WCHAR buf[256];
    szAttribute = Repl_GetLdapCommonName(attrId, TRUE);
    if (-1 == dwUpperReqIndex)
    {
        swprintf(buf, L"%s;Range=%u-*", szAttribute, dwBaseIndex);
    }
    else 
    {
        Assert(dwBaseIndex <= dwUpperReqIndex);
        swprintf(buf, L"%s;Range=%u-%u", szAttribute, dwBaseIndex, dwUpperReqIndex);
    }
    aAttributes[0] = buf;

    // Search
    printf("Making ldap call for %ws\n", aAttributes[0]);
    ldap_search_sW(pLdap, szBase, LDAP_SCOPE_BASE, L"(objectclass=*)", (LPWSTR*)aAttributes , FALSE, &pLDAPMsg);

    // Get values
    PWCHAR szRetAttribute;
    berelement * pCookie;
    szRetAttribute = ldap_first_attributeW(pLdap, pLDAPMsg, &pCookie);
    ppBerval = ldap_get_values_lenW(pLdap, pLDAPMsg, szRetAttribute);
    ldap_memfreeW(szRetAttribute);
    dwNumValues = ldap_count_values_len(ppBerval);
    if ( (!dwNumValues) && (dwBaseIndex > gdwMaxIndex))
    {
        // Base index out of range, and no values returned
        return;
    }
    
    // Extract any range information
    if (!swscanf(wcsstr(szRetAttribute, L"ange="), L"ange=%*u-%u", &dwUpperRetIndex))
        dwUpperRetIndex = -1;
    ldap_memfreeW(szRetAttribute);
    // ldap_ber_free( pBerElem, 0 ); Documented but not supported

    vCheckRangeResult(dwBaseIndex, dwUpperReqIndex, dwUpperRetIndex, dwNumValues);


    // Emulate client demarshaling
    puReplStructArray pReplStructArray;
    DWORD bc, err;
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);
    err = Repl_DeMarshalBerval(structId, ppBerval, dwNumValues, NULL, &bc);
    if (err)
        printf("FAILEDa\n");
    pReplStructArray = (puReplStructArray)malloc(bc);
    err = Repl_DeMarshalBerval(structId, ppBerval, dwNumValues, pReplStructArray, &bc);
    if (err)
        printf("FAILEDb\n");

    // See if we get the same result
    err = Repl_ArrayComp(structId, pReplStructArray, gpReplStructArray);
    if (err)
        printf("FAILED to Compare\n");
    
}

void
vCheckRangeResult(DWORD dwBaseIndex, DWORD dwUpperReqBound, 
                  DWORD dwUpperRetBound, DWORD dwNumRet)
{
    Assert(dwBaseIndex <= dwUpperReqBound);
    if (dwUpperReqBound < gdwMaxIndex)
    {
        if (dwUpperRetBound != dwUpperReqBound ||
            dwNumRet != dwUpperReqBound - dwBaseIndex + 1)
            printf("FAILED1\n");
    }
    else
    {
        if (dwUpperRetBound != -1 ||
            dwNumRet != gdwMaxIndex - dwBaseIndex + 1)
            printf("FAILED2\n"); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\ldaprepltest\replcompare.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <attids.h> 
#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>
#define DSID(x,y)    (y)
#define FILENO       (0)
#include <debug.h>

#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplCompare.hpp"

DWORD
structComp(PCHAR pStructA,
	   	   PCHAR pStructB, 
           DWORD dwStructLen, 
           DWORD rPtrOffset[],
           DWORD rPtrLen[],
           DWORD dwNumPtrs);

DWORD
Wcslen(const wchar_t *wstr);

DWORD
Wcslen(const wchar_t *wstr)
{
    if (wstr)
        return wcslen(wstr);
    else
        return 0;
}

DWORD
Repl_ArrayComp(DS_REPL_STRUCT_TYPE structId,
                   puReplStructArray pStructArrayA,
                   puReplStructArray pStructArrayB)
{
    DWORD i;
    DWORD dwMinArraySize;
    DWORD dwElementSize;
    PCHAR rStructA, rStructB;

    Repl_GetElemArray(structId, pStructArrayB, &rStructB);
    Repl_GetElemArray(structId, pStructArrayA, &rStructA);
    dwElementSize = Repl_GetElemSize(structId);
    dwMinArraySize = min(Repl_GetArrayLength(structId, pStructArrayA),
                      Repl_GetArrayLength(structId, pStructArrayB));

    switch(structId)
    {
    case dsReplNeighbor:
        {
            DWORD i;
            UUID zUUID = { 0 };
            for (i = 0; i < pStructArrayA->neighborsw.cNumNeighbors; i ++)
            {
                // TODO: Figure out why RPC Doesn't return these values.
                pStructArrayA->neighborsw.rgNeighbor[i].uuidNamingContextObjGuid = zUUID;
                pStructArrayA->neighborsw.rgNeighbor[i].uuidSourceDsaObjGuid = zUUID;
                pStructArrayB->neighborsw.rgNeighbor[i].uuidNamingContextObjGuid = zUUID;
                pStructArrayB->neighborsw.rgNeighbor[i].uuidSourceDsaObjGuid = zUUID;
            }
        }
        break;
    }

    DWORD dwDiff = 0;
    DWORD success = 0;
    for(i = 0; i < dwMinArraySize; i ++)
    {
        if (Repl_StructComp(structId, 
                                (puReplStruct)(rStructA + (i * dwElementSize)), 
                                (puReplStruct)(rStructB + (i * dwElementSize))))
        {
            dwDiff = 1;
            break;
        }
        else
        {
            success ++;
        }
    }

    if (dwDiff & !success)
    {
        DWORD j;
        dwDiff = 0;
        for(i = 0, j = Repl_GetArrayLength(structId, pStructArrayB) - 1; i < dwMinArraySize; j--, i ++)
        {
            if (Repl_StructComp(structId, 
                                    (puReplStruct)(rStructA + (i * dwElementSize)), 
                                    (puReplStruct)(rStructB + (j * dwElementSize))))
            {
                dwDiff = 1;
                break;
            }
            else
            {
                success++;
            }
        }
    }

    if (dwDiff & !success)
    {
        DWORD a, b;
        dwDiff = 0;
        for(i = 0, 
            b = Repl_GetArrayLength(structId, pStructArrayB) - 1,
            a = Repl_GetArrayLength(structId, pStructArrayA) - 1; i < dwMinArraySize; a--, b--, i ++)
        {
            if (Repl_StructComp(structId, 
                                    (puReplStruct)(rStructA + (a * dwElementSize)), 
                                    (puReplStruct)(rStructB + (b * dwElementSize))))
            {
                dwDiff = 1;
                break;
            }
            else
            {
                success++;
            }
        }
    }

    if (dwDiff)
        return success;
    else
        return 0;
}

DWORD
Repl_StructComp(DS_REPL_STRUCT_TYPE structId,
                puReplStruct pStructA,
                puReplStruct pStructB)
{
    DWORD dwNumPtrs = Repl_GetPtrCount(structId);
    PDWORD aPtrLengths;
    DWORD ret;

    if (dwNumPtrs)
        aPtrLengths = (PDWORD)malloc(sizeof(PDWORD) * dwNumPtrs);
    
    Assert(pStructA && pStructB);
    Repl_GetPtrLengths(structId, pStructA, aPtrLengths, dwNumPtrs, NULL);

    ret = structComp((PCHAR)pStructA, (PCHAR)pStructB,
        Repl_GetElemSize(structId),
        Repl_GetPtrOffsets(structId),
        aPtrLengths,
        dwNumPtrs
        );

    if (dwNumPtrs)
        free(aPtrLengths);
    return ret;
}

DWORD
structComp(PCHAR pStructA,
	   	   PCHAR pStructB, 
           DWORD dwStructLen, 
           DWORD rPtrOffset[],
           DWORD rPtrLen[],
           DWORD dwNumPtrs)
{
	PCHAR pA = pStructA;
	PCHAR pB = pStructB;
	DWORD i, dwNPDSize;

	// Without pointer case is easy
	if (!dwNumPtrs) {
		return memcmp(pA, pB, dwStructLen);
	}

	// compare NPD before first pointer
	dwNPDSize = rPtrOffset[0] - 0;
	if (dwNPDSize && memcmp(pA, pB, dwNPDSize))
		return 1;

	for(i = 0;;)
	{
		// advance to pointer
        pA = pStructA + rPtrOffset[i];
        pB = pStructB + rPtrOffset[i];

        if (memcmp(*(PCHAR *)pA, *(PCHAR *)pB, rPtrLen[i]))
        {
//            printf("%ws != %ws", *(LPWSTR *)pA, *(LPWSTR *)pB);
            return 1;
        }

		// skip over pointer
		pA += sizeof(PCHAR);
		pB += sizeof(PCHAR);

		if (++i == dwNumPtrs)
			break;

		// compare NPD between pointers
		dwNPDSize = rPtrOffset[i] - rPtrOffset[i-1] - sizeof(PCHAR);
		if (dwNPDSize && memcmp(pA, pB, dwNPDSize))
			return 1;
	}

	// compare NPD after last pointer
	dwNPDSize = dwStructLen - (pA - pStructA);	
	if (dwNPDSize && memcmp(pA, pB, dwNPDSize))
		return 1; 

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\ldaprepltest\testrpcspoof.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <winldap.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>

#include "ldaprepltest.hpp"
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplRpcSpoofProto.hxx"
#include "ReplCompare.hpp"

void
testAttribute(HANDLE hRPC, HANDLE hDS, DS_REPL_INFO_TYPE dsReplInfoType, LPWSTR pczNC);

BOOL
testRPCSpoof(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         pczDNS,                 // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPWSTR pczNC)
{
    DWORD ret;
    HANDLE hDS, hRPC;

    printf("\n* Testing RPC Spoof library - comparing LDAP to RPC *\n");
    
#if 0
    ret = DsBindWithCredW(pczNC,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) AuthIdentity,
                          &hRPC);
    if (ERROR_SUCCESS != ret) {
        printf("DsBindWithCred to %ls failed\n", pczDNS);
        return ret;
    }
    DsUnBind( &hRPC );

    ret = _DsBindWithCredW(pczNC,
                           NULL,
                           (RPC_AUTH_IDENTITY_HANDLE) AuthIdentity,
                           &hDS); 

    if (ERROR_SUCCESS != ret) {
        printf("DsBindWithCred to %ls failed\n", pczDNS);
        return ret;
    }
    _DsUnBind( &hDS );
#endif

    ret = DsBindWithCredW(NULL,
                          pczDNS,
                          (RPC_AUTH_IDENTITY_HANDLE) AuthIdentity,
                          &hRPC);
    if (ERROR_SUCCESS != ret) {
        printf("DsBindWithCred to %ls failed\n", pczDNS);
        return ret;
    }

    ret = _DsBindWithCredW(NULL,
                           pczDNS,
                           (RPC_AUTH_IDENTITY_HANDLE) AuthIdentity,
                           &hDS);
    if (ERROR_SUCCESS != ret) {
        printf("DsBindWithCred to %ls failed\n", pczDNS);
        return ret;
    }



    testAttribute(hRPC, hDS, DS_REPL_INFO_NEIGHBORS, NULL);
    testAttribute(hRPC, hDS, (DS_REPL_INFO_TYPE)DS_REPL_INFO_REPSTO, NULL);
    testAttribute(hRPC, hDS, DS_REPL_INFO_NEIGHBORS, pczNC);
    testAttribute(hRPC, hDS, (DS_REPL_INFO_TYPE)DS_REPL_INFO_REPSTO, pczNC);
    testAttribute(hRPC, hDS, DS_REPL_INFO_CURSORS_3_FOR_NC, pczNC);
    testAttribute(hRPC, hDS, DS_REPL_INFO_METADATA_2_FOR_OBJ, pczNC);
    testAttribute(hRPC, hDS, DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE, gpszGroupDn);
    testAttribute(hRPC, hDS, DS_REPL_INFO_PENDING_OPS, NULL);
    testAttribute(hRPC, hDS, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, NULL);
    testAttribute(hRPC, hDS, DS_REPL_INFO_KCC_DSA_LINK_FAILURES, NULL);

    return TRUE;
} 

void
testAttribute(HANDLE hRPC, HANDLE hDS, DS_REPL_INFO_TYPE dsReplInfoType, LPWSTR pczNC)
{
    puReplStructArray pBaseReplStructArray;
    puReplStructArray pReplStructArray;
    DWORD err;
    
    err = DsReplicaGetInfo2W(hRPC, dsReplInfoType, pczNC, NULL, NULL, NULL, 0, 0, (void **)&pBaseReplStructArray);
    if (err)
    {
        DWORD ourErr = _DsReplicaGetInfoW(hDS, dsReplInfoType, pczNC, NULL, (void **)&pReplStructArray);
        if (err != ourErr) {
            printf("   ERROR Codes for _DsReplicaGetInfo don't match\n");
        }
        return;
    }
    whine(!err);

    err = _DsReplicaGetInfoW(hDS, dsReplInfoType, pczNC, NULL, (void **)&pReplStructArray);
    whine(!err);

    ATTRTYP attrId = Repl_Info2AttrTyp(dsReplInfoType);
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);
    err = Repl_ArrayComp(structId, pBaseReplStructArray, pReplStructArray);
    if (err)
        printf("FAILED\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\replctrl\replctrl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    replctrl.h

Abstract:

API for replctrl.c

Author:

    Will Lees (wlees) 14-Nov-2000

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _REPLCTRL_
#define _REPLCTRL_

// Move this to ntdsapi.h someday
DWORD
DsMakeReplCookieForDestW(
    DS_REPL_NEIGHBORW *pNeighbor,
    DS_REPL_CURSORS * pCursors,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    );
DWORD
DsFreeReplCookie(
    PBYTE pCookie
    );
DWORD
DsGetSourceChangesW(
    LDAP *m_pLdap,
    LPWSTR m_pSearchBase,
    LPWSTR pszSourceFilter,
    DWORD dwReplFlags,
    PBYTE pCookieCurr,
    DWORD dwCookieLenCurr,
    LDAPMessage **ppSearchResult,
    BOOL *pfMoreData,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    PWCHAR *ppAttListArray
    );

#endif /* _REPLCTRL_ */

/* end replctrl.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\ldaprepltest\testxml.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <winldap.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>
#include <attids.h> 

#include "ldaprepltest.hpp"
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplRpcSpoofProto.hxx"
#include "ReplCompare.hpp"

void
testXmlAttribute(LDAP * pLdap, PWCHAR pzBase, ATTRTYP attrId);

void
testXml(RPC_AUTH_IDENTITY_HANDLE AuthIdentity)
{
    LDAP * pLdap;
    DWORD ret;

    // Open
    pLdap = ldap_openW(gpszDns, LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to %ls.\n", gpszDns);
        return;
    }
    
    // Bind
    ret = ldap_bind_sW(pLdap, gpszDns, (PWCHAR)AuthIdentity, LDAP_AUTH_SSPI);
    if (ret != LDAP_SUCCESS)
    {
        ret = LdapMapErrorToWin32(ret);
    }
    
    printf("\n* Testing XML marshaler *\n");
    testXmlAttribute(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS);
    testXmlAttribute(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS);
    testXmlAttribute(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_CURSORS);
    testXmlAttribute(pLdap, gpszBaseDn, ATT_MS_DS_REPL_ATTRIBUTE_META_DATA);
    testXmlAttribute(pLdap, gpszGroupDn, ATT_MS_DS_REPL_VALUE_META_DATA);
    testXmlAttribute(pLdap, NULL, ROOT_DSE_MS_DS_REPL_PENDING_OPS);
    testXmlAttribute(pLdap, NULL, ROOT_DSE_MS_DS_REPL_LINK_FAILURES);
    testXmlAttribute(pLdap, NULL, ROOT_DSE_MS_DS_REPL_CONNECTION_FAILURES);
    testXmlAttribute(pLdap, NULL, ROOT_DSE_MS_DS_REPL_ALL_INBOUND_NEIGHBORS);
    testXmlAttribute(pLdap, NULL, ROOT_DSE_MS_DS_REPL_ALL_OUTBOUND_NEIGHBORS);

}

void
testXmlAttribute(LDAP * pLdap, PWCHAR pzBase, ATTRTYP attrId)
{
    LDAPMessage * pLDAPMsg;   
    PWCHAR szFilter = L"(objectclass=*)";
    PWCHAR attrs[2] = { NULL, NULL };
    LPCWSTR szAttribute; 
    DWORD err, dwNumValues;
    PWCHAR * ppValue;

    szAttribute = Repl_GetLdapCommonName(attrId, FALSE);
    
    attrs[0] = (LPWSTR)szAttribute;
    err = ldap_search_sW(pLdap, pzBase, LDAP_SCOPE_BASE, szFilter, attrs, FALSE, &pLDAPMsg);

    // Get values
    ppValue = ldap_get_valuesW(pLdap, pLDAPMsg, (LPWSTR)szAttribute);
    dwNumValues = ldap_count_valuesW(ppValue);
    if (dwNumValues == -1)
    {
        printf("FAILED\n");
        return;
    }

    printf("%d XML strs = \"%ws\"\n", dwNumValues, dwNumValues ? ppValue[0] : L"(null)");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\replctrl\replctrl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    replctrl.c

Abstract:

    Callable api to the ldap replication control

    Use the dirsync replication control to get changes from a
    source and nc given a usn and utd

    This code derived from
    \nt\private\dirsync\dsserver\adread\read.cpp:
        GetMoreDataFromDS()

    The source is essentially stateless for change positioning. The caller
    (destination) records where he was last.  A change position is represented
    by a opaque data structure called a cookie.

    The is no support at the moment to explode and construct cookies, so that
    one could build an arbitrary one.  Instead, you may either duplicate a cookie
    from a reps-from, or you can start with no cookie, and iterate sequentially 
    through all the changes, and then proceeding incrementally from there.

Author:

    Will Lees (wlees) 30-Apr-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include <fileno.h>
#include <debug.h>
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <ismapi.h>
#include <schedule.h>
#include <ntldap.h>
#include <winber.h>

#define FILENO FILENO_TEST_REPLCTRL

#define CHK_LD_STATUS( x )                        \
{                                                 \
    if ( LDAP_SUCCESS != (x) )                    \
    {                                             \
        err = LdapMapErrorToWin32(x);             \
        printf( "[%s, %d] LDAP error %d (%ls) win32 %d.\n", \
                __FILE__,                         \
                __LINE__,                         \
                (x),                              \
                ldap_err2stringW( x ),            \
                err );                            \
       goto error;                                \
    }                                             \
}

#define MemAlloc( x ) malloc( x )
#define MemFree( x ) free( x )

#define BAIL() \
printf( "Fatal error at line %d, file %s\n", __LINE__, __FILE__ ); \
goto error;
#define BAIL_ON_NULL(x) if (!(x)) { \
printf( "%s had unexpected null value at line %d, file %s\n", #x,__LINE__, __FILE__ ); \
err = ERROR_NOT_ENOUGH_MEMORY; \
goto error; \
}
#define BAIL_ON_FAILURE(x) if (x) { \
printf( "%s had unexpected failure value at line %d, file %s\n", #x,__LINE__, __FILE__ ); \
goto error; \
}
#define ERR(parenarglist) \
printf parenarglist; \
goto error;

// Read 100 objects at a time
#define DIRSYNC_SIZE_LIMIT 100
// Maximum attrs to return
// sic
#define MAX_ATTIBUTES        1048576

// The following is from  dsamain/ldap/const.hxx

//
// version of the repl dirsync control cookie structure
//
// structure for v1
//   REPL VERSION
//   vector To
//   UTD Vector
//
// structure for v2
//   REPL VERSION
//   cb UTD vector
//   vectorTo
//   invocation ID
//   UTD Vector
//
// structure for v3
//   REPL_SIGNATURE
//   REPL_VERSION
//   TIMESTAMP
//   RESERVED
//   cb UTD vector
//   vectorTo
//   invocation ID
//   UTD Vector
//

#define REPL_VERSION        3
#define REPL_SIGNATURE      'SDSM'
#define LDAP_VALID_DIRSYNC_CONTROL_FLAGS    (DRS_GET_ANC)

//
// minimum size of a repl control cookie
//

#define MIN_REPL_CONTROL_BLOB_LENGTH    (sizeof(DWORD) + sizeof(DWORD) + sizeof(FILETIME) + \
                                        sizeof(LARGE_INTEGER) + sizeof(DWORD) + \
                                        sizeof(USN_VECTOR) + sizeof(UUID))

#define ASCII_TO_INT(x)    ((x)<='9' ? (x)-'0' : ((x) <='F' ? (x)-'A' + 10 : (x)-'a' + 10))
#define ASCII_TO_INTW(x)    ((x)<=L'9' ? (x)-L'0' : ((x) <=L'F' ? (x)-L'A' + 10 : (x)-L'a' + 10))

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Mon May 03 15:25:45 1999 */

DWORD
BerEncodeReplicationControl(
    DWORD dwReplFlags,
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal
    );

DWORD
BerDecodeReplicationCookie(
    LDAP *m_pLdap,
    LDAPMessage *m_pSearchResult,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    BOOL *pfMoreData
    );

void
displayResults(
    LDAP *pLdap,
    LDAPMessage *pSearchResult,
    BOOL fVerbose
    );

void
dumpCookie(
    PBYTE pCookieNext,
    DWORD dwCookieLenNext
    );

DWORD
packCookie(
    USN_VECTOR *pUsnVec,
    GUID *puuidInvocationId,
    UPTODATE_VECTOR *pUtdvecV1,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    );

/* End Forward */


DWORD
DsMakeReplCookieForDestW(
    DS_REPL_NEIGHBORW *pNeighbor,
    DS_REPL_CURSORS * pCursors,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    )

/*++

Routine Description:

A Cookie represents a position in the changes stream for a particular source.

Build a cookie from neighbor and cursor information representing the
position of a destination with respect to some source

Cookie is output on success, otherwise not returned.

Arguments:

    pNeighbor - 
    pCursors - 
    ppCookieNext - 
    pdwCookieLenNext - 

Return Value:

    DWORD - 

--*/

{
    DWORD err, i;
    USN_VECTOR usnVec;
    UPTODATE_VECTOR *pUTD = NULL;
    DWORD cbUTD = 0;

    // Initialize out parameters
    *ppCookieNext = NULL;
    *pdwCookieLenNext = 0;

    // Construct USN VECTOR
    ZeroMemory( &usnVec, sizeof( USN_VECTOR ) );
    usnVec.usnHighObjUpdate = pNeighbor->usnLastObjChangeSynced;
    usnVec.usnHighPropUpdate = pNeighbor->usnAttributeFilter;

    // Construct UPTODATE VECTOR
    cbUTD = UpToDateVecV1SizeFromLen( pCursors->cNumCursors );
    pUTD = malloc( cbUTD );
    if (pUTD == NULL) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    ZeroMemory( pUTD, cbUTD );
    pUTD->dwVersion = 1;
    pUTD->V1.cNumCursors = pCursors->cNumCursors;
    for( i = 0; i < pCursors->cNumCursors; i++ ) {
        pUTD->V1.rgCursors[i].uuidDsa = pCursors->rgCursor[i].uuidSourceDsaInvocationID;
        pUTD->V1.rgCursors[i].usnHighPropUpdate = pCursors->rgCursor[i].usnAttributeFilter;
    }

    // Build the initial cookie
    err = packCookie(
        &usnVec,
        &(pNeighbor->uuidSourceDsaInvocationID),
        pUTD,
        ppCookieNext,
        pdwCookieLenNext
        );
    if (err != ERROR_SUCCESS) {
        goto error;
    }

    err = ERROR_SUCCESS;
error:

    if (pUTD) {
        free(pUTD);
    }

    return err;
} /* DsMakeReplCookieForDest */


DWORD
DsFreeReplCookie(
    PBYTE pCookie
    )

/*++

Routine Description:

Free a cookie returned by DsMakeReplCookie

Arguments:

    pCookie - pointer to cookie

Return Value:

    DWORD - errors if cookie not valid

--*/

{
    DWORD dwSignature;

    if (pCookie == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the Signature.
    //
    dwSignature = *((PDWORD)pCookie);

    if (dwSignature != REPL_SIGNATURE) {
        return ERROR_INVALID_PARAMETER;
    }

    MemFree( pCookie );

    return ERROR_SUCCESS;
} /* DsFreeReplCookie */


DWORD
DsGetSourceChangesW(
    LDAP *m_pLdap,
    LPWSTR m_pSearchBase,
    LPWSTR pszSourceFilter,
    DWORD dwReplFlags,
    PBYTE pCookieCurr,
    DWORD dwCookieLenCurr,
    LDAPMessage **ppSearchResult,
    BOOL *pfMoreData,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    PWCHAR *ppAttListArray
    )

/*++

Return a packet of changes given position information in "current cookie".

If successful, an updated position will be returned in "next cookie".

Cookies are self describing and position independent: they may be saved to long
term storage and retrieved later as a kind of bookmark.  Cookies are specific to
the source server and naming context they were created for.

The caller is responsible for deallocating the cookies himself.  The "next
cookie" in particular must be deallocated using DsFreeReplCookie.  The current
cookie may come from a file or other long term storage.

The changes are returned as an LDAP message of entries, attributes and values.
Secret data will have been supressed.

Arguments:

The out parameters are initialized to null at the start.

    m_pLdap - ldap handle to source server.
    m_pSearchBase - The dn of the nc head to search
    pszSourceFilter - Ldap search filter, if any
    dwReplFlags - Replication flags, DRS_GET_ANC, etc
    pCookieCurr - null, or cookie previously returned by DsGetSourceChanges.
          The cookie must have come from a call with the same source server and
          same naming context.
    dwCookieLenCurr - cookie length, or zero
    ppSearchResult - pointer to pointer, to receive ldap message
    pfMoreData - Indication whether there is more data and this call should be made
        again with the updated cookie.  This is independent of whether the current
        call returned data.
    ppCookieNext - Newly allocated cookie for the updated position
    pdwCookieLenNext - Length of new cookie
    ppAttListArray - A Null terminated list of pointers to attributes to return

The out parameters are not allocated on error.

Even if there are no changes (entries in result are zero), the cookie may
have been updated with the latest positioning information.

Return Value:

    DWORD - 

--*/

{
    PBERVAL pBerVal = NULL;
    LDAPControlW replControl;
    LDAPControlW extDNControl;
    PLDAPControlW controlArray[3];
    int lderr, err;
    LDAP_TIMEVAL TimeVal;

    // Initialize out parameters
    *ppSearchResult = NULL;
    *pfMoreData = FALSE;
    *ppCookieNext = NULL;
    *pdwCookieLenNext = 0;

    //
    // The replication control has the USN that specifies where to
    // continue from. This can be treated as opaque information by us.
    //

    err = BerEncodeReplicationControl(dwReplFlags,
                                      pCookieCurr, dwCookieLenCurr,
                                      &pBerVal);
    BAIL_ON_FAILURE( err );

    replControl.ldctl_oid = LDAP_SERVER_DIRSYNC_OID_W;
    replControl.ldctl_iscritical = TRUE;
    replControl.ldctl_value.bv_len = pBerVal->bv_len;
    replControl.ldctl_value.bv_val = (PCHAR)(pBerVal->bv_val);
    extDNControl.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    extDNControl.ldctl_iscritical = TRUE;
    extDNControl.ldctl_value.bv_len = 0;
    extDNControl.ldctl_value.bv_val = NULL;

    controlArray[0] = &replControl;
    controlArray[1] = &extDNControl;
    controlArray[2] = NULL;

    //
    // Adding in timeout so that we can recover if the server do not respond
    //
    TimeVal.tv_usec = 0;
    TimeVal.tv_sec = LDAP_TIMEOUT;

//    dumpCookie( *ppCookieNext, *pdwCookieLenNext );

    lderr = ldap_search_ext_sW(m_pLdap,
                               m_pSearchBase,
                               LDAP_SCOPE_SUBTREE, // m_pSessionData->SourceScope
                               pszSourceFilter,
                               ppAttListArray,
                               0,
                               (PLDAPControlW *) &controlArray,
                               NULL,
                               &TimeVal,
                               DIRSYNC_SIZE_LIMIT,
                               ppSearchResult);

    CHK_LD_STATUS( lderr );

    if ( (*ppSearchResult) == NULL )
    {
        // Let caller know there is no search result or cookie
        err = ERROR_DS_PROTOCOL_ERROR;
        goto error;
    }

    //
    // Save the returned cookie value
    //

    err = BerDecodeReplicationCookie(
        m_pLdap,
        *ppSearchResult,
        ppCookieNext,
        pdwCookieLenNext,
        pfMoreData
        );
    BAIL_ON_FAILURE( err );

    err = ERROR_SUCCESS;

error:

    // On error, return the same cookie that came in

    // Release results on error
    if ( (err != ERROR_SUCCESS) && (*ppSearchResult) )
    {
        ldap_msgfree(*ppSearchResult);
        *ppSearchResult = NULL;
    }

    if (pBerVal)
        ber_bvfree(pBerVal);

    return err;

} /* DsGetSourceChanges */


DWORD
BerEncodeReplicationControl(
    DWORD dwReplFlags,
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal
    )

/*++

Routine Description:

    This encodes the replication cookie into a BERVAL that can be put in
    an LDAP control.

Arguments:

    dwReplFlags - Replication flags
    pCookie - Pointer to replication cookie
    dwLen - Length of cookie
    ppBerVal - Pointer that received the BERVAL structure. Called needs to
               free this using ber_bvfree().

Return Value:

    S_OK on success, error code otherwise

--*/

{
    DWORD err = ERROR_INVALID_PARAMETER;
    BerElement *pBer = NULL;

    pBer = ber_alloc_t(LBER_USE_DER);
    BAIL_ON_NULL(pBer);

    //
    // flag - set to zero, so order of parent & child objects is not important
    //

    if (ber_printf(pBer, "{iio}", dwReplFlags, MAX_ATTIBUTES, pCookie, dwLen) == -1)
    {
        err = ERROR_INTERNAL_ERROR;
        ERR(("Error in ber_printf\n"));
        BAIL();
    }

    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (ber_flatten(pBer, ppBerVal) != 0)
    {
        err = ERROR_INTERNAL_ERROR;
        ERR(("Error in ber_flatten\n"));
        BAIL();
    }

    err = ERROR_SUCCESS;

error:
    if (pBer)
    {
        ber_free(pBer,1);
    }

    return err;

}



DWORD
BerDecodeReplicationCookie(
    LDAP *m_pLdap,
    LDAPMessage *m_pSearchResult,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    BOOL *pfMoreData
    )

/*++

Routine Description:

    This saves the replication cookie that came back from the server so that
    it can be used for the next call

Arguments:

    m_pLdap - 
    m_pSearchResult - 
    ppCookieNext - 
    pdwCookieLenNext - 
    pfMoreData - 

Return Value:

    DWORD - 

--*/

{
    PLDAPControlW *ppServerControl = NULL;
    BERVAL berVal;
    DWORD err = ERROR_INVALID_PARAMETER;
    ULONG lderr;
    BerElement *pBer = NULL;
    PBERVAL pbv = NULL;
    DWORD size;
    DWORD i;

    lderr = ldap_parse_resultW(m_pLdap,
                               m_pSearchResult,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               &ppServerControl,
                               FALSE);
    CHK_LD_STATUS( lderr );

    //
    // Find the replication control
    //

    i = 0;
    while (ppServerControl[i] &&
           wcscmp(ppServerControl[i]->ldctl_oid,LDAP_SERVER_DIRSYNC_OID_W) != 0)
    {
        i++;
    }

    if (!ppServerControl[i])
    {
        err = ERROR_NOT_FOUND;
        ERR(("Did not get a replication server control back\n"));
        BAIL();
    }

    berVal.bv_len = ppServerControl[i]->ldctl_value.bv_len;
    berVal.bv_val = ppServerControl[i]->ldctl_value.bv_val;
    pBer = ber_init(&berVal);

    ber_scanf(pBer, "{iiO}", pfMoreData, &size, &pbv);

    *pdwCookieLenNext = pbv->bv_len;
    *ppCookieNext = (PBYTE)MemAlloc(pbv->bv_len);
    BAIL_ON_NULL(*ppCookieNext);

    memcpy(*ppCookieNext, pbv->bv_val, *pdwCookieLenNext);

    err = ERROR_SUCCESS;

error:
    if (pbv)
        ber_bvfree(pbv);
    if (pBer)
        ber_free(pBer, 1);
    if (ppServerControl)
        ldap_controls_freeW(ppServerControl);

    return err;
} /* BerDecodeReplicationCookie */


#if DBG


void
dumpCookie(
    PBYTE pCookieNext,
    DWORD dwCookieLenNext
    )

/*++

Routine Description:

    //
    // If the cookie is available, this debug code will dump out the cookie
    // value to the debugger
    //

Arguments:

    None

Return Value:

    None

--*/

{
    PUCHAR p;
    DWORD dwVersion, dwSignature;
    DWORD cbVecSize;
    USN_VECTOR usnVec;

    if (!pCookieNext)  {
        printf( "Cookie: null\n" );
    }

    p = pCookieNext;

    //
    // Get the Signature.
    //
    dwSignature = *((PDWORD)p);
    p += sizeof(DWORD);

    //
    // Get the Version.
    //
    dwVersion = *((PDWORD)p);
    p += sizeof(DWORD);

    // Skip filetime
    p += sizeof(FILETIME);

    // Skip reserved
    p += sizeof(LARGE_INTEGER);

    //
    // Get the size of the up to date vector
    //
    cbVecSize = *((PDWORD)p);
    p += sizeof(DWORD);

    // Usnvec
    memcpy(&usnVec,p,sizeof(USN_VECTOR));

    // todo: invocation uuid
    // todo: uptodatevec

    printf("Cookie: ver %d,\nHighObjUpdate: %I64d,\nHighPropUpdate: %I64d\n",
           dwVersion, usnVec.usnHighObjUpdate, usnVec.usnHighPropUpdate);
}
#endif


DWORD
packCookie(
    USN_VECTOR *pUsnVec,
    GUID *puuidInvocationId,
    UPTODATE_VECTOR *pUtdvecV1,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    )

/*++

Routine Description:

The following logic is taken from
    dsamain\ldap\ldapconv.cxx:LDAP_PackReplControl

Arguments:

    pUsnVec - 
    puuidInvocationId - 
    pUtdvecV1 - 
    ppCookieNext - 
    pdwCookieLenNext - 

Return Value:

    DWORD - 

--*/

{
    DWORD cbCookie = MIN_REPL_CONTROL_BLOB_LENGTH;
    DWORD cbVecSize = 0;
    PBYTE p, pbCookie = NULL;

    // todo: deal with not having a utd

    Assert( pUtdvecV1 != NULL );
    Assert(IS_VALID_UPTODATE_VECTOR(pUtdvecV1));

    if (pUtdvecV1->V1.cNumCursors > 0) {      
        cbVecSize = UpToDateVecV1Size(pUtdvecV1);
        cbCookie += cbVecSize;
    }

    pbCookie = MemAlloc( cbCookie );
    if (pbCookie == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( pbCookie, cbCookie );

    p = pbCookie;

    //
    // Pack the signature
    //

    *((PDWORD)p) = REPL_SIGNATURE;
    p += sizeof(DWORD);

    //
    // Pack the Version. 
    //

    *((PDWORD)p) = REPL_VERSION;    
    p += sizeof(DWORD);

    //
    // Set the current time
    //

    GetSystemTimeAsFileTime((PFILETIME)p);
    p += sizeof(FILETIME);

    //
    // reserved for now
    //

    p += sizeof(LARGE_INTEGER);

    //
    // Pack the size of the up to date vector
    //

    *((PDWORD)p) = cbVecSize;
    p += sizeof(DWORD);

    //
    // Copy the usnvecTo. 
    //

    CopyMemory( p,pUsnVec, sizeof(USN_VECTOR));
    p += sizeof(USN_VECTOR);

    //
    // Copy the invocation UUID
    //

    CopyMemory( p, puuidInvocationId, sizeof(UUID));

    p += sizeof(UUID);

    //
    // Copy the UPTODATE_VECTOR if it exists
    //

    if( cbVecSize > 0 ) {
        CopyMemory( p,
                    pUtdvecV1, 
                    cbVecSize);
    }

    *pdwCookieLenNext = cbCookie;
    *ppCookieNext = pbCookie;

    return ERROR_SUCCESS;
} /* packCookie */

/* end dirsync.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\replctrl\replctrltest.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    test.c

Abstract:

    LDAP Replication Control Test

    This test works at the leading edge of the replication change stream.
    First it reads all changes from usn 0 up to the present. It records a
    cookie marking this point in the stream. Then it creates
    a container, two child objects in the container, and then makes some
    modifications. When we ask for changes since the cookie, we know exactly
    what we should be getting.

Author:

    Will Lees (wlees) 14-Nov-2000

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <windows.h>
#include <ntldap.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <aclapi.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>
#include <mdglobal.h>

#include "replctrl.h"

#define CONTAINER_RDN_W L"ou=replctrltest,"
#define CONTACT1_RDN_W L"cn=contact1,"
#define CONTACT2_RDN_W L"cn=contact2,"

/* External */

/* Static */

// Structures to describe object attributes
// These are at module level so that object creation and object
// verification can take advantage of them.

// objectClass: organizationUnit
LPWSTR rgpszValues1[2] = { L"organizationalUnit", NULL };
LDAPModW modAttr1 = { LDAP_MOD_ADD, L"objectClass", rgpszValues1 };
LDAPMod *rgpmodAttrs1[2] = { &modAttr1, NULL };

// objectClass: contact
// notes: this is some notes
// sn: Lees
// initials: B
// givenName: William
LPWSTR rgpszValues2[2] = { L"contact", NULL };
LDAPModW modAttr2 = { LDAP_MOD_ADD, L"objectClass", rgpszValues2 };
LPWSTR rgpszValues2a[2] = { L"this is some notes", NULL };
LDAPModW modAttr2a = { LDAP_MOD_ADD, L"notes", rgpszValues2a };
LPWSTR rgpszValues2b[2] = { L"Lees", NULL };
LDAPModW modAttr2b = { LDAP_MOD_ADD, L"sn", rgpszValues2b };
LPWSTR rgpszValues2c[2] = { L"B", NULL };
LDAPModW modAttr2c = { LDAP_MOD_ADD, L"initials", rgpszValues2c };
LPWSTR rgpszValues2d[2] = { L"William", NULL };
LDAPModW modAttr2d = { LDAP_MOD_ADD, L"givenName", rgpszValues2d };
LDAPMod *rgpmodAttrs2[6] = {
    &modAttr2,
    &modAttr2a,
    &modAttr2b,
    &modAttr2c,
    &modAttr2d,
    NULL };

// objectClass: contact
// notes: other notes
// sn: Parham
// initials: ?
// givenName: Jeffrey
LPWSTR rgpszValues4[2] = { L"contact", NULL };
LDAPModW modAttr4 = { LDAP_MOD_ADD, L"objectClass", rgpszValues4 };
LPWSTR rgpszValues4a[2] = { L"other notes", NULL };
LDAPModW modAttr4a = { LDAP_MOD_ADD, L"notes", rgpszValues4a };
LPWSTR rgpszValues4b[2] = { L"Parham", NULL };
LDAPModW modAttr4b = { LDAP_MOD_ADD, L"sn", rgpszValues4b };
LPWSTR rgpszValues4c[2] = { L"?", NULL };
LDAPModW modAttr4c = { LDAP_MOD_ADD, L"initials", rgpszValues4c };
LPWSTR rgpszValues4d[2] = { L"Jeffrey", NULL };
LDAPModW modAttr4d = { LDAP_MOD_ADD, L"givenName", rgpszValues4d };
LDAPMod *rgpmodAttrs4[6] = {
    &modAttr4,
    &modAttr4a,
    &modAttr4b,
    &modAttr4c,
    &modAttr4d,
    NULL };

// description: this is the description
LPWSTR rgpszValues3[2] = { L"this is the description", NULL };
LDAPModW modAttr3 = { LDAP_MOD_ADD, L"description", rgpszValues3 };

// managedBy: <dn filled in at runtime>
// This is a linked attribute by the way, which is critical for some
// of these tests.  It was difficult to find a linked attribute that would
// go on a vanilla container. Usually these are pretty specialized.
WCHAR szDn5a[MAX_PATH];
LPWSTR rgpszValues5[2] = { szDn5a, NULL };
LDAPModW modAttr5 = { LDAP_MOD_ADD, L"managedby", rgpszValues5 };
LDAPMod *rgpmodAttrs5[3] = {
    &modAttr3, &modAttr5, NULL };


/* Forward */
/* End Forward */


#if 0
// OBSOLETE method of changing a security descriptor
// Since I went to all the trouble of reversing engineering how to
// do this, I'm not about to delete it!
DWORD
protectObjectsDsVersion(
    LDAP *pLdap,
    LPWSTR pszNC
    )

/*++

Routine Description:

   This is the old way of changing a security descriptor.

Arguments:

    pLdap - 
    pszNC - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    ULONG ulLdapError = LDAP_SUCCESS;
    WCHAR szDn[MAX_PATH];
    LDAPMessage *pResults = NULL;
    LPWSTR rgpszAttrList[2] = { L"nTSecurityDescriptor", NULL };
    LDAPControlW ctrlSecurity;
    LDAPControlW *rgpctrlServer[2];
    BYTE berValue[2*sizeof(ULONG)];
    SECURITY_INFORMATION seInfo = DACL_SECURITY_INFORMATION
        | GROUP_SECURITY_INFORMATION
        | OWNER_SECURITY_INFORMATION;
    struct berval **ppbvValues = NULL;

    struct berval bvValue;
    struct berval *rgpbvValues[2] = { &bvValue, NULL };
    LDAPModW modAttr = { LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,
                         L"nTSecurityDescriptor",
                         (LPWSTR *) rgpbvValues };
    LDAPMod *rgpmodAttrs[2] = { &modAttr, NULL };

    // initialize the ber val
    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE) (seInfo & 0xF);

    wcscpy( szDn, CONTACT1_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ctrlSecurity.ldctl_oid = LDAP_SERVER_SD_FLAGS_OID_W;
    ctrlSecurity.ldctl_iscritical = TRUE;
    ctrlSecurity.ldctl_value.bv_len = 5;
    ctrlSecurity.ldctl_value.bv_val = (PCHAR)berValue;

    rgpctrlServer[0] = &ctrlSecurity;
    rgpctrlServer[1] = NULL;

    ulLdapError = ldap_search_ext_s(pLdap,  // handle
                                    szDn,   // base
                                    LDAP_SCOPE_BASE, // scope
                                    L"(objectClass=*)", // filter
                                    rgpszAttrList, // attrs
                                    0, // attrsonly
                                    rgpctrlServer, // server controls
                                    NULL, // client controls
                                    NULL, // timeout
                                    0, // sizelimit
                                    &pResults);
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_search", dwWin32Error );
        goto cleanup;
    }
    if (pResults == NULL) {
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    ppbvValues = ldap_get_values_len( pLdap, pResults, rgpszAttrList[0] );
    if (ppbvValues == NULL) {
        printf( "Expected attribute %ls is missing from entry %ls\n",
                rgpszAttrList[0],
                szDn);
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

    // Update the security descriptor

    bvValue.bv_len = (*ppbvValues)->bv_len;
    bvValue.bv_val = (*ppbvValues)->bv_val;

    // Write it back

    ulLdapError = ldap_modify_sW( pLdap, szDn, rgpmodAttrs );
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_modify", dwWin32Error );
        goto cleanup;
    }

    printf( "\tprotected %ls.\n", szDn );

cleanup:
    if (pResults) {
        ldap_msgfree(pResults);
    }
    if ( ppbvValues ) {
        ldap_value_free_len(ppbvValues);
    }

    return dwWin32Error;

} /* protectObjectsDsVersion */
#endif


DWORD
protectSingleObject(
    LPWSTR pszDn
    )

/*++

Routine Description:

    Revoke authenticated user access to an object

Arguments:

    pszDn - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    PACL pOldDacl, pNewDacl = NULL;
    PBYTE pSD = NULL;
    EXPLICIT_ACCESS ea;

   dwWin32Error = GetNamedSecurityInfoW( pszDn,
                                         SE_DS_OBJECT_ALL,
                                         DACL_SECURITY_INFORMATION,
                                         NULL, // psidOwner
                                         NULL, // psidGroup
                                         &pOldDacl, // pDacl
                                         NULL, // pSacl
                                         &pSD );
    if (dwWin32Error) {
        printf( "Call %s failed with win32 error %d\n", "GetNamedSecurityInfo(DS_OBJECT)", dwWin32Error );
        goto cleanup;
    }

    // Revoke access to domain authenticated users
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessMode = REVOKE_ACCESS;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea.Trustee.ptstrName = "AUTHENTICATED USERS";

    dwWin32Error = SetEntriesInAcl( 1, &ea, pOldDacl, &pNewDacl );
    if (dwWin32Error) {
        printf( "Call %s failed with win32 error %d\n", "SetEntriesInAcl", dwWin32Error );
        goto cleanup;
    }

    dwWin32Error = SetNamedSecurityInfoW( pszDn,
                                         SE_DS_OBJECT_ALL,
                                         DACL_SECURITY_INFORMATION,
                                         NULL, // psidOwner
                                         NULL, // psidGroup
                                         pNewDacl, // pDacl
                                         NULL // pSacl
                                         );
    if (dwWin32Error) {
        printf( "Call %s failed with win32 error %d\n", "SetNamedSecurityInfo(DS_OBJECT)", dwWin32Error );
        goto cleanup;
    }

    printf( "\tprotected %ls.\n", pszDn );

cleanup:
    if (pSD) {
        LocalFree( pSD );
    }
    if (pNewDacl) {
        LocalFree( pNewDacl );
    }

    return dwWin32Error;
} /* protectSingleObject */


DWORD
protectObjects(
    LPWSTR pszNC
    )

/*++

Routine Description:

    Protect some objects against the user

Arguments:

    pszNC - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    WCHAR szDn[MAX_PATH];

    wcscpy( szDn, CONTACT1_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    dwWin32Error = protectSingleObject( szDn );
    if (dwWin32Error) {
        goto cleanup;
    }

    wcscpy( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    dwWin32Error = protectSingleObject( szDn );
    if (dwWin32Error) {
        goto cleanup;
    }

cleanup:
    return dwWin32Error;

} /* protectObjects */

DWORD
getForestVersion(
    LDAP *pLdap,
    DWORD *pdwForestVersion
    )

/*++

Routine Description:

    Read the forest version attribute

Arguments:

    pLdap - 
    pdwForestVersion - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    ULONG ulLdapError = LDAP_SUCCESS;
    LDAPMessage *pRootResults = NULL;
    LDAPMessage *pPartResults = NULL;
    LPWSTR *ppszConfigNC = NULL;
    LPWSTR *ppszValues = NULL;
    WCHAR pszPartitionsDn[MAX_PATH];
    LPWSTR rgpszAttrList[2] = { L"msds-behavior-version", NULL };

    // Read config nc from RootDSE
    ulLdapError = ldap_search_s(pLdap, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)", NULL,
                          0, &pRootResults);
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_search", dwWin32Error );
        goto cleanup;
    }
    if (pRootResults == NULL) {
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    ppszConfigNC = ldap_get_valuesW(pLdap, pRootResults,
                                    L"configurationNamingContext");
    if ( (ppszConfigNC == NULL) ||
         (*ppszConfigNC == NULL) ||
         (wcslen(*ppszConfigNC) == 0) ) {
        printf( "Expected attribute %ls is missing from entry %ls\n",
                L"configurationNamingContext",
                L"(root)");
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

    // Form partitions container dn

    wcscpy( pszPartitionsDn, L"cn=partitions," );
    wcscat( pszPartitionsDn, *ppszConfigNC );

    // Read behavior version
    ulLdapError = ldap_search_s(pLdap, pszPartitionsDn, LDAP_SCOPE_BASE, L"(objectClass=*)",
                                rgpszAttrList, 0, &pPartResults);
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_search", dwWin32Error );
        goto cleanup;
    }
    if (pPartResults == NULL) {
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    ppszValues = ldap_get_valuesW(pLdap, pPartResults,
                                    L"msds-behavior-version");
    if ( (ppszValues == NULL) ||
         (*ppszValues == NULL) ||
         (wcslen(*ppszValues) == 0) ) {
        printf( "Expected attribute %ls is missing from entry %ls\n",
                L"msds-behavior-version",
                pszPartitionsDn);
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

    *pdwForestVersion = _wtoi(*ppszValues);

cleanup:
    // Release results
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    if (pPartResults) {
        ldap_msgfree(pPartResults);
    }
    if (ppszConfigNC) {
        ldap_value_free( ppszConfigNC );
    }
    if (ppszValues) {
        ldap_value_free( ppszValues );
    }

    return dwWin32Error;

} /* getForestVersion */



DWORD
verifySingleObjectAttribute(
    LDAP *pLdap,
    LDAPMessage *pLdapEntry,
    LPWSTR pszDN,
    LDAPModW *pmodCurrent
    )

/*++

Routine Description:

    Given a LDAPMOD structure describing a single change to an attribute, see
    if that change is reflected in the Ldap Entry

Arguments:

    pLdap - 
    pLdapEntry - 
    pszDN - 
    pmodCurrent - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    LPWSTR *ppszLastValue;
    LPWSTR *ppszValues = NULL;
    LPWSTR pszValue;
    WCHAR szAttributeName[MAX_PATH];

    wcscpy( szAttributeName, pmodCurrent->mod_type );
    ppszValues = ldap_get_values( pLdap, pLdapEntry, szAttributeName );
    if (!ppszValues) {
        wcscat( szAttributeName, L";range=1-1" );
        ppszValues = ldap_get_values( pLdap, pLdapEntry, szAttributeName );
    }
    if (!ppszValues) {
        printf( "Expected attribute %ls is missing from entry %ls\n",
                pmodCurrent->mod_type,
                pszDN);
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

    // Skip to the last value in a multi-value
    ppszLastValue = ppszValues;
    while( *(ppszLastValue + 1) ) {
        ppszLastValue++;
    }

    // Deal with dn-values, which come back in extended form
    pszValue = wcschr( *ppszLastValue, L';' );
    if (pszValue) {
        pszValue++; // Skip separator
    } else {
        pszValue = *ppszLastValue;
    }

    if (_wcsicmp( pszValue, pmodCurrent->mod_vals.modv_strvals[0] )) {
        printf( "Expected value %ls on attribute %ls is missing from entry %ls\n",
                pmodCurrent->mod_vals.modv_strvals[0],
                pmodCurrent->mod_type,
                pszDN);
        printf( "Expected: %ls, actual: %ls\n",
                pmodCurrent->mod_vals.modv_strvals[0],
                pszValue );
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

cleanup:
    if (ppszValues) {
        ldap_value_free( ppszValues );
    }

    return dwWin32Error;
} /* verifySingleObjectAttribute */


DWORD
verifyObjectAttributes(
    LDAP *pLdap,
    LDAPMessage *pLdapEntry,
    LPWSTR pszRDN,
    LDAPModW **rgpmodAttrs
    )

/*++

Routine Description:

    Verify that the changes described by the LDAPMod structure are actually
    present in the entry.

Arguments:

    pLdap - 
    pLdapEntry - 
    pszRDN - 
    rgpmodAttrs - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPModW *pmodCurrent;
    LPWSTR pszDN = NULL;

    pszDN = ldap_get_dnW(pLdap, pLdapEntry);
    if (pszDN == NULL) {
        printf( "Expected entry dn is missing\n" );
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

    // Skip to second segment of extended dn
    pszDN = wcschr( pszDN, L';' ) + 1;

    if (_wcsnicmp( pszDN, pszRDN, wcslen( pszRDN ) )) {
        printf( "Expected entry dn is missing\n" );
        printf( "Expected: %ls, actual: %ls\n", pszRDN, pszDN );
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    while (pmodCurrent = *rgpmodAttrs++) {
        dwWin32Error = verifySingleObjectAttribute(
            pLdap,
            pLdapEntry,
            pszDN,
            pmodCurrent );
        if (dwWin32Error) {
            goto cleanup;
        }
    }

    printf( "\tverified %ls.\n", pszDN );

cleanup:
    if (pszDN) {
        ldap_memfreeW(pszDN);
    }

    return dwWin32Error;

} /* verifyObjectAttributes */


DWORD
getSecuredChanges(
    LDAP *pLdap,
    LPWSTR pszNC,
    PBYTE pbCookie,
    DWORD cbCookie
    )

/*++

Routine Description:

    Check for changes that should be visible to an unprivileged user
    after the objects have been protected

Arguments:

    pLdap - 
    pszNC - 
    pbCookie - 
    cbCookie - 

Return Value:

    DWORD - 

--*/

{
    BOOL fMoreData = TRUE;
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPMessage *pChangeEntries = NULL;
    PBYTE pbCookieNew = NULL;
    DWORD cbCookieNew = 0;
    DWORD cEntries, cExpectedEntries;
    LDAPMessage *pLdapEntry;
    DWORD dwReplFlags = 0;

    dwReplFlags |= DRS_DIRSYNC_PUBLIC_DATA_ONLY |
        DRS_DIRSYNC_INCREMENTAL_VALUES;

    printf( "\tBegin expected errors...\n" );
    // Try once without the OBJECT_SECURITY flag
    dwWin32Error = DsGetSourceChangesW(
        pLdap,  // ldap handle
        pszNC,  // search base
        NULL, // Source filter
        dwReplFlags, // repl flags
        pbCookie,
        cbCookie,
        &pChangeEntries,  // search result
        &fMoreData,
        &pbCookieNew,
        &cbCookieNew,
        NULL // att list array
        );
    printf( "\tEnd expected errors...\n" );
    if (dwWin32Error != ERROR_ACCESS_DENIED) {
        if (dwWin32Error == ERROR_SUCCESS) {
            dwWin32Error = ERROR_DS_INTERNAL_FAILURE;
        }
        // New cookie will not be allocated
        printf( "Call %s failed with win32 error %d\n", "DsGetSourceChanges", dwWin32Error );
        goto cleanup;
    }

    dwReplFlags |= DRS_DIRSYNC_OBJECT_SECURITY;
    // Try again with the OBJECT_SECURITY flag
    dwWin32Error = DsGetSourceChangesW(
        pLdap,  // ldap handle
        pszNC,  // search base
        NULL, // Source filter
        dwReplFlags, // repl flags
        pbCookie,
        cbCookie,
        &pChangeEntries,  // search result
        &fMoreData,
        &pbCookieNew,
        &cbCookieNew,
        NULL // att list array
        );
    if (dwWin32Error != ERROR_SUCCESS) {
        // New cookie will not be allocated
        printf( "Call %s failed with win32 error %d\n", "DsGetSourceChanges", dwWin32Error );
        goto cleanup;
    }
    if (!pChangeEntries) {
        printf( "Expected change entries not returned\n" );
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    if (fMoreData) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    cExpectedEntries = 1;

    cEntries = ldap_count_entries(pLdap, pChangeEntries);

    // We are expecting a certain number of objects here
    if (cEntries != cExpectedEntries) {
        printf( "Expected number of change entries not returned\n" );
        printf( "Expected: %d, actual %d\n", cExpectedEntries, cEntries );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    // First object
    pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
    dwWin32Error = verifySingleObjectAttribute(
        pLdap,
        pLdapEntry,
        CONTACT2_RDN_W,
        &modAttr4b );
    if (dwWin32Error) {
        goto cleanup;
    }

    // End of stream
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    if (pLdapEntry) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

cleanup:

    // Release changes
    if (pChangeEntries) {
        ldap_msgfree(pChangeEntries);
    }

    if ( pbCookieNew ) {
        DsFreeReplCookie( pbCookieNew );
    }

    return dwWin32Error;
} /* getFilteredChanges */


DWORD
getFilteredChanges(
    LDAP *pLdap,
    LPWSTR pszNC,
    PBYTE pbCookie,
    DWORD cbCookie
    )

/*++

Routine Description:

    Check that the correct changes are visible when filtering is being used

Arguments:

    pLdap - 
    pszNC - 
    pbCookie - 
    cbCookie - 

Return Value:

    DWORD - 

--*/

{
    BOOL fMoreData = TRUE;
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPMessage *pChangeEntries = NULL;
    PBYTE pbCookieNew = NULL;
    DWORD cbCookieNew = 0;
    DWORD cEntries, cExpectedEntries;
    LDAPMessage *pLdapEntry;
    DWORD dwReplFlags = 0;
    LPWSTR rgpszAttList[2] = { L"sn", NULL };

    dwReplFlags |= DRS_DIRSYNC_PUBLIC_DATA_ONLY |
        DRS_DIRSYNC_INCREMENTAL_VALUES;

    dwWin32Error = DsGetSourceChangesW(
        pLdap,  // ldap handle
        pszNC,  // search base
        L"(objectClass=contact)", // Source filter
        dwReplFlags, // repl flags
        pbCookie,
        cbCookie,
        &pChangeEntries,  // search result
        &fMoreData,
        &pbCookieNew,
        &cbCookieNew,
        rgpszAttList // att list array
        );
    if (dwWin32Error != ERROR_SUCCESS) {
        // New cookie will not be allocated
        printf( "Call %s failed with win32 error %d\n", "DsGetSourceChanges", dwWin32Error );
        goto cleanup;
    }

    if (!pChangeEntries) {
        printf( "Expected change entries not returned\n" );
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    if (fMoreData) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    cExpectedEntries = 2;

    cEntries = ldap_count_entries(pLdap, pChangeEntries);

    // We are expecting a certain number of objects here
    if (cEntries != cExpectedEntries) {
        printf( "Expected number of change entries not returned\n" );
        printf( "Expected: %d, actual %d\n", cExpectedEntries, cEntries );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    // First object
    pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
    dwWin32Error = verifySingleObjectAttribute(
        pLdap,
        pLdapEntry,
        CONTACT1_RDN_W,
        &modAttr2b );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Second object
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    dwWin32Error = verifySingleObjectAttribute(
        pLdap,
        pLdapEntry,
        CONTACT2_RDN_W,
        &modAttr4b );
    if (dwWin32Error) {
        goto cleanup;
    }

    // End of stream
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    if (pLdapEntry) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

cleanup:

    // Release changes
    if (pChangeEntries) {
        ldap_msgfree(pChangeEntries);
    }

    if ( pbCookieNew ) {
        DsFreeReplCookie( pbCookieNew );
    }

    return dwWin32Error;
} /* getFilteredChanges */


DWORD
getFilteredChangesAll(
    LDAP *pLdap,
    LPWSTR pszNC,
    PBYTE pbCookie,
    DWORD cbCookie
    )

/*++

Routine Description:

    Check that the correct changes are visible when filtering is being used

Arguments:

    pLdap - 
    pszNC - 
    pbCookie - 
    cbCookie - 

Return Value:

    DWORD - 

--*/

{
    BOOL fMoreData = TRUE;
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPMessage *pChangeEntries = NULL;
    PBYTE pbCookieNew = NULL;
    DWORD cbCookieNew = 0;
    DWORD cEntries, cExpectedEntries;
    LDAPMessage *pLdapEntry;
    DWORD dwReplFlags = 0;
    LPWSTR rgpszAttList[2] = { L"objectClass", NULL };

    dwReplFlags |= DRS_DIRSYNC_PUBLIC_DATA_ONLY |
        DRS_DIRSYNC_INCREMENTAL_VALUES;

    dwWin32Error = DsGetSourceChangesW(
        pLdap,  // ldap handle
        pszNC,  // search base
        L"(objectClass=*)", // Source filter
        dwReplFlags, // repl flags
        pbCookie,
        cbCookie,
        &pChangeEntries,  // search result
        &fMoreData,
        &pbCookieNew,
        &cbCookieNew,
        rgpszAttList // att list array
        );
    if (dwWin32Error != ERROR_SUCCESS) {
        // New cookie will not be allocated
        printf( "Call %s failed with win32 error %d\n", "DsGetSourceChanges", dwWin32Error );
        goto cleanup;
    }

    if (!pChangeEntries) {
        printf( "Expected change entries not returned\n" );
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    if (fMoreData) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    cExpectedEntries = 3;

    cEntries = ldap_count_entries(pLdap, pChangeEntries);

    // We are expecting a certain number of objects here
    if (cEntries != cExpectedEntries) {
        printf( "Expected number of change entries not returned\n" );
        printf( "Expected: %d, actual %d\n", cExpectedEntries, cEntries );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    // First object
    pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
    dwWin32Error = verifySingleObjectAttribute(
        pLdap,
        pLdapEntry,
        CONTACT1_RDN_W,
        &modAttr2 );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Second object
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    dwWin32Error = verifySingleObjectAttribute(
        pLdap,
        pLdapEntry,
        CONTACT2_RDN_W,
        &modAttr2 );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Third object
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    dwWin32Error = verifySingleObjectAttribute(
        pLdap,
        pLdapEntry,
        CONTAINER_RDN_W,
        &modAttr1 );
    if (dwWin32Error) {
        goto cleanup;
    }


    // End of stream
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    if (pLdapEntry) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

cleanup:

    // Release changes
    if (pChangeEntries) {
        ldap_msgfree(pChangeEntries);
    }

    if ( pbCookieNew ) {
        DsFreeReplCookie( pbCookieNew );
    }

    return dwWin32Error;
} /* getFilteredChangesAll */


DWORD
getFilteredChangesNone(
    LDAP *pLdap,
    LPWSTR pszNC,
    PBYTE pbCookie,
    DWORD cbCookie
    )

/*++

Routine Description:

    Check that the correct changes are visible when filtering is being used

    When specifying an attribute list, if there are changes, but do not contain any
    of the requested attributes, the change is not returned.

Arguments:

    pLdap - 
    pszNC - 
    pbCookie - 
    cbCookie - 

Return Value:

    DWORD - 

--*/

{
    BOOL fMoreData = TRUE;
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPMessage *pChangeEntries = NULL;
    PBYTE pbCookieNew = NULL;
    DWORD cbCookieNew = 0;
    DWORD cEntries, cExpectedEntries;
    LDAPMessage *pLdapEntry;
    DWORD dwReplFlags = 0;
    LPWSTR rgpszAttList[2] = { L"division", NULL };

    dwReplFlags |= DRS_DIRSYNC_PUBLIC_DATA_ONLY |
        DRS_DIRSYNC_INCREMENTAL_VALUES;

    dwWin32Error = DsGetSourceChangesW(
        pLdap,  // ldap handle
        pszNC,  // search base
        L"(objectClass=*)", // Source filter
        dwReplFlags, // repl flags
        pbCookie,
        cbCookie,
        &pChangeEntries,  // search result
        &fMoreData,
        &pbCookieNew,
        &cbCookieNew,
        rgpszAttList // att list array
        );
    if (dwWin32Error != ERROR_SUCCESS) {
        // New cookie will not be allocated
        printf( "Call %s failed with win32 error %d\n", "DsGetSourceChanges", dwWin32Error );
        goto cleanup;
    }

   if (!pChangeEntries) {
        dwWin32Error = ERROR_SUCCESS;
        goto cleanup;
    }

    if (fMoreData) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    cExpectedEntries = 0;

    cEntries = ldap_count_entries(pLdap, pChangeEntries);

    // We are expecting a certain number of objects here
    if (cEntries != cExpectedEntries) {
        printf( "Expected number of change entries not returned\n" );
        printf( "Expected: %d, actual %d\n", cExpectedEntries, cEntries );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    // End of stream
    pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
    if (pLdapEntry) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

cleanup:

    // Release changes
    if (pChangeEntries) {
        ldap_msgfree(pChangeEntries);
    }

    if ( pbCookieNew ) {
        DsFreeReplCookie( pbCookieNew );
    }

    return dwWin32Error;
} /* getFilteredChangesAll */


DWORD
getAllChanges(
    LDAP *pLdap,
    LPWSTR pszNC,
    PBYTE pbCookie,
    DWORD cbCookie,
    DWORD dwReplFlags
    )

/*++

Routine Description:

    Check that the changes match what we expect.
    Different kinds of checks are done according to:
    flags = none (ie last change first order)
    flags = ancestors first
    flags = incremental values

Arguments:

    pLdap - 
    pszNC - 
    pbCookie - 
    cbCookie - 
    fAncestorFirstOrder - 

Return Value:

    DWORD - 

--*/

{
    BOOL fMoreData = TRUE;
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPMessage *pChangeEntries = NULL;
    PBYTE pbCookieNew = NULL;
    DWORD cbCookieNew = 0;
    DWORD cEntries, cExpectedEntries;
    LDAPMessage *pLdapEntry;
    LPWSTR pszFirstRdn, pszSecondRdn, pszThirdRdn;
    LDAPModW **rgpmodFirstMod, **rgpmodSecondMod, **rgpmodThirdMod;

    dwReplFlags |= DRS_DIRSYNC_PUBLIC_DATA_ONLY;

    dwWin32Error = DsGetSourceChangesW(
        pLdap,  // ldap handle
        pszNC,  // search base
        NULL, // Source filter
        dwReplFlags, // repl flags
        pbCookie,
        cbCookie,
        &pChangeEntries,  // search result
        &fMoreData,
        &pbCookieNew,
        &cbCookieNew,
        NULL // att list array
        );
    if (dwWin32Error != ERROR_SUCCESS) {
        // New cookie will not be allocated
        printf( "Call %s failed with win32 error %d\n", "DsGetSourceChanges", dwWin32Error );
        goto cleanup;
    }

    if (!pChangeEntries) {
        printf( "Expected change entries not returned\n" );
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    if (fMoreData) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    cExpectedEntries = (dwReplFlags & DRS_DIRSYNC_INCREMENTAL_VALUES) ? 4 : 3;

    cEntries = ldap_count_entries(pLdap, pChangeEntries);

    // We are expecting three objects here
    if (cEntries != cExpectedEntries) {
        printf( "Expected number of change entries not returned\n" );
        printf( "Expected: %d, actual %d\n", cExpectedEntries, cEntries );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    if (dwReplFlags & DRS_DIRSYNC_ANCESTORS_FIRST_ORDER) {
        pszFirstRdn = CONTAINER_RDN_W;
        pszSecondRdn = CONTACT1_RDN_W; 
        pszThirdRdn = CONTACT2_RDN_W; 
        rgpmodFirstMod = rgpmodAttrs1;
        rgpmodSecondMod = rgpmodAttrs2;
        rgpmodThirdMod = rgpmodAttrs4;
    } else {
        pszFirstRdn = CONTACT1_RDN_W;
        pszSecondRdn = CONTACT2_RDN_W;
        pszThirdRdn = CONTAINER_RDN_W;
        rgpmodFirstMod = rgpmodAttrs2;
        rgpmodSecondMod = rgpmodAttrs4;
        rgpmodThirdMod = rgpmodAttrs1;
    }

    // First object
    pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
    dwWin32Error = verifyObjectAttributes( pLdap, pLdapEntry, pszFirstRdn, rgpmodFirstMod );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Second object
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    dwWin32Error = verifyObjectAttributes( pLdap, pLdapEntry, pszSecondRdn, rgpmodSecondMod );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Third object
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    dwWin32Error = verifyObjectAttributes( pLdap, pLdapEntry, pszThirdRdn, rgpmodThirdMod );
    if (dwWin32Error) {
        goto cleanup;
    }

    if (dwReplFlags & DRS_DIRSYNC_INCREMENTAL_VALUES) {
        // The linked attr change should appear as a separate change
        // in incremental mode
        pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );

        dwWin32Error = verifySingleObjectAttribute(
            pLdap,
            pLdapEntry,
            CONTAINER_RDN_W,
            &modAttr5 );
        if (dwWin32Error) {
            goto cleanup;
        }
    }

    // End of stream
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    if (pLdapEntry) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    // Reposition on container, whereever it is in the stream
    pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
    if (!(dwReplFlags & DRS_DIRSYNC_ANCESTORS_FIRST_ORDER)) {
        pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
        pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    }

    if (!(dwReplFlags & DRS_DIRSYNC_INCREMENTAL_VALUES)) {
        // The linked attr change should appear as part of the object
        // in non-incremental mode
        dwWin32Error = verifySingleObjectAttribute(
            pLdap,
            pLdapEntry,
            CONTAINER_RDN_W,
            &modAttr5 );
        if (dwWin32Error) {
            goto cleanup;
        }
    }

    // The container should have the non-linked attr change
    dwWin32Error = verifySingleObjectAttribute(
        pLdap,
        pLdapEntry,
        CONTAINER_RDN_W,
        &modAttr3 );
    if (dwWin32Error) {
        goto cleanup;
    }

cleanup:

    // Release changes
    if (pChangeEntries) {
        ldap_msgfree(pChangeEntries);
    }

    if ( pbCookieNew ) {
        DsFreeReplCookie( pbCookieNew );
    }

    return dwWin32Error;
} /* getAllChanges */


DWORD
syncChanges(
    LDAP *pLdap,
    LPWSTR pszNC,
    PBYTE *ppbCookie,
    DWORD *pcbCookie
    )

/*++

Routine Description:

    Read all changes up to the present

Arguments:

    pLdap - 
    ppbCookie - 
    pcbCookie - 

Return Value:

    BOOL - 

--*/

{
    PBYTE pbCookie = NULL;
    DWORD cbCookie = 0;
    BOOL fMoreData = TRUE;
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPMessage *pChangeEntries = NULL;

    // Start from scratch
    // Perf optimization: we only want the cookie advanced. We don't care
    // about the changes themselves. Filter them out.


    while (fMoreData) {
        PBYTE pbCookieNew;
        DWORD cbCookieNew;

        dwWin32Error = DsGetSourceChangesW(
            pLdap,  // ldap handle
            pszNC,  // search base
            L"(!(objectClass=*))", // Source filter
            DRS_DIRSYNC_PUBLIC_DATA_ONLY, // repl flags
            pbCookie,
            cbCookie,
            &pChangeEntries,  // search result
            &fMoreData,
            &pbCookieNew,
            &cbCookieNew,
            NULL // att list array
            );
        if (dwWin32Error != ERROR_SUCCESS) {
            // New cookie will not be allocated
            break;
        }

        {
            LDAPMessage *pLdapEntry;
            BerElement *pBer = NULL;
            LPWSTR attr;
            DWORD cAttributes = 0;

            for( pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
                 pLdapEntry;
                 pLdapEntry = ldap_next_entry( pLdap, pLdapEntry ) ) {

                // List attributes in object
                for (attr = ldap_first_attributeW(pLdap, pLdapEntry, &pBer);
                     attr != NULL;
                     attr = ldap_next_attributeW(pLdap, pLdapEntry, pBer))
                {
                    cAttributes++;
                }
            }
            printf( "\t[skipped %d entries, %d attributes]\n",
                    ldap_count_entries(pLdap, pChangeEntries),
                    cAttributes );
        }

        // Release changes
        ldap_msgfree(pChangeEntries);

        // get rid of old cookie
        if ( pbCookie ) {
            DsFreeReplCookie( pbCookie );
        }
        // Make new cookie the current cookie
        pbCookie = pbCookieNew;
        cbCookie = cbCookieNew;
    }

// Cleanup

    if (dwWin32Error) {
        if ( pbCookie ) {
            DsFreeReplCookie( pbCookie );
        }
    } else {
        // return the cookie
        *ppbCookie = pbCookie;
        *pcbCookie = cbCookie;
    }

    return dwWin32Error;
} /* syncChanges */


DWORD
createObjects(
    LDAP *pLdap,
    LPWSTR pszNC
    )

/*++

Routine Description:

    Create the objects and changes for the test

Arguments:

    pLdap - 
    pszNC - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    ULONG ulLdapError = LDAP_SUCCESS;
    WCHAR szDn[MAX_PATH];

    // Create the container

    wcscpy( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_add_sW( pLdap, szDn, rgpmodAttrs1 );
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_add", dwWin32Error );
        goto cleanup;
    }
    printf( "\tadded %ls.\n", szDn );

    // Create a contact in the container

    wcscpy( szDn, CONTACT1_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );
    wcscpy( szDn5a, szDn );  // Initialize global

    ulLdapError = ldap_add_sW( pLdap, szDn, rgpmodAttrs2 );
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_add", dwWin32Error );
        goto cleanup;
    }
    printf( "\tadded %ls.\n", szDn );

    // Create another contact in the container

    wcscpy( szDn, CONTACT2_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_add_sW( pLdap, szDn, rgpmodAttrs4 );
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_add", dwWin32Error );
        goto cleanup;
    }
    printf( "\tadded %ls.\n", szDn );

    // Modify the container
    // This forces it to replicate later in the stream

    wcscpy( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_modify_sW( pLdap, szDn, rgpmodAttrs5 );
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_modify", dwWin32Error );
        goto cleanup;
    }
    printf( "\tmodified %ls.\n", szDn );


cleanup:

    return dwWin32Error;
} /* createObjects */


DWORD
deleteObjects(
    LDAP *pLdap,
    LPWSTR pszNC
    )

/*++

Routine Description:

    Delete the objects from the prior run of the test

Arguments:

    pLdap - 
    pszNC - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    ULONG ulLdapError = LDAP_SUCCESS;
    WCHAR szDn[MAX_PATH];

    wcscpy( szDn, CONTACT1_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_delete_sW( pLdap, szDn );
    if (ulLdapError) {
        if (ulLdapError != LDAP_NO_SUCH_OBJECT) {
            printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
            dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
            printf( "Call %s failed with win32 error %d\n", "ldap_delete", dwWin32Error );
            goto cleanup;
        }
    } else {
        printf( "\tdeleted %ls.\n", szDn );
    }

    wcscpy( szDn, CONTACT2_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_delete_sW( pLdap, szDn );
    if (ulLdapError) {
        if (ulLdapError != LDAP_NO_SUCH_OBJECT) {
            printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
            dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
            printf( "Call %s failed with win32 error %d\n", "ldap_delete", dwWin32Error );
            goto cleanup;
        }
    } else {
        printf( "\tdeleted %ls.\n", szDn );
    }

    wcscpy( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_delete_sW( pLdap, szDn );
    if (ulLdapError) {
        if (ulLdapError != LDAP_NO_SUCH_OBJECT) {
            printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
            dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
            printf( "Call %s failed with win32 error %d\n", "ldap_delete", dwWin32Error );
            goto cleanup;
        }
    } else {
        printf( "\tdeleted %ls.\n", szDn );
    }

cleanup:

    return dwWin32Error;

} /* deleteObjects */


int __cdecl
wmain(
    int Argc,
    LPWSTR Argv[]
    )

/*++

Routine Description:

    Run the LDAP replication control test

Arguments:

    argc - 
    [] - 

Return Value:

    int __cdecl - 

--*/

{
    LDAP *pLdap;
    ULONG ulOptions;
    DWORD dwWin32Error = ERROR_SUCCESS;
    ULONG ulLdapError = LDAP_SUCCESS;
    PBYTE pbCookie = NULL;
    DWORD cbCookie;
    LPWSTR pszNC, pszUser, pszDomain, pszPassword;
    DWORD dwForestVersion;
    RPC_AUTH_IDENTITY_HANDLE hCredentials = NULL;

    if (Argc < 5) {
        printf( "%ls <naming context> <user> <domain> <password>\n", Argv[0] );
        printf( "The logged in account should be able to create objects.\n" );
        printf( "The supplied account will be used for impersonation during\n" );
        printf( "the test.  It should be a normal domain account.\n" );
        printf( "The forest version should be Whistler, although this program\n" );
        printf( "will run most of the tests in W2K forest mode.\n" );
        return 1;
    }

    printf( "LDAP Replication Control Test\n" );

    pszNC = Argv[1];
    pszUser = Argv[2];
    pszDomain = Argv[3];
    pszPassword = Argv[4];

    pLdap = ldap_initW(L"localhost", LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to localhost.\n" );
        dwWin32Error = GetLastError();
        printf( "Call %s failed with win32 error %d\n", "ldap_init", dwWin32Error );
        goto cleanup;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( pLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    //
    // Bind
    //

    ulLdapError = ldap_bind_sA( pLdap, NULL, NULL, LDAP_AUTH_SSPI);
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_bind", dwWin32Error );
        goto cleanup;
    }

    // Check that the test can run
    dwWin32Error = getForestVersion( pLdap, &dwForestVersion );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Clean out old objects from prior run
    printf( "\nClean out prior objects.\n" );
    dwWin32Error = deleteObjects( pLdap, pszNC );
    if (dwWin32Error) {
        goto cleanup;
    }

    printf( "\nSynchronize with change stream.\n" );
    dwWin32Error = syncChanges( pLdap, pszNC, &pbCookie, &cbCookie );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Create some changes
    printf( "\nMake some changes by creating objects.\n" );
    dwWin32Error = createObjects( pLdap, pszNC );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Get all changes
    // nc granular security, no incremental, no ancestors
    printf( "\nTest: all changes are returned in last-changed (USN) order.\n" );
    dwWin32Error = getAllChanges( pLdap, pszNC, pbCookie, cbCookie,
                                  0 /* no flags */ );
    if (dwWin32Error) {
        goto cleanup;
    }
    printf( "\tPassed.\n" );

    // nc granular security, no incremental, ancestors
    printf( "\nTest: all changes are returned in ancestor-first order.\n" );
    dwWin32Error = getAllChanges( pLdap, pszNC, pbCookie, cbCookie,
                                  DRS_DIRSYNC_ANCESTORS_FIRST_ORDER );
    if (dwWin32Error) {
        goto cleanup;
    }
    printf( "\tPassed.\n" );

    if (dwForestVersion > DS_BEHAVIOR_WIN2000) {
        // nc granular security, incremental, ancestors
        printf( "\nTest: all changes in USN order, values shown incrementally.\n" );
        dwWin32Error = getAllChanges( pLdap, pszNC, pbCookie, cbCookie,
                                      DRS_DIRSYNC_INCREMENTAL_VALUES );
        if (dwWin32Error) {
            goto cleanup;
        }
        printf( "\tPassed.\n" );
    } else {
        printf( "\nWarning: incremental value test skipped because forest verson is too low.\n" );
    }

    // Object filter
    // Attribute filter
    printf( "\nTest: filtered object/attribute, some returned.\n" );
    dwWin32Error = getFilteredChanges( pLdap, pszNC, pbCookie, cbCookie );
    if (dwWin32Error) {
        goto cleanup;
    }
    printf( "\tPassed.\n" );

    // Object filter
    // Attribute filter
    printf( "\nTest: filtered object/attribute, none returned.\n" );
    dwWin32Error = getFilteredChangesNone( pLdap, pszNC, pbCookie, cbCookie );
    if (dwWin32Error) {
        goto cleanup;
    }
    printf( "\tPassed.\n" );

    // Attribute filter only
    printf( "\nTest: all objects, filtered attribute.\n" );
    dwWin32Error = getFilteredChangesAll( pLdap, pszNC, pbCookie, cbCookie );
    if (dwWin32Error) {
        goto cleanup;
    }
    printf( "\tPassed.\n" );

    // Deny visibility of some objects
    printf( "\nChange protection on objects\n" );
    dwWin32Error = protectObjects( pszNC );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Impersonate a user
    dwWin32Error = DsMakePasswordCredentialsW( pszUser, pszDomain, pszPassword, &hCredentials );
    if (dwWin32Error) {
        printf( "Failed to construct password credentials.\n" );
        goto cleanup;
    }

    if (pLdap) {
        ldap_unbind(pLdap);
    }
    pLdap = ldap_initW(L"localhost", LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to localhost.\n" );
        dwWin32Error = GetLastError();
        printf( "Call %s failed with win32 error %d\n", "ldap_init", dwWin32Error );
        goto cleanup;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( pLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    //
    // Bind
    //

    ulLdapError = ldap_bind_sA( pLdap, NULL, hCredentials, LDAP_AUTH_SSPI);
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_bind", dwWin32Error );
        goto cleanup;
    }

    // Verify that we cannot see the objects
    // Verify that we cannot see the values
    printf( "\nTest: secured object/attribute.\n" );
    dwWin32Error = getSecuredChanges( pLdap, pszNC, pbCookie, cbCookie );
    if (dwWin32Error) {
        goto cleanup;
    }
    printf( "\tPassed.\n" );
 
cleanup:
    if ( pbCookie) {
        DsFreeReplCookie( pbCookie );
    }

    if (pLdap) {
        ldap_unbind(pLdap);
    }

    if (hCredentials) {
        DsFreePasswordCredentials( hCredentials );
    }

    if (dwWin32Error) {
        printf( "\nSummary: One or more failures occurred.\n" );
    } else {
        printf( "\nSummary: All tests passed.\n" );
    }

    return 0;
} /* wmain */

/* end test.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\ldaprepltest\testsingle.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <winldap.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>

#include "ldaprepltest.hpp"
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplRpcSpoofProto.hxx"
#include "ReplCompare.hpp"

DWORD
Repl_DeMarshalBerval(DS_REPL_STRUCT_TYPE dsReplStructType, 
                     berval * ldapValue[], OPTIONAL
                     DWORD dwNumValues,
                     puReplStructArray pReplStructArray, OPTIONAL
                     PDWORD pdwReplStructArrayLen);

void
testSingle(RPC_AUTH_IDENTITY_HANDLE AuthIdentity)
{
    LDAP * pLdap;
    DWORD err;

    // Open
    pLdap = ldap_openW(gpszDns, LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to %ls.\n", gpszDns);
        return;
    }
    
    // Bind
    err = ldap_bind_sW(pLdap, gpszDns, (PWCHAR)AuthIdentity, LDAP_AUTH_SSPI);
    if (err != LDAP_SUCCESS)
    {
        err = LdapMapErrorToWin32(err);
    }

    DWORD dwCount;
    DWORD attrId = ROOT_DSE_MS_DS_REPL_QUEUE_STATISTICS;
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);

    LDAPMessage * pLDAPMsg = NULL; 
    WCHAR buf[256];
    LPCWSTR aAttribute[2] = { buf, NULL, };

    aAttribute[0] = Repl_GetLdapCommonName(attrId, TRUE);
    ldap_search_sW(pLdap, NULL, LDAP_SCOPE_BASE, L"(objectclass=*)", (LPWSTR*)aAttribute , FALSE, &pLDAPMsg);

    // Get values
    berval ** ppBerval;
    PWCHAR szRetAttribute;
    berelement * pCookie;
    szRetAttribute = ldap_first_attributeW(pLdap, pLDAPMsg, &pCookie);
    ppBerval = ldap_get_values_lenW(pLdap, pLDAPMsg, szRetAttribute);
    ldap_memfreeW(szRetAttribute);
    dwCount = ldap_count_values_len(ppBerval);

    DWORD cb;
    puReplStructArray pReplStructArray;
    Repl_DeMarshalBerval(structId, ppBerval, dwCount, NULL, &cb);
    pReplStructArray = (puReplStructArray)malloc(cb);
    Repl_DeMarshalBerval(structId, ppBerval, dwCount, pReplStructArray, &cb);

    wprintf(L"Queue statistic {%d.%d}{%d}\n\n", 
        pReplStructArray->singleReplStruct.queueStatistics.ftimeCurrentOpStarted.dwHighDateTime,
        pReplStructArray->singleReplStruct.queueStatistics.ftimeCurrentOpStarted.dwLowDateTime,
        pReplStructArray->singleReplStruct.queueStatistics.cNumPendingOps);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\spn\testspn.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    testspn.c

Abstract:

    Program to test SPN api functions

Author:

    Will Lees (wlees) 20-Jan-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntdsapi.h>
#include <ntdsapip.h>

#define SECURITY_WIN32      // Who should set this, and to what?
#include <security.h>       // GetComputerNameEx

#include <winsock2.h>

#define MAX_SPN 1024
#define MAX_NAME_LENGTH 256
#define MAX_INSTANCES 5
#define MAX_ALIASES 5

#define COMPUTERNAME_TOKEN "<computername>"
#define COMPUTERDNS_TOKEN "<computerdns>"
#define COMPUTERDN_TOKEN "<computerdn>"

typedef struct _MAKE_SPN_TEST_CASE {
    LPSTR ServiceClass;
    LPSTR ServiceName;
    LPSTR InstanceName;
    USHORT InstancePort;
    LPSTR Referrer;
    LPSTR PrincipalName;
} MAKE_SPN_TEST_CASE, *PMAKE_SPN_TEST_CASE;

typedef struct _CLIENT_MAKE_SPN_TEST_CASE {
    LPSTR ServiceClass;
    LPSTR InstanceName;
    LPSTR PrincipalName;
} CLIENT_MAKE_SPN_TEST_CASE, *PCLIENT_MAKE_SPN_TEST_CASE;

typedef struct _GET_SPN_TEST_CASE {
    DS_SPN_NAME_TYPE ServiceType;
    LPSTR ServiceClass;
    LPSTR ServiceName;
    USHORT InstancePort;
    USHORT cInstanceNames;
    LPSTR InstanceNames[MAX_INSTANCES];
    USHORT InstancePorts[MAX_INSTANCES];
    DWORD cSpn;
    LPSTR Spn[MAX_INSTANCES + MAX_ALIASES];
} GET_SPN_TEST_CASE, *PGET_SPN_TEST_CASE;

#define NUMBER_ELEMENTS( A ) ( sizeof( A ) / sizeof( A[0] ) )

/* External */

/* Static */

static MAKE_SPN_TEST_CASE makeSpnTestCaseArray[] = {
    // ServClass   ServName   InstName   InstPort   Referrer

    // 0: Normal case without port
    { "ldap", "ntdev.ms.com", "dc1.ntdev.ms.com", 0, NULL,
      "ldap/dc1.ntdev.ms.com/ntdev.ms.com" },

    // 1: Normal case with port
    { "ldap", "ntdev.ms.com", "dc1.ntdev.ms.com", 123, NULL,
      "ldap/dc1.ntdev.ms.com:123/ntdev.ms.com" },

    // 2: IP address for service name, use referrer
    { "ldap", "1.2.3.4", "dc1.ntdev.ms.com", 123, "refer.ms.com",
      "ldap/dc1.ntdev.ms.com:123/refer.ms.com" },

    // 3: Normal case with duplicate service name and port, host based service
    { "ldap", "ntdev.ms.com", "ntdev.ms.com", 123, NULL,
      "ldap/ntdev.ms.com:123" },

    // 4: Normal case with duplicate service name, no port, host based service
    { "ldap", "ntdev.ms.com", "ntdev.ms.com", 0, NULL,
      "ldap/ntdev.ms.com" },

    // 5: Normal case with NULL instance and port, host based service
    { "ldap", "ntdev.ms.com", NULL, 123, NULL,
      "ldap/ntdev.ms.com:123" },

    // 6: Normal case with NULL instance, no port, host based service
    { "ldap", "ntdev.ms.com", NULL, 0, NULL,
      "ldap/ntdev.ms.com" },

    // 7: IP address for service name, use referrer, with NULL instance
    { "ldap", "1.2.3.4", NULL, 123, "refer.ms.com",
      "ldap/1.2.3.4:123/refer.ms.com" },

    // 8: Same as prev, but with a sneaky service name
    { "ldap", "1234567890123456789.guidbaseddnsname", NULL, 123, "refer.ms.com",
//      "ldap/1234567890123456789.guidbaseddnsname:123/1234567890123456789.guidbaseddnsname"
      "ldap/1234567890123456789.guidbaseddnsname:123"
    },

    // 9: Normal case without port, with dots at end
    { "ldap", "ntdev.ms.com.", "dc1.ntdev.ms.com.", 0, NULL,
      "ldap/dc1.ntdev.ms.com/ntdev.ms.com" },

    // 10: Normal case with port
    { "ldap", "ntdev.ms.com.", "dc1.ntdev.ms.com.", 123, NULL,
      "ldap/dc1.ntdev.ms.com:123/ntdev.ms.com" },

    // 11: IP address for service name, use referrer
    { "ldap", "1.2.3.4", "dc1.ntdev.ms.com.", 123, "refer.ms.com.",
      "ldap/dc1.ntdev.ms.com:123/refer.ms.com" },

    // 12: Normal case with duplicate service name and port, host based service
    { "ldap", "ntdev.ms.com.", "ntdev.ms.com.", 123, NULL,
      "ldap/ntdev.ms.com:123" }

};

static CLIENT_MAKE_SPN_TEST_CASE clientMakeSpnTestCaseArray[] = {
    // fully qualified domain name
    { "ldap", "<computerdns>",
//      "ldap/<computerdns>/<computerdns>"
      "ldap/<computerdns>"
    },
    // fqdns, with . at end
    { "ldap", "<computerdns>.",
//      "ldap/<computerdns>/<computerdns>"
      "ldap/<computerdns>"
    },
    // not qualified dns
    { "ldap", "<computername>",
//      "ldap/<computerdns>/<computerdns>"
      "ldap/<computerdns>"
    },
    // netbios name
    { "ldap", "\\\\<computername>",
//      "ldap/<computerdns>/<computerdns>"
      "ldap/<computerdns>"
    },
    // stringified ip address
    { "ldap", "172.31.234.189",
//      "ldap/<computerdns>/<computerdns>"
      "ldap/<computerdns>"
    }
};

static GET_SPN_TEST_CASE *getSpnTestCaseArray = NULL;

static GET_SPN_TEST_CASE getSpnTestCaseData[] = {

    { DS_SPN_DNS_HOST, "http", NULL, 0,
      1,
      { "p2.b26.ms.com" },
      { 0 },
      1,
//      { "http/p2.b26.ms.com/<computerdns>" }
      { "http/p2.b26.ms.com" }
    },

    { DS_SPN_DNS_HOST, "http", NULL, 0,
      0,
      { 0 },
      { 0 },
      2,
//      { "http/<computerdns>/<computerdns>",
//        "http/<computername>.dns.microsoft.com/<computerdns>" }
      { "http/<computerdns>",
        "http/<computername>.dns.microsoft.com" }
    },

    { DS_SPN_DNS_HOST, "http", NULL, 1234,
      0,
      { 0 },
      { 0 },
      2,
//      { "http/<computerdns>:1234/<computerdns>",
//        "http/<computername>.dns.microsoft.com:1234/<computerdns>" }
      { "http/<computerdns>:1234",
        "http/<computername>.dns.microsoft.com:1234" }
    },

    { DS_SPN_DN_HOST, "http", NULL, 0,
      1,
      { "p2.b26.ms.com" },
      { 0 },
      1,
//      { "http/p2.b26.ms.com/<computerdn>" }
      { "http/p2.b26.ms.com" }
    },

    { DS_SPN_NB_HOST, "http", NULL, 0,
      2,
      { "paulle3", "paulle4" },
      { 0 },
      2,
//      { "http/paulle3/<computername>", "http/paulle4/<computername>" }
      { "http/paulle3", "http/paulle4" }
    },

    { DS_SPN_SERVICE, "http", "www.ms.com", 0,
      0,
      { 0 },
      { 0 },
      1,
      { "http/www.ms.com/www.ms.com" }
   },

    { DS_SPN_SERVICE, "anRpcSvc", "cn=anRpcSvc,cn=RPC Services,cn=system,dc=ms,dc=com", 0,
      1,
      { "p2.b26.ms.com" },
      { 0 },
      1,
      { "anRpcSvc/p2.b26.ms.com/cn=anRpcSvc,cn=RPC Services,cn=system,dc=ms,dc=com" }
    },

    { DS_SPN_DOMAIN, "ldap", "ntdev.ms.com", 0,
      1,
      { "dc1.ntdev.ms.com" },
      { 0 },
      1,
      { "ldap/dc1.ntdev.ms.com/ntdev.ms.com" }
    },

    { DS_SPN_DOMAIN, "ldap", "dc=ntdev,dc=ms,dc=com", 0,
      1,
      { "p2.b26.ms.com" },
      { 0 },
      1,
      { "ldap/p2.b26.ms.com/ntdev.ms.com" }
    },

    { DS_SPN_NB_DOMAIN, "ldap", "ntdev", 0,
      1,
      { "ntdev-dc1" },
      { 0 },
      1,
      { "ldap/ntdev-dc1/ntdev" }
    },

    { DS_SPN_SERVICE, "ldap", "info.ms.com", 0,
      1,
      { "isrv2.mis.ms.com" },
      { 0 },
      1,
      { "ldap/isrv2.mis.ms.com/info.ms.com" }
    },

    { DS_SPN_SERVICE, "http", "www.ms.com", 8080,
      0,
      { 0 },
      { 0 },
      1,
      { "http/www.ms.com:8080/www.ms.com" }
    },

    { DS_SPN_SERVICE, "ldap", "ntdev.ms.com", 0,
      1,
      { "dc1.ntdev.ms.com" },
      { 7777 },
      1,
      { "ldap/dc1.ntdev.ms.com:7777/ntdev.ms.com" }
    }



};

/* Forward */ /* Generated by Emacs 19.34.1 on Tue Aug 11 09:39:41 1998 */

int __cdecl
main(
    int argc,
    CHAR *argv[]
    );

static BOOLEAN
testWriteAccount(
    int argc,
    char *argv[]
    );

static void
usage(
    char *program
    );

BOOLEAN
runMakeSpnTestCasesA(
    void
    );

static void
dumpTestMakeSpnCase(
    PMAKE_SPN_TEST_CASE Case
    );

static BOOLEAN
runClientMakeSpnTestCasesA(
    void
    );

static void
dumpTestClientMakeSpnCase(
    PCLIENT_MAKE_SPN_TEST_CASE Case
    );

static BOOLEAN
runGetSpnTestCasesA(
    void
    );

static void
dumpGetSpnTestCase(
    PGET_SPN_TEST_CASE test
    );

static BOOLEAN
runCrackSpnTestCasesA(
    void
    );

static void
setComputernameSpnTestCases(
    void
    );

static void
allocSubstitute(
    LPSTR Input,
    LPSTR OldValue,
    LPSTR NewValue,
    LPSTR *pOutput
    );

/* End Forward */


int __cdecl
main(
    int argc,
    CHAR *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    printf( "SPN API Tests\n" );

    if (argc > 1) {
        if (!testWriteAccount(argc, argv)) {
            printf( "WriteAccountSpn test failed\n" );
        } else {
            printf( "WriteAccountSpn test succeeded\n" );
        }
        return 0;
    }

    setComputernameSpnTestCases();

    if (!runMakeSpnTestCasesA()) {
        printf( "One or more MakeSpn test cases failed\n" );
    } else {
        printf( "MakeSpn test cases were successful\n" );
    }

    if (!runClientMakeSpnTestCasesA()) {
        printf( "One or more ClientMakeSpn test cases failed\n" );
    } else {
        printf( "ClientMakeSpn test cases were successful\n" );
    }

    if (!runGetSpnTestCasesA()) {
        printf( "One or more GetSpn test cases failed\n" );
    } else {
        printf( "GetSpn test cases were successful\n" );
    }

    if (!runCrackSpnTestCasesA()) {
        printf( "One or more CrackSpn test cases failed\n" );
    } else {
        printf( "CrackSpn test cases were successful\n" );
    }

    return 0;
}


static BOOLEAN
testWriteAccount(
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status, cSpn, i;
    DS_SPN_WRITE_OP operation;
    LPSTR dcName, domainName, account;
    LPSTR pSpn[20];
    BOOLEAN error = FALSE;
    HANDLE hDS;

    if (argc < 3) {
        usage( argv[0] );
        return FALSE;
    }

    if (_stricmp( argv[1], "-register" ) == 0) {
        LPSTR class = (argc > 2) ? argv[2] : NULL;
        LPSTR DN = (argc > 3) ? argv[3] : NULL;

        status = DsServerRegisterSpnA( DS_SPN_ADD_SPN_OP, class, DN );
        if (status != ERROR_SUCCESS) {
        printf( "DsServerRegisterSpnA failed with status %d\n", status );
        error = TRUE;
        }
        goto exit;
    } else if (_stricmp( argv[1], "-deregister" ) == 0) {
        LPSTR class = (argc > 2) ? argv[2] : NULL;
        LPSTR DN = (argc > 3) ? argv[3] : NULL;

        status = DsServerRegisterSpnA( DS_SPN_DELETE_SPN_OP, class, DN );
        if (status != ERROR_SUCCESS) {
        printf( "DsServerDeregisterSpnA failed with status %d\n", status );
        error = TRUE;
        }
        goto exit;
    } else if (_stricmp( argv[1], "-add" ) == 0) {
        operation = DS_SPN_ADD_SPN_OP;
    } else if (_stricmp( argv[1], "-replace" ) == 0) {
        operation = DS_SPN_REPLACE_SPN_OP;
    } else if (_stricmp( argv[1], "-delete" ) == 0) {
        operation = DS_SPN_DELETE_SPN_OP;
    } else {
        usage( argv[0] );
        return FALSE;
    }

    if (_stricmp( argv[2], "null" ) == 0) {
        dcName = NULL;
    } else {
        dcName = argv[2];
    }

    if (_stricmp( argv[3], "null" ) == 0) {
        domainName = NULL;
    } else {
        domainName = argv[3];
    }

    if (argc < 5) {
        usage( argv[0] );
        return FALSE;
    }
    account = argv[4];

    cSpn = argc - 5;
    for( i = 5; i < (DWORD) argc; i++ ) {
        pSpn[i - 5] = argv[i];
    }

    status = DsBindA( dcName, domainName, &hDS );
    if (status != ERROR_SUCCESS) {
        printf( "DsBind failed with status %d\n", status );
        return TRUE;
    }

    status = DsWriteAccountSpnA( hDS, operation, account, cSpn, pSpn );
    if (status != ERROR_SUCCESS) {
        printf( "DsWriteAccountSpnA failed with status %d\n", status );
        error = TRUE;
    }

    status = DsUnBindA( &hDS );
    if (status != ERROR_SUCCESS) {
        printf( "DsUnBind failed with status %d\n", status );
        return TRUE;
    }

exit:

    return !error;
}


static void
usage(
    char *program
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "usage:\n" );
    printf( "%s\n", program );
    printf( "%s -register/deregister ServiceClass [objectdn]\n", program );
    printf( "%s -add|-replace|-delete dcname/null domainname/null accountDN [spn1 spn2 ...]\n", program );
}


BOOLEAN
runMakeSpnTestCasesA(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i;
    DWORD status, length;
    CHAR buffer[MAX_SPN];
    PMAKE_SPN_TEST_CASE Case;
    BOOLEAN error = FALSE;
    PCHAR instanceNameA;

    printf( "\nAscii Make SPN test cases\n" );

    for( i = 0; i < NUMBER_ELEMENTS( makeSpnTestCaseArray ); i++ ) {
        Case = makeSpnTestCaseArray + i;

        printf( "test %d SPN %s:\n", i, Case->PrincipalName );

        length = MAX_SPN;
        status = DsMakeSpnA(
            Case->ServiceClass,
            Case->ServiceName,
            Case->InstanceName,
            Case->InstancePort,
            Case->Referrer,
            &length,
            buffer );
        if (status != ERROR_SUCCESS) {
            printf( "Test case %d failed with status %d\n", i, status );
            dumpTestMakeSpnCase( Case );
            error = TRUE;
        }

        if (strcmp( Case->PrincipalName, buffer ) != 0) {
            printf( "Test case %d did not return expected result\n", i );
            printf( "\tActual Result: %s\n", buffer );
            dumpTestMakeSpnCase( Case );
            error = TRUE;
        } else if (length != (strlen( Case->PrincipalName ) + 1)) {
            printf( "Test case %d did not return expected length\n", i );
            printf( "\tActual Length: %d\tExpected Length: %d\n",
                    length, (strlen( Case->PrincipalName )+1) );
            dumpTestMakeSpnCase( Case );
            error = TRUE;
        }
    }

    // Make sure overflow detection logic works!

    Case = makeSpnTestCaseArray;

    // len != 0, buf == 0  INVALID
    printf( "test %d overflow SPN %s:\n", 100, Case->PrincipalName );
    length = 1;
    status = DsMakeSpnA(
        Case->ServiceClass,
        Case->ServiceName,
        Case->InstanceName,
        Case->InstancePort,
        Case->Referrer,
        &length,
        NULL );
    if (status != ERROR_INVALID_PARAMETER) {
        printf( "Test case %d should have failed invalid but returned %d\n", 100, status );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }

    // len == 0, buf == 0  VALID
    printf( "test %d overflow SPN %s:\n", 101, Case->PrincipalName );
    length = 0;
    status = DsMakeSpnA(
        Case->ServiceClass,
        Case->ServiceName,
        Case->InstanceName,
        Case->InstancePort,
        Case->Referrer,
        &length,
        NULL );
    if (status != ERROR_BUFFER_OVERFLOW) {
        printf( "Test case %d should have overflowed but returned %d\n", 101, status );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }
    if (length != strlen( Case->PrincipalName ) + 1) {
        printf( "Test case %d returned wrong length %d\n", 101, length );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }

    // len == 0, buf != 0  VALID
    printf( "test %d overflow SPN %s:\n", 102, Case->PrincipalName );
    length = 0;
    status = DsMakeSpnA(
        Case->ServiceClass,
        Case->ServiceName,
        Case->InstanceName,
        Case->InstancePort,
        Case->Referrer,
        &length,
        buffer );
    if (status != ERROR_BUFFER_OVERFLOW) {
        printf( "Test case %d should have overflowed but returned %d\n", 102, status );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }
    if (length != strlen( Case->PrincipalName ) + 1) {
        printf( "Test case %d returned wrong length %d\n", 102, length );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }

    // len < total, buf != 0  VALID
    printf( "test %d overflow SPN %s:\n", 103, Case->PrincipalName );
    length = 1;
    status = DsMakeSpnA(
        Case->ServiceClass,
        Case->ServiceName,
        Case->InstanceName,
        Case->InstancePort,
        Case->Referrer,
        &length,
        buffer );
    if (status != ERROR_BUFFER_OVERFLOW) {
        printf( "Test case %d should have overflowed but returned %d\n", 103, status );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }
    if (length != strlen( Case->PrincipalName ) + 1) {
        printf( "Test case %d returned wrong length %d\n", 103, length );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }

    // len = total - 1, buf != 0  VALID
    printf( "test %d overflow SPN %s:\n", 104, Case->PrincipalName );
    length = strlen( Case->PrincipalName ); // don't include terminator
    status = DsMakeSpnA(
        Case->ServiceClass,
        Case->ServiceName,
        Case->InstanceName,
        Case->InstancePort,
        Case->Referrer,
        &length,
        buffer );
    if (status != ERROR_BUFFER_OVERFLOW) {
        printf( "Test case %d should have overflowed but returned %d\n", 104, status );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }
    if (length != strlen( Case->PrincipalName ) + 1) {
        printf( "Test case %d returned wrong length %d\n", 104, length );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }

    return !error;
}


static void
dumpTestMakeSpnCase(
    PMAKE_SPN_TEST_CASE Case
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "\tService Class: %s\n", Case->ServiceClass );
    printf( "\tService Name: %s\n", Case->ServiceName );
    printf( "\tInstance Name: %s\n",
            (Case->InstanceName != NULL) ? Case->InstanceName : "not present" );
    printf( "\tInstance Port: %d\n", Case->InstancePort );
    printf( "\tReferrer: %s\n",
            (Case->Referrer != NULL) ? Case->Referrer : "not present" );
    printf( "\tExpected: %s\n", Case->PrincipalName );
}


static BOOLEAN
runClientMakeSpnTestCasesA(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
//#define WIDE_SPN L"myservice/ntdsdc0.dns.microsoft.com/ntdsdc0.dns.microsoft.com"
#define WIDE_SPN L"myservice/ntdsdc0.dns.microsoft.com"
    DWORD i;
    DWORD status, length;
    CHAR buffer[MAX_SPN];
    WCHAR wbuffer[MAX_SPN];
    PCLIENT_MAKE_SPN_TEST_CASE Case;
    BOOLEAN error = FALSE;
    WCHAR wideSpn[] = WIDE_SPN;
    DWORD wideLength = NUMBER_ELEMENTS( wideSpn );

    printf( "\nAscii DsClientMakeSpnForTargetServer test cases\n" );

    for( i = 0; i < NUMBER_ELEMENTS( clientMakeSpnTestCaseArray ); i++ ) {
        Case = clientMakeSpnTestCaseArray + i;

        printf( "test %d SPN %s/%s:\n",
                i,
                Case->ServiceClass,
                Case->InstanceName );

        length = MAX_SPN;
        status = DsClientMakeSpnForTargetServerA(
            Case->ServiceClass,
            Case->InstanceName,
            &length,
            buffer );
        if (status != ERROR_SUCCESS) {
            printf( "Test case %d failed with status %d\n", i, status );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        } else if (strcmp( Case->PrincipalName, buffer ) != 0) {
            printf( "Test case %d did not return expected result\n", i );
            printf( "\tActual Result: %s\n", buffer );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        } else if (length != (strlen( Case->PrincipalName ) + 1)) {
            printf( "Test case %d did not return expected length\n", i );
            printf( "\tActual Length: %d\tExpected Length: %d\n",
                    length, (strlen( Case->PrincipalName )+1) );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        }

        // Check length inquiry
        length = 0;
        status = DsClientMakeSpnForTargetServerA(
            Case->ServiceClass,
            Case->InstanceName,
            &length,
            NULL );
        if (status != ERROR_BUFFER_OVERFLOW) {
            printf( "Test case %d failed with status %d\n", i, status );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        } else if (length != (strlen( Case->PrincipalName ) + 1)) {
            printf( "Test case %d did not return expected length\n", i );
            printf( "\tActual Length: %d\tExpected Length: %d\n",
                    length, (strlen( Case->PrincipalName )+1) );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        }

        // Check length off by one
        length = strlen( Case->PrincipalName ); // missing terminator
        status = DsClientMakeSpnForTargetServerA(
            Case->ServiceClass,
            Case->InstanceName,
            &length,
            buffer );
        if (status != ERROR_BUFFER_OVERFLOW) {
            printf( "Test case %d failed with status %d\n", i, status );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        } else if (length != (strlen( Case->PrincipalName ) + 1)) {
            printf( "Test case %d did not return expected length\n", i );
            printf( "\tActual Length: %d\tExpected Length: %d\n",
                    length, (strlen( Case->PrincipalName )+1) );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        }
    }

    if (error) { goto exit; }

    // test bad name
    printf( "test bad name:\n" );
    length = MAX_SPN;
    status = DsClientMakeSpnForTargetServerA(
        "foobar",
        "badname",
        &length,
        buffer );
    if (status != ERROR_INVALID_DOMAINNAME) {
        printf( "test for bad name did not return expected failure, actual:%d\n", status );
        error = TRUE;
        goto exit;
    }

    // test wide name
    printf( "test wide name:\n" );
    length = MAX_SPN;
    status = DsClientMakeSpnForTargetServerW(
        L"myservice",
        L"ntdsdc0",
        &length,
        wbuffer );
    if ( (status) ||
         (0 != _wcsicmp( wideSpn, wbuffer )) ||
         (length != wideLength)) {
        printf( "wide test case did not return expected result, expected '%ws', actual '%ws', exp %d act %d\n", wideSpn, wbuffer, wideLength, length );
        error = TRUE;
        goto exit;
    }

    // test wide overflow case
    printf( "test wide name overflow:\n" );
    length = 0;
    status = DsClientMakeSpnForTargetServerW(
        L"myservice",
        L"ntdsdc0",
        &length,
        NULL );
    if ( (status != ERROR_BUFFER_OVERFLOW) ||
         (length != wideLength)) {
        printf( "wide test case overflow did not return expected result, exp %d act %d\n", wideLength, length );
        error = TRUE;
        goto exit;
    }

exit:

    return !error;
}


static void
dumpTestClientMakeSpnCase(
    PCLIENT_MAKE_SPN_TEST_CASE Case
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "\tService Class: %s\n", Case->ServiceClass );
    printf( "\tInstance Name: %s\n",
            (Case->InstanceName != NULL) ? Case->InstanceName : "not present" );
    printf( "\tExpected: %s\n", Case->PrincipalName );
}


static BOOLEAN
runGetSpnTestCasesA(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status, i, j, cSpn;
    PGET_SPN_TEST_CASE test;
    BOOLEAN error = FALSE;
    LPSTR *pSpn;

    printf( "\nGet Spn Test Cases\n" );

    for( i = 0; i < NUMBER_ELEMENTS( getSpnTestCaseData ); i++ ) {
        test = getSpnTestCaseArray + i;
        printf( "test %d (%s):\n", i, test->Spn[0] );

        cSpn = 0;
        pSpn = NULL;

        status = DsGetSpnA( test->ServiceType,
                            test->ServiceClass,
                            test->ServiceName,
                            test->InstancePort,
                            test->cInstanceNames,
                            test->cInstanceNames ? test->InstanceNames : NULL,
                            test->cInstanceNames ? test->InstancePorts : NULL,
                            &cSpn,
                            &pSpn );
        if (status != ERROR_SUCCESS) {
            printf( "DsGetSpnA failed with status %d\n", status );
            dumpGetSpnTestCase( test );
            error = TRUE;
        } else if (cSpn != test->cSpn) {
            printf( "DsGetSpnA returned unexpected number of results, exp %d, act %d\n",
                    test->cSpn, cSpn );
            dumpGetSpnTestCase( test );
            error = TRUE;
            printf( "Actual:\n" );
            for( j = 0; j < cSpn; j++ ) {
                printf( "Spn[%d] = %s\n", j, pSpn[j] );
            }
        } else {
            for( j = 0; j < cSpn; j++ ) {
                if (strcmp( pSpn[j], test->Spn[j] ) != 0) {
                    printf( "DsGetSpnA returned unexpected spn:\nExpected: '%s'\nActual: '%s'\n",
                            test->Spn[j], pSpn[j] );
                    dumpGetSpnTestCase( test );
                    error = TRUE;
                }
            }
        }

        if (pSpn) {
            DsFreeSpnArrayA( cSpn, pSpn );
        }
    }

    return !error;
}


static void
dumpGetSpnTestCase(
    PGET_SPN_TEST_CASE test
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i;

    printf( "\tService Type: %d\n", test->ServiceType );
    printf( "\tService Class: %s\n", test->ServiceClass );
    printf( "\tService Name: %s\n",
            test->ServiceName ? test->ServiceName : "not present" );
    printf( "\tInstance Port: %d\n", test->InstancePort );
    if (test->cInstanceNames) {
        printf( "\tInstance Names = %d\n", test->cInstanceNames );
        for( i = 0; i < test->cInstanceNames; i++ ) {
            printf( "\t\tname[%d] = %s, port = %d\n",
                    i, test->InstanceNames[i], test->InstancePorts[i] );
        }
    }
    printf( "\tExpected spns = %d\n", test->cSpn );
    for( i = 0; i < test->cSpn; i++ ) {
        printf( "\t\tSpn[%d] = %s\n", i, test->Spn[i] );
    }
}


static BOOLEAN
runCrackSpnTestCasesA(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status, i;
    PGET_SPN_TEST_CASE test;
    CHAR serviceClassA[MAX_NAME_LENGTH];
    CHAR serviceNameA[MAX_NAME_LENGTH];
    CHAR instanceNameA[MAX_NAME_LENGTH];
    CHAR spnA[MAX_SPN];
    DWORD serviceClassALength, serviceNameALength, instanceNameALength;
    USHORT port;
    BOOLEAN error = FALSE;
    CHAR numberBuffer[10];

    printf( "\nCrack Spn Test Cases\n" );

    // Do test with arguments null

    printf( "argument null:\n" );
    status = DsCrackSpnA( "class/instance:123/service",
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_SUCCESS) {
        printf( "DsCrackSpnA failed with unexpected status %d\n", status );
        error = TRUE;
    } else if (port != 123) {
        printf( "DsCrackSpnA returned unexpected result:\nexpected:%d\nactual:%\n",
                123, port );
    }

    status = DsCrackSpn2A( "class/instance:123/service",
    	                  strlen( "class/instance:123/service" ),
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_SUCCESS) {
        printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
        error = TRUE;
    } else if (port != 123) {
        printf( "DsCrackSpn2A returned unexpected result:\nexpected:%d\nactual:%\n",
                123, port );
    }

    // Do test with bad argument

    printf( "too many slashes:\n" );
    status = DsCrackSpnA( "class/instance:123/service/foobar",
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_INVALID_PARAMETER) {
        printf( "DsCrackSpnA failed with unexpected status %d\n", status );
        error = TRUE;
    }

    status = DsCrackSpn2A( "class/instance:123/service/foobar",
    	                  strlen( "class/instance:123/service/foobar" ),
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_INVALID_PARAMETER) {
        printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
        error = TRUE;
    }

    printf( "not enough slashes:\n" );
    status = DsCrackSpnA( "class",
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_INVALID_PARAMETER) {
        printf( "DsCrackSpnA failed with unexpected status %d\n", status );
        error = TRUE;
    }

    status = DsCrackSpn2A( "class",
    	                  strlen( "class" ),
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_INVALID_PARAMETER) {
        printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
        error = TRUE;
    }

    printf( "no slash after port #:\n" );
    status = DsCrackSpnA( "foo/bar:123xxx/yyy",
    	                  NULL, NULL,
    	                  NULL, NULL,
    	                  NULL, NULL,
    	                  &port );
    if ( status != ERROR_INVALID_PARAMETER ) {
    	printf( "DsCrackSpnA failed with unexpected status %d\n", status );
    	error = TRUE;
    }

    status = DsCrackSpn2A( "foo/bar:123xxx/yyy",
                          strlen( "foo/bar:123xxx/yyy" ),
    	                  NULL, NULL,
    	                  NULL, NULL,
    	                  NULL, NULL,
    	                  &port );
    if ( status != ERROR_INVALID_PARAMETER ) {
    	printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
    	error = TRUE;
    }

    // Try abbreviated spn without port number

    printf( "abbreviated spn, no port:\n" );
    serviceClassALength = MAX_NAME_LENGTH;
    serviceNameALength = MAX_NAME_LENGTH;
    instanceNameALength = MAX_NAME_LENGTH;
    status = DsCrackSpnA( "class/instance",
                          &serviceClassALength, serviceClassA,
                          &serviceNameALength, serviceNameA,
                          &instanceNameALength, instanceNameA,
                          &port );
    if (status != ERROR_SUCCESS) {
        printf( "DsCrackSpnA failed with unexpected status %d\n", status );
        error = TRUE;
    } else if ( (strcmp( serviceClassA, "class" )) ||
                (strcmp( instanceNameA, "instance" )) ||
                (strcmp( instanceNameA, serviceNameA )) ||
                (port) ) {
        printf( "DsCrackSpnA returned unexpected result\n" );
        error = TRUE;
    }

    serviceClassALength = MAX_NAME_LENGTH;
    serviceNameALength = MAX_NAME_LENGTH;
    instanceNameALength = MAX_NAME_LENGTH;
    status = DsCrackSpn2A( "class/instance",
    	                  strlen( "class/instance" ),
                          &serviceClassALength, serviceClassA,
                          &serviceNameALength, serviceNameA,
                          &instanceNameALength, instanceNameA,
                          &port );
    if (status != ERROR_SUCCESS) {
        printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
        error = TRUE;
    } else if ( (strcmp( serviceClassA, "class" )) ||
                (strcmp( instanceNameA, "instance" )) ||
                (strcmp( instanceNameA, serviceNameA )) ||
                (port) ) {
        printf( "DsCrackSpn2A returned unexpected result\n" );
        error = TRUE;
    }

    // Try abbreviated spn with port number

    printf( "abbreviated spn, with port:\n" );
    serviceClassALength = MAX_NAME_LENGTH;
    serviceNameALength = MAX_NAME_LENGTH;
    instanceNameALength = MAX_NAME_LENGTH;
    status = DsCrackSpnA( "class/service:123",
                          &serviceClassALength, serviceClassA,
                          &serviceNameALength, serviceNameA,
                          &instanceNameALength, instanceNameA,
                          &port );
    if (status != ERROR_SUCCESS) {
        printf( "DsCrackSpnA failed with unexpected status %d\n", status );
        error = TRUE;
    } else if ( (strcmp( serviceClassA, "class" )) ||
                (strcmp( instanceNameA, "service" )) ||
                (strcmp( instanceNameA, serviceNameA )) ||
                (port != 123) ) {
        printf( "DsCrackSpnA returned unexpected result\n" );
        error = TRUE;
    }


    // Run through get spn test case data, using it for crack spn

    for( i = 0; i < NUMBER_ELEMENTS( getSpnTestCaseData ); i++ ) {
        test = getSpnTestCaseArray + i;

        printf( "test %d (%s):\n", i, test->Spn[0] );

        serviceClassALength = MAX_NAME_LENGTH;
        serviceNameALength = MAX_NAME_LENGTH;
        instanceNameALength = MAX_NAME_LENGTH;

        status = DsCrackSpnA( test->Spn[0],
                              &serviceClassALength, serviceClassA,
                              &serviceNameALength, serviceNameA,
                              &instanceNameALength, instanceNameA,
                              &port );
        if (status != ERROR_SUCCESS) {
            printf( "DsCrackSpnA failed with unexpected status %d\n", status );
            error = TRUE;
        } else if (
            (serviceClassALength != strlen( serviceClassA ) + 1) ||
            (serviceNameALength != strlen( serviceNameA ) + 1) ||
            (instanceNameALength != strlen( instanceNameA ) + 1) ) {
            printf( "DsCrackSpnA returned unexpected parameter length\n" );
            error = TRUE;
        } else {
            strcpy( spnA, serviceClassA );
            strcat( spnA, "/" );
            strcat( spnA, instanceNameA );
            if (port) {
                strcat( spnA, ":" );
                _itoa( port, numberBuffer, 10 );
                strcat( spnA, numberBuffer );
            }
            if ( ( (test->ServiceType != DS_SPN_DNS_HOST) &&
                   (test->ServiceType != DS_SPN_DN_HOST) &&
                   (test->ServiceType != DS_SPN_NB_HOST) ) ||
                 (_stricmp( serviceNameA, instanceNameA ) != 0) ) {
                strcat( spnA, "/" );
                strcat( spnA, serviceNameA );
            }

            if (strcmp( spnA, test->Spn[0] ) != 0) {
                printf( "DsCrackSpnA returned unexpected result:\nexpected:%s\nactual:%s\n",
                        test->Spn[0], spnA );
                printf( "class '%s' instance '%s' service '%s'\n",
                        serviceClassA, instanceNameA, serviceNameA );
                error = TRUE;
            }
        }

        serviceClassALength = MAX_NAME_LENGTH;
        serviceNameALength = MAX_NAME_LENGTH;
        instanceNameALength = MAX_NAME_LENGTH;

        status = DsCrackSpn2A( test->Spn[0],
        	                  test->Spn[0] ? strlen( test->Spn[0] ) : 0,
                              &serviceClassALength, serviceClassA,
                              &serviceNameALength, serviceNameA,
                              &instanceNameALength, instanceNameA,
                              &port );
        if (status != ERROR_SUCCESS) {
            printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
            error = TRUE;
        } else if (
            (serviceClassALength != strlen( serviceClassA ) + 1) ||
            (serviceNameALength != strlen( serviceNameA ) + 1) ||
            (instanceNameALength != strlen( instanceNameA ) + 1) ) {
            printf( "DsCrackSpn2A returned unexpected parameter length\n" );
            error = TRUE;
        } else {
            strcpy( spnA, serviceClassA );
            strcat( spnA, "/" );
            strcat( spnA, instanceNameA );
            if (port) {
                strcat( spnA, ":" );
                _itoa( port, numberBuffer, 10 );
                strcat( spnA, numberBuffer );
            }
            if ( ( (test->ServiceType != DS_SPN_DNS_HOST) &&
                   (test->ServiceType != DS_SPN_DN_HOST) &&
                   (test->ServiceType != DS_SPN_NB_HOST) ) ||
                 (_stricmp( serviceNameA, instanceNameA ) != 0) ) {
                strcat( spnA, "/" );
                strcat( spnA, serviceNameA );
            }

            if (strcmp( spnA, test->Spn[0] ) != 0) {
                printf( "DsCrackSpn2A returned unexpected result:\nexpected:%s\nactual:%s\n",
                        test->Spn[0], spnA );
                printf( "class '%s' instance '%s' service '%s'\n",
                        serviceClassA, instanceNameA, serviceNameA );
                error = TRUE;
            }
        }

    }

    return !error;
}


static void
setComputernameSpnTestCases(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i, j, length, status, elements;
    PGET_SPN_TEST_CASE test;
    PCLIENT_MAKE_SPN_TEST_CASE cmtest;
    CHAR computername[MAX_COMPUTERNAME_LENGTH + 1];
    CHAR computerdn[MAX_SPN + 1];
    CHAR computerdns[MAX_PATH + 1];
    struct hostent *he;

    elements = NUMBER_ELEMENTS( getSpnTestCaseData );
    length = elements * sizeof( GET_SPN_TEST_CASE );

    getSpnTestCaseArray = getSpnTestCaseData;

    for( i = 0; i < elements; i++ ) {
        test = getSpnTestCaseArray + i;
    }

    length = MAX_COMPUTERNAME_LENGTH + 1;
    if (!GetComputerName( computername, &length )) {
        status = GetLastError();
        printf( "GetComputerName failed with status %d\n", status );
        return;
    }
    length = MAX_SPN + 1;
    if (!GetComputerObjectName( NameFullyQualifiedDN, computerdn, &length )) {
        status = GetLastError();
        printf( "GetComputerNameEx failed with status %d\n", status );
        return;
    }
    // Get Dns hostname
    he = gethostbyname( "" );
    if (he == NULL) {
        status = WSAGetLastError();
        printf( "gethostbyname failed with status %d\n", status );
        return;
    }
    strcpy( computerdns, he->h_name );

    for( i = 0; i < NUMBER_ELEMENTS( clientMakeSpnTestCaseArray ); i++ ) {
        cmtest = clientMakeSpnTestCaseArray + i;

        // BUGBUG replaced value of test->Spn[i] is lost, might need to be freed?
        if (strstr( cmtest->InstanceName, COMPUTERNAME_TOKEN ) != NULL) {
            allocSubstitute( cmtest->InstanceName, COMPUTERNAME_TOKEN, computername, &(cmtest->InstanceName) );
            }
        if (strstr( cmtest->InstanceName, COMPUTERDN_TOKEN ) != NULL) {
            allocSubstitute( cmtest->InstanceName, COMPUTERDN_TOKEN, computerdn, &(cmtest->InstanceName) );
            }
        if (strstr( cmtest->InstanceName, COMPUTERDNS_TOKEN ) != NULL) {
            allocSubstitute( cmtest->InstanceName, COMPUTERDNS_TOKEN, computerdns, &(cmtest->InstanceName) );
        }

        if (strstr( cmtest->PrincipalName, COMPUTERNAME_TOKEN ) != NULL) {
            allocSubstitute( cmtest->PrincipalName, COMPUTERNAME_TOKEN, computername, &(cmtest->PrincipalName) );
            }
        if (strstr( cmtest->PrincipalName, COMPUTERDN_TOKEN ) != NULL) {
            allocSubstitute( cmtest->PrincipalName, COMPUTERDN_TOKEN, computerdn, &(cmtest->PrincipalName) );
            }
        if (strstr( cmtest->PrincipalName, COMPUTERDNS_TOKEN ) != NULL) {
            allocSubstitute( cmtest->PrincipalName, COMPUTERDNS_TOKEN, computerdns, &(cmtest->PrincipalName) );
        }
    }

    for( i = 0; i < NUMBER_ELEMENTS( getSpnTestCaseData ); i++ ) {
        test = getSpnTestCaseArray + i;

        for( j = 0; j < test->cSpn; j++ ) {

            // BUGBUG replaced value of test->Spn[i] is lost, might need to be freed?
            if (strstr( test->Spn[j], COMPUTERNAME_TOKEN ) != NULL) {
                allocSubstitute( test->Spn[j], COMPUTERNAME_TOKEN, computername, &(test->Spn[j]) );
            }
            if (strstr( test->Spn[j], COMPUTERDN_TOKEN ) != NULL) {
                allocSubstitute( test->Spn[j], COMPUTERDN_TOKEN, computerdn, &(test->Spn[j]) );
            }
            if (strstr( test->Spn[j], COMPUTERDNS_TOKEN ) != NULL) {
                allocSubstitute( test->Spn[j], COMPUTERDNS_TOKEN, computerdns, &(test->Spn[j]) );
            }
        }

    }
}


static void
allocSubstitute(
    LPSTR Input,
    LPSTR OldValue,
    LPSTR NewValue,
    LPSTR *pOutput
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD length;
    LPSTR output = NULL, p1, p2, p3;

    length = strlen( Input ) + 1 + (10 * strlen(NewValue));
    output = LocalAlloc( LPTR, length );
    if (output == NULL){
        printf( "failed to allocate %d bytes\n", length );
        return;
    }

    p3 = output;
    p1 = Input;
    while (1) {
        p2 = strstr( p1, OldValue );
        if (p2 == NULL) {
            strcpy( p3, p1 );
            break;
        }
        strncpy( p3, p1, (UINT)(p2 - p1) );
        p3 += (p2 - p1);

        strcpy( p3, NewValue );
        p3 += strlen( NewValue );

        p1 = p2 + strlen( OldValue );
    }

    *pOutput = output;
}

/* end testspn.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\test\mangle\mangle.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    testspn.c

Abstract:

    Program to test mangled rdn api functions

Author:

    Will Lees (wlees) 22-Feb-2001

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntdsapi.h>
#include <ntdsapip.h>

#define DS_MANGLE_NOT_MANGLED ((DS_MANGLE_FOR) 100)



BOOL
testCrackMangledRdn(
    void
    )

/*++

Routine Description:

    Test the DsCrackUnquotedMangledRdn API

Arguments:

    void - 

Return Value:

    BOOL - TRUE for error, FALSE for success

--*/

{
    struct _CRACK_MANGLED_RDN_TEST_CASE {
        LPSTR pszRdn;
        LPSTR pszGuid;
        DS_MANGLE_FOR eDsMangleFor;
    } testCases[] = {
        { "MPDC02\nCNF:e65c039f-e2f6-4d34-8ecb-ce70e7183299",
          "e65c039f-e2f6-4d34-8ecb-ce70e7183299",
          DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT },
        { "SLON00PDC500\nDEL:623e116d-5b60-48cb-a501-7d9c523345fd",
          "623e116d-5b60-48cb-a501-7d9c523345fd",
          DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "CN=SLON00PDC500\nDEL:623e116d-5b60-48cb-a501-7d9c523345fd",
          "623e116d-5b60-48cb-a501-7d9c523345fd",
          DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "DC=wlees4",
          NULL,
          DS_MANGLE_NOT_MANGLED }
    };
#define NUMBER_TEST_CASES (sizeof(testCases) / sizeof(testCases[0]))
    struct _CRACK_MANGLED_RDN_TEST_CASE *pTestCase;
    DWORD i, ret;
    GUID guid;
    DS_MANGLE_FOR eDsMangleFor;
    LPSTR pszGuid;
    BOOL fIsMangled;

    printf( "DsCrackUnquotedMangledRdnA Tests\n" );

    for( i = 0,pTestCase = testCases; i < NUMBER_TEST_CASES; i++,pTestCase++ ) {
        ZeroMemory( &guid, sizeof(GUID) );
        eDsMangleFor = DS_MANGLE_UNKNOWN;
        printf( "\tRdn[%d] %s\n", i, pTestCase->pszRdn );
        fIsMangled = DsCrackUnquotedMangledRdnA( pTestCase->pszRdn,
                                                 strlen( pTestCase->pszRdn ),
                                                 &guid,
                                                 &eDsMangleFor );
        if (!fIsMangled) {
            if (pTestCase->eDsMangleFor == DS_MANGLE_NOT_MANGLED) {
                continue;
            }
            printf( "DsCrackUnquotedMangledRdnA gave unexpected result\n" );
            return TRUE;
        }
        if (eDsMangleFor != pTestCase->eDsMangleFor) {
            printf( "Mangle state doesn't match\n" );
            return TRUE;
        }
        ret = UuidToString( &guid, &pszGuid );
        if (ret) {
            printf( "UuidToStsring failed with error %d\n", ret );
            return TRUE;
        }
        if (strcmp(pszGuid,pTestCase->pszGuid)) {
            printf( "Decoded guid doesn't match\n" );
            return TRUE;
        }
        RpcStringFree( &pszGuid );
    }

    return FALSE;
#undef NUMBER_TEST_CASES
} /* testCrackMangledRdn */


BOOL
testIsMangledRdn(
    void
    )

/*++

Routine Description:

    Test the IsMangledRdnValue function

Arguments:

    void - 

Return Value:

    BOOL - TRUE for error, FALSE for success

--*/

{
    struct _IS_MANGLED_RDN_TEST_CASE {
        LPSTR pszRdn;
        DS_MANGLE_FOR eDsMangleFor;
    } testCases[] = {
        { "MPDC02\nCNF:e65c039f-e2f6-4d34-8ecb-ce70e7183299",
           DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT },
        { "SLON00PDC500\nDEL:623e116d-5b60-48cb-a501-7d9c523345fd",
              DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "SLON00PDC500\\0ADEL:623e116d-5b60-48cb-a501-7d9c523345fd",
              DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "wlees4",
              DS_MANGLE_NOT_MANGLED }
    };
#define NUMBER_TEST_CASES (sizeof(testCases) / sizeof(testCases[0]))
    struct _IS_MANGLED_RDN_TEST_CASE *pTestCase;
    DWORD i, ret;
    BOOL fIsMangledForNameConflict, fIsMangledForDeletion;
    printf( "DsIsMangledRdnA Tests\n" );

    for( i = 0,pTestCase = testCases; i < NUMBER_TEST_CASES; i++,pTestCase++ ) {
        printf( "\tRdn[%d] %s\n", i, pTestCase->pszRdn );
        fIsMangledForNameConflict =
            DsIsMangledRdnValueA( pTestCase->pszRdn,
                                  strlen( pTestCase->pszRdn ),
                                  DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT );
        fIsMangledForDeletion =
            DsIsMangledRdnValueA( pTestCase->pszRdn,
                                  strlen( pTestCase->pszRdn ),
                                  DS_MANGLE_OBJECT_RDN_FOR_DELETION );
        switch (pTestCase->eDsMangleFor) {
        case DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT:
            if ( !fIsMangledForNameConflict ||
                 fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        case DS_MANGLE_OBJECT_RDN_FOR_DELETION:
            if ( fIsMangledForNameConflict ||
                 !fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        case DS_MANGLE_NOT_MANGLED:
            if ( fIsMangledForNameConflict ||
                 fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        default:
            printf( "Internal error\n" );
            return TRUE;
        }
    }

    return FALSE;
#undef NUMBER_TEST_CASES
} /* testIsMangledRdn */


BOOL
testIsMangledDn(
    void
    )

/*++

Routine Description:

    Test the IsMangledDn API

Arguments:

    void - 

Return Value:

    BOOL - TRUE for error, FALSE for success

--*/

{
    struct _IS_MANGLED_DN_TEST_CASE {
        LPSTR pszDn;
        DS_MANGLE_FOR eDsMangleFor;
    } testCases[] = {
        { "CN=MPDC02\nCNF:e65c039f-e2f6-4d34-8ecb-ce70e7183299,CN=blah",
              DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT },
        { "OU=SLON00PDC500\nDEL:623e116d-5b60-48cb-a501-7d9c523345fd,OU=foo,OU=bar",
              DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "DC=SLON00PDC500\\0ADEL:623e116d-5b60-48cb-a501-7d9c523345fd,DC=nttest,DC=microsoft,dc=com",
              DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "DC=wlees4,DC=wleesdom,DC=nttest,DC=microsoft,DC=com",
              DS_MANGLE_NOT_MANGLED }
    };
#define NUMBER_TEST_CASES (sizeof(testCases) / sizeof(testCases[0]))
    struct _IS_MANGLED_DN_TEST_CASE *pTestCase;
    DWORD i, ret;
    BOOL fIsMangledForNameConflict, fIsMangledForDeletion;
    printf( "DsIsMangledDnA Tests\n" );

    for( i = 0,pTestCase = testCases; i < NUMBER_TEST_CASES; i++,pTestCase++ ) {
        printf( "\tDn[%d] %s\n", i, pTestCase->pszDn );
        fIsMangledForNameConflict =
            DsIsMangledDnA( pTestCase->pszDn,
                            DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT );
        fIsMangledForDeletion =
            DsIsMangledDnA( pTestCase->pszDn,
                            DS_MANGLE_OBJECT_RDN_FOR_DELETION );
        switch (pTestCase->eDsMangleFor) {
        case DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT:
            if ( !fIsMangledForNameConflict ||
                 fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        case DS_MANGLE_OBJECT_RDN_FOR_DELETION:
            if ( fIsMangledForNameConflict ||
                 !fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        case DS_MANGLE_NOT_MANGLED:
            if ( fIsMangledForNameConflict ||
                 fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        default:
            printf( "Internal error\n" );
            return TRUE;
        }
    }

    return FALSE;
#undef NUMBER_TEST_CASES
} /* testIsMangledDn */


int __cdecl
main(
    int argc,
    CHAR *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    printf( "Mangled RDN API Tests\n" );

    if (testCrackMangledRdn()) {
        printf( "Failed.\n" );
    }
    if (testIsMangledRdn()) {
        printf( "Failed.\n" );
    }
    if (testIsMangledDn()) {
        printf( "Failed.\n" );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\aclguids\guidcache.h ===
{"msWMI-WMIGPO",                            {0x05630000,0x3927,0x4ede,0xbf,0x27,0xca,0x91,0xf2,0x75,0xc2,0x6f}, 2},
{"aNR",                                     {0x45b01500,0xc419,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"Receive Message",                         {0x06bd3200,0xdf3e,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"Account Restrictions",                    {0x4c164200,0x20c0,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29}, 1},
{"Check Stale Phantoms",                    {0x69ae6200,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05}, 1},
{"primaryGroupID",                          {0xbf967a00,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"shortServerName",                         {0x45b01501,0xc419,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"Peek Message",                            {0x06bd3201,0xdf3e,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"priorSetTime",                            {0xbf967a01,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Send Message",                            {0x06bd3202,0xdf3e,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"msDS-Site-Affinity",                      {0xc17c5602,0xbcb7,0x46f0,0x96,0x56,0x63,0x70,0xca,0x88,0x4b,0x72}, 2},
{"priorValue",                              {0xbf967a02,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"proxiedObjectName",                       {0xe1aea402,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Receive Journal",                         {0x06bd3203,0xdf3e,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"privateKey",                              {0xbf967a03,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"queryPolicyObject",                       {0xe1aea403,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-ID",                                {0x9339a803,0x94b8,0x47f7,0x91,0x23,0xa8,0x53,0xb9,0xff,0x7e,0x45}, 2},
{"lastLogonTimestamp",                      {0xc0e20a04,0x0e5a,0x4ff3,0x94,0x82,0x5e,0xfe,0xae,0xcd,0x70,0x60}, 2},
{"generationQualifier",                     {0x16775804,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"groupsToIgnore",                          {0xeea65904,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-SPX",                              {0x86b08004,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"aCSResourceLimits",                       {0x2e899b04,0x2834,0x11d3,0x91,0xd4,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"queryPolicyBL",                           {0xe1aea404,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"groupPriority",                           {0xeea65905,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"profilePath",                             {0xbf967a05,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-RetiredReplNCSignatures",            {0xd5b35506,0x19d6,0x4d26,0x9a,0xfb,0x11,0x35,0x7a,0xc9,0x9b,0x5e}, 2},
{"desktopProfile",                          {0xeea65906,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msDS-AzScopeName",                        {0x515a6b06,0x2617,0x4173,0x80,0x99,0xd5,0x60,0x5d,0xf0,0x43,0xc6}, 2},
{"proxyAddresses",                          {0xbf967a06,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKICriticalExtensions",                   {0xfc5a9106,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"proxyLifetime",                           {0xbf967a07,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-Cached-Membership",                  {0x69cab008,0xcdd4,0x4bc9,0xba,0xb8,0x0f,0xf3,0x7e,0xfe,0x1b,0x20}, 2},
{"pwdHistoryLength",                        {0xbf967a09,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"addressTemplate",                         {0x5fd4250a,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"pwdLastSet",                              {0xbf967a0a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-Preferred-GC-Site",                  {0xd921b50a,0x0ab2,0x42cd,0x87,0xf6,0x09,0xcf,0x83,0xa9,0x18,0x54}, 2},
{"applicationProcess",                      {0x5fd4250b,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"pwdProperties",                           {0xbf967a0b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"simpleSecurityObject",                    {0x5fe69b0b,0xe146,0x4f15,0xb0,0xab,0xc1,0xe5,0xd4,0x88,0xe0,0x94}, 2},
{"aCSMaxAggregatePeakRatePerUser",          {0xf072230c,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"displayTemplate",                         {0x5fd4250c,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"rangeLower",                              {0xbf967a0c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"altSecurityIdentities",                   {0x00fbf30c,0x91fe,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSNonReservedTxSize",                    {0xf072230d,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rangeUpper",                              {0xbf967a0d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"isCriticalSystemObject",                  {0x00fbf30d,0x91fe,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSEnableRSVPAccounting",                 {0xf072230e,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-GPSHeight",                        {0xbcdd4f0e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"name",                                    {0xbf967a0e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msPKI-OID-CPS",                           {0x5f49940e,0xa79f,0x4a51,0xbb,0x6f,0x3d,0x44,0x6a,0x54,0xdc,0x6b}, 2},
{"mS-SQL-GPSLatitude",                      {0xb222ba0e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"showInAddressBook",                       {0x3e74f60e,0x3e73,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSRSVPAccountFilesLocation",             {0xf072230f,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rDNAttID",                                {0xbf967a0f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"addressBookContainer",                    {0x3e74f60f,0x3e73,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Logon Information",                       {0x5f202010,0x79a5,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd4,0xcf}, 1},
{"aCSMaxNoOfAccountFiles",                  {0xf0722310,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"registeredAddress",                       {0xbf967a10,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-InformationURL",                   {0xa42cd510,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"aCSMaxSizeOfRSVPAccountFile",             {0xf0722311,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"groupOfUniqueNames",                      {0x0310a911,0x93a3,0x4e21,0xa7,0xa3,0x55,0xd8,0x5a,0xb2,0xc4,0x8b}, 2},
{"msDS-OperationsForAzTaskBL",              {0xa637d211,0x5739,0x4ed1,0x89,0xb2,0x88,0x97,0x45,0x48,0xbc,0x59}, 2},
{"foreignSecurityPrincipal",                {0x89e31c12,0x8530,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"MSMQ-MulticastAddress",                   {0x1d2f4412,0xf10d,0x4337,0x9b,0x48,0x6e,0x5b,0x12,0x5c,0xd2,0x65}, 2},
{"remoteServerName",                        {0xbf967a12,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"upgradeProductCode",                      {0xd9e18312,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQQueueQuota",                          {0x3f6b8e12,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msWMI-PolicyType",                        {0x595b2613,0x4109,0x4e77,0x90,0x13,0xa3,0xbb,0x4e,0xf2,0x77,0xc7}, 2},
{"msiScript",                               {0xd9e18313,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dSUISettings",                            {0x09b10f14,0x6f93,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msWMI-MergeablePolicyTemplate",           {0x07502414,0xfdca,0x4851,0xb0,0x4a,0x13,0x64,0x5b,0x11,0xd2,0x26}, 2},
{"remoteSource",                            {0xbf967a14,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"canUpgradeScript",                        {0xd9e18314,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"inetOrgPerson",                           {0x4828cc14,0x1437,0x45bc,0x9b,0x07,0xad,0x6f,0x01,0x5e,0x5f,0x28}, 2},
{"msDS-ObjectReferenceBL",                  {0x2b702515,0xc1f7,0x4b3b,0xb1,0x48,0xc0,0xe4,0xc6,0xce,0xec,0xb4}, 2},
{"accountExpires",                          {0xbf967915,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"remoteSourceType",                        {0xbf967a15,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fileExtPriority",                         {0xd9e18315,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-NC-Replica-Locations",               {0x97de9615,0xb537,0x46bc,0xac,0x0f,0x10,0x72,0x0f,0x39,0x09,0xf3}, 2},
{"Open Address List",                       {0xa1990816,0x4298,0x11d1,0xad,0xe2,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"defaultHidingValue",                      {0xb7b13116,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"replUpToDateVector",                      {0xbf967a16,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"localizedDescription",                    {0xd9e18316,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"objectCount",                             {0x34aaa216,0xb699,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msPKI-OIDLocalizedName",                  {0x7d59a816,0xbb05,0x4a72,0x97,0x1f,0x5c,0x13,0x31,0xf6,0x75,0x59}, 2},
{"msDS-SDReferenceDomain",                  {0x4c51e316,0xf628,0x43a5,0xb0,0x6b,0xff,0xb6,0x95,0xfc,0xb4,0xf3}, 2},
{"flatName",                                {0xb7b13117,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSNonReservedMinPolicedSize",            {0xb6873917,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msMQ-Custom-Recipient",                   {0x876d6817,0x35cc,0x436c,0xac,0xea,0x5e,0xf7,0x17,0x4d,0xd9,0xbe}, 2},
{"productCode",                             {0xd9e18317,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"volumeCount",                             {0x34aaa217,0xb699,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecPolicyReference",                    {0xb7b13118,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Enumerate Entire SAM Domain",             {0x91d67418,0x0135,0x4acc,0x8d,0x79,0xc0,0x8e,0x85,0x7c,0xfb,0xec}, 1},
{"adminCount",                              {0xbf967918,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"replicaSource",                           {0xbf967a18,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"nonSecurityMember",                       {0x52458018,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"physicalLocationObject",                  {0xb7b13119,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"organizationalStatus",                    {0x28596019,0x7349,0x4d2f,0xad,0xff,0x5a,0x62,0x99,0x61,0xf9,0x42}, 2},
{"adminDescription",                        {0xbf967919,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"nonSecurityMemberBL",                     {0x52458019,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"documentAuthor",                          {0xf18a8e19,0xaf5f,0x4478,0xb0,0x96,0x6f,0x35,0xc2,0x7e,0xb8,0x3f}, 2},
{"mS-SQL-OLAPDatabase",                     {0x20af031a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"adminDisplayName",                        {0xbf96791a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fRSReplicaSetGUID",                       {0x5245801a,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"replInterval",                            {0x45ba9d1a,0x56fa,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"MSMQ-SecuredSource",                      {0x8bf0221b,0x7a06,0x4d63,0x91,0xf0,0x14,0x99,0x94,0x18,0x13,0xd3}, 2},
{"msDS-AllowedDNSSuffixes",                 {0x8469441b,0x9ac4,0x4e45,0x82,0x05,0xbd,0x21,0x9d,0xbf,0x67,0x2d}, 2},
{"parentCA",                                {0x5245801b,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serviceBindingInformation",               {0xb7b1311c,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"directReports",                           {0xbf967a1c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rightsGuid",                              {0x8297931c,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"terminalServer",                          {0x6db69a1c,0x9422,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"assistant",                               {0x0296c11c,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecName",                               {0xb40ff81c,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serviceClassName",                        {0xb7b1311d,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"repsFrom",                                {0xbf967a1d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"superiorDNSRoot",                         {0x5245801d,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"appliesTo",                               {0x8297931d,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"tokenGroupsGlobalAndUniversal",           {0x46a9b11d,0x60ae,0x405a,0xb7,0xe8,0xff,0x8a,0x58,0xd4,0x56,0xd2}, 2},
{"otherFacsimileTelephoneNumber",           {0x0296c11d,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecID",                                 {0xb40ff81d,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"groupType",                               {0x9a9a021e,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-TargetType",                        {0xca2a281e,0x262b,0x4ff7,0xb4,0x19,0xbc,0x12,0x33,0x52,0xa4,0xe9}, 2},
{"msTAPI-ConferenceBlob",                   {0x4cc4601e,0x7201,0x4141,0xab,0xc8,0x3e,0x52,0x9a,0xe8,0x88,0x63}, 2},
{"repsTo",                                  {0xbf967a1e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fRSLevelLimit",                           {0x5245801e,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"foreignIdentifier",                       {0x3e97891e,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"controlAccessRight",                      {0x8297931e,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"otherMobile",                             {0x0296c11e,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecDataType",                           {0xb40ff81e,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"userSharedFolder",                        {0x9a9a021f,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"knowledgeInformation",                    {0x1677581f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSRootSecurity",                         {0x5245801f,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"nTMixedDomain",                           {0x3e97891f,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"x500uniqueIdentifier",                    {0xd07da11f,0x8a3d,0x42b6,0xb0,0xaa,0x76,0xc9,0x62,0xbe,0x71,0x9a}, 2},
{"msWMI-TargetNameSpace",                   {0x1c4ab61f,0x3420,0x44e5,0x84,0x9d,0x8b,0x5d,0xbf,0x60,0xfe,0xb7}, 2},
{"msDS-Cached-Membership-Time-Stamp",       {0x3566bf1f,0xbeee,0x4dcb,0x8a,0xbe,0xef,0x89,0xfc,0xfe,0xc6,0xc1}, 2},
{"primaryInternationalISDNNumber",          {0x0296c11f,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecData",                               {0xb40ff81f,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"userSharedFolderOther",                   {0x9a9a0220,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchLabeledURI",                        {0x16775820,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSExtensions",                           {0x52458020,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootInitialization",                   {0x3e978920,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msDS-AzApplicationVersion",               {0x7184a120,0x3ac4,0x47ae,0x84,0x8f,0xfe,0x0a,0xb2,0x07,0x84,0xd4}, 2},
{"managedBy",                               {0x0296c120,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQQueueType",                           {0x9a0dc320,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"Refresh Group Cache for Logons",          {0x9432c620,0x033c,0x4db7,0x8b,0x58,0x14,0xef,0x6d,0x0b,0xf4,0x77}, 1},
{"msDS-MembersForAzRoleBL",                 {0xececcd20,0xa7e0,0x4688,0x9c,0xcf,0x02,0xec,0xe5,0xe2,0x87,0xf5}, 2},
{"ipsecISAKMPReference",                    {0xb40ff820,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"url",                                     {0x9a9a0221,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecPolicy",                             {0xb7b13121,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"revision",                                {0xbf967a21,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dynamicLDAPServer",                       {0x52458021,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootGUID",                             {0x3e978921,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"primaryTelexNumber",                      {0x0296c121,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQJournal",                             {0x9a0dc321,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecNFAReference",                       {0xb40ff821,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"classDisplayName",                        {0x548e1c22,0xdea6,0x11d0,0xb0,0x10,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"physicalLocation",                        {0xb7b13122,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"attributeID",                             {0xbf967922,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rid",                                     {0xbf967a22,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"prefixMap",                               {0x52458022,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msPKI-RA-Policies",                       {0xd546ae22,0x0951,0x4d47,0x81,0x7e,0x1c,0x9f,0x96,0xfa,0xad,0x46}, 2},
{"mhsORAddress",                            {0x0296c122,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQQuota",                               {0x9a0dc322,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecNegotiationPolicyReference",         {0xb40ff822,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serviceAdministrationPoint",              {0xb7b13123,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"schemaIDGUID",                            {0xbf967923,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcNsBindings",                           {0xbf967a23,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"initialAuthIncoming",                     {0x52458023,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootMachineFilePath",                  {0x3e978923,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"otherMailbox",                            {0x0296c123,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQBasePriority",                        {0x9a0dc323,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecFilterReference",                    {0xb40ff823,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"schedule",                                {0xdd712224,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"subnet",                                  {0xb7b13124,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"attributeSecurityGUID",                   {0xbf967924,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcNsGroup",                              {0xbf967a24,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"initialAuthOutgoing",                     {0x52458024,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"siteGUID",                                {0x3e978924,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"managedObjects",                          {0x0296c124,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQJournalQuota",                        {0x9a0dc324,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"audio",                                   {0xd0e1d224,0xe1a0,0x42ce,0xa2,0xda,0x79,0x3b,0xa5,0x24,0x4f,0x35}, 2},
{"ipsecOwnersReference",                    {0xb40ff824,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"subnetContainer",                         {0xb7b13125,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"attributeSyntax",                         {0xbf967925,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcNsInterfaceID",                        {0xbf967a25,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"operatingSystem",                         {0x3e978925,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQLabelEx",                             {0x4580ad25,0xd407,0x48d2,0xad,0x24,0x43,0xe6,0xe5,0x67,0x93,0xd7}, 2},
{"mSMQLabel",                               {0x9a0dc325,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecBase",                               {0xb40ff825,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"queryFilter",                             {0xcbf70a26,0x7e78,0x11d2,0x99,0x21,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"applicationName",                         {0xdd712226,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"uniqueMember",                            {0x8f888726,0xf80a,0x44d7,0xb1,0xee,0xcb,0x9d,0xf2,0x13,0x92,0xc8}, 2},
{"operatingSystemVersion",                  {0x3e978926,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQAuthenticate",                        {0x9a0dc326,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecFilter",                             {0xb40ff826,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rpcNsPriority",                           {0xbf967a27,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"operatingSystemServicePack",              {0x3e978927,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQPrivacyLevel",                        {0x9a0dc327,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecNegotiationPolicy",                  {0xb40ff827,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-AzApplicationName",                  {0xdb5b0728,0x6208,0x4876,0x83,0xb7,0x95,0xd3,0xe5,0x69,0x52,0x75}, 2},
{"msDS-OperationsForAzRoleBL",              {0xf85b6228,0x3734,0x4525,0xb6,0xb7,0x3f,0x3b,0xb2,0x20,0x90,0x2c}, 2},
{"authenticationOptions",                   {0xbf967928,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcNsProfileEntry",                       {0xbf967a28,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"publicKeyPolicy",                         {0x80a67e28,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQOwnerID",                             {0x9a0dc328,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msDS-ExternalKey",                        {0xb92fd528,0x38ac,0x40d4,0x81,0x8d,0x04,0x33,0x38,0x08,0x37,0xc1}, 2},
{"ipsecISAKMPPolicy",                       {0xb40ff828,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fileLinkTracking",                        {0xdd712229,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"domainWidePolicy",                        {0x80a67e29,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQTransactional",                       {0x9a0dc329,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecNFA",                                {0xb40ff829,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"domainPolicyReference",                   {0x80a67e2a,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"Add/Remove Replica In Domain",            {0x9923a32a,0x3607,0x11d2,0xb9,0xbe,0x00,0x00,0xf8,0x7a,0x36,0xb2}, 1},
{"mSMQSites",                               {0x9a0dc32a,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"schemaFlagsEx",                           {0xbf967a2b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQOutRoutingServers",                   {0x9a0dc32b,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msWMI-IntMax",                            {0xfb920c2c,0xf294,0x4426,0x8a,0xc1,0xd2,0x4b,0x42,0xaa,0x2b,0xce}, 2},
{"auxiliaryClass",                          {0xbf96792c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"schemaVersion",                           {0xbf967a2c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQInRoutingServers",                    {0x9a0dc32c,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"badPasswordTime",                         {0xbf96792d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"searchFlags",                             {0xbf967a2d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQServiceType",                         {0x9a0dc32d,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msWMI-CreationDate",                      {0x748b0a2e,0x3351,0x4b3f,0xb1,0x71,0x2f,0x17,0x41,0x4e,0xa7,0x79}, 2},
{"badPwdCount",                             {0xbf96792e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"searchGuide",                             {0xbf967a2e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-ByteArray",                          {0xf0d8972e,0xdd5b,0x40e5,0xa5,0x1d,0x04,0x4c,0x7c,0x17,0xec,0xe7}, 2},
{"mSMQComputerType",                        {0x9a0dc32e,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mS-SQL-InformationDirectory",             {0xd0aedb2e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"builtinCreationTime",                     {0xbf96792f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"securityIdentifier",                      {0xbf967a2f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQForeign",                             {0x9a0dc32f,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"Open Connector Queue",                    {0xb4e60130,0xdf3f,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"defaultSecurityDescriptor",               {0x807a6d30,0x1669,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"builtinModifiedCount",                    {0xbf967930,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQOSType",                              {0x9a0dc330,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"cRLPartitionedRevocationList",            {0x963d2731,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"businessCategory",                        {0xbf967931,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"seeAlso",                                 {0xbf967a31,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-StringValidValues",                 {0x37609d31,0xa2bf,0x4b58,0x8f,0x53,0x2b,0x64,0xe5,0x7a,0x07,0x6d}, 2},
{"mSMQEncryptKey",                          {0x9a0dc331,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msWMI-UintSetParam",                      {0x8f4beb31,0x4e19,0x46f5,0x93,0x2e,0x5f,0xa0,0x3c,0x33,0x9b,0x1d}, 2},
{"mS-DS-CreatorSID",                        {0xc5e60132,0x1480,0x11d3,0x91,0xc1,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"certificateAuthorityObject",              {0x963d2732,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"cACertificate",                           {0xbf967932,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serialNumber",                            {0xbf967a32,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msPKI-PrivateKeyRecoveryAgent",           {0x1562a632,0x44b9,0x4a7e,0xa2,0xd3,0xe4,0x26,0xc9,0x6a,0x3a,0xcc}, 2},
{"mSMQUserSid",                             {0xc58aae32,0x56f9,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"mSMQSignKey",                             {0x9a0dc332,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"parentCACertificateChain",                {0x963d2733,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serverRole",                              {0xbf967a33,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQNameStyle",                           {0x9a0dc333,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"domainID",                                {0x963d2734,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serverState",                             {0xbf967a34,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQCSPName",                             {0x9a0dc334,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"cAConnect",                               {0x963d2735,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serviceClassID",                          {0xbf967a35,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msTAPI-RtConference",                     {0xca7b9735,0x4b2a,0x4e49,0x89,0xc3,0x99,0x02,0x53,0x34,0xdc,0x94}, 2},
{"mSMQLongLived",                           {0x9a0dc335,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"cAWEBURL",                                {0x963d2736,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Change Rid Master",                       {0xd58d5f36,0x0a98,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"serviceClassInfo",                        {0xbf967a36,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-intFlags3",                         {0xf29fa736,0xde09,0x4be4,0xb2,0x3a,0xe7,0x34,0xc1,0x24,0xba,0xcc}, 2},
{"msDS-OperationsForAzTask",                {0x1aacb436,0x2e9d,0x44a9,0x92,0x98,0xce,0x4d,0xeb,0xeb,0x6e,0xbf}, 2},
{"msDS-User-Account-Control-Computed",      {0x2cc4b836,0xb63f,0x4940,0x8d,0x23,0xea,0x7a,0xcf,0x06,0xaf,0x56}, 2},
{"mSMQVersion",                             {0x9a0dc336,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msDS-TasksForAzRoleBL",                   {0xa0dcd536,0x5158,0x42fe,0x8c,0x40,0xc0,0x0a,0x7a,0xd3,0x79,0x59}, 2},
{"cRLObject",                               {0x963d2737,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msiScriptPath",                           {0xbf967937,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serviceInstanceVersion",                  {0xbf967a37,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-AzOperation",                        {0x860abe37,0x9a9b,0x4fa4,0xb3,0xd2,0xb8,0xac,0xe5,0xdf,0x9e,0xc5}, 2},
{"mSMQSite1",                               {0x9a0dc337,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msieee80211-Data",                        {0x0e0d0938,0x2658,0x4580,0xa9,0xf6,0x7a,0x0a,0xc7,0xb5,0x66,0xcb}, 2},
{"cAUsages",                                {0x963d2738,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"codePage",                                {0xbf967938,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"adminPropertyPages",                      {0x52458038,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"primaryGroupToken",                       {0xc0ed8738,0x7efd,0x4481,0x84,0xd9,0x66,0xd2,0xdb,0x8b,0xe3,0x69}, 2},
{"mSMQSite2",                               {0x9a0dc338,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"adminContextMenu",                        {0x553fd038,0xf32e,0x11d0,0xb0,0xbc,0x00,0xc0,0x4f,0xd8,0xdc,0xa6}, 2},
{"msPKI-Key-Recovery-Agent",                {0x26ccf238,0xa08e,0x4b86,0x9a,0x82,0xa8,0xc9,0xac,0x7e,0xe5,0xcb}, 2},
{"mS-SQL-MultiProtocol",                    {0x8157fa38,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"associatedDomain",                        {0x3320fc38,0xc379,0x4c17,0xa5,0x10,0x1b,0xdf,0x61,0x33,0xc5,0xda}, 2},
{"unstructuredAddress",                     {0x50950839,0xcc4c,0x4491,0x86,0x3a,0xfc,0xf9,0x42,0xd6,0x84,0xb7}, 2},
{"previousCACertificates",                  {0x963d2739,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"st",                                      {0xbf967a39,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"shellPropertyPages",                      {0x52458039,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-UpdateScript",                       {0x146eb639,0xbb9f,0x4fc1,0xa8,0x25,0xe2,0x9e,0x00,0xc7,0x79,0x20}, 2},
{"mSMQSiteGates",                           {0x9a0dc339,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"shellContextMenu",                        {0x553fd039,0xf32e,0x11d0,0xb0,0xbc,0x00,0xc0,0x4f,0xd8,0xdc,0xa6}, 2},
{"dhcpUniqueKey",                           {0x963d273a,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-Genus",                             {0x50c8673a,0x8f56,0x4614,0x93,0x08,0x9e,0x13,0x40,0xfb,0x9a,0xf3}, 2},
{"street",                                  {0xbf967a3a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"nTFRSReplicaSet",                         {0x5245803a,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQCost",                                {0x9a0dc33a,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dhcpType",                                {0x963d273b,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"cOMClassID",                              {0xbf96793b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"subClassOf",                              {0xbf967a3b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQSignCertificates",                    {0x9a0dc33b,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"operatingSystemHotfix",                   {0xbd951b3c,0x9c96,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"pendingCACertificates",                   {0x963d273c,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-Description",                      {0x8386603c,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"cOMInterfaceID",                          {0xbf96793c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"subRefs",                                 {0xbf967a3c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQDigests",                             {0x9a0dc33c,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"previousParentCA",                        {0x963d273d,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"domainRelatedObject",                     {0x8bfd2d3d,0xefda,0x4549,0x85,0x2c,0xf8,0x5e,0x13,0x7a,0xed,0xc6}, 2},
{"cOMProgID",                               {0xbf96793d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQServices",                            {0x9a0dc33d,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"pendingParentCA",                         {0x963d273e,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-ServiceAccount",                   {0x64933a3e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msDS-App-Configuration",                  {0x90df3c3e,0x1854,0x4455,0xa5,0xd7,0xca,0xd4,0x0d,0x56,0x65,0x7a}, 2},
{"info",                                    {0xbf96793e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQQMID",                                {0x9a0dc33e,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msWMI-Query",                             {0x65fff93e,0x35e3,0x45a3,0x85,0xae,0x87,0x6c,0x67,0x18,0x29,0x7f}, 2},
{"currentParentCA",                         {0x963d273f,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"cn",                                      {0xbf96793f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"supplementalCredentials",                 {0xbf967a3f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"aCSNonReservedPeakRate",                  {0xa331a73f,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"mSMQMigrated",                            {0x9a0dc33f,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"cACertificateDN",                         {0x963d2740,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"nameServiceFlags",                        {0x80212840,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Group Membership",                        {0xbc0ac240,0x79a9,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd4,0xcf}, 1},
{"mSMQSiteID",                              {0x9a0dc340,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mS-SQL-NamedPipe",                        {0x7b91c840,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"allowedAttributes",                       {0x9a7ad940,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dhcpFlags",                               {0x963d2741,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rpcNsEntryFlags",                         {0x80212841,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"sn",                                      {0xbf967a41,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"allowedAttributesEffective",              {0x9a7ad941,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"notes",                                   {0x6d05fb41,0x246b,0x11d0,0xa9,0xc8,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"msDS-AzScriptTimeout",                    {0x87d0fb41,0x2c8b,0x41f6,0xb9,0x72,0x11,0xfd,0xfd,0x50,0xd6,0xb0}, 2},
{"dhcpIdentification",                      {0x963d2742,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rpcContainer",                            {0x80212842,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"General Information",                     {0x59ba2f42,0x79a2,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd3,0xcf}, 1},
{"msDS-ReplAttributeMetaData",              {0xd7c53242,0x724e,0x4c39,0x9d,0x4c,0x2d,0xf8,0xc9,0xd6,0x6c,0x7a}, 2},
{"allowedChildClasses",                     {0x9a7ad942,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dhcpObjName",                             {0x963d2743,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"contentIndexingAllowed",                  {0xbf967943,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"systemAuxiliaryClass",                    {0xbf967a43,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQQueue",                               {0x9a0dc343,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msDS-Approx-Immed-Subordinates",          {0xe185d243,0xf6ce,0x4adb,0xb4,0x96,0xb0,0xc0,0x05,0xd7,0x82,0x3c}, 2},
{"allowedChildClassesEffective",            {0x9a7ad943,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dhcpObjDescription",                      {0x963d2744,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"cost",                                    {0xbf967944,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"systemMayContain",                        {0xbf967a44,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-AzTaskIsRoleDefinition",             {0x7b078544,0x6c82,0x4fe9,0x87,0x2f,0xff,0x48,0xad,0x2b,0x2e,0x26}, 2},
{"mS-SQL-Location",                         {0x561c9644,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mSMQConfiguration",                       {0x9a0dc344,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"attributeTypes",                          {0x9a7ad944,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dhcpServers",                             {0x963d2745,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"c",                                       {0xbf967945,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"systemMustContain",                       {0xbf967a45,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-ReplValueMetaData",                  {0x2f5c8145,0xe1bd,0x410b,0x89,0x57,0x8b,0xfa,0x81,0xd5,0xac,0xfd}, 2},
{"mSMQEnterpriseSettings",                  {0x9a0dc345,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"canonicalName",                           {0x9a7ad945,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"associatedName",                          {0xf7fbfc45,0x85ab,0x42a4,0xa4,0x35,0x78,0x0e,0x62,0xf7,0x85,0x8b}, 2},
{"msPKI-Certificate-Policy",                {0x38942346,0xcc5b,0x424b,0xa7,0xd8,0x6f,0xfd,0x12,0x02,0x9c,0x5f}, 2},
{"dhcpSubnets",                             {0x963d2746,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"extraColumns",                            {0xd24e2846,0x1dd9,0x4bcf,0x99,0xd7,0xa6,0x22,0x7c,0xc8,0x6d,0xa7}, 2},
{"creationTime",                            {0xbf967946,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"systemOnly",                              {0xbf967a46,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"labeledURI",                              {0xc569bb46,0xc680,0x44bc,0xa2,0x73,0xe6,0xc2,0x27,0xd7,0x1b,0x45}, 2},
{"mSMQSiteLink",                            {0x9a0dc346,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dITContentRules",                         {0x9a7ad946,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dhcpMask",                                {0x963d2747,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"currentValue",                            {0xbf967947,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"systemPossSuperiors",                     {0xbf967a47,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Validated write to DNS host name",        {0x72e39547,0x7b18,0x11d1,0xad,0xef,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"DNS Host Name Attributes",                {0x72e39547,0x7b18,0x11d1,0xad,0xef,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"dNSHostName",                             {0x72e39547,0x7b18,0x11d1,0xad,0xef,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 2},
{"msWMI-Int8Max",                           {0xe3d8b547,0x003d,0x4946,0xa3,0x2b,0xdc,0x7c,0xed,0xc9,0x6b,0x74}, 2},
{"mSMQSettings",                            {0x9a0dc347,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"extendedAttributeInfo",                   {0x9a7ad947,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msDS-HasDomainNCs",                       {0x6f17e347,0xa842,0x4498,0xb8,0xb3,0x15,0xe0,0x07,0xda,0x4f,0xed}, 2},
{"msPKI-Certificate-Application-Policy",    {0xdbd90548,0xaa37,0x4202,0x99,0x66,0x8c,0x53,0x7b,0xa5,0xce,0x32}, 2},
{"rpcNsObjectID",                           {0x29401c48,0x7a27,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"dhcpRanges",                              {0x963d2748,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"objectVersion",                           {0x16775848,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msMQ-Recipient-FormatName",               {0x3bfe6748,0xb544,0x485a,0xb0,0x67,0x1b,0x31,0x0c,0x43,0x34,0xbf}, 2},
{"addressBookRoots",                        {0xf70b6e48,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"defaultClassStore",                       {0xbf967948,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"globalAddressList",                       {0xf754c748,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"extendedClassInfo",                       {0x9a7ad948,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dynamicObject",                           {0x66d51249,0x3355,0x4c1f,0xb2,0x4e,0x81,0xf2,0x52,0xac,0xa2,0x3b}, 2},
{"dhcpSites",                               {0x963d2749,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"telephoneNumber",                         {0xbf967a49,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fromEntry",                               {0x9a7ad949,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"rpcNsTransferSyntax",                     {0x29401c4a,0x7a27,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"dhcpReservations",                        {0x963d274a,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-SQLDatabase",                      {0x1d08694a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"ipPhone",                                 {0x4d146e4a,0x48d4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"teletexTerminalIdentifier",               {0xbf967a4a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-AllowAnonymousSubscription",       {0xdb77be4a,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"modifyTimeStamp",                         {0x9a7ad94a,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"superScopes",                             {0x963d274b,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"otherIpPhone",                            {0x4d146e4b,0x48d4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"presentationAddress",                     {0xa8df744b,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"telexNumber",                             {0xbf967a4b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"buildingName",                            {0xf87fa54b,0xb2c5,0x4fd7,0x88,0xc0,0xda,0xcc,0xb2,0x1d,0x93,0xc5}, 2},
{"dSCorePropagationData",                   {0xd167aa4b,0x8b08,0x11d2,0x99,0x39,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"objectClasses",                           {0x9a7ad94b,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msPKI-RA-Signature",                      {0xfe17e04b,0x937d,0x4f7e,0x8e,0x0e,0x92,0x92,0xc8,0xd5,0x68,0x3e}, 2},
{"superScopeDescription",                   {0x963d274c,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"siteObject",                              {0x3e10944c,0xc354,0x11d0,0xaf,0xf8,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"possibleInferiors",                       {0x9a7ad94c,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msDS-Other-Settings",                     {0x79d2f34c,0x9d7d,0x42bb,0x83,0x8f,0x86,0x6b,0x3e,0x44,0x00,0xe2}, 2},
{"optionDescription",                       {0x963d274d,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msCOM-UserLink",                          {0x9e6f3a4d,0x242c,0x4f37,0xb0,0x68,0x36,0xb5,0x7f,0x9f,0xc8,0x52}, 2},
{"localPolicyReference",                    {0x80a67e4d,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"siteObjectBL",                            {0x3e10944d,0xc354,0x11d0,0xaf,0xf8,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"subSchemaSubEntry",                       {0x9a7ad94d,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"optionsLocation",                         {0x963d274e,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Recalculate Hierarchy",                   {0x0bc1554e,0x0a99,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"qualityOfService",                        {0x80a67e4e,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"documentLocation",                        {0xb958b14e,0xac6d,0x4ec4,0x88,0x92,0xbe,0x70,0xb6,0x9f,0x72,0x81}, 2},
{"mS-SQL-SQLPublication",                   {0x17c2f64e,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"dhcpOptions",                             {0x963d274f,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"department",                              {0xbf96794f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"machineWidePolicy",                       {0x80a67e4f,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"applicationEntity",                       {0x3fdfee4f,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dhcpClasses",                             {0x963d2750,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"purportedSearch",                         {0xb4b54e50,0x943a,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"description",                             {0xbf967950,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"hideFromAB",                              {0xec05b750,0xa977,0x4efe,0x8e,0x8d,0xba,0x6c,0x1a,0x6e,0x33,0xa8}, 2},
{"thumbnailPhoto",                          {0x8d3bca50,0x1d7e,0x11d0,0xa0,0x81,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"certificationAuthority",                  {0x3fdfee50,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-AzAdminManager",                     {0xcfee1051,0x5f28,0x4bae,0xa8,0x63,0x5d,0x0c,0xc1,0x8a,0x8e,0xd1}, 2},
{"mscopeId",                                {0x963d2751,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"destinationIndicator",                    {0xbf967951,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-ScopeGuid",                         {0x87b78d51,0x405f,0x4b7f,0x80,0xed,0x2b,0xd2,0x87,0x86,0xf4,0x8d}, 2},
{"Domain Administer Server",                {0xab721a52,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b}, 1},
{"dhcpState",                               {0x963d2752,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQSiteGatesMig",                        {0xe2704852,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msDS-TasksForAzTaskBL",                   {0xdf446e52,0xb5fa,0x4ca2,0xa4,0x2f,0x13,0xf9,0x8a,0x52,0x6c,0x8f}, 2},
{"mSMQInterval2",                           {0x99b88f52,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"lDAPAdminLimits",                         {0x7359a352,0x90f7,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dSA",                                     {0x3fdfee52,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"friendlyCountry",                         {0xc498f152,0xdc6b,0x474a,0x9f,0x52,0x7c,0xdb,0xa3,0xd7,0xd3,0x51}, 2},
{"Change Password",                         {0xab721a53,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b}, 1},
{"dhcpProperties",                          {0x963d2753,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"options",                                 {0x19195a53,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"displayName",                             {0xbf967953,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"lDAPIPDenyList",                          {0x7359a353,0x90f7,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-AzOperationID",                      {0xa5f3b553,0x5d76,0x4cbe,0xba,0x3f,0x43,0x12,0x15,0x2c,0xab,0x18}, 2},
{"Public Information",                      {0xe48d0154,0xbcf8,0x11d1,0x87,0x02,0x00,0xc0,0x4f,0xb9,0x60,0x50}, 1},
{"Send As",                                 {0xab721a54,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b}, 1},
{"dhcpMaxKey",                              {0x963d2754,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-CreationDate",                     {0xede14754,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mS-SQL-AllowKnownPullSubscription",       {0xc3bb7054,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"displayNamePrintable",                    {0xbf967954,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-AzScope",                            {0x4feae054,0xce55,0x47bb,0x86,0x0e,0x5b,0x12,0x06,0x3a,0x51,0xde}, 2},
{"Send To",                                 {0xab721a55,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b}, 1},
{"dhcpUpdateTime",                          {0x963d2755,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dc",                                      {0x19195a55,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"title",                                   {0xbf967a55,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Receive As",                              {0xab721a56,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b}, 1},
{"dHCPClass",                               {0x963d2756,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-AzBizRuleLanguage",                  {0x52994b56,0x0e6c,0x4e07,0xaa,0x5c,0xef,0x9d,0x7f,0x5a,0x0e,0x25}, 2},
{"Reanimate Tombstones",                    {0x45ec5156,0xdb7e,0x47bb,0xb5,0x3f,0xdb,0xeb,0x2d,0x03,0xc4,0x0f}, 1},
{"notificationList",                        {0x19195a56,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msWMI-RangeParam",                        {0x45fb5a57,0x5018,0x4d0f,0x90,0x56,0x99,0x7c,0x8c,0x91,0x22,0xd9}, 2},
{"msDS-Behavior-Version",                   {0xd31a8757,0x2447,0x4545,0x80,0x81,0x3b,0xb6,0x10,0xca,0xcb,0xf2}, 2},
{"personalTitle",                           {0x16775858,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchConfigurationContainer",            {0xd03d6858,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"mS-SQL-Publisher",                        {0xc1676858,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mSMQNt4Flags",                            {0xeb38a158,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"dnsRoot",                                 {0xbf967959,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"trustAuthIncoming",                       {0xbf967a59,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Int8Default",                       {0xf4d8085a,0x8c5b,0x4785,0x95,0x9b,0xdc,0x58,0x55,0x66,0xe4,0x45}, 2},
{"msDS-ExecuteScriptPassword",              {0x9d054a5a,0xd187,0x46c1,0x9d,0x85,0x42,0xdf,0xc4,0x4a,0x56,0xdd}, 2},
{"domain",                                  {0x19195a5a,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"trustAttributes",                         {0x80a67e5a,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"Migrate SID History",                     {0xba33815a,0x4f93,0x4c76,0x87,0xf3,0x57,0x57,0x4b,0xff,0x81,0x09}, 1},
{"msDS-NCReplInboundNeighbors",             {0x9edba85a,0x3e9e,0x431b,0x9b,0x1a,0xa5,0xb6,0xe9,0xed,0xa7,0x96}, 2},
{"domainDNS",                               {0x19195a5b,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-SQLRepository",                    {0x11d43c5c,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msDS-AllUsersTrustQuota",                 {0xd3aa4a5c,0x4e03,0x4810,0x97,0xaa,0x2b,0x33,0x9e,0x7a,0x43,0x4b}, 2},
{"applicationSiteSettings",                 {0x19195a5c,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"trustDirection",                          {0xbf967a5c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-AzLastImportedBizRulePath",          {0x665acb5c,0xbb92,0x4dbc,0x8c,0x59,0xb3,0x63,0x8e,0xab,0x09,0xb3}, 2},
{"msPKI-Enterprise-Oid",                    {0x37cfd85c,0x6719,0x4ad8,0x8f,0x9e,0x86,0x78,0xba,0x62,0x75,0x63}, 2},
{"otherWellKnownObjects",                   {0x1ea64e5d,0xac0f,0x11d2,0x90,0xdf,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"nTDSSiteSettings",                        {0x19195a5d,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"domainPolicyObject",                      {0xbf96795d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"trustPartner",                            {0xbf967a5d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"domainReplica",                           {0xbf96795e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"trustPosixOffset",                        {0xbf967a5e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"interSiteTopologyGenerator",              {0xb7c69e5e,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08}, 2},
{"nTDSService",                             {0x19195a5f,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"trustAuthOutgoing",                       {0xbf967a5f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Class",                             {0x90c1925f,0x4a24,0x4b07,0xb2,0x02,0xbe,0x32,0xeb,0x3c,0x8b,0x74}, 2},
{"interSiteTopologyRenew",                  {0xb7c69e5f,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08}, 2},
{"nTDSConnection",                          {0x19195a60,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"Domain Password & Lockout Policies",      {0xc7407360,0x20bf,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29}, 1},
{"trustType",                               {0xbf967a60,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"interSiteTopologyFailover",               {0xb7c69e60,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08}, 2},
{"tombstoneLifetime",                       {0x16c3a860,0x1273,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"Update Schema Cache",                     {0xbe2bb760,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05}, 1},
{"addressEntryDisplayTable",                {0x5fd42461,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"subSchema",                               {0x5a8b3261,0xc38d,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mail",                                    {0xbf967961,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"uASCompat",                               {0xbf967a61,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-AppData",                            {0x9e67d761,0xe327,0x4d55,0xbc,0x95,0x68,0x2f,0x87,0x5e,0x2f,0x8e}, 2},
{"systemFlags",                             {0xe0fa1e62,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"addressEntryDisplayTableMSDOS",           {0x5fd42462,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"employeeID",                              {0xbf967962,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msCOM-PartitionLink",                     {0x09abac62,0x043f,0x4702,0xac,0x2b,0x6c,0xa1,0x5e,0xee,0x57,0x54}, 2},
{"msiScriptName",                           {0x96a7dd62,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"addressSyntax",                           {0x5fd42463,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"enabledConnection",                       {0xbf967963,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msiScriptSize",                           {0x96a7dd63,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"addressType",                             {0x5fd42464,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"uNCName",                                 {0xbf967a64,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"installUiLevel",                          {0x96a7dd64,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dnsAllowDynamic",                         {0xe0fa1e65,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"roleOccupant",                            {0xa8df7465,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"appSchemaVersion",                        {0x96a7dd65,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQQueueJournalQuota",                   {0x8e441266,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"dnsAllowXFR",                             {0xe0fa1e66,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"extendedCharsAllowed",                    {0xbf967966,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dnsSecureSecondaries",                    {0xe0fa1e67,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"defaultObjectCategory",                   {0x26d97367,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dnsNotifySecondaries",                    {0xe0fa1e68,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"printShareName",                          {0xba305f68,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"userAccountControl",                      {0xbf967a68,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"photo",                                   {0x9c979768,0xba1a,0x4c08,0x96,0x32,0xc6,0xa5,0xc1,0xed,0x64,0x9a}, 2},
{"Enroll",                                  {0x0e10c968,0x78fb,0x11d2,0x90,0xd4,0x00,0xc0,0x4f,0x79,0xdc,0x55}, 1},
{"ms-DS-MachineAccountQuota",               {0xd064fb68,0x1480,0x11d3,0x91,0xc1,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"dnsRecord",                               {0xe0fa1e69,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msDs-masteredBy",                         {0x60234769,0x4819,0x4615,0xa1,0xb2,0x49,0xd2,0xf1,0x19,0xac,0xb5}, 2},
{"printOwner",                              {0xba305f69,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"objectCategory",                          {0x26d97369,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"userCert",                                {0xbf967a69,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-IntId",                              {0xbc60096a,0x1b47,0x4b30,0x88,0x77,0x60,0x2c,0x93,0xf5,0x65,0x32}, 2},
{"mS-SQL-OLAPCube",                         {0x09f0506a,0xcd28,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"printNotify",                             {0xba305f6a,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"dSUIShellMaximum",                        {0xfcca766a,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"comment",                                 {0xbf967a6a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"account",                                 {0x2628a46a,0xa6ad,0x4ae0,0xb8,0x54,0x2b,0x12,0xd9,0xfe,0x6f,0x9e}, 2},
{"msPKI-Cert-Template-OID",                 {0x3164c36a,0xba26,0x468c,0x8b,0xda,0xc1,0xe5,0xcc,0x25,0x67,0x28}, 2},
{"msDS-AzDomainTimeout",                    {0x6448f56a,0xca70,0x4e2e,0xb0,0xaf,0xd2,0x0e,0x4c,0xe6,0x53,0xd0}, 2},
{"msDS-AzScriptEngineCacheMax",             {0x2629f66a,0x1f95,0x4bf3,0xa2,0x96,0x8e,0x9d,0x7b,0x9e,0x30,0xc8}, 2},
{"printStatus",                             {0xba305f6b,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"fRSReplicaSetType",                       {0x26d9736b,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-UnknownRangeParam",                 {0xb82ac26b,0xc6db,0x4098,0x92,0xc6,0x49,0xc1,0x8a,0x33,0x36,0xe1}, 2},
{"msPKI-Template-Minor-Revision",           {0x13f5236c,0x1884,0x46b1,0xb5,0xd0,0x48,0x4e,0x38,0x99,0x0d,0x58}, 2},
{"printSpooling",                           {0xba305f6c,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"sAMAccountType",                          {0x6e7b626c,0x64f2,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"fRSVersionGUID",                          {0x26d9736c,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"sPNMappings",                             {0x2ab0e76c,0x7041,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msWMI-SourceOrganization",                {0x34f7ed6c,0x615d,0x418d,0xaa,0x00,0x54,0x9a,0x7d,0x7b,0xe0,0x3e}, 2},
{"printKeepPrintedJobs",                    {0xba305f6d,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"serverReference",                         {0x26d9736d,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"userParameters",                          {0xbf967a6d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"tokenGroups",                             {0xb7c69e6d,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08}, 2},
{"document",                                {0x39bad96d,0xc2d6,0x4baf,0x88,0xab,0x7e,0x42,0x07,0x60,0x01,0x17}, 2},
{"printerName",                             {0x244b296e,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"pKIDefaultCSPs",                          {0x1ef6336e,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"driverVersion",                           {0xba305f6e,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-AllowImmediateUpdatingSubscription",{0xc4186b6e,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"serverReferenceBL",                       {0x26d9736e,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"userPassword",                            {0xbf967a6e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-TrustForestTrustInfo",               {0x29cc866e,0x49d3,0x4969,0x94,0x2e,0x1d,0xbc,0x09,0x25,0xd1,0x83}, 2},
{"pKIDefaultKeySpec",                       {0x426cae6e,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"printMediaSupported",                     {0x244b296f,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"printMaxXExtent",                         {0xba305f6f,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mailAddress",                             {0x26d9736f,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"uSNChanged",                              {0xbf967a6f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"wbemPath",                                {0x244b2970,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-Status",                           {0x9a7d4770,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"printMaxYExtent",                         {0xba305f70,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"uSNCreated",                              {0xbf967a70,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"lastKnownParent",                         {0x52ab8670,0x5709,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Reset Password",                          {0x00299570,0x246d,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29}, 1},
{"fRSFileFilter",                           {0x1be8f170,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"countryCode",                             {0x5fd42471,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"printMinXExtent",                         {0xba305f71,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"uSNDSALastObjRemoved",                    {0xbf967a71,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"lostAndFound",                            {0x52ab8671,0x5709,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"host",                                    {0x6043df71,0xfa48,0x46cf,0xab,0x7c,0xcb,0xd5,0x46,0x44,0xb2,0x2d}, 2},
{"fRSDirectoryFilter",                      {0x1be8f171,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"jpegPhoto",                               {0xbac80572,0x09c4,0x4fa9,0x9a,0xe6,0x76,0x28,0xd7,0xad,0xbe,0x0e}, 2},
{"printMinYExtent",                         {0xba305f72,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"transportDLLName",                        {0x26d97372,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"extensionName",                           {0xbf967972,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fRSUpdateTimeout",                        {0x1be8f172,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"createTimeStamp",                         {0x2df90d73,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"msDS-Auxiliary-Classes",                  {0xc4af1073,0xee50,0x4be0,0xb8,0xc0,0x89,0xa4,0x1f,0xe9,0x9a,0xbe}, 2},
{"printStaplingSupported",                  {0xba305f73,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"uSNLastObjRem",                           {0xbf967a73,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-AzTask",                             {0x1ed3a473,0x9b1b,0x418a,0xbf,0xa0,0x3a,0x37,0xb9,0x5a,0x53,0x06}, 2},
{"fRSWorkingPath",                          {0x1be8f173,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"parentGUID",                              {0x2df90d74,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"msCOM-Partition",                         {0xc9010e74,0x4e58,0x49f7,0x8a,0x89,0x5e,0x3e,0x23,0x40,0xfc,0xf8}, 2},
{"iPSECNegotiationPolicyType",              {0x07383074,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"printMemory",                             {0xba305f74,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"transportType",                           {0x26d97374,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"facsimileTelephoneNumber",                {0xbf967974,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fRSRootPath",                             {0x1be8f174,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQPrevSiteGates",                       {0x2df90d75,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"iPSECNegotiationPolicyAction",            {0x07383075,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"assetNumber",                             {0xba305f75,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"queryPolicy",                             {0x83cc7075,0xcca7,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"interSiteTransportContainer",             {0x26d97375,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msieee80211-ID",                          {0x7f73ef75,0x14c9,0x4c23,0x81,0xde,0xdd,0x07,0xa0,0x6f,0x9e,0x8b}, 2},
{"fRSStagingPath",                          {0x1be8f175,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQDependentClientServices",             {0x2df90d76,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"netbootAllowNewClients",                  {0x07383076,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"bytesPerMinute",                          {0xba305f76,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"interSiteTransport",                      {0x26d97376,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"flags",                                   {0xbf967976,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"versionNumber",                           {0xbf967a76,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQRoutingServices",                     {0x2df90d77,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"netbootLimitClients",                     {0x07383077,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"printRate",                               {0xba305f77,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msDS-AzClassId",                          {0x013a7277,0x5c2d,0x49ef,0xa7,0xde,0xb7,0x65,0xb3,0x6a,0x3f,0x6f}, 2},
{"forceLogoff",                             {0xbf967977,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"whenChanged",                             {0xbf967a77,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"unstructuredName",                        {0x9c8ef177,0x41cf,0x45c9,0x96,0x73,0x77,0x16,0xc0,0xc8,0x90,0x1b}, 2},
{"fRSDSPoll",                               {0x1be8f177,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQDsServices",                          {0x2df90d78,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"domainIdentifier",                        {0x7f561278,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"frsComputerReference",                    {0x2a132578,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootMaxClients",                       {0x07383078,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rFC822LocalPart",                         {0xb93e3a78,0xcbae,0x485e,0xa0,0x7b,0x5e,0xf4,0xae,0x50,0x56,0x86}, 2},
{"sIDHistory",                              {0x17eb4278,0xd167,0x11d0,0xb0,0x02,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"printRateUnit",                           {0xba305f78,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msWMI-Som",                               {0xab857078,0x0142,0x4406,0x94,0x5b,0x34,0xc9,0xb6,0xb1,0x33,0x72}, 2},
{"whenCreated",                             {0xbf967a78,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-SQLServer",                        {0x05f6c878,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"pKIEnrollmentAccess",                     {0x926be278,0x56f9,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"fRSFaultCondition",                       {0x1be8f178,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSTimeOfDay",                            {0x7f561279,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"frsComputerReferenceBL",                  {0x2a132579,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootCurrentClientCount",               {0x07383079,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"printNetworkAddress",                     {0xba305f79,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"fromServer",                              {0xbf967979,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"winsockAddresses",                        {0xbf967a79,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-ReplicationEpoch",                   {0x08e3aa79,0xeb1c,0x45b5,0xaf,0x7b,0x8f,0x94,0x24,0x6c,0x8e,0x41}, 2},
{"Allowed to Authenticate",                 {0x68b1d179,0x0d15,0x4d4f,0xab,0x71,0x46,0x15,0x2e,0x79,0xa7,0xbc}, 1},
{"aCSDirection",                            {0x7f56127a,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSControlDataCreation",                  {0x2a13257a,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootAnswerRequests",                   {0x0738307a,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"printMACAddress",                         {0xba305f7a,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"generatedConnection",                     {0xbf96797a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"wWWHomePage",                             {0xbf967a7a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"domainCAs",                               {0x7bfdcb7a,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msPKI-OID-User-Notice",                   {0x04c4da7a,0xe114,0x4e69,0x88,0xde,0xe2,0x93,0xf2,0xd3,0xb3,0x95}, 2},
{"trustParent",                             {0xb000ea7a,0xa086,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMaxTokenRatePerFlow",                  {0x7f56127b,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSControlInboundBacklog",                {0x2a13257b,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootAnswerOnlyValidClients",           {0x0738307b,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"x121Address",                             {0xbf967a7b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rIDSetReferences",                        {0x7bfdcb7b,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"domainCrossRef",                          {0xb000ea7b,0xa086,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMaxPeakBandwidthPerFlow",              {0x7f56127c,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSControlOutboundBacklog",               {0x2a13257c,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootNewMachineNamingPolicy",           {0x0738307c,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"transportAddressAttribute",               {0xc1dc867c,0xa261,0x11d1,0xb6,0x06,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingID",                               {0x11b6cc7c,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"documentSeries",                          {0x7a2be07c,0x302f,0x4b96,0xbc,0x90,0x07,0x95,0xd6,0x68,0x85,0xf8}, 2},
{"siteServer",                              {0x1be8f17c,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSAggregateTokenRatePerUser",            {0x7f56127d,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSFlags",                                {0x2a13257d,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootNewMachineOU",                     {0x0738307d,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-IntRangeParam",                     {0x50ca5d7d,0x5c8b,0x4ef3,0xb9,0xdf,0x5b,0x66,0xd4,0x91,0xe5,0x26}, 2},
{"governsID",                               {0xbf96797d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msPKI-Supersede-Templates",               {0x9de8ae7d,0x7a5b,0x421d,0xb5,0xe4,0x06,0x1f,0x79,0xdf,0xd5,0xd7}, 2},
{"adminMultiselectPropertyPages",           {0x18f9b67d,0x5ac6,0x4b3b,0x97,0xdb,0xd0,0xa4,0x06,0xaf,0xb7,0xba}, 2},
{"msiFileList",                             {0x7bfdcb7d,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingName",                             {0x11b6cc7d,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"licensingSiteSettings",                   {0x1be8f17d,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMaxDurationPerFlow",                   {0x7f56127e,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSMemberReference",                      {0x2a13257e,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootIntelliMirrorOSes",                {0x0738307e,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"groupAttributes",                         {0xbf96797e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKIKeyUsage",                             {0xe9b0a87e,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"categories",                              {0x7bfdcb7e,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingDescription",                      {0x11b6cc7e,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSServiceType",                          {0x7f56127f,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSMemberReferenceBL",                    {0x2a13257f,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootTools",                            {0x0738307f,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"userCertificate",                         {0xbf967a7f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"retiredReplDSASignatures",                {0x7bfdcb7f,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingKeyword",                          {0x11b6cc7f,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSTotalNoOfFlows",                       {0x7f561280,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSPartnerAuthLevel",                     {0x2a132580,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootLocallyInstalledOSes",             {0x07383080,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"attributeDisplayNames",                   {0xcb843f80,0x48d9,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"groupMembershipSAM",                      {0xbf967980,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"attributeSchema",                         {0xbf967a80,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"validAccesses",                           {0x4d2fa380,0x7f54,0x11d2,0x99,0x2a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msieee80211-DataType",                    {0x6558b180,0x35da,0x4efe,0xbe,0xed,0x52,0x1f,0x8f,0x48,0xca,0xfb}, 2},
{"mS-SQL-AllowQueuedUpdatingSubscription",  {0xc458ca80,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"rootTrust",                               {0x7bfdcb80,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingLocation",                         {0x11b6cc80,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQRoutingService",                      {0x2df90d81,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSPriority",                             {0x7f561281,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSPrimaryMember",                        {0x2a132581,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootServer",                           {0x07383081,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"homePostalAddress",                       {0x16775781,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"hasPartialReplicaNCs",                    {0xbf967981,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"builtinDomain",                           {0xbf967a81,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"catalogs",                                {0x7bfdcb81,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingProtocol",                         {0x11b6cc81,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msFRS-Hub-Member",                        {0x5643ff81,0x35b6,0x4ca9,0x95,0x12,0xba,0xf0,0xbd,0x0a,0x27,0x72}, 2},
{"mSMQDsService",                           {0x2df90d82,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSPermissionBits",                       {0x7f561282,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSServiceCommandStatus",                 {0x2a132582,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootSCPBL",                            {0x07383082,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"hasMasterNCs",                            {0xbf967982,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"classRegistration",                       {0xbf967a82,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-TasksForAzRole",                     {0x35319082,0x8c4a,0x4646,0x93,0x86,0xc2,0x94,0x9d,0x49,0x89,0x4d}, 2},
{"meetingType",                             {0x11b6cc82,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"documentIdentifier",                      {0x0b21ce82,0xff63,0x46d9,0x90,0xfb,0xc8,0xb9,0xf2,0x4e,0x97,0xb9}, 2},
{"msWMI-PropertyName",                      {0xab920883,0xe7f8,0x4d72,0xb4,0xa0,0xc0,0x44,0x98,0x97,0x50,0x9d}, 2},
{"mSMQDependentClientService",              {0x2df90d83,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSAllocableRSVPBandwidth",               {0x7f561283,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSTimeLastCommand",                      {0x2a132583,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"pekList",                                 {0x07383083,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-Rule",                              {0x3c7e6f83,0xdd0e,0x481b,0xa0,0xc2,0x74,0xcd,0x96,0xef,0x2a,0x66}, 2},
{"classSchema",                             {0xbf967a83,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"wellKnownObjects",                        {0x05308983,0x7688,0x11d1,0xad,0xed,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 2},
{"replTopologyStayOfExecution",             {0x7bfdcb83,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingApplication",                      {0x11b6cc83,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"iconPath",                                {0xf0f8ff83,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"netbootSIFFile",                          {0x2df90d84,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSMaxPeakBandwidth",                     {0x7f561284,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSTimeLastConfigChange",                 {0x2a132584,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-DS-ReplicatesNCReason",                {0x0ea12b84,0x08b3,0x11d3,0x91,0xbc,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"pekKeyChangeInterval",                    {0x07383084,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"showInAdvancedViewOnly",                  {0xbf967984,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"classStore",                              {0xbf967a84,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Size",                             {0xe9098084,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"meetingLanguage",                         {0x11b6cc84,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"streetAddress",                           {0xf0f8ff84,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"netbootMirrorDataFile",                   {0x2df90d85,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSEnableRSVPMessageLogging",             {0x7f561285,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-Parm1",                             {0x27e81485,0xb1b0,0x4a8b,0xbe,0xdd,0xce,0x19,0xa8,0x37,0xe2,0x6e}, 2},
{"fRSVersion",                              {0x2a132585,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"intellimirrorSCP",                        {0x07383085,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"homeDirectory",                           {0xbf967985,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"comConnectionPoint",                      {0xbf967a85,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msNPAllowDialin",                         {0xdb0c9085,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msDS-Replication-Notify-Subsequent-DSA-Delay",{0xd63db385,0xdd92,0x4b52,0xb1,0xd8,0x0d,0x3e,0xcc,0x0e,0x86,0xb6}, 2},
{"creator",                                 {0x7bfdcb85,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingMaxParticipants",                  {0x11b6cc85,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dNReferenceUpdate",                       {0x2df90d86,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSEventLogLevel",                        {0x7f561286,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rIDManagerReference",                     {0x66171886,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"nTFRSMember",                             {0x2a132586,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"intellimirrorGroup",                      {0x07383086,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"homeDrive",                               {0xbf967986,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"computer",                                {0xbf967a86,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Personal Information",                    {0x77b5b886,0x944a,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 1},
{"queryPoint",                              {0x7bfdcb86,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingOriginator",                       {0x11b6cc86,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dSHeuristics",                            {0xf0f8ff86,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"mSMQQueueNameExt",                        {0x2df90d87,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSEnableACSService",                     {0x7f561287,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fSMORoleOwner",                           {0x66171887,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"nTFRSSubscriptions",                      {0x2a132587,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"configuration",                           {0xbf967a87,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"indexedScopes",                           {0x7bfdcb87,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingContactInfo",                      {0x11b6cc87,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSPolicy",                               {0x7f561288,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msPKI-OID-Attribute",                     {0x8c9e1288,0x5028,0x4f4f,0xa7,0x04,0x76,0xd0,0x26,0xf2,0x46,0xef}, 2},
{"rIDAvailablePool",                        {0x66171888,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"nTFRSSubscriber",                         {0x2a132588,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"servicePrincipalName",                    {0xf3a64788,0x5306,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Validated write to service principal name",{0xf3a64788,0x5306,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 1},
{"friendlyNames",                           {0x7bfdcb88,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingOwner",                            {0x11b6cc88,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-LastDiagnosticDate",               {0xf6d6dd88,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"company",                                 {0xf0f8ff88,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"infrastructureUpdate",                    {0x2df90d89,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSSubnet",                               {0x7f561289,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rIDAllocationPool",                       {0x66171889,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"textEncodedORAddress",                    {0xa8df7489,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msNPCalledStationID",                     {0xdb0c9089,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"rIDSet",                                  {0x7bfdcb89,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingIP",                               {0x11b6cc89,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msCOM-UserPartitionSetLink",              {0x8e940c8a,0xe477,0x4367,0xb0,0x8d,0xff,0x2f,0xf9,0x42,0xdc,0xd7}, 2},
{"rIDPreviousAllocationPool",               {0x6617188a,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"displaySpecifier",                        {0xe0fa1e8a,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"userClass",                               {0x11732a8a,0xe14d,0x4cc5,0xb9,0x2f,0xd9,0x3f,0x51,0xc6,0xd8,0xe4}, 2},
{"msNPCallingStationID",                    {0xdb0c908a,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mS-SQL-UnicodeSortOrder",                 {0x72dc918a,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"createDialog",                            {0x2b09958a,0x8931,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQSiteForeign",                         {0xfd129d8a,0xd57e,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"mS-SQL-Keywords",                         {0x01e9a98a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"indexServerCatalog",                      {0x7bfdcb8a,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingScope",                            {0x11b6cc8a,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rIDUsedPool",                             {0x6617188b,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"dnsZone",                                 {0xe0fa1e8b,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msDS-AzLDAPQuery",                        {0x5e53368b,0xfc94,0x45c8,0x9d,0x7d,0xda,0xf3,0x1e,0xe7,0x11,0x2d}, 2},
{"msCOM-ObjectId",                          {0x430f678b,0x889f,0x41f2,0x98,0x43,0x20,0x3b,0x5a,0x65,0x57,0x2f}, 2},
{"container",                               {0xbf967a8b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"createWizardExt",                         {0x2b09958b,0x8931,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingAdvertiseScope",                   {0x11b6cc8b,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dMDLocation",                             {0xf0f8ff8b,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"rIDNextRID",                              {0x6617188c,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"dnsNode",                                 {0xe0fa1e8c,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-Memory",                           {0x5b5d448c,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"instanceType",                            {0xbf96798c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"country",                                 {0xbf967a8c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"meetingURL",                              {0x11b6cc8c,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rIDManager",                              {0x6617188d,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"authorityRevocationList",                 {0x1677578d,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"internationalISDNNumber",                 {0xbf96798d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"crossRef",                                {0xbf967a8d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"meetingRating",                           {0x11b6cc8d,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"machinePasswordChangeInterval",           {0xc9b6358e,0xbb38,0x11d0,0xaf,0xef,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-Parm2",                             {0x0003508e,0x9c42,0x4a76,0xa8,0xf4,0x38,0xbf,0x64,0xba,0xb0,0xde}, 2},
{"invocationId",                            {0xbf96798e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"device",                                  {0xbf967a8e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msNPSavedCallingStationID",               {0xdb0c908e,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"meetingIsEncrypted",                      {0x11b6cc8e,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"givenName",                               {0xf0f8ff8e,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"supportedApplicationContext",             {0x1677588f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-NormalizedClass",                   {0xeaba628f,0xeb8e,0x4fe9,0x83,0xfc,0x69,0x3b,0xe6,0x95,0x55,0x9b}, 2},
{"isDeleted",                               {0xbf96798f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dMD",                                     {0xbf967a8f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"meetingRecurrence",                       {0x11b6cc8f,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Apply Group Policy",                      {0xedacfd8f,0xffb3,0x11d1,0xb4,0x1d,0x00,0xa0,0xc9,0x68,0xf9,0x39}, 1},
{"samDomain",                               {0xbf967a90,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Clustered",                        {0x7778bd90,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"meetingStartTime",                        {0x11b6cc90,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"initials",                                {0xf0f8ff90,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"msDS-AdditionalDnsHostName",              {0x80863791,0xdbe9,0x4eb8,0x83,0x7e,0x7f,0x0a,0xb5,0x5d,0x9a,0xc7}, 2},
{"memberOf",                                {0xbf967991,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"samDomainBase",                           {0xbf967a91,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"meetingEndTime",                          {0x11b6cc91,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"implementedCategories",                   {0x7d6c0e92,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msieee80211-Policy",                      {0x7b9a2d92,0xb7eb,0x4382,0x97,0x72,0xc3,0xe0,0xf9,0xba,0xaf,0x94}, 2},
{"isSingleValued",                          {0xbf967992,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"server",                                  {0xbf967a92,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"carLicense",                              {0xd4159c92,0x957d,0x4a87,0x8a,0x67,0x8d,0x29,0x34,0xe0,0x16,0x49}, 2},
{"pKIEnrollmentService",                    {0xee4aa692,0x3bba,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"tokenGroupsNoGCAcceptable",               {0x040fc392,0x33df,0x11d2,0x98,0xb2,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"meetingBandwidth",                        {0x11b6cc92,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"requiredCategories",                      {0x7d6c0e93,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"keywords",                                {0xbf967993,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"meetingBlob",                             {0x11b6cc93,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-AzMinorVersion",                     {0xee85ed93,0xb209,0x4788,0x81,0x65,0xe7,0x02,0xf5,0x1b,0xfb,0xf3}, 2},
{"dSUIAdminNotification",                   {0xf6ea0a94,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"categoryId",                              {0x7d6c0e94,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-Vines",                            {0x94c56394,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msExchAssistantName",                     {0xa8df7394,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mS-SQL-GPSLongitude",                     {0xb7577c94,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"meeting",                                 {0x11b6cc94,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSMinimumPolicedSize",                   {0x8d0e7195,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"lastContentIndexed",                      {0xbf967995,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Change PDC",                              {0xbae50096,0x4752,0x11d1,0x90,0x52,0x00,0xc0,0x4f,0xc2,0xd4,0xcf}, 1},
{"packageType",                             {0x7d6c0e96,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"policyReplicationFlags",                  {0x19405b96,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"lastLogoff",                              {0xbf967996,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"setupCommand",                            {0x7d6c0e97,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"printPagesPerMinute",                     {0x19405b97,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQMigratedUser",                        {0x50776997,0x3c3d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"lastLogon",                               {0xbf967997,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"packageName",                             {0x7d6c0e98,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"privilegeDisplayName",                    {0x19405b98,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"USNIntersite",                            {0xa8df7498,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"lastSetTime",                             {0xbf967998,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-QueryLanguage",                     {0x7d3cfa98,0xc17b,0x4254,0x8b,0xd7,0x4d,0xe9,0xb9,0x32,0xa3,0x45}, 2},
{"packageFlags",                            {0x7d6c0e99,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"privilegeValue",                          {0x19405b99,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"domainPolicy",                            {0xbf967a99,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-IntSetParam",                       {0x292f0d9a,0xcf76,0x42b0,0x84,0x1f,0xb6,0x50,0xf3,0x31,0xdf,0x62}, 2},
{"versionNumberHi",                         {0x7d6c0e9a,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"secretary",                               {0x01072d9a,0x98ad,0x4a53,0x97,0x44,0xe8,0x3e,0x28,0x72,0x78,0xfb}, 2},
{"aCSPolicyName",                           {0x1cb3559a,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"privilegeAttributes",                     {0x19405b9a,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"lDAPDisplayName",                         {0xbf96799a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-TargetPath",                        {0x5006a79a,0x6bfe,0x4561,0x9f,0x52,0x13,0xcf,0x4d,0xd3,0xe5,0x60}, 2},
{"versionNumberLo",                         {0x7d6c0e9b,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMinimumDelayVariation",                {0x9c65329b,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"aCSRSVPLogFilesLocation",                 {0x1cb3559b,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"privilegeHolder",                         {0x19405b9b,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"linkID",                                  {0xbf96799b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-AzApplication",                      {0xddf8de9b,0xcba5,0x4e12,0x84,0x2e,0x28,0xd8,0xb6,0x6f,0x75,0xec}, 2},
{"lastUpdateSequence",                      {0x7d6c0e9c,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMaxNoOfLogFiles",                      {0x1cb3559c,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"documentTitle",                           {0xde265a9c,0xff2c,0x47b9,0x91,0xdc,0x6e,0x6f,0xe2,0xc4,0x30,0x62}, 2},
{"isPrivilegeHolder",                       {0x19405b9c,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dBCSPwd",                                 {0xbf96799c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"group",                                   {0xbf967a9c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRADIUSCallbackNumber",                  {0xdb0c909c,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"Change Domain Master",                    {0x014bf69c,0x7b3b,0x11d1,0x85,0xf6,0x08,0x00,0x2b,0xe7,0x4f,0xab}, 1},
{"categoryRegistration",                    {0x7d6c0e9d,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMaxSizeOfRSVPLogFile",                 {0x1cb3559d,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"isMemberOfPartialAttributeSet",           {0x19405b9d,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"lmPwdHistory",                            {0xbf96799d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"groupOfNames",                            {0xbf967a9d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"aCSDSBMPriority",                         {0x1cb3559e,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"partialAttributeSet",                     {0x19405b9e,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"localPolicyFlags",                        {0xbf96799e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"leaf",                                    {0xbf967a9e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"aCSDSBMRefresh",                          {0x1cb3559f,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"certificateRevocationList",               {0x1677579f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"defaultLocalPolicyObject",                {0xbf96799f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Mof",                               {0x6736809f,0x2064,0x443e,0xa1,0x45,0x81,0x26,0x2b,0x1f,0x13,0x66}, 2},
{"structuralObjectClass",                   {0x3860949f,0xf6a8,0x4b38,0x99,0x50,0x81,0xec,0xb6,0xbc,0x29,0x82}, 2},
{"location",                                {0x09dcb79f,0x165f,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"division",                                {0xfe6136a0,0x2073,0x11d0,0xa9,0xc2,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"aCSDSBMDeadTime",                         {0x1cb355a0,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"locality",                                {0xbf967aa0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serverName",                              {0x09dcb7a0,0x165f,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"templateRoots",                           {0xed9de9a0,0x7041,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msWMI-ChangeDate",                        {0xf9cdf7a0,0xec44,0x4937,0xa7,0x9b,0xcd,0x91,0x52,0x2b,0x3a,0xa8}, 2},
{"uid",                                     {0x0bb0fca0,0x1e89,0x429f,0x90,0x1a,0x14,0x13,0x89,0x4d,0x9f,0x59}, 2},
{"garbageCollPeriod",                       {0x5fd424a1,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"aCSCacheTimeout",                         {0x1cb355a1,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"localeID",                                {0xbf9679a1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mailRecipient",                           {0xbf967aa1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"homePhone",                               {0xf0f8ffa1,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"aCSNonReservedTxLimit",                   {0x1cb355a2,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"l",                                       {0xbf9679a2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-StringSetParam",                    {0x0bc579a2,0x1da7,0x4cea,0xb6,0x99,0x80,0x7f,0x3b,0x9d,0x63,0xa4}, 2},
{"pKICertificateTemplate",                  {0xe5209ca2,0x3bba,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"otherHomePhone",                          {0xf0f8ffa2,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"organization",                            {0xbf967aa3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Parm4",                             {0x3800d5a3,0xf1ce,0x4b82,0xa5,0x9a,0x15,0x28,0xea,0x79,0x5f,0x59}, 2},
{"mobile",                                  {0xf0f8ffa3,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"msIIS-FTPRoot",                           {0x2a7827a4,0x1483,0x49a5,0x9d,0x84,0x52,0xe3,0x81,0x21,0x56,0xb4}, 2},
{"lockOutObservationWindow",                {0xbf9679a4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"organizationalPerson",                    {0xbf967aa4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRADIUSFramedIPAddress",                 {0xdb0c90a4,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"otherPager",                              {0xf0f8ffa4,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"aCSServerList",                           {0x7cbd59a5,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msWMI-TargetObject",                      {0xc44f67a5,0x7de5,0x4a1f,0x92,0xd9,0x66,0x2b,0x57,0x36,0x4b,0x77}, 2},
{"lockoutDuration",                         {0xbf9679a5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"organizationalUnit",                      {0xbf967aa5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"otherTelephone",                          {0xf0f8ffa5,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"mS-SQL-TCPIP",                            {0x8ac263a6,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mS-SQL-CharacterSet",                     {0x696177a6,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"lockoutThreshold",                        {0xbf9679a6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"packageRegistration",                     {0xbf967aa6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"sDRightsEffective",                       {0xc3dbafa6,0x33df,0x11d2,0x98,0xb2,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"gPCWQLFilter",                            {0x7bd4c7a6,0x1add,0x4436,0x8c,0x04,0x39,0x99,0xa8,0x80,0x15,0x4c}, 2},
{"pager",                                   {0xf0f8ffa6,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"helpData16",                              {0x5fd424a7,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"person",                                  {0xbf967aa7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"co",                                      {0xf0f8ffa7,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"msDS-AzBizRule",                          {0x33d41ea8,0xc0c9,0x4c92,0x94,0x94,0xf1,0x04,0x87,0x84,0x13,0xfd}, 2},
{"helpData32",                              {0x5fd424a8,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"Recalculate Security Inheritance",        {0x62dd28a8,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05}, 1},
{"scriptPath",                              {0xbf9679a8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"printQueue",                              {0xbf967aa8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Type",                             {0xca48eba8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msWMI-Int8ValidValues",                   {0x103519a9,0xc002,0x441b,0x98,0x1a,0xb0,0xb3,0xe0,0x12,0xc8,0x03}, 2},
{"helpFileName",                            {0x5fd424a9,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"thumbnailLogo",                           {0xbf9679a9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"remoteMailRecipient",                     {0xbf967aa9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRADIUSFramedRoute",                     {0xdb0c90a9,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"documentVersion",                         {0x94b3a8a9,0xd613,0x4cec,0x9a,0xad,0x5f,0xbc,0xc1,0x04,0x6b,0x43}, 2},
{"mSMQInterval1",                           {0x8ea825aa,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"logonCount",                              {0xbf9679aa,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Replicating Directory Changes",           {0x1131f6aa,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2}, 1},
{"msCOM-PartitionSet",                      {0x250464ab,0xc417,0x497a,0x97,0x5a,0x9e,0x0d,0x45,0x9a,0x7c,0xa1}, 2},
{"logonHours",                              {0xbf9679ab,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Replication Synchronization",             {0x1131f6ab,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2}, 1},
{"nTDSDSA",                                 {0xf0f8ffab,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"logonWorkstation",                        {0xbf9679ac,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcEntry",                                {0xbf967aac,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msMQ-Group",                              {0x46b27aac,0xaafa,0x4ffb,0xb7,0x73,0xe5,0xbf,0x62,0x1e,0xe8,0x7b}, 2},
{"applicationVersion",                      {0xddc790ac,0xaf4d,0x442a,0x8f,0x0f,0xa1,0xd4,0xca,0xa7,0xdd,0x92}, 2},
{"msRRASVendorAttributeEntry",              {0xf39b98ac,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-intFlags4",                         {0xbd74a7ac,0xc493,0x4c9c,0xbd,0xfa,0x5c,0x7b,0x11,0x9c,0xa6,0xb2}, 2},
{"Manage Replication Topology",             {0x1131f6ac,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2}, 1},
{"Add GUID",                                {0x440820ad,0x65b4,0x11d1,0xa3,0xda,0x00,0x00,0xf8,0x75,0xae,0x0d}, 1},
{"uSNSource",                               {0x167758ad,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"lSACreationTime",                         {0xbf9679ad,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"samServer",                               {0xbf967aad,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRRASAttribute",                         {0xf39b98ad,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Replicating Directory Changes All",       {0x1131f6ad,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2}, 1},
{"schemaInfo",                              {0xf9fb64ae,0x93b4,0x11d2,0x99,0x45,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"lSAModifiedCount",                        {0xbf9679ae,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"secret",                                  {0xbf967aae,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rRASAdministrationDictionary",            {0xf39b98ae,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-Alias",                            {0xe0c6baae,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"machineArchitecture",                     {0xbf9679af,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"securityObject",                          {0xbf967aaf,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"securityPrincipal",                       {0xbf967ab0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-AzGenerateAudits",                   {0xf90abab0,0x186c,0x4418,0xbb,0x85,0x88,0x44,0x7c,0x87,0x22,0x2a}, 2},
{"remoteStorageGUID",                       {0x2a39c5b0,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serviceClass",                            {0xbf967ab1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"certificateTemplates",                    {0x2a39c5b1,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"crossCertificatePair",                    {0x167757b2,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"machineRole",                             {0xbf9679b2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serviceInstance",                         {0xbf967ab2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Phone and Mail Options",                  {0xe45795b2,0x9455,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 1},
{"msWMI-UintRangeParam",                    {0xd9a799b2,0xcef3,0x48b3,0xb5,0xad,0xfb,0x85,0xf8,0xdd,0x32,0x14}, 2},
{"userSMIMECertificate",                    {0xe16a9db2,0x403c,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQSiteName",                            {0xffadb4b2,0xde39,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"signatureAlgorithms",                     {0x2a39c5b2,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"site",                                    {0xbf967ab3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Web Information",                         {0xe45795b3,0x9455,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 1},
{"enrollmentProviders",                     {0x2a39c5b3,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"schemaUpdate",                            {0x1e2d06b4,0xac8f,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msTAPI-RtPerson",                         {0x53ea1cb5,0xb704,0x4df9,0x81,0x8f,0x5c,0xb4,0xec,0x86,0xca,0xc1}, 2},
{"deltaRevocationList",                     {0x167757b5,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"manager",                                 {0xbf9679b5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"storage",                                 {0xbf967ab5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"userPKCS12",                              {0x23998ab5,0x70f8,0x4007,0xa4,0xc1,0xa8,0x4a,0x38,0x31,0x1f,0x9a}, 2},
{"drink",                                   {0x1a1aa5b5,0x262e,0x4df6,0xaf,0x04,0x2c,0xf6,0xb0,0xd8,0x00,0x48}, 2},
{"msWMI-SimplePolicyTemplate",              {0x6cc8b2b5,0x12df,0x44f6,0x83,0x07,0xe7,0x4f,0x5c,0xde,0xe3,0x69}, 2},
{"aCSIdentityName",                         {0xdab029b6,0xddf7,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msWMI-StringDefault",                     {0x152e42b6,0x37c5,0x4f55,0xab,0x48,0x16,0x06,0x38,0x4a,0x9a,0xea}, 2},
{"Change Schema Master",                    {0xe12b56b6,0x0a95,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"msWMI-Parm3",                             {0x45958fb6,0x52bd,0x48ce,0x9f,0x9f,0xc2,0x71,0x2d,0x9f,0x2b,0xfc}, 2},
{"msRADIUSServiceType",                     {0xdb0c90b6,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dNSTombstoned",                           {0xd5eb2eb7,0xbe4e,0x463b,0xa2,0x14,0x63,0x4a,0x44,0xd7,0x39,0x2e}, 2},
{"mAPIID",                                  {0xbf9679b7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"top",                                     {0xbf967ab7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"houseIdentifier",                         {0xa45398b7,0xc44a,0x4eb6,0x82,0xd3,0x13,0xc1,0x09,0x46,0xdb,0xfe}, 2},
{"msDS-AzMajorVersion",                     {0xcfb9adb7,0xc4b7,0x4059,0x95,0x68,0x1e,0xd9,0xdb,0x6b,0x72,0x48}, 2},
{"serviceDNSName",                          {0x28630eb8,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-PublicationURL",                   {0xae0c11b8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"trustedDomain",                           {0xbf967ab8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-intFlags1",                         {0x18e006b9,0x6445,0x48e3,0x9d,0xcf,0xb5,0xec,0xfb,0xc4,0xdf,0x8e}, 2},
{"dmdName",                                 {0x167757b9,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"marshalledInterface",                     {0xbf9679b9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serviceDNSNameType",                      {0x28630eba,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"user",                                    {0xbf967aba,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-IntMin",                            {0x68c2e3ba,0x9837,0x4c70,0x98,0xe0,0xf0,0xc3,0x36,0x95,0xd0,0x23}, 2},
{"userPrincipalName",                       {0x28630ebb,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"maxPwdAge",                               {0xbf9679bb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"volume",                                  {0xbf967abb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"attributeCertificateAttribute",           {0xfa4693bb,0x7bc2,0x4cb9,0x81,0xa8,0xc9,0x9c,0x43,0xb7,0x90,0x5e}, 2},
{"legacyExchangeDN",                        {0x28630ebc,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-ClassDefinition",                   {0x2b9c0ebc,0xc272,0x45cb,0x99,0xd2,0x4d,0x0e,0x69,0x16,0x32,0xe0}, 2},
{"dSASignature",                            {0x167757bc,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"maxRenewAge",                             {0xbf9679bc,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-HasInstantiatedNCs",                 {0x11e9a5bc,0x4517,0x4049,0xaf,0x9c,0x51,0x55,0x4f,0xb0,0xfc,0x09}, 2},
{"treeName",                                {0x28630ebd,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"maxStorage",                              {0xbf9679bd,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"remoteStorageServicePoint",               {0x2a39c5bd,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-OperationsForAzRole",                {0x93f701be,0xfa4c,0x43b6,0xbc,0x2f,0x4d,0xbe,0xa7,0x18,0xff,0xab}, 2},
{"isDefunct",                               {0x28630ebe,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"gPLink",                                  {0xf30e3bbe,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"additionalTrustedServiceNames",           {0x032160be,0x9824,0x11d1,0xae,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDs-Schema-Extensions",                  {0xb39a61be,0xed07,0x4cab,0x9a,0x4a,0x49,0x63,0xed,0x01,0x41,0xe1}, 2},
{"maxTicketAge",                            {0xbf9679be,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rRASAdministrationConnectionPoint",       {0x2a39c5be,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"lockoutTime",                             {0x28630ebf,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"gPOptions",                               {0xf30e3bbf,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"uPNSuffixes",                             {0x032160bf,0x9824,0x11d1,0xae,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"organizationalRole",                      {0xa8df74bf,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mayContain",                              {0xbf9679bf,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msPKI-RA-Application-Policies",           {0x3c91fbbf,0x4773,0x4ccd,0xa8,0x7b,0x85,0xd5,0x3e,0x7b,0xcf,0x6a}, 2},
{"Receive Dead Letter",                     {0x4b6e08c0,0xdf3c,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"partialAttributeDeletionList",            {0x28630ec0,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"replPropertyMetaData",                    {0x281416c0,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"gPCFunctionalityVersion",                 {0xf30e3bc0,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-SortOrder",                        {0x6ddc42c0,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"assocNTAccount",                          {0x398f63c0,0xca60,0x11d1,0xbb,0xd1,0x00,0x00,0xf8,0x1f,0x10,0xc0}, 2},
{"Add/Remove self as member",               {0xbf9679c0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 1},
{"member",                                  {0xbf9679c0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serversContainer",                        {0xf780acc0,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-KeyVersionNumber",                   {0xc523e9c0,0x33b5,0x4ac8,0x89,0x23,0xb5,0x7b,0x92,0x7f,0x42,0xf6}, 2},
{"Peek Dead Letter",                        {0x4b6e08c1,0xdf3c,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"serviceConnectionPoint",                  {0x28630ec1,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"gPCFileSysPath",                          {0xf30e3bc1,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"applicationSettings",                     {0xf780acc1,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-Author",                            {0x6366c0c1,0x6972,0x4e66,0xb3,0xa5,0x1d,0x52,0xad,0x0c,0x05,0x47}, 2},
{"Receive Computer Journal",                {0x4b6e08c2,0xdf3c,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"groupPolicyContainer",                    {0xf30e3bc2,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-DS-ConsistencyGuid",                   {0x23773dc2,0xb63a,0x11d2,0x90,0xe1,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msPKI-Private-Key-Flag",                  {0xbab04ac2,0x0435,0x4709,0x93,0x07,0x28,0x38,0x0e,0x7c,0x70,0x01}, 2},
{"minPwdAge",                               {0xbf9679c2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-DS-ConsistencyChildCount",             {0x178b7bc2,0xb63a,0x11d2,0x90,0xe1,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"scopeFlags",                              {0x16f3a4c2,0x7e79,0x11d2,0x99,0x21,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"nTFRSSettings",                           {0xf780acc2,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"roomNumber",                              {0x81d7f8c2,0xe327,0x4a0d,0x91,0xc6,0xb4,0x2d,0x40,0x09,0x11,0x5f}, 2},
{"Peek Computer Journal",                   {0x4b6e08c3,0xdf3c,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"minPwdLength",                            {0xbf9679c3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"portName",                                {0x281416c4,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"minTicketAge",                            {0xbf9679c4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Build",                            {0x603e94c4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msPKI-Certificate-Name-Flag",             {0xea1dddc4,0x60ff,0x416e,0x8c,0xc0,0x17,0xce,0xe5,0x34,0xbc,0xe7}, 2},
{"driverName",                              {0x281416c5,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"modifiedCount",                           {0xbf9679c5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRASSavedCallbackNumber",                {0xdb0c90c5,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"printSeparatorFile",                      {0x281416c6,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"gPCUserExtensionNames",                   {0x42a75fc6,0x783f,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"modifiedCountAtLastProm",                 {0xbf9679c6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRASSavedFramedIPAddress",               {0xdb0c90c6,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msDS-PerUserTrustTombstonesQuota",        {0x8b70a6c6,0x50f9,0x4fa3,0xa7,0x1e,0x1c,0xe0,0x30,0x40,0x44,0x9b}, 2},
{"priority",                                {0x281416c7,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"moniker",                                 {0xbf9679c7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"uniqueIdentifier",                        {0xba0184c7,0x38c5,0x4bed,0xa5,0x26,0x75,0x42,0x14,0x70,0x58,0x0c}, 2},
{"msRASSavedFramedRoute",                   {0xdb0c90c7,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"defaultPriority",                         {0x281416c8,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"monikerDisplayName",                      {0xbf9679c8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"moveTreeState",                           {0x1f2ac2c8,0x3b71,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"printStartTime",                          {0x281416c9,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-intFlags2",                         {0x075a42c9,0xc55a,0x45b1,0xac,0x93,0xeb,0x08,0x6b,0x31,0xf6,0x10}, 2},
{"Create Inbound Forest Trust",             {0xe2a36dc9,0xae17,0x47c3,0xb5,0x8b,0xbe,0x34,0xc5,0x5b,0xa6,0x33}, 1},
{"msWMI-ObjectEncoding",                    {0x55dd81c9,0xc312,0x41f9,0xa8,0x4d,0xc6,0xad,0xbd,0xf1,0xe8,0xe1}, 2},
{"aCSNonReservedTokenSize",                 {0xa916d7c9,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msDS-AzRole",                             {0x8213eac9,0x9d55,0x44dc,0x92,0x5c,0xe9,0xa5,0x2b,0x92,0x76,0x44}, 2},
{"printEndTime",                            {0x281416ca,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"cRLDistributionPoint",                    {0x167758ca,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-LastBackupDate",                   {0xf2b6abca,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msDS-DnsRootAlias",                       {0x2143acca,0xeead,0x4d29,0xb5,0x91,0x85,0xfa,0x49,0xce,0x91,0x73}, 2},
{"printFormName",                           {0x281416cb,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"printDuplexSupported",                    {0x281416cc,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"gPCMachineExtensionNames",                {0x32ff8ecc,0x783f,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"entryTTL",                                {0xd213decc,0xd81a,0x4384,0xaa,0xc2,0xdc,0xfc,0xfd,0x63,0x1c,0xf8}, 2},
{"printBinNames",                           {0x281416cd,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-ExternalStore",                      {0x604877cd,0x9cdb,0x47c7,0xb0,0x3d,0x3d,0xaa,0xdb,0x04,0x49,0x10}, 2},
{"msDS-MembersForAzRole",                   {0xcbf7e6cd,0x85a4,0x4314,0x89,0x39,0x8b,0xfe,0x80,0x59,0x78,0x35}, 2},
{"originalDisplayTable",                    {0x5fd424ce,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"printMaxResolutionSupported",             {0x281416cf,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"connectionPoint",                         {0x5cb41ecf,0x0e4c,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"originalDisplayTableMSDOS",               {0x5fd424cf,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"rpcProfileElement",                       {0xf29653cf,0x7ad0,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msTAPI-ProtocolId",                       {0x89c1ebcf,0x7a5f,0x41fd,0x99,0xca,0xc9,0x00,0xb3,0x22,0x99,0xab}, 2},
{"printOrientationsSupported",              {0x281416d0,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"contact",                                 {0x5cb41ed0,0x0e4c,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcServerElement",                        {0xf29653d0,0x7ad0,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"Other Domain Parameters (for use by SAM)",{0xb8119fd0,0x04f6,0x4762,0xab,0x7a,0x49,0x86,0xc7,0x6b,0x3f,0x9a}, 1},
{"sAMAccountName",                          {0x3e0abfd0,0x126a,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"mS-SQL-Version",                          {0xc07cc1d0,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"preferredLanguage",                       {0x856be0d0,0x18e7,0x46e1,0x8f,0x5f,0x7e,0xe4,0xd9,0x02,0x0e,0x0d}, 2},
{"printMaxCopies",                          {0x281416d1,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Int8Min",                           {0xed1489d1,0x54cc,0x4066,0xb3,0x68,0xa0,0x0d,0xaa,0x26,0x64,0xf1}, 2},
{"localizationDisplayId",                   {0xa746f0d1,0x78d0,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"printCollate",                            {0x281416d2,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKIExpirationPeriod",                     {0x041570d2,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"room",                                    {0x7860e5d2,0xc8b0,0x4cbb,0xbd,0x45,0xd9,0x45,0x5b,0xeb,0x92,0x06}, 2},
{"printColor",                              {0x281416d3,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"perMsgDialogDisplayTable",                {0x5fd424d3,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"mustContain",                             {0xbf9679d3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"perRecipDialogDisplayTable",              {0x5fd424d4,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"mS-SQL-LastUpdatedDate",                  {0x9fcc43d4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"printLanguage",                           {0x281416d6,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"proxyGenerationEnabled",                  {0x5fd424d6,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"residentialPerson",                       {0xa8df74d6,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"nCName",                                  {0xbf9679d6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-TargetClass",                       {0x95b6d8d6,0xc9e8,0x4661,0xa2,0xbc,0x6a,0x5c,0xab,0xc0,0x4c,0x62}, 2},
{"documentPublisher",                       {0x170f09d7,0xeb69,0x448a,0x9a,0x30,0xf1,0xaf,0xec,0xfd,0x32,0xd7}, 2},
{"printAttributes",                         {0x281416d7,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-Settings",                           {0x0e1b47d7,0x40a3,0x4b48,0x8d,0x1b,0x4c,0xac,0x0c,0x1c,0xdf,0x21}, 2},
{"userWorkstations",                        {0xbf9679d7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-AllowedToDelegateTo",                {0x800d94d7,0xb7a1,0x42a1,0xb1,0x4d,0x7c,0xae,0x14,0x23,0xd0,0x7f}, 2},
{"msDS-Entry-Time-To-Die",                  {0xe1e9bad7,0xc6dd,0x4101,0xa8,0x43,0x79,0x4c,0xec,0x85,0xb0,0x38}, 2},
{"nETBIOSName",                             {0xbf9679d8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Contact",                          {0x4f6cbdd8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msDS-DateTime",                           {0x234fcbd8,0xfb52,0x4908,0xa3,0x28,0xfd,0x9f,0x6e,0x58,0xe4,0x03}, 2},
{"mS-SQL-Name",                             {0x3532dfd8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msPKI-Enrollment-Flag",                   {0xd15ef7d8,0xf226,0x46db,0xae,0x79,0xb3,0x4e,0x56,0x0b,0xd1,0x2c}, 2},
{"cOMCLSID",                                {0x281416d9,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"networkAddress",                          {0xbf9679d9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"cOMUniqueLIBID",                          {0x281416da,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"sitesContainer",                          {0x7a4117da,0xcd67,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-ConnectionURL",                    {0xa92d23da,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"bridgeheadTransportList",                 {0xd50c2cda,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"nextLevelStore",                          {0xbf9679da,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"cOMTreatAsClassId",                       {0x281416db,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"bridgeheadServerListBL",                  {0xd50c2cdb,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"nextRid",                                 {0xbf9679db,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msCOM-PartitionSetLink",                  {0x67f121dc,0x7d02,0x4c7d,0x82,0xf5,0x9a,0xd4,0xc9,0x50,0xac,0x34}, 2},
{"siteList",                                {0xd50c2cdc,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-Database",                         {0xd5a0dbdc,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"cOMOtherProgId",                          {0x281416dd,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"siteLinkList",                            {0xd50c2cdd,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Generate Resultant Set of Policy (Planning)",{0xb7b1b3dd,0xab09,0x4242,0x9e,0x30,0x99,0x80,0xe5,0xd3,0x22,0xf7}, 1},
{"cOMTypelibId",                            {0x281416de,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcNsAnnotation",                         {0x88611bde,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"siteLink",                                {0xd50c2cde,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-NonMembers",                         {0xcafcb1de,0xf23c,0x46b5,0xad,0xf7,0x1e,0x64,0x95,0x7b,0xd5,0xdb}, 2},
{"Generate Resultant Set of Policy (Logging)",{0xb7b1b3de,0xab09,0x4242,0x9e,0x30,0x99,0x80,0xe5,0xd3,0x22,0xf7}, 1},
{"vendor",                                  {0x281416df,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcGroup",                                {0x88611bdf,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"siteLinkBridge",                          {0xd50c2cdf,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-ShadowObject",                      {0xf1e44bdf,0x8dd3,0x4235,0x9c,0x86,0xf9,0x1f,0x31,0xf5,0xb5,0x69}, 2},
{"msDS-AdditionalSamAccountName",           {0x975571df,0xa4d5,0x429a,0x9f,0x59,0xcd,0xc6,0x58,0x1d,0x91,0xe6}, 2},
{"nTGroupMembers",                          {0xbf9679df,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-FilterContainers",                   {0xfb00dcdf,0xac37,0x483a,0x9c,0x12,0xac,0x53,0xa6,0x60,0x30,0x33}, 2},
{"aCSMaxTokenBucketPerFlow",                {0x81f6e0df,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"dSUIAdminMaximum",                        {0xee8d0ae0,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"rpcServer",                               {0x88611be0,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msFRS-Topology-Pref",                     {0x92aa27e0,0x5c50,0x402d,0x9e,0xc1,0xee,0x84,0x7d,0xef,0x97,0x88}, 2},
{"crossRefContainer",                       {0xef9e60e0,0x56f7,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"masteredBy",                              {0xe48e64e0,0x12c9,0x11d3,0x91,0x02,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"Do Garbage Collection",                   {0xfec364e0,0x0a98,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"rpcNsCodeset",                            {0x7a0ba0e0,0x8e98,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQDigestsMig",                          {0x0f71d8e0,0xda3b,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"rpcProfile",                              {0x88611be1,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"unicodePwd",                              {0xbf9679e1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"linkTrackSecret",                         {0x2ae80fe2,0x47b4,0x11d0,0xa1,0xa4,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"typeLibrary",                             {0x281416e2,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"syncWithObject",                          {0x037651e2,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ntPwdHistory",                            {0xbf9679e2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-TasksForAzTask",                     {0xb11c8ee2,0x5fcd,0x46a7,0x95,0xf0,0xf3,0x83,0x33,0xf0,0x96,0xcf}, 2},
{"msWMI-RealRangeParam",                    {0x6afe8fe2,0x70bc,0x4cce,0xb1,0x66,0xa9,0x6f,0x73,0x59,0xc5,0x14}, 2},
{"defaultGroup",                            {0x720bc4e2,0xa54a,0x11d0,0xaf,0xdf,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msDS-hasMasterNCs",                       {0xae2de0e2,0x59d7,0x4d47,0x8d,0x47,0xed,0x4d,0xfe,0x43,0x57,0xad}, 2},
{"treatAsLeaf",                             {0x8fd044e3,0x771f,0x11d1,0xae,0xae,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"syncMembership",                          {0x037651e3,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"nTSecurityDescriptor",                    {0xbf9679e3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"aCSNonReservedMaxSDUSize",                {0xaec2cfe3,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"syncAttributes",                          {0x037651e4,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"distinguishedName",                       {0xbf9679e4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-NCReplCursors",                      {0x8a167ce4,0xf9e8,0x47eb,0x8d,0x78,0xf7,0xfe,0x80,0xab,0xb2,0xcc}, 2},
{"syncWithSID",                             {0x037651e5,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"objectClass",                             {0xbf9679e5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Name",                              {0xc6c8ace5,0x7e81,0x42af,0xad,0x72,0x77,0x41,0x2c,0x59,0x41,0xc4}, 2},
{"mSMQNt4Stub",                             {0x6f914be6,0xd57e,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"objectClassCategory",                     {0xbf9679e6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"objectGUID",                              {0xbf9679e7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"lastBackupRestorationTime",               {0x1fbb0be8,0xba63,0x11d0,0xaf,0xef,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQComputerTypeEx",                      {0x18120de8,0xf4c4,0x4341,0xbd,0x95,0x32,0xeb,0x5b,0xcf,0x7c,0x80}, 2},
{"msDS-Security-Group-Extra-Classes",       {0x4f146ae8,0xa4fe,0x4801,0xa7,0x31,0xf5,0x18,0x48,0xa4,0xf4,0xe4}, 2},
{"objectSid",                               {0xbf9679e8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-AllowSnapshotFilesFTPDownloading", {0xc49b8be8,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msDS-ObjectReference",                    {0x638ec2e8,0x22e7,0x409c,0x85,0xd2,0x11,0xb2,0x1b,0xee,0x72,0xde}, 2},
{"msDS-AzApplicationData",                  {0x503fc3e8,0x1cc6,0x461a,0x99,0xa3,0x9e,0xee,0x04,0xf4,0x02,0xa7}, 2},
{"msIIS-FTPDir",                            {0x8a5c99e9,0x2230,0x46eb,0xb8,0xe8,0xe5,0x9d,0x71,0x2e,0xb9,0xee}, 2},
{"mS-SQL-OLAPServer",                       {0x0c7e18ea,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mS-SQL-RegisteredOwner",                  {0x48fd44ea,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msDS-Integer",                            {0x7bc64cea,0xc04e,0x4318,0xb1,0x02,0x3e,0x07,0x29,0x37,0x1a,0x65}, 2},
{"oEMInformation",                          {0xbf9679ea,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Applications",                     {0xfbcda2ea,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mSMQSignCertificatesMig",                 {0x3881b8ea,0xda3b,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msTAPI-uid",                              {0x70a4e7ea,0xb3b9,0x4643,0x89,0x18,0xe6,0xdd,0x24,0x71,0xbf,0xd4}, 2},
{"msDS-SPNSuffixes",                        {0x789ee1eb,0x8c8e,0x4e4c,0x8c,0xec,0x79,0xb3,0x1b,0x76,0x17,0xb5}, 2},
{"accountNameHistory",                      {0x031952ec,0x3b72,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"oMObjectClass",                           {0xbf9679ec,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKIOverlapPeriod",                        {0x1219a3ec,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"eFSPolicy",                               {0x8e4eb2ec,0x4712,0x11d0,0xa1,0xa0,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"creationWizard",                          {0x4d8601ed,0xac85,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"oMSyntax",                                {0xbf9679ed,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fileLinkTrackingEntry",                   {0x8e4eb2ed,0x4712,0x11d0,0xa1,0xa0,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"contextMenu",                             {0x4d8601ee,0xac85,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"fRSServiceCommand",                       {0xddac0cee,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"operatorCount",                           {0xbf9679ee,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"departmentNumber",                        {0xbe9ef6ee,0xcbc7,0x4f22,0xb2,0x7b,0x96,0x96,0x7e,0x7e,0xe5,0x85}, 2},
{"employeeNumber",                          {0xa8df73ef,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"o",                                       {0xbf9679ef,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"timeVolChange",                           {0xddac0cf0,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"isEphemeral",                             {0xf4c453f0,0xc5f1,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"employeeType",                            {0xa8df73f0,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ou",                                      {0xbf9679f0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-PerUserTrustQuota",                  {0xd161adf0,0xca24,0x4993,0xa3,0xaa,0x8b,0x2c,0x98,0x13,0x02,0xe8}, 2},
{"pKTGuid",                                 {0x8447f9f0,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"timeRefresh",                             {0xddac0cf1,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"otherLoginWorkstations",                  {0xbf9679f1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-PolicyTemplate",                    {0xe2bc80f1,0x244a,0x4d59,0xac,0xc6,0xca,0x5c,0x4f,0x82,0xe6,0xe1}, 2},
{"pKT",                                     {0x8447f9f1,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"seqNotification",                         {0xddac0cf2,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"Enabled",                                 {0xa8df73f2,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"middleName",                              {0xbf9679f2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dfsConfiguration",                        {0x8447f9f2,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"oMTGuid",                                 {0xddac0cf3,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"owner",                                   {0xbf9679f3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fTDfs",                                   {0x8447f9f3,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"linkTrackVolumeTable",                    {0xddac0cf4,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-Language",                         {0xc57f72f4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"ownerBL",                                 {0xbf9679f4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-AppleTalk",                        {0x8fda89f4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msDS-Replication-Notify-First-DSA-Delay", {0x85abd4f4,0x0a89,0x4e49,0xbd,0xec,0x6f,0x35,0xbb,0x25,0x62,0xba}, 2},
{"printNumberUp",                           {0x3bcbfcf4,0x4d3d,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"linkTrackObjectMoveTable",                {0xddac0cf5,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msDS-NCReplOutboundNeighbors",            {0x855f2ef5,0xa1c5,0x4cc4,0xba,0x6d,0x32,0x52,0x28,0x48,0xb6,0x1f}, 2},
{"msPKI-Minimal-Key-Size",                  {0xe96a63f5,0x417f,0x46d3,0xbe,0x52,0xdb,0x77,0x03,0xc5,0x03,0xdf}, 2},
{"msPKI-Template-Schema-Version",           {0x0c15e9f5,0x491d,0x4594,0x91,0x8f,0x32,0x81,0x3a,0x09,0x1d,0xa9}, 2},
{"printMediaReady",                         {0x3bcbfcf5,0x4d3d,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"linkTrackVolEntry",                       {0xddac0cf6,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msWMI-IntValidValues",                    {0x6af565f6,0xa749,0x4b72,0x96,0x34,0x3c,0x5d,0x47,0xe6,0xb4,0xe0}, 2},
{"pKIExtendedKeyUsage",                     {0x18976af6,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"linkTrackOMTEntry",                       {0xddac0cf7,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msCOM-DefaultPartitionLink",              {0x998b10f7,0xaa1a,0x4364,0xb8,0x67,0x75,0x3d,0x19,0x7f,0xe6,0x70}, 2},
{"physicalDeliveryOfficeName",              {0xbf9679f7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msTAPI-IpAddress",                        {0xefd7d7f7,0x178e,0x4767,0x87,0xfa,0xf8,0xa1,0x6b,0x84,0x05,0x44}, 2},
{"msWMI-IntDefault",                        {0x1b0c07f8,0x76dd,0x4060,0xa1,0xe1,0x70,0x08,0x46,0x19,0xdc,0x90}, 2},
{"msDS-LogonTimeSyncInterval",              {0xad7940f8,0xe43a,0x4a42,0x83,0xbc,0xd6,0x88,0xe5,0x9e,0xa6,0x05}, 2},
{"Allocate Rids",                           {0x1abd7cf8,0x0a99,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"Remote Access Information",               {0x037088f8,0x0ae1,0x11d2,0xb4,0x22,0x00,0xa0,0xc9,0x68,0xf9,0x39}, 1},
{"birthLocation",                           {0x1f0075f9,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMaximumSDUSize",                       {0x87a2d8f9,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"mSMQSiteNameEx",                          {0x422144fa,0xc17f,0x4649,0x94,0xd6,0x97,0x31,0xed,0x27,0x84,0xed}, 2},
{"oMTIndxGuid",                             {0x1f0075fa,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"possSuperiors",                           {0xbf9679fa,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKIMaxIssuingDepth",                      {0xf0bfdefa,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"volTableIdxGUID",                         {0x1f0075fb,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"postOfficeBox",                           {0xbf9679fb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Change Infrastructure Master",            {0xcc17b1fb,0x33d9,0x11d2,0x97,0xd4,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"aCSMinimumLatency",                       {0x9517fefb,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"mS-SQL-ThirdParty",                       {0xc4e311fc,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msDS-Non-Security-Group-Extra-Classes",   {0x2de144fc,0x1f52,0x486f,0xbd,0xf4,0x16,0xfc,0xc3,0x08,0x4e,0x54}, 2},
{"msDS-NonMembersBL",                       {0x2a8c68fc,0x3a7a,0x4e87,0x87,0x20,0xfe,0x77,0xc5,0x1c,0xbe,0x74}, 2},
{"currentLocation",                         {0x1f0075fc,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"postalAddress",                           {0xbf9679fc,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"controlAccessRights",                     {0x6da8a4fc,0x0e52,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"volTableGUID",                            {0x1f0075fd,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"postalCode",                              {0xbf9679fd,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dNSProperty",                             {0x675a15fe,0x3b70,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"currMachineId",                           {0x1f0075fe,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"preferredDeliveryMethod",                 {0xbf9679fe,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"auditingPolicy",                          {0x6da8a4fe,0x0e52,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"preferredOU",                             {0xbf9679ff,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{ NULL, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\aclguids\base64.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       base64.c
//
//--------------------------------------------------------------------------
NTSTATUS
base64encode(
    IN  VOID *  pDecodedBuffer,
    IN  DWORD   cbDecodedBufferSize,
    OUT LPSTR   pszEncodedString,
    IN  DWORD   cchEncodedStringSize,
    OUT DWORD * pcchEncoded             OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pDecodedBuffer (IN) - buffer to encode.
    cbDecodedBufferSize (IN) - size of buffer to encode.
    cchEncodedStringSize (IN) - size of the buffer for the encoded string.
    pszEncodedString (OUT) = the encoded string.
    pcchEncoded (OUT) - size in characters of the encoded string.

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
    static char rgchEncodeTable[64] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    DWORD   ib;
    DWORD   ich;
    DWORD   cchEncoded;
    BYTE    b0, b1, b2;
    BYTE *  pbDecodedBuffer = (BYTE *) pDecodedBuffer;

    // Calculate encoded string size.
    cchEncoded = 1 + (cbDecodedBufferSize + 2) / 3 * 4;

    if (NULL != pcchEncoded) {
        *pcchEncoded = cchEncoded;
    }

    if (cchEncodedStringSize < cchEncoded) {
        // Given buffer is too small to hold encoded string.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Encode data byte triplets into four-byte clusters.
    ib = ich = 0;
    while (ib < cbDecodedBufferSize) {
        b0 = pbDecodedBuffer[ib++];
        b1 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;
        b2 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;

        pszEncodedString[ich++] = rgchEncodeTable[b0 >> 2];
        pszEncodedString[ich++] = rgchEncodeTable[((b0 << 4) & 0x30) | ((b1 >> 4) & 0x0f)];
        pszEncodedString[ich++] = rgchEncodeTable[((b1 << 2) & 0x3c) | ((b2 >> 6) & 0x03)];
        pszEncodedString[ich++] = rgchEncodeTable[b2 & 0x3f];
    }

    // Pad the last cluster as necessary to indicate the number of data bytes
    // it represents.
    switch (cbDecodedBufferSize % 3) {
      case 0:
        break;
      case 1:
        pszEncodedString[ich - 2] = '=';
        // fall through
      case 2:
        pszEncodedString[ich - 1] = '=';
        break;
    }

    // Null-terminate the encoded string.
    pszEncodedString[ich++] = '\0';

    Assert(ich == cchEncoded);

    return STATUS_SUCCESS;
}


NTSTATUS
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pszEncodedString (IN) - base64-encoded string to decode.
    cbDecodeBufferSize (IN) - size in bytes of the decode buffer.
    pbDecodeBuffer (OUT) - holds the decoded data.
    pcbDecoded (OUT) - number of data bytes in the decoded data (if success or
        STATUS_BUFFER_TOO_SMALL).

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
#define NA (255)
#define DECODE(x) (((int)(x) < sizeof(rgbDecodeTable)) ? rgbDecodeTable[x] : NA)

    static BYTE rgbDecodeTable[128] = {
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 0-15 
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 16-31
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 63, NA, NA, NA, 62,  // 32-47
       52, 53, 54, 55, 56, 57, 58, 59, 60, 61, NA, NA, NA, NA, NA, NA,  // 48-63
       NA, NA,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  // 64-79
       15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, NA, NA, NA, NA, NA,  // 80-95
       NA, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,  // 96-111
       41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, NA, NA, NA, NA, NA,  // 112-127
    };

    DWORD   cbDecoded;
    DWORD   cchEncodedSize;
    DWORD   ich;
    DWORD   ib;
    BYTE    b0, b1, b2, b3;
    BYTE *  pbDecodeBuffer = (BYTE *) pDecodeBuffer;

    cchEncodedSize = lstrlenA(pszEncodedString);

    if ((0 == cchEncodedSize) || (0 != (cchEncodedSize % 4))) {
        // Input string is not sized correctly to be base64.
        return STATUS_INVALID_PARAMETER;
    }

    // Calculate decoded buffer size.
    cbDecoded = (cchEncodedSize + 3) / 4 * 3;
    if (pszEncodedString[cchEncodedSize-1] == '=') {
        if (pszEncodedString[cchEncodedSize-2] == '=') {
            // Only one data byte is encoded in the last cluster.
            cbDecoded -= 2;
        }
        else {
            // Only two data bytes are encoded in the last cluster.
            cbDecoded -= 1;
        }
    }

    if (NULL != pcbDecoded) {
        *pcbDecoded = cbDecoded;
    }

    if (cbDecoded > cbDecodeBufferSize) {
        // Supplied buffer is too small.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Decode each four-byte cluster into the corresponding three data bytes.
    ich = ib = 0;
    while (ich < cchEncodedSize) {
        b0 = DECODE(pszEncodedString[ich++]);
        b1 = DECODE(pszEncodedString[ich++]);
        b2 = DECODE(pszEncodedString[ich++]);
        b3 = DECODE(pszEncodedString[ich++]);

        if ((NA == b0) || (NA == b1) || (NA == b2) || (NA == b3)) {
            // Contents of input string are not base64.
            return STATUS_INVALID_PARAMETER;
        }

        pbDecodeBuffer[ib++] = (b0 << 2) | (b1 >> 4);

        if (ib < cbDecodeBufferSize) {
            pbDecodeBuffer[ib++] = (b1 << 4) | (b2 >> 2);
    
            if (ib < cbDecodeBufferSize) {
                pbDecodeBuffer[ib++] = (b2 << 6) | b3;
            }
        }
    }

    Assert(ib == cbDecoded);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\aclguids\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       util.h
//
//--------------------------------------------------------------------------
#ifndef _UTILH_
#define _UTILH_

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Windows Headers
//
#include <windows.h>

//
// C-Runtime Header
//
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <excpt.h>
#include <conio.h>
#include <sys\types.h>
#include <errno.h>
#include <sys\stat.h>
#include <ctype.h>

//
// API headers
//
#include <rpc.h>
#include <ntdsapi.h>
#include <winldap.h>
#include <sddl.h>
#include <ntldap.h>

//
// Defines
//

// DACLS
#define DACL_ALLOW_DELETE   "(A;;SD;;;AU)"

// STUBS
#define STUB_BJF_CLASS  "bjfclass"
#define STUB_BJF_OBJECT "bjfobject"

// ds
#define FILTER_CATEGORY_ANY     "(objectCategory=*)"
#define FILTER_LINKID_ANY       "(linkId=*)"
#define FILTER_CATEGORY_ATTR    "(objectCategory=attributeSchema)"
#define FILTER_CATEGORY_CLASS   "(objectCategory=classSchema)"
#define FILTER_OBJECT_SID       "(objectSID=.)"
#define FILTER_BJF_CLASS        "(cn=" STUB_BJF_CLASS "*)"

#define CN_ROOT                 ""
#define CN_TOP                  "Top"
#define CN_BJF_CONTAINER        "bjfContainer"

#define SCHEMA_NAMING_CONTEXT   "cn=schema"
#define CONFIG_NAMING_CONTEXT   "cn=configuration"

#define ATTR_NAMING_CONTEXTS    "namingContexts"
#define ATTR_CN                 "cn"
#define ATTR_DN                 "distinguishedName"
#define ATTR_IS_SINGLE_VALUED   "isSingleValued"
#define ATTR_LINK_ID            "linkId"
#define ATTR_MAY_CONTAIN        "mayContain"
#define ATTR_SYSTEM_MAY_CONTAIN "systemmayContain"
#define ATTR_MUST_CONTAIN        "mustContain"
#define ATTR_SYSTEM_MUST_CONTAIN "systemmustContain"
#define ATTR_LDAP_DISPLAY_NAME   "ldapDisplayName"
#define ATTR_PARTIAL_SET         "isMemberOfPartialAttributeSet"
#define ATTR_SYSTEM_FLAGS        "systemFlags"
#define ATTR_SYSTEM_ONLY         "systemOnly"
#define ATTR_GOVERNS_ID          "governsId"
#define ATTR_ATTRIBUTE_ID        "attributeId"
#define ATTR_SD                  "nTSecurityDescriptor"
#define ATTR_TG                 "tokenGroups"
#define ATTR_TGGU               "tokenGroupsGlobalAndUniversal"
#define ATTR_TGNOGC             "tokenGroupsNoGcAcceptable"
#define ATTR_DEFAULT_NC         "defaultNamingContext"
#define ATTR_OBJECT_SID         "objectSID"
#define ATTR_ENTRY_TTL          "EntryTTL"

// registry
#define NTDS_SERVICE            "NTDS"
#define NTDS_ROOT               "System\\CurrentControlSet\\Services\\" NTDS_SERVICE
#define NTDS_PARAMETERS         NTDS_ROOT "\\Parameters"
#define NTDS_UPDATE_SCHEMA      "Schema Update Allowed"
#define NTDS_DELETE_SCHEMA      "Schema Delete Allowed"
#define NTDS_SYSTEM_SCHEMA      "Allow System Only Change"

#define FREE(_x_)       { if (_x_) free(_x_); _x_ = NULL; }
#define FREE_LOCAL(_x_) { if (_x_) LocalFree(_x_); _x_ = NULL; }
#define FREECREDS(_x_)  { if (_x_) DsFreePasswordCredentials(_x_); _x_ = NULL; }
#define UNBIND(_x_)     { if (_x_) ldap_unbind(_x_); _x_ = NULL; }
#define FREE_MSG(x)        {if (x) {ldap_msgfree(x); (x) = NULL;}}
#define FREE_VALUES(x)     {if (x) {ldap_value_free(x); (x) = NULL;}}
#define FREE_BERVALUES(x)  {if (x) {ldap_value_free_len(x); (x) = NULL;}}
#define FREE_BER_VALUES(x) {if (x) {ldap_value_free_len(x); (x) = NULL;}}

//
// Globals and Params
//
extern BOOL Verbose;

typedef struct _Arg {
    CHAR    *prefix;
    CHAR    **ppArg;
    BOOL    optional;
} Arg;
    
PCHAR
ExtendDn(
    IN PCHAR Dn,
    IN PCHAR Cn
    );

BOOL
LdapSearch(
    IN PLDAP        ldap,
    IN PCHAR        Base,
    IN ULONG        Scope,
    IN PCHAR        Filter,
    IN PCHAR        Attrs[],
    IN LDAPMessage  **Res
    );

PCHAR *
GetValues(
    IN PLDAP  Ldap,
    IN PCHAR  Dn,
    IN PCHAR  DesiredAttr
    );
PCHAR
GetRootDn(
    IN PLDAP    Ldap,
    IN PCHAR    NamingContext
    );
VOID
FreeMod(
    IN OUT LDAPMod ***pppMod
    );
VOID
AddMod(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    );
VOID
AddModMod(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    );
VOID
AddModVal(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    );
BOOL
PutRegDWord(
    IN PCHAR    FQKey,
    IN PCHAR    Value,
    IN DWORD    DWord
    );
BOOL
GetRegDWord(
    IN  PCHAR   FQKey,
    IN  PCHAR   Value,
    OUT DWORD   *pDWord
    );
VOID
RefreshSchema(
    IN PLDAP Ldap
    );
PCHAR *
FindValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN PCHAR        DesiredAttr
    );
BOOL
DupStrValue(
    IN  PLDAP           Ldap,
    IN  PLDAPMessage    LdapEntry,
    IN  PCHAR           DesiredAttr,
    OUT PCHAR           *ppStr
    );
BOOL
DupBoolValue(
    IN  PLDAP           Ldap,
    IN  PLDAPMessage    LdapEntry,
    IN  PCHAR           DesiredAttr,
    OUT PBOOL           pBool
    );

DWORD
LdapSearchPaged(
    IN PLDAP        ldap,
    IN PCHAR        Base,
    IN ULONG        Scope,
    IN PCHAR        Filter,
    IN PCHAR        Attrs[],
    IN BOOL         (*Worker)(PLDAP Ldap, PLDAPMessage LdapMsg, PVOID Arg),
    IN PVOID        Arg
    );
BOOL
LdapDeleteTree(
    IN PLDAP        Ldap,
    IN PCHAR        Base
    );
BOOL
LdapDeleteEntries(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter
    );
BOOL
LdapDumpSd(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter
    );
BOOL
LdapAddDacl(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter,
    IN PCHAR        AddStringSd
    );
PLDAP
LdapBind(
    IN PCHAR    pDc,
    IN PCHAR    pDom,
    IN PCHAR    pUser,
    IN PCHAR    pPwd
    );
DWORD
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    );
#endif _UTILH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\aclguids\aclguids.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       aclguids.c
//
//  Author:     Marios Zikos
//
//--------------------------------------------------------------------------

//
// Aclguids is a utility that generates an include file with all the
// guids that can be used in ACLs. These guids are all the schema objects
// and all the control access rights
//
// The generated header file contains an array of guids, sorted on the guid.
// It is used by ldp, dsexts in order to print the name of a particular guid
// that is found on an ACL.
//
// This utility should be run periodically, whenever schema changes take place,
// inorder to have an updated version of the header file.
// It requires an installed DC with the schema that will be used to 
// generate the header file.

#include <util.h>

BOOL    List = FALSE;

CHAR    *pgUser         = NULL;
CHAR    *pgDom          = NULL;
CHAR    *pgPwd          = NULL;
CHAR    *pgDc           = NULL;
CHAR    *pFilename      = NULL;

Arg args[] =  { 
                { "-user:", &pgUser,       TRUE  },
                { "-dom:",  &pgDom,        TRUE  },
                { "-pwd:",  &pgPwd,        TRUE  },
                { "-dc:",   &pgDc,         TRUE  },
                { "-output:",&pFilename,    FALSE },
              };

DWORD argCount = sizeof(args) / sizeof(args[0]);

void GetArgs(
    int     argc, 
    char    **argv)
{
    char    *arg;
    DWORD   i;
    BOOL    found;

    while ( --argc > 0 ) {
        arg = argv[argc];
        found = FALSE;

        if (!_stricmp(arg, "/v") || !_stricmp(arg, "-v")) {
            Verbose = TRUE;
            continue;
        }

        if (!_stricmp(arg, "/l") || !_stricmp(arg, "-l")) {
            List = TRUE;
            continue;
        }

        for ( i = 0; i < argCount; i++ ) {
            if ( !_strnicmp(arg, args[i].prefix, strlen(args[i].prefix)) ) {
                *args[i].ppArg = &arg[strlen(args[i].prefix)];
                found = TRUE;
            }
        }

        if ( !found ) {
            printf("\nDon't understand %s\n", arg);
            goto Usage;
        }
    }

    for ( i = 0; i < argCount; i++ ) {
        if ( !args[i].optional && !*args[i].ppArg ) {
            printf("\nMissing %s\n", args[i].prefix);
            goto Usage;
        }
    }

    if (Verbose) {
        printf("Arguments:%s%s\n", 
               (Verbose) ? " /v" : "",
               (List) ? " /l" : ""
                );
        for ( i = 0; i < argCount; i++ ) {
            printf("\t%s%s\n", args[i].prefix, *args[i].ppArg);
        }
    }

    return;

Usage:

    printf("\nUsage: %s [/v(erbose)] args...\n", argv[0]);
    for ( i = 0; i < argCount; i++ ) {
        printf("\t%s %sxxx\n", 
               (args[i].optional) ? "(Optional)" : "(Required)",
               args[i].prefix);
    }

    exit(1);
}

char *insert_space (int len)
{
    static char buffer[256];
    int i;

    for (i=0; i<len && i<255; i++) {
        buffer[i]=' ';
    }

    buffer[i]='\0';

    return buffer;
}

typedef struct GuidCache
{
    GUID                guid;
    CHAR                *name;
    int                 type;
} GuidCache;

#define MAX_GUID_CACHE_SIZE 5000
GuidCache guidcache[MAX_GUID_CACHE_SIZE];
int guidCount = 0;


int __cdecl CompareGuidCache(const void * pv1, const void * pv2)
{
    return memcmp ( &((GuidCache *)pv1)->guid, &((GuidCache *)pv2)->guid, sizeof (GUID));
}


void _cdecl 
main(
    int     argc, 
    char    **argv)
{
    DWORD           dwErr, count;
    PCHAR           RootDn = NULL;
    PCHAR           ConfigNC = NULL;
    PCHAR           SchemaNC = NULL;
    
    LDAP            *hLdapConn = NULL;
    PLDAPSearch     hPage;
    PLDAPMessage    ldap_message = NULL;
    PLDAPMessage    entry = NULL;
    
    CHAR            filter[512];
    CHAR            *attrs[3];
    PCHAR           dn;
    LDAP_TIMEVAL    tm;
    ULONG           ulPageSize, ulEntryCount;
    
    PLDAP_BERVAL    *sd_value = NULL;

    FILE            *fp = NULL;
    
    int             i;

    // Args
    GetArgs(argc, argv);

    // Bind to DC
    hLdapConn = LdapBind(pgDc, pgUser, pgDom, pgPwd);
    if (!hLdapConn) {
        goto cleanup;
    }

    // get ROOT DN
    RootDn = GetRootDn(hLdapConn, "");
    if (!RootDn) {
        goto cleanup;
    }

    ConfigNC = GetRootDn(hLdapConn, CONFIG_NAMING_CONTEXT);
    if (!ConfigNC) {
        goto cleanup;
    }

    SchemaNC = GetRootDn(hLdapConn, SCHEMA_NAMING_CONTEXT);
    if (!SchemaNC) {
        goto cleanup;
    }

    fprintf(stderr, "RootDN: %s\nConfigNC: %s\nSchemaNC: %s\n", RootDn, ConfigNC, SchemaNC);


    fp = fopen (pFilename, "w");
    if (!fp) {
        fprintf(stderr, "Error opening file: %s\n", pFilename);
        goto cleanup;
    }

    // first search the schema
    //

    strcpy (filter , "schemaIdGuid=*");
    attrs[0] = "ldapDisplayName";
    attrs[1] = "schemaIdGuid";
    attrs[2] = NULL;

    tm.tv_sec = 1000;
    tm.tv_usec = 1000;
    ulPageSize = 100;

    hPage = ldap_search_init_page(  hLdapConn,
                                    SchemaNC,
                                    LDAP_SCOPE_SUBTREE,     // whole tree
                                    filter,                 // filter
                                    attrs,                  // list of attributes
                                    0,
                                    NULL, 
                                    NULL,
                                    100000,
                                    ulPageSize,
                                    NULL);

    if(hPage == NULL) {
        dwErr = LdapGetLastError();
        printf ( "Error: Search: %s. <%ld>", ldap_err2string(dwErr), dwErr);
    }

    do {
        dwErr = ldap_get_next_page_s(hLdapConn, 
                                     hPage, 
                                     &tm, 
                                     ulPageSize, 
                                     &ulEntryCount, 
                                     &ldap_message);    

        if (ldap_message != NULL) {

            entry = ldap_first_entry( hLdapConn, ldap_message );

            while (entry != NULL) {

                //dn = ldap_get_dn( hLdapConn, entry );
                //printf( "Distinguished Name is : %s\n", dn );
                //ldap_memfree( dn );

                if (!(sd_value = ldap_get_values_lenA(hLdapConn, entry, attrs[0])) )
                {
                    printf ( "Error\n");
                    break;
                }

                guidcache[guidCount].name = _strdup ((char*)(*sd_value)->bv_val);

                ldap_value_free_len(sd_value);

                if (!(sd_value = ldap_get_values_lenA(hLdapConn, entry, attrs[1])) )
                {
                    printf ( "Error\n");
                    break;
                }

                guidcache[guidCount].guid = *(GUID *)(*sd_value)->bv_val;
                guidcache[guidCount].type = 2;
                guidCount++;

                ldap_value_free_len(sd_value);

                entry = ldap_next_entry( hLdapConn, entry );
            }
            ldap_msgfree( ldap_message );
        }

    } while ( dwErr == LDAP_SUCCESS );
    
    ldap_search_abandon_page(hLdapConn, hPage);
    
    
    
    // next search the contolAccessRights
    //

    strcpy (filter , "(&(objectCategory=controlAccessRight)(rightsGUID=*))");

    attrs[0] = "displayName";
    attrs[1] = "rightsGUID";
    attrs[2] = NULL;

    hPage = ldap_search_init_page(  hLdapConn,
                                    ConfigNC,
                                    LDAP_SCOPE_SUBTREE,     // whole tree
                                    filter,                 // filter
                                    attrs,                  // list of attributes
                                    0,
                                    NULL, 
                                    NULL,
                                    100000,
                                    ulPageSize,
                                    NULL);

    if(hPage == NULL) {
        dwErr = LdapGetLastError();
        printf ( "Error: Search: %s. <%ld>", ldap_err2string(dwErr), dwErr);
    }

    do {
        dwErr = ldap_get_next_page_s(hLdapConn, 
                                     hPage, 
                                     &tm, 
                                     ulPageSize, 
                                     &ulEntryCount, 
                                     &ldap_message);    

        if (ldap_message != NULL) {

            entry = ldap_first_entry( hLdapConn, ldap_message );

            while (entry != NULL) {

                if (!(sd_value = ldap_get_values_lenA(hLdapConn, entry, attrs[0])) )
                {
                    printf ( "Error\n");
                    break;
                }

                guidcache[guidCount].name = _strdup ((char*)(*sd_value)->bv_val);

                ldap_value_free_len(sd_value);

                if (!(sd_value = ldap_get_values_lenA(hLdapConn, entry, attrs[1])) )
                {
                    printf ( "Error\n");
                    break;
                }

                UuidFromString ((char *)(*sd_value)->bv_val, &guidcache[guidCount].guid);
                guidcache[guidCount].type = 1;
                guidCount++;

                ldap_value_free_len(sd_value);

                entry = ldap_next_entry( hLdapConn, entry );
            }
            ldap_msgfree( ldap_message );
        }

    } while ( dwErr == LDAP_SUCCESS );
    
    ldap_search_abandon_page(hLdapConn, hPage);


    qsort(guidcache, guidCount, sizeof (GuidCache), CompareGuidCache);

    for (i=0; i<guidCount; i++) {
        fprintf(fp, "{\"%s\",%s", 
                       guidcache[i].name,
                       insert_space (40 - strlen (guidcache[i].name)));

        fprintf(fp, "{0x%08x,0x%04x,0x%04x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x}",
               guidcache[i].guid.Data1,
               guidcache[i].guid.Data2,
               guidcache[i].guid.Data3,
               guidcache[i].guid.Data4[0],
               guidcache[i].guid.Data4[1],
               guidcache[i].guid.Data4[2],
               guidcache[i].guid.Data4[3],
               guidcache[i].guid.Data4[4],
               guidcache[i].guid.Data4[5],
               guidcache[i].guid.Data4[6],
               guidcache[i].guid.Data4[7]
               );
               
        fprintf(fp, ", %d},\n", guidcache[i].type);

        free (guidcache[i].name);
    }
    fprintf(fp, "{ NULL, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0}\n");

cleanup:
    FREE(RootDn);
    FREE(ConfigNC);
    FREE(SchemaNC);
    UNBIND(hLdapConn);
    if (fp) {
        fclose (fp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\aclguids\util.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       util.c
//
//--------------------------------------------------------------------------
#include <util.h> 

BOOL Verbose = FALSE;

PCHAR
ExtendDn(
    IN PCHAR Dn,
    IN PCHAR Cn
    )
/*++
Routine Description:
    Extend an existing DN with a new CN= component.

Arguments:
    Dn  - distinguished name
    Cn  - common name

Return Value:
    CN=Cn,Dn
--*/
{
    ULONG  Len;
    PCHAR  NewDn;

    if (!Dn || !Cn) {
        return NULL;
    }

    Len = strlen("CN=,") + strlen(Dn) + strlen(Cn) + 1;
    NewDn = (PCHAR)malloc(Len);
    strcpy(NewDn, "CN=");
    strcat(NewDn, Cn);
    strcat(NewDn, ",");
    strcat(NewDn, Dn);
    return NewDn;
}

BOOL
LdapSearch(
    IN PLDAP        ldap,
    IN PCHAR        Base,
    IN ULONG        Scope,
    IN PCHAR        Filter,
    IN PCHAR        Attrs[],
    IN LDAPMessage  **Res
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call and check for errors.

Arguments:
    ldap
    Base
    Scope
    Filter
    Attrs
    Res

Return Value:
    The ldap array of values.
    The ldap array is freed with ldap_value_free().
--*/
{
    DWORD dwErr;

    // Issue the ldap search
    dwErr = ldap_search_s(ldap, Base, Scope, Filter, Attrs, FALSE, Res);

    // Check for errors
    if (dwErr) {
        if (Verbose) {
            printf("ldap_search_s(%s) ==> %08x (%08x): %s\n",
               Base, dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
        }
        return FALSE;
    }
    return TRUE;
}

BOOL
LdapDelete(
    IN PLDAP        ldap,
    IN PCHAR        Base
    )
/*++
Routine Description:
    Issue the ldap ldap_delete_s call and check for errors.

Arguments:
    ldap
    Base

Return Value:
    FALSE if problems
--*/
{
    DWORD dwErr;

printf("deleting %s\n", Base);

    // Issue the ldap search
    dwErr = ldap_delete_s(ldap, Base);

    // Check for errors
    if (dwErr != LDAP_SUCCESS && dwErr != LDAP_NO_SUCH_OBJECT) {
        if (Verbose) {
            printf("ldap_delete_s(%s) ==> %08x (%08x): %s\n",
               Base, dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
        }
        return FALSE;
    }
    return TRUE;
}

PCHAR *
GetValues(
    IN PLDAP  Ldap,
    IN PCHAR  Dn,
    IN PCHAR  DesiredAttr
    )
/*++
Routine Description:
    Return the DS values for one attribute in an object.

Arguments:
    ldap        - An open, bound ldap port.
    Base        - The "pathname" of a DS object.
    DesiredAttr - Return values for this attribute.

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with ldap_value_free(). NULL if unsuccessful.
--*/
{
    PCHAR           Attr;
    BerElement      *Ber;
    PLDAPMessage    LdapMsg;
    PLDAPMessage    LdapEntry;
    PCHAR           Attrs[2];
    PCHAR           *Values = NULL;

    // Search Base for all of its attributes + values
    Attrs[0] = DesiredAttr;
    Attrs[1] = NULL;

    // Issue the ldap search
    if (!LdapSearch(Ldap, Dn, LDAP_SCOPE_BASE, FILTER_CATEGORY_ANY,
                    Attrs, &LdapMsg)) {
        return NULL;
    }
    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (LdapEntry) {
        Attr = ldap_first_attribute(Ldap, LdapEntry, &Ber);
        if (Attr) {
            Values = ldap_get_values(Ldap, LdapEntry, Attr);
        }
    }
    ldap_msgfree(LdapMsg);
    return Values;
}

PCHAR
GetRootDn(
    IN PLDAP    Ldap,
    IN PCHAR    NamingContext
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    PCHAR   Root;       // DS pathname of configuration container
    PCHAR   *Values;    // values from the attribute "namingContexts"
    DWORD   NumVals;    // number of values

    // Return all of the values for the attribute namingContexts
    Values = GetValues(Ldap, CN_ROOT, ATTR_NAMING_CONTEXTS);
    if (Values == NULL)
        return NULL;

    // Find the naming context that begins with CN=Configuration
    NumVals = ldap_count_values(Values);
    while (NumVals--) {
        _strlwr(Values[NumVals]);
        Root = strstr(Values[NumVals], NamingContext);
        if (Root != NULL && Root == Values[NumVals]) {
            Root = _strdup(Root);
            ldap_value_free(Values);
            return Root;
        }
    }
    printf("COULD NOT FIND %s\n", NamingContext);
    ldap_value_free(Values);
    return NULL;
}

VOID
FreeMod(
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Free the structure built by successive calls to AddMod().

Arguments:
    pppMod  - Address of a null-terminated array.

Return Value:
    *pppMod set to NULL.
--*/
{
    DWORD   i, j;
    LDAPMod **ppMod;

    if (!pppMod || !*pppMod) {
        return;
    }

    // For each attibute
    ppMod = *pppMod;
    for (i = 0; ppMod[i] != NULL; ++i) {
        //
        // For each value of the attribute
        //
        for (j = 0; (ppMod[i])->mod_values[j] != NULL; ++j) {
            // Free the value
            if (ppMod[i]->mod_op & LDAP_MOD_BVALUES) {
                free(ppMod[i]->mod_bvalues[j]->bv_val);
            }
            free((ppMod[i])->mod_values[j]);
        }
        free((ppMod[i])->mod_values);   // Free the array of pointers to values
        free((ppMod[i])->mod_type);     // Free the string identifying the attribute
        free(ppMod[i]);                 // Free the attribute
    }
    free(ppMod);        // Free the array of pointers to attributes
    *pppMod = NULL;     // Now ready for more calls to AddMod()
}

VOID
AddModVal(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add a value to an existing attribute and an existing structure that
    will eventually be used in an ldap_add/modify() function to add/modify
    an object to the DS.

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes".

Return Value:
    Additional value for AttrType
--*/
{
    DWORD   i;
    LDAPMod **ppMod;    // Address of the first entry in the Mod array

    for (ppMod = *pppMod; *ppMod != NULL; ++ppMod) {
        if (!_stricmp((*ppMod)->mod_type, AttrType)) {
            for (i = 0; (*ppMod)->mod_values[i]; ++i);
            (*ppMod)->mod_values = (PCHAR *)realloc((*ppMod)->mod_values, 
                                                    sizeof (PCHAR *) * (i + 2));
            (*ppMod)->mod_values[i] = _strdup(AttrValue);
            (*ppMod)->mod_values[i+1] = NULL;
            break;
        }
    }
}

VOID
AddModOrAdd(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN ULONG  mod_op,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    mod_op          - LDAP_MOD_ADD/REPLACE
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PCHAR    *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PCHAR  *)malloc(sizeof (PCHAR ) * 2);
    Values[0] = _strdup(AttrValue);
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_values = Values;
    Attr->mod_type = _strdup(AttrType);
    Attr->mod_op = mod_op;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}

VOID
AddMod(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    AddModOrAdd(AttrType, AttrValue, LDAP_MOD_ADD, pppMod);
}

VOID
AddModMod(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_modify() function to change an object in the DS.
    The null-terminated array referenced by pppMod grows with each call
    to this routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    AddModOrAdd(AttrType, AttrValue, LDAP_MOD_REPLACE, pppMod);
}

VOID
AddBerMod(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN DWORD  AttrValueLen,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PCHAR   *Values;    // An array of pointers to bervals
    PBERVAL Berval;

    if (AttrValue == NULL) {
        return;
    }

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Construct a berval
    //
    Berval = (PBERVAL)malloc(sizeof(BERVAL));
    Berval->bv_len = AttrValueLen;
    Berval->bv_val = (PCHAR)malloc(AttrValueLen);
    CopyMemory(Berval->bv_val, AttrValue, AttrValueLen);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PCHAR  *)malloc(sizeof (PCHAR ) * 2);
    Values[0] = (PCHAR)Berval;
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_values = Values;
    Attr->mod_type = _strdup(AttrType);
    Attr->mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}

BOOL
PutRegDWord(
    IN PCHAR    FQKey,
    IN PCHAR    Value,
    IN DWORD    DWord
    )
/*++
Routine Description:
    This function writes a keyword value into the registry.

Arguments:
    HKey    - Key to be read
    Param   - value string to update
    DWord   - dword to be written

Return Value:
    TRUE    - Success
    FALSE   - Not
--*/
{
    HKEY    HKey;
    DWORD   dwErr;

    //
    // Open the key
    //
    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, FQKey, &HKey);
    if (dwErr) {
        if (Verbose) {
            printf("RegOpenKey(%s\\%s) ==> %08x\n", FQKey, Value, dwErr);
        }
        return FALSE;
    }
    //

    //
    // Write the value
    //
    dwErr = RegSetValueEx(HKey,
                          Value,
                          0,
                          REG_DWORD,
                          (PUCHAR)&DWord,
                          sizeof(DWord));
    RegCloseKey(HKey);
    if (dwErr) {
        if (Verbose) {
            printf("RegSetValueEx(%s\\%s) ==> %08x\n", FQKey, Value, dwErr);
        }
        return FALSE;
    }
    return TRUE;
}

BOOL
GetRegDWord(
    IN  PCHAR   FQKey,
    IN  PCHAR   Value,
    OUT DWORD   *pDWord
    )
/*++
Routine Description:
    This function reads a keyword value from the registry.

Arguments:
    HKey    - Key to be read
    Param   - value string to update
    pDWord  - address of dword read from registry

Return Value:
    TRUE    - Success
    FALSE   - Not
--*/
{
    HKEY    HKey;
    DWORD   dwErr;
    DWORD   dwSize = sizeof(DWORD);
    DWORD   dwType;

    //
    // Open the key
    //
    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, FQKey, &HKey);
    if (dwErr) {
        return FALSE;
    }
    //

    //
    // Read the value
    //
    dwErr = RegQueryValueEx(HKey,
                            Value,
                            NULL,
                            &dwType,
                            (PUCHAR) pDWord,
                            &dwSize);
    RegCloseKey(HKey);
    if (dwErr) {
        return FALSE;
    }
    if (dwType != REG_DWORD) {
        return FALSE;
    }
    return TRUE;
}

VOID
RefreshSchema(
    IN PLDAP Ldap
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    None.
--*/
{
    DWORD   dwErr;
    LDAPMod **Mod = NULL;

    AddMod("schemaUpdateNow", "1", &Mod);
    dwErr = ldap_modify_s(Ldap, "", Mod);
    FreeMod(&Mod);
    if (dwErr) {
        if (Verbose) {
            printf("ldap_modify_s(schemaUpdateNow) ==> %08x (%08x): %s\n", 
               dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
        }
    }
}

PCHAR *
FindValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN PCHAR        DesiredAttr
    )
/*++
Routine Description:
    Return the DS values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with LDAP_FREE_VALUES().
    NULL if unsuccessful.
--*/
{
    PCHAR       LdapAttr;
    BerElement  *LdapBer;

    // Search the entry for the desired attribute
    for (LdapAttr = ldap_first_attribute(Ldap, LdapEntry, &LdapBer);
         LdapAttr != NULL;
         LdapAttr = ldap_next_attribute(Ldap, LdapEntry, LdapBer)) {

        if (!_stricmp(DesiredAttr, LdapAttr)) {
            // Return the values for DesiredAttr
            return ldap_get_values(Ldap, LdapEntry, LdapAttr);
        }
    }
    return NULL;
}

PBERVAL *
FindBerValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN PCHAR        DesiredAttr
    )
/*++
Routine Description:
    Return the DS ber values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with LDAP_FREE_VALUES().
    NULL if unsuccessful.
--*/
{
    PCHAR       LdapAttr;
    BerElement  *LdapBer;

    // Search the entry for the desired attribute
    for (LdapAttr = ldap_first_attribute(Ldap, LdapEntry, &LdapBer);
         LdapAttr != NULL;
         LdapAttr = ldap_next_attribute(Ldap, LdapEntry, LdapBer)) {

        if (!_stricmp(DesiredAttr, LdapAttr)) {
            // Return the values for DesiredAttr
            return ldap_get_values_len(Ldap, LdapEntry, LdapAttr);
        }
    }
    return NULL;
}

BOOL
DupStrValue(
    IN  PLDAP           Ldap,
    IN  PLDAPMessage    LdapEntry,
    IN  PCHAR           DesiredAttr,
    OUT PCHAR           *ppStr
    )
/*++
Routine Description:
    Dup the first value for the attribute DesiredAttr

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - locate the values for this attribute
    Value       - Dup of first value (NULL if none)

Return Value:
    TRUE  - found a value, ppStr is set (free with FREE(*ppStr))
    FALSE - Not, ppStr is NULL
--*/
{
    PCHAR   *Values = NULL;


    *ppStr = NULL;

    // Dup the first value for DesiredAttr
    Values = FindValues(Ldap, LdapEntry, DesiredAttr);
    if (!Values || !Values[0]) {
        return FALSE;
    }
    *ppStr = _strdup(Values[0]);
    FREE_VALUES(Values);
    return TRUE;
}

BOOL
DupBoolValue(
    IN  PLDAP           Ldap,
    IN  PLDAPMessage    LdapEntry,
    IN  PCHAR           DesiredAttr,
    OUT PBOOL           pBool
    )
/*++
Routine Description:
    Dup the first value for the attribute DesiredAttr

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - locate the values for this attribute
    Value       - Dup of first value (NULL if none)

Return Value:
    TRUE  - found a value, *pBool is set
    FALSE - Not, pBool is undefined
--*/
{
    PCHAR   sBool = NULL;

    if (!DupStrValue(Ldap, LdapEntry, DesiredAttr, &sBool)) {
        return FALSE;
    }
    if (!_stricmp(sBool, "TRUE")) {
        *pBool = TRUE;
    } else if (!_stricmp(sBool, "FALSE")) {
        *pBool = FALSE;
    } else {
        FREE(sBool);
        return FALSE;
    }
    FREE(sBool);
    return TRUE;
}

DWORD
LdapSearchPaged(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN ULONG        Scope,
    IN PCHAR        Filter,
    IN PCHAR        Attrs[],
    IN BOOL         (*Worker)(PLDAP Ldap, PLDAPMessage LdapMsg, PVOID Arg),
    IN PVOID        Arg
    )
/*++
Routine Description:
    Call the Worker for each successful paged search

Arguments:
    ldap
    Base
    Scope
    Filter
    Attrs
    Res
    Worker
    Arg
            
Return Value:
    FALSE if problem
--*/
{
    PLDAPMessage    LdapMsg = NULL;
    DWORD           TotalEstimate, dwErr;
    LDAPSearch      *pSearch = NULL;

    // Paged search
    pSearch = ldap_search_init_page(Ldap,
                                    Base,
                                    Scope,
                                    Filter,
                                    Attrs,
                                    FALSE, NULL, NULL, 0, 0, NULL);
    if (pSearch == NULL) {
        dwErr = LdapGetLastError();
        if (Verbose) {
            printf("ldap_search_init_page(%s) ==> %08x (%08x): %s\n",
               Base, dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
        }
        goto cleanup;
    }

NextPage:
    FREE_MSG(LdapMsg);
    dwErr = ldap_get_next_page_s(Ldap,
                                 pSearch,
                                 0,
                                 2048,
                                 &TotalEstimate,
                                 &LdapMsg);
    if (dwErr != LDAP_SUCCESS) {
        if (dwErr == LDAP_NO_RESULTS_RETURNED) {
            dwErr = LDAP_SUCCESS;
        } else {
            if (Verbose) {
                printf("ldap_get_next_page_s(%s) ==> %08x (%08x): %s\n",
                   Base, dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
            }
        }
        goto cleanup;
    }

    // Call worker
    if ((*Worker)(Ldap, LdapMsg, Arg)) {
        goto NextPage;
    }

cleanup:
    FREE_MSG(LdapMsg);
    if (pSearch) {
        ldap_search_abandon_page(Ldap, pSearch);
    }
    return (dwErr);
}

BOOL
LdapDeleteTreeWorker(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapMsg,
    IN PVOID        Arg
    )
/*++
Routine Description:
    Delete the contents of each returned entry

Arguments:

Return Value:
    FALSE if problem
--*/
{
    PLDAPMessage    LdapEntry = NULL;
    BOOL            *pBool = Arg;
    PCHAR           *Values = NULL;

    // no problems, yet
    *pBool = TRUE;

    // scan thru the paged results
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL && *pBool;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        // Delete this entry and its contents
        Values = FindValues(Ldap, LdapEntry, ATTR_DN);
        if (Values && Values[0] && *Values[0]) {
            *pBool = LdapDeleteTree(Ldap, Values[0]);
        } else {
            *pBool = FALSE;
        }
        FREE_VALUES(Values);
    }
    return *pBool;
}

BOOL
LdapDeleteTree(
    IN PLDAP        Ldap,
    IN PCHAR        Base
    )
/*++
Routine Description:
    Delete Base and its contents

Arguments:
            
Return Value:
    FALSE if problem
--*/
{
    DWORD   dwErr;
    PCHAR   Attrs[16];
    BOOL    WorkerBool = TRUE;

    Attrs[0] = ATTR_DN;
    Attrs[1] = NULL;
    dwErr = LdapSearchPaged(Ldap,
                            Base,
                            LDAP_SCOPE_ONELEVEL,
                            FILTER_CATEGORY_ANY,
                            Attrs,
                            LdapDeleteTreeWorker,
                            &WorkerBool);
    // paged search went okay
    if (dwErr != LDAP_SUCCESS && dwErr != LDAP_NO_SUCH_OBJECT) {
        return FALSE;
    }

    // delete of contents went okay
    if (!WorkerBool) {
        return FALSE;
    }

    // delete base
    return LdapDelete(Ldap, Base);
}

BOOL
LdapDeleteEntriesWorker(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapMsg,
    IN PVOID        Arg
    )
/*++
Routine Description:
    Delete each returned entry

Arguments:

Return Value:
    FALSE if problem
--*/
{
    PLDAPMessage    LdapEntry = NULL;
    BOOL            *pBool = Arg;
    PCHAR           *Values = NULL;

    // no problems, yet
    *pBool = TRUE;

    // scan thru the paged results
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL && *pBool;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        // Delete this entry and its contents
        Values = FindValues(Ldap, LdapEntry, ATTR_DN);
        if (Values && Values[0] && *Values[0]) {
            *pBool = LdapDelete(Ldap, Values[0]);
        } else {
            *pBool = FALSE;
        }
        FREE_VALUES(Values);
    }
    return *pBool;
}

BOOL
LdapDeleteEntries(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter
    )
/*++
Routine Description:
    Delete entries returned from one level search of Base

Arguments:
    ldap
    Base
    Filter
            
Return Value:
    FALSE if problem
--*/
{
    DWORD   dwErr;
    PCHAR   Attrs[16];
    BOOL    WorkerBool = TRUE;

    Attrs[0] = ATTR_DN;
    Attrs[1] = NULL;
    dwErr = LdapSearchPaged(Ldap,
                            Base,
                            LDAP_SCOPE_ONELEVEL,
                            Filter,
                            Attrs,
                            LdapDeleteEntriesWorker,
                            &WorkerBool);
    // paged search went okay
    if (dwErr != LDAP_SUCCESS && dwErr != LDAP_NO_SUCH_OBJECT) {
        return FALSE;
    }
    return WorkerBool;
}

BOOL
LdapDumpSdWorker(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapMsg,
    IN PVOID        Arg
    )
/*++
Routine Description:
    Dump the Sd of each entry

Arguments:

Return Value:
    FALSE if problem
--*/
{
    PLDAPMessage    LdapEntry = NULL;
    PCHAR           *ValuesCn = NULL;
    PBERVAL         *ValuesSd = NULL;
    PCHAR           StringSd = NULL;
    DWORD           nStringSd = 0;

    // scan thru the paged results
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        // cn
        ValuesCn = FindValues(Ldap, LdapEntry, ATTR_CN);

        // SD
        ValuesSd = FindBerValues(Ldap, LdapEntry, ATTR_SD);
        if (ValuesSd && 
            ValuesSd[0] && 
            ValuesSd[0]->bv_len && 
            ValuesSd[0]->bv_val) {
            if (!ConvertSecurityDescriptorToStringSecurityDescriptor(
                    ValuesSd[0]->bv_val,
                    SDDL_REVISION_1,
                    GROUP_SECURITY_INFORMATION |
                    SACL_SECURITY_INFORMATION |
                    DACL_SECURITY_INFORMATION |
                    OWNER_SECURITY_INFORMATION,
                    &StringSd,
                    &nStringSd)) {
                printf("ConvertSd() ==> %08x\n", GetLastError());
            }
        }

        printf("%s: %s\n",
               (ValuesCn) ? ValuesCn[0] : "?", StringSd);
        FREE_VALUES(ValuesCn);
        FREE_BERVALUES(ValuesSd);
        FREE_LOCAL(StringSd);
    }
    return TRUE;
}

BOOL
LdapDumpSd(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter
    )
/*++
Routine Description:
    Delete entries returned from one level search of Base

Arguments:
            
Return Value:
    FALSE if problem
--*/
{
    DWORD   dwErr;
    PCHAR   Attrs[16];

    Attrs[0] = ATTR_CN;
    Attrs[1] = ATTR_SD;
    Attrs[2] = NULL;
    dwErr = LdapSearchPaged(Ldap,
                            Base,
                            LDAP_SCOPE_SUBTREE,
                            Filter,
                            Attrs,
                            LdapDumpSdWorker,
                            NULL);
    // paged search went okay
    if (dwErr != LDAP_SUCCESS && dwErr != LDAP_NO_SUCH_OBJECT) {
        return FALSE;
    }
    return TRUE;
}

BOOL
LdapAddDaclWorker(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapMsg,
    IN PVOID        Arg
    )
/*++
Routine Description:
    Add SDDL Aces to the DACL

Arguments:

Return Value:
    FALSE if problem
--*/
{
    PLDAPMessage            LdapEntry = NULL;
    PCHAR                   *ValuesCn = NULL;
    PCHAR                   *ValuesDn = NULL;
    PBERVAL                 *OldValuesSd = NULL;
    PCHAR                   OldStringSd = NULL;
    DWORD                   nOldStringSd = 0;
    LDAPMod                 **Mod = NULL;
    BOOL                    Ret = FALSE;
    PCHAR                   AddStringSd = Arg;
    PCHAR                   NewStringSd = NULL;
    DWORD                   nNewStringSd;
    PSECURITY_DESCRIPTOR    Sd;
    DWORD                   nSd;
    DWORD                   dwErr;
    LDAPControl             Control;
    LDAPControl             *aControl[2];
    BYTE                    AclInfo[5]
    ; INT                      Dacl = DACL_SECURITY_INFORMATION;

    Control.ldctl_oid = LDAP_SERVER_SD_FLAGS_OID;
    Control.ldctl_value.bv_len = sizeof(INT);
    Control.ldctl_value.bv_val = (PVOID)&Dacl;
    Control.ldctl_iscritical = TRUE;
    aControl[0] = &Control;
    aControl[1] = NULL;

    // scan thru the paged results
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        // cn
        ValuesCn = FindValues(Ldap, LdapEntry, ATTR_CN);
        if (!ValuesCn || !ValuesCn[0]) {
            goto cleanup;
        }

        printf("Processing %s...\n", ValuesCn[0]);

        // dn
        ValuesDn = FindValues(Ldap, LdapEntry, ATTR_DN);
        if (!ValuesDn || !ValuesDn[0]) {
            goto cleanup;
        }

        // Get Old SD
        OldValuesSd = FindBerValues(Ldap, LdapEntry, ATTR_SD);
        if (!OldValuesSd || 
            !OldValuesSd[0] || 
            !OldValuesSd[0]->bv_len || 
            !OldValuesSd[0]->bv_val) {
            goto cleanup;
        }

        // Old Sd -> Old String SD
        if (!ConvertSecurityDescriptorToStringSecurityDescriptor(OldValuesSd[0]->bv_val,
                                                                 SDDL_REVISION_1,
                                                                 DACL_SECURITY_INFORMATION,
                                                                 &OldStringSd,
                                                                 &nOldStringSd)) {
            if (Verbose) {
                printf("ConvertSdtoString(%s) ==> %08x\n", ValuesCn[0], GetLastError());
            }
            goto cleanup;
        }

        // Create new dacl
        nNewStringSd = strlen(OldStringSd) + strlen(AddStringSd) + 1;
        NewStringSd = malloc(nNewStringSd);
        strcpy(NewStringSd, OldStringSd);
        strcat(NewStringSd, AddStringSd);
        printf("%s: %s\n", ValuesCn[0], NewStringSd);
        if (!ConvertStringSecurityDescriptorToSecurityDescriptor(NewStringSd,
                                                                 SDDL_REVISION_1,
                                                                 &Sd,
                                                                 &nSd)) {
            if (Verbose) {
                printf("ConvertStringToSd(%s) ==> %08x\n", ValuesCn[0], GetLastError());
            }
            goto cleanup;
        }

        AddBerMod(ATTR_SD, Sd, nSd, &Mod);
        dwErr = ldap_modify_ext_s(Ldap, ValuesDn[0], Mod, aControl, NULL);
        if (dwErr) {
            if (Verbose) {
                printf("ldap_modify_ext_s(%s) ==> %08x (%08x): %s\n", 
                   ValuesCn[0], dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
            }
        }

        FREE_VALUES(ValuesCn);
        FREE_VALUES(ValuesDn);
        FREE_BERVALUES(OldValuesSd);
        FREE_LOCAL(OldStringSd);
        FREE_LOCAL(Sd);
        FreeMod(&Mod);
    }

    Ret = TRUE;

cleanup:
    FREE_VALUES(ValuesCn);
    FREE_VALUES(ValuesDn);
    FREE_BERVALUES(OldValuesSd);
    FREE_LOCAL(OldStringSd);
    FREE_LOCAL(Sd);
    FREE(NewStringSd);
    FreeMod(&Mod);
    return Ret;
}

BOOL
LdapAddDacl(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter,
    IN PCHAR        AddStringSd
    )
/*++
Routine Description:
    Delete entries returned from one level search of Base

Arguments:
            
Return Value:
    FALSE if problem
--*/
{
    DWORD   dwErr;
    PCHAR   Attrs[16];

    if (!AddStringSd) {
        return FALSE;
    }

    Attrs[0] = ATTR_CN;
    Attrs[1] = ATTR_SD;
    Attrs[2] = ATTR_DN;
    Attrs[3] = NULL;
    dwErr = LdapSearchPaged(Ldap,
                            Base,
                            LDAP_SCOPE_SUBTREE,
                            Filter,
                            Attrs,
                            LdapAddDaclWorker,
                            AddStringSd);
    // paged search went okay
    if (dwErr != LDAP_SUCCESS && dwErr != LDAP_NO_SUCH_OBJECT) {
        return FALSE;
    }
    return TRUE;
}

PLDAP
LdapBind(
    IN PCHAR    pDc,
    IN PCHAR    pUser,
    IN PCHAR    pDom,
    IN PCHAR    pPwd
    )
/*++
Routine Description:
    Bind to the DC

Arguments:
    pDc - domain controller or NULL
    pUser - user name or NULL
    pDom - domain name for pUser or NULL
    pPwd - password or NULL
            
Return Value:
    NULL if problem; otherwise bound ldap handle
--*/
{
    DWORD                       dwErr;
    PCHAR                       HostName = NULL;
    PLDAP                       Ldap = NULL;
    RPC_AUTH_IDENTITY_HANDLE    AuthIdentity = NULL;

    if (pUser || pDom || pPwd) {
        dwErr = DsMakePasswordCredentials(pUser, pDom, pPwd, &AuthIdentity);
        if (dwErr) {
            printf("DsMakePasswordCredentials(%s, %s, %s) ==> %08x\n",
                   pUser, pDom, pPwd, dwErr);
            return NULL;
        }
    }

    Ldap = ldap_open(pDc, LDAP_PORT);
    if (!Ldap) {
        dwErr = GetLastError();
        printf("ldap_open(%s) ==> %08x\n", pDc, dwErr);
        return NULL;
    }

    dwErr = ldap_bind_s(Ldap, "", AuthIdentity, LDAP_AUTH_NEGOTIATE);
    if (dwErr) {
        printf("ldap_bind_s() ==> %08x (%08x): %s\n", 
               dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
        UNBIND(Ldap);
        return NULL;
    }

    dwErr = ldap_get_option(Ldap,
                            LDAP_OPT_HOST_NAME,
                            &HostName);
    if (dwErr == LDAP_SUCCESS && HostName) {
        printf("\nBound to DC %s\n", HostName);
    }

    return (Ldap);
}

DWORD
base64encode(
    IN  VOID *  pDecodedBuffer,
    IN  DWORD   cbDecodedBufferSize,
    OUT LPSTR   pszEncodedString,
    IN  DWORD   cchEncodedStringSize,
    OUT DWORD * pcchEncoded             OPTIONAL
    )
/*++

Routine Description:

    Encode a base64-encoded string.

Arguments:

    pDecodedBuffer (IN) - buffer to encode.
    cbDecodedBufferSize (IN) - size of buffer to encode.
    cchEncodedStringSize (IN) - size of the buffer for the encoded string.
    pszEncodedString (OUT) = the encoded string.
    pcchEncoded (OUT) - size in characters of the encoded string.

Return Values:

    0 - success.
    ERROR_INVALID_PARAMETER
    ERROR_BUFFER_OVERFLOW

--*/
{
    static char rgchEncodeTable[64] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    DWORD   ib;
    DWORD   ich;
    DWORD   cchEncoded;
    BYTE    b0, b1, b2;
    BYTE *  pbDecodedBuffer = (BYTE *) pDecodedBuffer;

    // Calculate encoded string size.
    cchEncoded = 1 + (cbDecodedBufferSize + 2) / 3 * 4;

    if (NULL != pcchEncoded) {
        *pcchEncoded = cchEncoded;
    }

    if (cchEncodedStringSize < cchEncoded) {
        // Given buffer is too small to hold encoded string.
        return ERROR_BUFFER_OVERFLOW;
    }

    // Encode data byte triplets into four-byte clusters.
    ib = ich = 0;
    while (ib < cbDecodedBufferSize) {
        b0 = pbDecodedBuffer[ib++];
        b1 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;
        b2 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;

        pszEncodedString[ich++] = rgchEncodeTable[b0 >> 2];
        pszEncodedString[ich++] = rgchEncodeTable[((b0 << 4) & 0x30) | ((b1 >> 4) & 0x0f)];
        pszEncodedString[ich++] = rgchEncodeTable[((b1 << 2) & 0x3c) | ((b2 >> 6) & 0x03)];
        pszEncodedString[ich++] = rgchEncodeTable[b2 & 0x3f];
    }

    // Pad the last cluster as necessary to indicate the number of data bytes
    // it represents.
    switch (cbDecodedBufferSize % 3) {
      case 0:
        break;
      case 1:
        pszEncodedString[ich - 2] = '=';
        // fall through
      case 2:
        pszEncodedString[ich - 1] = '=';
        break;
    }

    // Null-terminate the encoded string.
    pszEncodedString[ich++] = '\0';

    return ERROR_SUCCESS;
}

DWORD
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pszEncodedString (IN) - base64-encoded string to decode.
    cbDecodeBufferSize (IN) - size in bytes of the decode buffer.
    pbDecodeBuffer (OUT) - holds the decoded data.
    pcbDecoded (OUT) - number of data bytes in the decoded data (if success or
        ERROR_BUFFER_OVERFLOW).

Return Values:

    0 - success.
    ERROR_INVALID_PARAMETER
    ERROR_BUFFER_OVERFLOW

--*/
{
#define NA (255)
#define DECODE(x) (((int)(x) < sizeof(rgbDecodeTable)) ? rgbDecodeTable[x] : NA)

    static BYTE rgbDecodeTable[128] = {
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 0-15 
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 16-31
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 63, NA, NA, NA, 62,  // 32-47
       52, 53, 54, 55, 56, 57, 58, 59, 60, 61, NA, NA, NA, NA, NA, NA,  // 48-63
       NA, NA,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  // 64-79
       15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, NA, NA, NA, NA, NA,  // 80-95
       NA, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,  // 96-111
       41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, NA, NA, NA, NA, NA,  // 112-127
    };

    DWORD   cbDecoded;
    DWORD   cchEncodedSize;
    DWORD   ich;
    DWORD   ib;
    BYTE    b0, b1, b2, b3;
    BYTE *  pbDecodeBuffer = (BYTE *) pDecodeBuffer;

    cchEncodedSize = lstrlenA(pszEncodedString);

    if ((0 == cchEncodedSize) || (0 != (cchEncodedSize % 4))) {
        // Input string is not sized correctly to be base64.
        return ERROR_INVALID_PARAMETER;
    }

    // Calculate decoded buffer size.
    cbDecoded = (cchEncodedSize + 3) / 4 * 3;
    if (pszEncodedString[cchEncodedSize-1] == '=') {
        if (pszEncodedString[cchEncodedSize-2] == '=') {
            // Only one data byte is encoded in the last cluster.
            cbDecoded -= 2;
        }
        else {
            // Only two data bytes are encoded in the last cluster.
            cbDecoded -= 1;
        }
    }

    if (NULL != pcbDecoded) {
        *pcbDecoded = cbDecoded;
    }

    if (cbDecoded > cbDecodeBufferSize) {
        // Supplied buffer is too small.
        return ERROR_BUFFER_OVERFLOW;
    }

    // Decode each four-byte cluster into the corresponding three data bytes.
    ich = ib = 0;
    while (ich < cchEncodedSize) {
        b0 = DECODE(pszEncodedString[ich++]);
        b1 = DECODE(pszEncodedString[ich++]);
        b2 = DECODE(pszEncodedString[ich++]);
        b3 = DECODE(pszEncodedString[ich++]);

        if ((NA == b0) || (NA == b1) || (NA == b2) || (NA == b3)) {
            // Contents of input string are not base64.
            return ERROR_INVALID_PARAMETER;
        }

        pbDecodeBuffer[ib++] = (b0 << 2) | (b1 >> 4);

        if (ib < cbDecodeBufferSize) {
            pbDecodeBuffer[ib++] = (b1 << 4) | (b2 >> 2);
    
            if (ib < cbDecodeBufferSize) {
                pbDecodeBuffer[ib++] = (b2 << 6) | b3;
            }
        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\balancep.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    balancep.h

Abstract:

    This module performs bridgehead balancing and schedule staggering. It depends upon the ldapp.h module.
    
Author:

    Ajit Krishnan (t-ajitk) 13-Jul-2001

Revision History:

    13-Jul-2001    t-ajitk
        Initial Writing
    22-Aug-2001 t-ajitk
        Satisfies load balancing spec
--*/


# ifndef _balancep_h
# define _balancep_h _balancep_h


# include <iostream>
# include <string>
# include <bitset>
# include <vector>
# include <map>

extern "C" {
#include <NTDSpch.h>

# include <windows.h>
# include <Assert.h>
# include <ismapi.h>
# include "LHMatch.h"
}

# include "ldapp.h"

using namespace std;

class BridgeheadBalance {
public:
    BridgeheadBalance (
        IN const wstring &m_root_dn,
        IN OUT LCCONN &conn,
        IN LCSERVER &eligible,
        IN bool balance_dest = true
    );
    /*++
    Routine Description:
        This constructor will accept a list of connection objects,
        eligible bridgeheads, and will balance the bridgeheads.
        It should be called once per transport. If balance_dest is true,
        all connections must have the same destination site. If balance_dest
        is false, all connections must have the same source site.
    Arguments:
        conn - connections of the appropriate transport type
        eligible - eligible bridgeheads of the appropriate transport type
        balance_dest - a flag indicating which end of the connections should
            be balanced. By default, the destination end will be balanced.
            If it is false, the source end will be balanced.
    --*/
private:
    void
    genPerformanceStats (
        IN LHGRAPH pGraph,
        IN int lSize,
        IN int rSize,
        IN LCSERVER&serv
        ) ;
    /*++
    Routine Description:
        Generate performance stats for a performance graph
        This routine should be called NUM_RUNS times. The last time it is called,
        it will dump stats to the log file (if the perfStats is true)
    Arguments:
        pGraph - A valid LH graph
        lSize - The number of vertices on the left side of the graph
        rSize - The number of vertices on the right side of the graph
        serv - A list of servers whose order corresponds to the vertices on the right side of the graph
    --*/


    wstring
    getServerName (
        IN Connection &c,
        IN bool balance_dest
        );
    /*++
    Routine Description:
        Determine the DN of the server
    Arguments:
        c - the connection whose server is being determined
        balance_dest - if true, determine the DN of the destination server.
            else, determine the DN of the source server.
    --*/

    void
    removeDuplicates (
        IN LHGRAPH pGraph,
        IN vector<int> & partition,
        IN int rSize
        );
    /*++
    Routine Description:
        Given an LH graph, and a set of left hand sides in a partition, remove all duplicates.
    Arguments:
        pGraph - An LH graph which may contain duplicates
        partition - The side of left hand side vertices forming the partition.Must contain at least 1 vertex.
        rSize - The number of vertices on the right side of the graph
        
    --*/
    
    bool
    isEligible (
        IN Connection &conn,
        IN Server &serv
        ) const;
    /*++
    Routine Description:
        Determine if a server is an eligible bridgehead for a given connection. To be considered 
        an eligible bridgehead the following criteria must be met:
        - All nc's being replicated must be hosted by the server
        - A writeable nc must replicate from a writeable nc
        - The nc in question must not be in the process of being deleted from the server
        - The replication type (ip,smtp) should match
        Notably, the current server is not considered eligible by this function. If this is required,
        the calling function should check for it.
    Arguments:
        conn - The connection for whom eligibility is being determined
        serv - The server whose eligibility is being determined
    --*/
private:
    static const int NUM_RUNS = 3;
    int run;

    int *MatchedVertex[3];
    int *NumMatched[3];
    int Cost[3];

    wstring m_root_dn;
};


/*++
Class Description:
    This is a function object which will be used to stagger schedules.
--*/
class ScheduleStagger {
public:
    ScheduleStagger (
        IN OUT LCCONN &l
        );
    /*++
    Routine Description:
        This constructor accepts a ldap container of connection objects. 
        It will stagger the schedule on each of the connection objects in 
        the ldap container.
    Arguments:
        l - An ldap container of connection objects
    --*/

    void
    ScheduleStaggerSameSource(
        IN OUT LCCONN &c
        );
    /*++
    Routine Description:
        Stagger the schedules of a given set of schedules. These should correspond to
        all connections outbound from a given server, and should be called once per server
        for outbound schedule staggering.
    Arguments:
        c - the partition of connections whose schedules should be staggered.
    --*/

private:

    /***** StaggeringInfo *****/
    /* This structure contains information about a connection for use
     * by the ScheduleStaggering routine.
     *
     * segments gives information about the segments in which we must
     * choose a time of replication.
     *
     * startingLVtx is the index of the first left-vertex in the LH
     * graph that is used by this connection.
     */
    typedef struct {
        SchedSegments   *segments;
        int             startingLVtx;
    } StaggeringInfo;

    typedef map<Connection*,StaggeringInfo> StagConnMap;

    wstring
    getServerName (
        IN Connection &c,
        IN bool balance_dest
        );
    /*++
    Routine Description:
        Determine the DN of the server
    Arguments:
        c - the connection whose server is being determined
        balance_dest - if true, determine the DN of the destination server.
            else, determine the DN of the source server.
    --*/
    
    static void
    PrintSchedule(
        IN const bitset<MAX_INTERVALS> &scheduleBits
        );
    /*++
    Routine Description:
        Print a schedule to the log file
    Arguments:
        scheduleBits - A reference to the bitset containing the schedule data
    --*/

    LHGRAPH
    SetupGraph(
        IN      LCCONN      &c,
        IN OUT  StagConnMap &connInfoMap
        );
    /*++
    Routine Description:
        Setup a graph for schedule staggering.
    Arguments:
        c - the set of connections whose schedules should be staggered.
        connInfoMap - A map containing staggering information about the connections
    --*/

    void
    ScheduleStaggerSameSource(
        IN      wstring &sourceServer,
        IN OUT  LCCONN  &c
        );
    /*++
    Routine Description:
        Stagger the schedules of a given set of schedules. These should correspond to
        all connections outbound from a given server, and should be called once per server
        for outbound schedule staggering.
    Arguments:
        sourceServer - The name of the source server whose connections to stagger.
        c - the set of connections whose schedules should be staggered.
    --*/
};


# endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\balance.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    balance.cpp

Abstract:

    This module performs bridgehead balancing and schedule staggering. It depends upon
    the ldapp.h module.
    
Author:

    Ajit Krishnan (t-ajitk) 13-Jul-2001

Revision History:

    Nick Harvey   (nickhar) 24-Sep-2001
        Reimplemented Schedule Staggering

--*/


#include "ldapp.h"
#include "ismp.h"
#include "balancep.h"

using namespace std;

/***** Inline Logging Macros *****/
#define LOG_STAGGER_SERVER \
    if (lbOpts.verbose || lbOpts.performanceStats ) { \
        *lbOpts.log << L"Staggering Schedules for server: " << sourceServer << endl \
                    << L"--------------------------------" << endl; \
    }

#define LOG_CONNECTION_SCHEDULES \
    if (lbOpts.verbose) { \
        *lbOpts.log << L"Connection: " << pConn->getName() << endl \
                    << L"Replication Interval (mins): " << pConn->getReplInterval() << endl \
                    << L"Availability Schedule" << endl; \
        PrintSchedule( pConn->getAvailabilitySchedule()->m_bs ); \
        *lbOpts.log << endl; \
        *lbOpts.log << L"Replication Schedule" << endl; \
        PrintSchedule( pConn->getReplicationSchedule()->m_bs ); \
        *lbOpts.log << endl << endl; \
    }

#define LOG_STAGGERING_COSTS \
    if (lbOpts.performanceStats) { \
        *lbOpts.log << L"Cost before staggering: " << cost_before << endl \
                    << L"Cost after staggering: " << cost_after << endl << endl; \
    }

#define LOG_CHANGED_SCHEDULE \
    if (lbOpts.verbose) { \
        *lbOpts.log << L"Updating schedule for connection: " << pConn->getName() << endl; \
        PrintSchedule( newReplBS ); \
        *lbOpts.log << endl << endl; \
    }

#define LOG_NOT_CHANGING_MANUAL \
    if (lbOpts.verbose) { \
        *lbOpts.log << L"Not updating schedule for connection: " << pConn->getName() << endl; \
        *lbOpts.log << L"Schedule was not updated because it is a manual connection: " \
            << endl << endl; \
    }

#define LOG_TOTAL_UPDATED \
    if (lbOpts.performanceStats) { \
        *lbOpts.log << cUpdatedConn << L" connections were updated" \
            << endl << endl; \
    }

#define LOG_BALANCING_COST \
    if( lbOpts.performanceStats ) { \
        *lbOpts.log << L"Balancing Cost Before: " << Cost[0] << endl; \
        *lbOpts.log << L"Balancing Cost After:  " << Cost[NUM_RUNS-1] << endl << endl; \
    }


bool
BridgeheadBalance :: isEligible (
    IN Connection &conn,
    IN Server &serv
    ) const
/*++

Routine Description:

    Determine is a server is an eligible bridgehead for a given connection. To be considered 
    an eligible bridgehead the following criteria must be met:
    - All nc's being replicated must be hosted by the server
    - A writeable nc must replicate from a writeable nc
    - The nc in question must not be in the process of being deleted from the server
    - The replication type (ip,smtp) should match
    Notably, the current server is not considered eligible by this function. If this is required,
    the calling function should check for it.
    
Arguments:

    conn - The connection for whom eligibility is being determined
    
    serv - The server whose eligibility is being determined

--*/
{
    vector<Nc> &conn_ncs = conn.getReplicatedNcs();
    vector<Nc> &serv_ncs = serv.getHostedNcs(m_root_dn);

    vector<Nc>::iterator ci=conn_ncs.begin();
    vector<Nc>::iterator si=serv_ncs.begin();

    LbToolOptions lbOpts = GetGlobalOptions();

    ci=conn_ncs.begin();
    si=serv_ncs.begin();
    
    // manual connections have no eligible bridgeheads
    // (except themselves) which will be dealt with by calling function
    if (conn.isManual()) {
        return false;
    }
    
    while (si != serv_ncs.end() && ci != conn_ncs.end()) {
        if (ci->getNcName() == si ->getNcName()) {
            // writeable must replicate from writeable
            if (ci->isWriteable() && !si->isWriteable()) {
                return false;
            }
            // should not be in process of being deleted
            if (si->isBeingDeleted()) {
                return false;
            }
            // match tranport types? A-ok. All servers supports ip. If smtp, check the server type.
            if (ci->getTransportType() == T_IP ||si->getTransportType() == T_SMTP) {
                // if no other ncs are replicated, it is eligible
                if (++ci == conn_ncs.end()) {
                    return true;
                }
            }
        }
        si++;
    }

    // some cs not hosted by server -> ineligible
    return false;
}

wstring
BridgeheadBalance :: getServerName (
    IN Connection &c,
    IN bool balance_dest    
    ) {
    /*++
    Routine Description:
    
        Determine the DN of the server
        
    Arguments:
    
        c - the connection whose server is being determined
        
        balance_dest - if true, determine the DN of the destination server.
            else, determine the DN of the source server.
    --*/

    wstring initial_server;
    if (balance_dest) {
        DnManip dn(c.getName());
        initial_server = dn.getParentDn(2);
    } else {
        initial_server = c.getFromServer();
    }
    return initial_server;
}


void
BridgeheadBalance::removeDuplicates(
    IN LHGRAPH pGraph,
    IN vector<int> & partition,
    IN int rSize
    )
/*++

Routine Description:

    Given an LH graph, and a set of left hand sides in a partition, remove all duplicates.
    
Arguments:

    pGraph - An LH graph which may contain duplicatesF
    
    partition - The side of left hand side vertices forming the partition. Must contain at
    least 1 vertex.

    rSize - The number of vertices on the right side of the graph

--*/
{
    Assert (partition.size() > 1 && rSize > 1 && L"removeDuplicates has an empty vertex list");
    LHGRAPH dupGraph = NULL;
    int ret = LHCreateGraph (partition.size(), rSize, &dupGraph);
    if (ret != LH_SUCCESS) {
        throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
    }

    vector<int>::iterator di;
    int lCount = 0;

    for (di = partition.begin(); di != partition.end(); di++) {
        // For each connection in the partition, add the appropriate edges
        int *rhsVertices=NULL;
        int numEdges = LHGetDegree (pGraph, *di, true);
        if (numEdges < 0) {
            throw Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR));
        }    

        for (int i=0; i<numEdges; i++) {
            int neighbour = LHGetNeighbour (pGraph, *di, true, i);
            if (neighbour < 0) {
                throw Error (GetMsgString(LBTOOL_LH_GRAPH_ERROR));
            }
            int ret = LHAddEdge (dupGraph, lCount, neighbour);
            if (ret != LH_SUCCESS) {
                throw Error (GetMsgString(LBTOOL_LH_GRAPH_ERROR));
            }
        }
        int vtx = LHGetMatchedVtx (pGraph, *di);
        if (vtx < 0) {
            throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
        }
        ret = LHSetMatchingEdge (dupGraph, lCount, vtx);
        if (ret != LH_SUCCESS) {
            throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
        }    
        lCount++;
    }

    // Run the algorithm on this subgraph    
    ret = LHFindLHMatching (dupGraph, LH_ALG_DEFAULT);
    if (ret != LH_SUCCESS) {
        throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
    }    

    // And set the matching edges on the original graph accordingly
    lCount = 0;
    for (di = partition.begin(); di != partition.end(); di++) {
        int vtx = LHGetMatchedVtx (dupGraph, lCount);
        if (vtx < 0) {
            throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
        }

        ret = LHSetMatchingEdge (pGraph, *di, vtx);
        if (ret != LH_SUCCESS) {
            throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
        }    
        lCount++;
    }

    LHSTATS stats;
    ret = LHGetStatistics(dupGraph, &stats);
    Assert( stats.matchingCost == partition.size() );
    ret = LHDestroyGraph (dupGraph);
    if (ret != LH_SUCCESS) {
        throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
    }

}

void
BridgeheadBalance::genPerformanceStats(
    IN LHGRAPH pGraph,
    IN int lSize,
    IN int rSize,
    IN LCSERVER &serv
    )
/*++
Routine Description:

    Generate performance stats for a performance graph
    This routine should be called NUM_RUNS times. The last time it is called,
    it will dump stats to the log file (if the perfStats is true)
    
Arguments:

    pGraph - A valid LH graph
    
    lSize - The number of vertices on the left side of the graph
    
    rSize - The number of vertices on the right side of the graph
    
    serv - A list of servers whose order corresponds to the vertices on the right side of
    the graph
--*/
{
    LbToolOptions lbOpts;
    LHSTATS stats;
    int ret;
    
    lbOpts = GetGlobalOptions();

    if( !lbOpts.performanceStats ) {
        return;
    }
    
    MatchedVertex[run] = (int*)(malloc(sizeof (int) * lSize));
    NumMatched[run] = (int*)(malloc(sizeof(int) * rSize));
    if (!MatchedVertex[run] || ! NumMatched[run]) {
        throw (Error(GetMsgString(LBTOOL_OUT_OF_MEMORY)));
    }
    
    ret = LHGetStatistics(pGraph, &stats);
    Cost[run] = stats.matchingCost;

    for (int i=0; i<lSize; i++) {
        int vtx = LHGetMatchedVtx (pGraph, i);
        if (vtx < 0) {
            throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
        }
        MatchedVertex[run][i] = vtx;
    }
            
    for (int i=0; i<rSize; i++) {
        int numMatched = LHGetMatchedDegree(pGraph, i);
        if (numMatched < 0) {
            throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
        }
        NumMatched[run][i] = numMatched;
    }

    if( run == NUM_RUNS-1 ) {
        SSERVER::iterator si = serv.objects.begin();
        
        LOG_BALANCING_COST;

        *lbOpts.log <<
        L"                                 DC Name"
        L"   Load Before"
        L"  Interim Load"
        L"    Load After" << endl;

        for (int i=0; i<rSize; i++) {
            *lbOpts.log << setw(5) << i;
            DnManip dn((*si)->getName());
            *lbOpts.log << setw(35) << dn.getRdn();
            
            for (int j=0; j<NUM_RUNS; j++) {
                *lbOpts.log << setw(14) << NumMatched[j][i];
            }
            *lbOpts.log << endl;
            si++;
         }
        *lbOpts.log << endl;
    }

    run++;
}

BridgeheadBalance::BridgeheadBalance(
    IN const wstring &root_dn,
    IN OUT LCCONN &conn,
    IN LCSERVER &eligible,
    IN bool balance_dest
    )
/*++

Routine Description:

    This constructor will accept a list of connection objects,
    eligible bridgeheads, and will balance the bridgeheads.
    It should be called once per transport.
    
Arguments:

    root_dn - the root dn
    
    conn - connections of the appropriate transport type
    
    eligible - eligible bridgeheads of the appropriate transport type
    
    balance_dest - a flag indicating which end of the connections should
        be balanced. By default, the destination end will be balanced.
        If it is false, the source end will be balanced.

Implementation Details:
    First, set up an LH graph structure, and balance the bridgeheads
    without worrying about duplicates. Then, partition the connections based
    on server. For each of these partitions, remove the duplicates. We know have
    a subgraph with no duplicates (if such a matching exists). Then, we can
    modify the from/to servers of the connection objects in question.
    If balance_dest is true, we partition based on source server. 
    If it is false, we partition based on the destinatio server.

--*/
{
    const int NO_INITIAL_MATCH = -1;
    SSERVER::iterator si;
    SCONN::iterator ci;
    vector<Connection*> connArray;
    LHGRAPH pGraph = NULL;
    int lSize, rSize, ret;

    m_root_dn = root_dn;
    run = 0;

    lSize = conn.objects.size();
    rSize = eligible.objects.size();

    ret = LHCreateGraph(lSize, rSize, &pGraph);
    if( ret != LH_SUCCESS ) {
        throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
    }
   
    vector<int> initial_matching;

    LbToolOptions lbOpts = GetGlobalOptions();

    // add edges for each eligible bridgehead
    int lCount = 0;
    for (ci = conn.objects.begin(); ci != conn.objects.end(); ci++) {
        int rCount = 0;
        wstring initial_server = getServerName (*(*ci), balance_dest);
        connArray.push_back (*ci);
        // check for all eligible bridgeheads. current server is always eligible
        if (lbOpts.verbose) {
            *lbOpts.log << endl << (*ci)->getName() << endl;
            if (balance_dest) {
                *lbOpts.log << GetMsgString(LBTOOL_PRINT_CLI_DEST_ELIGIBLE_BH);
            } else {
                *lbOpts.log << GetMsgString(LBTOOL_PRINT_CLI_SOURCE_ELIGIBLE_BH);
            }
        }

        for (si = eligible.objects.begin(); si != eligible.objects.end(); si++) {
            wstring from_server = (*ci)->getFromServer();
            if (!balance_dest) {
                from_server = getServerName(*(*ci), balance_dest);
                DnManip dn2 (from_server);
                from_server = dn2.getParentDn(1);                
            }

            if ((balance_dest && (*si)->getName() == initial_server) ||
                 (!balance_dest && (*si)->getName() == from_server) ) {
                if (lbOpts.verbose) {
                    *lbOpts.log << L"(" << lCount << L"," << rCount << L") *" << (*si)->getName() << endl;
                }
                ret = LHAddEdge (pGraph, lCount, rCount);
                if (ret != LH_SUCCESS) {
                    throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
                }    
                ret = LHSetMatchingEdge (pGraph, lCount, rCount);
                if (ret != LH_SUCCESS) {
                    throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
                }                    
                initial_matching.push_back (rCount);
            } else if ((*si)->isPreferredBridgehead((*ci)->getTransportType()) && isEligible (*(*ci), *(*si))) {
                if (lbOpts.verbose) {
                    *lbOpts.log << L"(" << lCount << L"," << rCount << L")  " << (*si)->getName() << endl;
                }
                ret = LHAddEdge (pGraph, lCount, rCount);
                if (ret != LH_SUCCESS) {
                    throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
                }    
            }  
            rCount++;
        }
        lCount++;
        if (initial_matching.size() != lCount) {
            initial_matching.push_back (NO_INITIAL_MATCH);
        }
    }

    genPerformanceStats(pGraph, lSize, rSize, eligible);
    
    ret = LHFindLHMatching (pGraph, LH_ALG_DEFAULT);
    if (ret != LH_SUCCESS) {
        throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
    }    

    if (lbOpts.verbose && lbOpts.performanceStats) {
        *lbOpts.log << L"Optimal Matching with duplicates generated: " << endl;
    }

    genPerformanceStats(pGraph, lSize, rSize, eligible);

    // It is undesirable to have duplicate connections -- connections with the
    // same source and destination servers. The next block of code is designed
    // to prevent creation of duplicate connections by moving connections to
    // other servers.
    // 
    // Implementation:
    // Partition the connections into disjoint sets of connections that
    // replicate to the same server. Run the 'removeDuplicates' function to
    // remove any duplicates from the set.

    // Create an array of boolean to indicate whether a connection has already
    // been assigned to a partition set or not.
    bool *bs = new bool[lSize];
    memset(bs, 0, lSize * sizeof(bool));

    // BUGBUG: nickhar: this implementation requires O(n^2) time. It is possible to
    // perform this operation in O(n log n) time.
    for(int i=0; i<lSize; i++) {
        vector<int> partition;
        Connection  *pConn, *pConn2;

        if( true == bs[i] ) {
            continue;   // This connection has been previously taken care of
        }
        bs[i] = true;
        
        // Determine this connection's remote server name (i.e. the one not in
        // the site being balanced).
        pConn = connArray[i];
        wstring site_name = getServerName(*pConn, !balance_dest);
        partition.push_back (i);    // Add server to this partition set

        // If 'balance_dest' is true, we're looking for connections with the
        // same From server. If 'balance_dest' is false, we're looking for
        // connections with the same To server.
        for (int j=i+1; j<lSize; j++) {
            if (bs[j] == true) {
                continue;       // previously dealt with
            }

            pConn2 = connArray[j];
            wstring site_name_b = getServerName(*pConn2, !balance_dest);
  
            if (site_name == site_name_b && initial_matching[j] != -1) {
                bs[j] = true;
                partition.push_back (j);
            }
        }

        // remove duplicates if there are more than one site in a partition
        if (partition.size() > 1) {
            removeDuplicates(pGraph, partition, rSize);
        }
    }
    delete bs;

    if (lbOpts.verbose && lbOpts.performanceStats) {
        *lbOpts.log << L"Optimal non-duplicate matching generated: " << endl << endl;
    }
    genPerformanceStats (pGraph, lSize, rSize, eligible);


    // now modify the connection objects as necessary

    // generate mapping for right side
    vector<Server*> server_map;
    for (si = eligible.objects.begin(); si != eligible.objects.end(); si++) {
        server_map.push_back (*si);
    }

    int cUpdatedConn=0;
    lCount = 0;
    for (ci = conn.objects.begin(); ci != conn.objects.end(); ci++) {
        int edge = LHGetMatchedVtx (pGraph, lCount);
        Connection *pConn;
        
        if (edge < 0) {
            throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
        }
        // ignore those connections that have not changed
        if (edge == initial_matching[lCount]) {
            lCount++;
            continue;
        }

        // Manual connections should have only one eligible edge so their
        // selected edge should not have changed.
        pConn = *ci;
        Assert( !pConn->isManual() );

        if (balance_dest) {
            if (lbOpts.verbose) {
                *lbOpts.log << endl << endl << L"Renaming: " << lCount << endl;
                *lbOpts.log << pConn->getName();
            }
            DnManip dn (pConn->getName());
            wstring rn = dn.getRdn();
            pConn->rename(rn + L",CN=NTDS Settings," + server_map[edge]->getName());
            if (lbOpts.verbose) {
                *lbOpts.log << endl << pConn->getName() << endl;
            }
        } else {
            wstring from_server = L"CN=NTDS Settings," + server_map[edge]->getName();
            pConn->setFromServer (from_server);
        }
        lCount++;
        cUpdatedConn++;
    }

    LOG_TOTAL_UPDATED;
    
    ret = LHDestroyGraph (pGraph);
    if (ret != LH_SUCCESS) {
        throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
    }
    
}


#define GET_DESTINATION_SERVER  true
#define GET_SOURCE_SERVER       false


wstring
ScheduleStagger::getServerName(
    IN Connection &c,
    IN bool fDestServer    
    )
/*++
Routine Description:

    Determine the DN of the server
    
Arguments:

    c - the connection whose server is being determined
    
    fDestServer - If equals GET_DESTINATION_SERVER, determine the DN of
        the destination server. If equals GET_SOURCE_SERVER, determine the
        DN of the source server.
--*/
{
    wstring server;
    if( GET_DESTINATION_SERVER==fDestServer ) {
        DnManip dn(c.getName());
        server = dn.getParentDn(2);
    } else {
        Assert( GET_SOURCE_SERVER==fDestServer );
        server = c.getFromServer();
    }
    return server;
}


void
ScheduleStagger :: PrintSchedule(
    IN const bitset<MAX_INTERVALS> &scheduleBits
    )
/*++

Routine Description:

    Print a schedule to the log file
    
Arguments:

    scheduleBits - A reference to the bitset containing the schedule data

--*/
{
    LbToolOptions lbOpts = GetGlobalOptions();
    const int INTERVALS_PER_DAY = 4 * 24;

    for (int i=0; i<MAX_INTERVALS; i++) {
        *lbOpts.log << (int) ( scheduleBits[i] ? 1 : 0 );

        // Print a line feed after every day
        if( (i%INTERVALS_PER_DAY) == (INTERVALS_PER_DAY-1) ) {
            *lbOpts.log << endl;
        }
    }
}


LHGRAPH
ScheduleStagger::SetupGraph(
    IN      LCCONN      &c,
    IN OUT  StagConnMap &connInfoMap
    )
/*++

Routine Description:

    Setup a graph for schedule staggering.

Arguments:

    c - the set of connections whose schedules should be staggered.

    connInfoMap - A map containing staggering information about the connections

Detailed Description:

    Step 0: For each connection, dump its availability and replication schedules.

    Step 1: For each connection, compute its "replication segments". These are
        contiguous periods of availability in which we should replicate once.

    Step 2: Determine the total number of replication segments over all connections.

    Step 3: Create a LH graph for doing the staggering and add all the
        required edges to the graph.

    Step 4: For every connections and every replication segment, look at the
        connection's current replication schedules for a time of replication.
        If one is found, this time is considered to be the 'initial replication
        time'. The staggering operation works by possibly changing this
        'initial time' to some other time. The edge corresponding to this
        'initial replication time' is set to be a matching edge.

    Note: Manual schedules should be handled specially here. Their 'availability
        schedule' should be defined purely by their replication schedule. We do
        not bother to do this here and therefore may not end up with an optimal
        balancing later.

--*/
{
    LbToolOptions lbOpts;
    Connection *pConn;
    SchedSegments *segments;
    LHGRAPH pGraph = NULL;
    SCONN::iterator ii;
    int ret, replInterval, cTotalSegments=0;

    lbOpts = GetGlobalOptions();

    // Examine every connection which pulls from this server
    for( ii=c.objects.begin(); ii!=c.objects.end(); ii++ ) {

        pConn = (*ii);
        LOG_CONNECTION_SCHEDULES;

        // Get replication interval
        replInterval = pConn->getReplInterval() / 15;

        // Compute the replication segments for each connection
        // and store in map.
        segments = pConn->getAvailabilitySchedule()->GetSegments(replInterval);
        connInfoMap[pConn].segments = segments;
        connInfoMap[pConn].startingLVtx = cTotalSegments;
        
        // Calculate the total number of segments
        cTotalSegments += segments->size();
        
    }

    // Create the LH graph
    ret = LHCreateGraph( cTotalSegments, MAX_INTERVALS, &pGraph );
    if( LH_SUCCESS!=ret ) {
        throw Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR));
    }

    // Examine all connections again in order to create edges and initial matching
    for( ii=c.objects.begin(); ii!=c.objects.end(); ii++ ) {
        bitset<MAX_INTERVALS>   bs_avail, bs_repl;
        int                     startingLVtx, segmentIndex=0;
        SegmentDescriptor       segDesc;
        SchedSegments::iterator jj;

        pConn = (*ii);
        segments = connInfoMap[pConn].segments;
        startingLVtx = connInfoMap[pConn].startingLVtx;

        // Find bitsets for current availability / replication schedules
        bs_avail = pConn->getAvailabilitySchedule()->getBitset();
        bs_repl  = pConn->getReplicationSchedule()->getBitset();

        // Add edges to the graph for every segment
        for( jj=segments->begin(); jj!=segments->end(); jj++ ) {
            int iChunk, chunkInitRepl=-1;
            
            segDesc = *jj;
            for( iChunk=segDesc.start; iChunk<=segDesc.end; iChunk++ ) {
                // Availability schedule is available at this chunk
                // so we should add an edge to the LHMatch graph indicating
                // the possibility of replicating during this chunk.
                if( bs_avail[iChunk] ) {
                    ret = LHAddEdge( pGraph, startingLVtx+segmentIndex, iChunk );
                    if (ret != LH_SUCCESS) {
                        throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
                    }

                    if( bs_repl[iChunk] ) {
                        // Existing replication schedule replicates during
                        // this chunk so this chunk can be used as the initial
                        // replication time.
                        chunkInitRepl = iChunk;
                    }
                }
            }

            if( chunkInitRepl > 0 ) {
                ret = LHSetMatchingEdge(pGraph, startingLVtx+segmentIndex, chunkInitRepl);
                Assert( LH_SUCCESS==ret );
            }

            segmentIndex++;
        }
    }

    return pGraph;
}


void
ScheduleStagger::ScheduleStaggerSameSource(
    IN      wstring &sourceServer,
    IN OUT  LCCONN  &c
    )
/*++

Routine Description:

    Stagger the schedules of a given set of schedules. These should correspond to
    all connections outbound from a given server, and should be called once per server
    for outbound schedule staggering.

Arguments:

    sourceServer - The name of the source server whose connections to stagger.
    
    c - the set of connections whose schedules should be staggered.

Detailed Description:

    Step 0: Build a graph representing the current state of the schedules
        and a map containing extra staggering information about the connections.

    Step 1: Run the LHMatch algorithm to improve the schedule-staggering.

    Step 2: For each connection, construct its new replication schedule.
        If this differs from the old schedule, update the old schedule.


--*/
{
    LbToolOptions lbOpts;
    StagConnMap connInfoMap;
    LHGRAPH pGraph = NULL;
    LHSTATS stats;
    SchedSegments *segments;
    SCONN::iterator ii;
    Connection *pConn;
    int cost_before, cost_after;
    int ret, replInterval, cUpdatedConn=0;

    lbOpts = GetGlobalOptions();
    LOG_STAGGER_SERVER;
    
    pGraph = SetupGraph( c, connInfoMap );

    ret = LHGetStatistics(pGraph, &stats);
    Assert( ret==LH_SUCCESS );
    cost_before = stats.matchingCost;
    
    // Generate the optimal matching
    ret = LHFindLHMatching (pGraph, LH_ALG_DEFAULT);
    if (ret != LH_SUCCESS) {
        throw (Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR)));
    }

    ret = LHGetStatistics(pGraph, &stats);
    Assert( ret==LH_SUCCESS );
    cost_after = stats.matchingCost;

    LOG_STAGGERING_COSTS;

    // Note: It is possible that cost_after > cost_before here.
    // In this case, it seems that it would be unnecessary to update the
    // schedules with the new (worse) cost. However, it is possible that the
    // existing schedules have a low cost because the schedules are incorrect.
    // So we update the cost regardless of whether the cost has improved or
    // deteriorated.

    // Determine the new computed replication schedules for each connection and
    // update the schedules if necessary.
    for( ii=c.objects.begin(); ii!=c.objects.end(); ii++ ) {
        SchedSegments::iterator jj;
        bitset<MAX_INTERVALS>   newReplBS(0), oldReplBS;
        int                     startingLVtx, rVtx, segmentIndex=0;

        pConn = (*ii);
        replInterval = pConn->getReplInterval();
        segments = connInfoMap[pConn].segments;
        startingLVtx = connInfoMap[pConn].startingLVtx;

        // Find out when to replicate in each chunk
        for( jj=segments->begin(); jj!=segments->end(); jj++ ) {
            rVtx = LHGetMatchedVtx(pGraph, startingLVtx+segmentIndex);
            Assert( rVtx>=0 );
            newReplBS[rVtx] = true;
            segmentIndex++;
        }

        // find bitset representing current replication schedule
        // and update the connection object if necessary
        oldReplBS = pConn->getReplicationSchedule()->getBitset();

        if( oldReplBS!=newReplBS ) {

            if( pConn->isManual() ) {
                // Manual connections cannot be updated
                LOG_NOT_CHANGING_MANUAL;
            } else {
                LOG_CHANGED_SCHEDULE;
                 
                // Set the new replication schedule on the connection object
                Schedule *new_s = new Schedule;
                new_s->setSchedule(newReplBS, replInterval);
                pConn->setReplicationSchedule(new_s);
                pConn->setUserOwnedSchedule();

                cUpdatedConn++;
            }
        }
    }

    LOG_TOTAL_UPDATED;

    ret = LHDestroyGraph(pGraph);
    if (ret != LH_SUCCESS) {
        throw Error(GetMsgString(LBTOOL_LH_GRAPH_ERROR));
    }

    // TODO: Should iterate through the map and destroy its contents here
}


ScheduleStagger::ScheduleStagger(
    IN OUT LCCONN& c
    )
/*++

Routine Description:

    This constructor accepts a ldap container of connection objects. 
    It will stagger the schedule on the connection objects per server in 
    the ldap container in order to minimize the load on the source DCs.
    
Arguments:

    l - An ldap container of connection objects

Implementation Details:

    We first group the connections by their source server.
    We then stagger the schedules on the connections in each group.
    The current replication schedules will be used to determine the initial
    matching. The availability schedules will be used to determine all possible
    matchings. The output matchings (new replication schedules) will be used
    to modify the existing connections.

    Note: It is possible to implement this function more efficiently by simply
    partitioning the connections into disjoint sets, grouped by source server.

--*/
{
    vector<wstring> serverList, serverSet;
    SCONN::iterator ci;
    vector<wstring>::iterator si;
    wstring sdn;
    int cmpStr;
    

    // First compute the list of all source servers over all the connections.
    // This list will likely include duplicates. Sort the list and keep
    // only unique objects, making it a set. Store the set in serverSet.
    for( ci=c.objects.begin(); ci!=c.objects.end(); ci++ ) {
        wstring sdn = getServerName(**ci, GET_SOURCE_SERVER);
        serverList.push_back(sdn);
    }
    sort(serverList.begin(), serverList.end());
    unique_copy(serverList.begin(), serverList.end(), back_inserter(serverSet));


    // For each server in the set, find the set of connections that replicate
    // from that server. Stagger the schedules on this set of connections.
    for( si=serverSet.begin(); si!=serverSet.end(); si++ ) {
        LCCONN connToStagger(L"");

        // Find all connections outgoing from current server
        for( ci=c.objects.begin(); ci!=c.objects.end(); ci++ ) {
            sdn = getServerName(*(*ci), false);
            cmpStr = _wcsicoll(si->c_str(), sdn.c_str());
            if( 0==cmpStr ) {
                connToStagger.objects.insert (*ci);
            }
        }

        // Stagger them
        if( connToStagger.objects.size()>0 ) {
            ScheduleStaggerSameSource( *si, connToStagger );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\base64.h ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.h

ABSTRACT:

    The base64 funcionality for ldifldap.lib.

DETAILS:
    
    It follows the base64 encoding standard of RFC 1521.
    
CREATED:

    07/17/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/
#ifndef _BASE_H
#define _BASE_H

#include "ldapp.h"

PBYTE base64decode(PWSTR bufcoded, long * plDecodedSize);
PWSTR base64encode(PBYTE bufin, long nbytes);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\base64.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.c

ABSTRACT:

    The base64 funcionality for ldifldap.lib.

DETAILS:
    
    Stolen from \nt\ds\ds\src\util\ldifds\ldifldap\base64.c
    
CREATED:

    07/17/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/

#include "base64.h"

//-------------------------------------------------------------------------------------------
// Function:     base64decode()
//
// Description:  base-64 decode a string of data. The data must be '\0' terminated.
//
// Arguments:    bufcoded       -pointer to encoded data
//               pcbDecoded     -number of decode bytes
//
// Return Value: Returns pointer to byte blob  is successful; otherwise NULL is returned.
//-------------------------------------------------------------------------------------------
PBYTE 
base64decode(
    PWSTR pszBufCoded, 
    long * plDecodedSize
    )
{
    long lBytesDecoded;
    int pr2six[256];
    int i;
    int j=0;
    PWSTR pszCur = pszBufCoded;
    int fDone = FALSE;
    long lBufSize = 0;
    long lCount = 0;
    PWSTR pszBufIn = NULL;
    PBYTE pbBufOut = NULL;
    PBYTE pbTemp = NULL;    
    PBYTE pbBufDecoded = NULL;
    int lop_off;
    HRESULT hr = S_OK;

    //
    // Build up the reverse index from base64 characters to values
    // The multiple loops are easier
    //
    for (i=65; i<91; i++) {
         pr2six[i]=j++;
    }
    
    for (i=97; i<123; i++) {
         pr2six[i]=j++;
    }
    
    for (i=48; i<58; i++) {
        pr2six[i]=j++;
    }

    pr2six[43]=j++;
    pr2six[47]=j++;
    pr2six[61]=0;

    //
    // The old code relied on the size of the original data provided before 
    // the encoding. We don't have that, so we'll just allocate as much as 
    // the encoded data, relying on the fact that the encoded data is always 
    // larger. (+4 for good measure)
    // 
    lBufSize=wcslen(pszCur)-1+4;
    *plDecodedSize = lBufSize;

    pbBufDecoded = (PBYTE)malloc(lBufSize*sizeof(BYTE));
    if(!pbBufDecoded) {
        hr = E_OUTOFMEMORY;
        return(NULL);
    }

        
    lCount=wcslen(pszCur);

    // Do the decoding to new buffer
    pszBufIn = pszCur;
    pbBufOut = pbBufDecoded;

    while(lCount > 0) {
        *(pbBufOut++) = (BYTE) (pr2six[*pszBufIn] << 2 | pr2six[pszBufIn[1]] >> 4);
        *(pbBufOut++) = (BYTE) (pr2six[pszBufIn[1]] << 4 | pr2six[pszBufIn[2]] >> 2);
        *(pbBufOut++) = (BYTE) (pr2six[pszBufIn[2]] << 6 | pr2six[pszBufIn[3]]);
        pszBufIn += 4;
        lCount -= 4;
    }

    //
    // The line below does not make much sense since \0 is really a valid 
    // binary value, so we can't add it to our data stream
    //
    //*(pbBufOut++) = '\0';
    
    //
    // Let's calculate the real size of our data
    //
    *plDecodedSize=(ULONG)(pbBufOut-pbBufDecoded);
    
    // 
    // if there were pads in the encoded stream, lop off the nulls the 
    // NULLS they created
    //
    lop_off=0;
    if (pszBufIn[-1]=='=') lop_off++;
    if (pszBufIn[-2]=='=') lop_off++;
    
    *plDecodedSize=*plDecodedSize-lop_off;

    pbTemp = (PBYTE) malloc((*plDecodedSize)*sizeof(BYTE));
    if (!pbTemp) {
        hr = E_OUTOFMEMORY;
        free( pbBufDecoded );
        return(NULL);
    }
    memcpy(pbTemp, pbBufDecoded, (*plDecodedSize)*sizeof(BYTE));

    if (pbBufDecoded) {
        free(pbBufDecoded);
    }
    return pbTemp; 
}

//
// the map for the encoder, according to RFC 1521
//
WCHAR _six2pr64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};


//-------------------------------------------------------------------------------------------
// Function:     base64encode()
//
// Description:  base-64 encode a string of data
//
// Arguments:    bufin          -pointer to data to encode
//               nbytes         -number of bytes to encode (do not include the trailing '\0'
//                                                          in this measurement if it is a string.)
//
// Return Value: Returns '\0' terminated string if successful; otherwise NULL is returned.
//-------------------------------------------------------------------------------------------
PWSTR 
base64encode(
    PBYTE pbBufInput, 
    long nBytes
    )
{
    PWSTR pszOut = NULL;
    PWSTR pszReturn = NULL;
    long i;
    long OutBufSize;
    PWSTR six2pr = _six2pr64;
    PBYTE pbBufIn = NULL;
    PBYTE pbBuffer = NULL;
    DWORD nPadding;

    //  
    // Size of input buffer * 133%
    //  
    OutBufSize = nBytes + ((nBytes + 3) / 3) + 5; 

    //
    //  Allocate buffer with 133% of nBytes
    //
    pszOut = (PWSTR)malloc((OutBufSize + 1)*sizeof(WCHAR));
    if( NULL==pszOut ) {
        return NULL;
    }
    pszReturn = pszOut;

    nPadding = 3 - (nBytes % 3);
    if (nPadding == 3) {
        pbBufIn = pbBufInput;
    }
    else {
        pbBuffer = (PBYTE)malloc(nBytes + nPadding);
        if( NULL==pbBuffer ) {
            free(pszOut);
            return NULL;
        }

        pbBufIn = pbBuffer;
        memcpy(pbBufIn,pbBufInput,nBytes);
        while (nPadding) {
            pbBufIn[nBytes+nPadding-1] = 0;
            nPadding--;
        }
    }
    

    //
    // Encode everything
    //  
    for (i=0; i<nBytes; i += 3) {
        *(pszOut++) = six2pr[*pbBufIn >> 2];                                     // c1 
        *(pszOut++) = six2pr[((*pbBufIn << 4) & 060) | ((pbBufIn[1] >> 4) & 017)]; // c2
        *(pszOut++) = six2pr[((pbBufIn[1] << 2) & 074) | ((pbBufIn[2] >> 6) & 03)];// c3
        *(pszOut++) = six2pr[pbBufIn[2] & 077];                                  // c4 
        pbBufIn += 3;
    }

    //
    // If nBytes was not a multiple of 3, then we have encoded too
    // many characters.  Adjust appropriately.
    //
    if (i == nBytes+1) {
        // There were only 2 bytes in that last group 
        pszOut[-1] = '=';
    } 
    else if (i == nBytes+2) {
        // There was only 1 byte in that last group 
        pszOut[-1] = '=';
        pszOut[-2] = '=';
    }

    *pszOut = '\0';

    if (pbBuffer) {
        free(pbBuffer);
    }

    return pszReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\driver.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    driver.h

Abstract:

    This module puts together various components to allow bridgehead balancing and schedule staggering.
    
Author:

    Ajit Krishnan (t-ajitk) 13-Jul-2001

Revision History:

    13-Jul-2001    t-ajitk
        Initial Writing
    22-Aug-2001 t-ajitk
        Satisfies load balancing spec
--*/

# include "ldapp.h"
# include "ismp.h"
# include "balancep.h"
# include <algorithm>
# include <iomanip>
# include <iostream>
using namespace std;

#define CR        0xD
#define BACKSPACE 0x8

wostream &
operator << (
    wostream &os, 
    const LbToolOptions &opt
    );
/*++
Routine Description:
    Standard ostream operator for lbToolOptions
Arguments:
    os - a standard wostream
    opt - the lbToolOptions which should be dumped to os
--*/

bool
GetPassword(
    WCHAR *     pwszBuf,
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    );
/*++

Routine Description:
    Retrieve password from command line (without echo).
    Code stolen from LUI_GetPasswdStr (net\netcmd\common\lui.c).
Arguments:
    pwszBuf - buffer to fill with password
    cchBufMax - buffer size (incl. space for terminating null)
    pcchBufUsed - on return holds number of characters used in password
Return Values:
    true - success
    other - failure
--*/


void GatherInput (
    IN LdapInfo &info,
    IN const wstring &site,
    OUT LCSERVER &servers,
    OUT LCSERVER &all_servers,
    OUT LCNTDSDSA &ntdsdsas,
    OUT LCCONN &inbound,
    OUT LCCONN &outbound,
    OUT LCSERVER &bridgeheads
    );
/*++
Routine Description:
    Query the ldap server & ISM to get all information required for this tools operation
Arguments:
    Info - The LDAP credential information
    site - the dn of the site we are balancing
    servers - a container where all servers in the current site should be placed
    all_servers - a container where all servers in the forest should be placed
    ntdsdsas - a container where all ntdsdsas in the current site should be placed
    inbound - a container where all connections inbound to the current site should be placed
    outbound - a countainer where all connections outbound from the current site should be placed
    bridgeheads - a container where all preferred bridgeheads from the current site should be placed
--*/

void 
UpdateCache (
    IN OUT LCSERVER &servers,
    IN OUT LCNTDSDSA &ntdsdsas
    );
/*++
Routine Description:
    Update the servers/ntdsdsas cache of each other. Each server and ntdsdsa
    must have one matching counterpart.
Arguments:
    servers - the list of servers
    ntdsdsas - the list of ntdsdsas
--*/


bool 
parseOptionFind (
    IN map<wstring,wstring> &options,
    IN const wstring &opt_a,
    IN const wstring &opt_b,
    OUT wstring &value
    );
/*++
Routine Description:
    Look for an argument in a map<wstring,wstring> structure, using 2 specified keys
Arguments:
    options: A map structure containing key:value pairs
    opt_a: The key for the option
    opt_b: Another key for the option
    value: The value if the key exists, and NULL otherwise
Return value:
    true if the key was found, and false otherwise
--*/

bool 
parseOptions (
    IN int argc,
    IN WCHAR **argv,
    OUT LbToolOptions &lbopts
    );
/*++
Routine Description:
    Parse the arguments for lbtool
Arguments:
    argc - The number of arguments
    argv - The list of arguments
    lbopts - The options structure this function will populate
Return Value:
    true if the parsing was successful, false otherwise (aka not all values specified etc).
--*/


void
RemoveIntraSiteConnections (
    IN const wstring &site,
    IN OUT LCCONN & conn,
    IN bool inbound );
/*++
Routine Description:
    Remove intra site connections froma list of connections
Arguments:
    site - The FQDN of the side
    conn - A list of connection objects
    inbound - Described the direction of the conections. True if inbound, false otherwise
--*/

void
FixNcReasons (
    IN LCNTDSDSA &ntdsdsas,
    IN LCCONN &conns,
    IN wstring &root_dn
    );
/*++
Routine Description:
    Generate a list of NC reasons for connections objects which do not have them
Arguments:
    ntdsdsas - A list of ntdsdsa objects. ntdsdsa objects for both sides of every connection object in the list must be included
    conns - A list of connection objects. Reasons will be generated for connections which are missing them
    root_dn - The root dn
--*/

wstring 
GetRootDn (
    IN LdapInfo &i);
/*++
Routine Description:
    Determine the root DN from the DS. the Config container is relative to the root dn
Arguments:
    i - An LdapInfo object representing the server whose root DN should be determined
--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\ism.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ismp

Abstract:

    This module define a set of classes to facilitate ISM queries, and availability
    schedule manipulation

Author:

    Ajit Krishnan (t-ajitk) 13-Jul-2001

Revision History:

    See header file
--*/

#include <minmax.h>
#include "ismp.h"

#define SCHED_NUMBER_INTERVALS_DAY   (4 * 24)
#define SCHED_NUMBER_INTERVALS_WEEK  (7 * SCHED_NUMBER_INTERVALS_DAY)


const bitset<MAX_INTERVALS> &
Schedule::getBitset(void) const
/*++

Routine Description:

   get the bitset representation for the current schedule

--*/
{
    return m_bs;
}


void
Schedule::setSchedule (
    IN bitset<MAX_INTERVALS> bs,
    IN int replInterval
    )
/*++

Routine Description:

    Standard constructor for a Schedule object.
    
Arguments:

    bs: a bitset representing the schedule

--*/
{
    m_repl_interval = replInterval;
    m_bs = bs;
}


void
Schedule::setSchedule (
    IN PSCHEDULE    header,
    IN int          replInterval
    )
/*++

Routine Description:

    Set the schedule
    
Arguments:

    header - A pschedule structure
    replInterval - The replication interval

--*/
{
    PBYTE data = ((unsigned char*) header) + header->Schedules[0].Offset;
    int bs_index=0;

    Assert( header->NumberOfSchedules == 1 );
    Assert( header->Schedules[0].Type == SCHEDULE_INTERVAL );

    m_repl_interval = replInterval;
        
    for (int i=0; i<7; i++) {
        for (int j=0; j<24; j++) {
            // for each hour, lowest 4 bits represent the 4 repl periods
            int hour_data = *data & 0xf;

            // set the value for each of the 4 periods
            for (int k=0; k<4; k++) {
                m_bs[bs_index++] = (hour_data & 1) ? true: false;
                hour_data = hour_data >> 1;
            }
            data++;
        }
    }
}


void
Schedule::setSchedule (
    IN ISM_SCHEDULE* cs,
    IN int replInterval
    )
/*++

Routine Description:

    Standard constructor for a Schedule object.
    
Arguments:

    an ISM_SCHEDULE structure which is obtained from the ISM

--*/
{
    if (! cs) {
        for (int i=0; i<MAX_INTERVALS; i++) {
           m_bs[i] = true;
        }
        replInterval = 15;
        return;
    }
    PBYTE pSchedule = cs->pbSchedule;
    DWORD cbSchedule = cs->cbSchedule;

    PSCHEDULE header = (PSCHEDULE) pSchedule;    
    setSchedule (header, replInterval);
}


SchedSegments*
Schedule::GetSegments(
    int     maxSegLength
    ) const
/*++

Routine Description:

    Allocate a vector of segments descriptors. This vector should
    be deleted by the caller when done.

Arguments:

    maxSegLength - The maximum length of a segment. Should be > 0.

Notes:

    Partially stolen from w32topl\schedman.c: ConvertAvailSchedToReplSched()
    
    TODO: Instead of duplicating all this logic here we should link
    with W32TOPL.DLL and use its schedule functions.

--*/
{
    SchedSegments* segments;
    SegmentDescriptor segDesc;
    int segStart, segEnd;

    // Allocate the vector of segments
    segments = new SchedSegments;
    if( NULL==segments ) {
        throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }
    
    // Ensure that maxSegLength is positive, otherwise we will loop forever.
    if( maxSegLength<=0 ) maxSegLength=1;

    segStart = 0;
    for(;;) {

        // Search for the start of a segment
        while( segStart<SCHED_NUMBER_INTERVALS_WEEK && !m_bs[segStart] ) {
            segStart++;
        }
        if( segStart>=SCHED_NUMBER_INTERVALS_WEEK ) {
            // We hit the end of the schedule. Done.
            break;
        } else {
            // Schedule must be available at start of segment
            Assert( m_bs[segStart] );
        }

        // Compute the end of the segment
        segEnd = min(segStart+maxSegLength, SCHED_NUMBER_INTERVALS_WEEK)-1;
        Assert( segEnd>=segStart );
        
        segDesc.start = segStart;
        segDesc.end = segEnd;
        segments->push_back( segDesc );

        // The next segment doesn't start until maxSegLength intervals after the
        // start of the current segment.
        segStart += maxSegLength; 
        ASSERT( segStart>segEnd );
    }

    return segments;
}


wostream &
operator<< (
    IN wostream &os,
    IN const Schedule &s
    ) {
    /*++
    Routine Description:
        Prints out all the windows in the schedule
        
    Return Value:
        A reference to a modified wostream
    --*/

    bitset<4*SCHEDULE_DATA_ENTRIES> bs = s.getBitset();
    for (int i=0; i< 4*SCHEDULE_DATA_ENTRIES; i++) {
        os << bs[i];
    }
    os << endl;
    return os;
}


IsmQuery :: IsmQuery (
    IN OUT LCCONN &l,
    IN const wstring &base_dn
    ) {
    /*++
    Routine Description:
    
        Standard constructor for an IsmQuery object
    Arguments:
    
        l: A reference to a ldapcontainer of connections
        hub_dn: The dn of the container
    --*/
    
    m_base_dn = base_dn;
    m_conn = &l;
}

void
IsmQuery :: getSchedules (
    ) {
    /*++
    Routine Description:
    
        Contact the ISM and populate the availabitlity schedules for each connection
        passed in through the constructor
    --*/
    
    SCONN::iterator ii;

    wstring transport_ip = L"CN=IP,CN=Inter-Site Transports,CN=Sites,CN=Configuration," + m_base_dn;
    wstring transport_smtp = L"CN=SMTP,CN=Inter-Site Transports,CN=Sites,CN=Configuration," + m_base_dn;

    LPWSTR dn_str_ip = const_cast<LPWSTR> (transport_ip.c_str());
    LPWSTR dn_str_smtp = const_cast<LPWSTR>(transport_smtp.c_str());

    for (ii = m_conn->objects.begin(); ii != m_conn->objects.end(); ii++) {
        ISM_SCHEDULE * pSchedule = NULL;
        LPWSTR dn_transport = dn_str_ip;
        
        if ((*ii)->getTransportType() == T_SMTP) {
            dn_transport = dn_str_smtp;
        }

        // find the site dn's of the source/dest connections (3 levels above connection dn)
        wstring wdn  = (*ii)->getFromServer();
        
        DnManip dn1 (wdn);
        DnManip dn2  ((*ii)->getName());

        wstring w_dn1 = dn1.getParentDn(3);
        wstring w_dn2 = dn2.getParentDn(4);

        
        PWCHAR dn_site1 = const_cast<PWCHAR>(w_dn1.c_str());
        PWCHAR dn_site2 = const_cast<PWCHAR>(w_dn2.c_str());

        int err = I_ISMGetConnectionSchedule (dn_transport, dn_site1, dn_site2, &pSchedule);

        if (err != NO_ERROR) {
            throw Error (GetMsgString(LBTOOL_ISM_GET_CONNECTION_SCHEDULE_ERROR));
        }

        (*ii)->setAvailabilitySchedule (pSchedule);
        I_ISMFree (pSchedule);
    }
}

void
IsmQuery :: getReplIntervals (
    ) {
    /*++
    Routine Description:
        Contact the ISM and populate the replIntervals for each connection
        passed in through the constructor
    --*/
    
    SCONN::iterator ii;

    // Create the transport dn's
    wstring transport_ip = L"CN=IP,CN=Inter-Site Transports,CN=Sites,CN=Configuration," + m_base_dn;
    wstring transport_smtp = L"CN=SMTP,CN=Inter-Site Transports,CN=Sites,CN=Configuration," + m_base_dn;

    LPWSTR dn_str_ip = const_cast<LPWSTR> (transport_ip.c_str());
    LPWSTR dn_str_smtp = const_cast<LPWSTR>(transport_smtp.c_str());

    ISM_CONNECTIVITY *ismc_ip = NULL;
    ISM_CONNECTIVITY *ismc_smtp = NULL;

    LbToolOptions lbOpts = GetGlobalOptions();
    // Get the per transport replication schedules
    int ret_ip = I_ISMGetConnectivity (dn_str_ip, &ismc_ip);
    int ret_smtp = I_ISMGetConnectivity (dn_str_smtp, &ismc_smtp);

    if (ret_ip == RPC_S_SERVER_UNAVAILABLE) {
        throw (Error (GetMsgString(LBTOOL_ISM_SERVER_UNAVAILABLE)));
        return;
    } 

    if (ret_ip != NO_ERROR || ret_smtp != NO_ERROR) {
        throw (Error (GetMsgString(LBTOOL_ISM_GET_CONNECTIVITY_ERROR) + GetMsgString(ret_ip, true)));
        return;
    }    

    // create a sorted index for the matrix dn's
    map<wstring,int> dn_index_ip, dn_index_smtp;

    for (int i = 0; i< ismc_ip->cNumSites; i++) {
        dn_index_ip[wstring(ismc_ip->ppSiteDNs[i])] = i;
    }

    if (lbOpts.showInput) {
        for (int i = 0; i< ismc_ip->cNumSites; i++) {
            dn_index_smtp[wstring(ismc_ip->ppSiteDNs[i])] = i;
            *lbOpts.log << i << L"  " << wstring(ismc_ip->ppSiteDNs[i]) << endl;
        }    
        for (int i=0; i<ismc_ip->cNumSites; i++) {
            for (int j=0; j<ismc_ip->cNumSites; j++) {
                *lbOpts.log << ismc_ip->pLinkValues[i*ismc_ip->cNumSites+j].ulReplicationInterval << L"  ";
            }
            *lbOpts.log << endl;
        }
        *lbOpts.log << endl;
        for (int i = 0; i< ismc_smtp->cNumSites; i++) {
            dn_index_smtp[wstring(ismc_smtp->ppSiteDNs[i])] = i;
            *lbOpts.log << i << L"  " << wstring(ismc_smtp->ppSiteDNs[i]) << endl;
        }    
        for (int i=0; i<ismc_smtp->cNumSites; i++) {
            for (int j=0; j<ismc_smtp->cNumSites; j++) {
                *lbOpts.log << ismc_smtp->pLinkValues[i*ismc_smtp->cNumSites+j].ulReplicationInterval << L"  ";
            }
            *lbOpts.log << endl;
        }
    }

    
    // for each connection, determine the repl interval
    for (ii = m_conn->objects.begin(); ii != m_conn->objects.end(); ii++) {
        ISM_CONNECTIVITY *ic = ismc_ip;

        if ((*ii)->getTransportType() == T_SMTP) {
            ic = ismc_smtp;
        }

        // find the site dn's of the source/dest connections (3 levels above connection dn)
        wstring wdn ((*ii)->getFromServer());
        
        DnManip dn1 (wdn);
        DnManip dn2  ((*ii)->getName());
        DnManip dn_site1 (dn1.getParentDn(3));
        DnManip dn_site2 (dn2.getParentDn(4));

        // Find the repl Interval
        int index1=-1, index2=-1, numSites;
        if (ic == ismc_ip) {
            index1 = dn_index_ip[dn_site1.getDn()];
            index2 = dn_index_ip[dn_site2.getDn()];
            numSites = ismc_ip->cNumSites;
        } else {
            index1 = dn_index_smtp[dn_site1.getDn()];
            index2 = dn_index_smtp[dn_site2.getDn()];
            numSites = ismc_smtp->cNumSites;
        }
        Assert (index1 != -1 && index2 != -1 && L"DN Lookup Table failure");

        PISM_LINK pLink = &(ic->pLinkValues[index1 * numSites + index2]);
        (*ii)->setReplInterval (pLink->ulReplicationInterval);
        
    }
    I_ISMFree (ismc_ip);
    I_ISMFree (ismc_smtp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\driver.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    driver.cpp

Abstract:

    This module puts together various components to allow bridgehead balancing
    and schedule staggering.
    
Author:

    Ajit Krishnan (t-ajitk) 13-Jul-2001

Revision History:

    Nick Harvey   (nickhar) 20-Sep-2001
        Clean-up & Maintenance

--*/

#include "ldapp.h"
#include "ismp.h"
#include "balancep.h"
#include "driver.h"

#define DS_CON_LIB_CRT_VERSION
#include "dsconlib.h"

#define VERSION     L"v1.1"

bool
GetPassword(
    WCHAR *     pwszBuf,
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    )
/*++

Routine Description:

    Retrieve password from command line (without echo).
    Code stolen from LUI_GetPasswdStr (net\netcmd\common\lui.c).

Arguments:

    pwszBuf - buffer to fill with password
    cchBufMax - buffer size (incl. space for terminating null)
    pcchBufUsed - on return holds number of characters used in password

Return Values:

    true - success
    other - failure

--*/
{
    HANDLE  hStdin;
    WCHAR   ch;
    WCHAR * bufPtr = pwszBuf;
    DWORD   c;
    int     err;
    int     mode, newMode;

    hStdin = GetStdHandle(STD_INPUT_HANDLE);

    cchBufMax -= 1;    /* make space for null terminator */
    *pcchBufUsed = 0;  /* GP fault probe (a la API's) */

    if (!GetConsoleMode(hStdin, (LPDWORD)&mode)) {
        err = GetLastError();
        throw Error(GetMsgString(LBTOOL_PASSWORD_ERROR));
    }

    newMode = mode & (~ (ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT) );
    SetConsoleMode(hStdin, newMode);

    while (TRUE) {
        err = ReadConsoleW(hStdin, &ch, 1, &c, 0);
        if (!err || c != 1) {
            /* read failure */
            break;
        }

        if (ch == CR) {       
            /* end of line */
            break;
        }

        if (ch == BACKSPACE) {

            /* back up one unless at beginning of buffer */
            if (bufPtr != pwszBuf) {
                bufPtr--;
                (*pcchBufUsed)--;
            }

        } else {

            *bufPtr = ch;
            if (*pcchBufUsed < cchBufMax) {
                bufPtr++;                    /* don't overflow buf */
            }
            (*pcchBufUsed)++;                /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = L'\0';         /* null terminate the string */

    if (*pcchBufUsed > cchBufMax) {
        throw Error(GetMsgString( LBTOOL_PASSWORD_TOO_LONG ));
        return false;
    } else {
        return true;
    }
}


wostream &
operator << (
    wostream &os,
    const LbToolOptions &opt
    )
/*++

Routine Description:

    Dump the lbToolOptions in human-readable form to an output stream.
    
Arguments:

    os - a standard wostream
    
    opt - the lbToolOptions which should be dumped to os

--*/
{ 
    os << boolalpha
        << L"Site: " << opt.site << endl
        << L"Whistler Mode: " << opt.whistlerMode << endl
        << L"Maximum Bridgehead Balancing: " << opt.maxBridge;
    if( opt.maxBridge ) {
        os << L":" << opt.maxBridgeNum;
    }

    os  << endl
        << L"Maximum Schedule Staggering: " << opt.maxSched;
    if( opt.maxSched ) {
        os << L":" << opt.maxSchedNum;
    }
        
	os << endl;
	if (opt.disownSchedules) {
		os << L"Disown Schedules: ";
	}

	os << endl
		<< L"Maximum Changes Per Server: " << opt.maxPerServerChanges;

    os  << endl
        << L"Log File: " << opt.logFile << endl
        << L"Commit: " << !opt.previewBool<< endl
        << L"Show Input: " << opt.showInput << endl
        << L"Verbose Output: " << opt.verbose << endl
        << L"Print Statistics: " << opt.performanceStats << endl
        << L"Domain: " << opt.domain << endl
        << L"User: " << opt.user << endl
        << L"Password: ";

    if (opt.password.length()) {
        os << L"*******" << endl;
    } else {
        os << endl;
    }

    return os;
}

bool 
FindOption(
    IN map<wstring,wstring> &options,
    IN const wstring &opt_a,
    IN const wstring &opt_b,
    OUT wstring &value
    )
/*++

Routine Description:

    Look for an argument in a map<wstring,wstring> structure, using 2 specified keys.
    Since all arguments keys were added in lower case form, we do away with another
    conversion here assuming that opt_a, and opt_b will be lower case.
    
Arguments:

    options - A map structure containing key:value pairs. These are the options
              input by the user. All keys should be converted to lowercase by
              the caller.

    opt_a - The key for the option whose value we are trying to find.
            Should be lowercase.

    opt_b - An alternate key for the option whose value we are trying to find.
            Should be all lowercase.

    value - The value if the key exists, and the empty string otherwise.
    
Return value:

    true if the key was found, and false otherwise

--*/
{
    map<wstring,wstring>::iterator match_a, match_b, end;

    // Search the map for opt_a and opt_b
    match_a = options.find(opt_a);
    match_b = options.find(opt_b);
    end = options.end();
    
    if ((match_a == end) && (match_b == end)) {
        // Neither opt_a nor opt_b matched any options in the map
        return false;
    }

    // match_b found the match. copy to match_a
    if (match_b != end) {
        match_a = match_b;
    }
    Assert( match_a != end );

    // key has no value
    if (match_a->second.length() == 0) {
        value = L"";
        return true;
    }

    // key has matching value
    value = match_a->second;
    return true;
}


void
ConvertToLowercase(
    IN OUT wstring &wstr
    )
/*++

Routine Description:

    Convert a wstring to lowercase
    
Arguments:

    wstr - The input and output string
    
--*/
{
    PWCHAR pszLower;

    pszLower = _wcsdup(wstr.c_str());
    if (!pszLower) {
        throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }
    _wcslwr(pszLower);
    wstr = pszLower;    // Copy pszLower back to wstr
    free(pszLower);
}


bool
ParseOneOption(
    IN  WCHAR *arg,
    OUT wstring &optname,
    OUT wstring &value
    )
/*++

Routine Description:

    Parse one argument specified in arg.
    The options should be either in the format
        /optname
    or
        /optname:value
    
Arguments:

    arg - The one argument to process
    
Return Value:

    true - parsing was successful. optname and value contain the parsed strings.
    false - parsing failure. optname and value should be ignored.

--*/
{
    PWCHAR option, optionLower;
    wstring wopt;
    int len, ret, col_pos;
    
    len = wcslen(arg);
    if (len <= 1) {
        // empty argument (seems unlikely)
        return false;
    }

    // Allocate enough memory for all worst cases
    option = (PWCHAR) malloc( (len+1) * sizeof(WCHAR) );
    if (!option) {
        throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }

    // Strip off the leading slash and store in option
    ret = swscanf(arg, L"/%s", option);
    if (! ret) {
        throw Error(GetMsgString(LBTOOL_CLI_INVALID_VALUE_PLACEMENT));
        return false;
    }
    len = wcslen(option);

    // Copy the option to wopt and free it
    wopt = option;      
    free(option);       

    // wopt now contains key or key:val

    // Find the colon and extract the option name
    col_pos = wopt.find(L":");
    if( col_pos>0 ) {
        optname = wopt.substr (0, col_pos);
	} else if( col_pos<0 ) {
		optname = wopt;
	} else if( col_pos==0 ) {
		return false;
	}

	// Extract the value
	if( col_pos>0 && col_pos<len-1 ) {
		value = wopt.substr (col_pos+1, len);
	} else {
		value = L"";
	}


    // The option name must be lower-case for later comparisons
	ConvertToLowercase(optname);

    return true;
}


void
DumpOptions(
    IN map<wstring,wstring> &options
    )
/*++

Routine Description:

    Dump the user-specified options to wcout for debugging purposes

--*/
{
    map<wstring,wstring>::iterator ii;

    wcout << L"Command-line Options:" << endl;
    for( ii=options.begin(); ii!=options.end(); ++ii ) {
        wcout << ii->first << L": " << ii->second << endl;
    }
    wcout << endl;
}


wostream*
OpenOFStream(
    IN wstring &fileName
    )
/*++

Routine Description:

    Open an output file stream with the given file name
    
Arguments:

    fileName - The name of the file to open
    
Return Value:

    A pointer to the opened stream. May return NULL.

--*/
{
    wostream*   result;
    PWCHAR      pwszFileName;
    PCHAR       pmszFileName;
    int         bufsize, ret;

    // Grab a pointer to the wide-char filename
    pwszFileName = const_cast<PWCHAR>(fileName.c_str());

    // Allocate a buffer and convert it to a multi-byte string
    bufsize = 2 * sizeof(CHAR) * (wcslen(pwszFileName) + 1);
    pmszFileName = (PCHAR) malloc( bufsize );
    if (!pmszFileName) {
        throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }
    ret = WideCharToMultiByte(CP_ACP, NULL, pwszFileName, -1, pmszFileName, bufsize, NULL, NULL);

    // Open a new output file stream using this name
    result = new wofstream( pmszFileName );

    // Free allocated memory and return
    free( pmszFileName );
    return result;
}


void
BuildGlobalOptions(
    IN map<wstring,wstring> &options,
    IN LbToolOptions &lbopts
    )
/*++

Routine Description:

    Examine the user-specified options and set up the tool's global options.
    
Arguments:

    options - The table of user-specified options and values
    
    lbopts - The structure of global tool options to set up
    
Return Value:

    None

--*/
{
    wstring     wval;
    const int   cbBuff=80;
    WCHAR       pBuff[cbBuff];
    DWORD       used;


    // ADLB should always compute NC Reasons because the KCC-generated
    // values are unreliable. If the KCC is improved, this functionality
    // can be revisited.
    lbopts.fComputeNCReasons = true;
    
    
    //////////////////////////////////////////
    // Macros to help us read in the options
    //////////////////////////////////////////
	// s1: Version 1 of the option (long option name)
	// s2: Version 2 of the option (short option name)
	// err: The Error String to Print if the value given
	//    : is of the wrong type, or has the wrong bounds
	// val: The place in the lbopts structure where the 
	//    : value of the keys (s1 or s2) should be stored 

    #define GET_STRING_VAL_OPTION(s1,s2,err,val) \
        if (FindOption(options, s1, s2, wval)) { \
            if (wval.length() == 0) \
                throw Error(GetMsgString(err)); \
            lbopts.val = wval; \
        }
    #define GET_STRING_OPTION(s1,s2,val) \
        if (FindOption(options, s1, s2, wval)) { \
            lbopts.val = wval; \
        }
    #define GET_BOOL_OPTION(s1,s2,err,val) \
        if( FindOption(options, s1, s2, wval)) { \
            if (wval.length() > 0) \
                throw Error(GetMsgString(err)); \
            lbopts.val = true; \
        }
    #define GET_SINGLE_DWORD_OPTION(s1,s2,err,val) \
        if (FindOption(options, s1, s2, wval)) { \
            if (wval.length() == 0) \
                throw Error(GetMsgString(err)); \
            int val=0; \
            int ret = swscanf (const_cast<PWCHAR>(wval.c_str()), L"%d", &val); \
            if (ret == 0 || val < 0) \
                throw Error(GetMsgString(err)); \
            lbopts.val = val; \
        }		
		
	// fVal:  A boolean Flag in the lbopts structure which is toggled if the
	//     :  value is specified
	// dwVal: Analogous to val in the macros above. This is where the value is
	//      : stored in the lbopts structure
	//      : This value is required
    #define GET_DWORD_OPTION(s1,s2,err,fVal,dwVal) \
        if (FindOption(options, s1, s2, wval)) { \
            if (wval.length() == 0) \
                throw Error(GetMsgString(err)); \
            int val=0; \
            int ret = swscanf (const_cast<PWCHAR>(wval.c_str()), L"%d", &val); \
            if (ret == 0 || val < 0) \
                throw Error(GetMsgString(err)); \
            lbopts.fVal = true; \
            lbopts.dwVal = val; \
        }
    
    ////////////////////////
    // Read in the options
    ////////////////////////

    // String + Value options: Site, Server
    GET_STRING_VAL_OPTION(L"site",   L"s", LBTOOL_CLI_OPTION_SITE_INVALID,   site)
    GET_STRING_VAL_OPTION(L"server", L"",  LBTOOL_CLI_OPTION_SERVER_INVALID, server)
    GET_STRING_VAL_OPTION(L"user",   L"u", LBTOOL_CLI_OPTION_USER_INVALID,   user)
    GET_STRING_VAL_OPTION(L"domain", L"d", LBTOOL_CLI_OPTION_DOMAIN_INVALID, domain)

    // String (+optional value) options: Log
    GET_STRING_OPTION(L"log",      L"l", logFile)
    GET_STRING_OPTION(L"preview",  L"",  previewFile)

    // Boolean options: verbose, perf, showinput
    GET_BOOL_OPTION(L"verbose",   L"v", LBTOOL_CLI_OPTION_VERBOSE_INVALID,   verbose)
    GET_BOOL_OPTION(L"perf",      L"",  LBTOOL_CLI_OPTION_PERF_INVALID,      performanceStats)
    GET_BOOL_OPTION(L"showinput", L"",  LBTOOL_CLI_OPTION_SHOWINPUT_INVALID, showInput)
    GET_BOOL_OPTION(L"commit",    L"c", LBTOOL_CLI_OPTION_COMMIT_INVALID,    previewBool)
	GET_BOOL_OPTION(L"disown",    L"",  LBTOOL_CLI_OPTION_DISOWN_INVALID,    disownSchedules)
	GET_BOOL_OPTION(L"stagger",   L"",  LBTOOL_CLI_OPTION_STAGGER_INVALID,   stagger)

    // Originally committing used to be the default. Now preview mode is the
    // default and committing must be done with the /commit option.
    lbopts.previewBool = !lbopts.previewBool;

    // Dword options: maxsched, maxbridge
    GET_DWORD_OPTION(L"maxsched",  L"ms", LBTOOL_CLI_OPTION_MAXSCHED_INVALID, maxSched, maxSchedNum)
    GET_DWORD_OPTION(L"maxbridge", L"mb", LBTOOL_CLI_OPTION_MAXBRIDGE_INVALID,
        maxBridge, maxBridgeNum)
	
	lbopts.maxPerServerChanges = DEFAULT_MAX_CHANGES_PER_SERVER; 
	GET_SINGLE_DWORD_OPTION(L"maxPerServer", L"mps", LBTOOL_CLI_OPTION_MAXPERSERVER_INVALID, maxPerServerChanges);  

	// If both /stagger and /maxSched are not specified, don't stagger schedules
	if ((!lbopts.stagger) && (!lbopts.maxSched)) {
		lbopts.maxSched = true;
		lbopts.maxSchedNum = 0;
	}

	if (lbopts.maxPerServerChanges == 0 || lbopts.maxPerServerChanges > DEFAULT_MAX_CHANGES_PER_SERVER) {
		wcout << GetMsgString (LBTOOL_MAX_PER_SERVER_CHANGES_OVERRIDEN);
	}

	if (lbopts.disownSchedules && lbopts.maxSchedNum > 0) {
		throw Error (GetMsgString(LBTOOL_CLI_OPTION_DISOWN_AND_STAGGER_INVALID));
	}

    ////////////////////
    // Unusual Options
    ////////////////////

    // Ldif filename
    FindOption(options, L"ldif", L"", lbopts.previewFile);

    // Password: Read from stdin if not specified
    if( FindOption(options, L"password", L"pw", lbopts.password) ) {
        if( lbopts.password.length()==0 || lbopts.password==L"*" ) {
            wcout << GetMsgString(LBTOOL_PASSWORD_PROMPT);
            GetPassword(pBuff, cbBuff, &used);
            lbopts.password = pBuff;
        }
    }


    ////////////////////
    // Post-processing
    ////////////////////

    // Check mandatory options: site, server
    if( lbopts.site.length()==0 || lbopts.server.length()==0 ) {
        throw Error(GetMsgString(LBTOOL_CLI_OPTION_REQUIRED_UNSPECIFIED));
    }

    // Open the log file with the given name
    if( lbopts.logFile.length()>0 ) {
        lbopts.log = OpenOFStream(lbopts.logFile);
		if( NULL==lbopts.log ) {
			throw Error(GetMsgString(LBTOOL_LOGFILE_ERROR));
		}
    } else {
        lbopts.log = &wcout;
    }

    // Open the preview file with the given name
    if (lbopts.previewFile.length() > 0) {
        lbopts.preview = OpenOFStream(lbopts.previewFile);
		if( NULL==lbopts.preview ) {
			throw Error(GetMsgString(LBTOOL_PREVIEWFILE_ERROR));
		}
    } else {
        lbopts.preview = &wcout;
    }
}


bool 
ParseOptions(
    IN int argc,
    IN WCHAR **argv,
    IN LbToolOptions &lbopts
    )
/*++

Routine Description:

    Parse the arguments for lbtool.
    Options should be either in the format
        /optname
    or
        /optname:value
    Note that neither optname nor value may contain spaces or colons.
    
Arguments:

    argc - The number of arguments
    
    argv - The list of arguments
    
    lbopts - The options structure this function will populate
    
Return Value:

    true - parsing was successful, lbopts has been populated
    false - parsing failure, mandatory options missing, etc.

--*/
{
    map<wstring,wstring> options;
    wstring wopt, wval;
    int iArg;

    // Clear the options to begin with
    memset( &lbopts, 0, sizeof(LbToolOptions) );
    
    for( iArg=1; iArg<argc; iArg++ ) {
        map<wstring,wstring>::iterator ii;

        // Parse this one argument
        if( !ParseOneOption(argv[iArg], wopt, wval) ) {
            return false;
        }
        
        // Check if this option has already been defined
        ii = options.find(wopt);
        if (ii != options.end()) {
            throw Error(GetMsgString(LBTOOL_CLI_OPTION_DEFINED_TWICE));
        }

        // Add the option to our map of options
        options[wopt] = wval;
    }

    #ifdef DBG
        DumpOptions(options);
    #endif

    BuildGlobalOptions(options, lbopts);

    return true;    
}


void UpdateCache (
    IN OUT LCSERVER &servers,
    IN OUT LCNTDSDSA &ntdsdsas
    ) {
/*++
Routine Description:

    Update the servers/ntdsdsas cache of each other. Each server and ntdsdsa
    must have one matching counterpart.
    
Arguments:

    servers - the list of servers
    ntdsdsas - the list of ntdsdsas
--*/

    typedef pair<wstring,Server*> SPAIR;
    typedef pair<wstring,NtdsDsa*> NDPAIR;
    vector<SPAIR> server_map;
    vector<NDPAIR> ntds_dsa_map;

    SSERVER::iterator si;
    SNTDSDSA::iterator ni;
    for (si = servers.objects.begin(); si != servers.objects.end(); si++) {
        server_map.push_back(SPAIR((*si)->getName(), *si));
    }
    for (ni = ntdsdsas.objects.begin(); ni != ntdsdsas.objects.end(); ni++) {
        DnManip dn ( (*ni)->getName());
        ntds_dsa_map.push_back (NDPAIR(dn.getParentDn(1), (*ni)));
    }

    sort (server_map.begin(), server_map.end());
    sort (ntds_dsa_map.begin(), ntds_dsa_map.end());

    vector<SPAIR>::iterator smi = server_map.begin();
    vector<NDPAIR>::iterator nmi = ntds_dsa_map.begin();

    vector<Server*> invalid_servers;

    while (smi != server_map.end() && nmi!= ntds_dsa_map.end()) {
        int ret = _wcsicoll (smi->first.c_str(), nmi->first.c_str());
        if (ret != 0) {
        // no matching ntds_dsa object
            invalid_servers.push_back (smi->second);
            smi++;
            continue;
        } else {
                smi->second->setNtdsDsa (nmi->second);
                nmi->second->setServer (smi->second);
                smi++;
                nmi++;
        }
    }

    while (smi != server_map.end()) {
        invalid_servers.push_back (smi->second);
        smi++;
    }

    // remove invalid servers from the list. have to use for loop since erase invalidates handles
    vector<Server*>::iterator invi;
    for (invi = invalid_servers.begin(); invi != invalid_servers.end(); invi++) {
         servers.objects.erase ((*invi));
    }
}

void
RemoveIntraSiteConnections (
    IN const wstring &site,
    IN OUT LCCONN & conn,
    IN bool inbound
    ) {
    /*++
    Routine Description:
    
        Remove intra site connections froma list of connections
        
    Arguments:
    
        site - The FQDN of the side
        conn - A list of connection objects
        inbound - Described the direction of the conections. True if inbound, false otherwise
    --*/
    SCONN::iterator ii;
    vector<Connection*> intra_site;
    for (ii = conn.objects.begin(); ii != conn.objects.end(); ii++) {
        if (inbound) {
            int attr_num = (*ii)->findAttribute (L"fromServer");
            Attribute a = (*ii)->getAttribute (attr_num);
            int num_values = a.numValues();
            AttrValue av = a.getValue(0);

              DnManip dn((PWCHAR)av.value);
            wstring fromSite = dn.getParentDn(3);
            if (! _wcsicoll(fromSite.c_str(), site.c_str())) {
                intra_site.push_back(*ii);
            }
        } else {
             DnManip dn((*ii)->getName());
             wstring toSite = dn.getParentDn(4);
             if (! _wcsicoll(toSite.c_str(), site.c_str())) {
                intra_site.push_back(*ii);
            }
        } // end if-else
    }
    vector<Connection*>::iterator ci;
    for (ci = intra_site.begin(); ci != intra_site.end(); ci++) {
        conn.objects.erase ((*ci));
    }
}

void
FixNcReasons (
    IN LCNTDSDSA &ntdsdsas,
    IN LCCONN &conns,
    IN wstring &root_dn
    ) {
/*++
Routine Description:

    Generate a list of NC reasons for connections objects which do not have them
    
Arguments:

    ntdsdsas - A list of ntdsdsa objects. ntdsdsa objects for both sides of every connection object in the list must be included
    conns - A list of connection objects. Reasons will be generated for connections which are missing them
    root_dn - The root dn
--*/

    SCONN::iterator ci;
    SNTDSDSA::iterator ni;

    for (ci = conns.objects.begin(); ci != conns.objects.end(); ci++) {
        bool nc_reason_exists = ((*ci)->findAttribute(L"mS-DS-ReplicatesNCReason") == -1) ? false : true;
    
        if (! nc_reason_exists) {
            DnManip dn ((*ci)->getName());
            wstring dest = dn.getParentDn(1);
            wstring source = (*ci)->getFromServer();

            // Find the ntdsdsas objects in the list
            NtdsDsa *ntds_dest=NULL, *ntds_source=NULL;
            for (ni = ntdsdsas.objects.begin(); ni != ntdsdsas.objects.end(); ni++) {
                wstring curr_dn = (*ni)->getName();
                if (! ntds_dest) {
                    int ret = _wcsicoll (dest.c_str(), curr_dn.c_str());
                    if (ret == 0) {
                        ntds_dest = *ni;
                    }
                }

                if (! ntds_source) {
                    int ret = _wcsicoll (source.c_str(), curr_dn.c_str());
                    if (ret == 0) {
                        ntds_source = *ni;
                    }
                }

                // and create the nc reasons
                if (ntds_dest && ntds_source) {
                    (*ci)->createNcReasons (*ntds_source, *ntds_dest, root_dn);
                    break;
                }

            }
            
        }
    }
    
}

void GatherInput (
    IN LdapInfo &info,
    IN const wstring &site,
    OUT LCSERVER &servers,
    OUT LCSERVER &all_servers,
    OUT LCNTDSDSA &ntdsdsas,
    OUT LCNTDSDSA &all_ntdsdsas,
    OUT LCCONN &inbound,
    OUT LCCONN &outbound
    )
/*++

Routine Description:

    Query the ldap server & ISM to get all information required for this tools operation
    
Arguments:

    Info - The LDAP credential information
    site - the dn of the site we are balancing

    servers - a container where all servers in the current site should be placed
    all_servers - a container where all servers in the forest should be placed
    ntdsdsas - a container where all ntdsdsas in the current site should be placed
    inbound - a container where all connections inbound to the current site should be placed
    outbound - a countainer where all connections outbound from the current site should be placed
    bridgeheads - a container where all preferred bridgeheads from the current site should be placed

--*/
{
    DnManip dn_site(site);
    DnManip dn_base = dn_site.getParentDn(3);
    wstring base = dn_base.getDn();
    LbToolOptions &lbOpts = GetGlobalOptions();

    LCNTDSSITE all_ntdsSiteSettings(L""); 

    // dn, filter, scope, attributes

    #define BEHAVIOR_VERSION    L"msDS-Behavior-Version"

    // determine forest version
    {
        LCLOBJECT fv(L"");
        vector<wstring> attributes;
        attributes.push_back(BEHAVIOR_VERSION);
        LdapQuery q (L"CN=Partitions,CN=Configuration," + base, L"objectClass=*", BASE, attributes);
        fv.populate(info, q);

        SLO::iterator ii;
        for (ii = fv.objects.begin(); ii != fv.objects.end(); ii++) {
            if ((*ii)->findAttribute(BEHAVIOR_VERSION) != -1) {
                Attribute a = (*ii)->getAttribute(0);
                AttrValue av = a.getValue(0);
                wstring version = (PWCHAR)av.value;
                // BUGBUG: Lexicographic comparison rather than numeric
                if (version >= L"1") {
                    lbOpts.whistlerMode = true;
                }
            }
        }
    }

    // if forest version is incorrect, exit the program
    if (lbOpts.maxSched == false || (lbOpts.maxSched == true && lbOpts.maxSchedNum != 0)) {
        if (lbOpts.previewBool == false && lbOpts.whistlerMode == false) {
            throw Error(GetMsgString(LBTOOL_SCHEDULE_STAGGERING_UNAVAILABLE));
        }
    }


    // all servers in the forest
    {
        vector<wstring> attributes;
        attributes.push_back (L"mailAddress");
        attributes.push_back (L"bridgeheadTransportList");
        LdapQuery q (site, L"objectCategory=CN=Server,CN=Schema,CN=Configuration," + base, SUBTREE, attributes);
        servers.populate(info, q);

        LdapQuery all_q (L"CN=Sites,CN=Configuration," + base, L"objectCategory=CN=Server,CN=Schema,CN=Configuration," + base, SUBTREE, attributes);
        all_servers.populate(info, all_q);
    }

	    // all ntdsSiteSettings in the forest
    {
        vector<wstring> attributes;
        attributes.push_back (L"options");

        LdapQuery all_q (L"CN=Sites,CN=Configuration," + base, L"objectCategory=CN=NTDS-Site-Settings,CN=Schema,CN=Configuration," + base, SUBTREE, attributes);
        all_ntdsSiteSettings.populate(info, all_q);
    }

    // all ntds dsa's in the forest
    {
        vector<wstring> attributes;
        attributes.push_back (L"hasPartialReplicaNCs");
        attributes.push_back (L"hasMasterNCs");
        attributes.push_back (L"msDS-HasMasterNCs");
        attributes.push_back (L"msDS-HasInstantiatedNCs");
        LdapQuery q (site, L"objectCategory=CN=NTDS-DSA,CN=Schema,CN=Configuration," + base, SUBTREE, attributes);
        ntdsdsas.populate(info, q);

        LdapQuery all_q (L"CN=Sites,CN=Configuration," + base, L"objectCategory=CN=NTDS-DSA,CN=Schema,CN=Configuration," + base, SUBTREE, attributes);
        all_ntdsdsas.populate(info, all_q);        
    }    

    // all inbound connections
    {
        // grab all attributes to recreate object if "moved"
        vector<wstring> attributes;
        attributes.push_back (L"enabledConnection");
        attributes.push_back (L"objectClass");
        attributes.push_back (L"fromServer");
        attributes.push_back (L"TransportType");
        attributes.push_back (L"options");
        attributes.push_back (L"schedule");
        attributes.push_back (L"systemFlags");
        if (! lbOpts.fComputeNCReasons) {
            attributes.push_back (L"mS-DS-ReplicatesNCReason");
        }
        LdapQuery q (site, L"objectCategory=CN=NTDS-Connection,CN=Schema,CN=Configuration," + base, SUBTREE, attributes);
        inbound.populate(info, q);
        RemoveIntraSiteConnections (site, inbound, true);      
    }

    // all outbound connections
    {
        // grab all attributes to recreate object if "moved"
        vector<wstring> attributes;
        attributes.push_back (L"fromServer");
        attributes.push_back (L"TransportType");
        attributes.push_back (L"options");
        attributes.push_back (L"schedule");
        attributes.push_back (L"systemFlags");
        if (! lbOpts.fComputeNCReasons) {
            attributes.push_back (L"mS-DS-ReplicatesNCReason");
        }
        // list of servers for outbound connections
        SSERVER::iterator ii;
        wstring server_list;
        for (ii = servers.objects.begin(); ii != servers.objects.end(); ii++) {
            server_list += L"(fromServer=CN=NTDS Settings," + (*ii)->getName() + L")";
        }
        LdapQuery q2 (L"CN=Sites,CN=Configuration," + base, L"(&(objectCategory=CN=NTDS-Connection,CN=Schema,CN=Configuration," + base + L")(|" + server_list + L"))", SUBTREE, attributes);
        outbound.populate(info, q2);
        RemoveIntraSiteConnections (site, outbound, false);
    }

    lbOpts.numConnectionsBridge = inbound.objects.size() + outbound.objects.size();
    lbOpts.numConnectionsSched = outbound.objects.size();
    
    UpdateCache (servers, ntdsdsas);
    UpdateCache (all_servers, all_ntdsdsas);

    LCSERVER bridgeheads_ip(L""), bridgeheads_smtp(L"");

    // update bridgehead cache. If there are no servers in the bridgehead list for
    // either transport, set all servers as eligible bridgeheads for that transport
    SSERVER::iterator ii;
    for (ii = servers.objects.begin(); ii != servers.objects.end(); ii++) {
        if ((*ii)->isPreferredBridgehead(T_IP)) {
            bridgeheads_ip.objects.insert (*(ii));
        } else if ((*ii)->isPreferredBridgehead(T_SMTP)) {
            bridgeheads_smtp.objects.insert (*ii);
        }
    }

    if (bridgeheads_ip.objects.size() == 0) {
        for (ii = servers.objects.begin(); ii != servers.objects.end(); ii++) {
            (*ii)->setPreferredBridgehead (T_IP);
        }
    }
    if (bridgeheads_smtp.objects.size() == 0) {
        for (ii = servers.objects.begin(); ii != servers.objects.end(); ii++) {
            (*ii)->setPreferredBridgehead (T_SMTP);
        }
    }

    // Do not query ism if maxsched:0
    if (lbOpts.maxSched == false || lbOpts.maxSchedNum > 0) {
        IsmQuery iqOutbound (outbound, base);
        iqOutbound.getReplIntervals();
        iqOutbound.getSchedules();
		   
		// Update the ReplIntervals to reflect Redundancy on the destination
		// end of the connection (ntds site settings object)
		SCONN::iterator ci;
		SNTDSSITE::iterator ni;
		for (ci = outbound.objects.begin(); ci != outbound.objects.end(); ci++) {
			wstring conn_name = (*ci)->getName();
			DnManip dm(conn_name);
			wstring ntds = L"CN=NTDS Site Settings," + dm.getParentDn(4);   
			NtdsSiteSettings obj_to_find(ntds);
			ni = all_ntdsSiteSettings.objects.find(&obj_to_find);   

			ASSERT (ni != all_ntdsSiteSettings.objects.end() && L"Unable to find NTDSA object");
			
			int red = (*ni)->defaultServerRedundancy();
			(*ci)->setRedundancyCount (red);
		}
	}
 

    // If maxSched / maxBridge unspecified, modify all
    if (lbOpts.maxSched == false) {
        lbOpts.maxSchedNum = lbOpts.numConnectionsSched;
    }

    if (lbOpts.maxBridge == false) {
        lbOpts.maxBridgeNum = lbOpts.numConnectionsBridge;
    }    
}


LbToolOptions lbOpts;

LbToolOptions &
GetGlobalOptions (
    ) {
    return lbOpts;
}

wstring 
GetRootDn (
    IN LdapInfo &i)
/*++

Routine Description:

    Determine the root DN from the DS. the Config container is relative to the root dn

Arguments:

    i - An LdapInfo object representing the server whose root DN should be determined

--*/
{
    vector<wstring> attributes;
    attributes.push_back (L"rootDomainNamingContext"); 
    LdapQuery q(L"", L"objectClass=*", BASE, attributes);
    LCLOBJECT root_object(L"");
    root_object.populate(i, q);
    Assert (root_object.objects.size() == 1 && L"Object can only have one null object");
    LdapObject *lo = *(root_object.objects.begin());
    Attribute a = lo->getAttribute(0);
    int num_attr_values = a.numValues();
    Assert (num_attr_values == 1);
    AttrValue av = a.getValue(0);
    return wstring ((PWCHAR)av.value);
}

void
PrintAbout(
    void
    )
/*++

Routine Description:

    Print information about the ADLB tool.

--*/
{
    wcout
    << L"ADLB - Active Directory Load Balancing Tool " VERSION << endl
    << L"Written by Ajit Krishnan, Nicholas Harvey, and William Lees" << endl
    << L"LHMatch technology by Nicholas Harvey and Laszlo Lovasz" << endl
    << L"(c) Copyright 2001 Microsoft Corp." << endl << endl;
}

int __cdecl
wmain(
    int argc,
    WCHAR ** argv
    )
/*++

Routine Description:

    The main routine of the program

Arguments:

    argc - Count of command line parameters
    argv - The command line parameters

--*/
{
    bool fParseOptionsSuccess=FALSE;

    DsConLibInitCRT();

    PrintAbout();
    
    // Parse command line options; store in global options
    try {
        fParseOptionsSuccess = ParseOptions(argc, argv, lbOpts);
    } catch (Error E) {
        wcerr << E.msg << endl;
    }
    if( !fParseOptionsSuccess ) {
        wcerr << GetMsgString (LBTOOL_NOVICE_HELP) << endl;
        exit(EXIT_FAILURE);
    }

    try {
        double afterQuery, afterInbound, afterOutbound, afterWrite, afterStagger;
        // find the root DN
        LdapInfo ldapInfo(lbOpts.server, 389, lbOpts.domain, lbOpts.user, lbOpts.password);
        wstring root_dn = GetRootDn (ldapInfo);
        lbOpts.site = L"CN=" + lbOpts.site + L",CN=Sites,CN=Configuration," + root_dn;
    
        LCLOBJECT sites(lbOpts.site);
        LCSERVER servers(L"");
        LCSERVER all_servers(L"");
        LCNTDSDSA ntdsdsas(L"");
        LCCONN inbound(L"");
        LCCONN outbound(L"");
        LCNTDSDSA all_ntdsdsas(L"");

        // server, port, domain, username, password
        GatherInput(ldapInfo, lbOpts.site, servers, all_servers, ntdsdsas, all_ntdsdsas,
            inbound, outbound);

        // dump options in verbose mode
        if (lbOpts.verbose) {
            *lbOpts.log << GetMsgString(LBTOOL_PRINT_CLI_OPT_HEADER);
            *lbOpts.log << lbOpts << endl;
        }

        FixNcReasons (all_ntdsdsas, inbound, root_dn);
        FixNcReasons (all_ntdsdsas, outbound, root_dn);
        
        // dump initial input
        if (lbOpts.showInput) {
            SSERVER::iterator ii;
            *lbOpts.log << GetMsgString(LBTOOL_PRINT_CLI_SERVER_NTDS_HEADER) << endl;
            for (ii = servers.objects.begin(); ii != servers.objects.end(); ii++) {
                *lbOpts.log << *(*ii);
                NtdsDsa *nd = (*ii)->getNtdsDsa();
                if (nd) {
                    *lbOpts.log << *nd;
                }
            }
            *lbOpts.log << endl
                << GetMsgString(LBTOOL_PRINT_CLI_CONN_OUTBOUND_HEADER) << outbound << endl
                << GetMsgString(LBTOOL_PRINT_CLI_CONN_INBOUND_HEADER) << inbound << endl;
        }
        afterQuery = clock();

		// write hosted nc's to the log file (verbose mode only)
		if (lbOpts.verbose) {
		    *lbOpts.log << GetMsgString (LBTOOL_PRINT_CLI_NCNAMES_HEADER) << endl;

		    SSERVER::iterator ii;
			for (ii = servers.objects.begin(); ii != servers.objects.end(); ii++) {
				*lbOpts.log << (*ii)->getName() << endl;
				
				vector<Nc> nc_list = (*ii)->getHostedNcs(root_dn);
				vector<Nc>::iterator ni;
				
				for (ni = nc_list.begin(); ni != nc_list.end(); ni++) {
					*lbOpts.log << L"    " << ni->getNcName();

					if (ni->isWriteable()) 
						*lbOpts.log << GetMsgString (LBTOOL_PRINT_CLI_NCNAME_WRITEABLE);
					else 
						*lbOpts.log << GetMsgString (LBTOOL_PRINT_CLI_NCNAME_PARTIAL);

					if (ni->getTransportType() == T_IP) 
						*lbOpts.log << GetMsgString (LBTOOL_PRINT_CLI_NCNAME_IP);
					else 
						*lbOpts.log << GetMsgString (LBTOOL_PRINT_CLI_NCNAME_SMTP);
				}

				*lbOpts.log << endl;
			}
		}

        // balance & stagger        
        if (lbOpts.maxBridge == false || lbOpts.maxBridgeNum > 0) {
            *lbOpts.log << endl << endl << GetMsgString(LBTOOL_PRINT_CLI_DEST_BH_START) << endl;
            if (inbound.objects.size() > 0) {
                BridgeheadBalance bb_inbound(root_dn, inbound, servers, true);
            }
            afterInbound = clock();
            *lbOpts.log << endl << endl << GetMsgString(LBTOOL_PRINT_CLI_SOURCE_BH_START) << endl;
            if (outbound.objects.size() > 0) {
                BridgeheadBalance bb_outbound(root_dn, outbound, servers, false);
            }
            afterOutbound = clock();
        } else {
            afterOutbound = afterInbound = afterQuery;
        }
        if (lbOpts.maxSched == false || lbOpts.maxSchedNum > 0) {
            *lbOpts.log << endl << endl << GetMsgString(LBTOOL_PRINT_CLI_STAGGER_START) << endl;
            ScheduleStagger ss (outbound);
        } 
		if (lbOpts.disownSchedules) {
			SCONN::iterator ci;
			for (ci = outbound.objects.begin(); ci != outbound.objects.end(); ci++) {
				(*ci)->setUserOwnedSchedule (false);
			}
		}
        afterStagger = clock();
        inbound.commit(ldapInfo);
        outbound.commit(ldapInfo);
        afterWrite = clock();

        // stats
        if (lbOpts.performanceStats) {
            *lbOpts.log << endl
                << GetMsgString(LBTOOL_ELAPSED_TIME_LDAP_QUERY) << afterQuery / (double)CLOCKS_PER_SEC << endl
                << GetMsgString(LBTOOL_ELAPSED_TIME_BH_INBOUND) <<  (afterInbound - afterQuery) / (double)CLOCKS_PER_SEC << endl
                << GetMsgString(LBTOOL_ELAPSED_TIME_BH_OUTBOUND)  << (afterOutbound - afterInbound) / (double)CLOCKS_PER_SEC << endl
                << GetMsgString(LBTOOL_ELAPSED_TIME_SCHEDULES) << (afterStagger - afterOutbound) / (double)CLOCKS_PER_SEC << endl
                << GetMsgString(LBTOOL_ELAPSED_TIME_LDAP_WRITE) << (afterWrite - afterOutbound) / (double)CLOCKS_PER_SEC << endl
                << GetMsgString(LBTOOL_ELAPSED_TIME_COMPUTATION)  << (afterStagger - afterQuery) / (double)CLOCKS_PER_SEC << endl
                << GetMsgString(LBTOOL_ELAPSED_TIME_TOTAL)<< (afterStagger)/(double)CLOCKS_PER_SEC << endl;
        }

        // cleanly deal with file handles
        if (lbOpts.logFile.length() > 0) {
            delete lbOpts.log;
        }

        if (lbOpts.previewFile.length() > 0) {
            delete lbOpts.preview;
        }

        exit(EXIT_SUCCESS);
    } catch (Error e) {
        if( lbOpts.log ) {
            *lbOpts.log << e.msg << endl;
        } else {
            wcout << e.msg << endl;
        }
        exit(EXIT_FAILURE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\ismp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ismp.h

Abstract:

    This module define a set of classes to facilitate ISM queries, and availability schedule manipulation
Author:

    Ajit Krishnan (t-ajitk) 13-Jul-2001

Revision History:

    13-Jul-2001    t-ajitk
        Initial Writing
    22-Aug-2001 t-ajitk
        Satisfies load balancing spec
--*/


# ifndef _ismp_h
# define _ismp_h _ismp_h


# include <iostream>
# include <string>
# include <bitset>
# include <vector>
# include <map>

extern "C" {
#include <NTDSpch.h>

# include <windows.h>
# include <Assert.h>
# include <ismapi.h>
# include <minmax.h>
}

# include "ldapp.h"

using namespace std;


// Type Definitions
typedef struct {
    int start;
    int end;
} SegmentDescriptor;
typedef vector<SegmentDescriptor> SchedSegments;


// Constants
static const int MAX_INTERVALS = 4 * SCHEDULE_DATA_ENTRIES;


class Schedule {
/*++ 
Class Description:
    A set of static methods to deal with availability schedules, windows & segments
--*/
public:
    void
    setSchedule (
        IN ISM_SCHEDULE* cs,
        IN int replInterval
        );
    /*++
    Routine Description:
        Standard constructor for a Schedule object.
    Arguments:
        cs - an ISM_SCHEDULE structure which is obtained from the ISM
        replInterval - the replication interval
    --*/

    void
    setSchedule (
        IN PSCHEDULE header,
        IN int replInterval
        );
    /*++
    Routine Description:
        Set the schedule
    Arguments:
        header - A pschedule structure
        replInterval - The replication interval
    --*/

    const bitset<MAX_INTERVALS> &
        getBitset(
        ) const;
    /*++
    Routine Description:
       get the bitset representation for the current schedule
    --*/

    void
    setSchedule (
        IN bitset<MAX_INTERVALS> bs,
        IN int replInterval 
        );
    /*++
    Routine Description:
        Standard constructor for a Schedule object.
    Arguments:
        bs: a bitset representing the schedule
        replInterval - the replication interval
    --*/

    SchedSegments*
    GetSegments(
        int maxSegLength
        ) const;
    /*++
    Routine Description:
        Allocate a vector of segments descriptors. This vector should
        be deleted by the caller when done.
    Arguments:
        maxSegLength - The maximum length of each segment
    --*/

    bitset<MAX_INTERVALS> m_bs;
    friend wostream &operator<< (IN wostream &os, IN const Schedule &s);
    
private:
    int m_repl_interval;

};

wostream &
operator << (
    IN wostream &os, 
    IN const Schedule &s
    );
/*++
Routine Description:
    Prints out all the windows in the schedule
Return Value:
    A reference to a modified wostream
--*/


typedef LdapContainer<Connection> LCCONN, *PLCCONN;
typedef LdapContainer<Server> LCSERVER, *PLCSERVER;
typedef LdapContainer<NtdsDsa> LCNTDSDSA, *PLCNTDSDSA;
typedef LdapContainer<LdapObject> LCLOBJECT, *PLCLOBJECT;
typedef LdapContainer<NtdsSiteSettings> LCNTDSSITE, *PLCNTDSSITE;

class IsmQuery {
public:
    IsmQuery (
        IN LCCONN &l,
        IN OUT const wstring &hub_dn
        );
    /*++
    Routine Description:
        Standard constructor for an IsmQuery object
    Arguments:
        l: A reference to a ldapcontainer of connections
        hub_dn: The root dn of the container. This _must_ be the root dn, or it will fail.
    --*/

    void
    getReplIntervals (
        );
    /*++
    Routine Description:
        Contact the ISM and populate the replIntervals for each connection
        passed in through the constructor
    --*/

    void
    getSchedules(
        );
    /*++
    Routine Description:
        Contact the ISM and populate the availabitlity schedules for each connection
        passed in through the constructor
    --*/

private:
    PLCCONN m_conn;
    wstring m_base_dn;
};
# endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\ldap.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ldapp

Abstract:

    This module define a set of classes to facilitate LDAP queries & commits.

Author:

    Ajit Krishnan (t-ajitk) 10-Jul-2001

Revision History:

    See header file

--*/


#include "ldapp.h"
#include "base64.h"
#include <map>

map<wstring,int> perServerChanges;

using namespace std;

void
my_assert( char *file, int line, char *foo )
/*++

Routine Description:

    Print the location of the assertion failure and break into the debugger.

    TODO: This has nothing todo with LDAP and does not belong in this file.
    TODO: What is foo?
    
Arguments:

    file
    line

--*/
{
    wcerr << line << file << endl << foo << endl;
    DebugBreak();
}


bool
isBinaryAttribute (
    IN const wstring &w
    )
/*++

Routine Description:

    Determine if an attribute is binary or not

    We are lame and just assume that schedules are the only binary
    attributes that we deal with.

    TODO: This function is a kludge. The design should be changed so that
    this function is not needed.
    
Arguments:

    w - the name of the attribute

--*/
{
    if (_wcsicoll(w.c_str(), L"schedule") == 0) {
        return true;
    }
    return false;
}


wstring 
GetMsgString (
    long sid,
    bool system,
    PWCHAR *args
    )
/*++

Routine Description:

    Return an error string from the msg.rc file

    TODO: Stack-allocated string may cause failure because stack may fail to grow
    TODO: This function has nothing to do with LDAP and does not belong in this file.
    
Arguments:

    sid - The resource of the id string to load.
    
Return Value:

    A wstring conforming to the internationalization specifications

--*/
{
    static WCHAR s_szBuffer[10000];

    LONG options = system? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE;
    DWORD ret=1;
    if (! system) {
        ret = FormatMessage (
            options, NULL, sid, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
            s_szBuffer, ARRAY_SIZE(s_szBuffer), (va_list*)args);
    }
    if (!ret) {
        wcerr << L"Error occured fetching internationalized message number " << sid
              <<  L". Error code: " << GetLastError() << endl;
    }
    if (!ret || system) {
        ret = FormatMessage (
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            (!ret) ? GetLastError() : sid,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
            s_szBuffer,
            ARRAY_SIZE(s_szBuffer),
            NULL);
        if (ret ) {
            wcerr << s_szBuffer << endl;
        }
    }

    wstring w((PWCHAR)s_szBuffer);
    return w;
}

DnManip::DnManip(
    const wstring &dn
    )
/*++

Routine Description:

    Constructor takes the Dn we are interested in manipulating
    
Arguments:

    dn - the DN whose components we are interested in

--*/
{
    PWCHAR wdn = const_cast<PWCHAR>(dn.c_str());
    PWCHAR *explode;

    m_dn = dn;

    // explode it to find qualified rdn
    explode = ldap_explode_dn(wdn, 0);
    if( NULL==explode ) {
        throw Error (GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }
    m_relative = wstring(explode[0]);
    ldap_value_free (explode);    
    m_dsname = genDsNameStruct();
}

DnManip :: ~DnManip (
    ) {
    /*++
    Routine Description:
    
        Destructor frees any dynamically allocated memory
    --*/

    free (m_dsname);
}

const wstring &
DnManip::getRdn(
    ) const
/*++

Routine Description:

    Return the qualified RDN of the current object

Return Value:

    The RDN

--*/
{
    return m_relative;
}

wstring
DnManip :: newParentDn (
    const DnManip &pdn
    ) const
/*++

Routine Description:

    The current object should be moved under another dn. This function
    will determine the new dn. The rdn will remain unchanged

Arguments:

    b - The new parent dn.

Return Value:

    The new DN which would result if it were moved

--*/
{
    PDSNAME dn = genDsNameStruct();
    PWCHAR prdn;
    ULONG len;
    ATTRTYP type;

    prdn=(PWCHAR)(malloc(sizeof(WCHAR) * dn->NameLen));
    if( NULL==prdn ) {
        throw Error (GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }

    // Get and null terminate the rdn
    GetRDNInfoExternal (dn, prdn, &len, &type);
    prdn[len] = '\0';

    // Determine new dn
    PDSNAME dsname_dn = pdn.genDsNameStruct();

    // needs enough space to accomodate new rdn...make a guess, exceeding real size by rdn of new parent
    // we could be more accurate by finding the rdn of the new parent, or by calling appendRDN without it.
    int new_len = (pdn.getDn().length() + len + 1) * sizeof (WCHAR);
    PDSNAME dsname_new_dn = pdn.genDsNameStruct(new_len);
    int iret_len = AppendRDN (dsname_dn, dsname_new_dn, dsname_new_dn->structLen, prdn, len, type);

    Assert (iret_len == 0 && L"Larger allocation required for AppendRDN");


    // Deallocate the 3 DSName structs and return
    wstring ret (dsname_new_dn->StringName);
    free (prdn);
    free (dn);
    free (dsname_dn);
    free (dsname_new_dn);
    return ret;
}

wstring
DnManip :: getParentDn (
    unsigned int cava
    ) const {
    /*++
    Routine Description:
    
        Determine the DN of a parent

    Arguments:
    
        cava - Level of parent (1=parent, 2=grandparent etc)

    Return Value:
    
        The DN of the parent
    --*/
    
    PDSNAME pdn = genDsNameStruct();

    // trim the ds name
    TrimDSNameBy (m_dsname, cava, pdn);
    wstring ret(pdn->StringName);

    free (pdn);
    return ret;
}

const wstring &
DnManip :: getDn (
    ) const {
    /*++
    Routine Description:
    
        Return the original DN

    Return Value:
    
        The DN
    --*/
    
    return m_dn;
}

PDSNAME
DnManip :: genDsNameStruct (
    int size
    ) const {
    /*++
    Routine Description:
    
        Private function allowing us to use NameMatched, etc. It converts a DN into a DSNAME 
        structure. The memory allocated should be freed using free (return_value). The DSNAME
        structure returned will assign 0 as the GUID.

    Arguments:
    
        size - # of bytes to be allocated for DN representation. If 0, it will be figured out.
        automatically. This parameter might be used to allocate more space than the current
        dn in order to store the result of RDN + DN.

    Return Value:
    
        A PDSNAME representing the current DN
    --*/
    
    PWCHAR w = const_cast<PWCHAR>(getDn().c_str());
    int wlen = wcslen (w);

    // Prepare the structure using appropriate macros
    if (size ==0) {
        size = wlen;
    }

    int dsSize = DSNameSizeFromLen (size);
    PDSNAME p = (PDSNAME)(malloc (dsSize));

    if (p == NULL) {
        throw Error (GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }
    
    memset (p, 0, sizeof (DSNAME));
    p->NameLen = wlen;
    p->structLen = dsSize;

    wcscpy (p->StringName, w);

    return p;
}

bool
DnManip :: operator== (
    const DnManip &b
    ) const {
    /*++
    Routine Description:
    
        Determine if two DN's point to the same LDAP entry. This does not hit the server,
        and does its best. It should only be used if both DN's have come from the same server,
        and have the same canonical form as a result. If they do not, the GUID's should be 
        compared instead.

    Return Value:
    
        True if they are the same LDAP object, false otherwise.
    --*/
    
    int ret = NameMatched (m_dsname, b.m_dsname);
    return (ret != 0);
}

bool
DnManip :: operator!= (
    const DnManip &b
    ) const {
    /*++
    Routine Description:
    
        Determine if two DN's point to the same LDAP entry. This does not hit the server,
        and does its best. It should only be used if both DN's have come from the same server,
        and have the same canonical form as a result. If they do not, the GUID's should be 
        compared instead.

    Return Value:
    
        False if they are the same LDAP object, true otherwise.
    --*/
    
    return (! operator==(b));
}


AttrValue :: AttrValue (
    IN PBYTE _value,
    IN int _size
    ) :
    /*++
    Routine Description:
    
        Using the constructor will warn us when this public struct changes, allowing us to find
        any errors.
    --*/
    
    value (_value),
    size (_size) {
}

bool
AttrValue :: decodeLdapDistnameBinary(
    OUT PVOID *ppvData,
    OUT LPDWORD pcbLength,
    IN LPWSTR *ppszDn
    )
/*++
Routine Description:

    Decode an argument of type DN(binary)
    
Arguments:

    pszLdapDistnameBinaryValue - Incoming ldap encoded distname binary value
    
    ppvData - Newly allocated data. Caller must deallocate
    
    pcbLength - length of returned data
    
    ppszDn - pointer to dn within incoming buffer, do not deallocate
    
Return Value:

    BOOL -

Implementation Details:

    This code taken from repadmin
--*/
{
    LPWSTR pszColon, pszData;
    DWORD length, i;

    LPWSTR pszLdapDistnameBinaryValue = (LPWSTR)value;

    // Check for 'B'
    if (*pszLdapDistnameBinaryValue != L'B') {
        return FALSE;
    }

    // Check for 1st :
    pszLdapDistnameBinaryValue++;
    if (*pszLdapDistnameBinaryValue != L':') {
        return FALSE;
    }

    // Get the length
    pszLdapDistnameBinaryValue++;

        
    length = wcstol(pszLdapDistnameBinaryValue, NULL, 10);

       
    if (length & 1) {
        // Length should be even
        return FALSE;
    }
    *pcbLength = length / 2;

    // Check for 2nd :
    pszColon = wcschr(pszLdapDistnameBinaryValue, L':');

       
    if (!pszColon) {
        return FALSE;
    }

    // Make sure length is correct
    pszData = pszColon + 1;
    if (pszData[length] != L':') {
        return FALSE;
    }
    pszColon = wcschr(pszData, L':');
    if (!pszColon) {
        return FALSE;
    }
    if (pszColon != pszData + length) {
        return FALSE;
    }


    // Decode the data
    *ppvData = malloc( *pcbLength );
    if(! *ppvData ) {
        throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }


    for( i = 0; i < *pcbLength; i++ ) {
        WCHAR szHexString[3];
        szHexString[0] = *pszData++;
        szHexString[1] = *pszData++;
        szHexString[2] = L'\0';
        ((PCHAR) (*ppvData))[i] = (CHAR) wcstol(szHexString, NULL, 16);
    }

    Assert( pszData == pszColon && L"decodeLdapDistnameBinary Assertion failed");

    // Return pointer to dn
    *ppszDn = pszColon + 1;

    return TRUE;
} /* decodeLdapDistnameBinary */

    
wostream &
operator<< (
    wostream &os, 
    const AttrValue &av
    ) {
    /*++
    Routine Description:
    
        Standard ostream operator for an Attribute Value.
        All attributes are assumed to be text.
    --*/

    
    return os << (PWCHAR)(av.value);
}

Attribute :: Attribute (
    IN const wstring &name
    ) :
    /*++
    Routine Description:
    
        Constructor

    Arguments:
    
        name - Each attribute must have a name
    --*/
    
    m_name (name)  {
    m_modified = false;
}

const wstring & 
Attribute :: getName (
    ) const {
    /*++ 
    Routine Description:
    
        Return the name of the current attribute object.

    Return Value:
    
        Name of the attribute.
    --*/
    
    return m_name;
}

int 
Attribute :: numValues (
    ) const {
    /*++
    Routine Description:
    
        Return the number of binary attributes this object contains.

    Return Value: 
    
        Number of binary attributes.
    --*/
    
    return m_values.size();
}

void 
Attribute :: addValue (
    IN const AttrValue &a
    ) {
    /*++
    Routine Description:
    
        Add a binary value to the list of values for this attribute. All attributes are modelled
        as multi-valued attributed. In this internal representation, multiple values may be
        specified for a single-valued attribute. It is the responsibility of the calling class to
        use addValue() or setValue() appropriately.

    Arguments:
    
        AttrValue - a binary attribute

    Return Value:
        None
    --*/

    m_values.push_back (a);
}

const AttrValue & 
Attribute :: getValue (
    IN int i
    ) const {
    /*++
    Routine Description:
    
        Get a read-only copy of the ith attribute value contained in this object. 
        If the range is invalid, this function will fail an Assertion.

    Arguments:
    
        i - Get the ith value (0 <= i <= numValues()-1)

    Return Value: 
    
        A read-only reference to the ith value
    --*/
    
    Assert(i >= 0 && i < m_values.size());
    return m_values[i];
}

AttrValue & 
Attribute :: setValue (
    IN int i,
    IN PBYTE value,
    IN int size
    ) {
    /*++
    Routine Description:
    
        Get a writeable copy of the ith attribute value contained in this object.

    Arguments:
    
        i - Get the ith value (0 <= i <= numValues()-1)

    Return Value: 
    
        A writeable reference to the ith value
    --*/

    
    Assert (i >= 0 && i < m_values.size());
    m_modified = true;
    m_values[i].value = value;
    m_values[i].size = size;
    return m_values[i];
}

AttrValue & 
Attribute :: setValue (
    IN int i
    ) {
    /*++
    Routine Description:
    
        Get a writeable copy of the ith attribute value contained in this object.

    Arguments:
    
        i - Get the ith value (0 <= i <= numValues()-1)

    Return Value: 
    
        A writeable reference to the ith value
    --*/
    Assert (i >= 0 && i < m_values.size());
    m_modified = true;
    return m_values[i];
}


bool
Attribute :: isModified (
    ) const {
    /*++
    Routine Description:
    
        Determines whether or not this attribute has been modified

    Return Value:
    
        true if setValue(i) was called; false otherwise
    -- */
    
    return m_modified;    
}

PLDAPMod
Attribute::getLdapMod(
    IN ULONG    mod_op,
    IN bool     binary
    ) const
/*++

Routine Description:

    Generate an LDAPMod structure for a given attribute
    
Arguments:

    mod_op - Type of structure: add, delete, replace etc
    binary - True if it is a binary attribute, false otherwise

--*/
{
    
    LDAPMod *lm = (PLDAPMod)malloc(sizeof(LDAPMod));
    if (!lm) {
        throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }

    lm->mod_op = mod_op;
    lm->mod_type = _wcsdup (getName().c_str());

    if (binary) {
        lm->mod_vals.modv_bvals = (struct berval**)(malloc(sizeof(berval) * (numValues() +1)));
        if( lm->mod_vals.modv_bvals == NULL ) {
            throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
        }

        for (int i=0; i<numValues(); i++) {
            berval *bv = (berval*)(malloc(sizeof(berval)));
            if (bv == NULL) {
                throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
            }
            bv->bv_len = getValue(i).size;
            bv->bv_val = (char*)getValue(i).value;
            lm->mod_vals.modv_bvals[i] = bv;
        }
        lm->mod_vals.modv_bvals[numValues()] = NULL;
        lm->mod_op |= LDAP_MOD_BVALUES;
    } else {
        // For string values, populate the PWCHAR* mod_vals.modv_strvals structure
        // with the strings with which the attribute values should be replaced

        lm->mod_vals.modv_strvals = (PWCHAR*)(malloc(sizeof(PWCHAR)*(numValues() + 1)));
        if( lm->mod_vals.modv_strvals == NULL ) {
            throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
        }

        for (int i=0; i<numValues(); i++) {
            lm->mod_vals.modv_strvals[i] = _wcsdup ((PWCHAR)(getValue(i).value));
        }
        lm->mod_vals.modv_strvals[numValues()] = NULL;
    }

    return lm;
}

void
Attribute :: commit (
    IN const LdapInfo &li,
    IN const wstring &sdn,
    IN bool binary,
    IN bool rename
    ) const
/*++

Routine Description:

    Modify this attribute of the given dn. It will connect to the LDAP server
    and will modify the attribute values for a given dn.

Arguments:

    i - The ldap server info to connect to
    dn - The dn of the object whose attribute should be modified
    binary - Binary values and String values are treated differently by the LDAP 
    server. Binary values will be committed as is, while string values may be 
    converted to appropriate encodings etc. Specify which behaviour should be
    followed.

Return Value:

    None

--*/
{ 
    if (! rename && ! m_modified) {
        return;
    }

    wstring name = getName();
    if (_wcsicoll (name.c_str(), L"schedule") == 0) {
        binary = true;
    }

    LbToolOptions lbOpts = GetGlobalOptions();
    if (lbOpts.previewBool) {
        if (! rename) {
            *lbOpts.preview << L"replace: " << getName() << endl;
        } 
        for (int i=0; i<numValues(); i++) {
            if (!binary) {
                *lbOpts.preview << getName() << L": " << (PWCHAR)(getValue(i).value) << endl;
            } else {
                PWCHAR encoded = base64encode(getValue(i).value, getValue(i).size);
                if (! encoded) {
                    throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
                }
                *lbOpts.preview << getName() << L":: " << encoded << endl;
            }
        }
        return;
    }

    LDAPMod lm;

    // Populate ldapmod structure
    lm.mod_op = LDAP_MOD_REPLACE;

    if (binary) { 
        lm.mod_op |= LDAP_MOD_BVALUES;
    }
    
    lm.mod_type = _wcsdup (getName().c_str());

    // Populate the values to the sent to the ldap server (use appropriate format for binary/strings)
    if (binary) {
        lm.mod_vals.modv_bvals = (struct berval**)(malloc(sizeof(berval) * (numValues() +1)));
        if( lm.mod_vals.modv_bvals == NULL ) {
            throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
        }

        for (int i=0; i<numValues(); i++) {
            berval *bv = (berval*)(malloc(sizeof(berval)));
            if (bv == NULL) {
                throw (Error(GetMsgString(LBTOOL_OUT_OF_MEMORY)));
            }
            bv->bv_len = getValue(i).size;
            bv->bv_val = (char*)getValue(i).value;
            lm.mod_vals.modv_bvals[i] = bv;
        }
        lm.mod_vals.modv_bvals[numValues()] = NULL;
    } else {
        // For string values, populate the PWCHAR* mod_vals.modv_strvals structure
        // with the strings with which the attribute values should be replaced

        lm.mod_vals.modv_strvals = (PWCHAR*)(malloc(sizeof(PWCHAR)*(numValues() + 1)));
        if( lm.mod_vals.modv_strvals == NULL ) {
            throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
        }

        for (int i=0; i<numValues(); i++) {
            lm.mod_vals.modv_strvals[i] = _wcsdup ((PWCHAR)(getValue(i).value));
        }
        lm.mod_vals.modv_strvals[numValues()] = NULL;
    }

    // Prepare null terminated modification array
    LDAPMod *mods[2];
    mods[0] = &lm;
    mods[1] = NULL;
    
    LDAP *ld = li.getHandle();
    PWCHAR dn = const_cast<PWCHAR>(sdn.c_str());

    int rc = ldap_modify_ext_s (ld, dn, mods, NULL, NULL);
    
    if (rc != LDAP_SUCCESS) {
        throw Error (GetMsgString(LBTOOL_LDAP_MODIFY_ERROR) + wstring(ldap_err2string(rc)));
    }
    if (binary) {
            free (lm.mod_vals.modv_bvals);
    } else {
        free (lm.mod_vals.modv_strvals);
    }

    if (binary) {
        for (int i=0; i<numValues(); i++) {
            free (lm.mod_vals.modv_bvals[i]);
        }
    } else {
        for (int i=0; i<numValues(); i++) {
            free (lm.mod_vals.modv_strvals[i]);
        }
    }

    free (lm.mod_type);
}


wostream &
operator<< (
    IN wostream &os,
    IN const Attribute &a
    ) {
    /*++
    Routine Description:
    
        Standard ostream operator for an Attribute
    --*/
    
    os << L"\t" << a.getName() << endl;
    for (int i=0; i < a.numValues(); i++) {
        if (a.getName() != L"schedule") {
            os << L"\t\t" << a.getValue(i) << endl;
        } else {
            AttrValue av = a.getValue(i);
            for (int i=0; i< av.size; i++) {
                os << hex << av.value[i];
            }
            os << dec << endl;
        };
    }
    return os;
}

LdapInfo :: LdapInfo (
    IN const wstring &server,
    IN int port, 
    IN const wstring &domainname,
    IN const wstring &username,
    IN const wstring &password
    ) {
    /*++
    Routine Description:
    
        The constructor takes in all required information to ensure that the object
        is in a consistent state. 

    Arguments:
    
        server - dns name of the server on which the ldap server resides
        port - the port number on which the ldap server resides
        domainname - domainname allows the use of altername credentials
        username - username allows the use of alternate credentials [optional]
        Use either the username or domain qualified username eg. "t-ajitk" or "redmond\\t-ajitk"
        password - password allows the use of alternate credentials [optional]
    --*/
    
    this->server = server;
    this->port = port;
    this->domainname = domainname;
    this->username = username;
    this->password = password;
    this->m_handle = NULL;
}

LDAP*
LdapInfo :: getHandle (
    ) const {
    /*++
    Routine Description:
    
        This returns an ldap handle from the structure. This allows us to pass this structure
        around, and yet retain the performance of a single LDAP session.

    Return Value:
    
        A valid LDAP handle
    --*/
    
    if (m_handle) {
        return m_handle;
    }
    
    int rc;

    PWCHAR servername = const_cast<PWCHAR>(this->server.c_str());

    // Initialize LDAP Session
    if (( m_handle = ldap_init (servername, port)) == NULL) {
        free (servername);
        throw (Error(GetMsgString(LBTOOL_LDAP_INIT_ERROR)));
    }

    // Bind to LDAP server
    PWCHAR username = const_cast<PWCHAR>(this->username.c_str());
    PWCHAR password = const_cast<PWCHAR>(this->password.c_str());
    PWCHAR domain = const_cast<PWCHAR>(this->domainname.c_str());

    if (wcslen(username) > 0) {
        // Create structure needed for ldap_bind
        SEC_WINNT_AUTH_IDENTITY ident;
        ident.User = username;
        ident.UserLength = wcslen (username);
        ident.Domain = domain;
        ident.DomainLength = wcslen (domain);
        ident.Password = password;
        ident.PasswordLength = wcslen (password);
        ident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        rc = ldap_bind_s (m_handle, username, (PWCHAR)&ident, LDAP_AUTH_NEGOTIATE);
    } else {
        rc = ldap_bind_s (m_handle, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    }

    if (rc != LDAP_SUCCESS) {
        throw (Error (GetMsgString(LBTOOL_LDAP_BIND_ERROR) + wstring(ldap_err2string(rc))));
        m_handle = NULL;
    }

       int version = LDAP_VERSION3;
        rc = ldap_set_option( m_handle, LDAP_OPT_PROTOCOL_VERSION, &version);

    if (rc != LDAP_SUCCESS) {
        throw (Error (GetMsgString(LBTOOL_LDAP_V3_UNSUPPORTED) + wstring (ldap_err2string(rc))));
    }

        Assert (m_handle && L"Unable to create LDAP Handle. Uncaught error");
    return m_handle;
}

LdapInfo :: ~LdapInfo (
    ) {
    /*++
    Routine Description:
    
        Destructor deallocates any dynamically allocated memory used by this class
    --*/
    
    ldap_unbind_s (m_handle);
    m_handle = NULL;
}

LdapQuery :: LdapQuery  (
    IN const wstring baseDn, 
    IN const wstring filter, 
    IN const LdapQueryScope & scope, 
    IN const vector < wstring > & attributes
    ) {
    /*++
    Routine Description:
    
        The constructor takes in all required information to ensure that the object
        is in a consistant state.

    Arguments:
    
        baseDn - fully qualified DN from where the search will be rooted
        filter - the filter wstring (LDAP query) to be used
        scope - the scope of the search
        attributes - A list of attribute names, whose corresponding values will be requested
            from the LDAP server.
    --*/
    
    this->baseDn = baseDn;
    this->filter = filter;
    this->scope = scope;
    this->attributes = attributes;
}

LdapObject :: LdapObject (
    IN const wstring &dn
    ) {
    /*++
    Routine Description:
    
        The constructor requires the DN of the object
    --*/
    
    m_dn = dn;
    m_new_dn = L"";
    m_num_attributes = 0;
    m_modified_cache = false;
}

const wstring &
LdapObject :: getName (
    ) const {
    /*++
    Routine Description:
    
        Get the DN of the current object

    Return value:
    
        The DN of the current LDAP object.
    --*/
    
    if (m_new_dn != L"") {
        return m_new_dn;
    }

    return m_dn;
}

int
LdapObject :: numAttributes (
    ) const {
    /*++
    Routine Description:
    
        Get the number of attributes the current object has

    Return value:
    
        The number of attributes.
    --*/
    
    return m_num_attributes;
}

void 
LdapObject :: addAttribute (
    IN const Attribute &a
    ) {
    /*++
    Routine Description:
    
        Add an attribute to the current object

    Arguments:
    
        a - the attribute to be added to the object

    Return value:
        none
    --*/
    
    m_modified_cache = true;
    m_num_attributes++;
    m_attributes.push_back (a);
}

Attribute &
LdapObject :: getAttribute (
    IN int i
    ) {
    /*++
    Routine Description:
    
        Get a writeable handle to the ith attribute of the current object

    Arguments:
    
        i - The ith attribute should be returned. 0 <= i <= numAttributes -1

    Return Value:
    
        A writeable handle to the ith attribute
    --*/
    
    Assert (i >= 0 && i < m_num_attributes);
    return m_attributes[i];    
}

void
LdapObject :: rename (
    IN const wstring &dn
    ) {
    /*++
    Routine Description:
    
        Change the  DN of the current object. This is internal to the state of the
        current object only, and will only be written to the LDAP server if the commit() 
        function is called.

    Arguments:
    
        dn - the DN of the renamed object.

    Return Value:
    
        None
    --*/
    
    m_new_dn = dn;
}


void
LdapObject::commit_copy_rename(
    IN const LdapInfo &info
    )
/*++
Routine Description:

    Write the LDAP object to the LDAP server using the credentials in i
    If the object has been renamed, it will be moved to the new location.
    This will be done by adding a new object and deleting the old object
    
Arguments:

    i - Use the credentials in i to bind to the server specified in i
    
Return Value:

    None
--*/
{
    vector<Attribute>::const_iterator ii;

    LbToolOptions lbOpts = GetGlobalOptions();

    if (lbOpts.previewBool) {
        *lbOpts.preview << L"dn: " << m_new_dn << endl
            << L"changetype:  add"<< endl;
        for (ii = m_attributes.begin(); ii != m_attributes.end(); ii++) {
            bool binary = false;
            wstring attr_name = ii->getName();
            if (_wcsicoll (attr_name.c_str(), L"schedule") == 0) {
                binary = true;
            }
            ii->commit (info, getName(), binary, true);
        }
        *lbOpts.preview << endl;

        *lbOpts.preview << L"dn: " << m_dn << endl
            << L"changetype: delete" << endl << endl;;

        return;
    } 

    // fall through: commit to server
    int num_attrs = numAttributes();
    PLDAPMod *attrs = (PLDAPMod*)malloc(sizeof(PLDAPMod*) * (num_attrs+1));
    if (! attrs) {
        throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }

    // generate ldapmod structures
    for (int i=0; i<num_attrs; i++) {
        Attribute a = getAttribute(i);
        bool binary =  isBinaryAttribute(a.getName());
        attrs[i] = a.getLdapMod(LDAP_MOD_ADD, binary);
    }
    attrs[num_attrs] = NULL;

    // add new object
    ULONG msg_num;
    int rc= ldap_add_ext (info.getHandle(), const_cast<PWCHAR>(m_new_dn.c_str()), attrs, NULL, NULL, &msg_num);

    if (rc != LDAP_SUCCESS) {
        throw (Error(GetMsgString(LBTOOL_LDAP_MODIFY_ERROR) + wstring(ldap_err2string(rc))));
    }

    // delete first object
    rc = ldap_delete_ext_s (info.getHandle(), const_cast<PWCHAR>(m_dn.c_str()), NULL, NULL);
    if (rc != LDAP_SUCCESS) {
        throw (Error(GetMsgString(LBTOOL_LDAP_MODIFY_ERROR) + wstring(ldap_err2string(rc))));
    }

    // free the memory for the ldapmod structures
    for (int i=0; i<num_attrs; i++) {
        Attribute a = getAttribute(i);
        bool binary = isBinaryAttribute(a.getName());
        for (int j=0; j<a.numValues(); j++) {
            if (binary) {
                free (attrs[i]->mod_vals.modv_bvals[j]);
            } else {
                free (attrs[i]->mod_vals.modv_strvals[j]);
            }
        }
        free (attrs[i]);
    }
    free (attrs);
}


void
LdapObject::commit_rename(
    IN const LdapInfo &info
    )
/*++
Routine Description:

    Write the LDAP object to the LDAP server using the credentials in i
    If the object has been renamed, it will be moved to the new location.
    This will be done by actually renaming the object, not copying it.
    This operation will only succeed if the appropriate systemFlag has
    been set.
    
Arguments:

    i - Use the credentials in i to bind to the server specified in i
    
Return Value:

    None
--*/
{
    LbToolOptions lbOpts = GetGlobalOptions();
    LDAP *ld = info.getHandle();

    if (lbOpts.previewBool) {
        *lbOpts.preview << L"dn: " << m_dn << endl;
        *lbOpts.preview << L"changetype: modrdn" << endl
                << L"newrdn: " << DnManip(m_new_dn).getRdn() << endl
                << L"deleteoldrdn: 1" << endl
                << L"newsuperior: " << DnManip(m_new_dn).getParentDn(1) << endl << endl;
        return;
    }

    PWCHAR dn = const_cast<PWCHAR>(m_dn.c_str());
    wstring foo = DnManip(m_new_dn).getRdn();
    PWCHAR new_rdn = const_cast<PWCHAR>(foo.c_str());
    wstring bar = DnManip(m_new_dn).getParentDn(1);
    PWCHAR new_parent_dn = const_cast<PWCHAR>(bar.c_str());

    int rc = ldap_rename_ext_s (ld, dn, new_rdn, new_parent_dn,
            TRUE,     // delete old rdn
            NULL,    // Server controls
            NULL);    // Client controls

    if (rc != LDAP_SUCCESS) {
        throw (Error(GetMsgString(LBTOOL_LDAP_MODIFY_ERROR) + wstring(ldap_err2string(rc))));
    }
    m_modified_cache = false;
}


void
LdapObject :: commit (
    IN const LdapInfo &i
    )
/*++

Routine Description:

    Write the LDAP object to the LDAP server using the credentials in i
    If the object has been renamed, it will be moved to the new location.
    All attributes will be synced to the state found in the current object. i.e.
    The values of each modified attribute found in the current object will be written 
    to the LDAP server. The values will not be overwritten--they will replace the
    values currently found on the object in the LDAP server.

Arguments:

    i - Use the credentials in i to bind to the server specified in i

Return Value:

    None

--*/
{
    
    // If object is unchanged, do nothing
    if (!isModified()) {
        return;
    }

    LbToolOptions &lbOpts = GetGlobalOptions();
    bool preview_header = false;
    
    if (m_new_dn != wstring(L"")) {
		// make sure key for the 
		DnManip dn = getName();
		wstring dest_server = dn.getParentDn (2);

		if (perServerChanges.find(dest_server) == perServerChanges.end()) {
			perServerChanges[dest_server] = 0;
		}
        
		if ((lbOpts.changedBridge < lbOpts.maxBridgeNum &&
			(perServerChanges[dest_server] < lbOpts.maxPerServerChanges
			 || lbOpts.maxPerServerChanges == 0))) {
            lbOpts.changedBridge++;
			perServerChanges[dest_server]++;
            if( IsMoveable() ) {
                commit_rename(i);
            } else {
                commit_copy_rename(i);
            }
			preview_header = true;
        }
    }

	wstring from_server;
	if (fromServerModified()) {
		Connection *tconn = (Connection*)(this);
		DnManip dn = tconn->getFromServer();
		from_server = dn.getParentDn(1);

		// make sure the key exists with an initial value of 0
		if (perServerChanges.find(from_server) == perServerChanges.end()) {
			perServerChanges[from_server] = 0;
		}

		// if we have made the maximum allowable number of changes for this server,
		// bail out here
		if (perServerChanges[from_server] >= lbOpts.maxPerServerChanges &&
			lbOpts.maxPerServerChanges != 0) {
			return;
		}
	}

    vector<Attribute>::const_iterator ii;
    for (ii = m_attributes.begin(); ii != m_attributes.end(); ii++) {
        // modify attributes which have been committed

        if (ii->isModified()) {
            wstring name = ii->getName();
            int ret_sch = _wcsicoll (name.c_str(), L"schedule");
            int ret_opt = _wcsicoll (name.c_str(), L"options");
			int ret_fs = _wcsicoll (name.c_str(), L"fromServer");

            bool under_limit = false;

			// schedule change
			if (ret_sch && lbOpts.changedSched < lbOpts.maxSchedNum) {
				lbOpts.changedSched++;
				under_limit = true;
			}

			// bridgehead change
			else if (ret_fs) {
				perServerChanges[from_server]++;
				under_limit = true;
			}

			// option change only when other changes are also being made
			// or when we disown the schedules
			else if (ret_opt && 
					 (lbOpts.changedSched < lbOpts.maxSchedNum ||
					  lbOpts.changedBridge < lbOpts.maxBridgeNum || 
					  lbOpts.disownSchedules )) {
				under_limit = true;
			}
			            
			if (under_limit) {
                if (preview_header == false && lbOpts.previewBool) {
                    preview_header = true;
                    *lbOpts.preview << L"dn: " <<  m_dn << endl
                        << L"changetype: modify" << endl;
                }
                
                ii->commit(i, getName());
                if (lbOpts.previewBool) {
                    *lbOpts.preview << L"-" << endl;
                }    
            }
        } 
    }


    if (preview_header && lbOpts.previewBool) {
            *lbOpts.preview << endl;
    }

    m_modified_cache = false;
    return;
}

int
LdapObject :: findAttribute (
    IN const wstring &find_attr
    ) const {
    /*++
    Routine Description:
    
        Determine if an attribute is present in the ldap object. The attribute name is compared
        case insensitively, and with locale considerations.

    Arguments:
    
        attr_name: the attribute whose presence should be determined

    Return Value:
    
        -1 if it does not exist, or the index if it does
    --*/
    
    int n = numAttributes();

    for (int i=0; i<n; i++) {
        wstring attr = const_cast<LdapObject*>(this)->getAttribute(i).getName();
        if (! _wcsicoll(attr.c_str(), find_attr.c_str())) {
            return i;
        }
    }
    return (-1);
}

bool
LdapObject :: isModified (
    ) const {
    /*++
    Routine Description:
    
        Determine if any of the attributed found in this object were modified,
        or if the object was renamed

    Return Value:
    
        True if rename() was called, or if any attributes have been modified. False otherwise.
    --*/
    
    // only check the attributes if we don't know if it has been modified.
    // else return true.
    if (m_new_dn != L"" || m_modified_cache) {
        return true;
    }

    vector<Attribute>::const_iterator ii;

    for (ii = m_attributes.begin(); ii != m_attributes.end(); ii++) {
        if (ii->isModified()) {
            // update the cache
            m_modified_cache = true;
            return true;
        }
    }
    
    return false;
}

bool
LdapObject::fromServerModified() const
/*++
Routine Description:
	Determine if the from server attribute on this object was modified.
Return Value:
	True if the FromServer attribute exists, and has been modified. False otherwise
--*/   
{
	vector<Attribute>::const_iterator ii;
    for (ii = m_attributes.begin(); ii != m_attributes.end(); ii++) {
        if (ii->getName() == L"fromServer" &&  ii->isModified()) {
            return true;
        }
    }
    
    return false;
}


bool
LdapObject::IsMoveable()
/*++

Routine Description:

    Determine if the current connection can be moved or not
    By default objects are not moveable, unless this method is
    overridden in a derived class.

Return Value:

    TRUE - can be moved
    FALSE - may not be moved

--*/
{
    return FALSE;
}

bool
LdapObject :: operator < (
    IN const LdapObject &other
    ) const {
    /*++ 
    Routine Description:
    
        The operators allow some way to sort the object into standard containers. Its semantics
        are undefined, and may be changed at any time.

    Return Value:
    
        A boolean representing some sorted order
    --*/    
    
    return (getName() < other.getName());
}


wostream &
operator<< (
    IN wostream &os,
    IN LdapObject &lo
    ) {
    /*++
    Routine Description:
    
        Standard ostream operator for an LdapObject
    --*/

    os << lo.getName() << endl;
    for (int i=0; i<lo.numAttributes(); i++)  {
        os << lo.getAttribute(i);
    }
    return os;
}



bool
LdapObjectCmp :: operator() (
    const LdapObject *a, 
    const LdapObject *b
    ) const {
    /*++
    Routine Description:
    
        do *a < *b
        
    Return Value:
    
        same as *a < *b
    --*/
    
    return (*a < *b);
}

Nc :: Nc ( IN const wstring &name,
    IN bool writeable,
    IN bool going,
    IN TransportType transport_type
    ) {
    /*++
    Routine Description:
    
        Standard constructor for an nc object
        
    Arguments:
    
        name - name of the nc
        
        writeable - true if this nc is a writeable copy, false otherwise
        
        going - true if this nc is in the process of being deleted. false otherwise
        
        transport_type - the transport type of this nc
    --*/
    
    m_name = name;
    m_writeable = writeable;
    m_going = going;
    m_transport_type = transport_type;
}

wstring
Nc :: getString (
    ) const {

    wstring reason;
    if (m_writeable) {
        reason = L"00000000";
    } else {
        reason = L"00000001";
    }
    
    return wstring (L"B:8:" + reason + L":" + m_name);
}

bool
Nc :: isWriteable (
    ) const {
    /*++
    Routine Description:
    
        Determine whether or not this is a writeable nc
        
    Return Value:
    
        True if it is writeable. False otherwise.
    --*/
    
    return m_writeable;
}

bool
Nc :: isBeingDeleted (
    ) const {
    /*++
    Routine Description:
    
        Determine whether or not this is nc is going.

    Return Value:
    
        True if it is being deleted. False otherwise.
    --*/
    
    return m_going;
}

TransportType
Nc :: getTransportType (
    ) const {
    /*++
    Routine Description:
    
        Determine the transport type of this nc.
        
    Return Value:
    
        T_IP if it supports IP. T_SMTP if it supports SMTP.
    --*/
    
    return m_transport_type;
}

const wstring&
Nc:: getNcName (
        ) const {
    /*++
    Routine Description:
        Get the name of the current nc
    Return value:
        The name of the current nc
    --*/
    return m_name;
}

bool 
Nc:: operator < (
    IN const Nc &b
    ) {
    /*++
    Routine Description:
        Some way to order NC's. The exact ordering is not specified
    Return Value:
        True or false determining a unique ordering among two NC's.
    --*/
        int ret = _wcsicoll(getNcName().c_str(), b.getNcName().c_str());
        return (ret < 0);
}

wostream &
operator<< (
    IN wostream &os,
    IN const Nc &n
    ) {
/*++
Routine Description:
    Standard ostream operator for an Attribute
--*/
    os << n.m_name << L"Write/Del " << n.m_writeable << L" " << n.m_going;
    if (n.m_transport_type == T_IP) {
        os << L" ip";
    } else {
        os << L" smtp";
    }
    return os;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adprep\exe\adpmain.c ===
/*++

Copyright (C) Microsoft Corporation, 2001
              Microsoft Windows

Module Name:

    ADPMAIN.C

Abstract:

    This file contains routines that check current OS version, and do 
    necessary update before administrator upgrade the Domain Controller.

Author:

    14-May-01 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    14-May-01 ShaoYin Created Initial File.

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//    Include header files                                              //
//                                                                      //
//////////////////////////////////////////////////////////////////////////



#include "adp.h"
#include "adpmsgs.h"


#include <ntverp.h>     // OS_VERSION
#include <ntlsa.h>      // LsaLookupSids

#include <lm.h>         // Net API
#include <sddl.h>       // SDDL

#include <Setupapi.h>   // SetupDecompressOrCopyFile 
#include <dsgetdc.h>    // DsEnumerateDomainTrusts
#include <dnsapi.h>     // DnsNameCompare_ExW
#include <ntldap.h>     // ldap search server control





BOOLEAN
AdpCheckIfAnotherProgramIsRunning(
    VOID
    )
/*++
Routine Description;

    This routine tries to create a mutex with the well known name. If creation
    failed with ERROR_ALREADY_EXISTS, it means another instance of adprep.exe 
    is running. All later instances should exit.
    
Parameters:

    None

Return Value:

    TRUE - There is already another adprep.exe is running. 
    
    FALSE - No, the current process is the only adprep.exe running now.   

--*/
{

    gMutex = CreateMutex(NULL, FALSE, ADP_MUTEX_NAME);

    if (NULL == gMutex || ERROR_ALREADY_EXISTS == GetLastError())
    {
        AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                  ADP_INFO_ALREADY_RUNNING,
                  NULL, 
                  NULL 
                  );

        return( TRUE );
    }
    else
    {
        return( FALSE );
    }

}

ULONG
AdpCreateFullSid(
    IN PSID DomainSid,
    IN ULONG Rid,
    OUT PSID *NewSid
    )
{
    NTSTATUS    WinError = ERROR_SUCCESS; 
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength = 0;
    PULONG      RidLocation = NULL;

    // 
    // calculate the size of the new sid
    // 
    AccountSubAuthorityCount = *GetSidSubAuthorityCount( DomainSid ) + (UCHAR)1;
    AccountSidLength = GetSidLengthRequired( AccountSubAuthorityCount );

    //
    // allocate memory for the new sid
    // 
    *NewSid = AdpAlloc( AccountSidLength );
    if (NULL != *NewSid)
    {
        //
        // Copy the domain sid into the first part of the new sid
        //
        if ( CopySid(AccountSidLength, *NewSid, DomainSid) )
        {
            //
            // Increment the account sid sub-authority count
            //
            *GetSidSubAuthorityCount(*NewSid) = AccountSubAuthorityCount;

            //
            // Add the rid as the final sub-authority
            //
            RidLocation = GetSidSubAuthority(*NewSid, AccountSubAuthorityCount-1);
            *RidLocation = Rid;
        }
        else
        {
            WinError = GetLastError();
        }
    }
    else
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if ((ERROR_SUCCESS != WinError) &&
        (NULL != *NewSid))
    {
        AdpFree( *NewSid );
        *NewSid = NULL;
    }

    return( WinError );
}




VOID 
AdpLogMissingGroups(
    BOOLEAN fDomainUpdate, 
    BOOLEAN fForestUpdate, 
    BOOLEAN fMemberOfDomainAdmins, 
    BOOLEAN fMemberOfEnterpriseAdmins,
    BOOLEAN fMemberOfSchemaAdmins, 
    PWCHAR  DomainDnsName
    )
/*++
Routine Description: 

    Adprep deteced that the logon user is not a member of one or all following
    groups, Enterprise Admins Group, Schema Admins Group and Domain Admins Group. 
    
    This routine tells client exactly which group the logon user is not a member
    of.  
   
--*/
{
    if (fDomainUpdate)
    {
        // DomainPrep 
        AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                  ADP_INFO_PERMISSION_IS_NOT_GRANTED_FOR_DOMAINPREP,
                  DomainDnsName,
                  DomainDnsName 
                  );
    }
    else
    {
        // ForestPrep
        ASSERT( fForestUpdate );

        if (fMemberOfEnterpriseAdmins)
        {
            if (fMemberOfSchemaAdmins)
            {
                // case 1:  not member of domain admins group
                ASSERT( !fMemberOfDomainAdmins );

                AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                          ADP_INFO_PERMISSION_IS_NOT_GRANTED_FOR_FORESTPREP1,
                          DomainDnsName,
                          DomainDnsName
                          );
            }
            else
            {
                if (fMemberOfDomainAdmins)
                {
                    // case 2: not a member of Schema admins group 
                    AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                              ADP_INFO_PERMISSION_IS_NOT_GRANTED_FOR_FORESTPREP2,
                              DomainDnsName,
                              NULL
                              );

                }
                else
                {
                    // case 3: not a member of schema and domain admins group
                    AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                              ADP_INFO_PERMISSION_IS_NOT_GRANTED_FOR_FORESTPREP3,
                              DomainDnsName,
                              DomainDnsName
                              );
                }
            }
        }
        else
        {
            if (fMemberOfSchemaAdmins)
            {
                if (fMemberOfDomainAdmins)
                {
                    // case 4: not a member of Enterprise Admins group
                    AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                              ADP_INFO_PERMISSION_IS_NOT_GRANTED_FOR_FORESTPREP4,
                              DomainDnsName,
                              NULL
                              );
                }
                else
                {
                    // case 5: not a member of Enterprise and Domain Admins Group 
                    AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                              ADP_INFO_PERMISSION_IS_NOT_GRANTED_FOR_FORESTPREP5,
                              DomainDnsName,
                              DomainDnsName
                              );
                }
            }
            else
            {
                if (fMemberOfDomainAdmins)
                {
                    // case 6: not a member of Enterprise and Schema Admins group 
                    AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                              ADP_INFO_PERMISSION_IS_NOT_GRANTED_FOR_FORESTPREP6,
                              DomainDnsName,
                              NULL
                              );
                }
                else
                {
                    // case 7: not a member of Enterprise, Schema and Domain Admins Group 
                    AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                              ADP_INFO_PERMISSION_IS_NOT_GRANTED_FOR_FORESTPREP7,
                              DomainDnsName,
                              DomainDnsName
                              );
                }
            }
        }
    }

    return;
}



ULONG
AdpGetRootDomainSid(
    PSID *RootDomainSid
    )
/*++
Routine Description:

    this routine search the rootDSE object of the local DC, get 
    extended DN value of rootDomainNamingContext attribute, 
    extract root domain SID from the extended DN.

Parameter:

    RootDomainSid - return root domain sid
    
Return Value:

    Win32 code  

--*/
{
    ULONG           WinError = ERROR_SUCCESS;
    ULONG           LdapError = LDAP_SUCCESS;
    ULONG           ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    WCHAR           ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    PLDAP           phLdap = NULL;
    LDAPControlW    ServerControls;
    LDAPControlW    *ServerControlsArray[] = {&ServerControls, NULL};
    WCHAR           *AttrArray[] = {LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT_W, NULL};
    LDAPMessage     *SearchResult = NULL;
    LDAPMessage     *Entry = NULL;
    WCHAR           **Values = NULL;
    WCHAR           *pSidStart, *pSidEnd, *pParse;
    BYTE            *pDest = NULL, OneByte;
    DWORD           RootDomainSidBuf[sizeof(SID)/sizeof(DWORD)+5];



    //
    // get local computer NetBios name
    // 
    memset(ComputerName, 0, sizeof(WCHAR) * ComputerNameLength);
    if (FALSE == GetComputerNameW (ComputerName, &ComputerNameLength))
    {
        WinError = GetLastError();
        return( WinError );
    }


    //
    // bind to ldap
    // 
    phLdap = ldap_openW( ComputerName, LDAP_PORT );
    if (NULL == phLdap)
    {
        WinError = LdapMapErrorToWin32( LdapGetLastError() ); 
        return( WinError );
    }


    LdapError = ldap_bind_sW( phLdap, NULL, NULL, LDAP_AUTH_NEGOTIATE );
    if (LDAP_SUCCESS != LdapError)
    {
        WinError = LdapMapErrorToWin32( LdapError );
        goto Error;
    }

    //
    // setup the control
    // 
    memset( &ServerControls, 0, sizeof(ServerControls) );
    ServerControls.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    ServerControls.ldctl_iscritical = TRUE;


    //
    // search root DSE object, get rootDomainNamingContext with extended DN
    // 
    LdapError = ldap_search_ext_sW(phLdap, 
                                   L"",         // baseDN (root DSE)
                                   LDAP_SCOPE_BASE,
                                   L"(objectClass=*)",  // filter
                                   AttrArray,   // attr array
                                   FALSE,       // get values
                                   (PLDAPControlW *)ServerControlsArray, // server control 
                                   NULL,        // no client control
                                   NULL,        // no time out
                                   0xFFFFFFFF,  // size limite
                                   &SearchResult
                                   );

    if (LDAP_SUCCESS != LdapError)
    {
        WinError = LdapMapErrorToWin32( LdapError );
        goto Error;
    }


    Entry = ldap_first_entry( phLdap, SearchResult );
    if (NULL == Entry)
    {
        WinError = LdapMapErrorToWin32( LdapGetLastError() );
        goto Error;
    }                  


    Values = ldap_get_valuesW( phLdap, Entry, AttrArray[0] );
    if (NULL == Values)
    {
        WinError = LdapMapErrorToWin32( LdapGetLastError() );
        goto Error;
    }

    if ( Values[0] && Values[0][0] != L'\0' )
    {
        // Values[0] is the value to parse.
        // The data will be returned as something like:

        // <GUID=278676f8d753d211a61ad7e2dfa25f11>;<SID=010400000000000515000000828ba6289b0bc11e67c2ef7f>;DC=foo,DC=bar

        // Parse through this to find the <SID=xxxxxx> part.  Note that it 
        // may be missing, but the GUID= and trailer should not be.
        // The xxxxx represents the hex nibbles of the SID.  Translate 
        // to the binary form and case to a SID.

        pSidStart = wcsstr( Values[0], L"<SID=" );

        if ( pSidStart )
        {
            //
            // find the end of this SID
            //
            pSidEnd = wcschr(pSidStart, L'>');

            if ( pSidEnd )
            {
                pParse = pSidStart + 5;
                pDest = (BYTE *)RootDomainSidBuf;

                while ( pParse < pSidEnd-1 )
                {
                    if ( *pParse >= L'0' && *pParse <= L'9' ) {
                        OneByte = (BYTE) ((*pParse - L'0') * 16);
                    }
                    else {
                        OneByte = (BYTE) ((towlower(*pParse) - L'a' + 10) * 16);
                    }

                    if ( *(pParse+1) >= L'0' && *(pParse+1) <= L'9' ) {
                        OneByte += (BYTE) (*(pParse+1) - L'0');
                    }
                    else {
                        OneByte += (BYTE) (towlower(*(pParse+1)) - L'a' + 10);
                    }

                    *pDest = OneByte;
                    pDest++;
                    pParse += 2;
                }

                *RootDomainSid = AdpAlloc( RtlLengthSid((PSID)RootDomainSidBuf) );
                if (NULL != *RootDomainSid)
                {
                    memset(*RootDomainSid, 0, RtlLengthSid((PSID)RootDomainSidBuf) );
                    RtlCopySid(RtlLengthSid((PSID)RootDomainSidBuf), 
                               *RootDomainSid, 
                               (PSID)RootDomainSidBuf
                               );
                }
                else {
                    WinError = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                WinError = ERROR_DS_MISSING_REQUIRED_ATT;
            }
        }
        else {
            WinError = ERROR_DS_MISSING_REQUIRED_ATT;
        }
    }
    else {
        WinError = ERROR_DS_MISSING_REQUIRED_ATT;
    }


Error:

    if ( Values ) {
        ldap_value_freeW( Values );
    }

    if ( SearchResult ) {
        ldap_msgfree( SearchResult );
    }

    if ( phLdap ) {
        ldap_unbind( phLdap );
    }

    return( WinError );

}




ULONG
AdpGetWellKnownGroupSids(
    OUT PSID *DomainAdminsSid,
    OUT PSID *EnterpriseAdminsSid,
    OUT PSID *SchemaAdminsSid,
    OUT PWCHAR *DomainDnsName
    )
/*++
    this routine fills out 
        DomainAdminsSid, EnterpriseAdminsSid, 
        SchemaAdminsSid and DomainDnsName

--*/
{
    ULONG                   WinError = ERROR_SUCCESS;
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    LSA_HANDLE              LsaPolicyHandle = NULL;
    LSA_OBJECT_ATTRIBUTES   ObjectAttributes;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    PSID                    RootDomainSid = NULL;

    
    //
    // initialize return values
    // 
    *DomainAdminsSid = NULL;
    *EnterpriseAdminsSid = NULL;
    *SchemaAdminsSid = NULL;
    *DomainDnsName = NULL;



    //
    // Get a handle to the Policy object.
    // 
    memset(&ObjectAttributes, 0, sizeof(ObjectAttributes));
    NtStatus = LsaOpenPolicy(NULL,
                             &ObjectAttributes, 
                             POLICY_ALL_ACCESS, //Desired access permissions.
                             &LsaPolicyHandle
                             );

    if ( !NT_SUCCESS(NtStatus) )
    {
        WinError = LsaNtStatusToWinError( NtStatus );
        goto Error;
    }


    //
    // Query primary domain information
    // 
    NtStatus = LsaQueryInformationPolicy(
                    LsaPolicyHandle, 
                    PolicyDnsDomainInformation,
                    &DnsDomainInfo
                    );

    if ( !NT_SUCCESS(NtStatus) )
    {
        WinError = LsaNtStatusToWinError( NtStatus );
        goto Error;
    }


    //
    // create domain admins SID and domain dns name
    // 
    WinError = AdpCreateFullSid(DnsDomainInfo->Sid,
                                DOMAIN_GROUP_RID_ADMINS,
                                DomainAdminsSid
                                );

    if (ERROR_SUCCESS != WinError)
    {
        goto Error;
    }

    // get domainDnsName
    *DomainDnsName = AdpAlloc(DnsDomainInfo->DnsDomainName.MaximumLength + sizeof(WCHAR)); // extra WCHAR for null terminator
    if (NULL == *DomainDnsName)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }
    memset(*DomainDnsName, 0, DnsDomainInfo->DnsDomainName.MaximumLength + sizeof(WCHAR) );
    memcpy(*DomainDnsName, 
           DnsDomainInfo->DnsDomainName.Buffer,
           DnsDomainInfo->DnsDomainName.Length
           );



    //
    // construct EnterpriseAdminsGroup SID and Schema Admins Group SID
    // 

    // get root domain SID
    WinError = AdpGetRootDomainSid( &RootDomainSid );
    if (ERROR_SUCCESS != WinError) {
        goto Error;
    }

    // if somehow can't retrieve root domain sid
    if (NULL == RootDomainSid) {
        WinError = ERROR_DS_MISSING_REQUIRED_ATT;
        goto Error;
    }

    // create enterpriseAdminsGroupSid
    WinError = AdpCreateFullSid(RootDomainSid,
                                DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
                                EnterpriseAdminsSid
                                );
    if (ERROR_SUCCESS != WinError) {
        goto Error;
    }

    // create SchemaAdminsGroupSid
    WinError = AdpCreateFullSid(RootDomainSid,
                                DOMAIN_GROUP_RID_SCHEMA_ADMINS,
                                SchemaAdminsSid
                                );
    if (ERROR_SUCCESS != WinError) {
        goto Error;
    }


Error:

    if (NULL != DnsDomainInfo)
        LsaFreeMemory( DnsDomainInfo );

    if (NULL != LsaPolicyHandle)
        LsaClose( LsaPolicyHandle ); 

    if (NULL != RootDomainSid)
        AdpFree( RootDomainSid );

    return( WinError );

}



ULONG
AdpCheckGroupMembership(
    BOOLEAN fForestUpdate,
    BOOLEAN fDomainUpdate,
    BOOLEAN *pPermissionGranted,
    ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description:

    this routine checks the logon user group membership. 
    for /forestprep, the logon user has to be a member of 
        root domain Enterprise Admins Group
        root domain Schema Admins Group
        local domain Domain Admins Group
    for /domainprep, the logon user has to be a member of 
        local domain Domain Ammins Group

--*/

{
    ULONG           WinError = ERROR_SUCCESS;
    BOOL            Result; 
    HANDLE          AccessToken = INVALID_HANDLE_VALUE;
    PTOKEN_GROUPS   ClientTokenGroups = NULL;   
    DWORD           ReturnLength = 0, i = 0;
    BOOLEAN         fMemberOfDomainAdmins = FALSE;
    BOOLEAN         fMemberOfEnterpriseAdmins = FALSE;
    BOOLEAN         fMemberOfSchemaAdmins = FALSE;
    PSID            DomainAdminsSid = NULL;
    PSID            EnterpriseAdminsSid = NULL;
    PSID            SchemaAdminsSid = NULL;
    PWCHAR          DomainDnsName = NULL;

    
    //
    // Set return value
    // 
    *pPermissionGranted = FALSE;


    // 
    // get DomainAdminsSid, EnterpriseAdminsSid, 
    //     SchemaAdminsSid and local DomainDnsName.
    //

    WinError = AdpGetWellKnownGroupSids(&DomainAdminsSid,
                                        &EnterpriseAdminsSid,
                                        &SchemaAdminsSid,
                                        &DomainDnsName
                                        );


    if (ERROR_SUCCESS == WinError)
    {
        if( OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &AccessToken) )
        {
            //
            // first call with NULL buffer to calculate the output buffer length
            //
            Result = GetTokenInformation(AccessToken, 
                                         TokenGroups,
                                         NULL,
                                         0,
                                         &ReturnLength
                                         );

            if ( !Result && (ReturnLength > 0) )
            {
                ClientTokenGroups = AdpAlloc( ReturnLength );
                if (NULL != ClientTokenGroups)
                {
                    // get tokeGroups information
                    Result = GetTokenInformation(AccessToken,
                                                 TokenGroups,
                                                 ClientTokenGroups,
                                                 ReturnLength,
                                                 &ReturnLength
                                                 );

                    if ( Result )
                    {
                        // walk through tokenGroups, examine group membership
                        for (i = 0; i < ClientTokenGroups->GroupCount; i++ )
                        {
                            if (EqualSid(ClientTokenGroups->Groups[i].Sid, 
                                         DomainAdminsSid)) 
                            {
                                fMemberOfDomainAdmins = TRUE;
                            }
                            else if (EqualSid(ClientTokenGroups->Groups[i].Sid, 
                                              EnterpriseAdminsSid)) 
                            {
                                fMemberOfEnterpriseAdmins = TRUE;
                            }
                            else if (EqualSid(ClientTokenGroups->Groups[i].Sid, 
                                              SchemaAdminsSid)) 
                            {
                                fMemberOfSchemaAdmins = TRUE;
                            }
                        }

                        if (fForestUpdate)
                        {
                            // for ForestPrep, the user needs to be a member of
                            // Domain Admins Group
                            // Enterprise Admins Group and 
                            // Schema Admins Group
                            if (fMemberOfDomainAdmins &&
                                fMemberOfEnterpriseAdmins && 
                                fMemberOfSchemaAdmins)
                            {
                                *pPermissionGranted = TRUE;
                            }
                        }
                        else
                        {
                            // DomainPrep, the user needs to be a member of 
                            // Domain Admins Group
                            ASSERT( TRUE == fDomainUpdate );
                            if (fMemberOfDomainAdmins)
                            {
                                *pPermissionGranted = TRUE;
                            }
                        }
                    }
                    else {
                        // GetTokenInformation failed
                        WinError = GetLastError();
                    }
                }
                else {
                    WinError = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else {
                // first GetTokenInformation failed and ReturnLength is 0
                WinError = GetLastError();
            }
        }
        else {
            // failed to get process token
            WinError = GetLastError();
        }
    }


    //
    // Clean up and log message
    // 

    // note: log file has not been created yet at this moment.
    if (ERROR_SUCCESS != WinError)
    {
        // failed
        AdpSetWinError( WinError, ErrorHandle );
        AdpLogErrMsg(ADP_DONT_WRITE_TO_LOG_FILE,
                     ADP_ERROR_CHECK_USER_GROUPMEMBERSHIP,
                     ErrorHandle,
                     NULL,
                     NULL
                     );
    }
    else if ( !(*pPermissionGranted) )
    {
        // succeeded, but permission is not granted

        AdpLogMissingGroups(fDomainUpdate,
                            fForestUpdate, 
                            fMemberOfDomainAdmins, 
                            fMemberOfEnterpriseAdmins,
                            fMemberOfSchemaAdmins,
                            DomainDnsName
                            );
    }

    if (INVALID_HANDLE_VALUE != AccessToken) 
        CloseHandle( AccessToken );

    if (NULL != ClientTokenGroups)
        AdpFree( ClientTokenGroups );

    if (NULL != DomainAdminsSid)
        AdpFree( DomainAdminsSid );

    if (NULL != EnterpriseAdminsSid)
        AdpFree( EnterpriseAdminsSid );
    
    if (NULL != SchemaAdminsSid)
        AdpFree( SchemaAdminsSid );

    if (NULL != DomainDnsName)
        AdpFree( DomainDnsName );


    return( WinError );

}





BOOL
AdpCheckConsoleCtrlEvent(
    VOID
    )
/*++
Routine Description:

    This routine checks if Console CTRL event has been received or not.

Parameter:
    None
    
Return Value:
    TRUE - Console CTRL event has been received
    FALSE - not yet

--*/
{
    BOOL result = FALSE;

    __try 
    {
        EnterCriticalSection( &gConsoleCtrlEventLock );

        result = gConsoleCtrlEventReceived;

    }
    __finally
    {
        LeaveCriticalSection( &gConsoleCtrlEventLock );
    }

    return( result );
}


VOID
AdpSetConsoleCtrlEvent(
    VOID
    )
/*++
Routine Description:

    This routine processes user's CTRL+C / CTRL+BREAK .. input

Parameter:
    None
    
Return Value:
    None    

--*/
{
    __try 
    {
        EnterCriticalSection( &gConsoleCtrlEventLock );

        gConsoleCtrlEventReceived = TRUE;

    }
    __finally
    {
        LeaveCriticalSection( &gConsoleCtrlEventLock );
    }

}


BOOL
WINAPI
ConsoleCtrlHandler(DWORD Event)
/*++
Routine Description:

   Console Control Handler. 

Arguments:
   Event  -- Type of Event to respond to.

Return Value:
   TRUE for success - means the signal has been handled
   FALSE - signal has NOT been handled, the process default HandlerRoutine will
           will be notified next 

--*/
{

    switch (Event)
    {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
    default:
        AdpSetConsoleCtrlEvent();
        break;
    }

    return( TRUE );
}



ULONG
AdpInitLogFile(
    ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    initialize log file
    
Parameters:

    ErrorHandle - pointer to error handle

Return Value:

    Win32 error code

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    WCHAR   SystemPath[MAX_PATH + 1];
    SYSTEMTIME  CurrentTime;
    ULONG   Length = 0;


    //
    // construct log folder path
    // %SystemRoot%\system32\debug\adprep\logs\YYYYMMDDHHMMSS
    //

    if (!GetSystemDirectoryW(SystemPath, MAX_PATH+1))
    {
        WinError = GetLastError();
        goto Error;
    }

    GetLocalTime(&CurrentTime);

    Length = (wcslen(SystemPath) + wcslen(ADP_LOG_DIRECTORY) + 14 + 1) * sizeof(WCHAR);
    gLogPath = AdpAlloc( Length );
    if (NULL == gLogPath)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }


    //
    // create log folder and set it to current directory
    // 

    swprintf(gLogPath, L"%s%s", SystemPath, ADP_LOG_DIR_PART1);
    if (CreateDirectoryW(gLogPath, NULL) ||
        ERROR_ALREADY_EXISTS == (WinError = GetLastError()))
    {
        wcscat(gLogPath, ADP_LOG_DIR_PART2);
        if (CreateDirectoryW(gLogPath, NULL) ||
            ERROR_ALREADY_EXISTS == (WinError = GetLastError()))
        {
            wcscat(gLogPath, ADP_LOG_DIR_PART3);
            if (CreateDirectoryW(gLogPath, NULL) ||
                ERROR_ALREADY_EXISTS == (WinError = GetLastError()))
            {
                memset(gLogPath, 0, Length);

                swprintf(gLogPath, L"%s%s%.4d%.2d%.2d%.2d%.2d%.2d",
                         SystemPath, 
                         ADP_LOG_DIRECTORY,
                         CurrentTime.wYear,
                         CurrentTime.wMonth,
                         CurrentTime.wDay,
                         CurrentTime.wHour,
                         CurrentTime.wMinute,
                         CurrentTime.wSecond
                         );

                if (CreateDirectoryW(gLogPath, NULL) ||
                    ERROR_ALREADY_EXISTS == (WinError = GetLastError()))
                {
                    WinError = ERROR_SUCCESS;
                    SetCurrentDirectoryW(gLogPath);

                    //
                    // open adprep.log file with write permission
                    // gLogFile is a globle file handle 
                    // 
                    gLogFile = _wfopen( ADP_LOG_FILE_NAME, L"w" );    

                    if (NULL == gLogFile)
                    {
                        WinError = GetLastError();
                    }
                }
            }
        }
    }


Error:

    if (ERROR_SUCCESS != WinError)
    {
        // failed
        AdpSetWinError( WinError, ErrorHandle );

        AdpLogErrMsg(ADP_DONT_WRITE_TO_LOG_FILE,
                     ADP_ERROR_CREATE_LOG_FILE,
                     ErrorHandle,
                     ADP_LOG_FILE_NAME,      // log file name
                     NULL
                     );

    }
    else
    {
        // succeeded
        AdpLogMsg(0,
                  ADP_INFO_CREATE_LOG_FILE,
                  ADP_LOG_FILE_NAME,      // log file name
                  gLogPath                // log file path
                  );

    }

    return( WinError );
}

VOID
AdpGenerateCompressedName(
    LPWSTR FileName,
    LPWSTR CompressedName
    )
/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

    Look backwards for a dot.  If there is no dot, append "._" to the name.
    If there is a dot followed by 0, 1, or 2 charcaters, append "_".
    Otherwise assume there is a 3-character extension and replace the
    third character after the dot with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

    CompressedName - receives compressed form. This routine assumes
        that this buffer is MAX_PATH TCHARs in size.

Return Value:

    None.

--*/

{
    LPTSTR p,q;

    //
    // Leave room for the worst case, namely where there's no extension
    // (and we thus have to append ._).
    //
    wcsncpy(CompressedName,FileName,MAX_PATH-2);

    p = wcsrchr(CompressedName,L'.');
    q = wcsrchr(CompressedName,L'\\');
    if(q < p) {
        //
        // If there are 0, 1, or 2 characters after the dot, just append
        // the underscore. p points to the dot so include that in the length.
        //
        if(wcslen(p) < 4) {
            wcscat(CompressedName,L"_");
        } else {
            //
            // Assume there are 3 characters in the extension and replace
            // the final one with an underscore.
            //
            p[3] = L'_';
        }
    } else {
        //
        // No dot, just add ._.
        //
        wcscat(CompressedName, L"._");
    }
}


ULONG
AdpCopyFileWorker(
    LPWSTR SourcePath,
    LPWSTR TargetPath,
    LPWSTR FileName,
    ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    This routine copies a file from SourcePath to TargetPath, using the FileName
    passed in.

Parameters:

    SourcePath - source files location
    TargetPath
    FileName
    ErrorHandle

Return Value:

    Win32 error code

--*/
{
    ULONG       WinError = ERROR_SUCCESS;
    WCHAR       SourceName[MAX_PATH + 1];
    WCHAR       ActualSourceName[MAX_PATH + 1];
    WCHAR       TargetName[MAX_PATH + 1];
    HANDLE      FindHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA     FindData;
    BOOL        FileNotFound = FALSE;

    if ((MAX_PATH < (wcslen(SourcePath) + wcslen(FileName) + 1)) || 
        (MAX_PATH < (wcslen(TargetPath) + wcslen(FileName) + 1)) )
    {
        return( ERROR_BAD_PATHNAME );
    }

    // create the source file name
    memset(SourceName, 0, (MAX_PATH+1) * sizeof(WCHAR));
    swprintf(SourceName, L"%ls\\%ls", SourcePath, FileName);

    // First check if the uncompressed file is there
    FindHandle = FindFirstFile(SourceName, &FindData);

    if (FindHandle && (FindHandle != INVALID_HANDLE_VALUE)) {
        //
        // Got the file, copy name in ActualSourceName
        //
        FindClose(FindHandle);
        wcscpy(ActualSourceName, SourceName );
    } else {
        //
        // Don't have the file, try the compressed file name
        //
        AdpGenerateCompressedName(SourceName,ActualSourceName);
        FindHandle = FindFirstFile(ActualSourceName, &FindData);
        if (FindHandle && (FindHandle != INVALID_HANDLE_VALUE)) {
            // Got the file. Name is already in ActualSourceName
            FindClose(FindHandle);
        } else {
            FileNotFound = TRUE;
        }
        
    }

    if ( FileNotFound )
    {
        // file is not found
        WinError = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        // O.K. the source file is there, create the target file name
        memset(TargetName, 0, (MAX_PATH + 1) * sizeof(WCHAR));
        swprintf(TargetName, L"%ls\\%ls", TargetPath, FileName);

        // delete any existing file of the same name 
        DeleteFile( TargetName );

        WinError = SetupDecompressOrCopyFile(ActualSourceName, TargetName, 0);
    }

    // log event
    if (ERROR_SUCCESS != WinError)
    {
        AdpSetWinError(WinError, ErrorHandle);
        AdpLogErrMsg(0, ADP_ERROR_COPY_SINGLE_FILE, ErrorHandle, ActualSourceName, TargetPath);
    }
    else
    {
        AdpLogMsg(0, ADP_INFO_COPY_SINGLE_FILE, ActualSourceName, TargetPath); 
    }

    return( WinError );
}



ULONG
AdpGetSchemaVersionOnLocalDC(
    ULONG *LocalDCVersion
    )
/*++

Routine Description:
    Reads a particular registry key

Arguments:
    LocalDCVersion - Pointer to DWORD to return the registry key value in DC

Return:
    Win32 error code

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   RegVersion = 0;
    DWORD   dwType, dwSize;
    HKEY    hKey;

    // Read the "Schema Version" value from NTDS config section in registry
    // Value is assumed to be 0 if not found
    dwSize = sizeof(RegVersion);
    WinError = RegOpenKey(HKEY_LOCAL_MACHINE, ADP_DSA_CONFIG_SECTION, &hKey);
    if (ERROR_SUCCESS == WinError)
    {
        WinError = RegQueryValueEx(hKey, ADP_SCHEMA_VERSION, NULL, &dwType, (LPBYTE) &RegVersion, &dwSize);
        RegCloseKey( hKey ); 
    }

    // set return value
    if (ERROR_SUCCESS == WinError)
    {
        *LocalDCVersion = RegVersion;
    }

    return( WinError );
}


VOID
AdpGetSchemaVersionInIniFile(
    IN LPWSTR IniFileName, 
    OUT DWORD *Version
    )

/*++

Routine Decsription:
    Reads the Object-Version key in the SCHEMA section of the
    given ini file and returns the value in *Version. If the 
    key cannot be read, 0 is returned in *Version

Arguments:
    IniFileName - Pointer to null-terminated inifile name
    Version - Pointer to DWORD to return version in

Return Value:
    None 

--*/
   
{
    WCHAR   Buffer[32];
    BOOL    fFound = FALSE;

    LPWSTR SCHEMASECTION = L"SCHEMA";
    LPWSTR OBJECTVER = L"objectVersion";
    LPWSTR DEFAULT = L"NOT_FOUND";

    *Version = 0;

    GetPrivateProfileStringW(
        SCHEMASECTION,
        OBJECTVER,
        DEFAULT,
        Buffer,
        sizeof(Buffer)/sizeof(WCHAR),
        IniFileName
        );

    if ( _wcsicmp(Buffer, DEFAULT) ) 
    {
         // Not the default string "NOT_FOUND", so got a value
         *Version = _wtoi(Buffer);
         fFound = TRUE;
    }

    ASSERT( fFound && L"can't get objectVersion from schema.ini\n");
}




ULONG
AdpCopySchemaFiles(
    LPWSTR WindowsPath,
    LPWSTR SystemPath,
    LPWSTR SourcePath,
    ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    Copy schema files from installation media (setup CD or network share) 
    to local machine
    
Parameters:

    SourcePath - source files location
    ErrorHandle - pointer to error handle

Return Value:

    Win32 error code

--*/
{
    ULONG       WinError = ERROR_SUCCESS;
    ULONG       LocalDCSchemaVersion = 0;
    ULONG       IniFileSchemaVersion = 0;  
    ULONG       i = 0;
    WCHAR       IniFileName[MAX_PATH + 1];
    WCHAR       FileName[MAX_PATH + 1];
    WCHAR       IniVerStr[32], RegVerStr[32], TempStr[32];


    if ( MAX_PATH < (wcslen(WindowsPath) + wcslen(ADP_SCHEMA_INI_FILE_NAME) + 1) ) 
    {
        return( ERROR_BAD_PATHNAME );
    }

    // copy schema.ini to %windir% directory 
    WinError = AdpCopyFileWorker(SourcePath, WindowsPath, ADP_SCHEMA_INI_FILE_NAME, ErrorHandle);

    if (ERROR_SUCCESS == WinError)
    {
        // get local DC schema version from registry
        WinError = AdpGetSchemaVersionOnLocalDC( &LocalDCSchemaVersion );

        if (ERROR_SUCCESS == WinError)
        {
            // get schema version from schema.ini file
            memset(IniFileName, 0, (MAX_PATH + 1) * sizeof(WCHAR));
            swprintf(IniFileName, L"%ls\\%ls", WindowsPath, ADP_SCHEMA_INI_FILE_NAME);
            AdpGetSchemaVersionInIniFile(IniFileName, &IniFileSchemaVersion);

            // copy all files from version on DC to latest version
            for (i = LocalDCSchemaVersion + 1; i <= IniFileSchemaVersion; i ++)
            {
                _itow(i, TempStr, 10);
                memset(FileName, 0, (MAX_PATH + 1) * sizeof(WCHAR));
                swprintf(FileName, L"%ls%ls%ls", L"sch", TempStr, L".ldf");
                WinError = AdpCopyFileWorker(SourcePath, SystemPath, FileName, ErrorHandle);
                if (ERROR_SUCCESS != WinError)
                {
                    break;
                }
            }
        }
    }

    return( WinError );
}


ULONG
AdpCopyDataFiles(
    LPWSTR SystemPath,
    LPWSTR SourcePath,
    ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    Copy adprep.exe related data files from installation media (setup CD or network share) 
    to local machine
    
Parameters:

    SourcePath - source files location
    ErrorHandle - pointer to error handle

Return Value:

    Win32 error code

--*/
{
    ULONG       WinError = ERROR_SUCCESS;
    WCHAR       TargetPath[MAX_PATH + 1];

    if ( MAX_PATH < (wcslen(SystemPath) + wcslen(ADP_DATA_DIRECTORY) + 1) )
    {
        return( ERROR_BAD_PATHNAME );
    }
    //
    // construct data folder path
    // %SystemRoot%\system32\debug\adprep\data
    // 
    memset(TargetPath, 0, (MAX_PATH + 1) * sizeof(WCHAR));
    swprintf(TargetPath, L"%ls%ls", SystemPath, ADP_DATA_DIRECTORY);

    // create data directory first
    if (CreateDirectoryW(TargetPath, NULL) ||
        ERROR_ALREADY_EXISTS == (WinError = GetLastError()))
    {
        // copy dcpromo.csv file 
        WinError = AdpCopyFileWorker(SourcePath, TargetPath, ADP_DISP_DCPROMO_CSV, ErrorHandle);

        if (ERROR_SUCCESS == WinError)
        {
            // copy 409.csv file
            WinError = AdpCopyFileWorker(SourcePath, TargetPath, ADP_DISP_409_CSV, ErrorHandle);
        }
    }

    return( WinError );
}



ULONG
AdpCopyFiles(
    BOOLEAN fForestUpdate,
    ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    Copy files from installation media (setup CD or network share) to local machine
    
Parameters:

    ErrorHandle - pointer to error handle

Return Value:

    Win32 error code

--*/
{
    ULONG       WinError = ERROR_SUCCESS;
    WCHAR       SourcePath[MAX_PATH + 1];
    WCHAR       SystemPath[MAX_PATH + 1];
    WCHAR       WindowsPath[MAX_PATH + 1];
    LPWSTR      Pos = NULL;

    // 
    // first, get source files location, they should be in the same directory 
    // as adprep.exe 
    // 
    memset(SourcePath, 0, (MAX_PATH + 1) * sizeof(WCHAR));
    if ( GetModuleFileName(NULL, SourcePath, MAX_PATH + 1) && 
         (Pos = wcsrchr(SourcePath, L'\\')) )
    {
        // remove the trailing '\' - backslash
        *Pos = 0;

        // get Windows Directory Path
        memset(WindowsPath, 0, (MAX_PATH + 1) * sizeof(WCHAR));
        if ( GetWindowsDirectoryW(WindowsPath, MAX_PATH + 1) )
        {
            // get System Directory Path
            memset(SystemPath, 0, (MAX_PATH + 1) * sizeof(WCHAR));
            if ( GetSystemDirectoryW(SystemPath, MAX_PATH + 1) )
            {
                // copy schema files 
                WinError = AdpCopySchemaFiles(WindowsPath, SystemPath, SourcePath, ErrorHandle);

                if (ERROR_SUCCESS == WinError && fForestUpdate) 
                {
                    // copy adprep related files (ONLY IN FORESTPREP case)
                    WinError = AdpCopyDataFiles(SystemPath, SourcePath, ErrorHandle);
                }
            }
            else 
            {
                WinError = GetLastError();
            }
        }
        else 
        {
            WinError = GetLastError();
        }
    }
    else 
    {
        WinError = GetLastError();
    }

    if (ERROR_SUCCESS != WinError)
    {
        AdpSetWinError(WinError, ErrorHandle);
        AdpLogErrMsg(0, ADP_ERROR_COPY_FILES, ErrorHandle, NULL, NULL);
    }
    
    return( WinError );
}



ULONG
AdpMakeLdapConnectionToLocalComputer(
    ERROR_HANDLE *ErrorHandle
    )
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    WCHAR   ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];


    //
    // get local computer NetBios name
    // 
    memset(ComputerName, 0, sizeof(WCHAR) * ComputerNameLength);
    if (FALSE == GetComputerNameW (ComputerName, &ComputerNameLength))
    {
        WinError = GetLastError();
        AdpSetWinError(WinError, ErrorHandle);
        AdpLogErrMsg(0, ADP_ERROR_GET_COMPUTERNAME, ErrorHandle, NULL, NULL);
        return( WinError );
    }

    //
    // make ldap connection and bind as current logged on user
    // 
    WinError = AdpMakeLdapConnection(&gLdapHandle, ComputerName, ErrorHandle);

    //
    // log error or success message since AdpMakeLdapConnection is part of adpcheck.lib
    // 
    if (ERROR_SUCCESS != WinError)
    {
        AdpLogErrMsg(0, ADP_ERROR_MAKE_LDAP_CONNECTION, ErrorHandle, ComputerName, NULL);
    }
    else
    {
        AdpLogMsg(0, ADP_INFO_MAKE_LDAP_CONNECTION, ComputerName, NULL);
    }

    return( WinError );
}




ULONG
AdpGetRootDSEInfo(
    LDAP *LdapHandle,
    ERROR_HANDLE    *ErrorHandle
    )
/*++

Routine Description:

    this rouinte reads root DSE object and retrieves / initializes global variables

Parameters:

    LdapHandle - ldap handle
    
    ErrorHandle - error handle (used to return error message)
    
Return Values;

    Win32 error code

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   LdapError = LDAP_SUCCESS;
    PWCHAR  Attrs[4];
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    

    Attrs[0] = L"defaultNamingContext";
    Attrs[1] = L"configurationNamingContext";
    Attrs[2] = L"schemaNamingContext";
    Attrs[3] = NULL;

    //
    // get forest root domain NC
    // 
    AdpTraceLdapApiStart(0, ADP_INFO_LDAP_SEARCH, NULL);
    LdapError = ldap_search_sW(LdapHandle,
                               L"", // root DSE object
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               Attrs,
                               0,
                               &Result
                               );
    AdpTraceLdapApiEnd(0, L"ldap_search_s()", LdapError);

    if (LDAP_SUCCESS != LdapError)
    {
        goto Error;
    }

    if ((NULL != Result) &&
        (Entry = ldap_first_entry(LdapHandle, Result)) 
        )
    {
        PWCHAR  *pTemp = NULL;

        pTemp = ldap_get_valuesW(LdapHandle,
                                 Entry,
                                 L"defaultNamingContext"
                                 );
        if (NULL != pTemp)
        {
            gDomainNC = AdpAlloc((wcslen(*pTemp) + 1) * sizeof(WCHAR));
            if (NULL != gDomainNC) 
            {
                wcscpy(gDomainNC, *pTemp);
            }
            else
            {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }

            ldap_value_freeW(pTemp);

        }
        else
        {
            // can't retrieve such attribute, must be access denied error
            WinError = ERROR_ACCESS_DENIED;
            goto Error;
        }

        pTemp = NULL;
        pTemp = ldap_get_valuesW(LdapHandle,
                                 Entry,
                                 L"configurationNamingContext"
                                 );

        if (NULL != pTemp)
        {
            gConfigurationNC = AdpAlloc((wcslen(*pTemp) + 1) * sizeof(WCHAR));
            if (NULL != gConfigurationNC) 
            {
                wcscpy(gConfigurationNC, *pTemp);
            }
            else
            {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }

            ldap_value_freeW(pTemp);
        }
        else
        {
            // can't retrieve such attribute, must be access denied error
            WinError = ERROR_ACCESS_DENIED;
            goto Error;
        }

        pTemp = NULL;
        pTemp = ldap_get_valuesW(LdapHandle,
                                 Entry,
                                 L"schemaNamingContext"
                                 );
        if (NULL != pTemp)
        {
            gSchemaNC = AdpAlloc((wcslen(*pTemp) + 1) * sizeof(WCHAR));
            if (NULL != gSchemaNC) 
            {
                wcscpy(gSchemaNC, *pTemp);
            }
            else
            {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }

            ldap_value_freeW(pTemp);
        }
        else
        {
            // can't retrieve such attribute, must be access denied error
            WinError = ERROR_ACCESS_DENIED;
            goto Error;
        }

    }
    else
    {
        LdapError = LdapGetLastError();
        goto Error;
    }




Error:

    // 
    // check LdapError first, then WinError
    // 
    if (LDAP_SUCCESS != LdapError)
    {
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle); 
        WinError = LdapMapErrorToWin32( LdapError );
    }
    else if (ERROR_SUCCESS != WinError)
    {
        AdpSetWinError(WinError, ErrorHandle);
    }

    if (ERROR_SUCCESS != WinError)
    {
        AdpLogErrMsg(0, ADP_ERROR_GET_ROOT_DSE_INFO, ErrorHandle, NULL, NULL);
    }
    else
    {
        AdpLogMsg(0, ADP_INFO_GET_ROOT_DSE_INFO, NULL, NULL);
    }
    
    if (Result)
    {
        ldap_msgfree(Result);
    }

    return( WinError );
}


ULONG
AdpInitGlobalVariables(
    OUT ERROR_HANDLE *ErrorHandle
    )
{
    ULONG   WinError = ERROR_SUCCESS;


    //
    // initialize well known DN(s) (such as DomainUpdates / ForestUpdates Containers
    // 

    ASSERT(NULL != gDomainNC);
    gDomainPrepOperations = AdpAlloc( (wcslen(gDomainNC) + 
                                       wcslen(L"cn=Operations,cn=DomainUpdates,cn=System") +
                                       2) * sizeof(WCHAR)
                                       );
    if (NULL != gDomainPrepOperations)
    {
        swprintf(gDomainPrepOperations,
                 L"%s,%s",
                 L"cn=Operations,cn=DomainUpdates,cn=System",
                 gDomainNC
                 );
    }
    else
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }


    ASSERT(NULL != gConfigurationNC);
    gForestPrepOperations = AdpAlloc( (wcslen(gConfigurationNC) +
                                       wcslen(L"cn=Operations,cn=ForestUpdates") +
                                       2) * sizeof(WCHAR)
                                      );

    if (NULL != gForestPrepOperations)
    {
        swprintf(gForestPrepOperations, 
                 L"%s,%s",
                 L"cn=Operations,cn=ForestUpdates",
                 gConfigurationNC
                 );
    }
    else
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

Error:

    if (ERROR_SUCCESS != WinError)
    {
        AdpSetWinError(WinError, ErrorHandle);
        AdpLogErrMsg(0, ADP_ERROR_INIT_GLOBAL_VARIABLES, ErrorHandle, NULL, NULL);
    }
    else
    {
        AdpLogMsg(0, ADP_INFO_INIT_GLOBAL_VARIABLES, NULL, NULL);
    }

    return( WinError );
}


VOID
AdpCleanUp(
    VOID
    )
/*++

Routine Description:

    this rouinte cleans up all global variables

Parameters:

    NONE
    
Return Values;

    NONE

--*/
{
    if (gDomainNC)
        AdpFree(gDomainNC);

    if (gConfigurationNC)
        AdpFree(gConfigurationNC);

    if (gSchemaNC)
        AdpFree(gSchemaNC);

    if (gDomainPrepOperations)
        AdpFree(gDomainPrepOperations);

    if (gForestPrepOperations)
        AdpFree(gForestPrepOperations);

    if (gLogPath)
        AdpFree(gLogPath);

    if (NULL != gLogFile)
        fclose( gLogFile );

    if (gLdapHandle)
        ldap_unbind_s( gLdapHandle );

    if (NULL != gMutex)
        CloseHandle( gMutex );

    if (gConsoleCtrlEventLockInitialized)
        DeleteCriticalSection( &gConsoleCtrlEventLock );

}




ULONG
AdpCreateContainerByDn(
    LDAP    *LdapHandle, 
    PWCHAR  ObjDn,
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    creats a container object using the ObjDn passed in

Parameters:

    LdapHandle - ldap handle    
    
    ObjDn - Object Dn
    
    ErrorHandle - Error handle
    
Return Values;

    win32 code

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   LdapError = LDAP_SUCCESS;
    LDAPModW *Attrs[2];
    LDAPModW Attr;
    PWCHAR  Pointers[2];

    Attr.mod_op = LDAP_MOD_ADD;
    Attr.mod_type = L"objectClass";
    Attr.mod_values = Pointers;
    Attr.mod_values[0] = L"container";
    Attr.mod_values[1] = NULL;

    Attrs[0] = &Attr;
    Attrs[1] = NULL;

    AdpTraceLdapApiStart(0, ADP_INFO_LDAP_ADD, ObjDn);
    LdapError = ldap_add_sW(LdapHandle,
                            ObjDn,
                            &Attrs[0]
                            );
    AdpTraceLdapApiEnd(0, L"ldap_add_s()", LdapError);

    if (LDAP_SUCCESS == LdapError)
    {
        AdpLogMsg(0, ADP_INFO_CREATE_OBJECT, ObjDn, NULL);
    }
    else if (LDAP_ALREADY_EXISTS == LdapError)
    {
        AdpLogMsg(0,ADP_INFO_OBJECT_ALREADY_EXISTS, ObjDn, NULL);
    }
    else
    {
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
        AdpLogErrMsg(0, ADP_ERROR_CREATE_OBJECT, ErrorHandle, ObjDn, NULL);
        WinError = LdapMapErrorToWin32( LdapError );
    }

    return( WinError );
}




ULONG
AdpDoForestUpgrade(
    BOOLEAN fSuppressSP2Warning,
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    Upgrade Forest wide information if necessary

Parameters:

    fSuppressSP2Warning - indicate whether we should display SP2 warning or not

    ErrorHandle
    
Return Values;

    win32 code

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    BOOLEAN fIsFinishedLocally = FALSE,
            fIsFinishedOnSchemaMaster = FALSE,
            fAmISchemaMaster = FALSE,
            fIsSchemaUpgradedLocally = FALSE,
            fIsSchemaUpgradedOnSchemaMaster = FALSE;
    PWCHAR  pSchemaMasterDnsHostName = NULL;
    PWCHAR  OperationDn = NULL;
    PWCHAR  pForestUpdateObject = NULL;
    ULONG   Index = 0;
    ULONG   OriginalKeyValue = 0;
    BOOL    OriginalKeyValueStored = FALSE;
    WCHAR   wc = 0;
    int     result = 0;
     

    if ( !fSuppressSP2Warning )
    {
        //
        // print warning (all DCs need to be upgrade to Windows2000 SP2 and above)
        // 
        AdpLogMsg(ADP_STD_OUTPUT, ADP_INFO_FOREST_UPGRADE_REQUIRE_SP2, NULL, NULL);

        result = wscanf( L"%lc", &wc );
        if ( (result <= 0) || (wc != L'c' && wc != L'C') )
        {
            // operation is canceled by user
            WinError = ERROR_CANCELLED;
            AdpSetWinError(WinError, ErrorHandle);
            AdpLogErrMsg(0, ADP_INFO_FOREST_UPGRADE_CANCELED, ErrorHandle, NULL, NULL);

            return( WinError );
        }
    }

    //
    // check forest upgrade status
    //
    WinError = AdpCheckForestUpgradeStatus(gLdapHandle,
                                           &pSchemaMasterDnsHostName, 
                                           &fAmISchemaMaster, 
                                           &fIsFinishedLocally, 
                                           &fIsFinishedOnSchemaMaster, 
                                           &fIsSchemaUpgradedLocally, 
                                           &fIsSchemaUpgradedOnSchemaMaster, 
                                           ErrorHandle
                                           );
    if (ERROR_SUCCESS != WinError)
    {
        AdpLogErrMsg(0, ADP_ERROR_CHECK_FOREST_UPDATE_STATUS, ErrorHandle, NULL, NULL);
        return( WinError );
    }

    if (fIsFinishedLocally && fIsSchemaUpgradedLocally)
    {
        //
        // Both adprep and schupgr are Done. Don't need to do anything. leave now
        // 
        AdpLogMsg(ADP_STD_OUTPUT, ADP_INFO_FOREST_UPDATE_ALREADY_DONE, NULL, NULL);

        AdpFree( pSchemaMasterDnsHostName );

        return( WinError );     // ERROR_SUCCESS
    }
    else if (!fAmISchemaMaster)
    {
        if (fIsFinishedOnSchemaMaster && fIsSchemaUpgradedOnSchemaMaster)
        {
            //
            // local DC is not Schema Master, but everything is done on Schema Master
            // let client wait the replication happens
            // 
            AdpLogMsg(ADP_STD_OUTPUT, ADP_INFO_FOREST_UPDATE_WAIT_REPLICATION, 
                      pSchemaMasterDnsHostName,NULL );
        } 
        else 
        {
            //
            // client needs to run this tool on Schema Master
            // 
            AdpLogMsg(ADP_STD_OUTPUT, 
                      ADP_INFO_FOREST_UPDATE_RUN_ON_SCHEMA_ROLE_OWNER,
                      pSchemaMasterDnsHostName,
                      pSchemaMasterDnsHostName
                      );
        }

        AdpFree( pSchemaMasterDnsHostName );

        return( WinError );     // ERROR_SUCCESS
    }

    //
    // get original value of registry key "Schema Update Allowed"
    // return error will be ignored
    //
    if (ERROR_SUCCESS == AdpGetRegistryKeyValue(&OriginalKeyValue, ErrorHandle) )
        OriginalKeyValueStored = TRUE;
        

    // 
    // Upgrade Schema if necessary
    // 
    if (!fIsSchemaUpgradedLocally)
    {
        BOOLEAN     fSFUInstalled = FALSE;

        // detect whether MS Windows Services for UNIX (SFU) is installed or not

        WinError = AdpDetectSFUInstallation(gLdapHandle, &fSFUInstalled, ErrorHandle);

        if (ERROR_SUCCESS != WinError) 
        {
            // failed to detect SFU installation, report error and exit
            goto Error;
        }


        if ( fSFUInstalled )
        {
            // detect that conflict SFU is installed. instruct client to apply hotfix 
            AdpLogMsg(ADP_STD_OUTPUT, ADP_INFO_SFU_INSTALLED, NULL, NULL);
            return( ERROR_SUCCESS );
        }



        if ( AdpUpgradeSchema( ErrorHandle ) )
        {
            WinError = ERROR_GEN_FAILURE;   
            goto Error;
        }
    }

    //
    // set registry key "schema update allowed" value to 1
    //
    WinError = AdpSetRegistryKeyValue( 1, ErrorHandle );
    if (ERROR_SUCCESS != WinError) 
    {
        goto Error;
    }
     

    //
    // update objects in Configuration or Schema NC  (forest wide info)
    //
    if (!fIsFinishedLocally)
    {
        //
        // Create ForestPrep Containers
        // 
        for (Index = 0; Index < gForestPrepContainersCount; Index++)
        {
            PWCHAR  ContainerDn = NULL;

            // construct DN for containers to be created
            WinError = AdpCreateObjectDn(ADP_OBJNAME_CN | ADP_OBJNAME_CONFIGURATION_NC,
                                         gForestPrepContainers[Index], 
                                         NULL,  // GUID
                                         NULL,  // SID
                                         &ContainerDn,
                                         ErrorHandle
                                         );

            if (ERROR_SUCCESS != WinError)
            {
                goto Error;
            }

            // create container
            WinError = AdpCreateContainerByDn(gLdapHandle, 
                                              ContainerDn, 
                                              ErrorHandle
                                              );

            AdpFree( ContainerDn );
            ContainerDn = NULL;

            if (ERROR_SUCCESS != WinError)
            {
                goto Error;
            }
        }

        // walk through all forestprep operations
        for (Index = 0; Index < gForestOperationTableCount; Index++)
        {
            OPERATION_CODE  OperationCode;
            BOOLEAN         fComplete = FALSE;

            //
            // check if user press CTRL+C or not (check it at the very beginning
            // or each operation)
            //
            if ( AdpCheckConsoleCtrlEvent() )
            {
                // operation is canceled by user
                WinError = ERROR_CANCELLED;
                AdpSetWinError(WinError, ErrorHandle);
                AdpLogErrMsg(0, ADP_INFO_CANCELED, ErrorHandle, NULL, NULL);
                goto Error;
            }

            if (OperationDn)
            {
                AdpFree(OperationDn);
                OperationDn = NULL;
            }

            //
            // constuct operation DN (based on the operation GUID)
            // 
            WinError = AdpCreateObjectDn(ADP_OBJNAME_GUID | ADP_OBJNAME_FOREST_PREP_OP,
                                         NULL,  // CN
                                         gForestOperationTable[Index].OperationGuid,
                                         NULL,  // SID
                                         &OperationDn,
                                         ErrorHandle
                                         );

            if (ERROR_SUCCESS == WinError)
            {
                //
                // check whether the operation is completed or not.
                // 
                WinError = AdpIsOperationComplete(gLdapHandle, 
                                                  OperationDn, 
                                                  &fComplete, 
                                                  ErrorHandle
                                                  );   

                if (ERROR_SUCCESS == WinError)
                {
                    //
                    // Operation Object (with GUID) exists already, skip to next OP
                    // 
                    if ( fComplete )
                    {
                        continue;
                    }

                    OperationCode = gForestOperationTable[Index].OperationCode;
                    WinError = gPrimitiveFuncTable[OperationCode](&(gForestOperationTable[Index]),
                                                                  gForestOperationTable[Index].TaskTable, 
                                                                  ErrorHandle
                                                                  );

                    if ( (ERROR_SUCCESS != WinError) &&
                         (gForestOperationTable[Index].fIgnoreError) &&
                         (gForestOperationTable[Index].ExpectedWinErrorCode == WinError)
                       )
                    {
                        //
                        // if 
                        //    the requested operation failed AND
                        //    this operation is Ignorable (skip-able) AND 
                        //    the expected error code matched:
                        //        expected Win32 error code == actual WinError returned
                        //
                        // clear the error code and continue
                        // write the warning to log file, but not to console
                        //    

                        WinError = ERROR_SUCCESS;
                        AdpClearError( ErrorHandle );
                        AdpLogMsg(0, ADP_INFO_ERROR_IGNORED, OperationDn, NULL); 
                    }

                    if (ERROR_SUCCESS == WinError)
                    {
                        //
                        // operation succeeds, create the operation object by Operation GUID
                        // 
                        WinError = AdpCreateContainerByDn(gLdapHandle, 
                                                          OperationDn, 
                                                          ErrorHandle
                                                          );
                    }
                }
            }

            if (ERROR_SUCCESS != WinError)
            {
                goto Error;
            }
        }

        //
        // no error so far, set the ForestUpdates Object revision to latest value 
        //
        if (ERROR_SUCCESS == WinError)
        {
            // create Windows2002Update container DN
            WinError = AdpCreateObjectDn(ADP_OBJNAME_CN | ADP_OBJNAME_CONFIGURATION_NC, 
                                         ADP_FOREST_UPDATE_CONTAINER_PREFIX,
                                         NULL,  // GUID,
                                         NULL,  // SID
                                         &pForestUpdateObject,
                                         ErrorHandle
                                         );

            if (ERROR_SUCCESS != WinError)
            {
                goto Error;
            }

            // create container
            WinError = AdpCreateContainerByDn(gLdapHandle, 
                                              pForestUpdateObject,
                                              ErrorHandle
                                              );

            if (ERROR_SUCCESS != WinError)
            {
                goto Error;
            }

            // set "revision" attribute to current ForestVersion
            WinError = AdpSetLdapSingleStringValue(gLdapHandle,
                                                   pForestUpdateObject,
                                                   L"revision",
                                                   ADP_FORESTPREP_CURRENT_REVISION_STRING,
                                                   ErrorHandle
                                                   );

            // log this operation
            if (ERROR_SUCCESS != WinError) 
            {
                AdpLogErrMsg(0, 
                             ADP_ERROR_SET_FOREST_UPDATE_REVISION, 
                             ErrorHandle,
                             ADP_FORESTPREP_CURRENT_REVISION_STRING,
                             pForestUpdateObject
                             );
            }
            else 
            {
                AdpLogMsg(0, ADP_INFO_SET_FOREST_UPDATE_REVISION,
                          ADP_FORESTPREP_CURRENT_REVISION_STRING,
                          pForestUpdateObject
                          );
            }
        }
    }


Error:

    // restore registry key setting
    AdpRestoreRegistryKeyValue( OriginalKeyValueStored, OriginalKeyValue, ErrorHandle );

    if (ERROR_SUCCESS != WinError)
    {
        AdpLogMsg(ADP_STD_OUTPUT, ADP_ERROR_FOREST_UPDATE, gLogPath, NULL);
    }
    else
    {
        AdpLogMsg(ADP_STD_OUTPUT, ADP_INFO_FOREST_UPDATE_SUCCESS, NULL, NULL);
    }

    if (OperationDn)
        AdpFree(OperationDn);

    if ( pSchemaMasterDnsHostName )
        AdpFree( pSchemaMasterDnsHostName );

    if (pForestUpdateObject)
        AdpFree( pForestUpdateObject );

    return( WinError );
}

ULONG
AdpDoDomainUpgrade(
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    Upgrade domain wide information if necessary

Parameters:

    ErrorHandle
    
Return Values;

    win32 code

--*/
{

    ULONG   WinError = ERROR_SUCCESS;
    BOOLEAN fIsFinishedLocally = FALSE,
            fIsFinishedOnIM = FALSE,
            fIsFinishedOnSchemaMaster = FALSE,
            fAmIInfrastructureMaster = FALSE,
            fAmISchemaMaster = FALSE,
            fIsSchemaUpgradedLocally = FALSE,
            fIsSchemaUpgradedOnSchemaMaster = FALSE;
    PWCHAR  pSchemaMasterDnsHostName = NULL;
    PWCHAR  pInfrastructureMasterDnsHostName = NULL;
    PWCHAR  pDomainUpdateObject = NULL;
    PWCHAR  ContainerDn = NULL;
    PWCHAR  OperationDn = NULL;
    ULONG   Index = 0;


    //
    // check forest update status, should run after forest udpate is done
    //
    WinError = AdpCheckForestUpgradeStatus(gLdapHandle, 
                                           &pSchemaMasterDnsHostName, 
                                           &fAmISchemaMaster, 
                                           &fIsFinishedLocally, 
                                           &fIsFinishedOnSchemaMaster, 
                                           &fIsSchemaUpgradedLocally, 
                                           &fIsSchemaUpgradedOnSchemaMaster, 
                                           ErrorHandle 
                                           );

    if (ERROR_SUCCESS != WinError)
    {
        AdpLogErrMsg(0,
                     ADP_ERROR_CHECK_FOREST_UPDATE_STATUS,
                     ErrorHandle, 
                     NULL, 
                     NULL
                     );
        return( WinError );
    }


    if (!fIsFinishedLocally || !fIsSchemaUpgradedLocally)
    {
        //
        // Forest update is not executed yet, exit now
        // 
        ASSERT( pSchemaMasterDnsHostName != NULL);
        AdpLogMsg(ADP_STD_OUTPUT,
                  ADP_INFO_NEED_TO_RUN_FOREST_UPDATE_FIRST,
                  pSchemaMasterDnsHostName, 
                  NULL);

        AdpFree( pSchemaMasterDnsHostName );
        return( WinError );         // ERROR_SUCCESS
    }

    AdpFree( pSchemaMasterDnsHostName );
    pSchemaMasterDnsHostName = NULL;

    //
    // check if the local DC is infrastructure master
    // 
    fIsFinishedLocally = FALSE;

    WinError = AdpCheckDomainUpgradeStatus(gLdapHandle, 
                                           &pInfrastructureMasterDnsHostName, 
                                           &fAmIInfrastructureMaster, 
                                           &fIsFinishedLocally, 
                                           &fIsFinishedOnIM, 
                                           ErrorHandle
                                           );

    if (ERROR_SUCCESS != WinError)
    {
        AdpLogErrMsg(ADP_STD_OUTPUT,
                     ADP_ERROR_CHECK_DOMAIN_UPDATE_STATUS,
                     ErrorHandle, 
                     NULL, 
                     NULL
                     );
        return( WinError );
    }

    if (fIsFinishedLocally)
    {
        //
        // Done, nothing needs to be done
        // 
        AdpLogMsg(ADP_STD_OUTPUT, ADP_INFO_DOMAIN_UPDATE_ALREADY_DONE, NULL, NULL);

        AdpFree( pInfrastructureMasterDnsHostName );

        return( WinError );         // ERROR_SUCCESS
    }
    else if (!fAmIInfrastructureMaster)
    {
        if (fIsFinishedOnIM)
        {
            //
            // let client wait
            // 
            AdpLogMsg(ADP_STD_OUTPUT, 
                      ADP_INFO_DOMAIN_UPDATE_WAIT_REPLICATION, 
                      pInfrastructureMasterDnsHostName, 
                      NULL 
                      );
        } 
        else 
        {
            //
            // let client run on FSMORoleOwner
            // 
            AdpLogMsg(ADP_STD_OUTPUT,
                      ADP_INFO_DOMAIN_UPDATE_RUN_ON_INFRASTRUCTURE_ROLE_OWNER,
                      pInfrastructureMasterDnsHostName,
                      pInfrastructureMasterDnsHostName
                      );
        }

        AdpFree( pInfrastructureMasterDnsHostName );

        return( WinError );     // ERROR_SUCCESS
    } 

    if ( NULL != pInfrastructureMasterDnsHostName )
    {
        AdpFree( pInfrastructureMasterDnsHostName );
        pInfrastructureMasterDnsHostName = NULL;
    }



    //
    // create DomainPrep Containers
    // 
    for (Index = 0; Index < gDomainPrepContainersCount; Index++)
    {
        // construct DN for containers to be created
        WinError = AdpCreateObjectDn(ADP_OBJNAME_DOMAIN_NC | ADP_OBJNAME_CN, 
                                     gDomainPrepContainers[Index], 
                                     NULL,  // GUID
                                     NULL,  // SID
                                     &ContainerDn,
                                     ErrorHandle
                                     );

        if (ERROR_SUCCESS != WinError)
        {
            goto Error;
        }

        // create container
        WinError = AdpCreateContainerByDn(gLdapHandle, 
                                          ContainerDn, 
                                          ErrorHandle
                                          );

        AdpFree( ContainerDn );
        ContainerDn = NULL;

        if (ERROR_SUCCESS != WinError)
        {
            goto Error;
        }
    }

    //
    // walk through domain operation table
    // 
    for (Index = 0; Index < gDomainOperationTableCount; Index++)
    {
        OPERATION_CODE  OperationCode;
        BOOLEAN         fComplete = FALSE;

        //
        // check if user press CTRL+C or not (check it at the very beginning
        // or each operation)
        //
        if ( AdpCheckConsoleCtrlEvent() )
        {
            // operation is canceled by user
            WinError = ERROR_CANCELLED;
            AdpSetWinError(WinError, ErrorHandle);
            AdpLogErrMsg(0, ADP_INFO_CANCELED, ErrorHandle, NULL, NULL);
            goto Error;
        }

        if (OperationDn)
        {
            AdpFree(OperationDn);
            OperationDn = NULL;
        }

        //
        // constuct operation DN (based on the operation GUID)
        // 
        WinError = AdpCreateObjectDn(ADP_OBJNAME_GUID | ADP_OBJNAME_DOMAIN_PREP_OP,
                                     NULL,  // CN
                                     gDomainOperationTable[Index].OperationGuid,
                                     NULL,  // SID
                                     &OperationDn,
                                     ErrorHandle
                                     );

        if (ERROR_SUCCESS == WinError)
        {

            //
            // check whether the operation is completed or not.
            // 
            WinError = AdpIsOperationComplete(gLdapHandle,
                                              OperationDn, 
                                              &fComplete, 
                                              ErrorHandle
                                              );   

            if (ERROR_SUCCESS == WinError)
            {
                //
                // Operation Object (with GUID) exists already, skip to next OP
                // 
                if ( fComplete )
                {
                    continue;
                }

                OperationCode = gDomainOperationTable[Index].OperationCode;
                WinError = gPrimitiveFuncTable[OperationCode](&(gDomainOperationTable[Index]),
                                                              gDomainOperationTable[Index].TaskTable, 
                                                              ErrorHandle
                                                              );

                if ( (ERROR_SUCCESS != WinError) &&
                     (gDomainOperationTable[Index].fIgnoreError) &&
                     (gDomainOperationTable[Index].ExpectedWinErrorCode == WinError)
                   )
                {
                    //
                    // if 
                    //    the requested operation failed AND
                    //    this operation is Ignorable (skip-able) AND 
                    //    the expected error code matched:
                    //        expected Win32 error code == actual WinError returned
                    //
                    // clear the error code and continue
                    // write the warning to log files, but not to console
                    //    

                    WinError = ERROR_SUCCESS;
                    AdpClearError( ErrorHandle );
                    AdpLogMsg(0, ADP_INFO_ERROR_IGNORED, OperationDn, NULL); 
                }


                if (ERROR_SUCCESS == WinError)
                {
                    //
                    // operation succeeds, create the operation object by Operation GUID
                    // 
                     WinError = AdpCreateContainerByDn(gLdapHandle, 
                                                       OperationDn, 
                                                       ErrorHandle
                                                       );
                }
            }
        }
        if (ERROR_SUCCESS != WinError)
        {
            goto Error;
        }
    }

    //
    // if still no error, set the DomainUpdates Object revision to latest value 
    //
    if (ERROR_SUCCESS == WinError)
    {

        WinError = AdpCreateObjectDn(ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
                                     ADP_DOMAIN_UPDATE_CONTAINER_PREFIX,
                                     NULL,  // GUID,
                                     NULL,  // SID
                                     &pDomainUpdateObject,
                                     ErrorHandle
                                     );

        if (ERROR_SUCCESS != WinError)
        {
            goto Error;
        }

        // create container
        WinError = AdpCreateContainerByDn(gLdapHandle, 
                                          pDomainUpdateObject,
                                          ErrorHandle
                                          );

        if (ERROR_SUCCESS != WinError)
        {
            goto Error;
        }

        // set "revision" attribute to current DomainVersion
        WinError = AdpSetLdapSingleStringValue(gLdapHandle,
                                               pDomainUpdateObject,
                                               L"revision", 
                                               ADP_DOMAINPREP_CURRENT_REVISION_STRING, 
                                               ErrorHandle 
                                               );

        if (ERROR_SUCCESS != WinError) 
        {
            AdpLogErrMsg(0, 
                         ADP_ERROR_SET_DOMAIN_UPDATE_REVISION, 
                         ErrorHandle, 
                         ADP_DOMAINPREP_CURRENT_REVISION_STRING,
                         pDomainUpdateObject
                         );
        }
        else 
        {
            AdpLogMsg(0, ADP_INFO_SET_DOMAIN_UPDATE_REVISION, 
                      ADP_DOMAINPREP_CURRENT_REVISION_STRING,
                      pDomainUpdateObject
                      );
        }

    }

Error:

    if (ERROR_SUCCESS != WinError)
    {
        AdpLogMsg(ADP_STD_OUTPUT, ADP_ERROR_DOMAIN_UPDATE, gLogPath, NULL);
    }
    else
    {
        AdpLogMsg(ADP_STD_OUTPUT, ADP_INFO_DOMAIN_UPDATE_SUCCESS, NULL, NULL);
    }

    if (ContainerDn)
        AdpFree(ContainerDn);

    if (OperationDn)
        AdpFree(OperationDn);

    if (pDomainUpdateObject)
        AdpFree( pDomainUpdateObject );

    return( WinError );
}




VOID
PrintHelp()
{
    // write help message to console
    AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE, ADP_INFO_HELP_MSG, NULL, NULL);

}


void
__cdecl wmain(
    int     cArgs,
    LPWSTR  *pArgs
    )
/*++

Routine Description:

    adprep.exe entry point

Parameters:

    cArgs - number of arguments

    pArgs - pointers to command line parameters
    
Return Values;

    0 - success
    1 - failed

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ERROR_HANDLE ErrorHandle;
    OSVERSIONINFOEXW osvi;
    BOOLEAN fDomainUpdate = FALSE,
            fForestUpdate = FALSE,
            fNoSPWarning = FALSE,
            fCopyFiles = TRUE,
            fPermissionGranted = FALSE;
    int     i; 
    UINT               Codepage;
                       // ".", "uint in decimal", null
    char               achCodepage[12] = ".OCP";
    
    //
    // Set locale to the default
    //
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
    }
    setlocale(LC_ALL, achCodepage);


    //
    // check passed in parameters
    // 

    if (cArgs <= 1)
    {
        PrintHelp();
        exit( 1 );
    }

    //
    // Parse command options
    // 

    for (i = 1; i < cArgs; i++)
    {
        if ( !_wcsicmp(pArgs[i], L"/DomainPrep") ||
             !_wcsicmp(pArgs[i], L"-DomainPrep") )
        {
            fDomainUpdate = TRUE;
            continue;
        }

        if ( !_wcsicmp(pArgs[i], L"/ForestPrep") ||
             !_wcsicmp(pArgs[i], L"-ForestPrep") )
        {
            fForestUpdate = TRUE;
            continue;
        }

        if ( !_wcsicmp(pArgs[i], L"/noFileCopy") ||
             !_wcsicmp(pArgs[i], L"-noFileCopy") )
        {
            fCopyFiles = FALSE;
            continue;
        }

        if ( !_wcsicmp(pArgs[i], L"/nospwarning") ||
             !_wcsicmp(pArgs[i], L"-nospwarning") )
        {
            fNoSPWarning = TRUE;
            continue;
        }

        PrintHelp();
        exit( 1 );
    }

    if ( !fDomainUpdate && !fForestUpdate )
    {
        PrintHelp();
        exit( 1 );
    }

    if (fDomainUpdate && fForestUpdate)
    {
        AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                  ADP_ERROR_CANT_RUN_BOTH, NULL, NULL );

        exit( 1 );
    }


    //
    // initialize error handle
    //
    memset(&ErrorHandle, 0, sizeof(ErrorHandle));


    //
    // check OS version and product type
    // 
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);

    if (!GetVersionExW((OSVERSIONINFOW*)&osvi))
    {
        // failed to retrieve OS version
        WinError = GetLastError();
        AdpSetWinError(WinError, &ErrorHandle);
        AdpLogErrMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                     ADP_ERROR_CHECK_OS_VERSION,
                     &ErrorHandle,
                     NULL,
                     NULL
                     );
        goto Error;
    }
    else if ((osvi.wProductType != VER_NT_DOMAIN_CONTROLLER) ||  // not a domain controller
             (osvi.dwMajorVersion < 5))    // NT4 or earlier
    {
        AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                  ADP_INFO_INVALID_PLATFORM, 
                  NULL,
                  NULL
                  );
        exit( 1 );
    }
    else if ((osvi.dwMajorVersion == 5) &&
             (osvi.dwMinorVersion == 1) &&
             (osvi.dwBuildNumber <=  3580) )
    {
        // block Pre Whistler (version 5.1) Beta3 upgrade
        AdpLogMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                  ADP_INFO_CANT_UPGRADE_FROM_BETA2,
                  NULL, 
                  NULL 
                  );
        exit( 1 );
    }


    //
    // Check to see if another adprep.exe is running concurrently
    //
    if ( AdpCheckIfAnotherProgramIsRunning() )
    {
        goto Error;
    }


    //
    // Check logon user's permission
    //
    WinError = AdpCheckGroupMembership(fForestUpdate, 
                                       fDomainUpdate, 
                                       &fPermissionGranted, 
                                       &ErrorHandle
                                       );
    if ( (ERROR_SUCCESS != WinError) || (!fPermissionGranted) )
    {
        goto Error;
    }

    //
    // Set Ctrl+C Handler
    // 
    __try
    {
        InitializeCriticalSection( &gConsoleCtrlEventLock );
        gConsoleCtrlEventLockInitialized = TRUE;
    }
    __except ( 1 )
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        AdpSetWinError(WinError, &ErrorHandle);
        AdpLogErrMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                     ADP_ERROR_SET_CONSOLE_CTRL_HANDLER,
                     &ErrorHandle,
                     NULL,
                     NULL
                     );
        goto Error;
    }

    if ( !SetConsoleCtrlHandler(ConsoleCtrlHandler, 1) )
    {
        WinError = GetLastError();
        AdpSetWinError(WinError, &ErrorHandle);
        AdpLogErrMsg(ADP_STD_OUTPUT | ADP_DONT_WRITE_TO_LOG_FILE,
                     ADP_ERROR_SET_CONSOLE_CTRL_HANDLER,
                     &ErrorHandle,
                     NULL,
                     NULL
                     );
        goto Error;
    }


    //
    // create log files 
    //
    WinError = AdpInitLogFile( &ErrorHandle );
    if ( ERROR_SUCCESS != WinError )
    {
        goto Error;
    }

    //
    // copy files
    //
    if ( fCopyFiles )
    {
        WinError = AdpCopyFiles(fForestUpdate, &ErrorHandle );
        if ( ERROR_SUCCESS != WinError )
        {
            goto Error;
        }
    }

    //
    // now create the ldap connection
    // 
    WinError = AdpMakeLdapConnectionToLocalComputer(&ErrorHandle);
    if (ERROR_SUCCESS != WinError)
    {
        goto Error;
    }


    //
    // get default naming context / configuration NC / schema NC
    // 
    WinError = AdpGetRootDSEInfo( gLdapHandle, &ErrorHandle );  
    if (ERROR_SUCCESS != WinError)
    {
        goto Error;
    }

    //
    // init global variables
    // 
    WinError = AdpInitGlobalVariables(&ErrorHandle);
    if (ERROR_SUCCESS != WinError)
    {
        goto Error;
    }


    //
    // do Forest Prep
    // 
    if ( fForestUpdate )
    {
        WinError = AdpDoForestUpgrade(fNoSPWarning, &ErrorHandle);
    }

    //
    // do domain prep
    // 
    if ( fDomainUpdate )
    {
        ASSERT( FALSE == fForestUpdate );
        WinError = AdpDoDomainUpgrade(&ErrorHandle);
    }

    
Error:

    // cleanup local variables
    AdpClearError( &ErrorHandle );

    // 
    // cleanup global variables
    // 
    AdpCleanUp();
    
    if (ERROR_SUCCESS != WinError)
        exit(1);
    else
        exit(0);
}





ULONG
PrimitiveCreateObject(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    primitive to create an object in DS

Parameters:

    TaskTable
    
    ErrorHandle
    
Return Values;

    Win32 Error

--*/
{
    ULONG       WinError = ERROR_SUCCESS;
    ULONG       LdapError = LDAP_SUCCESS;
    PWCHAR      pObjDn = NULL;
    LDAPModW    **AttrList = NULL;
    ULONG       SdLength = 0;
    PSECURITY_DESCRIPTOR Sd = NULL;


    AdpDbgPrint(("PrimitiveCreateObject\n"));

    //
    // get object DN
    //
    WinError = AdpCreateObjectDn(TaskTable->TargetObjName->ObjNameFlags,
                                 TaskTable->TargetObjName->ObjCn,
                                 TaskTable->TargetObjName->ObjGuid,
                                 TaskTable->TargetObjName->ObjSid,
                                 &pObjDn,
                                 ErrorHandle
                                 );
                                 
    if (ERROR_SUCCESS != WinError)
    {
        return( WinError );
    }

    //
    // convert SDDL SD to SD
    // 
    if (TaskTable->TargetObjectStringSD)
    {
        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                        TaskTable->TargetObjectStringSD,
                        SDDL_REVISION_1,
                        &Sd,
                        &SdLength
                        )
            )
        {
            WinError = GetLastError();
            AdpSetWinError(WinError, ErrorHandle);
            goto Error;
        }
    }

    //
    // build an attribute list to set
    // 

    WinError = BuildAttrList(TaskTable, 
                             Sd,
                             SdLength, 
                             &AttrList
                             );

    if (ERROR_SUCCESS != WinError)
    {
        AdpSetWinError(WinError, ErrorHandle);
        goto Error;
    }

    //
    // call ldap routine
    // 
    AdpTraceLdapApiStart(0, ADP_INFO_LDAP_ADD, pObjDn);
    LdapError = ldap_add_sW(gLdapHandle,
                            pObjDn,
                            AttrList
                            );
    AdpTraceLdapApiEnd(0, L"ldap_add_s()", LdapError);

    if (LDAP_ALREADY_EXISTS == LdapError)
    {
        AdpLogMsg(0, ADP_INFO_OBJECT_ALREADY_EXISTS, pObjDn, NULL);
        LdapError = LDAP_SUCCESS;
    }

    if (LDAP_SUCCESS != LdapError) 
    {
        AdpSetLdapError(gLdapHandle, LdapError, ErrorHandle);
        WinError = LdapMapErrorToWin32( LdapError );
    }

Error:

    if (ERROR_SUCCESS == WinError)
    {
        AdpLogMsg(0, ADP_INFO_CREATE_OBJECT, pObjDn, NULL);
    }
    else
    {
        AdpLogErrMsg(0, ADP_ERROR_CREATE_OBJECT, ErrorHandle, pObjDn, NULL);
    }

    if (Sd)
    {
        LocalFree( Sd );
    }

    if (pObjDn)
    {
        AdpFree( pObjDn );
    }

    if (AttrList)
    {
        FreeAttrList(AttrList);
    }

    return( WinError );
}



ULONG
PrimitiveAddMembers(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    primitive to add members to a group in DS

    // this primitive is not used currently, o.k. to remove

Parameters:

    TaskTable
    
    ErrorHandle
    
Return Values;

    Win32 Error

--*/
{
    ULONG   LdapError = LDAP_SUCCESS;
    ULONG   WinError = ERROR_SUCCESS;
    PWCHAR  pObjDn = NULL;
    PWCHAR  pMemberDn = NULL;
    LDAPModW    *Attrs[2];
    LDAPModW    Attr_1;
    PWCHAR      Pointers[2];


    AdpDbgPrint(("PrimitiveAddMembers\n"));

    //
    // get object / member dn
    //
    WinError = AdpCreateObjectDn(TaskTable->TargetObjName->ObjNameFlags,
                                 TaskTable->TargetObjName->ObjCn,
                                 TaskTable->TargetObjName->ObjGuid,
                                 TaskTable->TargetObjName->ObjSid,
                                 &pObjDn,
                                 ErrorHandle
                                 );

    if (ERROR_SUCCESS != WinError)
    {
        return( WinError );
    }

    WinError = AdpCreateObjectDn(TaskTable->MemberObjName->ObjNameFlags,
                                 TaskTable->MemberObjName->ObjCn,
                                 TaskTable->MemberObjName->ObjGuid,
                                 TaskTable->MemberObjName->ObjSid,
                                 &pObjDn,
                                 ErrorHandle
                                 );

    if (ERROR_SUCCESS != WinError)
    {
        AdpFree(pObjDn);
        return( WinError );
    }

    Attr_1.mod_op = LDAP_MOD_ADD;
    Attr_1.mod_type = L"member";
    Attr_1.mod_values = Pointers;
    Attr_1.mod_values[0] = pMemberDn;
    Attr_1.mod_values[1] = NULL;

    Attrs[0] = &Attr_1;
    Attrs[1] = NULL;

    AdpTraceLdapApiStart(0, ADP_INFO_LDAP_MODIFY, pObjDn);
    LdapError = ldap_modify_sW(gLdapHandle,
                               pObjDn,
                               &Attrs[0]
                               );
    AdpTraceLdapApiEnd(0, L"ldap_modify_s()", LdapError);

    if (LDAP_SUCCESS != LdapError)
    {
        WinError = LdapMapErrorToWin32( LdapError );
        AdpSetLdapError(gLdapHandle, LdapError, ErrorHandle);
        goto Error;
    }
   
Error:

    if (ERROR_SUCCESS == WinError)
    {
        AdpLogMsg(0, ADP_INFO_ADD_MEMBER, pMemberDn, pObjDn); 
    }
    else
    {
        AdpLogErrMsg(0, ADP_ERROR_ADD_MEMBER, ErrorHandle, pMemberDn, pObjDn);
    }

    if (pObjDn)
    {
        AdpFree( pObjDn );
    }

    if (pMemberDn)
    {
        AdpFree( pMemberDn );
    }

    return( WinError );
}



ULONG
PrimitiveAddRemoveAces(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    primitive to add/remove ACEs on an object in DS

Parameters:

    TaskTable
    
    ErrorHandle
    
Return Values;

    Win32 Error

--*/
{
    
    return( AdpAddRemoveAcesWorker(OperationTable, 
                                   0,
                                   TaskTable,
                                   ErrorHandle
                                   ) );

}



ULONG
PrimitiveSelectivelyAddRemoveAces(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    primitive to add/remove ACEs on an object in DS

Parameters:

    TaskTable
    
    ErrorHandle
    
Return Values;

    Win32 Error

--*/
{

    return( AdpAddRemoveAcesWorker(OperationTable,
                                   ADP_COMPARE_OBJECT_GUID_ONLY,
                                   TaskTable,
                                   ErrorHandle
                                   ) );

}




ULONG
PrimitiveModifyDefaultSd(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    primitive to modify default Security Descriptor on schema object

Parameters:

    TaskTable
    
    ErrorHandle
    
Return Values;

    Win32 Error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    PWCHAR  pObjDn = NULL;
    PWCHAR  pDefaultSd = NULL;
    PWCHAR  pMergedDefaultSd = NULL;
    PWCHAR  AcesToAdd = NULL;
    PWCHAR  AcesToRemove = NULL;
    PSECURITY_DESCRIPTOR    OrgSd = NULL,
                            NewSd = NULL,
                            SdToAdd = NULL,
                            SdToRemove = NULL;
    ULONG   NewSdLength = 0,
            OrgSdLength = 0,
            SdToAddLength = 0,
            SdToRemoveLength = 0;


    AdpDbgPrint(("PrimitiveModifyDefaultSd"));

    //
    // get object DN
    // 
    WinError = AdpCreateObjectDn(TaskTable->TargetObjName->ObjNameFlags,
                                 TaskTable->TargetObjName->ObjCn,
                                 TaskTable->TargetObjName->ObjGuid,
                                 TaskTable->TargetObjName->ObjSid,
                                 &pObjDn,
                                 ErrorHandle
                                 );

    if (ERROR_SUCCESS != WinError)
    {
        return( WinError );
    }

    //
    // get object default SD   
    // BUGBUG   should we expect attr doesn't exist?
    //
    WinError = AdpGetLdapSingleStringValue(gLdapHandle,
                                           pObjDn, 
                                           L"defaultSecurityDescriptor",
                                           &pDefaultSd, 
                                           ErrorHandle 
                                           );
    if (ERROR_SUCCESS != WinError)
    {
        goto Error;
    }

    //
    // convert SDDL to binary format SD
    // 
    if (NULL != pDefaultSd)
    {
        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                            pDefaultSd,
                            SDDL_REVISION_1,
                            &OrgSd,
                            &OrgSdLength
                            ))
        {
            WinError = GetLastError();
            AdpSetWinError( WinError, ErrorHandle );
            goto Error;
        }
    }


    if ((TaskTable->NumOfAces == 0) ||
        (TaskTable->AceList == NULL))
    {
        WinError = ERROR_INVALID_PARAMETER;
        AdpSetWinError(WinError, ErrorHandle);
        goto Error;
    }

    WinError = AdpBuildAceList(TaskTable,
                               &AcesToAdd,
                               &AcesToRemove
                               );
    if (ERROR_SUCCESS != WinError)
    {
        AdpSetWinError(WinError, ErrorHandle);
        goto Error;
    }

    if (NULL != AcesToAdd)
    {
        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                            AcesToAdd,
                            SDDL_REVISION_1,
                            &SdToAdd,
                            &SdToAddLength
                            ))

        {
            WinError = GetLastError();
            AdpSetWinError( WinError, ErrorHandle );
            goto Error;
        }
    }

    if (NULL != AcesToRemove)
    {
        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                            AcesToRemove,
                            SDDL_REVISION_1,
                            &SdToRemove,
                            &SdToRemoveLength
                            ))

        {
            WinError = GetLastError();
            AdpSetWinError( WinError, ErrorHandle );
            goto Error;
        }

    }

    WinError = AdpMergeSecurityDescriptors(OrgSd, 
                                           SdToAdd, 
                                           SdToRemove, 
                                           0,  // No flag indicated 
                                           &NewSd, 
                                           &NewSdLength 
                                           );

    if (ERROR_SUCCESS != WinError)
    {
        AdpSetWinError( WinError, ErrorHandle );
        goto Error;
    }

    if (!ConvertSecurityDescriptorToStringSecurityDescriptorW(
                            NewSd,
                            SDDL_REVISION_1,
                            OWNER_SECURITY_INFORMATION | 
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION  |
                                SACL_SECURITY_INFORMATION,
                            &pMergedDefaultSd,
                            NULL
                            ))
    {
        WinError = GetLastError();
        AdpSetWinError( WinError, ErrorHandle );
        goto Error;
    }


    WinError = AdpSetLdapSingleStringValue(gLdapHandle,
                                           pObjDn,
                                           L"defaultSecurityDescriptor",
                                           pMergedDefaultSd,
                                           ErrorHandle
                                           );

Error:

    if (ERROR_SUCCESS == WinError)
    {
        AdpLogMsg(0, ADP_INFO_MODIFY_DEFAULT_SD, pObjDn, NULL);
    }
    else
    {
        AdpLogErrMsg(0, ADP_ERROR_MODIFY_DEFAULT_SD, ErrorHandle, pObjDn, NULL);
    }

    if (pObjDn)
        AdpFree(pObjDn);

    if (pDefaultSd)
        AdpFree(pDefaultSd);

    if (AcesToAdd)
        AdpFree(AcesToAdd);

    if (AcesToRemove)
        AdpFree(AcesToRemove);

    if (NewSd)
        AdpFree(NewSd);

    if (OrgSd)
        LocalFree(OrgSd);
     
    if (SdToAdd)
        LocalFree(SdToAdd);

    if (SdToRemove)
        LocalFree(SdToRemove);

    if (pMergedDefaultSd)
        LocalFree(pMergedDefaultSd);


    return( WinError );

}



ULONG
PrimitiveModifyAttrs(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    primitive to modify DS object attributes

Parameters:

    TaskTable
    
    ErrorHandle
    
Return Values;

    Win32 Error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   LdapError = LDAP_SUCCESS;
    PWCHAR  pObjDn = NULL;
    LDAPModW    **AttrList = NULL;


    AdpDbgPrint(("PrimitiveModifyAttrs\n"));

    //
    // get object Dn
    //
    WinError = AdpCreateObjectDn(TaskTable->TargetObjName->ObjNameFlags,
                                 TaskTable->TargetObjName->ObjCn,
                                 TaskTable->TargetObjName->ObjGuid,
                                 TaskTable->TargetObjName->ObjSid,
                                 &pObjDn,
                                 ErrorHandle
                                 );

    if (ERROR_SUCCESS != WinError)
    {
        return( WinError );
    }

    //
    // build an attribute list to set
    // 

    WinError = BuildAttrList(TaskTable, 
                             NULL, 
                             0,
                             &AttrList
                             );

    if (ERROR_SUCCESS != WinError)
    {
        AdpSetWinError( WinError, ErrorHandle );
        goto Error;
    }


    //
    // using ldap to modify attributes
    // 
    AdpTraceLdapApiStart(0, ADP_INFO_LDAP_MODIFY, pObjDn);
    LdapError = ldap_modify_sW(gLdapHandle,
                               pObjDn,
                               AttrList
                               );
    AdpTraceLdapApiEnd(0, L"ldap_modify_s()", LdapError);

    if (LDAP_SUCCESS != LdapError)
    {
        WinError = LdapMapErrorToWin32( LdapError );
        AdpSetLdapError(gLdapHandle, LdapError, ErrorHandle);
        goto Error;
    }

Error:

    if (ERROR_SUCCESS == WinError)
    {
        AdpLogMsg(0, ADP_INFO_MODIFY_ATTR, pObjDn, NULL);
    }
    else
    {
        AdpLogErrMsg(0, ADP_ERROR_MODIFY_ATTR, ErrorHandle, pObjDn, NULL);
    }

    if (pObjDn)
        AdpFree( pObjDn );

    if (AttrList)
        FreeAttrList(AttrList);

    return( WinError );
}



void stepIt(
    long arg, void *vTotal)
{
   printf(".");
}


ULONG
PrimitiveCallBackFunc(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    primitive to call a call back function

Parameters:

    TaskTable
    
    ErrorHandle
    
Return Values;

    Win32 Error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    PWCHAR  pErrorMsg = NULL;


    hr = TaskTable->AdpCallBackFunc(gLogPath,
                                    OperationTable->OperationGuid,
                                    FALSE, // not dryRun (need to do both analysis and action)
                                    &pErrorMsg,
                                    NULL, // callee structure
                                    stepIt, // stepIt
                                    NULL  // totalSteps
                                    );
    printf("\n");

    if ( FAILED(hr) )
    {
        WinError = ERROR_GEN_FAILURE;
        AdpLogMsg(ADP_STD_OUTPUT, ADP_ERROR_CALLBACKFUNC_FAILED, pErrorMsg, gLogPath);
    }
    else
    {
        AdpLogMsg(0, ADP_INFO_CALL_BACK_FUNC, NULL, NULL);
    }

    if (pErrorMsg)
    {
        LocalFree( pErrorMsg );
    }

    // don't return HRESULT since it is a superset of WinError
    return( WinError );
}



ULONG
AdpDetectSFUInstallation(
    IN LDAP *LdapHandle,
    OUT BOOLEAN *fSFUInstalled,
    OUT ERROR_HANDLE *ErrorHandle
    )
/*++

    ISSUE-2002/10/24-shaoyin This is the SFU CN=UID conflict issue. see
    NTRAID#723208-2002/10/24-shaoyin

Routine Description: 

    This routine checks whether Services for UNIX is installed or not. 
    When Services for UNIX version 2 is installed, it extends the schema
    with an incorrect definition of the uid attribute.  When adprep tries 
    to extend the schema with the correct version of the uid attribute, 
    schupgr generates an error message that only tells the customer that 
    the schema extension failed, but not what the reason is and what they 
    can do.  Adprep will then fail.

    Fix is that adprep will detect that SFU 2.0 is installed and present 
    a warning that a fix for SFU 2.0 must be installed before you proeceed
    with adprep.  The adprep message contains the KB article number and the 
    fix number and tells the customer to contact PSS.

    Check if attribute Schema cn=uid and attributeID 
    (aka OID)=1.2.840.113556.1.4.7000.187.102 is present.  
    If present then display a message and exit:     

Parameter:

    LdapHandle 
    fSFUInstalled - return whether conflict SFU installation is detected or not 
    ErrorHandle
   
Return Code: 
    
    Win32 Error code

    ERROR_SUCCESS --- successfully determined whether SFU is installed or not.
                      boolean fSFUInstalled will indicated that. 

    All other ERROR codes --- adprep was unable to determined whether SFU is 
                              installed or not due to all kinds of error.

--*/
{
    ULONG           WinError = ERROR_SUCCESS;
    ULONG           LdapError = LDAP_SUCCESS; 
    PWCHAR          pObjectDn = NULL;
    PWCHAR          AttrList = NULL;
    LDAPMessage     *SearchResult = NULL;
    LDAPMessage     *Entry = NULL;


    // set return value

    *fSFUInstalled = FALSE;


    //
    // create the DN of CN=UID,CN=Schema object 
    // 

    WinError = AdpCreateObjectDn(ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
                                 L"CN=UID", // ObjCn
                                 NULL,      // ObjGuid
                                 NULL,      // ObjSid
                                 &pObjectDn,    // return value
                                 ErrorHandle
                                 );

    if (ERROR_SUCCESS != WinError)
    {
        AdpSetWinError(WinError, ErrorHandle);
        goto Error;
    }


    //
    // search this object
    // 

    AdpTraceLdapApiStart(0, ADP_INFO_LDAP_SEARCH, pObjectDn);
    LdapError = ldap_search_sW(LdapHandle,
                               pObjectDn,   // CN=UID,CN=Schema object 
                               LDAP_SCOPE_BASE,
                               L"(attributeId=1.2.840.113556.1.4.7000.187.102)", // filter
                               &AttrList,
                               0,
                               &SearchResult
                               );
    AdpTraceLdapApiEnd(0, L"ldap_search_s()", LdapError);

    if ( LDAP_SUCCESS != LdapError )
    {
        if ( LDAP_NO_SUCH_OBJECT != LdapError )
        {
            // search failed, but not due to missing object. 
            AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
            WinError = LdapMapErrorToWin32( LdapError );
        }
    }
    else if ( (LDAP_SUCCESS == LdapError) && 
              (Entry = ldap_first_entry(LdapHandle, SearchResult)) )
    {
        // object CN=UID,CN=Schema with the pre-set attributeID was found 
        *fSFUInstalled = TRUE;
    }

Error:

    // write adprop log - success or failure
    if (ERROR_SUCCESS == WinError)
    {
        AdpLogMsg(0, ADP_INFO_DETECT_SFU, NULL, NULL);
    }
    else
    {
        AdpLogErrMsg(0, ADP_ERROR_DETECT_SFU, ErrorHandle, NULL, NULL);
    }

    // clean up and return
    if (SearchResult) {
        ldap_msgfree( SearchResult );
    }

    if (pObjectDn) {
        AdpFree( pObjectDn);
    }

    return( WinError );

}




BOOLEAN
AdpUpgradeSchema(
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    upgrade schema during forest update

Parameters:

    ErrorHandle
    
Return Values;

    BOOLEAN:  1:    failed
              0:    success

--*/
{
    int                 ret = 0;
    BOOLEAN             success = TRUE;

    ret = _wsystem(L"schupgr.exe");

    if (ret)
    {
        success = FALSE;
    }
    else
    {
        WIN32_FIND_DATA     FindData;
        HANDLE              FindHandle = INVALID_HANDLE_VALUE;
        PWCHAR              ErrorFileName = NULL; 
        ULONG               Length = 0;

        //
        // search for ldif.err 
        //
        Length = sizeof(WCHAR) * (wcslen(gLogPath) + 2 + wcslen(L"ldif.err"));
        ErrorFileName = AdpAlloc( Length );
        if (NULL == ErrorFileName)
        {
            success = FALSE;
        }
        else
        {
            swprintf(ErrorFileName, L"%s\\%s", gLogPath, L"ldif.err");
            FindHandle = FindFirstFileW(ErrorFileName, &FindData);

            if (FindHandle && (INVALID_HANDLE_VALUE != FindHandle))
            {
                //
                // got the file, that means schupgr failed.
                // 
                FindClose(FindHandle);
                success = FALSE;
            }
        }
    }
      
    // check return winerror here

    if (success)
    {
        AdpLogMsg(0, ADP_INFO_CALL_SCHUPGR, NULL, NULL);
    }
    else
    {
        AdpLogMsg(ADP_STD_OUTPUT, ADP_ERROR_SCHUPGR_FAILED, gLogPath, NULL);
    }

    return( !success );
}

ULONG
AdpProcessPreWindows2000GroupMembers(
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    this routine makes change on Pre Windows2000 Compat Access Group members.
    
    if Everyone was a member, then add Anonymous Logon to this group as well. 
    otherwise, do nothing. 
    
    Note: we do not use LDAP API, instead call few LSA and NET APIs

Parameters:

    ErrorHandle
    
Return Values;

    Win32 Error

--*/
{
    ULONG       WinError = ERROR_SUCCESS;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NET_API_STATUS NetStatus;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaPolicyHandle = NULL;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains = NULL;
    PLSA_TRANSLATED_NAME Names = NULL;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY,
                             NtAuthority = SECURITY_NT_AUTHORITY;
    PSID    EveryoneSid = NULL;
    PSID    AnonymousSid = NULL;
    PSID    PreWindows2000Sid = NULL;
    PSID    SidList[1];

    UINT    cbMaxBufLength = 32768U;
    DWORD   dwPrivLevel   = 0;
    DWORD   cEntriesRead  = 0;
    DWORD   cTotalEntries = 0;
    DWORD_PTR   ResumeKey = 0;
    LPLOCALGROUP_MEMBERS_INFO_0 LocalGroupMembers = NULL;
    LOCALGROUP_MEMBERS_INFO_0 LocalGroupInfo0;
    char    lpErrBuff[100];
    ULONG   index;
    PWCHAR  GroupName = NULL;
    BOOLEAN fAddAnonymous = FALSE;



    //
    // init well known SIDs
    // 
    if (!AllocateAndInitializeSid(
            &NtAuthority,1,SECURITY_ANONYMOUS_LOGON_RID,0,0,0,0,0,0,0,&AnonymousSid) ||
        !AllocateAndInitializeSid(
            &WorldSidAuthority,1,SECURITY_WORLD_RID,0,0,0,0,0,0,0,&EveryoneSid) ||
        !AllocateAndInitializeSid(
            &NtAuthority,2,SECURITY_BUILTIN_DOMAIN_RID,DOMAIN_ALIAS_RID_PREW2KCOMPACCESS,0,0,0,0,0,0,&PreWindows2000Sid)
        )
    {
        WinError = GetLastError();
        AdpSetWinError( WinError, ErrorHandle );
        goto Error;
    }

    SidList[0] = PreWindows2000Sid;

    //
    // Get a handle to the Policy object.
    // 
    memset(&ObjectAttributes, 0, sizeof(ObjectAttributes));

    NtStatus = LsaOpenPolicy(NULL,
                             &ObjectAttributes, 
                             POLICY_ALL_ACCESS, //Desired access permissions.
                             &LsaPolicyHandle
                             );
    if (NT_SUCCESS(NtStatus))
    {
        //
        // get well known account (pre-window2000 compa access) AccountName
        // 
        NtStatus = LsaLookupSids(LsaPolicyHandle,
                                 1,
                                 SidList,
                                 &ReferencedDomains,
                                 &Names
                                 );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        WinError = LsaNtStatusToWinError(NtStatus);
        AdpSetWinError( WinError, ErrorHandle );
        goto Error;
    } 


    //
    // get the AccountName for Pre-Windows2000 group.
    // 

    GroupName = AdpAlloc( Names[0].Name.Length + sizeof(WCHAR));
    memcpy(GroupName, Names[0].Name.Buffer, Names[0].Name.Length);

    //
    // get members of pre-windows2000 group
    // 
    NetStatus = NetLocalGroupGetMembers(NULL,  // serverName
                                        GroupName,
                                        0,     // info level
                                        (PBYTE *)&LocalGroupMembers,
                                        cbMaxBufLength,
                                        &cEntriesRead,
                                        &cTotalEntries,
                                        &ResumeKey);

    if (NERR_Success == NetStatus)
    {
        //
        // go through all memeber, check if everyone is a member or not
        // 
        for (index = 0; index < cEntriesRead; index++)
        {
            if (EqualSid(EveryoneSid, LocalGroupMembers[index].lgrmi0_sid))
            {
                fAddAnonymous = TRUE;
                break;
            }
        }

        //
        // add anonymous logon SID to the group
        // 
        if (fAddAnonymous)
        {
            LocalGroupInfo0.lgrmi0_sid = AnonymousSid;
            NetStatus = NetLocalGroupAddMembers(NULL,
                                                GroupName, 
                                                0, 
                                                (LPBYTE)&LocalGroupInfo0,
                                                1
                                                );
        }
        else
        {
            AdpLogMsg(0, ADP_INFO_DONT_ADD_MEMBER_TO_PRE_WIN2K_GROUP, NULL, NULL);
        }

    }

    if (NERR_Success != NetStatus &&
        ERROR_MEMBER_IN_ALIAS != NetStatus)
    {
        WinError = NetStatus;
        AdpSetWinError( WinError, ErrorHandle );
        goto Error;
    }


Error:

    if (ERROR_SUCCESS == WinError)
    {
        AdpLogMsg(0, ADP_INFO_ADD_MEMBER_TO_PRE_WIN2K_GROUP, NULL, NULL);
    }
    else
    {
        AdpLogErrMsg(0, ADP_ERROR_ADD_MEMBER_TO_PRE_WIN2K_GROUP, ErrorHandle, NULL, NULL);
    }


    if (ReferencedDomains)
        LsaFreeMemory( ReferencedDomains );

    if (Names)
        LsaFreeMemory( Names );

    if (LsaPolicyHandle)
        LsaClose( LsaPolicyHandle );

    if (EveryoneSid)
        FreeSid( EveryoneSid );

    if (AnonymousSid)
        FreeSid( AnonymousSid );

    if (PreWindows2000Sid)
        FreeSid( PreWindows2000Sid );

    if (GroupName)
        AdpFree(GroupName);

    if (LocalGroupMembers)
        NetApiBufferFree( LocalGroupMembers );


    return( WinError );
}



ULONG
PrimitiveDoSpecialTask(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    primitive to do special tasks

Parameters:

    TaskTable

    ErrorHandle
    
Return Values;

    Win32 Error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;

    switch( TaskTable->SpecialTaskCode )
    {
    case PreWindows2000Group:

        WinError = AdpProcessPreWindows2000GroupMembers(ErrorHandle);
        break;

    default:
        ASSERT( FALSE );
        WinError = ERROR_INVALID_PARAMETER;
        break;
    }

    return( WinError );
}



ULONG
AdpIsOperationComplete(
    IN LDAP    *LdapHandle,
    IN PWCHAR  pOperationDn,
    IN BOOLEAN *fComplete,
    OUT ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    checks whether the operation (specified by pObjectionDn) is complete or not 
    by checking is the object exists.

Parameters:

    LdapHandle

    pOperationDn
    
    fComplete

    ErrorHandle
    
Return Values;

    Win32 Error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   LdapError = LDAP_SUCCESS;
    PWCHAR  AttrList = NULL;
    LDAPMessage *Result = NULL;

    *fComplete = FALSE;

    AdpTraceLdapApiStart(0, ADP_INFO_LDAP_SEARCH, pOperationDn);
    LdapError = ldap_search_sW(LdapHandle,
                               pOperationDn,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               &AttrList,
                               0,
                               &Result
                               );
    AdpTraceLdapApiEnd(0, L"ldap_search_s()", LdapError);

    if (LDAP_SUCCESS == LdapError)
    {
        *fComplete = TRUE;
        AdpLogMsg(0, ADP_INFO_OPERATION_COMPLETED, pOperationDn, NULL);

    }
    else if (LDAP_NO_SUCH_OBJECT == LdapError)
    {
        *fComplete = FALSE;
        AdpLogMsg(0, ADP_INFO_OPERATION_NOT_COMPLETE, pOperationDn, NULL);
    }
    else
    {
        WinError = LdapMapErrorToWin32( LdapError );
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
        AdpLogErrMsg(0, ADP_ERROR_CHECK_OPERATION_STATUS, ErrorHandle, pOperationDn, NULL);
    }

    if (Result)
    {
        ldap_msgfree( Result );
    }

    return( WinError );
}



ULONG
AdpAddRemoveAcesWorker(
    OPERATION_TABLE *OperationTable,
    ULONG Flags,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    )
/*++

Routine Description:

    primitive to add/remove ACEs on an object in DS

Parameters:

    TaskTable
    
    ErrorHandle
    
Return Values;

    Win32 Error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    PWCHAR  pObjDn = NULL;
    PWCHAR  AcesToAdd = NULL;
    PWCHAR  AcesToRemove = NULL;
    PSECURITY_DESCRIPTOR    OrgSd = NULL,
                            NewSd = NULL,
                            SdToAdd = NULL,
                            SdToRemove = NULL;
    ULONG   NewSdLength = 0,
            OrgSdLength = 0,
            SdToAddLength = 0,
            SdToRemoveLength = 0;



    AdpDbgPrint(("PrimitiveAddRemoveACEs\n"));

    //
    // get object DN
    // 
    WinError = AdpCreateObjectDn(TaskTable->TargetObjName->ObjNameFlags,
                                 TaskTable->TargetObjName->ObjCn,
                                 TaskTable->TargetObjName->ObjGuid,
                                 TaskTable->TargetObjName->ObjSid,
                                 &pObjDn,
                                 ErrorHandle
                                 );

    if (ERROR_SUCCESS != WinError)
    {
        return( WinError );
    }


    //
    // get object SD
    // 
    WinError = AdpGetObjectSd(gLdapHandle, 
                              pObjDn, 
                              &OrgSd, 
                              &OrgSdLength, 
                              ErrorHandle
                              );

    if (ERROR_SUCCESS != WinError)
    {
        goto Error;
    }


    //
    // convert SDDL ACE's to SD
    // 
    if ((TaskTable->NumOfAces == 0) ||
        (TaskTable->AceList == NULL))
    {
        ASSERT( FALSE );
        WinError = ERROR_INVALID_PARAMETER;
        AdpSetWinError( WinError, ErrorHandle );
        goto Error;
    }

    WinError = AdpBuildAceList(TaskTable,
                               &AcesToAdd,
                               &AcesToRemove
                               );
    if (ERROR_SUCCESS != WinError)
    {
        goto Error;
    }

    if (NULL != AcesToAdd)
    {
        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                            AcesToAdd,
                            SDDL_REVISION_1,
                            &SdToAdd,
                            &SdToAddLength
                            ))

        {
            WinError = GetLastError();
            AdpSetWinError( WinError, ErrorHandle );
            goto Error;
        }
    }

    if (NULL != AcesToRemove)
    {
        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                            AcesToRemove,
                            SDDL_REVISION_1,
                            &SdToRemove,
                            &SdToRemoveLength
                            ))

        {

            WinError = GetLastError();
            AdpSetWinError( WinError, ErrorHandle );
            goto Error;
        }

    }


    WinError = AdpMergeSecurityDescriptors(
                                OrgSd,
                                SdToAdd,
                                SdToRemove,
                                Flags,
                                &NewSd,
                                &NewSdLength
                                );

    if (ERROR_SUCCESS != WinError)
    {
        goto Error;
    }

    //
    // set object SD
    // 
    WinError = AdpSetObjectSd(gLdapHandle, 
                              pObjDn, 
                              NewSd, 
                              NewSdLength, 
                              DACL_SECURITY_INFORMATION, 
                              ErrorHandle 
                              );

Error:

    if (ERROR_SUCCESS == WinError)
    {
        AdpLogMsg(0, ADP_INFO_MODIFY_SD, pObjDn, NULL);
    }
    else
    {
        //    the requested SecurityUpdate operation failed AND
        //    this operation is Ignorable (skip-able) AND 
        //    the expected error code matched:
        //        expected Win32 error code == actual WinError returned
        //
        //    write the failure to log file, NOT to console

        //    the above logic only applies in ecurityDescriptorUpdate
        //    primitive, per the IPSEC team, the lack of these objects is not a 
        //    problematic configuration. Though adprep does explain that the 
        //    errors are benign, but this doesn't appear to work with 
        //    alleviating customer concerns. So we need to suppress the 
        //    warning on console output.
 

        ULONG   ErrFlag = 0;

        if (OperationTable->fIgnoreError &&
            OperationTable->ExpectedWinErrorCode == WinError)
        {
            ErrFlag |= ADP_DONT_WRITE_TO_STD_OUTPUT;
        }

        AdpLogErrMsg(ErrFlag, ADP_ERROR_MODIFY_SD, ErrorHandle, pObjDn, NULL);
    }

    if (pObjDn)
        AdpFree(pObjDn);

    if (AcesToAdd)
        AdpFree(AcesToAdd);

    if (AcesToRemove)
        AdpFree(AcesToRemove);

    if (OrgSd)
        AdpFree(OrgSd);
     
    if (NewSd)
        AdpFree(NewSd);

    if (SdToAdd)
        LocalFree(SdToAdd);

    if (SdToRemove)
        LocalFree(SdToRemove);


    return( WinError );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\ldap_derive.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ldapp.h

Abstract:

    This module define a set of classes to facilitate encapsulation of LDAP objects in the
    Configuration container. In particular, it encapsulates server, NtdsDsa and connection
    objects.

Author:

    Ajit Krishnan (t-ajitk) 10-Jul-2001

Revision History:

    Nick Harvey   (nickhar) 24-Sep-2001
        Clean-up & Maintenance

--*/

#include "ldapp.h"
#include "ismp.h"
#include <ntdsadef.h>

// NTDSSETTINGS_* symbols defined in ntdsapi.h

using namespace std;

bool
NtdsDsa :: getHostedNcsHelper (
    IN const wstring &root_dn,
    IN const wstring &attrName,
    IN bool writeable,
    IN bool isComingGoing
    )
/*++

Routine Description:

    Parse an attribute of type distname binary into a list of nc's. If ComingGoing
    information is not found in this attribute, it should be set to false. writeable will
    only be used when isComingGoing is true.
    
Arguments:

    attrName - an attribute of type distname binary
    
    writeable - whether the nc is writeable
    
    isComingGoing - whether this information is found in this attribute, or not

Return Values:

    true - attribute successfully processed
    false - this attribute does not exist

--*/
{
    LPWSTR ppszDn;
    int attrNum = findAttribute (attrName);
    // this attr doesn't exist (ex. no partials...)
    if (attrNum == -1) {
        return false;
    }

    Attribute a = getAttribute(attrNum);
    int numValues = a.numValues();


    // parse each ncreason
    for (int i=0; i<numValues; i++) {
        AttrValue av = a.getValue(i);
        PVOID ppvData;
        DWORD pcbLength;
                
        bool going, coming;
        // determine replication type IP/SMTP
        TransportType tt = T_IP;
        Server *s = getServer();
        bool suppSmtp = s->supportsSmtp();
        if (suppSmtp) {
            // only readable copies can replicate over smtp
            if (writeable == false) {
                tt = T_SMTP;
            } else {
                // exceptions are config & schema
                wstring schema_dn = L"CN=Schema," + root_dn;
                wstring config_dn = L"CN=Configuration," + root_dn;
                wstring nc_dn ((PWCHAR)(ppvData));
                int sret = _wcsicoll(nc_dn.c_str(), config_dn.c_str());
                int cret = _wcsicoll(nc_dn.c_str(), schema_dn.c_str());
                if (!sret || !cret) {
                    tt = T_SMTP;
                }
            }
        }

        // if cominggoing exists, get all information from the dword
        if (!isComingGoing) {
            going=coming=false;
            Nc nc (wstring((PWCHAR)av.value), writeable, going||coming, tt);
            m_ncs.push_back(nc);
        } else {
            bool bret = av.decodeLdapDistnameBinary(&ppvData, &pcbLength, &ppszDn);
            Assert (bret && L"decodeLdapDistnameBinary return value error");
            DWORD dwReason = ntohl ( *((LPDWORD)ppvData));
            writeable = (dwReason & m_host_nc_write_mask) ? true : false;
            coming = (dwReason & m_host_nc_coming_mask) ? true : false;
            going = (dwReason & m_host_nc_going_mask) ? true : false;
            Nc nc (wstring(ppszDn), writeable, going || coming, tt);
            m_ncs.push_back (nc);
        }
    }

    return true;
}

vector<Nc> &
NtdsDsa::getHostedNcs(
    IN const wstring &root_dn
    )
/*++

Routine Description:

    Get the list of NCs hosted by this ntdsDsa object
    
Arguments:
    root_dn - The root dn
    
Return Value:

    The list of hosted NC's

--*/
{
    if (m_ncs.size() > 0) {
        return m_ncs;
    }

    LbToolOptions lbOpts = GetGlobalOptions();

    // Ignore return value for hasPartialReplicaNCs
    getHostedNcsHelper (root_dn, L"hasPartialReplicaNCs", false, false);

    // If msDS-hasMasterNCs exists, it trumps hasMasterNCs
    if( ! getHostedNcsHelper (root_dn, L"msDS-hasMasterNCs", true, false) ) {
        // Ignore return value for hasMasterNCs
        getHostedNcsHelper (root_dn, L"hasMasterNCs", true, false);
    }
    
    sort (m_ncs.begin(), m_ncs.end());
    return m_ncs;
}

Server *
NtdsDsa :: getServer (
    )
/*++

Routine Description:

    Get the server which corresponds to this ntdsDsa object
    
Return Value:

    The corresponding server object

--*/
{
    Assert (m_server != NULL && L"NtdsDsa cache of server invalid");
    return m_server;
}

void
NtdsDsa :: setServer (
    Server *s
    )
/*++

Routine Description:

    Set the server which corresponds to this ntdsDsa object
    
Arguments:

    s - The corresponding server object

--*/
{
    m_server = s;
}

bool
Server :: isPreferredBridgehead (
    IN TransportType t
    )
/*++

Routine Description:

    Determine if this server is a preferred bridgehead. This will be also be
    true is setPreferredBridgehead was previously called
    
Arguments:

    t - The transport type for which PB status should be determined

--*/
{ 
    if (m_preferred_ip && t == T_IP) {
        return true;
    } else if (m_preferred_smtp && t == T_SMTP) {
        return true;
    }
    
    int attr_num = findAttribute(L"bridgeheadTransportList");
    
    if (attr_num == -1) {
        return false;
    }

    Attribute a = getAttribute (attr_num);
    int num_values = a.numValues();

    for (int i=0; i<num_values; i++) {
        AttrValue av = a.getValue(i);
        DnManip dn ((PWCHAR)av.value);
        wstring rn = dn.getRdn();
        if (t == T_IP && _wcsicoll(rn.c_str(), L"CN=IP") == 0)  {
            return true;
        } else if (t == T_SMTP && _wcsicoll(rn.c_str(), L"CN=SMTP") == 0) {
            return true;
        }
    }
    return false;
    
}

void
Server :: setPreferredBridgehead (
    IN TransportType t
    )
/*++

Routine Description:

    Set the server as a preferred object. This is internal state only, and
    will not modify the attributes of the server object
    
Arguments:

    t - The transport type for which this server shouldb e a PB

--*/
{
    if (t == T_IP) {
        m_preferred_ip = true;
    } else if (t == T_SMTP) {
        m_preferred_smtp = true;
    }
}

bool
Server :: supportsSmtp (
    )
/*++

Routine Description:

    Determine if this server supports smtp replication
    
Return Value:

    True if it supports smtp replication, False if it supports ip only

--*/
{
    int i = findAttribute(L"SMTP-Mail-Address");
    if (i == -1) {
        return false;
    }
    return true;
}

vector<Nc> &
Server :: getHostedNcs (
    IN const wstring &root_dn
    )
/*++

Routine Description:

    Get a list of all Ncs hosted by this server

Arguments:

    root_dn - The root dn
    
Return Value:

    A list of hosted Ncs

--*/
{
    NtdsDsa *nd = getNtdsDsa();
    return nd->getHostedNcs(root_dn);
}

NtdsDsa *
Server :: getNtdsDsa (
    )
/*++

Routine Description:

    Get the NtdsDsa which corresponds to this server object
    
Return Value:

    The corresponding NtdsDsa object

--*/
{
    Assert (m_ntds_dsa != NULL && L"Server cache of ntds dsa invalid");
    return m_ntds_dsa;
}

void
Server :: setNtdsDsa (
    NtdsDsa *nd
    ) {
    /*++
    Routine Description:
    
        Set the NtdsDsa which corresponds to this server object
        
    Arguments:
    
        ns - The corresponding server
    --*/
    m_ntds_dsa = nd;
}


NtdsSiteSettings :: NtdsSiteSettings (
    IN const wstring &dn
    ) 
    /*++
    Routine Description:
    
        Default constructor for a NtdsSiteSettings object
        
    Arguments:
    
        The DN of the ldapobject/NtdsSiteSettings
    --*/
    
    : LdapObject (dn){
	m_cache_populated = false;
	m_cache_defaultServerRedundancy = NTDSSETTINGS_DEFAULT_SERVER_REDUNDANCY;
}

int
NtdsSiteSettings :: defaultServerRedundancy (
		)
/*++
Routine Description:
	The number of Redundant Connections the KCC should have
	created to this site. If the
	NTDSSETTINGS_OPT_IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED     
	is not set in the options field, this function will always
	return 1; 
	
Return Values:
	1 if NTDSSETTINGS_OPT_IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED is not set
	The value of NTDSSETTINGS_DEFAULT_SERVER_REDUNDANCY otherwise
--*/
{
	if (m_cache_populated) {
		return m_cache_defaultServerRedundancy;
	}

	int attr_num = findAttribute (L"options");
	
	// if options attribute is not found, it defaults to 0
	int opt = 0;

	if (attr_num != -1) {
		Attribute &a = getAttribute (attr_num);
		int numValues = a.numValues();
		Assert (numValues == 1 && L"NtdsSiteSettings::Options has too many values");
		const AttrValue av = a.getValue(0);
		PWCHAR value = (PWCHAR)av.value;
		wchar_t *stop_string;
		opt = wcstol (value, &stop_string, 10);
		Assert (opt >= 0 && L"NtdsSiteSettings::Options contains invalid value");
	}


	if (opt & NTDSSETTINGS_OPT_IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED) {
		m_cache_defaultServerRedundancy = NTDSSETTINGS_DEFAULT_SERVER_REDUNDANCY;
	} else {
		m_cache_defaultServerRedundancy = 1;
	}

	m_cache_populated = true;
	return m_cache_defaultServerRedundancy;
}

void
Connection :: getReplicatedNcsHelper (
    const wstring &attrName
    )
/*++

Routine Description:

    Parse an attribute of type distname binary into a list of nc's. 
    
Arguments:

    attrName - an attribute of type distname binary

--*/
{
    LPWSTR ppszDn;
    int attrNum = findAttribute (attrName);

    // redmond has connection objects without nc reaons
    if (attrNum == -1) {
        return;
    }
    TransportType t = getTransportType();
    Attribute a = getAttribute(attrNum);
    int numValues = a.numValues();
    for (int i=0; i<numValues; i++) {
        AttrValue av = a.getValue(i);
        PVOID ppvData;
        DWORD pcbLength;
        bool bret = av.decodeLdapDistnameBinary(&ppvData, &pcbLength, &ppszDn);
        Assert (bret && L"decodeLdapDistnameBinary return value error");
        DWORD dwReason = ntohl ( *((LPDWORD)ppvData));
        bool writeable = dwReason & m_reason_gc_topology_mask;
        Nc nc (wstring(ppszDn), writeable, false, t);
        m_ncs.push_back (nc);
    }

}

vector<Nc> &
Connection :: getReplicatedNcs (
    )  {
    /*++
    Routine Description:
    
        Get a list of all NC's replicated by this connection
        
    Return Value:
    
        A list of all replicated NC's
    --*/
    if (m_ncs.size() > 0) {
        return m_ncs;
    }
    
    getReplicatedNcsHelper(L"mS-DS-ReplicatesNCReason");
    sort (m_ncs.begin(), m_ncs.end());
    return m_ncs;
}



Connection :: Connection (
    IN const wstring &dn
    ) 
    /*++
    Routine Description:
    
        Default constructor for a connection object
        
    Arguments:
    
        The DN of the ldapobject/connection
    --*/
    
    : LdapObject (dn){
    m_repl_interval = 15;
	m_redundancy_count = 1;
    m_repl_schedule = NULL;
    m_avail_schedule = NULL;
}

TransportType
Connection::getTransportType()
/*++

Routine Description:

    Determine the transport type of the current connection
    
Return Value:

    T_SMTP if it is an SMTP connection, and T_IP if it is an IP connection

--*/
{
    // If attr does not exist, it is ip only (intra-site)
    int i = findAttribute(L"TransportType");
    if (i == -1) {
        return T_IP;
    }

    // else, check value of attribute
    Attribute a = getAttribute(i);

    Assert (a.numValues() == 1 && L"Transport-Type must contain one value");

    const AttrValue av = a.getValue(0);
    wstring transport_dn ((PWCHAR)(av.value));

    wstring rdn = DnManip (transport_dn).getRdn();
    if (rdn == wstring(L"CN=IP")) {
        return T_IP;
    }
    
    return T_SMTP;
}

bool
Connection::IsMoveable()
/*++

Routine Description:

    Determine if the current connection can be moved or not
    
Return Value:

    TRUE - can be moved
    FALSE - may not be moved

--*/
{
    // If attr does not exist, it is not moveable by default
    int i = findAttribute(L"systemFlags");
    if (i == -1) {
        Assert( FALSE && L"systemFlags should always be present!");
        return FALSE;
    }

    // else, check value of attribute
    Attribute a = getAttribute(i);
    const AttrValue av = a.getValue(0);
    PWCHAR value = (PWCHAR)(av.value);
    wchar_t *stop_string;
    DWORD dwSystemFlags = wcstol (value, &stop_string, 10);

    return !! (dwSystemFlags & FLAG_CONFIG_ALLOW_MOVE);
}

void
Connection :: setFromServer (
    IN const wstring &from_server
    )
/*++

Routine Description:

    Set the fromServer attribute to point to a new server

Arguments:

    w - The new fromServer DN (fully qualified)
    
--*/
{
    Assert( !isManual() );

    int attr_num = findAttribute (L"fromServer");
    Assert (attr_num != -1 && L"Unable to find fromServer attribute from connection");
    Attribute &a = getAttribute (attr_num);
    int numValues = a.numValues();
    Assert (numValues == 1 && L"Connection has too many fromServer's");
    
    LbToolOptions lbOpts = GetGlobalOptions();
    if (lbOpts.verbose) {
        *lbOpts.log << endl << endl << L"Modifying fromServer on : " << endl << getName() << endl;
        *lbOpts.log << getFromServer() << endl;
        *lbOpts.log << from_server << endl;
    }
    PBYTE value = (PBYTE)(_wcsdup (from_server.c_str()));
    if( NULL==value ) {
        throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }
    a.setValue (0, value, (wcslen ((PWCHAR)(value))+1) * sizeof(WCHAR));
}

wstring
Connection :: getFromServer (
    ) {
    /*++
    Routine Description:
    
        Determine the FQDN of the fromServer
        
    Return Value:
    
        The DN of the fromServer
    --*/

    int attr_num = findAttribute (L"fromServer");
    Assert (attr_num != -1 && L"Unable to find fromServer attribute from connection");
    Attribute &a = getAttribute (attr_num);
    int numValues = a.numValues();
    Assert (numValues == 1 && L"Connection has too many fromServer's");
    AttrValue av = a.getValue(0);
    return wstring ((PWCHAR)av.value);
}


bool
Connection :: hasUserOwnedSchedule (
    ) {
    /*++
    Routine Description:
        Determine whether this connection has a user owned schedule
    Return Value:
        True if it is has a user owned schedule, and false otherwise
    --*/
    int i = findAttribute(L"Options");
    Assert (i != -1 && L"Unable to find Connection::Options");
    Attribute a = getAttribute (i);
    Assert (a.numValues() == 1 && L"Connection::Options should be single valued");

    const AttrValue av = a.getValue(0);
    PWCHAR value = (PWCHAR)(av.value);
    wchar_t *stop_string;
    int opt = wcstol (value, &stop_string, 10);

    Assert (opt >= 0 && L"Connection::Options contains invalid value");

    // if bit 1 is true, it is user owned
    if (opt & NTDSCONN_OPT_USER_OWNED_SCHEDULE) {
        return true;
    }

    return false;    
}

void
Connection :: setUserOwnedSchedule (
	IN bool status
    ) {
    /*++
    Routine Description:
        set the user owned schedule bit for this connection
    --*/

    // if already in the status requested, do nothing
    if ( (status && hasUserOwnedSchedule()) ||
		  ((!status) && (!hasUserOwnedSchedule())) ) {
        return;
    }

    int i = findAttribute(L"Options");
    Assert (i != -1 && L"Unable to find Connection::Options");
    Attribute &a = getAttribute (i);
    Assert (a.numValues() == 1 && L"Connection::Options should be single valued");

    AttrValue av = a.setValue(0);
    PWCHAR value = (PWCHAR)(av.value);
    wchar_t *stop_string;
    int opt = wcstol (value, &stop_string, 10);
    Assert (opt >= 0 && L"Connection::Options contains invalid value");
    
	if (status) {
		opt |= NTDSCONN_OPT_USER_OWNED_SCHEDULE;
	} else {
		opt -= NTDSCONN_OPT_USER_OWNED_SCHEDULE;
	}

    PWCHAR new_value = (PWCHAR)malloc(10 * sizeof(WCHAR));
    if (! new_value) {
        throw Error(GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }

    wsprintf (new_value, L"%d", opt);
    a.setValue(0, (PBYTE)new_value, (wcslen(new_value)+1)*sizeof(WCHAR));
}


bool
Connection :: isManual (
    )  {
    /*++
    Routine Description:
    
        Determine whether this connection was created manually, or by the KCC
        
    Return Value:
    
        True if it is a manual connection, and false otherwise
    --*/
    
    int i = findAttribute(L"Options");

    Assert (i != -1 && L"Unable to find Connection::Options");

    Attribute a = getAttribute (i);

    Assert (a.numValues() == 1 && L"Connection::Options should be single valued");

    const AttrValue av = a.getValue(0);
    PWCHAR value = (PWCHAR)(av.value);
    wchar_t *stop_string;
    int opt = wcstol (value, &stop_string, 10);

    Assert (opt >= 0 && L"Connection::Options contains invalid value");

    // if bit 0 is true, it is KCC generated
    if (opt & 1) {
        return false;
    }

    return true;
    
}

void
Connection :: setReplInterval (
    unsigned replInterval
    ) {
    /*++
    Routine Description:
    
        Set the replication interval for the connection
        
    Return Value:
    
        None
    --*/    
    
    m_repl_interval = replInterval;
}

void
Connection :: setRedundancyCount (
	IN int count
    ) {
    
	/*++
   Routine Description:
	   Set the redundancy count found on the NTDS Settings of the
	   destination end of the connection
   Arguments:
	   count: The integer redundancy Value
   Return Value:
	   None
   --*/    

	// Don't apply the redundancy factor to manual connections
	if (! isManual()) {
		m_repl_interval *= count;
		m_redundancy_count = count;
	}
}


int
Connection::getReplInterval(
    ) const
/*++
Routine Description:

    Get the replication interval for the connection
    
Return Value:

    The replication interval for the connection (in minutes)
--*/
{
    return m_repl_interval;
}

void
Connection :: setAvailabilitySchedule (
    IN ISM_SCHEDULE* cs
    ) {
    /*++
    Routine Description:
    
        Set the availability schedule for the connection
        
    Arguments:
    
        A pointer to an ISM_SCHEDULE structure which is parsed
        
    Return Value:
    
        None
    --*/    
    
    m_avail_schedule = new Schedule ();
    m_avail_schedule->setSchedule (cs, m_repl_interval);
}

const Schedule *
Connection :: getAvailabilitySchedule (
    ) const
/*++

Routine Description:

    Get a read-only reference to the availability schedule
    
Return Value:

    A read-only reference to the availability schedule.
    May not be NULL.

--*/
{
    Assert( NULL!=m_avail_schedule && L"NULL Availability Schedule found");
    return m_avail_schedule;
}

Schedule *
Connection::getReplicationSchedule(
    )
/*++

Routine Description:

    Get a read-only reference to the availability schedule
    
Return Value:

    A read-only reference to the availability schedule
    May not be null.

--*/
{
    if (m_repl_schedule) {
        return m_repl_schedule;
    }

    int attr_num = findAttribute (L"Schedule");
    Assert (attr_num != -1 && L"Unable to find Schedule attribute from connection");
    Attribute a = getAttribute (attr_num);
    Assert (a.numValues() == 1 && L"Connection has too many schedules");
    AttrValue av = a.getValue(0);        
    m_repl_schedule = new Schedule();
    m_repl_schedule->setSchedule((PSCHEDULE)(av.value), getReplInterval());

    Assert( NULL!=m_repl_schedule && L"NULL Replication Schedule found");
    return m_repl_schedule;
}

void
Connection::setReplicationSchedule(
    IN ISM_SCHEDULE* cs
    )
/*++

Routine Description:

    Set the replication schedule for the connection
    
Arguments:

    A pointer to an ISM_SCHEDULE structure which is parsed
    
Return Value:

    None

--*/    
{
    Assert( !isManual() );
    m_repl_schedule = new Schedule ();
    m_repl_schedule->setSchedule (cs, m_repl_interval);
}

void
Connection::setReplicationSchedule(
    IN Schedule *s
    )
/*++

Routine Description:

    Set the replication schedule for the connection

Arguments:

    s: A pointer to a schedule
    
Implementation Details:

    We do not create a new replication schedule, but take the 
    existing one, and modify the bits specifying the replication times.
    All the other bits are left as is. 

--*/    
{
    Assert( !isManual() );

    if (m_repl_schedule) {
        delete m_repl_schedule;
    }
    m_repl_schedule = s;
    
    // Modify the underlying attribute value as well
    int attr_num = findAttribute (L"Schedule");
    Assert (attr_num != -1 && L"Unable to find Schedule attribute from connection");
    Attribute &a = getAttribute (attr_num);
    Assert (a.numValues() == 1 && L"Connection has too many schedules");
    AttrValue av = a.setValue(0);

    PSCHEDULE header = (PSCHEDULE)(av.value);
    PBYTE data = ((unsigned char*) header) + header->Schedules[0].Offset;

    Assert( header->NumberOfSchedules == 1 );
    Assert( header->Schedules[0].Type == SCHEDULE_INTERVAL );

    const bitset<MAX_INTERVALS> bs = s->getBitset();
    int bs_index = 0;

    // and modify the lowest 4 bits of the data values as needed
    for (int i=0; i<7; i++) {
        for (int j=0; j<24; j++) {
            int hour_data = 0;

            // convert 4 bits from the bitset into a word
            int or_fac = 1;
            for (int k=0; k<4; k++) {
                if (bs[bs_index++] == true) {
                    hour_data |= or_fac;
                }
                or_fac *= 2;
            }

        // set the lowest four bits
            *data = *data & (~0xf);
            *data = *data | hour_data;
            data++;
        }
    }
}


Connection :: ~Connection (
    ) {
    /*++
    Routine Description:
        A standard destructor for a connection object
    --*/
    
    if (m_repl_schedule) {
        delete m_repl_schedule;
    }

    if (m_avail_schedule) {
        delete m_avail_schedule;
    }
}


void
Connection :: createNcReasons (
    IN NtdsDsa &ntds_source,
    IN NtdsDsa &ntds_dest,
    IN const wstring &root_dn
    ) {
    /*++
    Routine Description:
    
        Populate the NC Reasons attribute
        
    Arguments:
    
        ntds_source - the source NtdsDsa object
        ntds_dest - the destination NtdsDsa object
        root_dn - the root FQDN
    --*/

    vector<Nc> reasons_source = ntds_source.getHostedNcs(root_dn);
    vector<Nc> reasons_dest = ntds_dest.getHostedNcs(root_dn);
    vector<Nc> reasons_nc;

    sort (reasons_source.begin(), reasons_source.end());
    sort (reasons_dest.begin(), reasons_dest.end());

    vector<Nc>::iterator si = reasons_source.begin();
    vector<Nc>::iterator di = reasons_dest.begin();
    LbToolOptions lbOpts = GetGlobalOptions();

    while (si != reasons_source.end() && di != reasons_dest.end()) {
        int ret = _wcsicoll (si->getNcName().c_str(), di->getNcName().c_str());

        // not comparing same nc
        if (ret) {
            if (*si < *di) {
                si++;
            } else {
                di++;
            }
            continue;
        }

        // find info being replicated, and add nc
        bool writeable = di->isWriteable();
        bool going = false;
        TransportType tt = si->getTransportType();
        reasons_nc.push_back (Nc(si->getNcName(), writeable, going, tt));
        si++;
        di++;
    }

    vector<Nc>::iterator ni;

    Attribute a  (L"mS-DS-ReplicatesNCReason");
    
    for (ni = reasons_nc.begin(); ni != reasons_nc.end(); ni++) {
        wstring wreason = ni->getString();
        PBYTE value = (PBYTE)_wcsdup (wreason.c_str());
        int size = (wreason.length() + 1) * sizeof (WCHAR);
        AttrValue av(value, size);
        a.addValue(av);
    }
    addAttribute(a);

    if (lbOpts.showInput) {
        *lbOpts.log << (*this) << endl;
    }
}




Server :: Server (
    IN const wstring &dn
    ) : LdapObject(dn) {
    /*++
    Routine Description:
    
        Standard constructor for a server object
    --*/

    m_preferred_ip = false;
    m_preferred_smtp = false;
}

NtdsDsa :: NtdsDsa (
    IN const wstring &dn
    ) : LdapObject (dn) {
    /*++
    Routine Description:
    
        Standard constructor for an ntdsdsa object
        
    --*/
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adprep\exe\adp.h ===
/*++

Copyright (C) Microsoft Corporation, 2001
              Microsoft Windows

Module Name:

    ADP.H

Abstract:

    This is the header file for domain/forest prepare.

Author:

    14-May-01 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    14-May-01 ShaoYin Created Initial File.

--*/

#ifndef _ADP_
#define _ADP_


#ifndef UNICODE
#define UNICODE
#endif // UNICODE


//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


//
// Windows Headers
//
#include <windows.h>
#include <winerror.h>
#include <rpc.h>
#include <winldap.h>

//
// C-Runtime Header
//
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>


//
// localization
// 
#include <locale.h>


//
// internal header
// 
#include "adpcheck.h"




//
// define debug flags
//

#define ADP_DBG                 0
#define ADP_VERIFICATION_TEST   0


#if ADP_DBG
#define AdpDbgPrint(x)  printf x
#else
#define AdpDbgPrint(x)  
#endif 



#define MAXDWORD        (~(DWORD)0)



//
// define valid input object name format
//

// define valid prefix
#define ADP_OBJNAME_NONE                     0x00000001
#define ADP_OBJNAME_CN                       0x00000002
#define ADP_OBJNAME_GUID                     0x00000004
#define ADP_OBJNAME_SID                      0x00000008

#define ADP_OBJNAME_PREFIX_MASK             (ADP_OBJNAME_NONE |   \
                                             ADP_OBJNAME_CN   |   \
                                             ADP_OBJNAME_GUID |   \
                                             ADP_OBJNAME_SID )


// define valid suffix
#define ADP_OBJNAME_DOMAIN_NC                0x00000100
#define ADP_OBJNAME_CONFIGURATION_NC         0x00000200
#define ADP_OBJNAME_SCHEMA_NC                0x00000400
#define ADP_OBJNAME_DOMAIN_PREP_OP           0x00001000
#define ADP_OBJNAME_FOREST_PREP_OP           0x00002000

#define ADP_OBJNAME_SUFFIX_MASK      ( ADP_OBJNAME_DOMAIN_NC        |   \
                                       ADP_OBJNAME_CONFIGURATION_NC |   \
                                       ADP_OBJNAME_SCHEMA_NC        |   \
                                       ADP_OBJNAME_DOMAIN_PREP_OP   |   \
                                       ADP_OBJNAME_FOREST_PREP_OP )

                                    

//
// add or remove ACE (used in global.c to describe the operation needs to be conducted) 
// 
#define ADP_ACE_ADD                     0x00000001
#define ADP_ACE_DEL                     0x00000002


//
// used in AdpMergeSecurityDescriptors() to determine when should add or remove an ACE
//
#define ADP_COMPARE_OBJECT_GUID_ONLY     0x00000001


//
// define flags for message output routine
//
#define ADP_STD_OUTPUT                  0x00000001
#define ADP_DONT_WRITE_TO_LOG_FILE      0x00000002          
#define ADP_DONT_WRITE_TO_STD_OUTPUT    0x00000004


//
// log file name
//
#define ADP_LOG_FILE_NAME       L"ADPrep.log"

//
// scheme file name
// 
#define ADP_SCHEMA_INI_FILE_NAME    L"schema.ini"

//
// data file name
// 
#define ADP_DISP_DCPROMO_CSV    L"dcpromo.csv"
#define ADP_DISP_409_CSV        L"409.csv"

//
// log/data directory path
//
#define ADP_LOG_DIR_PART1   L"\\debug"
#define ADP_LOG_DIR_PART2   L"\\adprep"
#define ADP_LOG_DIR_PART3   L"\\logs"
#define ADP_LOG_DIRECTORY   L"\\debug\\adprep\\logs\\"
#define ADP_DATA_DIRECTORY  L"\\debug\\adprep\\data"        // note: no the last backslash 


//
// Wellknown (global) Name for adprep Mutex 
// this mutex is used to control one and only one instance of adprep.exe 
// is running at any given time on a given DC
// 
#define ADP_MUTEX_NAME                          L"Global\\ADPREP is running"
#define ADP_MUTEX_NAME_WITHOUT_GLOBAL_PREFIX    L"ADPREP is running"



// Define registry section and value
#define ADP_SCHEMAUPDATEALLOWED         L"Schema Update Allowed"
#define ADP_DSA_CONFIG_SECTION          L"System\\CurrentControlSet\\Services\\NTDS\\Parameters"
#define ADP_SCHEMA_VERSION              L"Schema Version"
#define ADP_SCHEMAUPDATEALLOWED_WHOLE_PATH  L"System\\CurrentControlSet\\Services\\NTDS\\Parameters\\Schema Update Allowed"


//
// Define a Macro for ARRAY Counts
//
#define ARRAY_COUNT(x)      (sizeof(x)/sizeof(x[0]))





//
// Each operation code maps to a primitive. 
// Note: the first item has to be 0, because we will use operation code 
//       to the primitive routine
//

typedef enum _OPERATION_CODE {
    CreateObject = 0,
    AddMembers,
    AddRemoveAces,
    SelectivelyAddRemoveAces,
    ModifyDefaultSd,
    ModifyAttrs,
    CallBackFunc,
    SpecialTask,
} OPERATION_CODE;


//
// object name structure
//

typedef struct _OBJECT_NAME {
    ULONG       ObjNameFlags;
    PWCHAR      ObjCn;
    GUID        * ObjGuid;
    PWCHAR      ObjSid;
} OBJECT_NAME, *POBJECT_NAME;


//
// attribute list structure
//

typedef struct _ATTR_LIST {
    ULONG       AttrOp;
    PWCHAR      AttrType;
    PWCHAR      StringValue;
} ATTR_LIST, *PATTR_LIST;


//
// ACEs list
//

typedef struct _ACE_LIST {
    ULONG       AceOp;
    PWCHAR      StringAce;
} ACE_LIST, *PACE_LIST;


//
// progress function
//

typedef void (*progressFunction)(long arg, void *calleeStruct);

//
// prototype for call back function
//

typedef HRESULT (*AdpUpgradeCallBack)(PWSTR logFilesPath,
                                      GUID  *OperationGuid,
                                      BOOL  dryRun,
                                      PWSTR *errorMsg,
                                      void *calleeStruct,
                                      progressFunction stepIt,
                                      progressFunction totalSteps
                                      );

//
// declaration of Display Specifier Upgrade routine
//

HRESULT 
UpgradeDisplaySpecifiers 
(
    PWSTR logFilesPath,
    GUID *operationGuid,
    BOOL dryRun,
    PWSTR *errorMsg,
    void *caleeStruct,
    progressFunction stepIt,
    progressFunction totalSteps
);


HRESULT 
UpgradeGPOSysvolLocation 
(
    PWSTR               logFilesPath,
    GUID               *operationGuid,
    BOOL                dryRun,
    PWSTR              *errorMsg,
    void               *caleeStruct,
    progressFunction    stepIt,
    progressFunction    totalSteps
);



//
// operations which can't be implemented by primitive 
//

typedef enum _SPECIAL_TASK {
    PreWindows2000Group = 1,
} SPECIAL_TASK;


//
// structure to describe an operation
// an operation is consisted of tasks, the task tables contains all tasks 
// of an operation
//

typedef struct _TASK_TABLE {
    OBJECT_NAME * TargetObjName;
    OBJECT_NAME * MemberObjName;
    PWCHAR      TargetObjectStringSD;
    ATTR_LIST   * AttrList;
    ULONG       NumOfAttrs;
    ACE_LIST    * AceList;
    ULONG       NumOfAces;
    AdpUpgradeCallBack  AdpCallBackFunc;
    SPECIAL_TASK SpecialTaskCode;
} TASK_TABLE, *PTASK_TABLE;



//
//
//

typedef struct _OPERATION_TABLE {
    OPERATION_CODE  OperationCode;     // primitive 
    GUID            * OperationGuid;
    TASK_TABLE      * TaskTable;
    ULONG           NumOfTasks;
    BOOLEAN         fIgnoreError;   // indicate if this operation fails, 
                                    // whether to ignore the error and continue,
                                    // or to stop and exit
    ULONG           ExpectedWinErrorCode;   // expected Win32 error code 
} OPERATION_TABLE, *POPERATION_TABLE;



//
// prototype of primivates
//

typedef ULONG (*PRIMITIVE_FUNCTION)(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    );


ULONG
PrimitiveCreateObject(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    );

ULONG
PrimitiveAddMembers(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    );

ULONG
PrimitiveAddRemoveAces(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    );

ULONG
PrimitiveSelectivelyAddRemoveAces(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    );

ULONG
PrimitiveModifyDefaultSd(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    );

ULONG
PrimitiveModifyAttrs(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    );

ULONG
PrimitiveCallBackFunc(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    );

ULONG
PrimitiveDoSpecialTask(
    OPERATION_TABLE *OperationTable,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    );


//
// global variables
//


// ldap handle (connect to the local host DC)
extern LDAP    *gLdapHandle;

// log file
extern FILE    *gLogFile;

// mutex - controls one and only one adprep.exe is running 
extern HANDLE  gMutex;


// critical section - used to access Console CTRL signal variables
extern CRITICAL_SECTION     gConsoleCtrlEventLock;
extern BOOL                 gConsoleCtrlEventLockInitialized;

// Console CTRL signal variable
extern BOOL                 gConsoleCtrlEventReceived;


extern PWCHAR  gDomainNC;
extern PWCHAR  gConfigurationNC;
extern PWCHAR  gSchemaNC;
extern PWCHAR  gDomainPrepOperations;
extern PWCHAR  gForestPrepOperations;
extern PWCHAR  gLogPath;

extern POPERATION_TABLE     gDomainOperationTable;
extern ULONG                gDomainOperationTableCount;

extern POPERATION_TABLE     gForestOperationTable;
extern ULONG                gForestOperationTableCount;


extern PRIMITIVE_FUNCTION   *gPrimitiveFuncTable;
extern ULONG   gPrimitiveFuncTableCount;


extern PWCHAR  *gDomainPrepContainers;
extern ULONG   gDomainPrepContainersCount;

extern PWCHAR  *gForestPrepContainers;
extern ULONG   gForestPrepContainersCount;






//
// internal used routines
//

ULONG
AdpCreateObjectDn(
    IN ULONG Flags,
    IN PWCHAR ObjCn,
    IN GUID   *ObjGuid,
    IN PWCHAR StringSid,
    OUT PWCHAR *ppObjDn,
    OUT ERROR_HANDLE *ErrorHandle
    );


ULONG
AdpIsOperationComplete(
    IN LDAP    *LdapHandle,
    IN PWCHAR  pObjDn,
    IN BOOLEAN *fExist,
    OUT ERROR_HANDLE *ErrorHandle
    );


ULONG
AdpCreateContainerByDn(
    LDAP    *LdapHandle, 
    PWCHAR  ObjDn,
    ERROR_HANDLE *ErrorHandle
    );


ULONG
AdpBuildAceList(
    TASK_TABLE *TaskTable,
    PWCHAR  * AcesToAdd,
    PWCHAR  * AcesToRemove
    );



ULONG
AdpLogMsg(
    ULONG Flags,
    ULONG MessageId,
    PWCHAR Parm1,
    PWCHAR Parm2
    );

ULONG
AdpLogErrMsg(
    ULONG Flags,
    ULONG MessageId,
    ERROR_HANDLE *ErrorHandle,
    PWCHAR Parm1,
    PWCHAR Parm2
    );

VOID
AdpTraceLdapApiStart(
    ULONG Flags,
    ULONG LdapApiId,
    LPWSTR pObjectDn
    );

VOID
AdpTraceLdapApiEnd(
    ULONG Flags,
    LPWSTR LdapApiName,
    ULONG LdapError
    );

     
ULONG
BuildAttrList(
    IN TASK_TABLE *TaskTable, 
    IN PSECURITY_DESCRIPTOR SD,
    IN ULONG SDLength,
    OUT LDAPModW ***AttrList
    );

VOID
FreeAttrList(
    LDAPModW    **AttrList
    );


ULONG
AdpGetObjectSd(
    IN LDAP *LdapHandle,
    IN PWCHAR pObjDn, 
    OUT PSECURITY_DESCRIPTOR *Sd,
    OUT ULONG *SdLength,
    OUT ERROR_HANDLE *ErrorHandle
    );


ULONG
AdpSetObjectSd(
    IN LDAP *LdapHandle,
    IN PWCHAR pObjDn, 
    IN PSECURITY_DESCRIPTOR Sd,
    IN ULONG SdLength,
    IN SECURITY_INFORMATION SeInfo,
    OUT ERROR_HANDLE *ErrorHandle
    );


ULONG
AdpMergeSecurityDescriptors(
    IN PSECURITY_DESCRIPTOR OrgSd, 
    IN PSECURITY_DESCRIPTOR SdToAdd,
    IN PSECURITY_DESCRIPTOR SdToRemove,
    IN ULONG Flags,
    OUT PSECURITY_DESCRIPTOR *NewSd,
    OUT ULONG   *NewSdLength
    );

ULONG
AdpAddRemoveAcesWorker(
    OPERATION_TABLE *OperationTable,
    ULONG Flags,
    TASK_TABLE *TaskTable,
    ERROR_HANDLE *ErrorHandle
    );

ULONG
AdpGetRegistryKeyValue(
    OUT ULONG *RegKeyValue, 
    ERROR_HANDLE *ErrorHandle
    );

ULONG
AdpSetRegistryKeyValue(
    ULONG RegKeyValue,
    ERROR_HANDLE *ErrorHandle
    );

ULONG
AdpCleanupRegistry(
    ERROR_HANDLE *ErrorHandle
    );

ULONG
AdpRestoreRegistryKeyValue(
    BOOL OriginalKeyValueStored, 
    ULONG OriginalKeyValue, 
    ERROR_HANDLE *ErrorHandle
    );

BOOLEAN
AdpUpgradeSchema(
    ERROR_HANDLE *ErrorHandle
    );

ULONG
AdpDetectSFUInstallation(
    IN LDAP *LdapHandle,
    OUT BOOLEAN *fSFUInstalled,
    OUT ERROR_HANDLE *ErrorHandle
    );

ULONG
AdpSetLdapSingleStringValue(
    IN LDAP *LdapHandle,
    IN PWCHAR pObjDn,
    IN PWCHAR pAttrName,
    IN PWCHAR pAttrValue,
    OUT ERROR_HANDLE *ErrorHandle
    );





#endif      // _ADP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adprep\exe\adputil.c ===
/*++

Copyright (C) Microsoft Corporation, 2001
              Microsoft Windows

Module Name:

    ADPUTIL.C

Abstract:

    This file contains misc routines that implement adprep.exe

Author:

    14-May-01 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    14-May-01 ShaoYin Created Initial File.

--*/




//////////////////////////////////////////////////////////////////////////
//                                                                      //
//    Include header files                                              //
//                                                                      //
//////////////////////////////////////////////////////////////////////////



#include "adp.h"

#include <ntldap.h>             // LDAP_SERVER_SD_FLAGS_OID_W,
#include <seopaque.h>           // PACE_HEADER
#include <permit.h>             // DS_GENERIC_MAPPING


#include "adpmsgs.h"



ULONG
AdpLogMsg(
    ULONG Flags,
    ULONG MessageId,
    PWCHAR  Parm1,
    PWCHAR  Parm2
    )
{
    HMODULE Resource = NULL;
    ULONG   Length = 0;
    PWCHAR  AdpMsg = NULL;
    PWCHAR  ArgArray[3];

    //
    // create ADP Message
    //
    Resource = (HMODULE) LoadLibraryW( L"adprep.exe" );

    if (NULL == Resource)
    {
        goto Error;
    }

    ArgArray[0] = Parm1;
    ArgArray[1] = Parm2;
    ArgArray[2] = NULL;

    Length = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            Resource,
                            MessageId, 
                            0, 
                            (LPWSTR) &AdpMsg,
                            0,
                            (va_list *) &(ArgArray)
                            );

    if ( (0 == Length) || (NULL == AdpMsg) )
    {
        goto Error;
    }

    // 
    //  Messages from a message file have a cr and lf appended to the end
    // 
    AdpMsg[ Length - 2 ] = L'\0';



    // write to console
    if (Flags & ADP_STD_OUTPUT)
    {
        printf("%ls\n\n\n\n", AdpMsg);
    }


    // write to lgo file
    if ( !(Flags & ADP_DONT_WRITE_TO_LOG_FILE) &&
         NULL != gLogFile )
    {
        fwprintf( gLogFile, L"%s\n\n\n\n", AdpMsg );
        fflush( gLogFile );
    }


Error:

    if ( AdpMsg )
        LocalFree( AdpMsg );

    if ( NULL != Resource )
        FreeLibrary( Resource );

    return( ERROR_SUCCESS ); 
}

ULONG
AdpLogErrMsg(
    ULONG Flags,
    ULONG MessageId,
    ERROR_HANDLE *ErrorHandle,
    PWCHAR  Parm1,
    PWCHAR  Parm2
    )
{
    HMODULE Resource = NULL;
    ULONG   Length = 0;
    PWCHAR  AdpMsg = NULL;
    PWCHAR  ErrorInfo = NULL;
    PWCHAR  ArgArray[4];
    WCHAR   WinErrorCode[20];
    WCHAR   LdapErrorCode[20];
    WCHAR   LdapServerExtErrorCode[20];

    //
    // create ADP Message
    //
    Resource = (HMODULE) LoadLibraryW( L"adprep.exe" );

    if (NULL == Resource)
    {
        goto Error;
    }                            

    ArgArray[0] = Parm1;
    ArgArray[1] = Parm2;
    ArgArray[2] = NULL;
    ArgArray[3] = NULL;

    Length = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            Resource,
                            MessageId, 
                            0, 
                            (LPWSTR) &AdpMsg,
                            0,
                            (va_list *) &(ArgArray)
                            );

    if ( (0 == Length) || (NULL == AdpMsg) )
    {
        goto Error;
    }

    // 
    //  Messages from a message file have a cr and lf appended to the end
    // 
    AdpMsg[ Length - 2 ] = L'\0';

    // write to console
    if ( !(Flags & ADP_DONT_WRITE_TO_STD_OUTPUT) )
    {
        printf("%ls\n\n", AdpMsg);
    }

    // write to lgo file
    if ( !(Flags & ADP_DONT_WRITE_TO_LOG_FILE) &&
         NULL != gLogFile )
    {
        fwprintf( gLogFile, L"%s\n\n", AdpMsg );
        fflush( gLogFile );
    }

    //
    // next, log error information
    //

    if (ADP_WIN_ERROR & ErrorHandle->Flags)
    {
        ASSERT(0 == (ADP_LDAP_ERROR & ErrorHandle->Flags));

        _ultow(ErrorHandle->WinErrorCode, WinErrorCode, 16);
        ArgArray[0] = WinErrorCode; 
        ArgArray[1] = ErrorHandle->WinErrorMsg;
        ArgArray[2] = NULL;
        ArgArray[3] = NULL;

        Length = 0;
        Length = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                Resource,
                                ADP_ERROR_WIN_ERROR,
                                0, 
                                (LPWSTR) &ErrorInfo,
                                0,
                                (va_list *) &(ArgArray)
                                );

    }
    else
    {
        ASSERT(0 != (ADP_LDAP_ERROR & ErrorHandle->Flags));

        _ultow(ErrorHandle->LdapErrorCode, LdapErrorCode, 16);
        _ultow(ErrorHandle->LdapServerExtErrorCode, LdapServerExtErrorCode, 16);
        ArgArray[0] = LdapErrorCode; 
        ArgArray[1] = LdapServerExtErrorCode;
        ArgArray[2] = ErrorHandle->LdapServerErrorMsg;
        ArgArray[3] = NULL;

        Length = 0;
        Length = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                Resource,
                                ADP_ERROR_LDAP_ERROR,
                                0, 
                                (LPWSTR) &ErrorInfo,
                                0,
                                (va_list *) &(ArgArray)
                                );
    }

    if ( (0 == Length) || (NULL == ErrorInfo) )
    {
        goto Error;
    }

    // 
    //  Messages from a message file have a cr and lf appended to the end
    // 
    ErrorInfo[ Length - 2 ] = L'\0';



    // write to console
    if ( !(Flags & ADP_DONT_WRITE_TO_STD_OUTPUT) )
    {
        printf("%ls\n\n\n\n", ErrorInfo);
    }

    // write to lgo file
    if ( !(Flags & ADP_DONT_WRITE_TO_LOG_FILE) &&
         NULL != gLogFile )
    {
        fwprintf( gLogFile, L"%s\n\n\n\n", ErrorInfo );
        fflush( gLogFile );
    }
    


Error:

    if ( AdpMsg )
    {
        LocalFree( AdpMsg );
    }

    if (ErrorInfo)
    {
        LocalFree( ErrorInfo );
    }

    if ( NULL != Resource )
    {
        FreeLibrary( Resource );
    }

    // error has been logged, clear it
    AdpClearError( ErrorHandle );

    return( ERROR_SUCCESS ); 
}

VOID
AdpTraceLdapApiStart(
    ULONG Flags,
    ULONG LdapApiId,
    LPWSTR pObjectDn
    )
/*++
Routine Descption:

    This routine logs which LDAP API has been called and the target object DN

Parameters:

    Flags 
    LdapApiId
    pObjectDn

Return Values:
    None

--*/
{
    HMODULE Resource = NULL;
    ULONG   Length = 0;
    PWCHAR  TraceInfo = NULL;
    PWCHAR  LdapApiInfo = NULL;
    PWCHAR  ArgArray[2];

    //
    // load resource
    //
    Resource = (HMODULE) LoadLibraryW( L"adprep.exe" );
    if (NULL == Resource)
    {
        goto Error;
    }                            

    // create LDAP API info
    ArgArray[0] = pObjectDn;
    ArgArray[1] = NULL;

    Length = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            Resource,
                            LdapApiId,
                            0, 
                            (LPWSTR) &LdapApiInfo,
                            0,
                            (va_list *) &(ArgArray)
                            );


    if ( (0 == Length) || (NULL == LdapApiInfo) )
    {
        goto Error;
    }

    //  Messages from a message file have a cr and lf appended to the end
    LdapApiInfo[ Length - 2 ] = L'\0';

    ArgArray[0] = LdapApiInfo;
    ArgArray[1] = NULL;

    Length = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            Resource,
                            ADP_INFO_TRACE_LDAP_API_START,
                            0, 
                            (LPWSTR) &TraceInfo,
                            0,
                            (va_list *) &(ArgArray)
                            );

    if ( (0 == Length) || (NULL == TraceInfo) )
    {
        goto Error;
    }

    //  Messages from a message file have a cr and lf appended to the end
    TraceInfo[ Length - 2 ] = L'\0';

    // write to lgo file
    if ( !(Flags & ADP_DONT_WRITE_TO_LOG_FILE) &&
         NULL != gLogFile )
    {
        fwprintf( gLogFile, L"%s\n\n\n\n", TraceInfo );
        fflush( gLogFile );
    }
    

Error:

    if ( TraceInfo )
    {
        LocalFree( TraceInfo );
    }

    if (LdapApiInfo)
    {
        LocalFree( LdapApiInfo );
    }

    if ( NULL != Resource )
    {
        FreeLibrary( Resource );
    }

}

VOID
AdpTraceLdapApiEnd(
    ULONG Flags,
    LPWSTR LdapApiName,
    ULONG LdapError
    )
/*++
Routine Description:

    This routine logs LdapApi return value and indicates ldap call returns 

Parameter:

    Flags
    LdapApiName
    LdapError

Return Value:
    None

--*/
{
    HMODULE Resource = NULL;
    ULONG   Length = 0;
    PWCHAR  TraceInfo = NULL;
    WCHAR   LdapErrorCode[20];
    PWCHAR  ArgArray[3];

    //
    // load resource
    //
    Resource = (HMODULE) LoadLibraryW( L"adprep.exe" );
    if (NULL == Resource)
    {
        goto Error;
    }                            

    // create LDAP API info
    _ultow(LdapError, LdapErrorCode, 16);
    ArgArray[0] = LdapApiName;
    ArgArray[1] = LdapErrorCode;
    ArgArray[2] = NULL;

    Length = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            Resource,
                            ADP_INFO_TRACE_LDAP_API_END,
                            0, 
                            (LPWSTR) &TraceInfo,
                            0,
                            (va_list *) &(ArgArray)
                            );

    if ( (0 == Length) || (NULL == TraceInfo) )
    {
        goto Error;
    }

    //  Messages from a message file have a cr and lf appended to the end
    TraceInfo[ Length - 2 ] = L'\0';

    // write to lgo file
    if ( !(Flags & ADP_DONT_WRITE_TO_LOG_FILE) &&
         NULL != gLogFile )
    {
        fwprintf( gLogFile, L"%s\n\n\n\n", TraceInfo );
        fflush( gLogFile );
    }
    

Error:

    if ( TraceInfo )
    {
        LocalFree( TraceInfo );
    }

    if ( NULL != Resource )
    {
        FreeLibrary( Resource );
    }

}







ULONG
AdpGetDnFromSid(
    IN PWCHAR  StringSid,
    OUT PWCHAR *ppObjDn
    )
/*++
Routine Description;

    get objectDN by object SID
    
Parameters:

    StingSid

Return Value:

    Win32 error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   LdapError = LDAP_SUCCESS;
    PWCHAR  AttrList[2];
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    PWCHAR  *Dn_Value = NULL;

    AttrList[0] = L"Dn";
    AttrList[1] = NULL;

    // String SID should be <SID=S-1-5-xxxxxx>
    AdpTraceLdapApiStart(0, ADP_INFO_LDAP_SEARCH, StringSid);
    LdapError = ldap_search_sW(gLdapHandle,
                               StringSid,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               AttrList,
                               0,
                               &Result
                               );
    AdpTraceLdapApiEnd(0, L"ldap_search_s()", LdapError);

    if ((LDAP_SUCCESS == LdapError) &&
        (NULL != Result) &&
        (Entry = ldap_first_entry(gLdapHandle,Result)) &&
        (Dn_Value = ldap_get_valuesW(gLdapHandle,Entry,AttrList[0])) )
    {
        ULONG   len = 0;

        len = (wcslen(*Dn_Value) + 1) * sizeof(WCHAR);
        *ppObjDn = AdpAlloc( len );

        if (*ppObjDn)
        {
            wcscpy(*ppObjDn, *Dn_Value);
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        WinError = LdapMapErrorToWin32( LdapGetLastError() );
    }

    if (Dn_Value)
        ldap_value_free( Dn_Value );

    if (Result)
        ldap_msgfree( Result );

    return( WinError );
}



ULONG
AdpCreateObjectDn(
    IN ULONG Flags,
    IN PWCHAR ObjCn,
    IN GUID   *ObjGuid,
    IN PWCHAR StringSid,
    OUT PWCHAR *ppObjDn,
    OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    construct object DN
    
Parameters:


Return Value:

    Win32 error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    PWCHAR  pStringGuid = NULL;
    PWCHAR  pPrefix = NULL;
    PWCHAR  pSuffix = NULL;
    ULONG   Length = 0;

    *ppObjDn = NULL;

    switch( Flags & ADP_OBJNAME_PREFIX_MASK )
    {
    case ADP_OBJNAME_CN:

        pPrefix = ObjCn;
        break;

    case ADP_OBJNAME_GUID:
        WinError = UuidToStringW((UUID *)ObjGuid, (PWCHAR *)&pStringGuid);

        if (RPC_S_OK != WinError)
        {
            goto Error;
        }

        Length = (wcslen(pStringGuid) + wcslen(L"cn=") + 1) * sizeof(WCHAR); 

        pPrefix = AdpAlloc( Length ); 

        if (NULL == pPrefix)
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        if ( 0 > _snwprintf(pPrefix, (Length/sizeof(WCHAR))-1 , L"cn=%s", pStringGuid) )
        {
            WinError = ERROR_INVALID_PARAMETER;
            goto Error;
        }

        break;

    case ADP_OBJNAME_SID:

        WinError = AdpGetDnFromSid(StringSid, ppObjDn);
        if (ERROR_SUCCESS != WinError) {
            goto Error;
        }
                
    case ADP_OBJNAME_NONE:
        break;

    default:

        WinError = ERROR_INVALID_PARAMETER;
        goto Error;
    }

    switch (Flags & ADP_OBJNAME_SUFFIX_MASK)
    {
    case ADP_OBJNAME_DOMAIN_NC:
        pSuffix = gDomainNC;
        break;

    case ADP_OBJNAME_CONFIGURATION_NC:
        pSuffix = gConfigurationNC;
        break;

    case ADP_OBJNAME_SCHEMA_NC:
        pSuffix = gSchemaNC;
        break;

    case ADP_OBJNAME_DOMAIN_PREP_OP:
        pSuffix = gDomainPrepOperations;
        break;

    case ADP_OBJNAME_FOREST_PREP_OP:
        pSuffix = gForestPrepOperations;
        break;

    default:

        WinError = ERROR_INVALID_PARAMETER;
        goto Error;
    }

    if (pPrefix)
    {
        Length += wcslen(pPrefix) * sizeof(WCHAR);
    }

    if (pSuffix)
    {
        Length += wcslen(pSuffix) * sizeof(WCHAR);
    }

    // 1 wchar for the RDN separator, 1 wchar for the ending terminator
    Length += 2 * sizeof(WCHAR);    


    *ppObjDn = AdpAlloc( Length );

    if (NULL == *ppObjDn)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        if (pPrefix)
        {
            if ( 0 > _snwprintf(*ppObjDn, (Length/sizeof(WCHAR)-1), L"%s,%s", pPrefix, pSuffix) )
            {
                WinError = ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            wcscpy(*ppObjDn, pSuffix);
        }
    }

Error:

    if (pStringGuid)
    {
        RpcStringFreeW(&pStringGuid);
        pStringGuid = NULL;
    }

    if (pPrefix && pPrefix != ObjCn)
    {
        AdpFree( pPrefix );
        pPrefix = NULL;

    }

    if ( ERROR_SUCCESS != WinError )
    {
        AdpSetWinError(WinError, ErrorHandle);
        AdpLogErrMsg(0, ADP_ERROR_CONSTRUCT_DN, ErrorHandle, NULL, NULL);
    }

    return( WinError );
}

ULONG
AdpSetLdapSingleStringValue(
    IN LDAP *LdapHandle,
    IN PWCHAR pObjDn,
    IN PWCHAR pAttrName,
    IN PWCHAR pAttrValue,
    OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    set single string-value attribute value
    
Parameters:
    
    LdapHandle
    pObjDn
    pAttrName
    pAttrValue
    ErrorHandle

Return Value:

    Win32 error

--*/
{
    ULONG       LdapError = LDAP_SUCCESS;
    LDAPModW    *Attrs[2];
    LDAPModW    Attr_1;
    PWCHAR      Pointers[2];


    Attr_1.mod_op = LDAP_MOD_REPLACE;
    Attr_1.mod_type = pAttrName;
    Attr_1.mod_values = Pointers;
    Attr_1.mod_values[0] = pAttrValue;
    Attr_1.mod_values[1] = NULL;

    Attrs[0] = &Attr_1;
    Attrs[1] = NULL;
    
    AdpTraceLdapApiStart(0, ADP_INFO_LDAP_MODIFY, pObjDn);
    LdapError = ldap_modify_sW(LdapHandle,
                               pObjDn,
                               Attrs
                               );
    AdpTraceLdapApiEnd(0, L"ldap_modify_s()", LdapError);

    if (LDAP_SUCCESS != LdapError)
    {
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
    }

    return( LdapMapErrorToWin32(LdapError) );
}





ULONG
BuildAttrList(
    IN TASK_TABLE *TaskTable, 
    IN PSECURITY_DESCRIPTOR SD,
    IN ULONG SDLength,
    OUT LDAPModW ***AttrList
    )
/*++
Routine Description;

    build attribute list
    
Parameters:


Return Value:

    Win32 error

--*/
{

    ULONG   WinError = ERROR_SUCCESS;
    ULONG   NumOfAttrs = 0, Index = 0, BufSize = 0;


    *AttrList = NULL;

    NumOfAttrs = TaskTable->NumOfAttrs + 1;

    if (SD)
    {
        NumOfAttrs ++;
    }

    if (0 == NumOfAttrs)
    {
        return( ERROR_SUCCESS );
    }

    *AttrList = AdpAlloc( NumOfAttrs * sizeof(LDAPModW *) );

    if (NULL == *AttrList)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    for (Index = 0; Index < TaskTable->NumOfAttrs; Index++)
    {
        (*AttrList)[Index] = (LDAPModW *) AdpAlloc( sizeof(LDAPModW) );
        if (NULL == (*AttrList)[Index])
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }
        ((*AttrList)[Index])->mod_op = TaskTable->AttrList[Index].AttrOp;
        ((*AttrList)[Index])->mod_type = TaskTable->AttrList[Index].AttrType;
        ((*AttrList)[Index])->mod_values = AdpAlloc( 2 * sizeof(PWCHAR) );
        if (NULL == ((*AttrList)[Index])->mod_values)
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }
        ((*AttrList)[Index])->mod_values[0] = TaskTable->AttrList[Index].StringValue;
        ((*AttrList)[Index])->mod_values[1] = NULL;
    }

    if (SD)
    {
        (*AttrList)[Index] = (LDAPModW *) AdpAlloc( sizeof(LDAPModW) );
        if (NULL == (*AttrList)[Index])
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }
        ((*AttrList)[Index])->mod_op = LDAP_MOD_ADD | LDAP_MOD_BVALUES;
        ((*AttrList)[Index])->mod_type = L"nTSecurityDescriptor";
        ((*AttrList)[Index])->mod_bvalues = (LDAP_BERVAL **) AdpAlloc( 2 * sizeof(LDAP_BERVAL *) );
        if (NULL == ((*AttrList)[Index])->mod_bvalues)
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }
        ((*AttrList)[Index])->mod_bvalues[0] = AdpAlloc( sizeof(LDAP_BERVAL) );
        if (NULL == ((*AttrList)[Index])->mod_bvalues[0])
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }
        ((*AttrList)[Index])->mod_bvalues[0]->bv_val = (char *) SD;
        ((*AttrList)[Index])->mod_bvalues[0]->bv_len = SDLength;
        ((*AttrList)[Index])->mod_bvalues[1] = NULL;

        Index ++;
    }

    (*AttrList)[Index] = NULL;

Error:

    return( WinError );
}


VOID
FreeAttrList(
    LDAPModW    **AttrList
    )
/*++
Routine Description;

    free attribute list
    
Parameters:


Return Value:

    Win32 error

--*/
{
    ULONG   Index = 0;

    if (AttrList)
    {
        while ( AttrList[Index] )
        {
            if ( (AttrList[Index])->mod_op & LDAP_MOD_BVALUES )
            {
                if ( (AttrList[Index])->mod_bvalues )
                {
                    if ( (AttrList[Index])->mod_bvalues[0] )
                    {
                        AdpFree( (AttrList[Index])->mod_bvalues[0] );
                    }
                    AdpFree( (AttrList[Index])->mod_bvalues );
                }
            }
            else
            {
                if ( (AttrList[Index])->mod_values )
                {
                    AdpFree( (AttrList[Index])->mod_values );
                }
            }

            AdpFree( AttrList[Index] );
            Index ++;
        }

        AdpFree( AttrList );
    }
}



ULONG
AdpBuildAceList(
    TASK_TABLE *TaskTable,
    PWCHAR  * AcesToAdd,
    PWCHAR  * AcesToRemove
    )
/*++
Routine Description;

    build ACE list
    
Parameters:


Return Value:

    Win32 error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   Index = 0;
    ULONG   NumOfAdd = 0, SizeOfAdd = 0;
    ULONG   NumOfDel = 0, SizeOfDel = 0;

    AdpDbgPrint(("AdpBuildAceList\n"));

    *AcesToAdd = NULL;
    *AcesToRemove = NULL;

    for (Index = 0; Index < TaskTable->NumOfAces; Index++)
    {
        if (ADP_ACE_ADD == TaskTable->AceList[Index].AceOp)
        {
            NumOfAdd ++;
            SizeOfAdd += wcslen(TaskTable->AceList[Index].StringAce) * sizeof(WCHAR);
        }
        else if (ADP_ACE_DEL == TaskTable->AceList[Index].AceOp)
        {
            NumOfDel ++;
            SizeOfDel += wcslen(TaskTable->AceList[Index].StringAce) * sizeof(WCHAR);
        }
        else
        {
            return( ERROR_INVALID_PARAMETER );
        }
    }


    if (NumOfAdd > 0)
    {
        SizeOfAdd += (wcslen(L"D:") + 1) * sizeof(WCHAR);

        *AcesToAdd = AdpAlloc( SizeOfAdd );

        if (NULL == *AcesToAdd)
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        wcscpy(*AcesToAdd, L"D:");

        for (Index = 0; Index < TaskTable->NumOfAces; Index++)
        {
            if (ADP_ACE_ADD == TaskTable->AceList[Index].AceOp)
            {
                wcscat(*AcesToAdd, TaskTable->AceList[Index].StringAce);
            }
        }
    }

    if (NumOfDel > 0)
    {
        SizeOfDel += (wcslen(L"D:") + 1) * sizeof(WCHAR);

        *AcesToRemove = AdpAlloc( SizeOfDel );

        if (NULL == *AcesToRemove)
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        wcscpy(*AcesToRemove, L"D:");

        for (Index = 0; Index < TaskTable->NumOfAces; Index++)
        {
            if (ADP_ACE_DEL == TaskTable->AceList[Index].AceOp)
            {
                wcscat(*AcesToRemove, TaskTable->AceList[Index].StringAce);
            }
        }
    }


Error:

    if (ERROR_SUCCESS != WinError)
    {
        if (*AcesToAdd)
        {
            AdpFree(*AcesToAdd);
            *AcesToAdd = NULL;
        }

        if (*AcesToRemove)
        {
            AdpFree(*AcesToRemove);
            *AcesToRemove = NULL;
        }
    }

    return( WinError );
}






#if ADP_VERIFICATION_TEST

void DumpGUID (GUID *Guid)
{
    if ( Guid ) {

        printf( "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                     Guid->Data1, Guid->Data2, Guid->Data3, Guid->Data4[0],
                     Guid->Data4[1], Guid->Data4[2], Guid->Data4[3], Guid->Data4[4],
                     Guid->Data4[5], Guid->Data4[6], Guid->Data4[7] );
    }
}

void
DumpSID (PSID pSID)
{
    UNICODE_STRING StringSid;
    
    RtlConvertSidToUnicodeString( &StringSid, pSID, TRUE );
    printf( "%wZ", &StringSid );
    RtlFreeUnicodeString( &StringSid );
}

void
DumpAce(
    ACE_HEADER   *pAce
    )
{
    ACCESS_ALLOWED_ACE          *paaAce = NULL;   //initialized to avoid C4701 
    ACCESS_ALLOWED_OBJECT_ACE   *paaoAce = NULL;  //initialized to avoid C4701
    GUID                        *pGuid;
    PBYTE                       ptr;
    ACCESS_MASK                 mask;
    CHAR                        *name;
    CHAR                        *label;
    BOOL                        fIsClass;

    printf("\t\tAce Type:  0x%x - ", pAce->AceType);
#define DOIT(flag) if (flag == pAce->AceType) printf("%hs\n", #flag)
    DOIT(ACCESS_ALLOWED_ACE_TYPE);
    DOIT(ACCESS_DENIED_ACE_TYPE);
    DOIT(SYSTEM_AUDIT_ACE_TYPE);
    DOIT(SYSTEM_ALARM_ACE_TYPE);
    DOIT(ACCESS_ALLOWED_COMPOUND_ACE_TYPE);
    DOIT(ACCESS_ALLOWED_OBJECT_ACE_TYPE);
    DOIT(ACCESS_DENIED_OBJECT_ACE_TYPE);
    DOIT(SYSTEM_AUDIT_OBJECT_ACE_TYPE);
    DOIT(SYSTEM_ALARM_OBJECT_ACE_TYPE);
#undef DOIT

    printf("\t\tAce Size:  %d bytes\n", pAce->AceSize);

    printf("\t\tAce Flags: 0x%x\n", pAce->AceFlags);
#define DOIT(flag) if (pAce->AceFlags & flag) printf("\t\t\t%hs\n", #flag)
    DOIT(OBJECT_INHERIT_ACE);
    DOIT(CONTAINER_INHERIT_ACE);
    DOIT(NO_PROPAGATE_INHERIT_ACE);
    DOIT(INHERIT_ONLY_ACE);
    DOIT(INHERITED_ACE);
#undef DOIT

    if ( pAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {
        paaAce = (ACCESS_ALLOWED_ACE *) pAce;
        mask = paaAce->Mask;
        printf("\t\tAce Mask:  0x%08x\n", mask);
    }
    else
    {
        // object ACE
        paaoAce = (ACCESS_ALLOWED_OBJECT_ACE *) pAce;
        mask = paaoAce->Mask;
        printf("\t\tObject Ace Mask:  0x%08x\n", mask);
    }

#define DOIT(flag) if (mask & flag) printf("\t\t\t%hs\n", #flag)
    DOIT(DELETE);
    DOIT(READ_CONTROL);
    DOIT(WRITE_DAC);
    DOIT(WRITE_OWNER);
    DOIT(SYNCHRONIZE);
    DOIT(ACCESS_SYSTEM_SECURITY);
    DOIT(MAXIMUM_ALLOWED);
    DOIT(GENERIC_READ);
    DOIT(GENERIC_WRITE);
    DOIT(GENERIC_EXECUTE);
    DOIT(GENERIC_ALL);
    DOIT(ACTRL_DS_CREATE_CHILD);
    DOIT(ACTRL_DS_DELETE_CHILD);
    DOIT(ACTRL_DS_LIST);
    DOIT(ACTRL_DS_SELF);
    DOIT(ACTRL_DS_READ_PROP);
    DOIT(ACTRL_DS_WRITE_PROP);
    DOIT(ACTRL_DS_DELETE_TREE);
    DOIT(ACTRL_DS_LIST_OBJECT);
    DOIT(ACTRL_DS_CONTROL_ACCESS);
#undef DOIT

    if ( pAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {

            printf("\t\tAce Sid:");
            DumpSID ((PSID) &paaAce->SidStart);
            printf("\n");
    }
    else
    {
        // object ACE

        printf("\t\tObject Ace Flags: 0x%x\n" , paaoAce->Flags);

#define DOIT(flag) if (paaoAce->Flags & flag) printf("\t\t\t%hs\n", #flag)
        DOIT(ACE_OBJECT_TYPE_PRESENT);
        DOIT(ACE_INHERITED_OBJECT_TYPE_PRESENT);
#undef DOIT

        if ( paaoAce->Flags & ACE_OBJECT_TYPE_PRESENT )
        {
            printf("\t\tObject Ace Type: ");
            DumpGUID ((GUID *)&paaoAce->ObjectType);
            printf("\n");
        }

        if ( paaoAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT )
        {
            if ( paaoAce->Flags & ACE_OBJECT_TYPE_PRESENT )
                pGuid = &paaoAce->InheritedObjectType;
            else
                pGuid = &paaoAce->ObjectType;

            printf("\t\tInherited object type: ");
            DumpGUID (pGuid);
            printf("\n");
        }

        ptr = (PBYTE) &paaoAce->ObjectType;

        if ( paaoAce->Flags & ACE_OBJECT_TYPE_PRESENT )
            ptr += sizeof(GUID);

        if ( paaoAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT )
            ptr += sizeof(GUID);

        printf("\t\tObject Ace Sid:");
        DumpSID((PSID) ptr);
        printf("\n");
    }
}


void
DumpAclHeader(
    PACL    pAcl
    )
{
    printf("\tRevision      %d\n", pAcl->AclRevision);
    printf("\tSize:         %d bytes\n", pAcl->AclSize);
    printf("\t# Aces:       %d\n", pAcl->AceCount);
}

//
// Dump an ACL to stdout in all its glory.
//

void
DumpAcl(
    PACL    pAcl
    )
{
    DWORD                       dwErr;
    WORD                        i;
    ACE_HEADER                  *pAce;

    DumpAclHeader(pAcl);

    for ( i = 0; i < pAcl->AceCount; i++ )
    {
        printf("\tAce[%d]\n", i);

        if ( !GetAce(pAcl, i, (LPVOID *) &pAce) )
        {
            dwErr = GetLastError();
            printf("*** Error: GetAce ==> 0x%x - output incomplete\n",dwErr);
        }
        else
        {
            DumpAce(pAce);
        }
    }
}

#endif



ACCESS_MASK
AdpMaskFromAce(
    IN ACE_HEADER  *Ace
    )
/*++
Routine Description;

    get make from an ACE
    
Parameters:


Return Value:

    Access mask

--*/
{
    ACCESS_MASK     Mask;


    // depending on the type of the ace extract mask from the related structure
    //
    if ( Ace->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE )
    {
        // we are using a standard ACE (not object based)
        Mask = ((ACCESS_ALLOWED_ACE *) Ace)->Mask;
    }
    else
    {
        // we are using an object ACE (supports inheritance)
        Mask = ((ACCESS_ALLOWED_OBJECT_ACE *) Ace)->Mask;
    }

    return( Mask );
}



BOOL
AdpIsEqualAce(
    ACE_HEADER *Ace1,
    ACE_HEADER *Ace2
    )
/*++
Routine Description;

    compare two ACEs, and tell whether they are the same or not
    
Parameters:


Return Value:

    TRUE - two ACEs are equal
    FALSE 

--*/
{
    ACCESS_ALLOWED_ACE  *pStdAce1 = NULL; 
    ACCESS_ALLOWED_ACE  *pStdAce2 = NULL;
    ACCESS_ALLOWED_OBJECT_ACE   *pObjectAce1 = NULL;
    ACCESS_ALLOWED_OBJECT_ACE   *pObjectAce2 = NULL;
    GUID                *pGuid1 = NULL;
    GUID                *pGuid2 = NULL;
    PBYTE               ptr1 = NULL, ptr2 = NULL;
    ACCESS_MASK         Mask1 = 0, Mask2 = 0;


    //
    // ACEs should be at least of the same type
    // 
    if (Ace1->AceType != Ace2->AceType)
    {
        return( FALSE );
    }

    //
    // Compare AceFlags
    // 
    if (Ace1->AceFlags != Ace2->AceFlags)
    {
        return( FALSE );
    }

    //
    // Compare AccessMask
    // 
    Mask1 = AdpMaskFromAce(Ace1);
    Mask2 = AdpMaskFromAce(Ace2);

    if (Mask1 != Mask2)
    {
        return( FALSE );
    }


    //
    // this is a standard ACE
    // 
    if (Ace1->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE)
    {
        pStdAce1 = (ACCESS_ALLOWED_ACE *) Ace1;
        pStdAce2 = (ACCESS_ALLOWED_ACE *) Ace2;

        return( EqualSid((PSID) &pStdAce1->SidStart, (PSID) &pStdAce2->SidStart) );
    }

    // 
    // this is an object ACE
    // 
    pObjectAce1 = (ACCESS_ALLOWED_OBJECT_ACE *) Ace1;
    pObjectAce2 = (ACCESS_ALLOWED_OBJECT_ACE *) Ace2;

    //
    // check object allowed ACE flag
    // 

    if (pObjectAce1->Flags != pObjectAce2->Flags)
    {
        return( FALSE );
    }

    // 
    // if ACE_OBJECT_TYPE_PRESENT is set, we are protecting an
    // object, property set, or property identified by the specific GUID.
    // check that we are protecting the same object - property
    //
    if ((pObjectAce1->Flags & ACE_OBJECT_TYPE_PRESENT) && 
        memcmp(&pObjectAce1->ObjectType, &pObjectAce2->ObjectType, sizeof(GUID))
        )
    {
        return(FALSE);
    }

    // if ACE_INHERITED_OBJECT_TYPE_PRESENT is set, we are inheriting an
    // object, property set, or property identified by the specific GUID.
    // check to see that we are inheriting the same type of object - property
    // only if we are also protecting the particular object - property
    //
    if ( pObjectAce1->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT ) 
    {
        //
        // compute the correct offset of InheritedObjectType field
        //
        if (pObjectAce1->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            pGuid1 = &pObjectAce1->InheritedObjectType;
            pGuid2 = &pObjectAce2->InheritedObjectType;
        }
        else
        {
            pGuid1 = &pObjectAce1->ObjectType;
            pGuid2 = &pObjectAce2->ObjectType;
        }

        if ( memcmp(pGuid1, pGuid2, sizeof(GUID)) )
        {
            return(FALSE);
        }
    }

    // possibly, we are protecting the same object - property and we
    // inherit the same object - property, so possition after these GUIDS
    // and compare the SIDS hanging on the ACE.
    //
    ptr1 = (PBYTE) &pObjectAce1->ObjectType;
    ptr2 = (PBYTE) &pObjectAce2->ObjectType;

    if ( pObjectAce1->Flags & ACE_OBJECT_TYPE_PRESENT ) 
    {
        ptr1 += sizeof(GUID);
        ptr2 += sizeof(GUID);
    }

    if ( pObjectAce1->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT ) 
    {
        ptr1 += sizeof(GUID);
        ptr2 += sizeof(GUID);
    }

    return( EqualSid((PSID) ptr1, (PSID) ptr2) );
}

BOOL
AdpIsEqualObjectGuid(
    ACE_HEADER *Ace1,
    ACE_HEADER *Ace2
    )
/*++
Routine Description;

    compare two ACEs, and tell whether they are the same or not
    
Parameters:


Return Value:

    TRUE - two ACEs are equal
    FALSE 

--*/
{
    ACCESS_ALLOWED_OBJECT_ACE   *pObjectAce1 = NULL;
    ACCESS_ALLOWED_OBJECT_ACE   *pObjectAce2 = NULL;


    //
    // ACEs should be at least of the same type
    // 
    if ((Ace1->AceType != Ace2->AceType) ||
        (Ace1->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE))
    {
        return( FALSE );
    }

    // 
    // this is an object ACE
    // 
    pObjectAce1 = (ACCESS_ALLOWED_OBJECT_ACE *) Ace1;
    pObjectAce2 = (ACCESS_ALLOWED_OBJECT_ACE *) Ace2;

    //
    // compare objectGUID field
    //
    if ((pObjectAce1->Flags & ACE_OBJECT_TYPE_PRESENT) && 
        (pObjectAce2->Flags & ACE_OBJECT_TYPE_PRESENT) &&
        (!memcmp(&pObjectAce1->ObjectType, &pObjectAce2->ObjectType, sizeof(GUID))) 
        )
    {
        return( TRUE );
    }
    else
    {
        return( FALSE );
    }

}


ULONG
AdpCompareAces(
    ULONG Flags,
    ACE_HEADER *Ace1,
    ACE_HEADER *Ace2
    )
{

    if ( Flags & ADP_COMPARE_OBJECT_GUID_ONLY )
    {
        return( AdpIsEqualObjectGuid( Ace1, Ace2 ) );
    }
    else
    {
        return( AdpIsEqualAce( Ace1, Ace2 ) );
    }

}




ULONG
AdpMergeSecurityDescriptors(
    IN PSECURITY_DESCRIPTOR OrgSd, 
    IN PSECURITY_DESCRIPTOR SdToAdd,
    IN PSECURITY_DESCRIPTOR SdToRemove,
    IN ULONG Flags,
    OUT PSECURITY_DESCRIPTOR *NewSd,
    OUT ULONG   *NewSdLength
    )
/*++
Routine Description;

    modify OrgSd - add new ACEs and remove duplicates
    
Parameters:


Return Value:

    Win32 error code
--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    PSID    Owner = NULL;
    PSID    Group = NULL;
    PACL    Sacl = NULL,
            OrgDacl = NULL,
            DaclToAdd = NULL,
            DaclToRemove = NULL,
            NewDacl = NULL;

    SECURITY_DESCRIPTOR_CONTROL Control = 0;
    DWORD   Revision = 0;


    BOOL    OwnerDefaulted = FALSE, 
            GroupDefaulted = FALSE, 
            SaclPresent = FALSE,
            SaclDefaulted = FALSE,
            DaclPresent = FALSE,
            DaclDefaulted = FALSE;

    ULONG   i = 0, 
            j = 0, 
            Length = 0,
            OrgAceCount = 0,
            AceCountToAdd = 0,
            AceCountToRemove = 0,
            NewAceCount = 0;

    PACE_HEADER OrgAce = NULL,
                AceToAdd = NULL,
                AceToRemove = NULL;

    SECURITY_DESCRIPTOR AbsoluteSd;
                

    AdpDbgPrint(("AdpMergeSecurityDescriptor\n"));


    //
    // init return values
    // 

    *NewSd = NULL;
    *NewSdLength = 0;

    //
    // get DACL info
    // 
    if (NULL != SdToAdd)
    {
        if (!GetSecurityDescriptorDacl(SdToAdd,&DaclPresent,&DaclToAdd,&DaclDefaulted)||
            (NULL == DaclToAdd) )
        {
            WinError = GetLastError();
            goto Error;
        }
        AceCountToAdd = DaclToAdd->AceCount;
    }

    if (NULL != SdToRemove)
    {
        if (!GetSecurityDescriptorDacl(SdToRemove, &DaclPresent,&DaclToRemove,&DaclDefaulted) ||
            (NULL == DaclToRemove) )
        {
            WinError = GetLastError();
            goto Error;
        }
        AceCountToRemove = DaclToRemove->AceCount;
    }

    if (!GetSecurityDescriptorOwner(OrgSd,&Owner,&OwnerDefaulted) || 
        !GetSecurityDescriptorGroup(OrgSd,&Group,&GroupDefaulted) ||
        !GetSecurityDescriptorSacl(OrgSd,&SaclPresent,&Sacl,&SaclDefaulted) || 
        !GetSecurityDescriptorDacl(OrgSd,&DaclPresent,&OrgDacl,&DaclDefaulted) ||
        !GetSecurityDescriptorControl(OrgSd, &Control, &Revision) ||
        (NULL == OrgDacl)
        )
    {
        WinError = GetLastError();
        goto Error;
    }
    OrgAceCount = OrgDacl->AceCount;


#if ADP_VERIFICATION_TEST

    if (DaclToAdd)
    {
        printf("DACL to add:\n");
        DumpAcl(DaclToAdd);
    }
    
    if (DaclToRemove)
    {
        printf("DACL to del:\n");
        DumpAcl(DaclToRemove);
    }

    if (OrgDacl)
    {
        printf("OrgDACL:\n");
        DumpAcl(OrgDacl);
    }

    printf("Original Control is 0x%x Revision: 0x%x\n", Control, Revision);

#endif

    //
    // Merge DACL's
    //      allocate memory for new DACL (max DACL size of OrgDacl + DaclToAdd)
    //      initialize it
    //      add ACEs
    //

    Length = OrgDacl->AclSize;
    if (DaclToAdd)
    {
        Length += DaclToAdd->AclSize - sizeof(ACL);
    }

    NewDacl = AdpAlloc( Length );
    if (NULL == NewDacl)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    if (!InitializeAcl(NewDacl, Length, ACL_REVISION_DS)) 
    {
        WinError = GetLastError();
        goto Error;
    }


    //
    // del ACE from the original ACL
    // 

    if (DaclToRemove)
    {
        for (i = 0, OrgAce = FirstAce(OrgDacl);
             i < OrgAceCount;
             i ++, OrgAce = NextAce(OrgAce)
             )
        {
            BOOLEAN fRemoveCurrentAce = FALSE;

            for (j = 0, AceToRemove = FirstAce(DaclToRemove);
                 j < AceCountToRemove;
                 j ++, AceToRemove = NextAce(AceToRemove)
                 )
            {
                //
                // compare two ACEs
                //
                if ( AdpIsEqualAce(AceToRemove, OrgAce) )
                {
                    // found the ACE to remove 
                    fRemoveCurrentAce = TRUE;
                    break;
                }
            }

            if (!fRemoveCurrentAce)
            {
                if (!AddAce(NewDacl, 
                            ACL_REVISION_DS,
                            MAXDWORD,       // insert to the end
                            OrgAce,
                            OrgAce->AceSize
                            ))
                {
                    WinError = GetLastError();
                    goto Error;
                }
            }
        }
    }
    else
    {
        // 
        // nothing to remove
        // 
        for (i = 0, OrgAce = FirstAce(OrgDacl);
             i < OrgAceCount;
             i ++, OrgAce = NextAce(OrgAce)
             )
        {
            if (!AddAce(NewDacl, 
                        ACL_REVISION_DS,
                        MAXDWORD,     // insert the ACE to the end of ACL
                        OrgAce,
                        OrgAce->AceSize
                        ))
            {
                WinError = GetLastError();
                goto Error;
            }
        }
    }


    //
    // scan for ACEs to ADD
    // 
    NewAceCount = NewDacl->AceCount;
    if (DaclToAdd)
    {
        for (i = 0, AceToAdd = FirstAce(DaclToAdd);
             i < AceCountToAdd;
             i ++, AceToAdd = NextAce(AceToAdd)
            )
        {
            BOOLEAN fAddNewAce = TRUE;

            for (j = 0, OrgAce = FirstAce(NewDacl);
                 j < NewAceCount;
                 j ++, OrgAce = NextAce(OrgAce)
                 ) 
            {
                //
                // compare two ACEs, 
                // if return TRUE, don't add, already exists in current SD
                // if return FALSE, add the new ACE 
                // 
                if ( AdpCompareAces(Flags, AceToAdd, OrgAce) )
                {
                    // found duplicate, don't add
                    fAddNewAce = FALSE;
                    break;
                }
            }

            if (fAddNewAce)
            {
                if (!AddAce(NewDacl, 
                            ACL_REVISION_DS,
                            MAXDWORD,     // insert the ACE to the end of ACL
                            AceToAdd,
                            AceToAdd->AceSize
                            ))
                {
                    WinError = GetLastError();
                    goto Error;
                }
            }
        }
    }



    //
    // Adjust ACL Size
    // 
    {
        ULONG_PTR   AclStart;
        ULONG_PTR   AclEnd;
        PVOID       Ace = NULL;

        if (FindFirstFreeAce(NewDacl, &Ace) && (NULL!=Ace))
        {
            AclStart = (ULONG_PTR) NewDacl;
            AclEnd = (ULONG_PTR) Ace;

            NewDacl->AclSize = (USHORT)(AclEnd - AclStart);
        }
    }                                                                          

#if ADP_VERIFICATION_TEST

    if (NewDacl)
    {
        printf("New DACL:\n");
        DumpAcl(NewDacl);
    }

#endif

    //
    // construct the new SD
    // 
    if (!InitializeSecurityDescriptor(&AbsoluteSd, SECURITY_DESCRIPTOR_REVISION) ||
        !SetSecurityDescriptorOwner(&AbsoluteSd, Owner, OwnerDefaulted) ||
        !SetSecurityDescriptorGroup(&AbsoluteSd, Group, GroupDefaulted) ||
        !SetSecurityDescriptorSacl(&AbsoluteSd, SaclPresent, Sacl, SaclDefaulted) ||
        !SetSecurityDescriptorDacl(&AbsoluteSd, DaclPresent, NewDacl, DaclDefaulted) 
        )
    {
        WinError = GetLastError();
        goto Error;
    }



    *NewSdLength = GetSecurityDescriptorLength(&AbsoluteSd);
    *NewSd = AdpAlloc( *NewSdLength );
    if (NULL == *NewSd)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    if (!MakeSelfRelativeSD(&AbsoluteSd, *NewSd, NewSdLength))
    {
        WinError = GetLastError();
        goto Error;
    }
 
    //
    // Set SecurityDescriptorControl Flag
    // 
    if (!SetSecurityDescriptorControl(*NewSd, 
                                      (SE_DACL_AUTO_INHERIT_REQ | 
                                       SE_DACL_AUTO_INHERITED |
                                       SE_DACL_PROTECTED), 
                                       Control & (SE_DACL_AUTO_INHERIT_REQ |
                                                  SE_DACL_AUTO_INHERITED |
                                                  SE_DACL_PROTECTED) ) 
         )
    {
        WinError = GetLastError();
        goto Error;
    }

Error:

    if (NewDacl)
    {
        AdpFree( NewDacl );
    }

    if (ERROR_SUCCESS != WinError)
    {
        if ( *NewSd )
        {
            AdpFree( *NewSd );
            *NewSd = NULL;
        }
        *NewSdLength = 0;
    }


    return( WinError );
}






ULONG
AdpGetObjectSd(
    IN LDAP *LdapHandle,
    IN PWCHAR pObjDn, 
    OUT PSECURITY_DESCRIPTOR *Sd,
    OUT ULONG *SdLength,
    OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    read object security descriptor
    
Parameters:


Return Value:

    Win32 error code

--*/
{
    ULONG       WinError = ERROR_SUCCESS;
    ULONG       LdapError = LDAP_SUCCESS;
    PWCHAR      AttrList[2];
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    PLDAP_BERVAL *Sd_Value = NULL;   


    AdpDbgPrint(("AdpGetObjectSdbyDn %ls\n", pObjDn));

    *Sd = NULL;
    *SdLength = 0;


    AttrList[0] = L"nTSecurityDescriptor";
    AttrList[1] = NULL;

    AdpTraceLdapApiStart(0, ADP_INFO_LDAP_SEARCH, pObjDn);
    LdapError = ldap_search_sW(LdapHandle,
                               pObjDn,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               &AttrList[0],
                               0,
                               &Result
                               );
    AdpTraceLdapApiEnd(0, L"ldap_search_s()", LdapError);

    if (LDAP_SUCCESS != LdapError)
    {
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
        WinError = LdapMapErrorToWin32( LdapError );
    }
    else if ((NULL != Result) &&
             (Entry = ldap_first_entry(LdapHandle, Result)) &&
             (Sd_Value = ldap_get_values_lenW(LdapHandle, Entry, AttrList[0])) )
    {
        //
        // allocate memory for SD
        // 
        *Sd = (PSECURITY_DESCRIPTOR) AdpAlloc( (*Sd_Value)->bv_len );
        if (NULL != *Sd)
        {
            memcpy(*Sd, 
                   (PBYTE)(*Sd_Value)->bv_val,
                   (*Sd_Value)->bv_len
                   );

            *SdLength = (*Sd_Value)->bv_len;
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            AdpSetWinError( WinError, ErrorHandle );
        }
    }
    else
    {
        LdapError = LdapGetLastError();
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
        WinError = LdapMapErrorToWin32( LdapGetLastError() ); 
    }


    //
    // cleanup 
    // 

    if ( Sd_Value)
    {
        ldap_value_free_len( Sd_Value );
    }
     
    if ( Result )
    {
        ldap_msgfree( Result );
    }

    return( WinError );
}


ULONG
AdpSetObjectSd(
    IN LDAP *LdapHandle,
    IN PWCHAR pObjDn, 
    IN PSECURITY_DESCRIPTOR Sd,
    IN ULONG SdLength,
    IN SECURITY_INFORMATION SeInfo,
    OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    set object security descriptor
    
Parameters:


Return Value:

    Win32 error code

--*/
{
    ULONG       LdapError = LDAP_SUCCESS;
    LDAPModW    *AttrList[2];
    LDAPModW    Attr;
    LDAP_BERVAL *BerValues[2];
    LDAP_BERVAL BerVal;
    BYTE        bValue[8];

    LDAPControlW    SeInfoControl = 
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) bValue
                        },
                        TRUE
                    };

    PLDAPControlW   ServerControls[2] = 
                    {
                        &SeInfoControl,
                        NULL
                    };


    AdpDbgPrint(("AdpSetObjectSdbyDn %ls\n", pObjDn));
                      
    bValue[0] = 0x30;
    bValue[1] = 0x03;
    bValue[2] = 0x02;
    bValue[3] = 0x1;
    bValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

    BerVal.bv_len = SdLength;
    BerVal.bv_val = (PCHAR) Sd;

    BerValues[0] = &BerVal;
    BerValues[1] = NULL;

    Attr.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    Attr.mod_type = L"nTSecurityDescriptor";
    Attr.mod_bvalues = &BerValues[0]; 

    AttrList[0] = &Attr;
    AttrList[1] = NULL;

    AdpTraceLdapApiStart(0, ADP_INFO_LDAP_MODIFY, pObjDn);
    LdapError = ldap_modify_ext_sW(LdapHandle,
                                   pObjDn,
                                   AttrList,
                                   &ServerControls[0],
                                   NULL             // client control
                                   );
    AdpTraceLdapApiEnd(0, L"ldap_modify_ext_s()", LdapError);
    
    if (LDAP_SUCCESS != LdapError)
    {
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
    }

    return( LdapMapErrorToWin32(LdapError) );
}





ULONG
AdpGetRegistryKeyValue(
    OUT ULONG *RegKeyValue, 
    ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    this routine gets the registry key value
    
Parameters:

    errorHandle

Return Value:

    Win32 error code

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   Value = 0;
    WCHAR   StringlizedValue[20];
    DWORD   dwType, dwSize;
    HKEY    hKey;

    // Read the value of "Schema Update Allowed" regKey from NTDS config section
    // Value is assumed to be 0 if not found
    dwSize = sizeof(Value);
    WinError = RegOpenKey(HKEY_LOCAL_MACHINE, ADP_DSA_CONFIG_SECTION, &hKey);
    if (ERROR_SUCCESS == WinError)
    {
        WinError = RegQueryValueEx(hKey, ADP_SCHEMAUPDATEALLOWED, NULL, &dwType, (LPBYTE) &Value, &dwSize);
        RegCloseKey( hKey ); 
    }

    // set return value
    if (ERROR_SUCCESS == WinError)
    {
        *RegKeyValue = Value;
    }

    // write it to log, don't write too much info to log file (comment it out temporarily) 
    /*
    if (ERROR_SUCCESS == WinError) 
    {
        _ultow(Value, StringlizedValue, 16);
        AdpLogMsg(0, ADP_INFO_GET_REGISTRY_KEY_VALUE, ADP_SCHEMAUPDATEALLOWED_WHOLE_PATH, StringlizedValue);
    }
    else {
        AdpSetWinError(WinError, ErrorHandle);
        AdpLogErrMsg(ADP_DONT_WRITE_TO_STD_OUTPUT, 
                     ADP_ERROR_GET_REGISTRY_KEY_VALUE, 
                     ErrorHandle, 
                     ADP_SCHEMAUPDATEALLOWED_WHOLE_PATH, 
                     NULL
                     );
    }
    */

    return( WinError );
}



ULONG
AdpSetRegistryKeyValue(
    ULONG RegKeyValue,
    ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    set regkey, so that adprep.exe can modify objects under schema NC on Win2K system
    
Parameters:

    errorHandle

Return Value:

    Win32 error code

--*/
{
    DWORD   WinError = ERROR_SUCCESS;
    HKEY    hKey;
    DWORD   Value;
    DWORD   dwSize = sizeof(DWORD);
    WCHAR   StringlizedValue[20];

    Value = RegKeyValue;
    _ultow(Value, StringlizedValue, 16);

    WinError = RegOpenKeyW(HKEY_LOCAL_MACHINE, ADP_DSA_CONFIG_SECTION, &hKey);

    if (ERROR_SUCCESS == WinError) 
    {
        //
        // Set the keys "Schema Update Allowed"
        //
        WinError = RegSetValueExW(hKey, ADP_SCHEMAUPDATEALLOWED, 0, REG_DWORD, (LPBYTE) &Value, dwSize);

        RegCloseKey(hKey);
    }

    // write it to log, don't write too much info to log file (comment it out temporarily) 
    if (ERROR_SUCCESS == WinError) 
    {
        AdpLogMsg(0, ADP_INFO_SET_REGISTRY_KEY_VALUE, ADP_SCHEMAUPDATEALLOWED_WHOLE_PATH, StringlizedValue); 
    }
    else {
        AdpSetWinError(WinError, ErrorHandle);
        AdpLogErrMsg(0, 
                     ADP_ERROR_SET_REGISTRY_KEY_VALUE, 
                     ErrorHandle, 
                     ADP_SCHEMAUPDATEALLOWED_WHOLE_PATH, 
                     StringlizedValue
                     );
    }

    return( WinError );
}


ULONG
AdpCleanupRegistry(
    ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    reset rekey
    
Parameters:


Return Value:

    Win32 error code

--*/
{
    DWORD   WinError = ERROR_SUCCESS;
    HKEY    hKey;

    WinError = RegOpenKeyW(HKEY_LOCAL_MACHINE, ADP_DSA_CONFIG_SECTION, &hKey);

    if (ERROR_SUCCESS == WinError) 
    {
        //
        // delete the keys "Schema Update Allowed"
        //
        WinError = RegDeleteValueW(hKey, ADP_SCHEMAUPDATEALLOWED);
        if (ERROR_FILE_NOT_FOUND == WinError)
            WinError = ERROR_SUCCESS;
        RegCloseKey(hKey);
    }

    // write it to log, don't write too much info to log file (comment it out temporarily) 
    /*
    if (ERROR_SUCCESS == WinError) 
    {
        AdpLogMsg(0, ADP_INFO_DELETE_REGISTRY_KEY, ADP_SCHEMAUPDATEALLOWED_WHOLE_PATH, NULL);
    }
    else 
    {
        AdpSetWinError(WinError, ErrorHandle);
        AdpLogErrMsg(ADP_DONT_WRITE_TO_STD_OUTPUT, 
                     ADP_ERROR_DELETE_REGISTRY_KEY,
                     ErrorHandle, 
                     ADP_SCHEMAUPDATEALLOWED_WHOLE_PATH, 
                     NULL
                     );
    }
    */

    return( WinError );
}


ULONG
AdpRestoreRegistryKeyValue(
    BOOL OriginalKeyValueStored, 
    ULONG OriginalKeyValue, 
    ERROR_HANDLE *ErrorHandle
    )
{
    ULONG   WinError = ERROR_SUCCESS;

    if ( OriginalKeyValueStored )
    {
        WinError = AdpSetRegistryKeyValue( OriginalKeyValue, ErrorHandle );
    }
    else
    {
        WinError = AdpCleanupRegistry( ErrorHandle );
    }

    return( WinError );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\ldapp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ldapp.h

Abstract:

    This module define a set of classes to facilitate LDAP queries & commits.

Author:

    Ajit Krishnan (t-ajitk) 10-Jul-2001

Revision History:

    10-Jul-2001    t-ajitk
        Initial Writing
    22-Aug-2001 t-ajitk
        Satisfies load balancing spec
--*/


# ifndef _ldapp_h
# define _ldapp_h _ldapp_h

#include <NTDSpch.h>

# include <ntlsa.h>
extern "C" {
# include <ntdsa.h>
# include <ntdsapi.h>
# include <dsaapi.h>
# include <ismapi.h>
# include <locale.h>
}

# include <winldap.h>
# include <winber.h>
# include <windows.h>
# include <assert.h>
# include <winsock.h>

# include <iostream>
# include <iomanip>
# include <fstream>
# include <string>
# include <vector>
# include <set>
# include <algorithm>
# include <cmath>
# include <cstdlib>
# include <msg.h>

# define DEFAULT_MAX_CHANGES_PER_SERVER 10

using namespace std;

// forward declarations
class LdapInfo;
class Schedule;
class LdapObject;
class NtdsDsa;
class Server;
class NtdsSiteSettings;

#define ARRAY_SIZE(x) (sizeof(x)/sizeof(*(x)))

// macros for dealing with assertions
void
my_assert ( char *file, int line, char *foo);

#define Assert(x) { if (!(x)) my_assert(__FILE__, __LINE__, #x ); }

// Global Options structure
class LbToolOptions {
public:
    bool verbose;
    bool performanceStats;
    bool maxBridge;
    int maxBridgeNum;
    bool maxSched;
    int maxSchedNum;
    int numConnectionsBridge;
    int numConnectionsSched;
    int changedBridge;
    int changedSched;
    wstring domain;
    wstring user;
    wstring password;
    wstring site;
    wstring logFile;
    wostream *log;
    wstring server;
    bool whistlerMode;
    bool previewBool;
    wstring previewFile;
    wostream *preview;
    bool showInput;
    bool fComputeNCReasons;
	int maxPerServerChanges;
	bool disownSchedules;
	bool stagger;
};

bool 
    isBinaryAttribute(
        IN const wstring &w
        );
/*++
Routine Description:
    Determine if an attribute is binary or not
Arguments:
    w - the name of the attribute
--*/


LbToolOptions &
GetGlobalOptions();


wstring 
GetMsgString (
    IN long sid,
    bool system=false,
    PWCHAR *args = NULL
    );
/*++
Routine Description:
    Return an error string from the msg.rc file
Arguments:
    sid - The resource of the id string to load.
Return Value:
    A wstring conforming to the internationalization specifications
--*/

class Error { 
    public: 
    Error (wstring s) : msg(s) { } 
    wstring msg; 
};


class DnManip {
/*++ 
Class Description:
    A set of static methods to deal with DN parsing and manipulation
--*/
public:
    DnManip (const wstring &dn);
    /*++
    Routine Description:
        Constructor takes the Dn we are interested in manipulating
    Arguments:
        dn - the DN whose components we are interested in
    --*/

    ~DnManip (
        );
    /*++
    Routine Description:
        Destructor frees any dynamically allocated memory
    --*/
    
    const wstring &
    getDn (
        ) const;
    /*++
    Routine Description:
        Return the original DN
    Return Value:
        The DN
    --*/
    
    wstring
    newParentDn (
        const DnManip &b
        ) const;
    /*++
    Routine Description:
        The current object should be moved under another dn. This function
        will determine the new dn. The rdn will remain unchanged
    Arguments:
        b - The new parent dn.
    Return Value:
        The new DN which would result if it were moved
    --*/

    const wstring &
    getRdn (
        ) const;
    /*++
    Routine Description:
        Return the qualified RDN of the current object
    Return Value:
        The RDN
    --*/
    
    wstring
    getParentDn (
        unsigned int cava=1
        ) const;
    /*++
    Routine Description:
        Determine the DN of a parent
    Arguments:
        cava - Level of parent (1=parent, 2=grandparent etc)
    Return Value:
        The DN of the parent
    --*/

    bool
    operator== (
        const DnManip &other
        ) const;
    /*++
    Routine Description:
        Determine if two DN's point to the same LDAP entry. This does not hit the server,
        and does its best. It should only be used if both DN's have come from the same server,
        and have the same canonical form as a result. If they do not, the GUID's should be 
        compared instead.
    Return Value:
        True if they are the same LDAP object, false otherwise.
    --*/

    bool
    operator!= (
        const DnManip &other
        ) const;
    /*++
    Routine Description:
        Determine if two DN's point to the same LDAP entry. This does not hit the server,
        and does its best. It should only be used if both DN's have come from the same server,
        and have the same canonical form as a result. If they do not, the GUID's should be 
        compared instead.
    Return Value:
        False if they are the same LDAP object, true otherwise.
    --*/

private:
    PDSNAME
    genDsNameStruct (
        int size=0
        ) const;
    /*++
    Routine Description:
        Private function allowing us to use NameMatched, etc. It converts a DN into a DSNAME 
        structure. The memory allocated should be freed using free (return_value). The DSNAME
        structure returned will assign 0 as the GUID.
    Arguments:
        size - # of bytes to be allocated for DN representation. If 0, it will be figured out.
        automatically. This parameter might be used to allocate more space than the current
        dn in order to store the result of RDN + DN.
    Return Value:
        A PDSNAME representing the current DN
    --*/
private:
    wstring m_dn;
    wstring m_relative;
    int m_num_components;
    PDSNAME m_dsname;
};



class AttrValue {
public:
    /*++
    Class Description:
        This class stores a single binary attribute value
    Member Description:
        value - Supplies pointer location of binary attribute value
        size - Supplies size of binary attribute value in bytes
    --*/
    AttrValue (PBYTE value, int size);
    /*++
    Routine Description:
        Using the constructor will warn us when this public struct changes, allowing us to find
        any errors.
    --*/

    bool
    decodeLdapDistnameBinary(
        OUT PVOID *ppvData,
        OUT LPDWORD pcbLength,
        IN LPWSTR *ppszDn
            );
    /*++
    Routine Description:
        Decode an argument of type DN(binary)
    Arguments:
        pszLdapDistnameBinaryValue - Incoming ldap encoded distname binary value
        ppvData - Newly allocated data. Caller must deallocate
        pcbLength - length of returned data
        ppszDn - pointer to dn within incoming buffer, do not deallocate
    Return Value:
        BOOL -
    --*/
    
    PBYTE value;
    int size;
};

wostream &
operator<< (
    IN wostream &wos, 
    IN const AttrValue &av
    );
/*++
Routine Description:
    Standard ostream operator for an Attribute Value
--*/

class Attribute {
/*++
Class Description: 
    This class models an LDAP attribute with multiple binary values.
--*/
public:
    
    Attribute (
        IN const wstring &name
        );
    /*++
    Routine Description:
        Constructor
    Arguments:
        name - Each attribute must have a name
    --*/
    
    const wstring &
    getName (
        ) const;
    /*++ 
    Routine Description:
        Return the name of the current attribute object.
    Return Value:
        Name of the attribute.
    --*/
    
    int 
    numValues (
        ) const;
    /*++
    Routine Description:
        Return the number of binary attributes this object contains.
    Return Value: 
        Number of binary attributes.
    --*/
    
    void 
    addValue (
        IN const AttrValue &a
        );
    /*++
    Routine Description:
        Add a binary value to the list of values for this attribute. All attributes are modelled
        as multi-valued attributed. In this internal representation, multiple values may be
        specified for a single-valued attribute. It is the responsibility of the calling class to
        use addValue() or setValue() appropriately.
    Arguments:
        AttrValue - a binary attribute
    Return Value:
        None
    --*/
    
    const AttrValue &
    getValue (
        IN int i
        ) const;
    /*++
    Routine Description:
        Get a read-only copy of the ith attribute value contained in this object. 
        If the range is invalid, this function will fail an Assertion.
    Arguments:
        i - Get the ith value (0 <= i <= numValues()-1)
    Return Value: 
        A read-only reference to the ith value
    --*/


    AttrValue &
    setValue (
        IN int i
        );
    /*++
    Routine Description:
        Get a writeable copy of the ith attribute value contained in this object.
    Arguments:
        i - Get the ith value (0 <= i <= numValues()-1)
    Return Value: 
        A writeable reference to the ith value
    --*/


    AttrValue &
    setValue (
        IN int i,
        IN PBYTE value,
        IN int length
        );
    /*++
    Routine Description:
        Change an attribute value
    Arguments:
        i - Get the ith value (0 <= i <= numValues()-1)
        value - The new value
        length - The length of the new value
    Return Value: 
        A writeable reference to the ith value
    --*/

    bool
    isModified (
        ) const;
    /*++
    Routine Description:
        Determines whether or not this attribute has been modified
    Return Value:
        true if setValue(i) was called; false otherwise
    -- */

    void
    commit (
        IN const LdapInfo &i,
        IN const wstring &dn,
        IN bool binary = false,
        IN bool rename = false
        ) const;
    /*++
    Routine Description:
        Modify this attribute of the given dn. It will connect to the LDAP server
        and will modify the attribute values for a given dn.
    Arguments:
        i - The ldap server info to connect to
        dn - The dn of the object whose attribute should be modified
        binary - Binary values and String values are treated differently by the LDAP 
        server. Binary values will be committed as is, while string values may be 
        converted to appropriate encodings etc. Specify which behaviour should be
        followed.
    Return Value:
        None
    --*/

    PLDAPMod
    getLdapMod (
        IN ULONG mod_op,
        bool binary = false
        ) const;
    /*++
    Routine Description:
        Generate an LDAPMod structure for a given attribute
    Arguments:
        mod_op - Type of structure: add, delete, replace etc
        binary - True if it is a binary attribute, false otherwise
    --*/

private:    
    wstring m_name;
    bool m_modified;
    vector<AttrValue> m_values;
};


wostream &
operator<< (
    IN wostream &os,
    IN const Attribute &a
    );
/*++
Routine Description:
    Standard ostream operator for an Attribute
--*/
    

enum LdapQueryScope { 
    BASE=LDAP_SCOPE_BASE, 
    ONE_LEVEL=LDAP_SCOPE_ONELEVEL,
    SUBTREE=LDAP_SCOPE_SUBTREE 
};
/*++
Enum Description:
    This enumeration flags the possible scopes for ldap queries.
    The values mimic those found in the LDAP header files, so that it may be
    used as a drop-in replacement.
--*/

class LdapInfo {
public:
/*++
Class Description:
    This contains all necessary info to bind & authenticate with some server.
    It contains the location of the server, and any required credentials.
--*/

    LdapInfo (
        IN const wstring &server, 
        IN int port, 
        IN const wstring &domainname,
        IN const wstring &username, 
        IN const wstring &password
        );
    /*++
    Routine Description:
        The constructor takes in all required information to ensure that the object
        is in a consistent state. 
    Arguments:
        server - dns name of the server on which the ldap server resides
        port - the port number on which the ldap server resides
        domainname - domainname allows the use of altername credentials
        username - username allows the use of alternate credentials [optional]
        Use either the username or domain qualified username eg. "t-ajitk" or "redmond\\t-ajitk"
        password - password allows the use of alternate credentials [optional]
    --*/

    ~LdapInfo ();
    /*++
    Routine Description:
        Destructor deallocates any dynamically allocated memory used by this class
    --*/
    
    LDAP *getHandle (
        ) const;
    /*++
    Routine Description:
        This returns an ldap handle from the structure. This allows us to pass this structure
        around, and yet retain the performance of a single LDAP session.
    Return Value:
        A valid LDAP handle
    --*/
    
    wstring server;
    int port;
    wstring domainname;
    wstring username;
    wstring password;

private:
    mutable LDAP *m_handle;
};

class LdapQuery {
/*++
Class Description:
    This contains all necessary info to perform an ldap query. It should be used along
    with LdapInfo (authentication information). 
--*/
public:

    LdapQuery (
        IN const wstring baseDn, 
        IN const wstring filter, 
        IN const LdapQueryScope &scope, 
        IN const vector<wstring> &attributes
        );
    /*++
    Routine Description:
        The constructor takes in all required information to ensure that the object
        is in a consistant state.
    Arguments:
        baseDn - fully qualified DN from where the search will be rooted
        filter - the filter wstring (LDAP query) to be used
        scope - the scope of the search
        attributes - A list of attribute names, whose corresponding values will be requested
            from the LDAP server.
    --*/
    
    wstring baseDn;
    wstring filter;
    LdapQueryScope scope;
    vector<wstring> attributes;
};

enum TransportType { T_IP, T_SMTP};

class Nc {
public:
    Nc ( IN const wstring &name,
        IN bool writeable,
        IN bool going,
        IN TransportType transport_type
        );
    /*++
    Routine Description:
        Standard constructor for an nc object
    Arguments:
        name - name of the nc
        writeable - true if this nc is a writeable copy, false otherwise
        going - true if this nc is in the process of being deleted. false otherwise
        transport_type - the transport type of this nc
    --*/

    const wstring&
    getNcName (
        ) const;
    /*++
    Routine Description:
        Get the name of the current nc
    Return value:
        The name of the current nc
    --*/
    

    bool
    isWriteable (
        ) const;
    /*++
    Routine Description:
        Determine whether or not this is a writeable nc
    Return Value:
        True if it is writeable. False otherwise.
    --*/

    bool
    isBeingDeleted (
        ) const;
    /*++
    Routine Description:
        Determine whether or not this is nc is going.
    Return Value:
        True if it is being deleted. False otherwise.
    --*/

    TransportType
    getTransportType (
        ) const;
    /*++
    Routine Description:
        Determine the transport type of this nc.
    Return Value:
        T_IP if it supports IP. T_SMTP if it supports SMTP.
    --*/

    bool 
    operator < (
        IN const Nc &b
        );
    /*++
    Routine Description:
        Some way to order NC's. The exact ordering is not specified
    Return Value:
        True or false determining a unique ordering among two NC's.
    --*/

    wstring
    getString (
        ) const;

    friend wostream & operator<< (IN wostream &os, IN const Nc &n);
    static const m_reason_gc_topology_mask = 1; // bit 0 kccconn.hxx

private:
    wstring m_name;
    bool m_writeable, m_going;
    TransportType m_transport_type;
};

wostream &
operator<< (
    IN wostream &os,
    IN const Nc &n
    );
/*++
Routine Description:
    Standard ostream operator for an Nc
--*/


class LdapObject {
/*++
Class Description:
    This models an existing LDAP object. Although this may be used to model a new object
    internally, the commit method assumes the existance of the original LDAP object.
--*/
public:

    LdapObject (
        IN const wstring &dn
        );
    /*++
    Routine Description:
        The constructor requires the DN of the object
    --*/
    
    const wstring &
    getName (
        ) const;
    /*++
    Routine Description:
        Get the DN of the current object
    Return value:
        The DN of the current LDAP object.
    --*/
    
    int 
    numAttributes (
        ) const;
    /*++
    Routine Description:
        Get the number of attributes the current object has
    Return value:
        The number of attributes.
    --*/
    
    void 
    addAttribute (
        IN const Attribute &a
        );
    /*++
    Routine Description:
        Add an attribute to the current object
    Arguments:
        a - the attribute to be added to the object
    Return value:
        none
    --*/
    
    Attribute &
    getAttribute (
        IN int i
        );
    /*++
    Routine Description:
        Get a writeable handle to the ith attribute of the current object
    Arguments:
        i - The ith attribute should be returned. 0 <= i <= numAttributes -1
    Return Value:
        A writeable handle to the ith attribute
    --*/
    
    void 
    rename (
        IN const wstring &parent_dn
        );
    /*++
    Routine Description:
        Change the  DN of the current object. This is internal to the state of the
        current object only, and will only be written to the LDAP server if the commit() 
        function is called.
    Arguments:
        dn - the DN of the renamed object.
    Return Value:
        None
    --*/
    
    void
    commit_copy_rename(
        IN const LdapInfo &i
        ) ;
    /*++
    Routine Description:
        Write the LDAP object to the LDAP server using the credentials in i
        If the object has been renamed, it will be moved to the new location.
        This will be done by adding a new object and deleting the old object
    Arguments:
        i - Use the credentials in i to bind to the server specified in i
    Return Value:
        None
    --*/

    void
    commit_rename(
        IN const LdapInfo &i
        ) ;
    /*++
    Routine Description:
        Write the LDAP object to the LDAP server using the credentials in i
        If the object has been renamed, it will be moved to the new location.
        This will be done by actually renaming, not by copying the object.
    Arguments:
        i - Use the credentials in i to bind to the server specified in i
    Return Value:
        None
    --*/

    void
    commit (
        IN const LdapInfo &i
        ) ;
    /*++
    Routine Description:
        Write the LDAP object to the LDAP server using the credentials in i
        If the object has been renamed, it will be moved to the new location.
        All attributes will be synced to the state found in the current object. i.e.
        The values of each modified attribute found in the current object will be written 
        to the LDAP server. The values will not be overwritten--they will replace the
        values currently found on the object in the LDAP server.
    Arguments:
        i - Use the credentials in i to bind to the server specified in i
    Return Value:
        None
    --*/

    bool
    isModified (
        ) const;
    /*++
    Routine Description:
        Determine if any of the attributed found in this object were modified,
        or if the object was renamed
    Return Value:
        True if rename() was called, or if any attributes have been modified. False otherwise.
    --*/

	bool
	fromServerModified (
		) const;
	/*++
	Routine Description:
		Determine if the from server attribute on this object was modified.
	Return Value:
		True if the FromServer attribute exists, and has been modified. False otherwise
   --*/   

    virtual bool
    IsMoveable();
    /*++
    Routine Description:
        Determine if the current connection can be moved or not
    Return Value:
        TRUE - can be moved
        FALSE - may not be moved
    --*/

    int
    findAttribute (
        IN const wstring &attr_name
        ) const;
    /*++
    Routine Description:
        Determine if an attribute is present in the ldap object.The attribute name is compared
        case insensitively, and with locale considerations.
    Arguments:
        attr_name: the attribute whose presence should be determined
    Return Value:
        -1 if it does not exist, or the index if it does
    --*/

    inline bool
    operator< (
        IN const LdapObject &other
        ) const;
    /*++ 
    Routine Description:
        The operators allow some way to sort the object into standard containers. Its semantics
        are undefined, and may be changed at any time.
    Return Value:
        A boolean representing some sorted order
    --*/    

private:
    wstring m_dn;
    wstring m_new_dn;
    int m_num_attributes;
    vector<Attribute> m_attributes;
protected:
    mutable bool m_modified_cache;
};


wostream &
operator<< (
    IN wostream &os,
    IN LdapObject &l
    );
/*++
Routine Description:
    Standard ostream operator for an LdapObject
--*/

class Connection : public LdapObject {
public:
    Connection (
        IN const wstring &dn
        );
    /*++
    Routine Description:
        Default constructor for a connection object
    Arguments:
        The DN of the ldapobject/connection
    --*/

    ~Connection (
        );
    /*++
    Routine Description:
        A standard destructor for a connection object
    --*/
    
    TransportType
    getTransportType (
        );
    /*++
    Routine Description:
        Determine the transport type of the current connection
    Return Value:
        T_SMTP if it is an SMTP connection, and T_IP if it is an IP connection
    --*/
    
    bool
    isManual (
        );
    /*++
    Routine Description:
        Determine whether this connection was created manually, or by the KCC
    Return Value:
        True if it is a manual connection, and false otherwise
    --*/

    bool
    hasUserOwnedSchedule (
        );
    /*++
    Routine Description:
        Determine whether this connection has a user owned schedule
    Return Value:
        True if it is has a user owned schedule, and false otherwise
    --*/
    
    void
    setUserOwnedSchedule (
		IN bool status = true
        );
    /*++
    Routine Description:
        set the user owned schedule bit for this connection.
		If status is true, set the bit. If it is false, unset the bit.
    --*/
    
    void
    setReplInterval (
        unsigned replInterval
        );
    /*++
    Routine Description:
        Set the replication interval for the connection
    Return Value:
        None
    --*/
    

    int
    getReplInterval (
        ) const;
    /*++
    Routine Description:
        Get the replication interval for the connection
    Return Value:
        The replication interval for the connection
    --*/
    
    void
    setAvailabilitySchedule (
        IN ISM_SCHEDULE* cs
        );
    /*++
    Routine Description:
        Set the availability schedule for the connection
    Arguments:
        A pointer to an ISM_SCHEDULE structure which is parsed
    Return Value:
        None
    --*/

    void
    setReplicationSchedule (
        IN ISM_SCHEDULE* cs
        );
    /*++
    Routine Description:
        Set the replication schedule for the connection
    Arguments:
        A pointer to an ISM_SCHEDULE structure which is parsed
    Return Value:
        None
    --*/    


	void
    setReplicationSchedule(
		IN Schedule *s
		);

	/*++
	Routine Description:
		Set the replication schedule for the connection
	Arguments:
		s: A pointer to a schedule
	Implementation Details:
		We do not create a new replication schedule, but take the 
		existing one, and modify the bits specifying the replication times.
		All the other bits are left as is. 
	--*/    

    void
    setRedundancyCount (
    IN int count
    ) ;
     /*++
    Routine Description:
        Set the redundancy count found on the NTDS Settings of the
		destination end of the connection
    Arguments:
		count: The integer redundancy Value
    Return Value:
        None
    --*/    

    const Schedule *
    getAvailabilitySchedule (
        ) const;
    /*++
    Routine Description:
        Get a read-only reference to the availability schedule
    Return Value:
        A read-only reference to the availabitlity schedule
    --*/

    Schedule *
    getReplicationSchedule (
    ) ;
    /*++
    Routine Description:    
        Get a writeable reference to the replication schedule
    Return Value:
        A writeable reference to the availability schedule
    --*/

    vector<Nc> &
    getReplicatedNcs();
    /*++
    Routine Description:
        Get a list of all NC's replicated by this connection
    Return Value:
        A list of all replicated NC's
    --*/

    virtual bool
    IsMoveable();
    /*++
    Routine Description:
        Determine if the current connection can be moved or not
    Return Value:
        TRUE - can be moved
        FALSE - may not be moved
    --*/

    void
    setFromServer (
        IN const wstring &w
        );
    /*++
    Routine Description:
        Set the fromServer attribute to point to a new server
    Arguments:
        w - The new fromServer DN (fully qualified)
    --*/

    wstring
    getFromServer (
        ) ;
    /*++
    Routine Description:
        Determine the FQDN of the fromServer
    Return Value:
        The DN of the fromServer
    --*/
    
    void
    createNcReasons (
        IN NtdsDsa &ntds_source,
        IN NtdsDsa &ntds_dest,
        IN const wstring &root_dn
        );
    /*++
    Routine Description:
        Populate the NC Reasons attribute
    Arguments:
        ntds_source - the source NtdsDsa object
        ntds_dest - the destination NtdsDsa object
        root_dn - the root FQDN
    --*/
private:
    void
    getReplicatedNcsHelper (
        const wstring &attrName
        ) ;
    /*++
    Routine Description:
        Parse an attribute of type distname binary into a list of nc's. 
    Arguments:
        attrName - an attribute of type distname binary
    --*/
    vector<Nc> m_ncs;
    Schedule *m_repl_schedule, *m_avail_schedule;
    unsigned m_repl_interval;
	int m_redundancy_count;
    static const m_reason_gc_topology_mask = 1; // bit 0 kccconn.hxx
};

class Server : public LdapObject {
public:
    Server (
        IN const wstring &dn
        );
    /*++
    Routine Description:
        Standard constructor for a server object
    --*/

    vector<Nc> &
    getHostedNcs (
        IN const wstring &root_dn
        );
    /*++
    Routine Description:
        Get a list of all Ncs hosted by this server
    Arguments:
        root_dn - the root dn
    Return Value:
        A list of hosted Ncs
    --*/

    NtdsDsa *
    getNtdsDsa (
        );
    /*++
    Routine Description:
        Get the NtdsDsa which corresponds to this server object
    Return Value:
        The corresponding NtdsDsa object
    --*/

    void
    setNtdsDsa (
        NtdsDsa *ns
        );
    /*++
    Routine Description:
        Set the NtdsDsa which corresponds to this server object
    Arguments:
        ns - The corresponding server
    --*/

    bool
    supportsSmtp (
        );
    /*++
    Routine Description:
        Determine if this server supports smtp replication
    Return Value:
        True if it supports smtp replication, False if it supports ip only
    --*/

    void
    setPreferredBridgehead (
        IN TransportType t
        );
    /*++
    Routine Description:
        Set the server as a preferred object. This is internal state only, and
        will not modify the attributes of the server object
    Arguments:
        t - The transport type for which this server shouldb e a PB
    --*/

    bool
    isPreferredBridgehead (
        IN TransportType t
        );
    /*++
    Routine Description:
        Determine if this server is a preferred bridgehead. This will be also be
        true is setPreferredBridgehead was previously called
    Arguments:
        t - The transport type for which PB status should be determined
    --*/
    
private:
    bool m_preferred_ip;
    bool m_preferred_smtp;
    NtdsDsa *m_ntds_dsa;
};

class NtdsSiteSettings: public LdapObject {
public:
	NtdsSiteSettings (
		IN const wstring &dn
		);
	/*++
	Routine Description:
		Standard constructor for an NtdsSiteSettings object
	--*/

	int
	defaultServerRedundancy (
		);
	/*++
	Routine Description:
		The number of Redundant Connections the KCC should have
		created to this site. If the
		NTDSSETTINGS_OPT_IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED     
		is not set in the options field, this function will always
		return 1; 
	
	Return Values:
		1 if NTDSSETTINGS_OPT_IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED is not set
		The value of NTDSSETTINGS_DEFAULT_SERVER_REDUNDANCY otherwise
	--*/

private:
	bool m_cache_populated;
    int m_cache_defaultServerRedundancy;
};


class NtdsDsa : public LdapObject {
public:
    NtdsDsa (
        IN const wstring &dn
        );
    /*++
    Routine Description:
        Standard constructor for an ntdsdsa object
    --*/
    
    vector<Nc> &
    getHostedNcs (
            IN const wstring &root_dn
        ) ;
    /*++
    Routine Description:
        Get the list of NCs hosted by this ntdsDsa object
    Arguments:
        root_dn - the Root dn
    Return Value:
        The list of hosted NC's
    --*/

    Server *
    getServer (
        );
    /*++
    Routine Description:
        Get the server which corresponds to this ntdsDsa object
    Return Value:
        The corresponding server object
    --*/

    void
    setServer (
        Server *s
        );
    /*++
    Routine Description:
        Set the server which corresponds to this ntdsDsa object
    Arguments:
        s - The corresponding server object
    --*/
    
private:
    bool
    NtdsDsa :: getHostedNcsHelper (
        IN const wstring &root_dn,    
        const wstring &attrName,
        IN bool writeable=false,
        IN bool isComingGoing=true
        ) ;
    /*++

    Routine Description:
        Parse an attribute of type distname binary into a list of nc's. If ComingGoing
        information is not found in this attribute, it should be set to false. writeable will
        only be used when isComingGoing is true.
    Arguments:
        root_dn - the root dn
        attrName - an attribute of type distname binary
        writeable - whether the nc is writeable
        isComingGoing - whether this information is found in this attribute, or not
    --*/

    vector<Nc> m_ncs;
    static const m_host_nc_write_mask = 4; 
    static const m_host_nc_coming_mask = 16;
    static const m_host_nc_going_mask = 32;
    Server *m_server;
};


class LdapObjectCmp {
/*++
Class Description:
    Function-Object to do comparsion on LdapObject's for set insertions. This is required since user
    define operators must take at least one object as a parameter, and we wish to do overload the
    comparsion of two primitive types. This will allow us to order them based on the DN's instead of
    pointer values.
--*/
public:
    bool operator()(
        const LdapObject *a, 
        const LdapObject *b
        ) const;
    /*++
    Routine Description:
        do *a < *b
    Return Value:
        same as *a < *b
    --*/
};

typedef set<LdapObject*, LdapObjectCmp> SLO, *PSLO;
typedef set<Connection*, LdapObjectCmp> SCONN, *PSCONN;
typedef set<Server*, LdapObjectCmp> SSERVER, *PSSERVER;
typedef set<NtdsDsa*,LdapObjectCmp> SNTDSDSA, *PSNTDSDSA;
typedef set<NtdsSiteSettings*,LdapObjectCmp> SNTDSSITE, *PSNTDSSITE;

template <class T>
class LdapContainer {
/*++
Class Description:
    This container will contain a number of ldap_object*, and will query LDAP servers
    in order to populate itself
--*/
public:

    LdapContainer (
        IN const wstring &dn
        );
    /*++
    Routine Description:
        Constructor takes a dn. Use "" if there is no appropriate DN
    Arguments:
        dn - the DN of the container object. If this is not being modelled as an LDAP
        container, any string may be specified. The commit() function will not rename
        the container based on this dn. It is provided as an aid to the programmer.
    --*/
    
    const wstring &
    getName (
        ) const;
    /*++
    Routine Description:
        Returns the dn with which the container was instantiated
    Return value:
        DN of the container
    --*/

    void 
    populate (
        IN const LdapInfo &i, 
        IN const LdapQuery &q
        );
    /*++
    Routine Description:
        Populate the container with the object found by applying the query q on server i
    Arguments:
        i - Apply the query on the server in i, with the credentials in i
        q - Apply the query found in q
    Return Value:
        None
    --*/
    
    void 
    commit (
        LdapInfo &info
        ) const;
    /*++
    Routine Description:
        Write any modified objects found in this container to the LDAP server
    Arguments:
        info - The LDAP credentials to use when binding to the server
    Return Value:
        None
    --*/

    set<T*, LdapObjectCmp> objects;
            
private:
    
    void
    populate_helper (
        IN LDAP *&ld,
        IN PLDAPMessage searchResult
        ) ;
    /*++
    Routine Description:
        Private function to be called by populate(). It will take a PLDAPMessage and will
        add all LDAPObject's found in that message into the current container. 
    Return Value:
        None
    --*/
private:
    wstring m_dn;
    static const int m_page_size = 800;
};

template<class T>
wostream &
operator << (wostream &os, const LdapContainer<T> &c);
/*++
Routine Description:    
    Standard ostream operator for an LdapContainer
--*/

# include "ldap_container.cpp"

# endif    // _ldapp_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adlb\ldap_container.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ldapp.h

Abstract:

    This module define a set of classes to facilitate LDAP queries & commits.

Author:

    Ajit Krishnan (t-ajitk) 10-Jul-2001

Revision History:

    See header file
--*/


# ifndef _ldap_container_implementation_
# define _ldap_container_implementation_

template<class T>
LdapContainer<T>::LdapContainer (
    IN const wstring &dn
    ) {
    /*++
    Routine Description:
    
        Constructor takes a dn. Use "" if there is no appropriate DN
        
    Arguments:
    
        dn - the DN of the container object. If this is not being modelled as an LDAP
        container, any string may be specified. The commit() function will not rename
        the container based on this dn. It is provided as an aid to the programmer.
    --*/
    
    m_dn = dn;    
}

template<class T>
const wstring &
LdapContainer<T>:: getName (
    ) const {
    /*++
    Routine Description:
    
        Returns the dn with which the container was instantiated
        
    Return value:
    
        DN of the container
    --*/
    
    return m_dn;
}


template<class T>
void
LdapContainer<T>::populate_helper (
    IN LDAP *&ld,
    IN PLDAPMessage searchResult
    ) {
    /*++
    Routine Description:
    
        Private function to be called by populate(). It will take a PLDAPMessage and will
        add all LDAPObject's found in that message into the current container. 
        
    Return Value:
    
        None
    --*/
    
    for (LDAPMessage *entry = ldap_first_entry (ld, searchResult);
        entry != NULL;
        entry = ldap_next_entry (ld, entry) 
        ) {
        // Per Result
        // create LdapObject
        
        PWCHAR dn;

        T *lo;
        if ((dn = ldap_get_dn (ld, entry)) != NULL) {
            lo = new T (dn);
            ldap_memfree (dn);
        }

        PWCHAR attr;
        BerElement *ber;

        for (attr = ldap_first_attribute (ld, entry, &ber);
            attr != NULL;
            attr = ldap_next_attribute (ld, entry, ber)
            ) {
            // Per Result/Attribute
            // create Attribute
            
            Attribute *a;
            PWCHAR *values;
            berval **bin_values;
            wstring attr_name (attr);
            if (attr_name == L"schedule") {
                if ((bin_values = ldap_get_values_len(ld, entry, attr)) != NULL) {
                    a = new Attribute (attr);
                    for (int i=0; bin_values[i] != NULL; i++) {
                        // Per Result/Attribute/Value
                        // create AttrValue and add to Attribute

                        PBYTE val = (PBYTE)(malloc(bin_values[i]->bv_len));
                        memcpy ((PVOID)val, (PVOID)bin_values[i]->bv_val, bin_values[i]->bv_len);
                        AttrValue av ((PBYTE) val, bin_values[i]->bv_len);
                        a->addValue (av);
                    }
                    ldap_value_free_len (bin_values);
                }
            } else {
                if ((values = ldap_get_values(ld, entry, attr)) != NULL) {
                    a = new Attribute (attr);
                    for (int i=0; values[i] != NULL; i++) {
                        // Per Result/Attribute/Value
                        // create AttrValue and add to Attribute

                        AttrValue av ((PBYTE)_wcsdup (values[i]), wcslen(values[i]));
                        a->addValue (av);
                    }
                    ldap_value_free (values);
                }
            }
            ldap_memfree (attr);

            // Add Attribute to LdapObject
            lo->addAttribute(*a);
            
        }

        // Add LdapObject to current container
        objects.insert (lo);
        ber_free (ber, 0);
    }
}


template<class T>
void
LdapContainer<T>::populate (
    IN const LdapInfo &h,
    IN const LdapQuery &q
    ) {
    /*++
    Routine Description:
    
        Populate the container with the object found by applying the query q on server i
        
    Arguments:
    
        i - Apply the query on the server in i, with the credentials in i
        q - Apply the query found in q
        
    Return Value:
    
        None
    --*/

    // Get a valid LDAP Handle
    LDAP *ld = h.getHandle();
    int rc;

    PWCHAR baseDn = const_cast<PWCHAR>(q.baseDn.c_str());
    PWCHAR filter = const_cast<PWCHAR>(q.filter.c_str());
    struct l_timeval timeOutStruct = {10L, 0L};
    int timeOutInt = 100;

    // Initialize list of attributes to request from server
    PWCHAR* request_attr;
    vector<wstring>::const_iterator ii;
    request_attr = (PWCHAR*)malloc (sizeof(PCHAR) * (q.attributes.size()+1));
    if( NULL==request_attr ) {
        throw Error (GetMsgString(LBTOOL_OUT_OF_MEMORY));
    }
    
    int request_attr_count = 0;

    for (ii = q.attributes.begin(); ii != q.attributes.end(); ii++) {
        request_attr[request_attr_count++] = const_cast<PWCHAR>(ii->c_str());
    }
    request_attr[request_attr_count] = NULL;

    PLDAPSearch plsearch = ldap_search_init_page (ld, baseDn, q.scope, filter,
        request_attr,            // return specified attributes
        0,                    // return attributes and values
        NULL,                // server controls
        NULL,                // client controls
        timeOutInt,            // time limit
        m_page_size,            // page size
        NULL);                // sort control

    if (plsearch == NULL) {
        throw (Error(GetMsgString(LBTOOL_LDAP_SEARCH_FAILURE)));
    } 

    // page through all results, and stick them into the current container
    PLDAPMessage searchResult = NULL;
    ULONG *msg_number = NULL;
    ULONG num_messages=0;
    rc = LDAP_SUCCESS;
    
    while (rc == LDAP_SUCCESS) {
        rc = ldap_get_next_page_s (ld, plsearch, &timeOutStruct, m_page_size, &num_messages, &searchResult);
        populate_helper (ld, searchResult);
    }

    // make sure it exited only when it finished parsing the results or there were no results
    if (rc != LDAP_NO_RESULTS_RETURNED && rc != LDAP_NO_SUCH_OBJECT) {
        throw (Error(GetMsgString(LBTOOL_LDAP_SEARCH_FAILURE) + wstring(ldap_err2string(rc))));
    }

    // reclaim memory
    rc = ldap_search_abandon_page (ld, plsearch);
    if (rc != LDAP_SUCCESS) {
        throw (Error(GetMsgString(LBTOOL_LDAP_SEARCH_FAILURE) + wstring(ldap_err2string(rc))));
    }
    
}

template<class T>
void
LdapContainer<T> :: commit (
    LdapInfo &info
    ) const {
    /*++
    Routine Description:
    
        Write any modified objects found in this container to the LDAP server
        
    Return Value:
    
        None
    --*/
    
    set<T*,LdapObjectCmp>::iterator ii;

    // Commit each object in the current container
    for (ii = objects.begin(); ii != objects.end(); ii++) {
        (*ii)->commit(info);
    }
}

template<class T>
wostream &
operator << (
    wostream &os,
    const LdapContainer<T> &c
    ) {
    /*++
    Routine Description:
    
        Standard ostream operator for an LdapContainer
    --*/
    
    set<T*,LdapObjectCmp>::const_iterator ii;
    for (ii = c.objects.begin(); ii != c.objects.end(); ii++) {
        LdapObject *lo = *ii;
        os << *(*ii);
        //os << (LdapObject)*(*ii);
    }

    return os;
}

# endif // _ldap_container_implementation_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adprep\lib\adpcheck.c ===
/*++

Copyright (C) Microsoft Corporation, 2001
              Microsoft Windows

Module Name:

    ADPCHECK.C

Abstract:

    This file contains routines that check current OS version, and do 
    necessary update before administrator upgrade the Domain Controller.

Author:

    14-May-01 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    14-May-01 ShaoYin Created Initial File.

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//    Include header files                                              //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





#include "adpcheck.h"

#include "ntdsapi.h"
#include <stdio.h>
#include <stdlib.h>


PVOID
AdpAlloc(
    SIZE_T  Size
    )
/*++
Routine Description;

    allocate memory from process heap
    
Parameters:


Return Value:

    address allocated

--*/
{
    PVOID   pTemp = NULL;

    pTemp = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Size);

    return( pTemp );
}

VOID
AdpFree(
    PVOID BaseAddress
    )
/*++
Routine Description;

    release heap memory
    
Parameters:


Return Value:

    NONE

--*/
{
    if (NULL != BaseAddress) {
        HeapFree(GetProcessHeap(), 0, BaseAddress);
    }
    return;
}




ULONG
AdpExamRevisionAttr(
    IN LDAP *LdapHandle,
    IN PWCHAR pObjectToCheck,
    IN ULONG DesiredRevisionNumber,
    OUT BOOLEAN *fIsFinished,
    IN OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    read object revision attribute, check whether upgrade has been executed or not.

    if the value of revision attribute is 1, upgrade is done
    other FALSE
    
Parameters:


Return Value:

    Win32 error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   LdapError = LDAP_SUCCESS;
    PWCHAR  AttrList[2];
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    PWCHAR  *RevisionValue = NULL;

    //
    // init return value
    // 
    *fIsFinished = FALSE;

    //
    // read "revision" attribute on the target object
    // 
    AttrList[0] = L"revision";
    AttrList[1] = NULL;

    LdapError = ldap_search_sW(LdapHandle,
                               pObjectToCheck,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               AttrList,
                               0,
                               &Result
                               );

    if ((LDAP_SUCCESS == LdapError) &&
        (NULL != Result) &&
        (Entry = ldap_first_entry(LdapHandle,Result)) &&
        (RevisionValue = ldap_get_valuesW(LdapHandle,Entry,AttrList[0]))
        )
    {
        ULONG   Revision = 0;

        Revision = _wtoi(*RevisionValue);

        if (Revision >= DesiredRevisionNumber)
        {
            *fIsFinished = TRUE;
        }
    }
    else
    {
        LdapError = LdapGetLastError();

        if ((LDAP_NO_SUCH_OBJECT != LdapError) && 
            (LDAP_NO_SUCH_ATTRIBUTE != LdapError))
        {
            WinError = LdapMapErrorToWin32( LdapError );
            AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
        }
    }

    if (RevisionValue)
    {
        ldap_value_freeW( RevisionValue );
    }

    if (Result)
    {
        ldap_msgfree( Result );
    }

    return( WinError );
}



ULONG
AdpAmIFSMORoleOwner(
    IN LDAP *LdapHandle,
    IN PWCHAR pFSMORoleOwnerReferenceObjDn, 
    IN PWCHAR pLocalMachineDnsHostName,
    OUT BOOLEAN *fAmIFSMORoleOwner,
    OUT PWCHAR *pFSMORoleOwnerDnsHostName,
    IN OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    determine if the local machine is FSMO role owner, if not who is the FSMO
    role owner. the algorithm to use it:
    
    1. read fSMORoleOwner attribute on pFSMORoleOwnerReferenceObjDn
    2. trim the first part of the value (DN) of fSMORoleOwner attirbute to
       get FSMO Role Owner server object DN
    3. read dnsHostName on the FSMO role owner server object to the server 
       DNS Host Name
    4. compare pLocalMachineDnsHostName and FSMORoleOwnerDnsHostName    
    5. if equal, then yes, the local machine is FSMO role owner
       otherwise, not
    
    
Parameters:


Return Value:

    Win32 error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    PWCHAR  FSMORoleOwnerValue = NULL;
    PWCHAR  pServerObjDn = NULL;
    PWCHAR  pLast = NULL;

    //
    // init return value
    // 
    *fAmIFSMORoleOwner = FALSE;
    *pFSMORoleOwnerDnsHostName = NULL;

    //
    // search pFSMOReferenceObject to find out FSMO Role Owner
    //
    WinError = AdpGetLdapSingleStringValue(LdapHandle, 
                                           pFSMORoleOwnerReferenceObjDn, 
                                           L"fSMORoleOwner", 
                                           &FSMORoleOwnerValue, 
                                           ErrorHandle 
                                           );

    if (ERROR_SUCCESS == WinError)
    {
        //
        // Trim the first part of FSMORoleOwner DN to get DN of the server object 
        //
        pServerObjDn = FSMORoleOwnerValue;
        pLast = FSMORoleOwnerValue + wcslen(pServerObjDn);

        while(pServerObjDn <= pLast)
        {
            if (*pServerObjDn == L',' ||
                *pServerObjDn == L';')
            {
                break;
            }
            pServerObjDn ++;
        }

        if (pServerObjDn < pLast)
        { 
            pServerObjDn ++;
        }
        else
        {
            WinError = ERROR_INTERNAL_ERROR;
            AdpSetWinError(WinError, ErrorHandle);
        }
    }

    if (ERROR_SUCCESS == WinError)
    {
        //
        // search dnsHostName on Server Object (FSMO Role Owner)
        // 
        WinError = AdpGetLdapSingleStringValue(LdapHandle, 
                                               pServerObjDn, 
                                               L"dnsHostName", 
                                               pFSMORoleOwnerDnsHostName, 
                                               ErrorHandle 
                                               );

        if (ERROR_SUCCESS == WinError)
        {
            if (!_wcsicmp(pLocalMachineDnsHostName, *pFSMORoleOwnerDnsHostName))
            {
                *fAmIFSMORoleOwner = TRUE;
            }
        }
    }


    // 
    // cleanup
    //

    if (FSMORoleOwnerValue)
    {
        AdpFree(FSMORoleOwnerValue);
    }

    return( WinError );
}


ULONG
AdpMakeLdapConnection(
    LDAP **LdapHandle,
    PWCHAR HostName,
    ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    create an LDAP connection to the DC (specified by HostName)

    
Parameters:

    LdapHandle - ldap connection to return
    
    HostName - DC name (NULL - means local machine)

    ErrorHandle

Return Value:

    Win32 error

--*/
{
    ULONG   LdapError = LDAP_SUCCESS;
    ULONG   CurrentFlags = 0;

    *LdapHandle = NULL;
    *LdapHandle = ldap_openW(HostName,
                             LDAP_PORT
                             );


    if (NULL == *LdapHandle)
    {
        LdapError = LdapGetLastError();
        goto Error;
    }

    LdapError = ldap_get_optionW(*LdapHandle,
                                 LDAP_OPT_REFERRALS,
                                 &CurrentFlags
                                 );

    if (LDAP_SUCCESS != LdapError) {
        goto Error;
    }

    CurrentFlags = PtrToUlong(LDAP_OPT_OFF);

    LdapError = ldap_set_optionW(*LdapHandle,
                                 LDAP_OPT_REFERRALS,
                                 &CurrentFlags
                                 );

    if (LDAP_SUCCESS != LdapError) {
        goto Error;
    }

    LdapError = ldap_bind_sW(*LdapHandle,
                             NULL,  // dn
                             NULL,  // Cred
                             LDAP_AUTH_SSPI
                             );

Error:

    if (LDAP_SUCCESS != LdapError)
    {
        AdpSetLdapError(*LdapHandle, LdapError, ErrorHandle);
    }

    return( LdapMapErrorToWin32(LdapError) );
}



ULONG
AdpGetSchemaVersionFromIniFile( 
    OUT ULONG *SchemaVersion,
    IN OUT ERROR_HANDLE *ErrorHandle
    )
{
    ULONG       WinError = ERROR_SUCCESS;
    ULONG       nChars = 0;
    WCHAR       Buffer[32];
    WCHAR       IniFileName[MAX_PATH] = L"";
    BOOLEAN     fFound = FALSE;

    WCHAR       *SCHEMASECTION = L"SCHEMA";
    WCHAR       *OBJECTVER = L"objectVersion";
    WCHAR       *DEFAULT = L"NOT_FOUND";


    *SchemaVersion = 0;

    //
    // get Windows Directory path 
    //
    nChars = GetWindowsDirectoryW(IniFileName, MAX_PATH);

    if (nChars == 0 || nChars > MAX_PATH)
    {
        WinError = GetLastError();
        AdpSetWinError(WinError, ErrorHandle);
        return( WinError );
    }

    //
    // create schema.ini file name
    //
    wcscat(IniFileName, L"\\schema.ini"); 

    GetPrivateProfileStringW(SCHEMASECTION,
                             OBJECTVER,
                             DEFAULT,
                             Buffer,
                             sizeof(Buffer)/sizeof(WCHAR),
                             IniFileName
                             );

    if ( _wcsicmp(Buffer, DEFAULT) )
    {
        // Not the default string, so got a value
        *SchemaVersion = _wtoi( Buffer );
        fFound = TRUE;
    }

    if (fFound)
    {
        return( ERROR_SUCCESS );
    }
    else
    {
        WinError = ERROR_FILE_NOT_FOUND;
        AdpSetWinError(WinError, ErrorHandle);
        return( WinError );
    }

}



ULONG
AdpCheckSchemaVersion(
    IN LDAP *LdapHandle,
    IN PWCHAR SchemaObjectDn,
    IN PWCHAR SchemaMasterDnsHostName,
    IN BOOLEAN fAmISchemaMaster,
    OUT BOOLEAN *fIsSchemaUpgradedLocally,
    OUT BOOLEAN *fIsSchemaUpgradedOnSchemaMaster,
    IN OUT ERROR_HANDLE *ErrorHandle
    )
{
    ULONG   WinError = ERROR_SUCCESS;
    LDAP    *SchemaMasterLdapHandle = NULL; 
    PWCHAR  pObjectVersionValue = NULL;
    PWCHAR  pObjectVersionValueSchemaMaster = NULL;
    ULONG   VersionTo = 0; 
    ULONG   VersionLocal = 0;
    ULONG   VersionSchemaMaster = 0;

    //
    // set return value to FALSE
    //
    *fIsSchemaUpgradedLocally = FALSE;
    *fIsSchemaUpgradedOnSchemaMaster = FALSE;


    //
    // get newer schema version from schema.ini file
    // 
    WinError = AdpGetSchemaVersionFromIniFile(&VersionTo, ErrorHandle);

    if (ERROR_SUCCESS != WinError)
    {
        return( WinError );
    }

    //
    // get current schema version from Local DC
    //
    WinError = AdpGetLdapSingleStringValue(LdapHandle, 
                                           SchemaObjectDn,
                                           L"objectVersion", 
                                           &pObjectVersionValue, 
                                           ErrorHandle 
                                           );

    if (ERROR_SUCCESS != WinError)
    {
        goto Error;
    }

    //
    // convert string value to integer
    //
    VersionLocal = _wtoi( pObjectVersionValue );
    

    //
    // check to see if schupgr has been run locally 
    // 
    if (VersionLocal >= VersionTo) 
    {
        *fIsSchemaUpgradedLocally = TRUE;
    }


    if ( (*fIsSchemaUpgradedLocally) || fAmISchemaMaster )
    {
        //
        // Do NOT check schema version on Schema Master if 
        // 1. Schema is up to date on the local DC, then assume schema is up 
        //    to date on schema master as well. 
        // OR 
        // 2. the local DC is schema master
        // 
        *fIsSchemaUpgradedOnSchemaMaster = *fIsSchemaUpgradedLocally;
    }
    else
    {
        // 
        // make ldap connection to Schema Master (locally DC is not FSMO role owner)
        // 
        WinError = AdpMakeLdapConnection(&SchemaMasterLdapHandle, 
                                         SchemaMasterDnsHostName, 
                                         ErrorHandle 
                                         );

        if (ERROR_SUCCESS != WinError)
        {
            goto Error;
        }

        //
        // get schema version on Schema Master DC
        //
        WinError = AdpGetLdapSingleStringValue(SchemaMasterLdapHandle,
                                               SchemaObjectDn,
                                               L"objectVersion", 
                                               &pObjectVersionValueSchemaMaster, 
                                               ErrorHandle 
                                               );

        if (ERROR_SUCCESS != WinError)
        {
            goto Error;
        }

        //
        // convert string value to integer
        //
        VersionSchemaMaster = _wtoi( pObjectVersionValueSchemaMaster );

        if (VersionSchemaMaster >= VersionTo)
        {
            *fIsSchemaUpgradedOnSchemaMaster = TRUE;
        }

    }


Error:

    //
    // clean up
    // 

    if (NULL != pObjectVersionValue)
    {
        AdpFree( pObjectVersionValue );
    }

    if (NULL != pObjectVersionValueSchemaMaster)
    {
        AdpFree( pObjectVersionValueSchemaMaster );
    }

    if (SchemaMasterLdapHandle)
    {
        ldap_unbind_s( SchemaMasterLdapHandle );
    }

    return( WinError );
}



ULONG
AdpCheckUpgradeStatusCommon(
    IN LDAP *LdapHandle,
    IN ULONG DesiredRevisionNumber,
    IN PWCHAR pObjectToCheck,
    IN PWCHAR pFSMORoleOwnerReferenceObjDn, 
    IN PWCHAR pLocalMachineDnsHostName,
    OUT PWCHAR *pFSMORoleOwnerDnsHostName,
    OUT BOOLEAN *fAmIFSMORoleOwner,
    OUT BOOLEAN *fIsFinishedLocally,
    OUT BOOLEAN *fIsFinishedOnFSMORoleOwner,
    IN OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    check domain/forest upgrade status 

    1. read revision attribute on pObjectToCheck

    2. we will know whether upgrade is done or not (revision should be 1 if done)

        2.1 yes, return
        
        2.2 no. then AM I FSMO Role Owner?    

            2.2.1 yes. (I am FSMO role Owner) return
            
            2.2.2 no.
              
                2.2.2.1 make ldap connection to FSMO Role Owner
                
                2.2.2.2 check whether the upgrade is finished on FSMO Role Owner.
   
    
Parameters:


Return Value:

    Win32 error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    LDAP    *FSMORoleOwnerLdapHandle = NULL;

    //
    // initialize the return values;
    // 
    *fIsFinishedLocally = FALSE;
    *fAmIFSMORoleOwner = FALSE;
    *fIsFinishedOnFSMORoleOwner = FALSE;

    //
    // check the object's revision attribute on the local DC
    // 
    WinError = AdpExamRevisionAttr(LdapHandle, 
                                   pObjectToCheck, 
                                   DesiredRevisionNumber, 
                                   fIsFinishedLocally, 
                                   ErrorHandle 
                                   );

    if (ERROR_SUCCESS != WinError)
    {
        goto Cleanup;
    }

    // 
    // continue to find out who IS the FSMO Role Owner
    //
    WinError = AdpAmIFSMORoleOwner(LdapHandle, 
                                   pFSMORoleOwnerReferenceObjDn, 
                                   pLocalMachineDnsHostName, 
                                   fAmIFSMORoleOwner, 
                                   pFSMORoleOwnerDnsHostName, 
                                   ErrorHandle 
                                   );

    if (ERROR_SUCCESS != WinError)
    {
        goto Cleanup;
    }

    if (*fIsFinishedLocally || *fAmIFSMORoleOwner)
    {
        //
        // Do NOT check revision on FSMORoleOwner if 
        // 1. adprep is finished on the local DC, then assume adprep
        //    has been run on FSMORoleOwner already.
        // OR 
        // 2. the local DC is FSMORoleOwner
        // 
        *fIsFinishedOnFSMORoleOwner = *fIsFinishedLocally;
    }
    else
    {
        // 
        // adprep.exe is not finished locally, and the local DC is not FSMORoleOwner 
        // make ldap connection to the FSMO role owner  
        // 
        WinError = AdpMakeLdapConnection(&FSMORoleOwnerLdapHandle,
                                         *pFSMORoleOwnerDnsHostName, 
                                         ErrorHandle 
                                         );

        if (ERROR_SUCCESS != WinError)
        {
            goto Cleanup;
        }

        //
        // check whether update has been done in FSMO role owner
        // 
        WinError = AdpExamRevisionAttr(FSMORoleOwnerLdapHandle, 
                                       pObjectToCheck, 
                                       DesiredRevisionNumber, 
                                       fIsFinishedOnFSMORoleOwner, 
                                       ErrorHandle 
                                       );

    }

Cleanup:

    if (FSMORoleOwnerLdapHandle)
    {
        ldap_unbind_s( FSMORoleOwnerLdapHandle );
    }

    if ( (ERROR_SUCCESS != WinError) && (NULL != *pFSMORoleOwnerDnsHostName) )
    {
        AdpFree( *pFSMORoleOwnerDnsHostName );
        *pFSMORoleOwnerDnsHostName = NULL;
    }

    return( WinError );
}


ULONG
AdpCheckForestUpgradeStatus(
    IN LDAP *LdapHandle,
    OUT PWCHAR  *pSchemaMasterDnsHostName,
    OUT BOOLEAN *fAmISchemaMaster,
    OUT BOOLEAN *fIsFinishedLocally,
    OUT BOOLEAN *fIsFinishedOnSchemaMaster,
    OUT BOOLEAN *fIsSchemaUpgradedLocally,
    OUT BOOLEAN *fIsSchemaUpgradedOnSchemaMaster,
    IN OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    check forest upgrade status 

    create ForestUpdates object DN
    create Schema master FSMO reference object DN
    create local machine DNS host name 

    calling AdpCheckUpgradeStatusCommon()

    
Parameters:


Return Value:

    Win32 error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   LdapError = LDAP_SUCCESS;
    PWCHAR  AttrList[4];
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    PWCHAR  pObjectToCheck = NULL;
    PWCHAR  pSchemaMasterReferenceObjDn = NULL;
    PWCHAR  pDnsHostName = NULL;
    PWCHAR  *pSchemaValue = NULL;
    PWCHAR  *pConfigValue = NULL;
    PWCHAR  *pDnsHostNameValue = NULL;
    ULONG   Length = 0;

    //
    // get SchemaNC and ConfigurationNC to create DN's
    // 
    AttrList[0] = L"schemaNamingContext";
    AttrList[1] = L"configurationNamingContext"; 
    AttrList[2] = L"dnsHostName";
    AttrList[3] = NULL;
                           
    LdapError = ldap_search_sW(LdapHandle,
                               L"",
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               AttrList,
                               0,
                               &Result
                               );

    if (LDAP_SUCCESS != LdapError)
    {
        WinError = LdapMapErrorToWin32( LdapError );
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
    }
    else if ((NULL != Result) &&
             (Entry = ldap_first_entry(LdapHandle, Result)) &&
             (pSchemaValue = ldap_get_valuesW(LdapHandle, Entry, AttrList[0])) &&
             (pConfigValue = ldap_get_valuesW(LdapHandle, Entry, AttrList[1])) &&
             (pDnsHostNameValue = ldap_get_valuesW(LdapHandle, Entry, AttrList[2]))
            )
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;

        Length = (wcslen(*pSchemaValue) + 1) * sizeof(WCHAR);
        pSchemaMasterReferenceObjDn = AdpAlloc(Length);
        if (NULL != pSchemaMasterReferenceObjDn)
        {
            wcscpy(pSchemaMasterReferenceObjDn, *pSchemaValue);

            Length = (wcslen(*pDnsHostNameValue) + 1) * sizeof(WCHAR);
            pDnsHostName = AdpAlloc(Length);
            if (NULL != pDnsHostName)
            {
                wcscpy(pDnsHostName, *pDnsHostNameValue);

                Length = (wcslen(*pConfigValue) + 
                          wcslen(ADP_FOREST_UPDATE_CONTAINER_PREFIX) + 
                          2) * sizeof(WCHAR);

                pObjectToCheck = AdpAlloc(Length);
                if (NULL != pObjectToCheck)
                {
                    swprintf(pObjectToCheck, L"%s,%s", 
                             ADP_FOREST_UPDATE_CONTAINER_PREFIX,
                             *pConfigValue
                             );

                    WinError = ERROR_SUCCESS;
                }
            }
        }

        if (ERROR_SUCCESS != WinError)
        {
            AdpSetWinError(WinError, ErrorHandle);
        }
    }
    else
    {
        LdapError = LdapGetLastError();
        WinError = LdapMapErrorToWin32( LdapError );
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
    }

    if (ERROR_SUCCESS == WinError)
    {
        WinError = AdpCheckUpgradeStatusCommon(LdapHandle, 
                                               ADP_FORESTPREP_CURRENT_REVISION, 
                                               pObjectToCheck, 
                                               pSchemaMasterReferenceObjDn, 
                                               pDnsHostName, 
                                               pSchemaMasterDnsHostName, 
                                               fAmISchemaMaster, 
                                               fIsFinishedLocally, 
                                               fIsFinishedOnSchemaMaster, 
                                               ErrorHandle 
                                               );

        if (ERROR_SUCCESS == WinError) 
        {

            WinError = AdpCheckSchemaVersion(LdapHandle, 
                                             pSchemaMasterReferenceObjDn,  // schema object DN 
                                             *pSchemaMasterDnsHostName,    // schema master DNS host name
                                             *fAmISchemaMaster,            // Am I schema master? 
                                             fIsSchemaUpgradedLocally, 
                                             fIsSchemaUpgradedOnSchemaMaster, 
                                             ErrorHandle 
                                             );
        }
    }

    //
    // cleanup
    // 
    if (pObjectToCheck)
    {
        AdpFree(pObjectToCheck);
    }

    if (pDnsHostName)
    {
        AdpFree(pDnsHostName);
    }

    if (pSchemaMasterReferenceObjDn)
    {
        AdpFree(pSchemaMasterReferenceObjDn);
    }

    if (pDnsHostNameValue)
    {
        ldap_value_freeW( pDnsHostNameValue );
    }

    if (pSchemaValue)
    {
        ldap_value_freeW( pSchemaValue );
    }

    if (pConfigValue)
    {
        ldap_value_freeW( pConfigValue );
    }

    if (Result)
    {
        ldap_msgfree( Result );
    }

    return( WinError );
}


ULONG
AdpCheckGetWellKnownObjectDn(
    IN LDAP *LdapHandle, 
    IN WCHAR *pHostObject,
    IN WCHAR *pWellKnownGuid,
    OUT WCHAR **ppObjName,
    IN OUT ERROR_HANDLE *ErrorHandle
    )
{
    ULONG       WinError = ERROR_SUCCESS;
    ULONG       LdapError = LDAP_SUCCESS;
    PWCHAR      AttrList[2];
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    PWCHAR      pSearchBase = NULL;
    PWCHAR      pDN = NULL;
    ULONG       Length = 0;

    Length = sizeof(WCHAR) * (11 + wcslen(pHostObject) + wcslen(pWellKnownGuid));

    pSearchBase = AdpAlloc( Length );

    if (NULL == pSearchBase)
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        AdpSetWinError(WinError, ErrorHandle);
        return( WinError );
    }

    swprintf(pSearchBase, L"<WKGUID=%s,%s>", pWellKnownGuid, pHostObject);

    AttrList[0] = L"1.1";
    AttrList[1] = NULL;

    LdapError = ldap_search_sW(LdapHandle,
                               pSearchBase,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               AttrList,
                               0,
                               &Result
                               );

    if (LDAP_SUCCESS != LdapError)
    {
        WinError = LdapMapErrorToWin32( LdapError );
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
    }
    else if ((NULL != Result) &&
             (Entry = ldap_first_entry(LdapHandle, Result)) &&
             (pDN = ldap_get_dnW(LdapHandle, Entry))
             )
    {
        Length = sizeof(WCHAR) * (wcslen(pDN) + 1);
        *ppObjName = AdpAlloc( Length ); 

        if (NULL != *ppObjName)
        {
            wcscpy(*ppObjName, pDN);
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            AdpSetWinError(WinError, ErrorHandle);
        }
    }
    else
    {
        LdapError = LdapGetLastError();
        if (LDAP_SUCCESS == LdapError)
        {
            // we didn't get the well known object name, it must be access denied error
            WinError = ERROR_ACCESS_DENIED;
            AdpSetWinError(WinError, ErrorHandle);
        }
        else
        {
            WinError = LdapMapErrorToWin32( LdapError );
            AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
        }
    }

    if (pSearchBase)
    {
        AdpFree( pSearchBase );
    }

    if (pDN)
    {
        ldap_memfreeW( pDN );
    }

    if (Result)
    {
        ldap_msgfree( Result );
    }

    return( WinError );
}


ULONG
AdpCheckDomainUpgradeStatus(
    IN LDAP *LdapHandle,
    OUT PWCHAR  *pInfrastructureMasterDnsHostName,
    OUT BOOLEAN *fAmIInfrastructureMaster,
    OUT BOOLEAN *fIsFinishedLocally,
    OUT BOOLEAN *fIsFinishedOnIM,
    IN OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    check forest upgrade status 

    create DomainUpdates object DN
    create Infrasturcture Master FSMO reference object DN
    create local machine DNS host name 

    calling AdpCheckUpgradeStatusCommon()

    
Parameters:


Return Value:

    Win32 error

--*/
{
    ULONG   WinError = ERROR_SUCCESS;
    ULONG   LdapError = LDAP_SUCCESS;
    PWCHAR  AttrList[3];
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    PWCHAR  pObjectToCheck = NULL;
    PWCHAR  pIMReferenceObjDn = NULL;
    PWCHAR  pDnsHostName = NULL;
    PWCHAR  *pDomainNCValue = NULL;
    PWCHAR  *pDnsHostNameValue = NULL;
    ULONG   Length = 0; 

    //
    // get DomainNC and DnsHostName
    //
    AttrList[0] = L"defaultNamingContext";
    AttrList[1] = L"dnsHostName";
    AttrList[2] = NULL;
    LdapError = ldap_search_sW(LdapHandle,
                               L"",
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               AttrList,
                               0,
                               &Result
                               );

    if (LDAP_SUCCESS != LdapError)
    {
        WinError = LdapMapErrorToWin32( LdapError );
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
    }
    else if ((NULL != Result) &&
             (Entry = ldap_first_entry(LdapHandle, Result)) &&
             (pDomainNCValue = ldap_get_valuesW(LdapHandle, Entry, AttrList[0])) &&
             (pDnsHostNameValue = ldap_get_valuesW(LdapHandle, Entry, AttrList[1]))
             )
    {
        Length = (wcslen(*pDnsHostNameValue) + 1) * sizeof(WCHAR);
        pDnsHostName = AdpAlloc(Length);
        if (NULL != pDnsHostName)
        {
            wcscpy(pDnsHostName, *pDnsHostNameValue);
        }

        Length = (wcslen(*pDomainNCValue) + 
                  wcslen(ADP_DOMAIN_UPDATE_CONTAINER_PREFIX) + 
                  2) * sizeof(WCHAR);

        pObjectToCheck = AdpAlloc(Length);
        if (NULL != pObjectToCheck)
        {
            swprintf(pObjectToCheck, L"%s,%s", 
                     ADP_DOMAIN_UPDATE_CONTAINER_PREFIX,
                     *pDomainNCValue
                     );
        }

        if (NULL == pDnsHostName ||
            NULL == pObjectToCheck)
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            AdpSetWinError(WinError, ErrorHandle);
        }

        if (ERROR_SUCCESS == WinError)
        {
            WinError = AdpCheckGetWellKnownObjectDn(LdapHandle, 
                                                    (*pDomainNCValue), 
                                                    GUID_INFRASTRUCTURE_CONTAINER_W, 
                                                    &pIMReferenceObjDn, 
                                                    ErrorHandle 
                                                    );
        }


        if (ERROR_SUCCESS == WinError)
        {
            WinError = AdpCheckUpgradeStatusCommon(LdapHandle, 
                                                   ADP_DOMAINPREP_CURRENT_REVISION, 
                                                   pObjectToCheck, 
                                                   pIMReferenceObjDn, 
                                                   pDnsHostName, 
                                                   pInfrastructureMasterDnsHostName, 
                                                   fAmIInfrastructureMaster, 
                                                   fIsFinishedLocally, 
                                                   fIsFinishedOnIM, 
                                                   ErrorHandle 
                                                   );
        }

    }
    else
    {
        LdapError = LdapGetLastError();
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
        WinError = LdapMapErrorToWin32( LdapError );
    }


    //
    // cleanup
    // 
    if (pObjectToCheck)
    {
        AdpFree(pObjectToCheck);
    }

    if (pDnsHostName)
    {
        AdpFree(pDnsHostName);
    }

    if (pIMReferenceObjDn)
    {
        AdpFree(pIMReferenceObjDn);
    }

    if (pDnsHostNameValue)
    {
        ldap_value_freeW( pDnsHostNameValue );
    }

    if (pDomainNCValue)
    {
        ldap_value_freeW( pDomainNCValue );
    }

    if (Result)
    {
        ldap_msgfree( Result );
    }

    return( WinError );
}


VOID
AdpClearError( 
    IN OUT ERROR_HANDLE *ErrorHandle 
    )
{
    // free memory 
    if (ErrorHandle->WinErrorMsg)
    {
        LocalFree( ErrorHandle->WinErrorMsg );
    }

    if (ErrorHandle->LdapServerErrorMsg)
    {
        ldap_memfree( ErrorHandle->LdapServerErrorMsg );
    }

    memset(ErrorHandle, 0, sizeof(ERROR_HANDLE));
}

VOID
AdpSetWinError(
    IN ULONG WinError,
    OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description:
    
    This routine gets Win32 error string for the passed in Win32 Error code 

Parameters:

    WinError - Win32 Error Code
    
    ErrorHandle - container the return error code and error message    
--*/
{
    ULONG       BufLength = 0;
    PWCHAR      WinErrorMsg = NULL;

    if (ERROR_SUCCESS == WinError)
    {
        return;
    }

    // no error has been set previously
    ASSERT( 0 == ErrorHandle->Flags );


    // indicate this is WinError
    ErrorHandle->Flags = ADP_WIN_ERROR;

    // Set error code first
    ErrorHandle->WinErrorCode = WinError;

    // format Win32 error string
    BufLength = 0;
    BufLength = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                               FORMAT_MESSAGE_ALLOCATE_BUFFER,
                               NULL,
                               WinError,
                               0,
                               (LPWSTR) &WinErrorMsg,
                               0,
                               NULL
                               );

    if ( (0 != BufLength) && (NULL != WinErrorMsg) )
    {
        //
        //  Messages from a message file have a cr and lf appended to the end
        //
        WinErrorMsg[ BufLength - 2 ] = L'\0';

        ErrorHandle->WinErrorMsg = WinErrorMsg;
    }


    return; 
}

VOID
AdpSetLdapError(
    IN LDAP *LdapHandle,
    IN ULONG LdapError,
    OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description

    This routine tries to get the error code and error message about the 
    ldap failure in best effort.
    
    Note: if it fails to gather ExtendedError or fails to create error message, 
          only the ErrorCode will be set. ErrorMsg will be left as NULL. 

Parameter

    LdapHandle - ldap handle
    
    LdapError --- ldap error
    
    ErrorHandle - container the return error code and error message    

Return Value    

--*/
{
    ULONG       IgnoredLdapError = LDAP_SUCCESS;
    BOOLEAN     UseWinErrorMsg = TRUE;
    ULONG       ServerExtErrorCode = 0;
    PWCHAR      ServerErrorMsg = NULL;


    if (LDAP_SUCCESS == LdapError)
    {
        return;
    }

    // no error has been set previously
    ASSERT( 0 == ErrorHandle->Flags );

    //
    // if the LdapHandle is good, try to get ServerError and Extended Error
    // 
    if (NULL != LdapHandle)
    {
        // don't use WinError
        UseWinErrorMsg = FALSE;

        //
        // get Ldap server side error code (this should be an Win32 error code)
        // 
        IgnoredLdapError = ldap_get_optionW(LdapHandle, LDAP_OPT_SERVER_EXT_ERROR, &ServerExtErrorCode);

        // printf("Server Error Number is 0x%x IgnoredLdapError 0x%x\n", ServerExtErrorCode, IgnoredLdapError);

        if (LDAP_SUCCESS != IgnoredLdapError)
        {
            UseWinErrorMsg = TRUE;
        }
        else
        {
            //
            // get server error msg, including server error code, msg, DSID
            // 
            IgnoredLdapError = ldap_get_optionW(LdapHandle, LDAP_OPT_SERVER_ERROR, &ServerErrorMsg);

            // printf("Server Error Msg is %ls IgnoredLdapError 0x%x\n", ServerErrorMsg, IgnoredLdapError);

            if (LDAP_SUCCESS != IgnoredLdapError)
            {
                UseWinErrorMsg = TRUE;
            }
            else
            {
                ErrorHandle->Flags = ADP_LDAP_ERROR;
                ErrorHandle->LdapErrorCode = LdapError;
                ErrorHandle->LdapServerExtErrorCode = ServerExtErrorCode;
                ErrorHandle->LdapServerErrorMsg = ServerErrorMsg;
            }
        }
    }

    //
    // if LdapHandle is invalid or can't get ExtendedError, using WinError
    // 
    if ( UseWinErrorMsg )
    {
        // convert LdapError to WinError
        AdpSetWinError( LdapMapErrorToWin32(LdapError), ErrorHandle );

    }

    return;
}





ULONG
AdpGetLdapSingleStringValue(
    IN LDAP *LdapHandle,
    IN PWCHAR pObjDn,
    IN PWCHAR pAttrName,
    OUT PWCHAR *ppAttrValue,
    OUT ERROR_HANDLE *ErrorHandle
    )
/*++
Routine Description;

    read DS object, retrieve single string-value attribute
    
Parameters:


Return Value:

    Win32 error

--*/
{
    ULONG       WinError = ERROR_SUCCESS;
    ULONG       LdapError = LDAP_SUCCESS;
    PWCHAR      AttrList[2];
    LDAPMessage *Result = NULL;
    LDAPMessage *Entry = NULL;
    PWCHAR      *Value = NULL;


    *ppAttrValue = NULL;

    AttrList[0] = pAttrName;
    AttrList[1] = NULL;

    LdapError = ldap_search_sW(LdapHandle,
                               pObjDn,
                               LDAP_SCOPE_BASE,
                               L"(objectClass=*)",
                               AttrList,
                               0,
                               &Result
                               );

    if (LDAP_SUCCESS != LdapError)
    {
        WinError = LdapMapErrorToWin32( LdapError );
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
    }
    else if ((NULL != Result) &&
             (Entry = ldap_first_entry(LdapHandle, Result)) &&
             (Value = ldap_get_valuesW(LdapHandle, Entry, pAttrName))
             )
    {
        ULONG   Length = 0;

        Length = (wcslen(*Value) + 1) * sizeof(WCHAR);

        *ppAttrValue = AdpAlloc( Length );
        if (NULL != *ppAttrValue)
        {
            wcscpy(*ppAttrValue, *Value);
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            AdpSetWinError(WinError, ErrorHandle);
        }
    }
    else
    {
        LdapError = LdapGetLastError();
        WinError = LdapMapErrorToWin32( LdapError );
        AdpSetLdapError(LdapHandle, LdapError, ErrorHandle);
    }

    if (Value)
    {
        ldap_value_freeW( Value );
    }

    if (Result)
    {
        ldap_msgfree( Result );
    }

    return( WinError );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adprep\exe\global.c ===
/*++

Copyright (C) Microsoft Corporation, 2001
              Microsoft Windows

Module Name:

    GLOBAL.C

Abstract:

    This files contains all information about Forest/Domain Upgrade Operation

    NOTE: whenever a new operation is added to this file, the author should 
          also update the following files:
          
            1. schema.ini  add the coresponding operation GUID for fresh
               installation case. 
               
            2. schema.ini  increase the value of "revision" attribute of 
               cn=Windows2002Update,cn=DomainUpdates,cn=System  and 
               cn=Windows2002Update,cn=ForestUpdates,cn=Configuration

            3. adpcheck.h  increate the value of current ADPrep revision

Author:

    14-May-01 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    14-May-01 ShaoYin Created Initial File.

--*/








#include "adp.h"



//
// global variables
//


// ldap handle (connect to the local host DC)
LDAP    *gLdapHandle = NULL;

// log file
FILE    *gLogFile = NULL;

// mutex - controls one and only one adprep.exe is running 
HANDLE  gMutex = NULL;

// critical section - used to access Console CTRL signal variables
CRITICAL_SECTION     gConsoleCtrlEventLock;
BOOL                 gConsoleCtrlEventLockInitialized = FALSE;


// Console CTRL signal variable
BOOL                 gConsoleCtrlEventReceived = FALSE;

PWCHAR  gDomainNC = NULL;
PWCHAR  gConfigurationNC = NULL;
PWCHAR  gSchemaNC = NULL;
PWCHAR  gDomainPrepOperations = NULL;
PWCHAR  gForestPrepOperations = NULL;
PWCHAR  gLogPath = NULL;


//
// Domain Operations 
//     For each operation the following information will be provided
//     1. object name
//     2. attribute list or ACE list or desired info to complete the operation
//     3. task table
// 

//
// Domain Operation 01 Object Name
//
OBJECT_NAME Domain_OP_01_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=WMIPolicy,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
//
// Domain Operation 01 attribute list
//
ATTR_LIST Domain_OP_01_AttrList[] =
{
    {LDAP_MOD_ADD, 
     L"objectClass", 
     L"container"
    },
};
//
// Domain Operation 01 TaskTable
//
TASK_TABLE  Domain_OP_01_TaskTable[] = 
{
    {&Domain_OP_01_ObjName,
     NULL,          // member name
     L"O:DAD:P(A;;CCLCSWRPWPLORC;;;BA)(A;;CCLCSWRPWPLORC;;;PA)(A;CI;LCRPLORC;;;AU)(A;CI;LCRPLORC;;;SY)(A;CI;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;EA)(A;CI;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;DA)(A;CIIO;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;CO)",
     Domain_OP_01_AttrList, // Attrs
     ARRAY_COUNT(Domain_OP_01_AttrList),    // number of attrs
     NULL,                  // Aces
     0,                     // number of Aces
     NULL,                  // call back
     0                      // Special Task Code
    },
};




//
// Domain OP 02 Object Name
//
OBJECT_NAME Domain_OP_02_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN=ComPartitions,CN=System",
    NULL,   // GUID
    NULL    // SID
};
// Domain OP 02 attribute list
ATTR_LIST Domain_OP_02_AttrList[] =
{
    {LDAP_MOD_ADD,
     L"objectClass",
     L"container"
     },
};
// Domain OP 02 task table
TASK_TABLE Domain_OP_02_TaskTable[] =
{
    {&Domain_OP_02_ObjName,
     NULL,  // member
     L"O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCDCRCWDWOSW;;;DA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)",
     Domain_OP_02_AttrList, 
     ARRAY_COUNT(Domain_OP_02_AttrList),
     NULL,                  // Aces
     0,                     // number of Aces
     NULL,                  // call back
     0                      // Special Task Code
     },
};





// Domain OP 03 Object Name
OBJECT_NAME Domain_OP_03_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN=ComPartitionSets,CN=System",
    NULL,   // GUID
    NULL    // SID
};
// Domain OP 03 attribute list
ATTR_LIST Domain_OP_03_AttrList[] =
{
    {LDAP_MOD_ADD,
     L"objectClass",
     L"container"
    },
};
// Domain OP 03 tasktable
TASK_TABLE Domain_OP_03_TaskTable[] =
{
    {&Domain_OP_03_ObjName,
     NULL,  // member
     L"O:DAG:DAD:(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCDCRCWDWOSW;;;DA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)",
     Domain_OP_03_AttrList, 
     ARRAY_COUNT(Domain_OP_03_AttrList),
     NULL,                  // Aces
     0,                     // number of Aces
     NULL,                  // call back
     0                      // Special Task Code
    },
};




//
// Domain Operation 04 - Pre Windows2000 Compat Access Group members change
//
TASK_TABLE  Domain_OP_04_TaskTable[] =
{
    {NULL,  // Target object name
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,     // number of attr
     NULL,  // aces
     0,     // number of ace
     NULL,  // call back function
     PreWindows2000Group      // Special Task Code
    },
};





//
// Domain OP 05 - object Name (also used by other operations)
//
OBJECT_NAME Domain_ObjName = 
{
    ADP_OBJNAME_NONE | ADP_OBJNAME_DOMAIN_NC,
    NULL,   // CN
    NULL,   // GUID
    NULL    // SID
};
// Domain OP 05 ACE list
ACE_LIST Domain_OP_05_AceList[] =
{
    {ADP_ACE_ADD,
     L"(OA;;RP;c7407360-20bf-11d0-a768-00aa006e0529;;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RP;b8119fd0-04f6-4762-ab7a-4986c76b3f9a;;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RP;b8119fd0-04f6-4762-ab7a-4986c76b3f9a;;AU)"
    },
};
// Domain OP 05 Tasktable
TASK_TABLE  Domain_OP_05_TaskTable[] = 
{
    {&Domain_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_05_AceList,
     ARRAY_COUNT(Domain_OP_05_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};



//
// domain operation 06
// this operation was removed on Jan. 24, 2002, see RAID 522886
//


//
// domain operation 07
//

OBJECT_NAME Domain_OP_07_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN={31B2F340-016D-11D2-945F-00C04FB984F9},CN=Policies,CN=System",
    NULL,   // GUID
    NULL    // SID
};
ACE_LIST Domain_OP_07_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(A;;LCRPLORC;;;ED)"
    },
};
TASK_TABLE Domain_OP_07_TaskTable[] =
{
    {&Domain_OP_07_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_07_AceList,
     ARRAY_COUNT(Domain_OP_07_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};




//
// domain operation 08
//
OBJECT_NAME Domain_OP_08_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN={6AC1786C-016F-11D2-945F-00C04fB984F9},CN=Policies,CN=System",
    NULL,   // GUID
    NULL    // SID
};
ACE_LIST Domain_OP_08_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(A;;LCRPLORC;;;ED)"
    },
};
TASK_TABLE Domain_OP_08_TaskTable[] =
{
    {&Domain_OP_08_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_08_AceList,
     ARRAY_COUNT(Domain_OP_08_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};




//
// domain operation 09
//

OBJECT_NAME Domain_OP_09_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN=Policies,CN=System",
    NULL,   // GUID
    NULL    // SID
};
ACE_LIST Domain_OP_09_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;CI;LCRPLORC;;f30e3bc2-9ff0-11d1-b603-0000f80367c1;ED)"
    },
};
TASK_TABLE Domain_OP_09_TaskTable[] =
{
    {&Domain_OP_09_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_09_AceList,
     ARRAY_COUNT(Domain_OP_09_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};


//
// domain operation 10 
//
OBJECT_NAME Domain_OP_10_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN=AdminSDHolder,CN=System",
    NULL,   // GUID
    NULL    // SID
};
ACE_LIST Domain_OP_10_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;PS)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RPWP;bf967a7f-0de6-11d0-a285-00aa003049e2;;CA)"
    },
};
TASK_TABLE Domain_OP_10_TaskTable[] =
{
    {&Domain_OP_10_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_10_AceList,
     ARRAY_COUNT(Domain_OP_10_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};




//
// domain operation 11 
//
OBJECT_NAME Domain_OP_11_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN=User,CN={31B2F340-016D-11D2-945F-00C04FB984F9},CN=Policies,CN=System",
    NULL,   // GUID
    NULL    // SID
};
ACE_LIST Domain_OP_11_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(A;;LCRPLORC;;;ED)"
    },
};
TASK_TABLE Domain_OP_11_TaskTable[] =
{
    {&Domain_OP_11_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_11_AceList,
     ARRAY_COUNT(Domain_OP_11_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};



//
// domain operation 12 
//
OBJECT_NAME Domain_OP_12_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN=User,CN={6AC1786C-016F-11D2-945F-00C04fB984F9},CN=Policies,CN=System",
    NULL,   // GUID
    NULL    // SID
};
ACE_LIST Domain_OP_12_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(A;;LCRPLORC;;;ED)"
    },
};
TASK_TABLE Domain_OP_12_TaskTable[] =
{
    {&Domain_OP_12_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_12_AceList,
     ARRAY_COUNT(Domain_OP_12_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};


//
// domain operation 13 
//
OBJECT_NAME Domain_OP_13_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN=Machine,CN={6AC1786C-016F-11D2-945F-00C04fB984F9},CN=Policies,CN=System",
    NULL,   // GUID
    NULL    // SID
};
ACE_LIST Domain_OP_13_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(A;;LCRPLORC;;;ED)"
    },
};
TASK_TABLE Domain_OP_13_TaskTable[] =
{
    {&Domain_OP_13_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_13_AceList,
     ARRAY_COUNT(Domain_OP_13_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};


//
// domain operation 14 
//
OBJECT_NAME Domain_OP_14_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN=Machine,CN={31B2F340-016D-11D2-945F-00C04FB984F9},CN=Policies,CN=System",
    NULL,   // GUID
    NULL    // SID
};
ACE_LIST Domain_OP_14_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(A;;LCRPLORC;;;ED)"
    },
};
TASK_TABLE Domain_OP_14_TaskTable[] =
{
    {&Domain_OP_14_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_14_AceList,
     ARRAY_COUNT(Domain_OP_14_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};




//
// domain operation 15 
//
ATTR_LIST Domain_OP_15_AttrList[] =
{
    {LDAP_MOD_REPLACE,
     L"msDS-PerUserTrustQuota",
     L"1"
    },
    {LDAP_MOD_REPLACE,
     L"msDS-AllUsersTrustQuota",
     L"1000"
    },
    {LDAP_MOD_REPLACE,
     L"msDS-PerUserTrustTombstonesQuota",
     L"10"
    },
};
TASK_TABLE Domain_OP_15_TaskTable[] =
{
    {&Domain_ObjName,
     NULL,          // member name
     NULL,          // object SD 
     Domain_OP_15_AttrList, // Attrs
     ARRAY_COUNT(Domain_OP_15_AttrList),    // number of attrs
     NULL,                  // Aces
     0,                     // number of Aces
     NULL,                  // call back
     0                      // Special Task Code
    },
};


//
// domain operation 16 --- this operation is removed on April. 17, 2002
// RAID 498986. 
//


//
// domain operation 17 (Add ACEs to domain object)
// RAID bug # 423557
// 
ACE_LIST Domain_OP_17_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;DD)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;BA)"
    },
};
TASK_TABLE Domain_OP_17_TaskTable[] =
{
    {&Domain_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_17_AceList,
     ARRAY_COUNT(Domain_OP_17_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};


//
// Domain Operation 18 
// invoke the call back funtion to update sysvol ACLs corresponding to a GPO
// BUG 317412
//
TASK_TABLE Domain_OP_18_TaskTable[] =
{
    {NULL,  // Object Name
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     NULL,  // AceList
     0,
     UpgradeGPOSysvolLocation,  // call back function
     0      // Special Task Code
    }
};


//
// domain operation 19 (Selectively Add ACEs to domain object)
// RAID bug # 421784
// 
OBJECT_NAME Domain_OP_19_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN=Server,CN=System",
    NULL,   // GUID
    NULL    // SID
};

ACE_LIST Domain_OP_19_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;CR;91d67418-0135-4acc-8d79-c08e857cfbec;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;91d67418-0135-4acc-8d79-c08e857cfbec;;RU)"
    },
};
TASK_TABLE Domain_OP_19_TaskTable[] =
{
    {&Domain_OP_19_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_19_AceList,
     ARRAY_COUNT(Domain_OP_19_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};


//
// domain operation 20 (Add ACEs to domain object)
// RAID bug # 468773 (linked with Forest OP 15, Forest OP 16 
// userLogon PropertySet and DisplayName
// 
// this operation was removed on Jan. 24, 2002, see RAID 522886
// 


//
// domain operation 21 (Add ACEs to domain object)
// RAID bug # 468773 (linked with Forest OP 15, Forest OP 16 
// description attribute
// 
// this operation was removed on Jan. 24, 2002, see RAID 522886
// 



//
// Domain Operation 22  --- Create CN=ForeignSecurityPrincipals Container
// see Bug 490029 for detail
// 

//
// Domain Operation 22 Object Name
//
OBJECT_NAME Domain_OP_22_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ForeignSecurityPrincipals",        // RDN
    NULL,       // GUID
    NULL        // SID
};
//
// Domain Operation 22 attribute list
//
ATTR_LIST Domain_OP_22_AttrList[] =
{
    {LDAP_MOD_ADD, 
     L"objectClass", 
     L"container"
    },
    {LDAP_MOD_ADD,
     L"description",
     L"Default container for security identifiers (SIDs) associated with objects from external, trusted domains"
    },
    {LDAP_MOD_ADD,
     L"ShowInAdvancedViewOnly",
     L"FALSE"
    },
};
//
// Domain Operation 22 TaskTable
//
TASK_TABLE  Domain_OP_22_TaskTable[] = 
{
    {&Domain_OP_22_ObjName,
     NULL,          // member name
     L"O:DAG:DAD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPLCLORC;;;AU)",
     Domain_OP_22_AttrList, // Attrs
     ARRAY_COUNT(Domain_OP_22_AttrList),    // number of attrs
     NULL,                  // Aces
     0,                     // number of Aces
     NULL,                  // call back
     0                      // Special Task Code
    },
};





//
// domain operation 23 (Replace an existing ACE in an existing object)
// remove on April 23, 2002
// 








//
// Domain Operation 24, create CN=Program Data,DC=X container
// RAID 595039
//

//
// Domain Operation 24 Object Name
//
OBJECT_NAME Domain_OP_24_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=Program Data", // CN
    NULL,       // GUID
    NULL        // SID
};
//
// Domain Operation 24 attribute list
//
ATTR_LIST Domain_OP_24_AttrList[] =
{
    {LDAP_MOD_ADD, 
     L"objectClass", 
     L"container"
    },
    {
     LDAP_MOD_ADD,
     L"description",
     L"Default location for storage of application data."
    }
};
//
// Domain Operation 24 TaskTable
//
TASK_TABLE  Domain_OP_24_TaskTable[] = 
{
    {&Domain_OP_24_ObjName,
     NULL,          // member name
     L"O:DAG:DAD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPLCLORC;;;AU)",
     Domain_OP_24_AttrList, // Attrs
     ARRAY_COUNT(Domain_OP_24_AttrList),    // number of attrs
     NULL,                  // Aces
     0,                     // number of Aces
     NULL,                  // call back
     0                      // Special Task Code
    },
};






//
// Domain Operation 25  --- Create CN=Microsoft,CN=Program Data,DC=X
// RAID 595039
// 

//
// Domain Operation 25 Object Name
//
OBJECT_NAME Domain_OP_25_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=Microsoft,CN=Program Data",
    NULL,       // GUID
    NULL        // SID
};
//
// Domain Operation 25 attribute list
//
ATTR_LIST Domain_OP_25_AttrList[] =
{
    {LDAP_MOD_ADD, 
     L"objectClass", 
     L"container"
    },
    {LDAP_MOD_ADD,
     L"description",
     L"Default location for storage of Microsoft application data."
    },
};
//
// Domain Operation 25 TaskTable
//
TASK_TABLE  Domain_OP_25_TaskTable[] = 
{
    {&Domain_OP_25_ObjName,
     NULL,          // member name
     L"O:DAG:DAD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPLCLORC;;;AU)",
     Domain_OP_25_AttrList, // Attrs
     ARRAY_COUNT(Domain_OP_25_AttrList),    // number of attrs
     NULL,                  // Aces
     0,                     // number of Aces
     NULL,                  // call back
     0                      // Special Task Code
    },
};




//
// domain operation 26 (modify securityDescriptor on existing Domain Object)
// RAID 498986. 
// replace 
// (OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;BU)
// with 
// (OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;S-1-5-32-557)
//
ACE_LIST Domain_OP_26_AceList[] = 
{
    {ADP_ACE_DEL,
     L"(OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;BU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;S-1-5-32-557)"
    },
};
TASK_TABLE Domain_OP_26_TaskTable[] =
{
    {&Domain_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_26_AceList,
     ARRAY_COUNT(Domain_OP_26_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};





//
// domain operation 27 (modify securityDescriptor on the Domain NC Head Object)
// RAID 606437
// Granted following 3 ControlAccessRights to Authenticated Users
//
ACE_LIST Domain_OP_27_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;CR;280f369c-67c7-438e-ae98-1d46f3c6f541;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;ccc2dc7d-a6ad-4a7a-8846-c04e3cc53501;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;05c74c5e-4deb-43b4-bd9f-86664c2a7fd5;;AU)"
    },
};
TASK_TABLE Domain_OP_27_TaskTable[] =
{
    {&Domain_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_27_AceList,
     ARRAY_COUNT(Domain_OP_27_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};



//
// Domain Operation 28 Object Name
// Create CN=SOM,CN=WMIPolicy object   
// RAID 631375
//
OBJECT_NAME Domain_OP_28_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=SOM,CN=WMIPolicy,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
ATTR_LIST Domain_OP_28_AttrList[] =
{
    {LDAP_MOD_ADD, 
     L"objectClass", 
     L"container"
    },
};
TASK_TABLE  Domain_OP_28_TaskTable[] = 
{
    {&Domain_OP_28_ObjName,
     NULL,          // member name
     L"O:DAD:P(A;CI;LCRPLORC;;;AU)(A;CI;LCRPLORC;;;SY)(A;CI;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;DA)(A;CI;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;EA)(A;;CCLCSWRPWPLORC;;;BA)(A;;CCLCSWRPWPLORC;;;PA)(A;CIIO;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;CO)",
     Domain_OP_28_AttrList, // Attrs
     ARRAY_COUNT(Domain_OP_28_AttrList),    // number of attrs
     NULL,                  // Aces
     0,                     // number of Aces
     NULL,                  // call back
     0                      // Special Task Code
    },
};





//
// domain operation 29 (modify securityDescriptor on CN=IP Security,CN=System object 
// RAID 645935
//
OBJECT_NAME Domain_OP_29_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
ACE_LIST Domain_OP_29_AceList[] = 
{
    {ADP_ACE_DEL,
     L"(A;;RPLCLORC;;;AU)"
    },
    {ADP_ACE_DEL,
     L"(A;;RPWPCRLCLOCCDCRCWDWOSW;;;DA)"
    },
    {ADP_ACE_DEL,
     L"(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)"
    },
    {ADP_ACE_ADD,
     L"(A;CI;RPLCLORC;;;DC)"
    },
    {ADP_ACE_ADD,
     L"(A;CI;RPLCLORC;;;PA)"
    },
    {ADP_ACE_ADD,
     L"(A;CI;RPWPCRLCLOCCDCRCWDWOSW;;;DA)"
    },
    {ADP_ACE_ADD,
     L"(A;CI;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)"
    },
};
TASK_TABLE Domain_OP_29_TaskTable[] =
{
    {&Domain_OP_29_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_29_AceList,
     ARRAY_COUNT(Domain_OP_29_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};



//
// domain operation 30 - 51 (modify securityDescriptor on following objects)
// CN=ipsecPolicy{72385230-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System
// CN=ipsecISAKMPPolicy{72385231-70FA-11D1-864C-14A300000000}
// CN=ipsecNFA{72385232-70FA-11D1-864C-14A300000000}
// CN=ipsecNFA{59319BE2-5EE3-11D2-ACE8-0060B0ECCA17}
// CN=ipsecNFA{594272E2-071D-11D3-AD22-0060B0ECCA17}
// CN=ipsecNFA{6A1F5C6F-72B7-11D2-ACF0-0060B0ECCA17}
// CN=ipsecPolicy{72385236-70FA-11D1-864C-14A300000000}
// CN=ipsecISAKMPPolicy{72385237-70FA-11D1-864C-14A300000000}
// CN=ipsecNFA{59319C04-5EE3-11D2-ACE8-0060B0ECCA17}
// CN=ipsecPolicy{7238523C-70FA-11D1-864C-14A300000000}
// CN=ipsecISAKMPPolicy{7238523D-70FA-11D1-864C-14A300000000}
// CN=ipsecNFA{7238523E-70FA-11D1-864C-14A300000000}
// CN=ipsecNFA{59319BF3-5EE3-11D2-ACE8-0060B0ECCA17}
// CN=ipsecNFA{594272FD-071D-11D3-AD22-0060B0ECCA17}
// CN=ipsecNegotiationPolicy{59319BDF-5EE3-11D2-ACE8-0060B0ECCA17}
// CN=ipsecNegotiationPolicy{59319BF0-5EE3-11D2-ACE8-0060B0ECCA17}
// CN=ipsecNegotiationPolicy{59319C01-5EE3-11D2-ACE8-0060B0ECCA17}
// CN=ipsecNegotiationPolicy{72385233-70FA-11D1-864C-14A300000000}
// CN=ipsecNegotiationPolicy{7238523F-70FA-11D1-864C-14A300000000}
// CN=ipsecNegotiationPolicy{7238523B-70FA-11D1-864C-14A300000000}
// CN=ipsecFilter{7238523A-70FA-11D1-864C-14A300000000}
// CN=ipsecFilter{72385235-70FA-11D1-864C-14A300000000}
// 
// RAID 645935
//
OBJECT_NAME Domain_OP_30_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecPolicy{72385230-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
ACE_LIST Domain_OP_30_AceList[] = 
{
    {ADP_ACE_DEL,
     L"(A;;RPLCLORC;;;AU)"
    },
    {ADP_ACE_DEL,
     L"(A;;RPWPCRLCLOCCDCRCWDWOSW;;;DA)"
    },
    {ADP_ACE_DEL,
     L"(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)"
    },
};
TASK_TABLE Domain_OP_30_TaskTable[] =
{
    {&Domain_OP_30_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};


OBJECT_NAME Domain_OP_31_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecISAKMPPolicy{72385231-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_31_TaskTable[] =
{
    {&Domain_OP_31_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};


OBJECT_NAME Domain_OP_32_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNFA{72385232-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_32_TaskTable[] =
{
    {&Domain_OP_32_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_33_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNFA{59319BE2-5EE3-11D2-ACE8-0060B0ECCA17},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_33_TaskTable[] =
{
    {&Domain_OP_33_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_34_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNFA{594272E2-071D-11D3-AD22-0060B0ECCA17},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_34_TaskTable[] =
{
    {&Domain_OP_34_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_35_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNFA{6A1F5C6F-72B7-11D2-ACF0-0060B0ECCA17},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_35_TaskTable[] =
{
    {&Domain_OP_35_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_36_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecPolicy{72385236-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_36_TaskTable[] =
{
    {&Domain_OP_36_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_37_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecISAKMPPolicy{72385237-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_37_TaskTable[] =
{
    {&Domain_OP_37_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_38_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNFA{59319C04-5EE3-11D2-ACE8-0060B0ECCA17},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_38_TaskTable[] =
{
    {&Domain_OP_38_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_39_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecPolicy{7238523C-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_39_TaskTable[] =
{
    {&Domain_OP_39_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_40_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecISAKMPPolicy{7238523D-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_40_TaskTable[] =
{
    {&Domain_OP_40_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_41_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNFA{7238523E-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_41_TaskTable[] =
{
    {&Domain_OP_41_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_42_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNFA{59319BF3-5EE3-11D2-ACE8-0060B0ECCA17},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_42_TaskTable[] =
{
    {&Domain_OP_42_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_43_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNFA{594272FD-071D-11D3-AD22-0060B0ECCA17},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_43_TaskTable[] =
{
    {&Domain_OP_43_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_44_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNegotiationPolicy{59319BDF-5EE3-11D2-ACE8-0060B0ECCA17},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_44_TaskTable[] =
{
    {&Domain_OP_44_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_45_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNegotiationPolicy{59319BF0-5EE3-11D2-ACE8-0060B0ECCA17},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_45_TaskTable[] =
{
    {&Domain_OP_45_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_46_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNegotiationPolicy{59319C01-5EE3-11D2-ACE8-0060B0ECCA17},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_46_TaskTable[] =
{
    {&Domain_OP_46_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_47_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNegotiationPolicy{72385233-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_47_TaskTable[] =
{
    {&Domain_OP_47_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_48_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNegotiationPolicy{7238523F-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_48_TaskTable[] =
{
    {&Domain_OP_48_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_49_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecNegotiationPolicy{7238523B-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_49_TaskTable[] =
{
    {&Domain_OP_49_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_50_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecFilter{7238523A-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_50_TaskTable[] =
{
    {&Domain_OP_50_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};

OBJECT_NAME Domain_OP_51_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC, 
    L"CN=ipsecFilter{72385235-70FA-11D1-864C-14A300000000},CN=IP Security,CN=System",  // CN
    NULL,       // GUID
    NULL        // SID
};
TASK_TABLE Domain_OP_51_TaskTable[] =
{
    {&Domain_OP_51_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_30_AceList,
     ARRAY_COUNT(Domain_OP_30_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};




//
// domain operation 52 (modify securityDescriptor on the Domain NC Head Object)
// RAID 187994
//
ACE_LIST Domain_OP_52_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(A;;LCRPLORC;;;ED)"
    },
};
TASK_TABLE Domain_OP_52_TaskTable[] =
{
    {&Domain_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_52_AceList,
     ARRAY_COUNT(Domain_OP_52_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};



//
// Domain OP 53 - replace old ACE (A;;RC;;;RU) with (A;;RPRC;;;RU) 
// on existing domain root object
// RAID 715218 (but should really be part of 214739)
//

// Domain OP 05 ACE list
ACE_LIST Domain_OP_53_AceList[] =
{
    {ADP_ACE_DEL,
     L"(A;;RC;;;RU)"
    },
    {ADP_ACE_ADD,
     L"(A;;RPRC;;;RU)"
    },
};
// Domain OP 53 Tasktable
TASK_TABLE  Domain_OP_53_TaskTable[] = 
{
    {&Domain_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_53_AceList,
     ARRAY_COUNT(Domain_OP_53_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};





//
// Domain OP 54 -  RAID 721799
// add ACE (OA;;RP;46a9b11d-60ae-405a-b7e8-ff8a58d456d2;;S-1-5-32-560)
// to AdminSDHolder object
// 
// 
OBJECT_NAME Domain_OP_54_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN=AdminSDHolder,CN=System",
    NULL,   // GUID
    NULL    // SID
};
ACE_LIST Domain_OP_54_AceList[] =
{
    {ADP_ACE_ADD,
     L"(OA;;RP;46a9b11d-60ae-405a-b7e8-ff8a58d456d2;;S-1-5-32-560)"
    },
};
TASK_TABLE  Domain_OP_54_TaskTable[] = 
{
    {&Domain_OP_54_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_54_AceList,
     ARRAY_COUNT(Domain_OP_54_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};


//
// Domain OP 55 -  RAID 727979
// add ACE (OA;;WPRP;6db69a1c-9422-11d1-aebd-0000f80367c1;;S-1-5-32-561)
// to AdminSDHolder object
// 
// 
OBJECT_NAME Domain_OP_55_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_DOMAIN_NC,
    L"CN=AdminSDHolder,CN=System",
    NULL,   // GUID
    NULL    // SID
};
ACE_LIST Domain_OP_55_AceList[] =
{
    {ADP_ACE_ADD,
     L"(OA;;WPRP;6db69a1c-9422-11d1-aebd-0000f80367c1;;S-1-5-32-561)"
    },
};
TASK_TABLE  Domain_OP_55_TaskTable[] = 
{
    {&Domain_OP_55_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set   
     0,     // number of attrs
     Domain_OP_55_AceList,
     ARRAY_COUNT(Domain_OP_55_AceList), // number of ace
     NULL,  // call back function
     0      // Special Task Code
    },
};





//
// domain operation GUID
//

const GUID  DOMAIN_OP_01_GUID = {0xab402345,0xd3c3,0x455d,0x9f,0xf7,0x40,0x26,0x8a,0x10,0x99,0xb6};
const GUID  DOMAIN_OP_02_GUID = {0xBAB5F54D,0x06C8,0x48de,0x9B,0x87,0xD7,0x8B,0x79,0x65,0x64,0xE4};
const GUID  DOMAIN_OP_03_GUID = {0xF3DD09DD,0x25E8,0x4f9c,0x85,0xDF,0x12,0xD6,0xD2,0xF2,0xF2,0xF5};
const GUID  DOMAIN_OP_04_GUID = {0x2416C60A,0xFE15,0x4d7a,0xA6,0x1E,0xDF,0xFD,0x5D,0xF8,0x64,0xD3};
const GUID  DOMAIN_OP_05_GUID = {0x7868D4C8,0xAC41,0x4e05,0xB4,0x01,0x77,0x62,0x80,0xE8,0xE9,0xF1};

const GUID  DOMAIN_OP_07_GUID = {0x860C36ED,0x5241,0x4c62,0xA1,0x8B,0xCF,0x6F,0xF9,0x99,0x41,0x73};
const GUID  DOMAIN_OP_08_GUID = {0x0E660EA3,0x8A5E,0x4495,0x9A,0xD7,0xCA,0x1B,0xD4,0x63,0x8F,0x9E};
const GUID  DOMAIN_OP_09_GUID = {0xA86FE12A,0x0F62,0x4e2a,0xB2,0x71,0xD2,0x7F,0x60,0x1F,0x81,0x82};
const GUID  DOMAIN_OP_10_GUID = {0xD85C0BFD,0x094F,0x4cad,0xA2,0xB5,0x82,0xAC,0x92,0x68,0x47,0x5D};
const GUID  DOMAIN_OP_11_GUID = {0x6ADA9FF7,0xC9DF,0x45c1,0x90,0x8E,0x9F,0xEF,0x2F,0xAB,0x00,0x8A};
const GUID  DOMAIN_OP_12_GUID = {0x10B3AD2A,0x6883,0x4fa7,0x90,0xFC,0x63,0x77,0xCB,0xDC,0x1B,0x26};
const GUID  DOMAIN_OP_13_GUID = {0x98DE1D3E,0x6611,0x443b,0x8B,0x4E,0xF4,0x33,0x7F,0x1D,0xED,0x0B};
const GUID  DOMAIN_OP_14_GUID = {0xF607FD87,0x80CF,0x45e2,0x89,0x0B,0x6C,0xF9,0x7E,0xC0,0xE2,0x84};
const GUID  DOMAIN_OP_15_GUID = {0x9CAC1F66,0x2167,0x47ad,0xA4,0x72,0x2A,0x13,0x25,0x13,0x10,0xE4};

const GUID  DOMAIN_OP_17_GUID = {0x6FF880D6,0x11E7,0x4ed1,0xA2,0x0F,0xAA,0xC4,0x5D,0xA4,0x86,0x50};
const GUID  DOMAIN_OP_18_GUID = {0x446f24ea,0xcfd5,0x4c52,0x83,0x46,0x96,0xe1,0x70,0xbc,0xb9,0x12};
const GUID  DOMAIN_OP_19_GUID = {0x293F0798,0xEA5C,0x4455,0x9F,0x5D,0x45,0xF3,0x3A,0x30,0x70,0x3B};

const GUID  DOMAIN_OP_22_GUID = {0x5c82b233,0x75fc,0x41b3,0xac,0x71,0xc6,0x95,0x92,0xe6,0xbf,0x15};

const GUID  DOMAIN_OP_24_GUID = {0x4dfbb973,0x8a62,0x4310,0xa9,0x0c,0x77,0x6e,0x00,0xf8,0x32,0x22};
const GUID  DOMAIN_OP_25_GUID = {0x8437C3D8,0x7689,0x4200,0xBF,0x38,0x79,0xE4,0xAC,0x33,0xDF,0xA0};
const GUID  DOMAIN_OP_26_GUID = {0x7cfb016c,0x4f87,0x4406,0x81,0x66,0xbd,0x9d,0xf9,0x43,0x94,0x7f};
const GUID  DOMAIN_OP_27_GUID = {0xf7ed4553,0xd82b,0x49ef,0xa8,0x39,0x2f,0x38,0xa3,0x6b,0xb0,0x69};
const GUID  DOMAIN_OP_28_GUID = {0x8ca38317,0x13a4,0x4bd4,0x80,0x6f,0xeb,0xed,0x6a,0xcb,0x5d,0x0c};
const GUID  DOMAIN_OP_29_GUID = {0x3c784009,0x1f57,0x4e2a,0x9b,0x04,0x69,0x15,0xc9,0xe7,0x19,0x61};
const GUID  DOMAIN_OP_30_GUID = {0x6bcd5678,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_31_GUID = {0x6bcd5679,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_32_GUID = {0x6bcd567a,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_33_GUID = {0x6bcd567b,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_34_GUID = {0x6bcd567c,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_35_GUID = {0x6bcd567d,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_36_GUID = {0x6bcd567e,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_37_GUID = {0x6bcd567f,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_38_GUID = {0x6bcd5680,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_39_GUID = {0x6bcd5681,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_40_GUID = {0x6bcd5682,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_41_GUID = {0x6bcd5683,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_42_GUID = {0x6bcd5684,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_43_GUID = {0x6bcd5685,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_44_GUID = {0x6bcd5686,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_45_GUID = {0x6bcd5687,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_46_GUID = {0x6bcd5688,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_47_GUID = {0x6bcd5689,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_48_GUID = {0x6bcd568a,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_49_GUID = {0x6bcd568b,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_50_GUID = {0x6bcd568c,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_51_GUID = {0x6bcd568d,0x8314,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_52_GUID = {0x3051c66f,0xb332,0x4a73,0x9a,0x20,0x2d,0x6a,0x7d,0x6e,0x6a,0x1c};
const GUID  DOMAIN_OP_53_GUID = {0x3e4f4182,0xac5d,0x4378,0xb7,0x60,0x0e,0xab,0x2d,0xe5,0x93,0xe2};
const GUID  DOMAIN_OP_54_GUID = {0xc4f17608,0xe611,0x11d6,0x97,0x93,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID  DOMAIN_OP_55_GUID = {0x13d15cf0,0xe6c8,0x11d6,0x97,0x93,0x00,0xc0,0x4f,0x61,0x32,0x21};


//
// Domain Operation Table, includes
//
//     1. operation code (primitive)
//     2. operation guid
//     3. task table
//

OPERATION_TABLE DomainOperationTable[] = 
{
    {CreateObject, 
     (GUID *) &DOMAIN_OP_01_GUID,
     Domain_OP_01_TaskTable,
     ARRAY_COUNT(Domain_OP_01_TaskTable),
     FALSE,
     0
    },
    {CreateObject, 
     (GUID *) &DOMAIN_OP_02_GUID,
     Domain_OP_02_TaskTable,
     ARRAY_COUNT(Domain_OP_02_TaskTable),
     FALSE,
     0
    },
    {CreateObject, 
     (GUID *) &DOMAIN_OP_03_GUID,
     Domain_OP_03_TaskTable,
     ARRAY_COUNT(Domain_OP_03_TaskTable),
     FALSE,
     0
    },
    {SpecialTask,
     (GUID *) &DOMAIN_OP_04_GUID,
     Domain_OP_04_TaskTable,
     ARRAY_COUNT(Domain_OP_04_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_05_GUID,
     Domain_OP_05_TaskTable,
     ARRAY_COUNT(Domain_OP_05_TaskTable),
     FALSE,
     0
    },
    // Domain OP 06 was removed
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_07_GUID,
     Domain_OP_07_TaskTable,
     ARRAY_COUNT(Domain_OP_07_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_08_GUID,
     Domain_OP_08_TaskTable,
     ARRAY_COUNT(Domain_OP_08_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_09_GUID,
     Domain_OP_09_TaskTable,
     ARRAY_COUNT(Domain_OP_09_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_10_GUID,
     Domain_OP_10_TaskTable,
     ARRAY_COUNT(Domain_OP_10_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_11_GUID,
     Domain_OP_11_TaskTable,
     ARRAY_COUNT(Domain_OP_11_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_12_GUID,
     Domain_OP_12_TaskTable,
     ARRAY_COUNT(Domain_OP_12_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_13_GUID,
     Domain_OP_13_TaskTable,
     ARRAY_COUNT(Domain_OP_13_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_14_GUID,
     Domain_OP_14_TaskTable,
     ARRAY_COUNT(Domain_OP_14_TaskTable),
     FALSE,
     0
    },
    {ModifyAttrs,
     (GUID *) &DOMAIN_OP_15_GUID,
     Domain_OP_15_TaskTable,
     ARRAY_COUNT(Domain_OP_15_TaskTable),
     FALSE,
     0
    },
    // Domain Operation 16 is removed on April 17, 2002 (RAID 498986) 
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_17_GUID,
     Domain_OP_17_TaskTable,
     ARRAY_COUNT(Domain_OP_17_TaskTable),
     FALSE,
     0
    },
    {CallBackFunc,
     (GUID *) &DOMAIN_OP_18_GUID,
     Domain_OP_18_TaskTable,
     ARRAY_COUNT(Domain_OP_18_TaskTable),
     FALSE,
     0
    },
    {SelectivelyAddRemoveAces,
     (GUID *) &DOMAIN_OP_19_GUID,
     Domain_OP_19_TaskTable,
     ARRAY_COUNT(Domain_OP_19_TaskTable),
     FALSE,
     0
    },
    // Domain OP 20 was removed
    // Domain OP 21 was removed
    {CreateObject, 
     (GUID *) &DOMAIN_OP_22_GUID,
     Domain_OP_22_TaskTable,
     ARRAY_COUNT(Domain_OP_22_TaskTable),
     FALSE,
     0
    },
    // Domain OP 23 was removed
    {CreateObject, 
     (GUID *) &DOMAIN_OP_24_GUID,
     Domain_OP_24_TaskTable,
     ARRAY_COUNT(Domain_OP_24_TaskTable),
     FALSE,
     0
    },
    {CreateObject, 
     (GUID *) &DOMAIN_OP_25_GUID,
     Domain_OP_25_TaskTable,
     ARRAY_COUNT(Domain_OP_25_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_26_GUID,
     Domain_OP_26_TaskTable,
     ARRAY_COUNT(Domain_OP_26_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_27_GUID,
     Domain_OP_27_TaskTable,
     ARRAY_COUNT(Domain_OP_27_TaskTable),
     FALSE,
     0
    },
    {CreateObject, 
     (GUID *) &DOMAIN_OP_28_GUID,
     Domain_OP_28_TaskTable,
     ARRAY_COUNT(Domain_OP_28_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_29_GUID,
     Domain_OP_29_TaskTable,
     ARRAY_COUNT(Domain_OP_29_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_30_GUID,
     Domain_OP_30_TaskTable,
     ARRAY_COUNT(Domain_OP_30_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_31_GUID,
     Domain_OP_31_TaskTable,
     ARRAY_COUNT(Domain_OP_31_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_32_GUID,
     Domain_OP_32_TaskTable,
     ARRAY_COUNT(Domain_OP_32_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_33_GUID,
     Domain_OP_33_TaskTable,
     ARRAY_COUNT(Domain_OP_33_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_34_GUID,
     Domain_OP_34_TaskTable,
     ARRAY_COUNT(Domain_OP_34_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_35_GUID,
     Domain_OP_35_TaskTable,
     ARRAY_COUNT(Domain_OP_35_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_36_GUID,
     Domain_OP_36_TaskTable,
     ARRAY_COUNT(Domain_OP_36_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_37_GUID,
     Domain_OP_37_TaskTable,
     ARRAY_COUNT(Domain_OP_37_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_38_GUID,
     Domain_OP_38_TaskTable,
     ARRAY_COUNT(Domain_OP_38_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_39_GUID,
     Domain_OP_39_TaskTable,
     ARRAY_COUNT(Domain_OP_39_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_40_GUID,
     Domain_OP_40_TaskTable,
     ARRAY_COUNT(Domain_OP_40_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_41_GUID,
     Domain_OP_41_TaskTable,
     ARRAY_COUNT(Domain_OP_41_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_42_GUID,
     Domain_OP_42_TaskTable,
     ARRAY_COUNT(Domain_OP_42_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_43_GUID,
     Domain_OP_43_TaskTable,
     ARRAY_COUNT(Domain_OP_43_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_44_GUID,
     Domain_OP_44_TaskTable,
     ARRAY_COUNT(Domain_OP_44_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_45_GUID,
     Domain_OP_45_TaskTable,
     ARRAY_COUNT(Domain_OP_45_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_46_GUID,
     Domain_OP_46_TaskTable,
     ARRAY_COUNT(Domain_OP_46_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_47_GUID,
     Domain_OP_47_TaskTable,
     ARRAY_COUNT(Domain_OP_47_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_48_GUID,
     Domain_OP_48_TaskTable,
     ARRAY_COUNT(Domain_OP_48_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_49_GUID,
     Domain_OP_49_TaskTable,
     ARRAY_COUNT(Domain_OP_49_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_50_GUID,
     Domain_OP_50_TaskTable,
     ARRAY_COUNT(Domain_OP_50_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_51_GUID,
     Domain_OP_51_TaskTable,
     ARRAY_COUNT(Domain_OP_51_TaskTable),
     TRUE,
     ERROR_FILE_NOT_FOUND
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_52_GUID,
     Domain_OP_52_TaskTable,
     ARRAY_COUNT(Domain_OP_52_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_53_GUID,
     Domain_OP_53_TaskTable,
     ARRAY_COUNT(Domain_OP_53_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_54_GUID,
     Domain_OP_54_TaskTable,
     ARRAY_COUNT(Domain_OP_54_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &DOMAIN_OP_55_GUID,
     Domain_OP_55_TaskTable,
     ARRAY_COUNT(Domain_OP_55_TaskTable),
     FALSE,
     0
    },
};


POPERATION_TABLE gDomainOperationTable = DomainOperationTable; 
ULONG   gDomainOperationTableCount = sizeof(DomainOperationTable) / sizeof(OPERATION_TABLE);




//
// Forest Operations
// 

//
// Forest Operation 01 (this was for schema upgrade, but removed later on
//


//
// Forest Operation 02
//
OBJECT_NAME Forest_OP_02_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_CONFIGURATION_NC,
    L"CN=Sites",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_02_AceList[] =
{
    {ADP_ACE_ADD,
     L"(OA;CI;LCRPLORC;;bf967ab3-0de6-11d0-a285-00aa003049e2;ED)"
    },
};
TASK_TABLE  Forest_OP_02_TaskTable[] = 
{
    {&Forest_OP_02_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_02_AceList,
     ARRAY_COUNT(Forest_OP_02_AceList), // number of aces
     NULL,  // call back function
     0      // Special Task Code
    },
};




//
// Forest Operation 03
//
OBJECT_NAME Forest_OP_03_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Sam-Domain",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_03_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;RP;c7407360-20bf-11d0-a768-00aa006e0529;;RU)"
    },
    {ADP_ACE_ADD,
     L"(A;;RPRC;;;RU)"
    },
    {ADP_ACE_ADD,
     L"(A;;LCRPLORC;;;ED)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;037088f8-0ae1-11d2-b422-00a0c968f939;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;4c164200-20c0-11d0-a768-00aa006e0529;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;5f202010-79a5-11d0-9020-00c04fc2d4cf;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RPLCLORC;;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RP;b8119fd0-04f6-4762-ab7a-4986c76b3f9a;;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RP;b8119fd0-04f6-4762-ab7a-4986c76b3f9a;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967aba-0de6-11d0-a285-00aa003049e2;ED)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967a9c-0de6-11d0-a285-00aa003049e2;ED)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967a86-0de6-11d0-a285-00aa003049e2;ED)"
    },
    {ADP_ACE_DEL,
     L"(A;;RC;;;RU)"
    },
};
TASK_TABLE  Forest_OP_03_TaskTable[] =
{
    {&Forest_OP_03_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_03_AceList,
     ARRAY_COUNT(Forest_OP_03_AceList),
     NULL,  // call back function
     0      // Special Task Code
    },
};



//
// Forest Operation 04
//
OBJECT_NAME Forest_OP_04_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Domain-DNS",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_04_AceList[] =
{
    {ADP_ACE_ADD,
     L"(OA;;RP;c7407360-20bf-11d0-a768-00aa006e0529;;RU)"
    },
    {ADP_ACE_ADD,
     L"(A;;RPRC;;;RU)"
    },
    {ADP_ACE_ADD,
     L"(A;;LCRPLORC;;;ED)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;037088f8-0ae1-11d2-b422-00a0c968f939;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;4c164200-20c0-11d0-a768-00aa006e0529;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;5f202010-79a5-11d0-9020-00c04fc2d4cf;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RPLCLORC;;4828CC14-1437-45bc-9B07-AD6F015E5F28;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RP;b8119fd0-04f6-4762-ab7a-4986c76b3f9a;;RU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RP;b8119fd0-04f6-4762-ab7a-4986c76b3f9a;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967aba-0de6-11d0-a285-00aa003049e2;ED)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967a9c-0de6-11d0-a285-00aa003049e2;ED)"
    },
    {ADP_ACE_ADD,
     L"(OA;CIIO;RP;b7c69e6d-2cc7-11d2-854e-00a0c983f608;bf967a86-0de6-11d0-a285-00aa003049e2;ED)"
    },
    {ADP_ACE_DEL,
     L"(A;;RC;;;RU)"
    },
};
TASK_TABLE  Forest_OP_04_TaskTable[] =
{
    {&Forest_OP_04_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_04_AceList,
     ARRAY_COUNT(Forest_OP_04_AceList),
     NULL,  // call back function
     0      // Special Task Code
    },
};




//
// Forest Operation 05
//
OBJECT_NAME Forest_OP_05_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=organizational-Unit",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_05_AceList[] =
{
    {ADP_ACE_ADD,
     L"(A;;LCRPLORC;;;ED)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CCDC;4828CC14-1437-45bc-9B07-AD6F015E5F28;;AO)"   
    },
};
TASK_TABLE Forest_OP_05_TaskTable[] =
{
    {&Forest_OP_05_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_05_AceList,
     ARRAY_COUNT(Forest_OP_05_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};



//
// Forest Operation 06
//
OBJECT_NAME Forest_OP_06_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Group-Policy-Container",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_06_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(A;CI;LCRPLORC;;;ED)"
    },
};
TASK_TABLE Forest_OP_06_TaskTable[] = 
{
    {&Forest_OP_06_ObjName,
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_06_AceList,
     ARRAY_COUNT(Forest_OP_06_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};




//
// Forest Operation 07
//
OBJECT_NAME Forest_OP_07_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Trusted-Domain",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_07_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;WP;736e4812-af31-11d2-b7df-00805f48caeb;bf967ab8-0de6-11d0-a285-00aa003049e2;CO)",
    },
    {ADP_ACE_ADD,
     L"(A;;SD;;;CO)"
    },
};
TASK_TABLE Forest_OP_07_TaskTable[] = 
{
    {&Forest_OP_07_ObjName,
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_07_AceList,
     ARRAY_COUNT(Forest_OP_07_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};



//
// Forest Operation 08
//
TASK_TABLE Forest_OP_08_TaskTable[] =
{
    {NULL,  // Object Name
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     NULL,  // AceList
     0,
     UpgradeDisplaySpecifiers,  // call back function
     0      // Special Task Code
    }
};


//
// Forest Operation 11 (Add ACEs to CN=AIA,CN=Public Key Services,CN=Services,CN=Configuration object) 
// 
OBJECT_NAME Forest_OP_11_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_CONFIGURATION_NC,
    L"CN=AIA,CN=Public Key Services,CN=Services",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_11_AceList[] =
{
    {ADP_ACE_ADD,
     L"(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;CA)"
    },
    {ADP_ACE_ADD,
     L"(A;;RPLCLORC;;;RU)"
    },
};
TASK_TABLE  Forest_OP_11_TaskTable[] = 
{
    {&Forest_OP_11_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_11_AceList,
     ARRAY_COUNT(Forest_OP_11_AceList), // number of aces
     NULL,  // call back function
     0      // Special Task Code
    },
};

//
// Forest Operation 12 (Add ACEs to CN=CDP,CN=Public Key Services,CN=Services,CN=Configuration,DC=X object)
// 
OBJECT_NAME Forest_OP_12_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_CONFIGURATION_NC,
    L"CN=CDP,CN=Public Key Services,CN=Services",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_12_AceList[] =
{
    {ADP_ACE_ADD,
     L"(A;;RPLCLORC;;;RU)"
    },
};
TASK_TABLE  Forest_OP_12_TaskTable[] = 
{
    {&Forest_OP_12_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_12_AceList,
     ARRAY_COUNT(Forest_OP_12_AceList), // number of aces
     NULL,  // call back function
     0      // Special Task Code
    },
};



//
// Forest Operation 13 (Add ACEs to CN=Configuration,DC=X container)
// 
OBJECT_NAME Forest_OP_13_ObjName =
{
    ADP_OBJNAME_NONE | ADP_OBJNAME_CONFIGURATION_NC,
    NULL,   // CN
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_13_AceList[] =
{
    {ADP_ACE_ADD,
     L"(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;ED)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;BA)"
    }
};
TASK_TABLE  Forest_OP_13_TaskTable[] = 
{
    {&Forest_OP_13_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_13_AceList,
     ARRAY_COUNT(Forest_OP_13_AceList), // number of aces
     NULL,  // call back function
     0      // Special Task Code
    },
};


//
// Forest Operation 14 (Add ACEs to CN=Schema,CN=Configuration,DC=X container)
// 
OBJECT_NAME Forest_OP_14_ObjName =
{
    ADP_OBJNAME_NONE | ADP_OBJNAME_SCHEMA_NC,
    NULL,   // CN
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_14_AceList[] =
{
    {ADP_ACE_ADD,
     L"(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;ED)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;BA)"
    }
};
TASK_TABLE  Forest_OP_14_TaskTable[] = 
{
    {&Forest_OP_14_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_14_AceList,
     ARRAY_COUNT(Forest_OP_14_AceList), // number of aces
     NULL,  // call back function
     0      // Special Task Code
    },
};



//
// Forest Operation 15 (Merge defaultSD on samDomain)
// Raid # 468773 linked with Forest OP 16 and Domain OP 20, 21
// 
// this operation ForestOP15 was removed on Jan. 25, 2002, see RAID 522886
//

//
// Forest Operation 16 (Merge defaultSD on Domain-DNS)
// Raid # 468773 linked with Forest OP 15 and Domain OP 20, 21
//
// this operation ForstOP16 was removed on Jan. 25, 2002, see RAID 522886
//



//
// Forest Operation 17
// Merger DefaultSD (Add and Remove ACEs) on CN=Sam-Server Schema object
// RAID bug # 421784
//

OBJECT_NAME Forest_OP_17_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Sam-Server",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_17_AceList[] =
{
    {ADP_ACE_ADD,
     L"(OA;;CR;91d67418-0135-4acc-8d79-c08e857cfbec;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;91d67418-0135-4acc-8d79-c08e857cfbec;;RU)"
    },
};
TASK_TABLE Forest_OP_17_TaskTable[] =
{
    {&Forest_OP_17_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_17_AceList,
     ARRAY_COUNT(Forest_OP_17_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};





//
// Forest Operation 18 (Merge defaultSD on samDomain)
// No Bug #, pick up difference from old sch*.ldf
//
ACE_LIST Forest_OP_18_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;DD)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;BA)"
    },
};
TASK_TABLE Forest_OP_18_TaskTable[] = 
{
    {&Forest_OP_03_ObjName,         // NOTE: we are re-using the OP_03 object name
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_18_AceList,
     ARRAY_COUNT(Forest_OP_18_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};



//
// Forest Operation 19 (Merge defaultSD on Domain-DNS)
// No Bug #, pick up difference from old sch*.ldf
//
ACE_LIST Forest_OP_19_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;DD)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;1131f6ad-9c07-11d1-f79f-00c04fc2dcd2;;BA)"
    },
};
TASK_TABLE Forest_OP_19_TaskTable[] = 
{
    {&Forest_OP_04_ObjName,         // NOTE: we are re-using the OP_04 object name
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_19_AceList,
     ARRAY_COUNT(Forest_OP_19_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};




//
// Forest Operation 20 
// Merger DefaultSD (Add and Remove ACEs) on CN=Site
// No Bug #, pick up difference from old sch*.ldf
//
OBJECT_NAME Forest_OP_20_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Site",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_20_AceList[] =
{
    {ADP_ACE_DEL,
     L"(A;;LCRPLORC;;;ED)"
    },
};
TASK_TABLE Forest_OP_20_TaskTable[] =
{
    {&Forest_OP_20_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_20_AceList,
     ARRAY_COUNT(Forest_OP_20_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};



//
// Forest Operation 21
//
TASK_TABLE Forest_OP_21_TaskTable[] =
{
    {NULL,  // Object Name
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     NULL,  // AceList
     0,
     UpgradeDisplaySpecifiers,  // call back function
     0      // Special Task Code
    }
};





//
// Forest Operation 22 
// Merger DefaultSD (Add and Remove ACEs) on CN=Computer Schema object
// RAID bug # 522886
//

OBJECT_NAME Forest_OP_22_ObjName = 
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Computer",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_22_AceList[] =
{
    {ADP_ACE_ADD,
     L"(OA;;WP;3e0abfd0-126a-11d0-a060-00aa006c33ed;bf967a86-0de6-11d0-a285-00aa003049e2;CO)"
    },
    {ADP_ACE_ADD,
     L"(OA;;WP;5f202010-79a5-11d0-9020-00c04fc2d4cf;bf967a86-0de6-11d0-a285-00aa003049e2;CO)"
    },
    {ADP_ACE_ADD,
     L"(OA;;WP;bf967950-0de6-11d0-a285-00aa003049e2;bf967a86-0de6-11d0-a285-00aa003049e2;CO)"
    },
    {ADP_ACE_ADD,
     L"(OA;;WP;bf967953-0de6-11d0-a285-00aa003049e2;bf967a86-0de6-11d0-a285-00aa003049e2;CO)"
    },
};
TASK_TABLE Forest_OP_22_TaskTable[] =
{
    {&Forest_OP_22_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_22_AceList,
     ARRAY_COUNT(Forest_OP_22_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};





//
// Forest Operation 23 (Merge defaultSD on samDomain)
// RAID 498986. 
// replace 
// (OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;BU)
// with 
// (OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;S-1-5-32-557)
//
ACE_LIST Forest_OP_23_AceList[] = 
{
    {ADP_ACE_DEL,
     L"(OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;BU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;S-1-5-32-557)"
    },
};
TASK_TABLE Forest_OP_23_TaskTable[] = 
{
    {&Forest_OP_03_ObjName,         // NOTE: we are re-using the OP_03 object name
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_23_AceList,
     ARRAY_COUNT(Forest_OP_23_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};



//
// Forest Operation 24 (Merge defaultSD on Domain-DNS)
// RAID 498986. 
// replace 
// (OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;BU)
// with 
// (OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;S-1-5-32-557)
//
ACE_LIST Forest_OP_24_AceList[] = 
{
    {ADP_ACE_DEL,
     L"(OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;BU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;e2a36dc9-ae17-47c3-b58b-be34c55ba633;;S-1-5-32-557)"
    },
};
TASK_TABLE Forest_OP_24_TaskTable[] = 
{
    {&Forest_OP_04_ObjName,         // NOTE: we are re-using the OP_04 object name
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_24_AceList,
     ARRAY_COUNT(Forest_OP_24_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};





//
// Forest Operation 25 (Merge defaultSD on samDomain)
// RAID 606437
// Granted following 3 ControlAccessRights to Authenticated Users
//
ACE_LIST Forest_OP_25_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;CR;280f369c-67c7-438e-ae98-1d46f3c6f541;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;ccc2dc7d-a6ad-4a7a-8846-c04e3cc53501;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;05c74c5e-4deb-43b4-bd9f-86664c2a7fd5;;AU)"
    },
};
TASK_TABLE Forest_OP_25_TaskTable[] = 
{
    {&Forest_OP_03_ObjName,         // NOTE: we are re-using the OP_03 object name
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_25_AceList,
     ARRAY_COUNT(Forest_OP_25_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};



//
// Forest Operation 26 (Merge defaultSD on Domain-DNS)
// RAID 606437
// Granted following 3 ControlAccessRights to Authenticated Users
//
ACE_LIST Forest_OP_26_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;CR;280f369c-67c7-438e-ae98-1d46f3c6f541;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;ccc2dc7d-a6ad-4a7a-8846-c04e3cc53501;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;CR;05c74c5e-4deb-43b4-bd9f-86664c2a7fd5;;AU)"
    },
};
TASK_TABLE Forest_OP_26_TaskTable[] = 
{
    {&Forest_OP_04_ObjName,         // NOTE: we are re-using the OP_04 object name
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_26_AceList,
     ARRAY_COUNT(Forest_OP_26_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};


//
// Forest Operation 27 (Modify nTSD on CN=Partitions,CN=Configuration,DC=X obj) 
// removed. All change has been migrated to Forest OP 29 
// 




//
// Forest Operation 28 (Merge defaultSD on Dns-Zone object)
// RAID 619169
//
OBJECT_NAME Forest_OP_28_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Dns-Zone",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_28_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;CO)"
    },
};
TASK_TABLE Forest_OP_28_TaskTable[] = 
{
    {&Forest_OP_28_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_28_AceList,
     ARRAY_COUNT(Forest_OP_28_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};



//
// Forest Operation 29 (Modify nTSD on CN=Partitions,CN=Configuration,DC=X obj)
// RAID 552352 && 623850
// 
OBJECT_NAME Forest_OP_29_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_CONFIGURATION_NC,
    L"CN=Partitions",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_29_AceList[] =
{
    {ADP_ACE_DEL,
     L"(A;;RPLCLORC;;;AU)"
    },
    {ADP_ACE_ADD,
     L"(A;;LCLORC;;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RP;d31a8757-2447-4545-8081-3bb610cacbf2;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RP;66171887-8f3c-11d0-afda-00c04fd930c9;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RP;032160bf-9824-11d1-aec0-0000f80367c1;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RP;789EE1EB-8C8E-4e4c-8CEC-79B31B7617B5;;AU)"
    },
    {ADP_ACE_ADD,
     L"(OA;;RP;e48d0154-bcf8-11d1-8702-00c04fb96050;;AU)"
    }
};
TASK_TABLE  Forest_OP_29_TaskTable[] = 
{
    {&Forest_OP_29_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_29_AceList,
     ARRAY_COUNT(Forest_OP_29_AceList), // number of aces
     NULL,  // call back function
     0      // Special Task Code
    },
};



//
// Forest Operation 30 (Modify nTSD on CN=Partitions,CN=Configuration,DC=X obj)
// RAID 639909 (639897)
// 
OBJECT_NAME Forest_OP_30_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_CONFIGURATION_NC,
    L"CN=Partitions",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_30_AceList[] =
{
    {ADP_ACE_ADD,
     L"(A;;CC;;;ED)"
    }
};
TASK_TABLE  Forest_OP_30_TaskTable[] = 
{
    {&Forest_OP_30_ObjName,
     NULL,  // member name
     NULL,  // object SD
     NULL,  // attrs to set
     0,
     Forest_OP_30_AceList,
     ARRAY_COUNT(Forest_OP_30_AceList), // number of aces
     NULL,  // call back function
     0      // Special Task Code
    },
};



//
// Forest Operation 31 - 36 (Merge defaultSD on Ipsec-xxx object)
// RAID 645935
//
OBJECT_NAME Forest_OP_31_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Ipsec-Base",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_31_AceList[] = 
{
    {ADP_ACE_DEL,
     L"(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)"
    },
    {ADP_ACE_DEL,
     L"(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)"
    },
    {ADP_ACE_DEL,
     L"(A;;RPLCLORC;;;AU)"
    },
};
TASK_TABLE Forest_OP_31_TaskTable[] = 
{
    {&Forest_OP_31_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_31_AceList,
     ARRAY_COUNT(Forest_OP_31_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};

OBJECT_NAME Forest_OP_32_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Ipsec-Filter",
    NULL,   // GUID
    NULL,   // SID
};
TASK_TABLE Forest_OP_32_TaskTable[] = 
{
    {&Forest_OP_32_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_31_AceList,
     ARRAY_COUNT(Forest_OP_31_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};

OBJECT_NAME Forest_OP_33_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Ipsec-ISAKMP-Policy",
    NULL,   // GUID
    NULL,   // SID
};
TASK_TABLE Forest_OP_33_TaskTable[] = 
{
    {&Forest_OP_33_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_31_AceList,
     ARRAY_COUNT(Forest_OP_31_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};

OBJECT_NAME Forest_OP_34_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Ipsec-Negotiation-Policy",
    NULL,   // GUID
    NULL,   // SID
};
TASK_TABLE Forest_OP_34_TaskTable[] = 
{
    {&Forest_OP_34_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_31_AceList,
     ARRAY_COUNT(Forest_OP_31_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};

OBJECT_NAME Forest_OP_35_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Ipsec-NFA",
    NULL,   // GUID
    NULL,   // SID
};
TASK_TABLE Forest_OP_35_TaskTable[] = 
{
    {&Forest_OP_35_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_31_AceList,
     ARRAY_COUNT(Forest_OP_31_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};

OBJECT_NAME Forest_OP_36_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Ipsec-Policy",
    NULL,   // GUID
    NULL,   // SID
};
TASK_TABLE Forest_OP_36_TaskTable[] = 
{
    {&Forest_OP_36_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_31_AceList,
     ARRAY_COUNT(Forest_OP_31_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};


//
// Forest Operation 37 - 40 
// Merge defaultSD on user / inetorgperson / computer / group schema objects 
// RAID 721799
//
OBJECT_NAME Forest_OP_37_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=User",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_37_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;RP;46a9b11d-60ae-405a-b7e8-ff8a58d456d2;;S-1-5-32-560)"
    },
};
TASK_TABLE Forest_OP_37_TaskTable[] = 
{
    {&Forest_OP_37_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_37_AceList,
     ARRAY_COUNT(Forest_OP_37_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};


OBJECT_NAME Forest_OP_38_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=inetOrgPerson",
    NULL,   // GUID
    NULL,   // SID
};
TASK_TABLE Forest_OP_38_TaskTable[] = 
{
    {&Forest_OP_38_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_37_AceList,
     ARRAY_COUNT(Forest_OP_37_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};


OBJECT_NAME Forest_OP_39_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Computer",
    NULL,   // GUID
    NULL,   // SID
};
TASK_TABLE Forest_OP_39_TaskTable[] = 
{
    {&Forest_OP_39_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_37_AceList,
     ARRAY_COUNT(Forest_OP_37_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};

OBJECT_NAME Forest_OP_40_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=Group",
    NULL,   // GUID
    NULL,   // SID
};
TASK_TABLE Forest_OP_40_TaskTable[] = 
{
    {&Forest_OP_40_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_37_AceList,
     ARRAY_COUNT(Forest_OP_37_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};


//
// Forest Operation 41 - 42
// Merge defaultSD on user / inetorgperson objects 
// RAID 721799
//
OBJECT_NAME Forest_OP_41_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=User",
    NULL,   // GUID
    NULL,   // SID
};
ACE_LIST Forest_OP_41_AceList[] = 
{
    {ADP_ACE_ADD,
     L"(OA;;WPRP;6db69a1c-9422-11d1-aebd-0000f80367c1;;S-1-5-32-561)"
    },
};
TASK_TABLE Forest_OP_41_TaskTable[] = 
{
    {&Forest_OP_41_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_41_AceList,
     ARRAY_COUNT(Forest_OP_41_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};


OBJECT_NAME Forest_OP_42_ObjName =
{
    ADP_OBJNAME_CN | ADP_OBJNAME_SCHEMA_NC,
    L"CN=inetOrgPerson",
    NULL,   // GUID
    NULL,   // SID
};
TASK_TABLE Forest_OP_42_TaskTable[] = 
{
    {&Forest_OP_42_ObjName,         
     NULL,  // member name
     NULL,  // SD
     NULL,  // attrs to set
     0,
     Forest_OP_41_AceList,
     ARRAY_COUNT(Forest_OP_41_AceList),
     NULL,  // call back function
     0      // Special Task Code
    }
};






//
// Forest Operation GUID
//

const GUID FOREST_OP_02_GUID = {0x3467DAE5,0xDEDD,0x4648,0x90,0x66,0xF4,0x8A,0xC1,0x86,0xB2,0x0A};
const GUID FOREST_OP_03_GUID = {0x33B7EE33,0x1386,0x47cf,0xBA,0xA1,0xB0,0x3E,0x06,0x47,0x32,0x53};
const GUID FOREST_OP_04_GUID = {0xE9EE8D55,0xC2FB,0x4723,0xA3,0x33,0xC8,0x0F,0xF4,0xDF,0xBF,0x45};
const GUID FOREST_OP_05_GUID = {0xCCFAE63A,0x7FB5,0x454c,0x83,0xAB,0x0E,0x8E,0x12,0x14,0x97,0x4E};
const GUID FOREST_OP_06_GUID = {0xAD3C7909,0xB154,0x4c16,0x8B,0xF7,0x2C,0x3A,0x78,0x70,0xBB,0x3D};
const GUID FOREST_OP_07_GUID = {0x26AD2EBF,0xF8F5,0x44a4,0xB9,0x7C,0xA6,0x16,0xC8,0xB9,0xD0,0x9A};
const GUID FOREST_OP_08_GUID = {0x4444C516,0xF43A,0x4c12,0x9C,0x4B,0xB5,0xC0,0x64,0x94,0x1D,0x61};

const GUID FOREST_OP_11_GUID = {0x436A1A4B,0xF41A,0x46e6,0xAC,0x86,0x42,0x77,0x20,0xEF,0x29,0xF3};
const GUID FOREST_OP_12_GUID = {0xB2B7FB45,0xF50D,0x41bc,0xA7,0x3B,0x8F,0x58,0x0F,0x3B,0x63,0x6A};
const GUID FOREST_OP_13_GUID = {0x1BDF6366,0xC3DB,0x4d0b,0xB8,0xCB,0xF9,0x9B,0xA9,0xBC,0xE2,0x0F};
const GUID FOREST_OP_14_GUID = {0x63C0F51A,0x067C,0x4640,0x8A,0x4F,0x04,0x4F,0xB3,0x3F,0x10,0x49};

const GUID FOREST_OP_17_GUID = {0xDAE441C0,0x366E,0x482E,0x98,0xD9,0x60,0xA9,0x9A,0x18,0x98,0xCC};
const GUID FOREST_OP_18_GUID = {0x7DD09CA6,0xF0D6,0x43BF,0xB7,0xF8,0xEF,0x34,0x8F,0x43,0x56,0x17};
const GUID FOREST_OP_19_GUID = {0x6B800A81,0xAFFE,0x4A15,0x8E,0x41,0x6E,0xA0,0xC7,0xAA,0x89,0xE4};
const GUID FOREST_OP_20_GUID = {0xDD07182C,0x3174,0x4C95,0x90,0x2A,0xD6,0x4F,0xEE,0x28,0x5B,0xBF};
const GUID FOREST_OP_21_GUID = {0xffa5ee3c,0x1405,0x476d,0xb3,0x44,0x7a,0xd3,0x7d,0x69,0xcc,0x25}; 
const GUID FOREST_OP_22_GUID = {0x099F1587,0xAF70,0x49C6,0xAB,0x6C,0x7B,0x3E,0x82,0xBE,0x0F,0xE2};
const GUID FOREST_OP_23_GUID = {0x1a3f6b15,0x55f2,0x4752,0xba,0x27,0x3d,0x38,0xa8,0x23,0x2c,0x4d};
const GUID FOREST_OP_24_GUID = {0xdee21a17,0x4e8e,0x4f40,0xa5,0x8c,0xc0,0xc0,0x09,0xb6,0x85,0xa7};
const GUID FOREST_OP_25_GUID = {0x9bd98bb4,0x4047,0x4de5,0xbf,0x4c,0x7b,0xd1,0xd0,0xf6,0xd2,0x1d};
const GUID FOREST_OP_26_GUID = {0x3fe80fbf,0xbf39,0x4773,0xb5,0xbd,0x3e,0x57,0x67,0xa3,0x0d,0x2d};

const GUID FOREST_OP_28_GUID = {0xf02915e2,0x9141,0x4f73,0xb8,0xe7,0x28,0x04,0x66,0x27,0x82,0xda};
const GUID FOREST_OP_29_GUID = {0x39902c52,0xef24,0x4b4b,0x80,0x33,0x2c,0x9d,0xfd,0xd1,0x73,0xa2};
const GUID FOREST_OP_30_GUID = {0x20bf09b4,0x6d0b,0x4cd1,0x9c,0x09,0x42,0x31,0xed,0xf1,0x20,0x9b};
const GUID FOREST_OP_31_GUID = {0x94f238bb,0x831c,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID FOREST_OP_32_GUID = {0x94f238bc,0x831c,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID FOREST_OP_33_GUID = {0x94f238bd,0x831c,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID FOREST_OP_34_GUID = {0x94f238be,0x831c,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID FOREST_OP_35_GUID = {0x94f238bf,0x831c,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID FOREST_OP_36_GUID = {0x94f238c0,0x831c,0x11d6,0x97,0x7b,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID FOREST_OP_37_GUID = {0xeda27b47,0xe610,0x11d6,0x97,0x93,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID FOREST_OP_38_GUID = {0xeda27b48,0xe610,0x11d6,0x97,0x93,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID FOREST_OP_39_GUID = {0xeda27b49,0xe610,0x11d6,0x97,0x93,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID FOREST_OP_40_GUID = {0xeda27b4a,0xe610,0x11d6,0x97,0x93,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID FOREST_OP_41_GUID = {0x26d9c510,0xe61a,0x11d6,0x97,0x93,0x00,0xc0,0x4f,0x61,0x32,0x21};
const GUID FOREST_OP_42_GUID = {0x26d9c511,0xe61a,0x11d6,0x97,0x93,0x00,0xc0,0x4f,0x61,0x32,0x21};


//
// Forest Operation Table
//

OPERATION_TABLE ForestOperationTable[] = 
{
    {AddRemoveAces,
     (GUID *) &FOREST_OP_02_GUID,
     Forest_OP_02_TaskTable,
     ARRAY_COUNT(Forest_OP_02_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_03_GUID,
     Forest_OP_03_TaskTable,
     ARRAY_COUNT(Forest_OP_03_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_04_GUID,
     Forest_OP_04_TaskTable,
     ARRAY_COUNT(Forest_OP_04_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_05_GUID,
     Forest_OP_05_TaskTable,
     ARRAY_COUNT(Forest_OP_05_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_06_GUID,
     Forest_OP_06_TaskTable,
     ARRAY_COUNT(Forest_OP_06_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_07_GUID,
     Forest_OP_07_TaskTable,
     ARRAY_COUNT(Forest_OP_07_TaskTable),
     FALSE,
     0
    },
    {CallBackFunc,
     (GUID *) &FOREST_OP_08_GUID,
     Forest_OP_08_TaskTable,
     ARRAY_COUNT(Forest_OP_08_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &FOREST_OP_11_GUID,
     Forest_OP_11_TaskTable,
     ARRAY_COUNT(Forest_OP_11_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &FOREST_OP_12_GUID,
     Forest_OP_12_TaskTable,
     ARRAY_COUNT(Forest_OP_12_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &FOREST_OP_13_GUID,
     Forest_OP_13_TaskTable,
     ARRAY_COUNT(Forest_OP_13_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &FOREST_OP_14_GUID,
     Forest_OP_14_TaskTable,
     ARRAY_COUNT(Forest_OP_14_TaskTable),
     FALSE,
     0
    },
    // Forest OP 15 was removed
    // Forest OP 16 was removed
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_17_GUID,
     Forest_OP_17_TaskTable,
     ARRAY_COUNT(Forest_OP_17_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_18_GUID,
     Forest_OP_18_TaskTable,
     ARRAY_COUNT(Forest_OP_18_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_19_GUID,
     Forest_OP_19_TaskTable,
     ARRAY_COUNT(Forest_OP_19_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_20_GUID,
     Forest_OP_20_TaskTable,
     ARRAY_COUNT(Forest_OP_20_TaskTable),
     FALSE,
     0
    },
    {CallBackFunc,
     (GUID *) &FOREST_OP_21_GUID,
     Forest_OP_21_TaskTable,
     ARRAY_COUNT(Forest_OP_21_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_22_GUID,
     Forest_OP_22_TaskTable,
     ARRAY_COUNT(Forest_OP_22_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_23_GUID,
     Forest_OP_23_TaskTable,
     ARRAY_COUNT(Forest_OP_23_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_24_GUID,
     Forest_OP_24_TaskTable,
     ARRAY_COUNT(Forest_OP_24_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_25_GUID,
     Forest_OP_25_TaskTable,
     ARRAY_COUNT(Forest_OP_25_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_26_GUID,
     Forest_OP_26_TaskTable,
     ARRAY_COUNT(Forest_OP_26_TaskTable),
     FALSE,
     0
    },
    // Forest OP 27 has been migrated to Forest OP 29
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_28_GUID,
     Forest_OP_28_TaskTable,
     ARRAY_COUNT(Forest_OP_28_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &FOREST_OP_29_GUID,
     Forest_OP_29_TaskTable,
     ARRAY_COUNT(Forest_OP_29_TaskTable),
     FALSE,
     0
    },
    {AddRemoveAces,
     (GUID *) &FOREST_OP_30_GUID,
     Forest_OP_30_TaskTable,
     ARRAY_COUNT(Forest_OP_30_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_31_GUID,
     Forest_OP_31_TaskTable,
     ARRAY_COUNT(Forest_OP_31_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_32_GUID,
     Forest_OP_32_TaskTable,
     ARRAY_COUNT(Forest_OP_32_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_33_GUID,
     Forest_OP_33_TaskTable,
     ARRAY_COUNT(Forest_OP_33_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_34_GUID,
     Forest_OP_34_TaskTable,
     ARRAY_COUNT(Forest_OP_34_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_35_GUID,
     Forest_OP_35_TaskTable,
     ARRAY_COUNT(Forest_OP_35_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_36_GUID,
     Forest_OP_36_TaskTable,
     ARRAY_COUNT(Forest_OP_36_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_37_GUID,
     Forest_OP_37_TaskTable,
     ARRAY_COUNT(Forest_OP_37_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_38_GUID,
     Forest_OP_38_TaskTable,
     ARRAY_COUNT(Forest_OP_38_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_39_GUID,
     Forest_OP_39_TaskTable,
     ARRAY_COUNT(Forest_OP_39_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_40_GUID,
     Forest_OP_40_TaskTable,
     ARRAY_COUNT(Forest_OP_40_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_41_GUID,
     Forest_OP_41_TaskTable,
     ARRAY_COUNT(Forest_OP_41_TaskTable),
     FALSE,
     0
    },
    {ModifyDefaultSd,
     (GUID *) &FOREST_OP_42_GUID,
     Forest_OP_42_TaskTable,
     ARRAY_COUNT(Forest_OP_42_TaskTable),
     FALSE,
     0
    },
};


POPERATION_TABLE gForestOperationTable = ForestOperationTable; 
ULONG   gForestOperationTableCount = sizeof(ForestOperationTable) / sizeof(OPERATION_TABLE);




//
// DomainPrep Containers CN's
// 

PWCHAR  DomainPrepContainersTable[] =
{
    {L"cn=DomainUpdates,cn=System"},
    {L"cn=Operations,cn=DomainUpdates,cn=System"},
};

PWCHAR  *gDomainPrepContainers = DomainPrepContainersTable;
ULONG   gDomainPrepContainersCount = sizeof(DomainPrepContainersTable) / sizeof(PWCHAR); 




//
// ForestPrep Containers CN's
// 

PWCHAR  ForestPrepContainersTable[] = 
{
    {L"cn=ForestUpdates"},
    {L"cn=Operations,cn=ForestUpdates"},
};

PWCHAR  *gForestPrepContainers = ForestPrepContainersTable;
ULONG   gForestPrepContainersCount = sizeof(ForestPrepContainersTable) / sizeof(PWCHAR);




//
// ADPrep Primitive Table
// 

PRIMITIVE_FUNCTION  PrimitiveFuncTable[] =
{
    PrimitiveCreateObject,
    PrimitiveAddMembers,
    PrimitiveAddRemoveAces,
    PrimitiveSelectivelyAddRemoveAces,
    PrimitiveModifyDefaultSd,
    PrimitiveModifyAttrs,
    PrimitiveCallBackFunc,
    PrimitiveDoSpecialTask,
};

PRIMITIVE_FUNCTION *gPrimitiveFuncTable = PrimitiveFuncTable;
ULONG   gPrimitiveFuncTableCount = sizeof(PrimitiveFuncTable) / sizeof(PRIMITIVE_FUNCTION);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adprep\lib\adpcheck.h ===
/*++

Copyright (C) Microsoft Corporation, 2001
              Microsoft Windows

Module Name:

    ADPCHECK.H

Abstract:

    This is the header file for domain/forest check

Author:

    14-May-01 ShaoYin

Environment:

    User Mode - Win32

Revision History:

    14-May-01 ShaoYin Created Initial File.

--*/

#ifndef _ADP_CHECK_
#define _ADP_CHECK_



//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


//
// Windows Headers
//
#include <windows.h>
#include <winerror.h>
#include <rpc.h>
#include <winldap.h>


//
// localization
// 
#include <locale.h>



//
// define ADP revision number
//
// adprep.exe is required to be run if schema version changes or adprep version 
// changes. Through out the entire adprep code base, 
//      ADP_FORESTPREP_CURRENT_REVISION and 
//      ADP_FORESTPREP_CURRENT_REVISION_STRING are used.
// So we should always keep them the highest revision number. 
//
//

#define ADP_FORESTPREP_PRE_WHISTLER_BETA3_REVISION  0x1
#define ADP_FORESTPREP_WHISTLER_BETA3_REVISION      0x2
#define ADP_FORESTPREP_WHISTLER_RC1_REVISION        0x8
#define ADP_FORESTPREP_WHISTLER_RC2_REVISION        0x9
#define ADP_FORESTPREP_CURRENT_REVISION             ADP_FORESTPREP_WHISTLER_RC2_REVISION
#define ADP_FORESTPREP_CURRENT_REVISION_STRING      L"9"


#define ADP_DOMAINPREP_PRE_WHISTLER_BETA3_REVISION  0x1
#define ADP_DOMAINPREP_WHISTLER_BETA3_REVISION      0x2
#define ADP_DOMAINPREP_WHISTLER_RC1_REVISION        0x6
#define ADP_DOMAINPREP_WHISTLER_RC2_REVISION        0x8
#define ADP_DOMAINPREP_CURRENT_REVISION             ADP_DOMAINPREP_WHISTLER_RC2_REVISION
#define ADP_DOMAINPREP_CURRENT_REVISION_STRING      L"8"



#define ADP_FOREST_UPDATE_CONTAINER_PREFIX  L"CN=Windows2003Update,CN=ForestUpdates"
#define ADP_DOMAIN_UPDATE_CONTAINER_PREFIX  L"CN=Windows2003Update,CN=DomainUpdates,CN=System"



#define ADP_WIN_ERROR                      0x00000001
#define ADP_LDAP_ERROR                     0x00000002


typedef struct _ERROR_HANDLE {
    ULONG   Flags;
    ULONG   WinErrorCode;      // used to hold WinError Code
    PWSTR   WinErrorMsg;       // pointer to WinError Message 
    ULONG   LdapErrorCode;
    ULONG   LdapServerExtErrorCode;
    PWSTR   LdapServerErrorMsg;
} ERROR_HANDLE, *PERROR_HANDLE;


PVOID
AdpAlloc(
    SIZE_T  Size
    );

VOID
AdpFree(
    PVOID BaseAddress
    );



ULONG
AdpMakeLdapConnection(
    LDAP **LdapHandle,
    PWCHAR HostName,
    ERROR_HANDLE *ErrorHandle
    );

ULONG
AdpCheckForestUpgradeStatus(
    IN LDAP *LdapHandle,
    OUT PWCHAR  *pSchemaMasterDnsHostName,
    OUT BOOLEAN *fAmISchemaMaster,
    OUT BOOLEAN *fIsFinishedLocally,
    OUT BOOLEAN *fIsFinishedOnSchemaMaster,
    OUT BOOLEAN *fIsSchemaUpgradedLocally,
    OUT BOOLEAN *fIsSchemaUpgradedOnSchemaMaster,
    IN OUT ERROR_HANDLE *ErrorHandle
    );

ULONG
AdpCheckDomainUpgradeStatus(
    IN LDAP *LdapHandle,
    OUT PWCHAR  *pInfrastructureMasterDnsHostName,
    OUT BOOLEAN *fAmIInfrastructureMaster,
    OUT BOOLEAN *fIsFinishedLocally,
    OUT BOOLEAN *fIsFinishedOnIM,
    IN OUT ERROR_HANDLE *ErrorHandle
    );


VOID
AdpSetWinError(
    IN ULONG WinError,
    OUT ERROR_HANDLE *ErrorHandle
    );

VOID
AdpSetLdapError(
    IN LDAP *LdapHandle,
    IN ULONG LdapError,
    OUT ERROR_HANDLE *ErrorHandle
    );

VOID
AdpClearError( 
    IN OUT ERROR_HANDLE *ErrorHandle 
    );


ULONG
AdpGetLdapSingleStringValue(
    IN LDAP *LdapHandle,
    IN PWCHAR pObjDn,
    IN PWCHAR pAttrName,
    OUT PWCHAR *ppAttrValue,
    OUT ERROR_HANDLE *ErrorHandle
    );

#endif  // _ADP_CHECK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\bootopt\exe\main.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    main.c

Abstract:

    This module implements functions to detect the system partition drive and
    providing extra options in boot.ini for NTDS setup on intel platform.

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created             10/07/96    rsraghav

--*/

#include <windows.h>
#include <bootopt.h>
#include <stdio.h>

int __cdecl main(int argc, char *argv[])
{
    BOOLEAN fUsage = FALSE;
    DWORD   WinError = ERROR_SUCCESS;
    NTDS_BOOTOPT_MODTYPE Modification = eAddBootOption;
    CHAR   *Option;

    if ( argc == 2 )
    {
        Option = argv[1];

        if ( *Option == '-' || *Option == '/' )
        {
            Option++;
        }

        if ( !_stricmp( Option, "add" ) )
        {
            printf( "Adding ds repair boot option ...\n");
            Modification = eAddBootOption;
        }
        else if ( !_stricmp( Option, "remove" ) )
        {
            printf( "Removing ds repair boot option ...\n");
            Modification = eRemoveBootOption;
        }
        else
        {
            fUsage = TRUE;
        }
    }
    else
    {
        fUsage = TRUE;
    }

    if ( fUsage )
    {
        printf( "%s -[add|remove]\nThis command adds or removes the ds repair"\
                 " option from your system boot options.\n", argv[0] );
    }
    else
    {
        WinError = NtdspModifyDsRepairBootOption( Modification );

        if ( WinError == ERROR_SUCCESS )
        {
            printf( "The command completed successfully.\n" );
        }
        else
        {
            printf( "The command errored with %d.\n", WinError );
        }
    }

    return ( fUsage ?  0  : WinError );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\adprep\gpupgrade\gpupgrade.cpp ===
/*******************************************************************************************/
/* gpoupg.cpp                                                                              */   
/*                                                                                         */   
/*                                                                                         */   
/* Code that fixes up the GPOs when domainprep operation when the DC/domain gets upgraded. */
/* using adprep domainprep operation                                                       */   
/*                                                                                         */   
/* Created UShaji       27th July 2001                                                     */   
/*                                                                                         */
/* Assumptions:                                                                            */
/*    1. This code is being called from the DC itself                                      */
/*          we are reading the sysvol locations from the local registry.                   */
/*                                                                                         */
/*    2. Domain is up at this point                                                        */
/*          We are calling DsGetDcName to figure out the domain                            */
/*                                                                                         */
/*    3. This lib is getting linked to the exe directly                                    */
/*          We are initialising module handle with the exe filename                        */
/*******************************************************************************************/

#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <accctrl.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <lm.h>

#include "smartptr.h"
#include "adpmsgs.h"


// error logging mechanisms
//
// Error messages are going to be logged in the following fashion.
//      1. Verbose messages will only be logged to the log file.
//      2. Error messages will be logged to the log file and will be
//         returned as an error string.


           
class CMsg;

class CLogger
{
private:
    XPtrLF<WCHAR>   m_xszErrorMsg;  // Error msg string
    LPWSTR          m_szLogFile;    // this is not allocated in this class
public:
    CLogger(LPWSTR szLogFile);
    HRESULT Log(CMsg *pMsg);
    LPWSTR ErrorMsg()
    {
        return m_xszErrorMsg.Acquire();
    }
};

class CMsg 
{
    BOOL            m_bError;       // the kind of error to log
    DWORD           m_dwMsgId;      // id of the string in the resource
    XPtrLF<LPTSTR>  m_xlpStrings;   // Array to store arguments
    WORD            m_cStrings;     // Number of elements already in the array
    WORD            m_cAllocated;   // Number of elements allocated
    BOOL            m_bInitialised; // Initialised ?
    BOOL            m_bFailed;      // Failed in processing ?

    // Not implemented.
    CMsg(const CMsg& x);
    CMsg& operator=(const CMsg& x);

    BOOL ReallocArgStrings();
    LPTSTR MsgString();

public:
    CMsg(BOOL bError, DWORD dwMsgId);
    ~CMsg();
    BOOL AddArg(LPWSTR szArg);
    BOOL AddArgWin32Error(DWORD dwArg);
    friend HRESULT CLogger::Log(CMsg *pMsg);
};
    
#define SYSVOL_LOCATION_KEY     L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters"
#define SYSVOL_LOCATION_VALUE   L"Sysvol"
#define POLICIES_SUBDIR         L"Policies"

#define LOGFILE                 L"gpupgrad.log"


HMODULE g_hModule;

// we are not using this.
typedef void *progressFunction;

extern "C" {
HRESULT 
UpgradeGPOSysvolLocation (
                        PWSTR               logFilesPath,
                        GUID               *operationGuid,
                        BOOL                dryRun,
                        PWSTR              *errorMsg,
                        void               *caleeStruct,
                        progressFunction    stepIt,
                        progressFunction    totalSteps);
};

HRESULT UpgradeSysvolGPOs(LPWSTR              szSysvolPoliciesPath,                         
                          CLogger            *pLogger);

LPTSTR CheckSlash (LPTSTR lpDir);
BOOL ValidateGuid( TCHAR *szValue );





HRESULT 
UpgradeGPOSysvolLocation (
                        PWSTR               logFilesPath,
                        GUID               *operationGuid,
                        BOOL                dryRun,
                        PWSTR              *errorMsg,
                        void               *caleeStruct,
                        progressFunction    stepIt,
                        progressFunction    totalSteps)
/*++

Routine Description:

    Entry point for the domainprep
  
Arguments:

    Refer domainprep documentation

Return Value:

	S_OK on success. 
	On failure the corresponding error code will be returned.
	Any API calls that are made in this function might fail and these error
	codes will be returned directly.

Assumptions: 
      1. This code is being called from the DC itself and we are reading the sysvol
          locations from the local registry.

      2. Domain is up at this point

      3. This lib is getting linked to the exe directly                                   
          We are initializing module handle with the exe filename                       

--*/
{
    HRESULT                     hr                  = S_OK;
    XPtrLF<WCHAR>               xszGPOSysvolLocation;
    XPtrLF<WCHAR>               xszLogFile;
    DWORD                       dwErr               = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFO     pDCInfo             = NULL;
    XKey                        xhKey;
    DWORD                       dwSize              = 0;
    DWORD                       dwType;
    LPWSTR                      lpDomainDNSName;
    LPWSTR                      lpEnd;
    
    if (dryRun) {
        return S_OK;
    }

    //
    // allocate space for logfilepath\LOGFILE
    //

    xszLogFile = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(lstrlen(logFilesPath) + 2 + lstrlen(LOGFILE)));

    if (!xszLogFile) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    lstrcpy(xszLogFile, logFilesPath);
    lpEnd = CheckSlash(xszLogFile);
    lstrcat(lpEnd, LOGFILE);


    CLogger                     Logger(xszLogFile);
    CLogger                    *pLogger = &Logger;


    g_hModule = GetModuleHandle(NULL);

    //
    // get the domain name of the DC.
    //

    dwErr = DsGetDcName(NULL, NULL, NULL, NULL, DS_RETURN_DNS_NAME, &pDCInfo);

    if (dwErr != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(dwErr);
        CMsg    msg(TRUE, EVENT_GETDOMAIN_FAILED);
        msg.AddArgWin32Error(hr); pLogger->Log(&msg);
        goto Exit;
    }

    lpDomainDNSName = pDCInfo->DomainName;


    //
    // Now get the sysvol location
    //

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         SYSVOL_LOCATION_KEY, 
                         0,
                         KEY_READ,
                         &xhKey);

    if (dwErr != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(dwErr);
        CMsg    msg(TRUE, EVENT_GETSYSVOL_FAILED);
        msg.AddArgWin32Error(hr); pLogger->Log(&msg);
        goto Exit;
    }


    dwErr = RegQueryValueEx(xhKey, 
                            SYSVOL_LOCATION_VALUE, 
                            0,
                            &dwType,
                            NULL,
                            &dwSize);

    if ( (dwErr != ERROR_MORE_DATA) && (dwErr != ERROR_SUCCESS) ) {
        hr = HRESULT_FROM_WIN32(dwErr);
        CMsg    msg(TRUE, EVENT_GETSYSVOL_FAILED);
        msg.AddArgWin32Error(hr); pLogger->Log(&msg);
        goto Exit;
    }


    //
    // Allocate space for the size of the sysvol + \ + domain name + \ + policies
    //

    xszGPOSysvolLocation = (LPWSTR)LocalAlloc(LPTR, (sizeof(WCHAR)*(lstrlen(lpDomainDNSName) + 3 + lstrlen(POLICIES_SUBDIR))) + dwSize);

    if (!xszGPOSysvolLocation) {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
        CMsg    msg(TRUE, EVENT_OUT_OF_MEMORY);
        pLogger->Log(&msg);
        goto Exit;
    }

    dwErr = RegQueryValueEx(xhKey, 
                            SYSVOL_LOCATION_VALUE, 
                            0,
                            &dwType,
                            (LPBYTE)((LPWSTR)xszGPOSysvolLocation),
                            &dwSize);

    if (dwErr != ERROR_SUCCESS)  {
        hr = HRESULT_FROM_WIN32(dwErr);
        CMsg    msg(TRUE, EVENT_GETSYSVOL_FAILED);
        msg.AddArgWin32Error(hr); pLogger->Log(&msg);
        goto Exit;
    }

    lpEnd = CheckSlash(xszGPOSysvolLocation);
    lstrcpy(lpEnd, lpDomainDNSName);
    
    lpEnd = CheckSlash(xszGPOSysvolLocation);
    lstrcpy(lpEnd, POLICIES_SUBDIR);


    //
    // Now do the actual upgrading of GPO paths
    //

    hr = UpgradeSysvolGPOs(xszGPOSysvolLocation, &Logger);

Exit:
    if (pDCInfo) {
        NetApiBufferFree ( pDCInfo );
    }

    if (FAILED(hr) && (errorMsg)) {
        *errorMsg = pLogger->ErrorMsg();
    }

    return hr;
}


HRESULT UpgradeSysvolGPOs(LPWSTR              szSysvolPoliciesPath,                         
                          CLogger            *pLogger)
/*++

Routine Description:

    Upgrades all the sysvol GPO locations with the new ACE corresponding
    to the upgrade
  
Arguments:

	[in] szSysvolPoliciesPath - Location of the domain sysvol path.
                                This should be the path that is normally accessed as
                                \\domain\sysvol\domain\policies
                                
    [out] errorMsg            - Verbose Error Message corresponding to the operation                    
        
Return Value:

	S_OK on success. 
	On failure the corresponding error code will be returned.
	Any API calls that are made in this function might fail and these error
	codes will be returned directly.
--*/

{
    HRESULT                     hr                  = S_OK;
    HANDLE                      hFindHandle         = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA             findData;
    XPtrLF<WCHAR>               xszPolicyDirName;
    DWORD                       dwErr;
    LPWSTR                      lpEnd               = NULL;
    SID_IDENTIFIER_AUTHORITY    authNT              = SECURITY_NT_AUTHORITY;
    PSID                        psidEnterpriseDCs   = NULL;
    EXPLICIT_ACCESS             EnterpriseDCPerms;
    
    //
    // Get the EDCs sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_ENTERPRISE_CONTROLLERS_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidEnterpriseDCs)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CMsg    msg(TRUE, EVENT_GETEDC_SID_FAILED);
        msg.AddArgWin32Error(hr); pLogger->Log(&msg);
        goto Exit;
    }

    memset(&EnterpriseDCPerms, 0, sizeof(EXPLICIT_ACCESS));



    EnterpriseDCPerms.grfAccessMode = GRANT_ACCESS;

    // 
    // File system read permissions
    //

    EnterpriseDCPerms.grfAccessPermissions  = (STANDARD_RIGHTS_READ | SYNCHRONIZE | FILE_LIST_DIRECTORY |
                                               FILE_READ_ATTRIBUTES | FILE_READ_EA |
                                               FILE_READ_DATA | FILE_EXECUTE);

    EnterpriseDCPerms.grfInheritance = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);


    EnterpriseDCPerms.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    EnterpriseDCPerms.Trustee.pMultipleTrustee = NULL;
    EnterpriseDCPerms.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    EnterpriseDCPerms.Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
    EnterpriseDCPerms.Trustee.ptstrName = (LPWSTR)psidEnterpriseDCs;




    //
    // Allocate space for the directoryname + \ + filename
    // This needs to contain space for the full directory name
    //

    xszPolicyDirName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*
                                          (lstrlen(szSysvolPoliciesPath) + 2 + MAX_PATH));

    if ( !xszPolicyDirName ) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CMsg    msg(TRUE, EVENT_OUT_OF_MEMORY);
        pLogger->Log(&msg);
        goto Exit;
    }

    lstrcpy(xszPolicyDirName, szSysvolPoliciesPath);
    lpEnd = CheckSlash(xszPolicyDirName);
    lstrcpy(lpEnd, TEXT("*"));


    //
    // Enumerate through this directory and look for all the directories that has
    // guids as names
    //


    hFindHandle = FindFirstFile( xszPolicyDirName, &findData );

    if (hFindHandle == INVALID_HANDLE_VALUE) {
        // it should fail in this case because it should have at least 1 or 2 GPOs in the domain
        hr = HRESULT_FROM_WIN32(GetLastError());
        CMsg    msg(TRUE, EVENT_SYSVOL_ENUM_FAILED);
        msg.AddArg(xszPolicyDirName); msg.AddArgWin32Error(hr); pLogger->Log(&msg);
        goto Exit;
    }

    for (;;) {

        XPtrLF<SECURITY_DESCRIPTOR> xSecurityDescriptor;
        PACL                        pDACL;
        XPtrLF<ACL>                 xNewDACL; 
        BOOL                        bPermsPresent;
        
        //
        // Get the full path name to the dir name in xszPolicyDirName
        //

        lstrcpy(lpEnd, findData.cFileName);

        if ( (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (ValidateGuid(findData.cFileName)) ) {
            
            //
            // GPO dirs should be GUIDs
            //

            dwErr = GetNamedSecurityInfo(xszPolicyDirName, 
                                         SE_FILE_OBJECT,
                                         DACL_SECURITY_INFORMATION,
                                         NULL,
                                         NULL,
                                         &pDACL, // this is a pointer inside security descriptor
                                         NULL,
                                         (PSECURITY_DESCRIPTOR *)&xSecurityDescriptor);

            if (dwErr != ERROR_SUCCESS) {
                hr = HRESULT_FROM_WIN32(dwErr);
                CMsg    msg(TRUE, EVENT_GET_PERMS_FAILED);
                msg.AddArg(xszPolicyDirName); msg.AddArgWin32Error(hr); pLogger->Log(&msg);
                goto Exit;
            }

            //
            // idempotency required by adprep is achieved by specifying GRANT_ACCESS in the explicit ACE.
            // This will merge with any existing permissions
            // 

            dwErr = SetEntriesInAcl(1, &EnterpriseDCPerms, pDACL, &xNewDACL);
            
            if (dwErr != ERROR_SUCCESS) {
                hr = HRESULT_FROM_WIN32(dwErr);
                CMsg    msg(TRUE, EVENT_CREATE_PERMS_FAILED);
                msg.AddArg(xszPolicyDirName); msg.AddArgWin32Error(hr); pLogger->Log(&msg);
                goto Exit;
            }


            dwErr = SetNamedSecurityInfo(xszPolicyDirName,
                                         SE_FILE_OBJECT,
                                         DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                                         NULL,
                                         NULL,
                                         xNewDACL,
                                         NULL);

            if (dwErr != ERROR_SUCCESS) {
                hr = HRESULT_FROM_WIN32(dwErr);
                CMsg    msg(TRUE, EVENT_SET_PERMS_FAILED);
                msg.AddArg(xszPolicyDirName); msg.AddArgWin32Error(hr); pLogger->Log(&msg);
                goto Exit;
            }
            
            CMsg    msg(FALSE, EVENT_SET_PERMS_SUCCEEDED);
            msg.AddArg(xszPolicyDirName); pLogger->Log(&msg);
        }
        else {
            CMsg    msg(FALSE, EVENT_NOTGPO_DIR);
            msg.AddArg(xszPolicyDirName); pLogger->Log(&msg);
        }


        if (!FindNextFile( hFindHandle, &findData )) {
            dwErr = GetLastError();
            if (dwErr == ERROR_NO_MORE_FILES) {
                CMsg    msg(FALSE, EVENT_UPDATE_SUCCEEDED);
                pLogger->Log(&msg);
                break;
            }
            else {
                hr = HRESULT_FROM_WIN32(dwErr);
                CMsg    msg(TRUE, EVENT_ENUMCONTINUE_FAILED);
                msg.AddArg(xszPolicyDirName); msg.AddArgWin32Error(hr); pLogger->Log(&msg);
                goto Exit;
            }
        }
    }



    hr = S_OK;

Exit:

    if (hFindHandle != INVALID_HANDLE_VALUE) {
        FindClose(hFindHandle);
    }

    if (psidEnterpriseDCs) {
        FreeSid(psidEnterpriseDCs);
    }

    return hr;
}


 

//*************************************************************
//  CMsg::CMsg
//  Purpose:    Constructor
//
//  Parameters:
//      dwFlags - Error or informational
//      dwMsgId    - Id of the msg
//
//
//  allocates a default sized array for the messages
//*************************************************************

#define DEF_ARG_SIZE 10

CMsg::CMsg(BOOL bError, DWORD dwMsgId ) :
                          m_bError(bError), m_cStrings(0), m_cAllocated(0), m_bInitialised(FALSE),
                          m_dwMsgId(dwMsgId), m_bFailed(TRUE)
{
    XLastError xe;
    //
    // Allocate a default size for the message
    //

    m_xlpStrings = (LPTSTR *)LocalAlloc(LPTR, sizeof(LPTSTR)*DEF_ARG_SIZE);
    m_cAllocated = DEF_ARG_SIZE;
    if (!m_xlpStrings) {
        return;
    }
    
    m_bInitialised = TRUE;
    m_bFailed = FALSE;
}



//*************************************************************
//  CMsg::~CMsg()
//
//  Purpose:    Destructor
//
//  Parameters: void
//
//  frees the memory
//*************************************************************

CMsg::~CMsg()
{
    XLastError xe;
    for (int i = 0; i < m_cStrings; i++)
        if (m_xlpStrings[i])
            LocalFree(m_xlpStrings[i]);
}

//*************************************************************
//
//  CMsg::ReallocArgStrings
//
//  Purpose: Reallocates the buffer for storing arguments in case
//           the buffer runs out
//
//  Parameters: void
//
//  reallocates
//*************************************************************

BOOL CMsg::ReallocArgStrings()
{
    XPtrLF<LPTSTR>  aStringsNew;
    XLastError xe;


    //
    // first allocate a larger buffer
    //

    aStringsNew = (LPTSTR *)LocalAlloc(LPTR, sizeof(LPTSTR)*(m_cAllocated+DEF_ARG_SIZE));

    if (!aStringsNew) {
        m_bFailed = TRUE;
        return FALSE;
    }


    //
    // copy the arguments
    //

    for (int i = 0; i < (m_cAllocated); i++) {
        aStringsNew[i] = m_xlpStrings[i];
    }

    m_xlpStrings = aStringsNew.Acquire();
    m_cAllocated+= DEF_ARG_SIZE;

    return TRUE;
}



//*************************************************************
//
//  CMsg::AddArg
//
//  Purpose: Add arguments appropriately formatted
//
//  Parameters:
//
//*************************************************************

BOOL CMsg::AddArg(LPTSTR szArg)
{
    XLastError xe;
    
    if ((!m_bInitialised) || (m_bFailed)) {
        return FALSE;
    }

    if (m_cStrings == m_cAllocated) {
        if (!ReallocArgStrings())
            return FALSE;
    }


    m_xlpStrings[m_cStrings] = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*(lstrlen(szArg)+1));

    if (!m_xlpStrings[m_cStrings]) {
        m_bFailed = TRUE;
        return FALSE;
    }


    lstrcpy(m_xlpStrings[m_cStrings], szArg);
    m_cStrings++;

    return TRUE;
}

//*************************************************************
//
//  CMsg::AddArgWin32Error
//
//  Purpose: Add arguments formatted as error string
//
//  Parameters:
//
//*************************************************************

BOOL CMsg::AddArgWin32Error(DWORD dwArg)
{
    XLastError xe;

    if ((!m_bInitialised) || (m_bFailed))
    {
        return FALSE;
    }

    if (m_cStrings == m_cAllocated)
    {
        if (!ReallocArgStrings())
            return FALSE;
    }

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                         0,
                         dwArg,
                         0,
                         (LPTSTR) &m_xlpStrings[m_cStrings],
                         1,
                         0 ) == 0 )
    {
        m_bFailed = TRUE;
        return FALSE;
    }
    
    m_cStrings++;

    return TRUE;
}


//*************************************************************
//
//  CMsg::MsgString
//
//  Purpose: Returns the error msg formatted as a string
//
//  Parameters:
//
//*************************************************************

LPTSTR CMsg::MsgString()
{
    XLastError xe;
    BOOL bResult = TRUE;
    LPTSTR szMsg=NULL;

    if ((!m_bInitialised) || (m_bFailed)) {
        return FALSE;
    }

    
    if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                       FORMAT_MESSAGE_FROM_HMODULE | 
                       FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       g_hModule,
                       m_dwMsgId,
                       0,
                       (LPTSTR)&szMsg,
                       0, // min number of chars
                       (va_list *)(LPTSTR *)(m_xlpStrings))) {
        xe = GetLastError();
        return NULL;
    }

    return szMsg;
}


//*************************************************************
//
//  Clogger: initialize the logger with the log file name
//
//
//*************************************************************
CLogger::CLogger(LPWSTR szLogFile)
{
    m_szLogFile = szLogFile;
}

    
//*************************************************************
//
//  Append to the log file and in case of error hold onto the string
//
//
//*************************************************************
HRESULT CLogger::Log(CMsg *pMsg)
{
    XPtrLF<WCHAR>       xszMsg;

    xszMsg = pMsg->MsgString();

    if (!xszMsg) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (m_szLogFile) {
        HANDLE hFile;
        DWORD dwBytesWritten;
        
        hFile = CreateFile( m_szLogFile,
                           FILE_WRITE_DATA | FILE_APPEND_DATA,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

        if (hFile != INVALID_HANDLE_VALUE) {

            if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                WriteFile (hFile, (LPCVOID) xszMsg,
                           lstrlen (xszMsg) * sizeof(TCHAR),
                           &dwBytesWritten,
                           NULL);
            }

            CloseHandle (hFile);
        }
    }

    if (pMsg->m_bError) {
        m_xszErrorMsg = xszMsg.Acquire();
    }

    return S_OK;
}
                                                                                             
//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

#define GUID_LENGTH 38

BOOL ValidateGuid( TCHAR *szValue )
{
    //
    // Check if szValue is of form {19e02dd6-79d2-11d2-a89d-00c04fbbcfa2}
    //

    if ( lstrlen(szValue) < GUID_LENGTH )
        return FALSE;

    if ( szValue[0] != TEXT('{')
         || szValue[9] != TEXT('-')
         || szValue[14] != TEXT('-')
         || szValue[19] != TEXT('-')
         || szValue[24] != TEXT('-')
         || szValue[37] != TEXT('}') )
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\base64\base64.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.c

ABSTRACT:

    Base64 encoding and decoding functions.

DETAILS:
    
CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#include "debug.h"
#include "base64.h"

#include <fileno.h>
#define FILENO   FILENO_UTIL_BASE64_BASE64

NTSTATUS
base64encode(
    IN  VOID *  pDecodedBuffer,
    IN  DWORD   cbDecodedBufferSize,
    OUT LPSTR   pszEncodedString,
    IN  DWORD   cchEncodedStringSize,
    OUT DWORD * pcchEncoded             OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pDecodedBuffer (IN) - buffer to encode.
    cbDecodedBufferSize (IN) - size of buffer to encode.
    cchEncodedStringSize (IN) - size of the buffer for the encoded string.
    pszEncodedString (OUT) = the encoded string.
    pcchEncoded (OUT) - size in characters of the encoded string.

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
    static char rgchEncodeTable[64] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    DWORD   ib;
    DWORD   ich;
    DWORD   cchEncoded;
    BYTE    b0, b1, b2;
    BYTE *  pbDecodedBuffer = (BYTE *) pDecodedBuffer;

    // Calculate encoded string size.
    cchEncoded = 1 + (cbDecodedBufferSize + 2) / 3 * 4;

    if (NULL != pcchEncoded) {
        *pcchEncoded = cchEncoded;
    }

    if (cchEncodedStringSize < cchEncoded) {
        // Given buffer is too small to hold encoded string.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Encode data byte triplets into four-byte clusters.
    ib = ich = 0;
    while (ib < cbDecodedBufferSize) {
        b0 = pbDecodedBuffer[ib++];
        b1 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;
        b2 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;

        pszEncodedString[ich++] = rgchEncodeTable[b0 >> 2];
        pszEncodedString[ich++] = rgchEncodeTable[((b0 << 4) & 0x30) | ((b1 >> 4) & 0x0f)];
        pszEncodedString[ich++] = rgchEncodeTable[((b1 << 2) & 0x3c) | ((b2 >> 6) & 0x03)];
        pszEncodedString[ich++] = rgchEncodeTable[b2 & 0x3f];
    }

    // Pad the last cluster as necessary to indicate the number of data bytes
    // it represents.
    switch (cbDecodedBufferSize % 3) {
      case 0:
        break;
      case 1:
        pszEncodedString[ich - 2] = '=';
        // fall through
      case 2:
        pszEncodedString[ich - 1] = '=';
        break;
    }

    // Null-terminate the encoded string.
    pszEncodedString[ich++] = '\0';

    Assert(ich == cchEncoded);

    return STATUS_SUCCESS;
}


NTSTATUS
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pszEncodedString (IN) - base64-encoded string to decode.
    cbDecodeBufferSize (IN) - size in bytes of the decode buffer.
    pbDecodeBuffer (OUT) - holds the decoded data.
    pcbDecoded (OUT) - number of data bytes in the decoded data (if success or
        STATUS_BUFFER_TOO_SMALL).

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
#define NA (255)
#define DECODE(x) (((int)(x) < sizeof(rgbDecodeTable)) ? rgbDecodeTable[x] : NA)

    static BYTE rgbDecodeTable[128] = {
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 0-15 
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 16-31
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 62, NA, NA, NA, 63,  // 32-47
       52, 53, 54, 55, 56, 57, 58, 59, 60, 61, NA, NA, NA,  0, NA, NA,  // 48-63
       NA,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  // 64-79
       15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, NA, NA, NA, NA, NA,  // 80-95
       NA, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,  // 96-111
       41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, NA, NA, NA, NA, NA,  // 112-127
    };

    DWORD   cbDecoded;
    DWORD   cchEncodedSize;
    DWORD   ich;
    DWORD   ib;
    BYTE    b0, b1, b2, b3;
    BYTE *  pbDecodeBuffer = (BYTE *) pDecodeBuffer;

    cchEncodedSize = lstrlenA(pszEncodedString);

    if ((0 == cchEncodedSize) || (0 != (cchEncodedSize % 4))) {
        // Input string is not sized correctly to be base64.
        return STATUS_INVALID_PARAMETER;
    }

    // Calculate decoded buffer size.
    cbDecoded = (cchEncodedSize + 3) / 4 * 3;
    if (pszEncodedString[cchEncodedSize-1] == '=') {
        if (pszEncodedString[cchEncodedSize-2] == '=') {
            // Only one data byte is encoded in the last cluster.
            cbDecoded -= 2;
        }
        else {
            // Only two data bytes are encoded in the last cluster.
            cbDecoded -= 1;
        }
    }

    if (NULL != pcbDecoded) {
        *pcbDecoded = cbDecoded;
    }

    if (cbDecoded > cbDecodeBufferSize) {
        // Supplied buffer is too small.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Decode each four-byte cluster into the corresponding three data bytes.
    ich = ib = 0;
    while (ich < cchEncodedSize) {
        b0 = DECODE(pszEncodedString[ich]); ich++;
        b1 = DECODE(pszEncodedString[ich]); ich++;
        b2 = DECODE(pszEncodedString[ich]); ich++;
        b3 = DECODE(pszEncodedString[ich]); ich++;

        if ((NA == b0) || (NA == b1) || (NA == b2) || (NA == b3)) {
            // Contents of input string are not base64.
            return STATUS_INVALID_PARAMETER;
        }

        pbDecodeBuffer[ib++] = (b0 << 2) | (b1 >> 4);

        if (ib < cbDecoded) {
            pbDecodeBuffer[ib++] = (b1 << 4) | (b2 >> 2);
    
            if (ib < cbDecoded) {
                pbDecodeBuffer[ib++] = (b2 << 6) | b3;
            }
        }
    }

    Assert(ib == cbDecoded);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\bootopt\lib\common.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    utils.h

Abstract:

    This module proto-types helper functions for the bootopt library and
    the structure definitions for structures that are common to intel and
    non-intel platforms.

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created             10/07/96    rsraghav

--*/

// C Runtime
#include <stdio.h>
#include <stdlib.h>

// NT APIs
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

// Windos APIs
#include <windows.h>

#include <bootopt.h>

//  Macro Definitions

#define MALLOC(cb)              Malloc(cb)
#define REALLOC(pv, cbNew)      Realloc((pv),(cbNew))
#define FREE(pv)                Free(&(pv))

#define DISPLAY_STRING_DS_REPAIR    L"Windows NT (Directory Service Repair)"

#define MAX_DRIVE_NAME_LEN              (3)             // ?:\0

#define MAX_BOOT_START_OPTIONS_LEN      (256)
#define MAX_BOOT_PATH_LEN               (256)
#define MAX_BOOT_DISPLAY_LEN            (256)

#define INITIAL_KEY_COUNT   (10)
#define DEFAULT_KEY_INCREMENT (2)


//  Memory routine proto-types

PVOID   Malloc(IN DWORD cb);
PVOID   Realloc(IN PVOID pv, IN DWORD cbNew);
VOID    Free(IN OUT PVOID *ppv);

//  Other Common Util proto-types
BOOL   FModifyStartOptionsToBootKey(TCHAR *pszStartOptions, NTDS_BOOTOPT_MODTYPE Modification );

PTSTR DupString(IN PTSTR String);
PCWSTR StringString(IN PCWSTR String, IN PCWSTR SubString);
LPWSTR _lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);
PWSTR NormalizeArcPath(IN PWSTR Path);
PWSTR DevicePathToArcPath(IN PWSTR NtPath, BOOL fFindSecond);
PWSTR GetSystemRootDevicePath();

VOID DnConcatenatePaths(IN OUT PTSTR Path1, IN     PTSTR Path2, IN     DWORD BufferSizeChars);

// Function proto-types     (X86)
TCHAR   GetX86SystemPartition();
VOID    InitializeBootKeysForIntel();
VOID    WriteBackBootKeysForIntel();

// Function proto-types     (non-intel)
BOOL    InitializeNVRAMForNonIntel();
BOOL    FModifyStartOptionsNVRAM(TCHAR *pszStartOptions, NTDS_BOOTOPT_MODTYPE Modification );
VOID    WriteBackNVRAMForNonIntel( NTDS_BOOTOPT_MODTYPE Modification );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\clntutl\inc\helper.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       helper.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : helper.h
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 9/17/1996
*    Description : common declarations
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef HELPER_H
#define HELPER_H

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#endif


#ifdef __cplusplus
extern "C" {
#endif
// include //
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include <windows.h>
#include <string.h>
#include <assert.h>
#include <stdio.h>
#include <tchar.h>
// #include <crtdbg.h>


// defines //
// convinience
/**
#ifndef SZ
#define SZ x  PCHAR x[]
#endif
**/
#ifndef _T
#define _T(x)  _TEXT(x)
#endif


// defaults
#define MAXSTR			   1024
#define MAXLIST            256
#define MAX_TINY_LIST      32


//
// Debugging flags
//

#define DBG_0			         0x0         // no debug
#define DBG_MEM   	             0x00000001
#define DBG_FLOW		         0x00000002
#define DBG_ERROR                0x00000004
#define DBG_WARN                 0x00000008
#define DBG_ALWAYS	             0xffffffff  // always out






// prototypes //

#ifdef __cplusplus
extern "C" {
#endif
// global variables //
extern DWORD g_dwDebugLevel;    // debug print level



extern void dprintf(DWORD dwLevel, LPCTSTR lpszFormat, ...);
extern void fatal(LPCTSTR msg);


#ifdef __cplusplus
}
#endif


#endif

/******************* EOF *********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\bootopt\lib\common.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    utils.c

Abstract:

    This module implements helper functions for the bootopt library.

Author:

    R.S. Raghavan (rsraghav)

Revision History:

    Created             10/07/96    rsraghav

--*/

#include "common.h"

WCHAR ArcNameDirectory[] = L"\\ArcName";

//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )


PTSTR
DupString(
    IN PTSTR String
    )
{
    PTSTR p;

    p = MALLOC((lstrlen(String)+1)*sizeof(TCHAR));
    if (p == NULL) {
        return NULL;
    }
    lstrcpy(p,String);
    return(p);
}

VOID
DnConcatenatePaths(
    IN OUT PTSTR Path1,
    IN     PTSTR Path2,
    IN     DWORD BufferSizeChars
    )
{
    BOOL NeedBackslash = TRUE;
    DWORD l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(*Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(l+lstrlen(Path2) < BufferSizeChars) {
        lstrcat(Path1,Path2);
    }
}

PWSTR
StringUpperN(
    IN OUT PWSTR    p,
    IN     unsigned n
    )
{
    unsigned u;

    for(u=0; u<n; u++) {
        p[u] = (WCHAR)CharUpperW((PWCHAR)p[u]);
    }

    return(p);
}

PCWSTR
StringString(
    IN PCWSTR String,
    IN PCWSTR SubString
    )
{
    int l1,l2,x,i;

    l1 = lstrlen(String);
    l2 = lstrlen(SubString);
    x = l1-l2;

    for(i=0; i<=x; i++) {
        if(!memcmp(String+i,SubString,l2*sizeof(TCHAR))) {
            return(String+i);
        }
    }

    return(NULL);
}

LPWSTR
_lstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    )
{
    LPWSTR src,dst;

    src = (LPWSTR)lpString2;
    dst = lpString1;

    if(iMaxLength) {
        while(iMaxLength && *src) {
            *dst++ = *src++;
            iMaxLength--;
        }
        if(iMaxLength) {
            *dst = '\0';
        } else {
            dst--;
            *dst = '\0';
        }
    }
    return lpString1;
}

PWSTR
NormalizeArcPath(
    IN PWSTR Path
    )

/*++

Routine Description:

    Transform an ARC path into one with no sets of empty parenthesis
    (ie, transforom all instances of () to (0).).

    The returned path will be all lowercase.

Arguments:

    Path - ARC path to be normalized.

Return Value:

    Pointer to buffer containing normalized path.
    Caller must free this buffer with FREE().

--*/

{
    PWSTR p,q,r;
    PWSTR NormalizedPath, NewPath;

    NormalizedPath = MALLOC((lstrlen(Path)+100)*sizeof(WCHAR));
    if (NormalizedPath == NULL) {
        return NULL;
    }
    ZeroMemory(NormalizedPath,(lstrlen(Path)+100)*sizeof(WCHAR));

    for(p=Path; q=(PWSTR)StringString(p,L"()"); p=q+2) {

        r = NormalizedPath + lstrlen(NormalizedPath);
        _lstrcpynW(r,p,(INT)((q-p)+1));
        lstrcat(NormalizedPath,L"(0)");
    }
    lstrcat(NormalizedPath,p);

    // Resize buffer to free up unused space

    NewPath = REALLOC(NormalizedPath,(lstrlen(NormalizedPath)+1)*sizeof(WCHAR));

    // If success, return new block, otherwise return old block
    if (NewPath) {
        NormalizedPath = NewPath;
    }

    return(NormalizedPath);
}

PWSTR GetSystemRootDevicePath()
{
    TCHAR szSystemRoot[MAX_BOOT_PATH_LEN];
    PWSTR pstrSystemDir = NULL;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ObjectHandle;
    NTSTATUS Status;
    PWSTR pstrDevicePath = NULL;
    PWSTR pstrDirStart = NULL;

    GetEnvironmentVariable(L"SystemRoot", szSystemRoot, MAX_BOOT_PATH_LEN);

    pstrSystemDir = wcschr(szSystemRoot, TEXT(':'));
    if (pstrSystemDir)
        pstrSystemDir++;    // now it points to directory part of the systemroot.
    _wcslwr(pstrSystemDir); // lowercase version of the system root env variable

    // Open \SystemRoot symbolic link object
    RtlInitUnicodeString(&UnicodeString, L"\\SystemRoot");
    InitializeObjectAttributes(&Obja, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
    Status = NtOpenSymbolicLinkObject(&ObjectHandle, READ_CONTROL | SYMBOLIC_LINK_QUERY, &Obja);
    if (NT_SUCCESS(Status))
    {
        // allocate memory for the DevicePath
        pstrDevicePath = MALLOC(MAX_PATH * sizeof(WCHAR));
        if (pstrDevicePath)
        {
            UnicodeString.Buffer = pstrDevicePath;
            UnicodeString.Length = 0;
            UnicodeString.MaximumLength = (MAX_PATH * sizeof(WCHAR));

            RtlZeroMemory(pstrDevicePath, UnicodeString.MaximumLength);

            Status = NtQuerySymbolicLinkObject(ObjectHandle, &UnicodeString, NULL);
            if (NT_SUCCESS(Status))
            {
                // pstrDevicePath points to the DevicePath with directory extension.
                // truncate the directory extension

                _wcslwr(pstrDevicePath); // lowercase version of the device path

                pstrDirStart = wcsstr(pstrDevicePath, pstrSystemDir);
                if (pstrDirStart)
                    *pstrDirStart = TEXT('\0');
            }
            else
            {
                // NtQuerySymbolicLinkObject() failed
                FREE(pstrDevicePath);
                pstrDevicePath = NULL;
            }
        }

        NtClose(ObjectHandle);
    }
    
    return pstrDevicePath;
}

PWSTR
DevicePathToArcPath(
    IN PWSTR NtPath,
    BOOL fFindSecond
    )
{
    UNICODE_STRING UnicodeString;
    HANDLE DirectoryHandle;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    BOOLEAN RestartScan;
    DWORD Context;
    BOOL MoreEntries;
    PWSTR ArcName;
    UCHAR Buffer[1024];
    POBJECT_DIRECTORY_INFORMATION DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;
    PWSTR ArcPath;
    BOOL fFoundFirst = FALSE;

    //
    // Assume failure.
    //
    ArcPath = NULL;

    //
    // Open the \ArcName directory.
    //
    INIT_OBJA(&Obja,&UnicodeString,ArcNameDirectory);

    Status = NtOpenDirectoryObject(&DirectoryHandle,DIRECTORY_QUERY,&Obja);

    if(NT_SUCCESS(Status)) {

        RestartScan = TRUE;
        Context = 0;
        MoreEntries = TRUE;

        do {

            Status = NtQueryDirectoryObject(
                        DirectoryHandle,
                        Buffer,
                        sizeof(Buffer),
                        TRUE,           // return single entry
                        RestartScan,
                        &Context,
                        NULL            // return length
                        );

            if(NT_SUCCESS(Status)) {

                CharLower(DirInfo->Name.Buffer);

                //
                // Make sure this name is a symbolic link.
                //
                if(DirInfo->Name.Length
                && (DirInfo->TypeName.Length >= 24)
                && StringUpperN((PWSTR)DirInfo->TypeName.Buffer,12)
                && !memcmp(DirInfo->TypeName.Buffer,L"SYMBOLICLINK",24))
                {
                    ArcName = MALLOC(DirInfo->Name.Length + sizeof(ArcNameDirectory) + sizeof(WCHAR));

                    if (ArcName == NULL) {
                        ArcPath = NULL;
                        break;
                    }
                    lstrcpy(ArcName,ArcNameDirectory);
                    DnConcatenatePaths(ArcName,DirInfo->Name.Buffer,(DWORD)(-1));

                    //
                    // We have the entire arc name in ArcName.  Now open it as a symbolic link.
                    //
                    INIT_OBJA(&Obja,&UnicodeString,ArcName);

                    Status = NtOpenSymbolicLinkObject(
                                &ObjectHandle,
                                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                &Obja
                                );

                    if(NT_SUCCESS(Status)) {

                        //
                        // Finally, query the object to get the link target.
                        //
                        UnicodeString.Buffer = (PWSTR)Buffer;
                        UnicodeString.Length = 0;
                        UnicodeString.MaximumLength = sizeof(Buffer);

                        Status = NtQuerySymbolicLinkObject(
                                    ObjectHandle,
                                    &UnicodeString,
                                    NULL
                                    );

                        if(NT_SUCCESS(Status)) {

                            //
                            // nul-terminate the returned string
                            //
                            UnicodeString.Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

                            if(!lstrcmpi(UnicodeString.Buffer,NtPath)) {

                                ArcPath = ArcName
                                        + (sizeof(ArcNameDirectory)/sizeof(WCHAR));

                                if (fFindSecond && !fFoundFirst)
                                {   // We are requested to find the second match and this is the first match
                                    // skip this match and continue to look for a second match
                                    fFoundFirst = TRUE;
                                    ArcPath = NULL;
                                }
                            }
                        }

                        NtClose(ObjectHandle);
                    }

                    if(!ArcPath) {
                        FREE(ArcName);
                    }
                }

            } else {

                MoreEntries = FALSE;
                if(Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                }
            }

            RestartScan = FALSE;

        } while(MoreEntries && !ArcPath);

        NtClose(DirectoryHandle);
    }

    //
    // ArcPath points into thje middle of a buffer.
    // The caller needs to be able to free it, so place it in its
    // own buffer here.
    //
    if(ArcPath) {
        ArcPath = DupString(ArcPath);
        FREE(ArcName);
    }

    return(ArcPath);
}

/*************************************************************************************
Routine Description:

    Displays a message box to indicate that there has been a memory allocation error.

Arguments:

Return Value:

**************************************************************************************/
void  ErrMemDlg()
{
    KdPrint(("NTDSETUP: Insufficient memory to continue\n"));
}


/*************************************************************************************
Routine Description:

    Allocates memory and fatal errors if none is available.

Arguments:

    cb - number of bytes to allocate

Return Value:

    Pointer to memory.

**************************************************************************************/

PVOID   Malloc(IN DWORD cb)
{
    PVOID p;

    if (((p = (PVOID) malloc(cb)) == NULL) && (cb != 0))
    {
        ErrMemDlg();
    }

    if ( p )
    {
        RtlZeroMemory( p, cb );
    }

    return(p);
}


/*************************************************************************************
Routine Description:

    Reallocates a block of memory previously allocated with Malloc();
    fatal error if no memory available.

Arguments:

    pv - pointer to the block of memory to be resized
    cb - number of bytes to allocate

Return Value:

    Pointer to memory.

**************************************************************************************/

PVOID   Realloc(IN PVOID pv, IN DWORD cbNew)
{
    PVOID p;

    if (((p = realloc(pv,cbNew)) == NULL) && (cbNew != 0))
    {
        ErrMemDlg();
    }

    return (p);
}

/*************************************************************************************
Routine Description:

    Free a block of memory previously allocated with Malloc().
    Sets the pointer to NULL.

Arguments:

    ppv - pointer to the pointer to the block to be freed.

Return Value:

    none.

**************************************************************************************/

VOID    Free(IN OUT PVOID *ppv)
{
    if (*ppv)
        free(*ppv);

    *ppv = NULL;
}


DWORD NtdspModifyDsRepairBootOption( NTDS_BOOTOPT_MODTYPE Modification )
{

#ifdef _X86_
    InitializeBootKeysForIntel();
    if (FModifyStartOptionsToBootKey(L" /debug /safeboot:DSREPAIR", Modification))
    {
        // We have really added a new key - write back to the system
        WriteBackBootKeysForIntel();
    }
#else
    if (InitializeNVRAMForNonIntel())
    {
        if (FModifyStartOptionsNVRAM(L"/debug /safeboot:DSREPAIR", Modification ))
        {
            WriteBackNVRAMForNonIntel( Modification );
        }
    }
#endif
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\bootopt\lib\nonintel.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    nonintel.c

Abstract:

    This module implements functions to deal with NVRAM for non-intel platforms.

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created             10/07/96    rsraghav
    
    Colin Brace  (ColinBr)  05/12/97
        Improved error handling

--*/

// Include files
#include "common.h"

#define SIZECHARS(buffer)   (sizeof(buffer)/sizeof(TCHAR))

// nv-ram stuff
typedef enum {
    BootVarSystemPartition = 0,
    BootVarOsLoader,
    BootVarOsLoadPartition,
    BootVarOsLoadFilename,
    BootVarLoadIdentifier,
    BootVarOsLoadOptions,
    BootVarMax
} BOOT_VARS;

PWSTR BootVarNames[BootVarMax] = { L"SYSTEMPARTITION",
                                   L"OSLOADER",
                                   L"OSLOADPARTITION",
                                   L"OSLOADFILENAME",
                                   L"LOADIDENTIFIER",
                                   L"OSLOADOPTIONS"
                                 };

PWSTR BootVarValues[BootVarMax];
DWORD BootVarComponentCount[BootVarMax];
PWSTR *BootVarComponents[BootVarMax];
DWORD LargestComponentCount;

PWSTR NewBootVarValues[BootVarMax];

PWSTR pstrArcPath;
PWSTR pstrLoadFilePath;
PWSTR pstrNewStartOption;
DWORD bootMarker = 0;


ULONG *SaveEntry;

WCHAR Buffer[4096];

#define OLD_SAMUSEREG_OPTION_NONINTEL   L"SAMUSEREG"
#define OLD_SAMUSEREG_OPTION_NONINTEL_2 L"/DEBUG /SAMUSEREG"
#define OLD_SAMUSEREG_OPTION_NONINTEL_3 L"/DEBUG /SAMUSEDS"
#define OLD_SAMUSEREG_OPTION_NONINTEL_4 L"/DEBUG /SAFEMODE"

BOOL  fFixedExisting = FALSE;

BOOL
EnablePrivilege(
    IN PTSTR PrivilegeName,
    IN BOOL  Enable
    )
{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(GetLastError() == ERROR_CALL_NOT_IMPLEMENTED);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    //
    // AdjustTokenPrivileges always returns TRUE; the real info is
    // in the LastError
    //

    if (ERROR_SUCCESS == GetLastError()) {
        b = TRUE;
    } else {
        KdPrint(("NTDSETUP: Unable to AdjustTokenPriviledges, error %d\n", GetLastError()));
        b = FALSE;
    }

    return(b);
}


BOOL
SetNvRamVar(
    IN PWSTR VarName,
    IN PWSTR VarValue
    )
{
    UNICODE_STRING U1,U2;

    RtlInitUnicodeString(&U1,VarName);
    RtlInitUnicodeString(&U2,VarValue);

    return(NT_SUCCESS(NtSetSystemEnvironmentValue(&U1,&U2)));
}


VOID
GetVarComponents(
    IN  PWSTR    VarValue,
    OUT PWSTR  **Components,
    OUT PDWORD   ComponentCount
    )
{
    PWSTR *components;
    DWORD componentCount;
    PWSTR p;
    PWSTR Var;
    PWSTR comp;
    DWORD len;
    DWORD dwCurrentMax = INITIAL_KEY_COUNT;


    components = MALLOC(dwCurrentMax * sizeof(PWSTR));
    if (!components)
    {
        *Components = NULL;
        *ComponentCount = 0;
        return;
    }
    

    for(Var=VarValue,componentCount=0; *Var; ) {

        //
        // Skip leading spaces.
        //
        while((*Var == L' ') || (*Var == L'\t')) {
            Var++;
        }

        if(*Var == 0) {
            break;
        }

        p = Var;

        while(*p && (*p != L';')) {
            p++;
        }

        len = (DWORD)((PUCHAR)p - (PUCHAR)Var);

        comp = MALLOC(len + sizeof(WCHAR));

        len /= sizeof(WCHAR);

        _lstrcpynW(comp,Var,len+1);

        components[componentCount] = NormalizeArcPath(comp);

        FREE(comp);

        componentCount++;

        if(componentCount == dwCurrentMax) 
        {
            dwCurrentMax += DEFAULT_KEY_INCREMENT;
            components = REALLOC(components, dwCurrentMax * sizeof(PWSTR));
            if (!components)
            {
                *Components = NULL;
                *ComponentCount = 0;
                return;
            }
        }

        Var = p;
        if(*Var) {
            Var++;      // skip ;
        }
    }

    *Components = REALLOC(components,componentCount*sizeof(PWSTR));
    *ComponentCount = (*Components) ? componentCount : 0;
}

BOOL
InitializeNVRAMForNonIntel()
{
    DWORD var;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG i;

    //
    // Get relevent boot vars.
    //
    // Enable privilege 
    //
    if(!EnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE)) {
        KdPrint(("NTDSETUP: EnablePrivilege failed, error %d\n", GetLastError()));
    } else 
    {

        for(var=0; var<BootVarMax; var++) {

            RtlInitUnicodeString(&UnicodeString,BootVarNames[var]);

            Status = NtQuerySystemEnvironmentValue(
                        &UnicodeString,
                        Buffer,
                        SIZECHARS(Buffer),
                        NULL
                        );

            if(NT_SUCCESS(Status)) {
                BootVarValues[var] = DupString(Buffer);
            } else {
                //
                // Error out
                //
                KdPrint(("NTDSETUP: NtQuerySystemEnvironmentValue failed with 0x%x\n", Status));
                return FALSE;
            }

            GetVarComponents(
                BootVarValues[var],
                &BootVarComponents[var],
                &BootVarComponentCount[var]
                );

            //
            // Track the variable with the most number of components.
            //
            if(BootVarComponentCount[var] > LargestComponentCount) {
                LargestComponentCount = BootVarComponentCount[var];
            }
        }
    }

    //
    // Allocate space the record of whether entries should be saved
    //
    SaveEntry = ( PULONG ) MALLOC( LargestComponentCount * sizeof(ULONG ) );
    if ( !SaveEntry )
    {
        return FALSE;
    }

    for ( i = 0; i < LargestComponentCount; i++ )
    {
        SaveEntry[i] = TRUE;
    }

    return TRUE;

}

BOOL 
FModifyStartOptionsNVRAM(
    IN TCHAR *pszStartOptions, 
    IN NTDS_BOOTOPT_MODTYPE Modification
    )
{
    TCHAR szSystemRoot[MAX_BOOT_PATH_LEN];
    TCHAR szDriveName[MAX_DRIVE_NAME_LEN];
    DWORD i, j;
    DWORD cMaxIterations;
    PWSTR pstrSystemRootDevicePath = NULL;
    BOOL  fRemovedAtLeastOneEntry = FALSE;

    if (!pszStartOptions)
    {
        KdPrint(("NTDSETUP: Unable to add the start option\n"));
        return FALSE;
    }

    GetEnvironmentVariable(L"SystemDrive", szDriveName, MAX_DRIVE_NAME_LEN);
    GetEnvironmentVariable(L"SystemRoot", szSystemRoot, MAX_BOOT_PATH_LEN);

    pstrSystemRootDevicePath = GetSystemRootDevicePath();
    if (!pstrSystemRootDevicePath)
        return FALSE;
    else
    {
        pstrArcPath      = DevicePathToArcPath(pstrSystemRootDevicePath, FALSE);
        FREE(pstrSystemRootDevicePath);
    }

    if (!pstrArcPath)
    {
        KdPrint(("NTDSETUP: Unable to add the start option\n"));
        return FALSE;
    }

    // point pstrLoadFilePath to the first letter after <drive>:
    pstrLoadFilePath = wcschr(szSystemRoot, TEXT(':'));
    if (!pstrLoadFilePath)
    {
        KdPrint(("NTDSETUP: Unable to add the start option\n"));
        return FALSE;
    }
    pstrLoadFilePath++;

    // check to see if there is already a corresponding entry which has the same start option
    // also keep track of the marker corresponding to the current boot partion/loadfile combination
    cMaxIterations = min(BootVarComponentCount[BootVarOsLoadPartition],BootVarComponentCount[BootVarOsLoadFilename]);
    for (i = 0; i <  cMaxIterations; i++)
    {
        if (!lstrcmpi(pstrArcPath, BootVarComponents[BootVarOsLoadPartition][i]) && 
            !lstrcmpi(pstrLoadFilePath, BootVarComponents[BootVarOsLoadFilename][i]))
        {
            bootMarker = i;

            if (i >= BootVarComponentCount[BootVarOsLoadOptions])
            {
                // no start options available for this combo
                continue;
            }

            // Now check if the given start option already exists at this marker        - if so, no need to add a new one
            if (!lstrcmpi(pszStartOptions, BootVarComponents[BootVarOsLoadOptions][i]))
            {
                if ( Modification == eRemoveBootOption )
                {
                    SaveEntry[ i ] = FALSE;
                    fRemovedAtLeastOneEntry = TRUE;
                }
                else
                {
                    ASSERT( Modification == eAddBootOption );

                    return FALSE;
                }

            }
            else if (!lstrcmpi(OLD_SAMUSEREG_OPTION_NONINTEL, BootVarComponents[BootVarOsLoadOptions][i]) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_NONINTEL_2, BootVarComponents[BootVarOsLoadOptions][i]) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_NONINTEL_4, BootVarComponents[BootVarOsLoadOptions][i]) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_NONINTEL_3, BootVarComponents[BootVarOsLoadOptions][i]) )
            {

                if ( Modification == eRemoveBootOption )
                {
                    SaveEntry[ i ] = FALSE;
                    fRemovedAtLeastOneEntry = TRUE;
                }
                else
                {

                    ASSERT( Modification == eAddBootOption );

                    // Old samusereg option exists - convert it to the new option and display string
                    FREE(BootVarValues[BootVarLoadIdentifier]);
                    Buffer[0] = TEXT('\0');
                    if (0 == i)
                        lstrcat(Buffer, DISPLAY_STRING_DS_REPAIR);
                    else if (BootVarComponentCount[BootVarLoadIdentifier] > 0)
                        lstrcat(Buffer, BootVarComponents[BootVarLoadIdentifier][0]);
    
                    for (j = 1; j < BootVarComponentCount[BootVarLoadIdentifier]; j++)
                    {
                        lstrcat(Buffer, L";");
                        if (j == i)
                            lstrcat(Buffer, DISPLAY_STRING_DS_REPAIR);
                        else
                            lstrcat(Buffer, BootVarComponents[BootVarLoadIdentifier][j]);
                    }
                    BootVarValues[BootVarLoadIdentifier] = DupString(Buffer);
    
                    FREE(BootVarValues[BootVarOsLoadOptions]);
                    Buffer[0] = TEXT('\0');
                    if (0 == i)
                        lstrcat(Buffer, pszStartOptions);
                    else if (BootVarComponentCount[BootVarOsLoadOptions] > 0)
                        lstrcat(Buffer, BootVarComponents[BootVarOsLoadOptions][0]);
    
                    for (j = 1; j < BootVarComponentCount[BootVarOsLoadOptions]; j++)
                    {
                        lstrcat(Buffer, L";");
                        if (j == i)
                            lstrcat(Buffer, pszStartOptions);
                        else
                            lstrcat(Buffer, BootVarComponents[BootVarOsLoadOptions][j]);
                    }
                    BootVarValues[BootVarOsLoadOptions] = DupString(Buffer);
    
                    fFixedExisting = TRUE;
                    break;
                }
            }
        }
    }

    if ( !fRemovedAtLeastOneEntry && (Modification == eRemoveBootOption) )
    {
        // No changes necessary
        return FALSE;
    }

    // Use the part corresponding to the boot marker as the default value for any component and store the start option for later writing
    pstrNewStartOption = DupString(pszStartOptions);    

    return TRUE;
}

/*****************************************************************************

Routine Description:

    This writes all the boot-related NVRAM variables back to the NVRAM
    space.

Arguments:

    fWriteOriginal - if TRUE, it attempts to write original NVRAM vars 
                                unaltered;
                     if FALSE, it attempst to write the new NVRAM vars

Return Value:

    TRUE, if all the boot-related NVRAM vars are written back successfully
    FALSE, otherwise.

*****************************************************************************/

BOOL FWriteNVRAMVars(BOOL fWriteOriginal) 
{
    // set new system partition
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarSystemPartition], BootVarComponents[BootVarSystemPartition][bootMarker]);
    if (!SetNvRamVar(BootVarNames[BootVarSystemPartition], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarSystemPartition] : Buffer))
        return FALSE;

    // set new os loader
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarOsLoader], BootVarComponents[BootVarOsLoader][bootMarker]);
    if (!SetNvRamVar(BootVarNames[BootVarOsLoader], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarOsLoader] : Buffer))
        return FALSE;

    // set new Load Partition
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarOsLoadPartition], pstrArcPath);
    if (!SetNvRamVar(BootVarNames[BootVarOsLoadPartition], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarOsLoadPartition] : Buffer))
        return FALSE;

    // set new Load File Name
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarOsLoadFilename], pstrLoadFilePath);
    if (!SetNvRamVar(BootVarNames[BootVarOsLoadFilename], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarOsLoadFilename] : Buffer))
        return FALSE;

    // set new Load Identifier
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarLoadIdentifier], DISPLAY_STRING_DS_REPAIR);
    if (!SetNvRamVar(BootVarNames[BootVarLoadIdentifier], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarLoadIdentifier] : Buffer))
        return FALSE;

    // set new Load Option
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarOsLoadOptions], pstrNewStartOption);
    if (!SetNvRamVar(BootVarNames[BootVarOsLoadOptions], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarOsLoadOptions] : Buffer))
        return FALSE;

    return TRUE;
}

BOOL
FRemoveLoadEntries(
    VOID
    )
/*++

Description:

    This routine copies all of the boot entries from the original buffers into 
    new buffers except for the entries marked as "don't keep" from the
    SaveEntry[] array.

Parameters:

    None

Return Values:

    TRUE is successful.

--*/
{

    ULONG iComponent, iBootVar, Size;

    for ( iBootVar = 0 ; iBootVar < BootVarMax; iBootVar++ )
    {
        Size = 0;

        for ( iComponent = 0; iComponent < BootVarComponentCount[iBootVar]; iComponent++ )
        {
            // +1 for the ";"
            Size += (wcslen(BootVarComponents[iBootVar][iComponent]) + 1) * sizeof(WCHAR);
        }

        // +1 for the null terminator
        Size += 1;

        NewBootVarValues[ iBootVar ] = (PWSTR) MALLOC( Size );
        if ( !NewBootVarValues[ iBootVar ] )
        {
            return FALSE;
        }

    }

    for ( iComponent = 0; iComponent < LargestComponentCount; iComponent++ )
    {
        if ( SaveEntry[ iComponent ] )
        {           
            for ( iBootVar = 0 ; iBootVar < BootVarMax; iBootVar++ )
            {
                if ( iComponent < BootVarComponentCount[iBootVar] )
                {
                    if ( iComponent > 0 )
                    {
                        wcscat( NewBootVarValues[iBootVar], L";" );
                    }

                    if ( BootVarComponents[iBootVar][iComponent] )
                    {
                        wcscat( NewBootVarValues[iBootVar], BootVarComponents[iBootVar][iComponent] );
                    }
                }
            }
        }
    }

    return TRUE;
}

BOOL
FWriteSmallerNVRAMVars(
    BOOL fWriteOriginal
    )
/*++

Description:

Parameters:

Return Values:

--*/
{
    ULONG iBootVar;
    int Status;

    for ( iBootVar = 0 ; iBootVar < BootVarMax; iBootVar++ )
    {
        Status = SetNvRamVar( BootVarNames[ iBootVar ],
                                (fWriteOriginal) ? BootVarValues[ iBootVar ] 
                                    : NewBootVarValues[ iBootVar ] );

        if ( !Status )
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*****************************************************************************

Routine Description:

    This writes attempts to write the modified boot variables to 
    NVRAM space. If the attempt failed, it attempts write the original
    boot variables back to NVRAM space. Puts out an appropriate error
    message box on failure.

Arguments:

    None.

Return Value:

    None.
*****************************************************************************/

VOID WriteBackNVRAMForNonIntel( NTDS_BOOTOPT_MODTYPE Modification )
{

    if ( Modification == eRemoveBootOption )
    {

        //
        // Create new (smaller) buffers
        //
        if ( FRemoveLoadEntries() )
        {
            // First attempt to write the modified NVRAM vars
            if (!FWriteSmallerNVRAMVars(FALSE))
            {
                // Writing to NVRAM failed - attempt to write the original NVRAM back
                if (!FWriteSmallerNVRAMVars(TRUE))
                {

                    KdPrint(("NTDSETUP: Unable to add a Directory Service Repair boot option to NVRAM - \
                            Final entry in the boot list might be invalid!\n")); 
                }
                else
                {
                    // Unable to modify NVRAM - but old NVRAM is reverted back
                    KdPrint(("NTDSETUP: Unable to remove a Directory Service Repair boot option to NVRAM\n"));
                }
            }
        }
        else
        {
            KdPrint(("NTDSETUP: Unable to remove the Directory Service Repair boot option to NVRAM\n" ));
        }

    }
    else
    {
        ASSERT( Modification == eAddBootOption );

        // First attempt to write the modified NVRAM vars
        if (!FWriteNVRAMVars(FALSE))
        {
            // Writing to NVRAM failed - attempt to write the original NVRAM back
            if (!FWriteNVRAMVars(TRUE))
            {
                KdPrint(("NTDSETUP: Unable to add a Directory Service Repair boot option to NVRAM - \
                        Final entry in the boot list might be invalid!\n")); 
            }
            else
            {
                // Unable to modify NVRAM - but old NVRAM is reverted back
                KdPrint(("NTDSETUP: Unable to add a Directory Service Repair boot option to NVRAM\n"));
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\bootopt\lib\intel.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    intel.c

Abstract:

    This module implements functions to detect the system partition drive and
    providing extra options in boot.ini for NTDS setup on intel platform.

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created             10/07/96    rsraghav

--*/

// Include files
#include "common.h"

#define MAX_KEY_LEN (MAX_BOOT_PATH_LEN + MAX_BOOT_DISPLAY_LEN + MAX_BOOT_START_OPTIONS_LEN + 5) // 5 -> =,",",sp,null
#define MAX_KEY_VALUE_LEN (MAX_BOOT_DISPLAY_LEN + MAX_BOOT_START_OPTIONS_LEN + 1)

#define INITIAL_OSSECTION_SIZE      (2048)
#define DEFAULT_OSSECTION_INCREMENT (1024)


// used to eliminate old option in boot.ini
#define OLD_SAMUSEREG_OPTION    L" /SAMUSEREG"
#define OLD_SAMUSEREG_OPTION_2  L" /DEBUG /SAMUSEREG"
#define OLD_SAMUSEREG_OPTION_3  L" /DEBUG /SAMUSEDS"
#define OLD_SAMUSEREG_OPTION_4  L" /DEBUG /SAFEMODE"


//  BOOT_KEY    - structure representing a complete boot option with the arc path, display string, and start options
typedef  struct _BOOT_KEY
{
    TCHAR       szPath[MAX_BOOT_PATH_LEN];
    TCHAR       szDisplay[MAX_BOOT_DISPLAY_LEN];
    TCHAR       szStartOptions[MAX_BOOT_START_OPTIONS_LEN];
    BOOLEAN     fWriteBack;
} BOOT_KEY;

BOOT_KEY        *BootKey = NULL;
DWORD           cBootKeys = 0;
DWORD           cMaxBootKeys = 0;

TCHAR           *szOSSection = NULL;
DWORD           cchOSSection = 0;

// Constants used for boot.ini parsing
TCHAR szBootIni[]     = TEXT("?:\\boot.ini");
TCHAR szOS[]          = TEXT("operating systems");


BOOL GetPartitionInfo(
    IN  TCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    )
{
    TCHAR DriveName[] = TEXT("\\\\.\\?:");
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;

    DriveName[4] = Drive;

    hDisk = CreateFile (
                DriveName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if (hDisk == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    b = DeviceIoControl (
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &DataSize,
            NULL
            );

    CloseHandle (hDisk);

    return (b);
}



UINT MyGetDriveType (IN TCHAR Drive)
{
    TCHAR DriveNameNt[] = TEXT("\\\\.\\?:");
    TCHAR DriveName[] = TEXT("?:\\");
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type.  If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk.  Otherwise
    // just believe the api.
    //
    //
    DriveName[0] = Drive;

    if ((rc = GetDriveType (DriveName)) == DRIVE_REMOVABLE) {

        DriveNameNt[4] = Drive;

        hDisk = CreateFile (
                    DriveNameNt,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

        if (hDisk != INVALID_HANDLE_VALUE)
        {
            b = DeviceIoControl (
                    hDisk,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,
                    &MediaInfo,
                    sizeof(MediaInfo),
                    &DataSize,
                    NULL
                    );

            //
            // It's really a hard disk if the media type is removable.
            //
            if (b && (MediaInfo.MediaType == RemovableMedia))
            {
                rc = DRIVE_FIXED;
            }

            CloseHandle (hDisk);
        }
    }

    return(rc);
}


PWSTR ArcPathToNtPath (IN PWSTR ArcPath)
{
    NTSTATUS Status;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    UCHAR Buffer[1024];
    PWSTR arcPath = NULL;
    PWSTR ntPath = NULL;

    //
    // Assume failure
    //
    ntPath = NULL;

    arcPath = MALLOC(((wcslen(ArcPath)+1)*sizeof(WCHAR)) + sizeof(L"\\ArcName"));
    if (NULL == arcPath)
    {
        goto Error;
    }
    wcscpy (arcPath, L"\\ArcName\\");
    wcscat (arcPath, ArcPath);

    RtlInitUnicodeString (&UnicodeString, arcPath);

    InitializeObjectAttributes (
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenSymbolicLinkObject (
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if (NT_SUCCESS(Status))
    {
        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = (PWSTR)Buffer;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = sizeof(Buffer);

        Status = NtQuerySymbolicLinkObject (
                    ObjectHandle,
                    &UnicodeString,
                    NULL
                    );

        if (NT_SUCCESS(Status))
        {
            ntPath = MALLOC(UnicodeString.Length+sizeof(WCHAR));
            
            if (NULL == ntPath)
            {
                goto Error;
            }

            CopyMemory(ntPath,UnicodeString.Buffer,UnicodeString.Length);

            ntPath[UnicodeString.Length/sizeof(WCHAR)] = 0;
        }

        NtClose (ObjectHandle);
    }

Error:

    if (arcPath)
    {
        FREE (arcPath);
    }

    return (ntPath);
}

BOOL AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN WCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    unsigned i;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

    PTSTR BootFiles[] = { TEXT("BOOT.INI"),
                          TEXT("NTLDR"),
                          TEXT("NTDETECT.COM"),
                          NULL
                        };

    TCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if (!GetPartitionInfo((TCHAR)Drive,&PartitionInfo))
    {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;

    for (i=0; i<min(DriveLayout->PartitionCount,4); i++)
    {
        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
          && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
          && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart))
        {
            IsPrimary = TRUE;
            break;
        }
    }

    if (!IsPrimary)
    {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be
    // accurate (like user is using os/2 boot manager, for example).
    //

    //
    // See whether an nt boot files are present on this drive.
    //
    for (i=0; BootFiles[i]; i++)
    {
        wsprintf (FileName, TEXT("%wc:\\%s"), Drive, BootFiles[i]);

        FindHandle = FindFirstFile (FileName, &FindData);

        if (FindHandle == INVALID_HANDLE_VALUE)
        {
            return (FALSE);
        }
        else
        {
            FindClose (FindHandle);
        }
    }

    return (TRUE);
}

/*************************************************************************************

Routine Description:

    Determine the system partition on x86 machines.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    The one thing we can be sure of is that the system partition is on
    the physical hard disk with the arc path multi(0)disk(0)rdisk(0).
    We can be sure of this because by definition this is the arc path
    for bios drive 0x80.

    This routine determines which drive letters represent drives on
    that physical hard drive, and checks each for the nt boot files.
    The first drive found with those files is assumed to be the system
    partition.

    If for some reason we cannot determine the system partition by the above
    method, we simply assume it's C:.

Arguments:

Return Value:

    Drive letter of system partition.

**************************************************************************************/

TCHAR GetX86SystemPartition()
{
    BOOL  GotIt;
    PWSTR NtDevicePath = NULL;
    WCHAR Drive = L'\0';
    WCHAR DriveName[3];
    WCHAR Buffer[512];
    DWORD NtDevicePathLen;
    PWSTR p;
    DWORD PhysicalDriveNumber;
    HANDLE hDisk;
    BOOL  b =FALSE;
    DWORD DataSize;
    PVOID DriveLayout = NULL;
    DWORD DriveLayoutSize;

    DriveName[1] = L':';
    DriveName[2] = 0;

    GotIt = FALSE;

    //
    // The system partition must be on multi(0)disk(0)rdisk(0)
    //
    if (NtDevicePath = ArcPathToNtPath (L"multi(0)disk(0)rdisk(0)"))
    {
        //
        // The arc path for a disk device is usually linked
        // to partition0.  Get rid of the partition part of the name.
        //
        CharLowerW (NtDevicePath);

        if (p = wcsstr (NtDevicePath, L"\\partition"))
        {
            *p = 0;
        }

        NtDevicePathLen = lstrlenW (NtDevicePath);

        //
        // Determine the physical drive number of this drive.
        // If the name is not of the form \device\harddiskx then
        // something is very wrong.
        //
        if (!wcsncmp (NtDevicePath, L"\\device\\harddisk", 16))
        {
            PhysicalDriveNumber = wcstoul (NtDevicePath+16, NULL, 10);

            wsprintfW (Buffer, L"\\\\.\\PhysicalDrive%u", PhysicalDriveNumber);

            //
            // Get drive layout info for this physical disk.
            //
            hDisk = CreateFileW (
                        Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

            if (hDisk != INVALID_HANDLE_VALUE)
            {
                //
                // Get partition information.
                //
                DriveLayout = MALLOC(1024);
                DriveLayoutSize = 1024;

                do
                {

                    b = DeviceIoControl (
                            hDisk,
                            IOCTL_DISK_GET_DRIVE_LAYOUT,
                            NULL,
                            0,
                            DriveLayout,
                            DriveLayoutSize,
                            &DataSize,
                            NULL
                            );

                    if (!b && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
                    {
                        // DeviceIoControl failed because we have insufficient buffer
                        // => attempt to realloc

                        PVOID pTemp = DriveLayout;

                        DriveLayoutSize += 1024;
                        DriveLayout = REALLOC(DriveLayout,DriveLayoutSize);

                        if (NULL == DriveLayout)
                        {
                            // realloc failed - free the old layout and we will fall out of the loop
                            // automatically.
                            FREE(pTemp);
                        }
                    }
                    else 
                    {
                        // DeviceIoControl was successful or we hit some error other
                        // than insufficient buffer => break out of the loop
                        break;
                    }
                } while (DriveLayout);

                CloseHandle (hDisk);

                if (b)
                {
                    //
                    // The system partition can only be a drive that is on
                    // this disk.  We make this determination by looking at NT drive names
                    // for each drive letter and seeing if the nt equivalent of
                    // multi(0)disk(0)rdisk(0) is a prefix.
                    //
                    for (Drive=L'C'; Drive<=L'Z'; Drive++)
                    {
                        if (MyGetDriveType ((TCHAR)Drive) == DRIVE_FIXED)
                        {
                            DriveName[0] = Drive;

                            if (QueryDosDeviceW (DriveName, Buffer, sizeof(Buffer)/sizeof(WCHAR)))
                            {
                                if (!_wcsnicmp (NtDevicePath, Buffer, NtDevicePathLen))
                                {
                                    //
                                    // Now look to see whether there's an nt boot sector and
                                    // boot files on this drive.
                                    //
                                    if (AppearsToBeSysPart(DriveLayout,Drive))
                                    {
                                        GotIt = TRUE;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                if (DriveLayout)
                {
                    FREE(DriveLayout);
                }
            }
        }

        FREE(NtDevicePath);
    }


    return (GotIt ? (TCHAR)Drive : TEXT('C'));
}


/*************************************************************************************

Routine Description:

    Initializes all the boot keys in BootKey array by parsing boot.ini.


Arguments:

Return Value:

    None.

**************************************************************************************/

VOID InitializeBootKeysForIntel()
{
    DWORD   dwFileAttrSave;
    TCHAR   *pszKey;
    TCHAR   *pszNext;
    TCHAR   *pszDisplay;
    TCHAR   *pszStartOption;

    // First get the System Partition drive so that we can fetch boot.ini from the right place
    szBootIni[0] = GetX86SystemPartition();

    // Save the current file attributes of boot.ini and modify it so that we can write to it
    dwFileAttrSave = GetFileAttributes(szBootIni);
    SetFileAttributes(szBootIni, FILE_ATTRIBUTE_NORMAL);

    // Get the entire OS section from boot.ini
    cchOSSection = INITIAL_OSSECTION_SIZE;
    szOSSection = (TCHAR *) MALLOC(cchOSSection * sizeof(TCHAR));
    if (!szOSSection)
    {
        cchOSSection = 0;
        goto Leave;
    }

    // safe-guard initialization
    szOSSection[0] = TEXT('\0');


    while ( GetPrivateProfileSection(szOS, szOSSection, cchOSSection, szBootIni) == (cchOSSection - 2))
    {
        TCHAR *szOSSectionSave = szOSSection; 

        // szOSSection is not large enough to hold all the data in the section
        cchOSSection += DEFAULT_OSSECTION_INCREMENT;
        szOSSection = (TCHAR *) REALLOC(szOSSection, cchOSSection * sizeof(TCHAR));
        if (!szOSSection)
        {
            FREE(szOSSectionSave);
            cchOSSection = 0;
            goto Leave;
        }
    }

    // We have successfully read the OSSection - proceed to process it

    // Point pszKey to the start of the first string in the OS Section
    pszKey = &szOSSection[0];

    // We are starting with zero Boot Keys
    cBootKeys = 0;

    while (*pszKey != TEXT('\0'))
    {
        // There is at least one more key to add - see if we have enough space & reallocate if needed
        if (!BootKey)
        {
            cMaxBootKeys = INITIAL_KEY_COUNT;
            BootKey = (BOOT_KEY *) MALLOC(cMaxBootKeys * sizeof(BOOT_KEY));
            if (!BootKey)
            {
                cBootKeys = 0;
                cMaxBootKeys = 0;
                goto Leave;
            }
        }
        else if (cBootKeys >= cMaxBootKeys)
        {
            BOOT_KEY *BootKeySave = BootKey;

            cMaxBootKeys += DEFAULT_KEY_INCREMENT;
            BootKey = (BOOT_KEY *) REALLOC(BootKey,cMaxBootKeys * sizeof(BOOT_KEY));
            if (!BootKey)
            {
                FREE(BootKeySave);
                cBootKeys = 0;
                cMaxBootKeys = 0;
                goto Leave;
            }
        }

        // find the start of next string for next iteration (need to save this as we write 
        // into the current string
        pszNext = pszKey + lstrlen(pszKey) + 1;

        // Initialize the components of the current boot option that we are going to process
        BootKey[cBootKeys].szPath[0] = TEXT('\0');
        BootKey[cBootKeys].szDisplay[0] = TEXT('\0');
        BootKey[cBootKeys].szStartOptions[0] = TEXT('\0');
        BootKey[cBootKeys].fWriteBack = TRUE;

        // Locate the '=' marker
        pszDisplay = wcschr(pszKey, TEXT('='));
        if (pszDisplay)
        {
            *pszDisplay = TEXT('\0');
            
            pszDisplay++;

            // now pszDisplay is pointing to the first char in the value part - find the second quote
            pszStartOption = wcschr(pszDisplay, TEXT('"'));
            if (pszStartOption)
                pszStartOption = wcschr(pszStartOption+1, TEXT('"'));

            if (pszStartOption)
                pszStartOption++;

            // Now pszStartOption is pointing the char after the second quote
            if (pszStartOption && *pszStartOption != TEXT('\0'))
            {
                // this key has start options copy the start option first
                lstrcpy(&BootKey[cBootKeys].szStartOptions[0], pszStartOption);

                // put null in the first char of pszStartOption so that we can have null terminated display string 
                *pszStartOption = TEXT('\0');
            }

            // pszDisplay is still pointing to the first char in the value part and the end of display string
            // is null-terminated now
            lstrcpy(&BootKey[cBootKeys].szDisplay[0], pszDisplay);
        }

        // pszKey is still pointing to the first char of path and it is null-terminated at '=' sign if there was
        // an associated value
        lstrcpy(&BootKey[cBootKeys].szPath[0], pszKey);

        // finished processing the current key -  update cBootKeys and go to the next key
        ++cBootKeys;
        pszKey = pszNext;

    }  // while (*pszKey)

Leave:
    
    // Restore the file attributes on boot.ini
    SetFileAttributes(szBootIni, dwFileAttrSave);

}

BOOL
FModifyStartOptionsToBootKey(
    IN TCHAR *pszStartOptions, 
    IN NTDS_BOOTOPT_MODTYPE Modification
    )
{
    TCHAR szSystemRoot[MAX_BOOT_PATH_LEN];
    TCHAR szCurrentFullArcPath[MAX_BOOT_PATH_LEN];
    TCHAR szCurrentFullArcPath2[MAX_BOOT_PATH_LEN];
    TCHAR szDriveName[MAX_DRIVE_NAME_LEN];
    PWSTR pstrArcPath;
    DWORD i;
    BOOL  fFixedExisting = FALSE;
    BOOL  fMatchedFirst = TRUE;
    PWSTR pstrSystemRootDevicePath = NULL;
    BOOL  fRemovedAtLeastOneEntry = FALSE;

    if (!pszStartOptions || !BootKey)
    {
        KdPrint(("NTDSETUP: Unable to add the boot option for safemode boot\n"));

            return FALSE;
    }

    ASSERT( Modification == eAddBootOption || Modification == eRemoveBootOption );

    GetEnvironmentVariable(L"SystemDrive", szDriveName, MAX_DRIVE_NAME_LEN);
    GetEnvironmentVariable(L"SystemRoot", szSystemRoot, MAX_BOOT_PATH_LEN);

    pstrSystemRootDevicePath = GetSystemRootDevicePath();
    if (!pstrSystemRootDevicePath)
        return FALSE;

    pstrArcPath  = DevicePathToArcPath(pstrSystemRootDevicePath, FALSE);

    if (pstrArcPath)
    {
        PWSTR pstrTemp;

        lstrcpy(szCurrentFullArcPath, pstrArcPath);
        FREE(pstrArcPath);

        pstrTemp = wcschr(szSystemRoot, TEXT(':'));
        if (pstrTemp)
            lstrcat(szCurrentFullArcPath, pstrTemp+1);

        // Get a second Full Arc path if one exists
        szCurrentFullArcPath2[0] = TEXT('\0');
        pstrArcPath = DevicePathToArcPath(pstrSystemRootDevicePath, TRUE);
        if (pstrArcPath)
        {
            lstrcpy(szCurrentFullArcPath2, pstrArcPath);
            FREE(pstrArcPath);
            if (pstrTemp)
                lstrcat(szCurrentFullArcPath2, pstrTemp+1);
        }
    }
    else 
    {
        KdPrint(("NTDSETUP: Unable to add the boot option for safemode boot\n"));
            return FALSE;
    }

    if (pstrSystemRootDevicePath)
        FREE(pstrSystemRootDevicePath);

    // szCurrentFullArcPath contains the complete arc path now
    // check to see if there already a corresponding entry which has the same start option
    for (i = 0; i < cBootKeys; i++)
    {
        if (!lstrcmpi(szCurrentFullArcPath, BootKey[i].szPath) || 
            !lstrcmpi(szCurrentFullArcPath2, BootKey[i].szPath) )
        {
            if (!lstrcmpi(pszStartOptions, BootKey[i].szStartOptions))
            {
                // The given start option for the given boot key already exists - no need to add a new one
                if ( Modification == eRemoveBootOption )
                {
                    BootKey[i].fWriteBack = FALSE;
                    fRemovedAtLeastOneEntry = TRUE;
                }
                else
                {
                    ASSERT( Modification == eAddBootOption );
                    return FALSE;
                }

            }
            else if (!lstrcmpi(OLD_SAMUSEREG_OPTION, BootKey[i].szStartOptions) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_2, BootKey[i].szStartOptions) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_4, BootKey[i].szStartOptions) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_3, BootKey[i].szStartOptions))
            {

                if ( Modification == eRemoveBootOption )
                {
                    BootKey[i].fWriteBack = FALSE;
                    fRemovedAtLeastOneEntry = TRUE;
                }
                else
                {
                    // This boot option is the old samusereg option - modify to the new option
                    lstrcpy(BootKey[i].szStartOptions, pszStartOptions);
                    wsprintf(BootKey[i].szDisplay, L"\"%s\"", DISPLAY_STRING_DS_REPAIR);
                    fFixedExisting = TRUE;
                    break;
                }

            }

            // we are going to add a new boot entry - find out which Full Arc Path matched 
            // the current Boot Key' Arc path in boot.ini
            if (lstrcmpi(szCurrentFullArcPath, BootKey[i].szPath))
                fMatchedFirst = FALSE;
        }
    }

    if (!fFixedExisting && (Modification == eAddBootOption) )
    {
        // we need to add the new option - check to see if there is enough space add one more
        if (cBootKeys >= cMaxBootKeys)
        {
            BOOT_KEY *BootKeySave = BootKey;

            cMaxBootKeys += cBootKeys + 1;
            BootKey = (BOOT_KEY *) REALLOC(BootKey,cMaxBootKeys * sizeof(BOOT_KEY));
            if (!BootKey)
            {
                FREE(BootKeySave);

                cBootKeys = 0;
                cMaxBootKeys = 0;
                return FALSE;
            }
        }

        lstrcpy(BootKey[cBootKeys].szPath, fMatchedFirst ? szCurrentFullArcPath : szCurrentFullArcPath2);
        lstrcpy(BootKey[cBootKeys].szStartOptions, pszStartOptions);
        wsprintf(BootKey[cBootKeys].szDisplay, L"\"%s\"", DISPLAY_STRING_DS_REPAIR);
        BootKey[cBootKeys].fWriteBack = TRUE;

        ++cBootKeys;
    }

    if ( !fRemovedAtLeastOneEntry && (Modification == eRemoveBootOption) )
    {
        //
        // No changes necessary
        //
        return FALSE;
    }

    // We really added a new key or modified an existing old key - Success
    return TRUE;
}

VOID WriteBackBootKeysForIntel()
{
    TCHAR *pszCurrent;
    DWORD   dwFileAttrSave;
    DWORD i;
    TCHAR *szOSSectionSave = szOSSection;

    if (!BootKey)
    {
        // no boot keys found (allocation failure or parsing failure) - no point in continuing
        KdPrint(("NTDSETUP: Unable to write OS Section in boot.ini - allocation failed\n"));
        goto cleanup;
    }

    // reallocate szOSSection to hold at least one more line of boot option
    cchOSSection += MAX_KEY_LEN;
    szOSSection = REALLOC(szOSSection, cchOSSection * sizeof(TCHAR));
    if (!szOSSection)
    {
        // allocation failed
        FREE(szOSSectionSave);

        cchOSSection = 0;
        KdPrint(("NTDSETUP: Unable to write OS Section in boot.ini - allocation failed\n"));
        
        goto cleanup;
    }

    pszCurrent = szOSSection;
    for (i = 0; i < cBootKeys; i++)
    {
        int count;

        if ( BootKey[i].fWriteBack )
        {
            count = wsprintf(pszCurrent, L"%s=%s%s", BootKey[i].szPath, BootKey[i].szDisplay, BootKey[i].szStartOptions);
            pszCurrent += (count + 1);    // go past the terminating null
        }

    }

    // add an extra null at the end
    *pszCurrent = TEXT('\0');

    // Save the current file attributes of boot.ini and modify it so that we can write to it
    dwFileAttrSave = GetFileAttributes(szBootIni);
    SetFileAttributes(szBootIni, FILE_ATTRIBUTE_NORMAL);

    if (!WritePrivateProfileSection(szOS, szOSSection, szBootIni))
    {
        KdPrint(("NTDSETUP: Unable to write OS Section in boot.ini - allocation failed\n"));
    }

    // Restore the file attributes on boot.ini
    SetFileAttributes(szBootIni, dwFileAttrSave);

cleanup:


    // Cleanup all allocated buffers
    if (BootKey)
    {
        FREE(BootKey);
        BootKey = NULL;
        cBootKeys = 0;
        cMaxBootKeys = 0;
    }

    if (szOSSection)
    {
        FREE(szOSSection);
        cchOSSection = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\clntutl\src\helper.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       helper.c
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : helper.c
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 9/17/1996
*    Description : common declarations
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef HELPER_C
#define HELPER_C



// include //
#include "helper.h"

// defines //



#ifdef __cplusplus
extern "C" {
#endif
// global variables //
DWORD g_dwDebugLevel=DBG_ERROR|DBG_WARN;




// functions //

/*+++
Function   : dprintf
Description: Debug print function
Parameters : variable args
Return     :
Remarks    : none.
---*/
void dprintf(DWORD dwLevel, LPCTSTR lpszFormat, ...){

#if DBG

	TCHAR szBuff[MAXSTR];
	va_list argList;

	
	if(dwLevel & g_dwDebugLevel){

		va_start(argList, lpszFormat);

		_vstprintf(szBuff, lpszFormat, argList);
		OutputDebugString(szBuff);
		OutputDebugString(_T("\r\n"));


		//
		// done
		//
		va_end(argList);
	}

#endif
}




/*+++
Function   : fatal
Description: fatal abort function
Parameters : debug port message
Return     :
Remarks    : none.
---*/
void fatal(LPCTSTR msg){

   dprintf(DBG_ALWAYS, _T("Fatal abort: %s"), msg);
   ExitProcess(0);
}


#ifdef __cplusplus
}
#endif




#endif

/******************* EOF *********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\clntutl\src\evtlog.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       evtlog.cxx
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : EvtLog.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 3/15/1998
*    Description :
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef EVTLOG_CXX
#define EVTLOG_CXX



// include //
#include "evtlog.hxx"
#include "excpt.hxx"
#include <time.h>
#include <algorithm>
using   namespace std;


// defines //
// defines //
#define VALIDATE(x)     if(!m_bValid) return x
#define INVALIDATE      m_bValid = FALSE

#define EVTLOGSRC       _T("Directory Service")




// types //


// global variables //


// functions //


/*+++
Function   : Constructor
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DsEventLogMgr::DsEventLogMgr(LPCTSTR pSvr_): ThrdMgr(){


   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr constructor\n"));

   InitDefaults();

   //
   // process server name
   //
   if(!pSvr_){
      dprintf(DBG_ERROR, _T("DsEventLogMgr: Invalid server\n"));
      INVALIDATE;
      m_dwLastError = (DWORD)-1;
      return;
   }
   else if (pSvr_[0] == '\\') {
      //
      // got already in UNC format
      //
      m_pUncSvr = new TCHAR[_tcslen(pSvr_)+1];
      if (!m_pUncSvr) {
          dprintf(DBG_ERROR, _T("DsEventLogMgr: Could not allocate memory!\n"));
          INVALIDATE;
          return;
      }
      _tcscpy(m_pUncSvr, pSvr_);
   }
   else{
      //
      // got in just server name. Add \\
      //
      m_pUncSvr = new TCHAR[_tcslen(pSvr_)+1+_tcslen(_T("\\\\"))];
      if (!m_pUncSvr) {
          dprintf(DBG_ERROR, _T("DsEventLogMgr: Could not allocate memory!\n"));
          INVALIDATE;
          return;
      }
      _tcscpy(m_pUncSvr, _T("\\\\"));
      m_pUncSvr = _tcscat(m_pUncSvr, pSvr_);
   }

   //
   // Attempt to open event log (no use forking thread if can't get in)
   //
   if(Open()){
      //
      // Get initial log info
      //
      if(!GetNumberOfEventLogRecords(m_hEvtLog, &m_dwRecordCount)){
         dprintf(DBG_ERROR, _T("Error<%lu>: Cannot get number of eventlog records\n"), GetLastError());
         INVALIDATE;
      }
   }
   else {
      //
      // could not open. Invalidate server
      //
      dprintf(DBG_ERROR, _T("Error<%lu>: Cannot open eventlog\n"), GetLastError());
      INVALIDATE;
      return;
   }



}



DsEventLogMgr::~DsEventLogMgr(void){

   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr destructor\n"));

   delete m_pUncSvr;

   if(m_hEvtLog){
      CloseEventLog(m_hEvtLog);
   }
   delete m_pFilter;


}



void DsEventLogMgr::InitDefaults(void){

   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr::InitDefaults\n"));
   m_bValid = TRUE;
   m_pUncSvr = NULL;
   m_hEvtLog= NULL;
   m_dwLastError = 0;
   m_dwRecordCount = 0;
   m_pEvents = NULL;
   m_BufferSize = 0;
   //
   // event print filter
   //
   m_pFilter = new EVTFILTER;
   if (!m_pFilter) {
       assert(m_pFilter);
       m_bValid = FALSE;
   } else {
       m_pFilter->dwBacklog;
       // empty   m_Filter.EvtId;
       m_pFilter->dwEvtType = EVENTLOG_SUCCESS|EVENTLOG_ERROR_TYPE|EVENTLOG_WARNING_TYPE|
           EVENTLOG_INFORMATION_TYPE|EVENTLOG_AUDIT_SUCCESS|EVENTLOG_AUDIT_FAILURE;
       // empty vector<int> Category;
       m_pFilter->pMsgLib = (LPTSTR)szMessageLib;
       m_pFilter->OutStyle = EF_TAB;
       m_pFilter->bAppend = TRUE;
   }
}





BOOL DsEventLogMgr::Open(void){


   VALIDATE(m_bValid);

   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr::Open (%s)\n"), m_pUncSvr);
   //
   // open event log
   //
   m_hEvtLog = OpenEventLog(m_pUncSvr, EVTLOGSRC);

   if(NULL == m_hEvtLog){
      INVALIDATE;
      m_dwLastError = GetLastError();
      dprintf(DBG_ERROR, _T("Error<%lu>: could not open event log on %s.\n"),
                                                   m_dwLastError, m_pUncSvr);
   }

   return m_bValid;
}



BOOL DsEventLogMgr::run(void){


   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr::run (%s)\n"), m_pUncSvr);

   //
   // Init thread state
   //
   VALIDATE(m_bValid);
   SetRunning(TRUE);

   //
   // fetch event log
   //

   m_bValid = Fetch();

   //
   // wrap up
   //
   SetRunning(FALSE);
   return m_bValid;
}



BOOL DsEventLogMgr::Fetch(void){

   BOOL bStatus=FALSE;
   DWORD cbBuffer=0, cbRead=0, cbNxtBuffer=0;
   LPBYTE pBuffer=NULL;


   VALIDATE(m_bValid);

   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr::Fetch (%s)\n"), m_pUncSvr);

   try{

      //
      // Allocate approximate buffer space
      // we're approximating needed space as:
      // eventlog record + extra string space * a bit more then exact record count
      //
      cbBuffer = (sizeof(EVENTLOGRECORD) + MAXSTR)*(m_dwRecordCount+4);
      pBuffer = new BYTE[cbBuffer];
      if (!pBuffer) {
          assert(pBuffer != NULL);
          throw(CLocalException(_T("Could not allocate memory!\n")));
      }

      while (bStatus == FALSE) {


         memset(pBuffer, 0, cbBuffer);
         dprintf(DBG_FLOW, _T("\tDsEventLogMgr Reading log... \n"));
         bStatus = ReadEventLog(m_hEvtLog,
                                EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                                0,
                                pBuffer,
                                cbBuffer,
                                &cbRead,
                                &cbNxtBuffer);

         if(FALSE == bStatus){
            m_dwLastError = GetLastError();
            dprintf(DBG_WARN, _T("Warning <%lu>: ReadEventLog failed\n"), m_dwLastError);

            //
            // See if we need more buffer space
            //
            if(m_dwLastError == ERROR_INSUFFICIENT_BUFFER){

               dprintf(DBG_FLOW, _T("\tDsEventLogMgr Re-Reading log... \n"));
               delete pBuffer, pBuffer=NULL;
               pBuffer = new BYTE[cbBuffer];
            }        // re-read
            else{
               //
               // Error condition
               //
               m_dwLastError = GetLastError();
               dprintf(DBG_WARN, _T("Error <%lu>: ReadEventLog failed\n"), m_dwLastError);
               throw(CLocalException(_T("Cannot read event log"), m_dwLastError));
            }


         }        // non-successfull initial read
         else{
            //
            // successfull initial read: bStatus = TRUE
            //
            m_pEvents = (EVENTLOGRECORD*)new BYTE[cbRead];
            if (!m_pEvents) {
                assert(m_pEvents != NULL);
                throw(CLocalException(_T("Could not allocate memory!\n")));
            }

            memcpy((LPBYTE)m_pEvents, pBuffer, cbRead);
            m_BufferSize = cbRead;
            dprintf(DBG_FLOW, _T("\tDsEventLogMgr. Loaded Event list.\n"));
         }

      }
      dprintf(DBG_FLOW, _T(">> %s returned %d events.\n"), m_pUncSvr, m_dwRecordCount);

   }
   catch(CLocalException &e){
      dprintf(DBG_ERROR, _T("Error<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
      INVALIDATE;
   }

   //
   // Unconditional cleanup
   //
   delete pBuffer;

   return m_bValid;
}





/*+++
Function   : PrintLog
Description: print event list to file as specified by filter
Parameters : output file name & filter properties
Return     :
Remarks    : none.
---*/
BOOL DsEventLogMgr::PrintLog(LPCTSTR lpOutput, PEVTFILTER pFilter){

   VALIDATE(m_bValid);
   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr::PrintLog(%s)\n"), m_pUncSvr);
   //
   // copy over filter props: design this way so that we have a set of defaults
   //
   PEVTFILTER pFltr=m_pFilter;
   if(pFilter){
      //
      // replace default filter
      //
      pFltr = pFilter;
   }

   HINSTANCE hMsgLib=NULL;
   HANDLE hFile=NULL;
   DWORD dwStatus;
   try{

      //
      // try to open output file
      //
      HANDLE hFile = CreateFile(lpOutput,
                                GENERIC_READ|GENERIC_WRITE,
                                FILE_SHARE_READ|FILE_SHARE_WRITE,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
      if(hFile == INVALID_HANDLE_VALUE){
         throw(CLocalException(_T("Could not open output file"), m_dwLastError = GetLastError()));
      }
      dwStatus = SetFilePointer(hFile, 0, NULL, pFltr->bAppend?FILE_END:FILE_BEGIN);
      if(dwStatus == (DWORD)-1){
         throw(CLocalException(_T("Could not seek file"), m_dwLastError = GetLastError()));
      }

      //
      // prepare message library:
      // if can't load we'll use no string parsing method
      //
      hMsgLib = LoadLibraryEx(pFltr->pMsgLib, NULL, DONT_RESOLVE_DLL_REFERENCES);
      if(hMsgLib == NULL){
         m_dwLastError = GetLastError();
         dprintf(DBG_WARN, _T("Warning <0x%x>Failed to load %s\n"), m_dwLastError, pFltr->pMsgLib);
      }


      //
      // cycle through events
      //
      EVENTLOGRECORD *pCurrRec = NULL;
      LONG lRead = 0;
      DWORD dwWritten=0;
      TCHAR szClientInfo[MAXSTR];
      const TCHAR szHeaderTab[] = _T("\nComputer\tService\tEventID\tEventType\tCategory\tTimeGenerated\tRecordNumber\tExtended Message\n\n");
      const TCHAR szHeaderComma[] = _T("\nComputer,Service,EventID,EventType,Category,TimeGenerated,RecordNumber\tExtended Message\n\n");
      const TCHAR szHeaderRecord[] = _T("\nEventlog Record list\n\n");
      LPTSTR pHeader = NULL;
      DWORD cbHeader = 0;

      //
      // write header
      //
      TCHAR szComputer[MAX_COMPUTERNAME_LENGTH+1];
      DWORD cbComputer=MAX_COMPUTERNAME_LENGTH;
      SYSTEMTIME sysTime;

      GetLocalTime(&sysTime);

      if(!GetComputerName(szComputer, &cbComputer))
         throw(CLocalException(_T("Cannot get computer name!"), m_dwLastError = GetLastError()));

      _stprintf(szClientInfo, _T("\n---\t---\t---\t---\nClient: %s\tServer: %s\tTime:%d/%d/%d [%d:%d]\n"), szComputer,
                                                                                     m_pUncSvr,
                                                                                     (INT)sysTime.wMonth,
                                                                                     (INT)sysTime.wDay,
                                                                                     (INT)sysTime.wYear,
                                                                                     (INT)sysTime.wHour,
                                                                                     (INT)sysTime.wMinute);
      m_bValid = WriteFile(hFile,
                           szClientInfo,
                           _tcslen(szClientInfo),
                           &dwWritten,
                           NULL);
      if(!m_bValid){
         throw(CLocalException(_T("Could not write header to file (client info)"), m_dwLastError = GetLastError()));
      }


      switch(pFltr->OutStyle){
      case EF_TAB:
         pHeader = (LPTSTR)szHeaderTab;
         break;
      case EF_COMMA:
         pHeader = (LPTSTR)szHeaderComma;
         break;
      case EF_RECORD:
         pHeader = (LPTSTR)szHeaderRecord;
         break;
      case EF_NONE:
      default:
         throw(CLocalException(_T("Unknown case for event log filter output")));

      }

      cbHeader = _tcslen(pHeader);
      m_bValid = WriteFile(hFile,
                           (LPVOID)pHeader,
                           cbHeader,
                           &dwWritten,
                           NULL);
      if(!m_bValid){
         throw(CLocalException(_T("Could not write header to file"), m_dwLastError = GetLastError()));
      }


      for(pCurrRec = GetEvents(),
          lRead = BufferSize();
          lRead > 0;
          lRead  -= pCurrRec->Length,
          pCurrRec = (EVENTLOGRECORD*) ((LPBYTE)pCurrRec+pCurrRec->Length)){


         //
         // filter event
         //

         //
         // apply filters
         //
         if(pFltr->dwBacklog != 0 &&
            time(NULL) - pFltr->dwBacklog > pCurrRec->TimeGenerated){
            dprintf(DBG_FLOW, _T("Backlog time filtered: skipped record %lu "), pCurrRec->RecordNumber);
            continue;
         }
         if(!pFltr->EvtId.empty() &&
            find(pFltr->EvtId.begin(), pFltr->EvtId.end(), pCurrRec->EventID) == pFltr->EvtId.end()){
            dprintf(DBG_FLOW, _T("EventID filtered: skipped record %lu "), pCurrRec->RecordNumber);
            continue;
         }
         if(!(pFltr->dwEvtType & pCurrRec->EventType)){
            dprintf(DBG_FLOW, _T("EventType filtered: skipped record %lu "), pCurrRec->RecordNumber);
            continue;
         }
         if(!pFltr->Category.empty() &&
            find(pFltr->Category.begin(), pFltr->Category.end(), pCurrRec->EventCategory) == pFltr->Category.end()){
            dprintf(DBG_FLOW, _T("EventCategory filtered: skipped record %lu "), pCurrRec->RecordNumber);
            continue;
         }

         //
         // pre process event log entry
         //
         PCHAR pService= (PCHAR) ((LPBYTE) pCurrRec + sizeof(EVENTLOGRECORD));
         PCHAR pComputerName= (PCHAR) ((LPBYTE) pService + strlen(pService) + 1);


         //
         // process event record strings
         //
         UINT	iSz=0;
         PCHAR rgszInserts[MAXLIST];
         PCHAR szInsert = (PCHAR)((LPBYTE) pCurrRec + pCurrRec->StringOffset);
         if(pCurrRec->NumStrings >= MAXLIST-1){
            dprintf(DBG_ERROR, _T("Too many strings in event log entry"));
            continue;
         }

         if(hMsgLib){

            memset(rgszInserts, 0, sizeof(rgszInserts));
            for (iSz = 0; iSz < pCurrRec->NumStrings; iSz++){
               rgszInserts[iSz] = szInsert;
               szInsert += sizeof(CHAR)*(strlen(szInsert) + 1);
            }
         }

         //
         // Print event log information
         //
         LPTSTR pMsgBuffer=NULL;
         TCHAR pOutBuff[2*MAXSTR];

         //
         // Create format
         //
         //
         // format via Category
         //
         TCHAR szCat[MAXSTR];
         dwStatus = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                  FORMAT_MESSAGE_FROM_HMODULE |
                                  FORMAT_MESSAGE_IGNORE_INSERTS,
                                  hMsgLib,
                                  (DWORD) pCurrRec->EventCategory,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  (LPTSTR) &pMsgBuffer,
                                  0,
                                  NULL);

         if(dwStatus != 0){
            _stprintf(szCat, _T("[%d] %s"), (INT)pCurrRec->EventCategory, pMsgBuffer);
            LocalFree(pMsgBuffer), pMsgBuffer=NULL;
         }
         else{
            dprintf(DBG_WARN, _T("Failed to format category\n"));
            _stprintf(szCat, _T("[%d] unknown"), (INT)pCurrRec->EventCategory);
         }

         struct tm *generated = localtime((time_t*)&pCurrRec->TimeGenerated);
         TCHAR szGenerated[MAXSTR];
         if(generated){
            _stprintf(szGenerated, _T("%d/%d/%d [%d:%d]"), generated->tm_mon+1,
                                                          generated->tm_mday,
                                                          generated->tm_year,
                                                          generated->tm_hour,
                                                          generated->tm_min);

         }
         else{
            //
            // if we err'd converting
            //
            _stprintf(szGenerated, _T("%lu"), pCurrRec->TimeGenerated);
         }


         switch(pFltr->OutStyle){
         case EF_TAB:
            _stprintf(pOutBuff, _T("%s\t%s\t0x%x\t%s\t%s\t%s\t%lu\t"), pComputerName,
                                                              pService,
                                                              pCurrRec->EventID,
                                                              pCurrRec->EventType == EVENTLOG_SUCCESS? _T("SUCCESS"):
                                                              pCurrRec->EventType == EVENTLOG_ERROR_TYPE? _T("ERROR"):
                                                              pCurrRec->EventType == EVENTLOG_WARNING_TYPE? _T("WARNING"):
                                                              pCurrRec->EventType == EVENTLOG_INFORMATION_TYPE? _T("INFO"):
                                                              pCurrRec->EventType == EVENTLOG_AUDIT_SUCCESS? _T("AUDIT_SUCCESS"):
                                                              pCurrRec->EventType == EVENTLOG_AUDIT_FAILURE? _T("AUDIT_FAILURE"):
                                                              _T("UNKNOWN"),
                                                              szCat,
                                                              szGenerated,
                                                              pCurrRec->RecordNumber);
            NoNewLines(pOutBuff);
            break;
         case EF_COMMA:
            _stprintf(pOutBuff, _T("%s,%s,0x%x,%s,%s,%s,%lu,"), pComputerName,
                                                              pService,
                                                              pCurrRec->EventID,
                                                              pCurrRec->EventType == EVENTLOG_SUCCESS? _T("SUCCESS"):
                                                              pCurrRec->EventType == EVENTLOG_ERROR_TYPE? _T("ERROR"):
                                                              pCurrRec->EventType == EVENTLOG_WARNING_TYPE? _T("WARNING"):
                                                              pCurrRec->EventType == EVENTLOG_INFORMATION_TYPE? _T("INFO"):
                                                              pCurrRec->EventType == EVENTLOG_AUDIT_SUCCESS? _T("AUDIT_SUCCESS"):
                                                              pCurrRec->EventType == EVENTLOG_AUDIT_FAILURE? _T("AUDIT_FAILURE"):
                                                              _T("UNKNOWN"),
                                                              szCat,
                                                              szGenerated,
                                                              pCurrRec->RecordNumber);
            NoNewLines(pOutBuff);
            break;
         case EF_RECORD:
            _stprintf(pOutBuff,  _T("\n---\nEvent Record %lu (at %s):\n")
                                 _T("Service        : %s\n")
                                 _T("Computer Name  : %s\n")
                                 _T("Event ID       : 0x%x\n")
                                 _T("Event Type     : %s\n")
                                 _T("Event Category : %s\n")
                                 _T("Extended Message: "),
                                 pCurrRec->RecordNumber, szGenerated,
                                 pService,
                                 pComputerName,
                                 pCurrRec->EventID,
                                 pCurrRec->EventType == EVENTLOG_SUCCESS? _T("SUCCESS"):
                                 pCurrRec->EventType == EVENTLOG_ERROR_TYPE? _T("ERROR"):
                                 pCurrRec->EventType == EVENTLOG_WARNING_TYPE? _T("WARNING"):
                                 pCurrRec->EventType == EVENTLOG_INFORMATION_TYPE? _T("INFO"):
                                 pCurrRec->EventType == EVENTLOG_AUDIT_SUCCESS? _T("AUDIT_SUCCESS"):
                                 pCurrRec->EventType == EVENTLOG_AUDIT_FAILURE? _T("AUDIT_FAILURE"):
                                 _T("UNKNOWN"),
                                 szCat);

            break;
         case EF_NONE:
         default:
            throw(CLocalException(_T("Unknown case for event log filter output")));

         }
         //
         // Acutal write
         //

         m_bValid = WriteFile(hFile,
                              pOutBuff,
                              _tcslen(pOutBuff),
                              &dwWritten,
                              NULL);
         if(!m_bValid){
            throw(CLocalException(_T("Could not write event to file"), m_dwLastError = GetLastError()));
         }
         //
         // print extended format string information
         //

         //
         // Create format
         //
         DWORD dwFormat = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE;
         va_list *args=NULL;
         if(iSz == 0){
            //
            // No args
            //
            dwFormat |= FORMAT_MESSAGE_IGNORE_INSERTS;
            args=NULL;
         }
         else{
            //
            // we have args to process
            //
            dwFormat |= FORMAT_MESSAGE_ARGUMENT_ARRAY;
            args = (va_list *)rgszInserts;
         }

         //
         // format via event ID.
         //
         dwStatus = FormatMessage(dwFormat,
                                  hMsgLib,
                                  (DWORD) pCurrRec->EventID,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  (LPTSTR) &pMsgBuffer,
                                  0,
                                  args);

         if(dwStatus == 0){
            _stprintf(pOutBuff, _T("<Error[%lu] parsing extended message>"), GetLastError());
         }
         else{
            _stprintf(pOutBuff, _T("%s"), pMsgBuffer?pMsgBuffer:_T("none"));
            LocalFree(pMsgBuffer);
         }
         //
         // Acutal write of extended message
         //
         NoNewLines(pOutBuff);
         m_bValid = WriteFile(hFile,
                              pOutBuff,
                              _tcslen(pOutBuff),
                              &dwWritten,
                              NULL);
         if(!m_bValid){
            throw(CLocalException(_T("Could not write event to file"), m_dwLastError = GetLastError()));
         }
         WriteFile(hFile, _T("\n\r"), _tcslen(_T("\n\r")), &dwWritten, NULL);

         if(lRead  - (LONG)pCurrRec->Length <= 0){
            dprintf(DBG_FLOW, _T("Hit last record (lRead = %ld).\n"), lRead);
            break;
         }

      }

   }
   catch(CLocalException &e){
      dprintf(DBG_ERROR, _T("Error<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
      INVALIDATE;
   }


   //
   // cleanup
   //
   if(hMsgLib)
      FreeLibrary(hMsgLib);
   if(hFile)
      CloseHandle(hFile);

   return m_bValid;

}


void DsEventLogMgr::NoNewLines(LPTSTR pBuff){

   if(pBuff){
      for(INT i=0;i<_tcslen(pBuff);i++){
        if(pBuff[i] == '\r' || pBuff[i] == '\n')
           pBuff[i] = '.';
      }

   }
}


#endif

/******************* EOF *********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\clntutl\src\cfgstore.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cfgstore.cxx
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : cfgstore.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 3/9/1998
*    Description : Retrieves & stores domain configuration
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef CFGSTORE_CXX
#define CFGSTORE_CXX



// include //
#include "helper.h"
#include "excpt.hxx"
#include <winldap.h>
#include <ntldap.h>
#include <rpc.h>
#include <ntdsa.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <winsock2.h>
#include <ipexport.h>
#include <icmpapi.h>

#ifdef __cplusplus
}
#endif

#ifdef _DEBUG_MEMLEAK
#include <crtdbg.h>
#endif


#include "cfgstore.hxx"


// defines //
#define VALIDATE(x)     if(!m_bValid) return x
#define INVALIDATE      m_bValid = FALSE

#define ICMP_TIMEOUT    500            // 300 ms for a icmp reply


// types //




/*+++
class   : DomainInfo
Description: Contain server basic information
---*/



DomainInfo::DomainInfo(LPTSTR pNcName,
                 LPTSTR pDnsRoot,
                 LPTSTR pFlatName,
                 LPTSTR pTrustParent_,
                 LPTSTR pPartition_)
                                   : m_pszNcName(pNcName),
                                     m_pszDnsRoot(pDnsRoot),
                                     m_pszFlatName(pFlatName),
                                     m_pszTrustParent(pTrustParent_),
                                     m_pszPartitionName(pPartition_) {

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s1);
#endif
}



DomainInfo::~DomainInfo(void){

   delete m_pszNcName;
   delete m_pszDnsRoot;
   delete m_pszFlatName;
   delete m_pszTrustParent;
   delete m_pszPartitionName;

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s2);
   if ( _CrtMemDifference( &s3, &s1, &s2 ) ){

    OutputDebugString("*** [DomainInfo] _CrtMemDifference detected memory leak ***\n");
    _CrtMemDumpStatistics( &s3 );
    _CrtMemDumpAllObjectsSince(&s3);
    OutputDebugString("*** [DomainInfo] end of dump ***\n");

   }
   ASSERT(_CrtCheckMemory());
#endif


}

/******************  SERVERINFO *******************/
/*+++
class   : ServerInfo
Description: Contain server basic information
---*/

/*+++
Function   : Constructor
Description:
Parameters :
Return     :
Remarks    : none.
---*/
ServerInfo::ServerInfo(LPTSTR Dest_, SEC_WINNT_AUTH_IDENTITY *pAuth_){

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s1);
#endif

   dprintf(DBG_FLOW, _T("Call: ServerInfo constructor\n"));
   InitDefaults();

   if(!logon(Dest_) || !LoadOperationalAttributes()){
      INVALIDATE;
   }
   else{
      //
      // good logon
      //

      m_lpszFlatName = Dest_;
      m_bValid = TRUE;
      m_bOwnLd = TRUE;
   }

}


ServerInfo::ServerInfo(LDAP *ld_){

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s1);
#endif

   dprintf(DBG_FLOW, _T("Call: ServerInfo constructor(2)\n"));
   InitDefaults();

   m_ld=ld_;
   m_bOwnLd = FALSE;

   if(!LoadOperationalAttributes()){
      INVALIDATE;
   }
   else{
      //
      // good logon
      //

      m_lpszFlatName = NULL;
      m_bValid = TRUE;
   }

}



/*+++
Function   : Destructor
Description:
Parameters :
Return     :
Remarks    : none.
---*/
ServerInfo::~ServerInfo(void){

   dprintf(DBG_FLOW, _T("Call: ServerInfo destructor\n"));

   if(m_bOwnLd)
       ldap_unbind(m_ld);
   delete m_lpszDsService;
   delete m_lpszServer;
   delete m_lpszSchemaNC;
   delete m_lpszDefaultNC;
   delete m_lpszConfigNC;
   delete m_lpszRootNC;
   delete m_lpszLdapService;
   delete m_lpszDomain;

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s2);
   if ( _CrtMemDifference( &s3, &s1, &s2 ) ){

    OutputDebugString("*** [ServerInfo] _CrtMemDifference detected memory leak ***\n");
    _CrtMemDumpStatistics( &s3 );
    _CrtMemDumpAllObjectsSince(&s3);
    OutputDebugString("*** [ServerInfo] end of dump ***\n");

   }
   ASSERT(_CrtCheckMemory());
#endif



}



/*+++
Function   : InitDefaults
Description:
Parameters :
Return     :
Remarks    : none.
---*/
VOID ServerInfo::InitDefaults(void){

   //
   // general
   //
   dprintf(DBG_FLOW, _T("Call: ServerInfo::InitDefaults\n"));
   m_bValid = TRUE;
   m_pAuth = NULL;
   m_ld = NULL;
   //
   // Operational Attributes info
   //
   m_lpszDsService = NULL;
   m_lpszServer = NULL;
   m_lpszSchemaNC = NULL;
   m_lpszConfigNC = NULL;
   m_lpszDefaultNC = NULL;
   m_lpszRootNC = NULL;
   m_lpszLdapService = NULL;
   m_lpszDomain=NULL;
   pDomainInfo=NULL;
   m_lpszFlatName = NULL;
   m_dwOptions = 0;
   m_bOwnLd = FALSE;
}



/*+++
Function   : ping
Description: Pings the specified server
Parameters : none
Return     : TRUE if any error condition or got the server
             FALSE if ping returned an error (0 icmp)
Remarks    : none.
---*/
BOOL ServerInfo::ping(LPTSTR pSvr){

   VALIDATE(m_bValid);
   BOOL bStatus = TRUE;
   IPAddr address;
   struct hostent *hostp = NULL;

   //
   // see if we have a valid server specified for icmpping
   //
   if(!pSvr)
      return TRUE;

   //
   // Get its address for icmpSendEcho
   //
   address = inet_addr(pSvr);
   if (address == -1L)
   {
       hostp = gethostbyname(pSvr);
       if (hostp)
       {
           address = *(long *)hostp->h_addr;
       }
       else
       {
          dprintf(DBG_ERROR, _T("Error<%lu>: cannot find server address %s.\n"),
                                                         WSAGetLastError(), pSvr);
          return FALSE;
       }
   }

   HANDLE hIcmp = IcmpCreateFile();

   if(hIcmp == INVALID_HANDLE_VALUE){
      dprintf(DBG_ERROR, _T("Error<%lu>: Cannot open Icmp handle\n"), GetLastError());
      bStatus = TRUE;
   }
   else{
      //
      // send echo req
      //
      DWORD dwStatus=0;
      const BYTE IcmpBuffer[] = {"IcmpEchoRequest"};
      const INT cIcmpBuffer   = 16;
      const INT cReplyBuffer = sizeof(ICMP_ECHO_REPLY)+24;
      LPBYTE pReplyBuffer = new BYTE[cReplyBuffer];
      assert(pReplyBuffer);



      dwStatus = IcmpSendEcho(hIcmp,
                              address,
                              (LPVOID)IcmpBuffer,
                              cIcmpBuffer,
                              NULL,
                              pReplyBuffer,
                              cReplyBuffer,
                              ICMP_TIMEOUT);
      if(dwStatus == 0){
         //
         // dead server
         //
         dprintf(DBG_WARN, _T("Warning <%lu>: IcmpSendEcho returned 0 entries\n"),
                                                               GetLastError());
         bStatus = FALSE;
      }
      else{
         //
         // Cool, it's alive
         //
         bStatus = TRUE;
      }

      delete pReplyBuffer;
   }
   IcmpCloseHandle(hIcmp);

   return bStatus;

}


/*+++
Function   : logon
Description: logs (ldap_open/bind) into the specified svr
Parameters : dest svr, can be NULL for default
Return     :
Remarks    : none.
---*/
BOOL ServerInfo::logon(LPTSTR pDest){

   ULONG ulStatus=0;

   dprintf(DBG_FLOW, _T("Call: ServerInfo::logon\n"));
   VALIDATE(m_bValid);

   if(pDest && !ping(pDest)){
      dprintf(DBG_FLOW, _T("Failed to ping %s\n"), pDest);
      INVALIDATE;
      return m_bValid;
   }

   m_ld = ldap_open(pDest, LDAP_PORT);
   if(m_ld){
      ulStatus = ldap_bind_s(m_ld, NULL, (LPTSTR)m_pAuth, LDAP_AUTH_SSPI);
      if(ulStatus != LDAP_SUCCESS){
         dprintf(DBG_WARN, _T("Warning: connected as anonymous\n"));
      }

      INT iChaseRefferal=0;
      ldap_set_option(m_ld, LDAP_OPT_REFERRALS, (PVOID)&iChaseRefferal);
   }
   else{
      INVALIDATE;
   }

   return m_bValid;
}


/*+++
Function   : LoadOperationalAttributes
Description:
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ServerInfo::LoadOperationalAttributes(void){

   ULONG ulStatus = 0;
   LDAP_TIMEVAL tv={ 180, 0};
   LDAPMessage *pMsg=NULL, *pEntry;
   LPTSTR *pVal=NULL;

   dprintf(DBG_FLOW, _T("Call: ServerInfo::LoadOperationalAttributes\n"));
   VALIDATE(m_bValid);

   try{

      ulStatus = ldap_search_st(m_ld,
                                NULL,
                                LDAP_SCOPE_BASE,
                                _T("objectclass=*"),
                                NULL,
                                FALSE,
                                &tv,
                                &pMsg);

      if(ulStatus != LDAP_SUCCESS){
         throw (CLocalException(_T("Failed to get operational attributes"), LdapGetLastError()));
      }

      pEntry = ldap_first_entry(m_ld, pMsg);
      if(!pEntry){
         throw (CLocalException(_T("failed to process operational entry"), LdapGetLastError()));
      }

      pVal = ldap_get_values(m_ld, pMsg, _T("DsServiceName"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszDsService = new TCHAR[_tcslen(pVal[0])+1];
         if (!m_lpszDsService) {
             throw(CLocalException(_T("Could not allocate memory!\n")));
         }

         _tcscpy(m_lpszDsService, pVal[0]);
      }
      else{
         throw (CLocalException(_T("Warning: failed to get DsServiceName"), LdapGetLastError()));
      }
      ldap_value_free(pVal);

      pVal = ldap_get_values(m_ld, pMsg, _T("ServerName"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszServer = new TCHAR[_tcslen(pVal[0])+1];
         if (!m_lpszServer) {
             throw(CLocalException(_T("Could not allocate memory!\n")));
         }

         _tcscpy(m_lpszServer, pVal[0]);
      }
      else{
         throw (CLocalException(_T("failed to get ServerName")));
      }
      ldap_value_free(pVal);

      pVal = ldap_get_values(m_ld, pMsg, _T("ConfigurationNamingContext"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszConfigNC = new TCHAR[_tcslen(pVal[0])+1];
         if (!m_lpszConfigNC) {
             throw(CLocalException(_T("Could not allocate memory!\n")));
         }

         _tcscpy(m_lpszConfigNC, pVal[0]);
      }
      else{
         throw (CLocalException(_T("failed to get ConfigurationNamingContext")));
      }
      ldap_value_free(pVal);


      pVal = ldap_get_values(m_ld, pMsg, _T("SchemaNamingContext"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszSchemaNC = new TCHAR[_tcslen(pVal[0])+1];
         if (!m_lpszSchemaNC) {
             throw(CLocalException(_T("Could not allocate memory!\n")));
         }

         _tcscpy(m_lpszSchemaNC, pVal[0]);
      }
      else{
         throw (CLocalException(_T("failed to get SchemaNamingContext")));
      }
      ldap_value_free(pVal);

      pVal = ldap_get_values(m_ld, pMsg, _T("DefaultNamingContext"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszDefaultNC = new TCHAR[_tcslen(pVal[0])+1];
         _tcscpy(m_lpszDefaultNC, pVal[0]);
      }
      else{
         throw (CLocalException(_T("failed to get DefaultNamingContext")));
      }
      ldap_value_free(pVal);



      pVal = ldap_get_values(m_ld, pMsg, _T("RootDomainNamingContext"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszRootNC = new TCHAR[_tcslen(pVal[0])+1];
         _tcscpy(m_lpszRootNC, pVal[0]);
      }
      else{
         throw (CLocalException(_T("failed to get RootDomainNamingContext")));
      }
      ldap_value_free(pVal);

      pVal = ldap_get_values(m_ld, pMsg, _T("LdapServiceName"));
      if(pVal != NULL && pVal[0] != NULL){
         LPTSTR p1=NULL, p2=NULL;
         m_lpszLdapService = new TCHAR[_tcslen(pVal[0])+1];
         _tcscpy(m_lpszLdapService, pVal[0]);
         p1 = _tcschr(m_lpszLdapService, ':');
         if(p1){
            p1++;
            assert(p1!=NULL);
            p2 = _tcschr(p1, '\\');
            if(p2){
               //
               // old format
               //
               assert(p2!=NULL);
               m_lpszDomain = new TCHAR[(p2-p1)+1];
               _tcsncpy(m_lpszDomain, p1, sizeof(TCHAR)*(p2-p1));
            }
            else if((p2 = _tcschr(p1, '@')) != NULL){
               //
               // use new format
               //
               assert(p2);
               p2++;
               m_lpszDomain = new TCHAR[_tcslen(p2)+1];
               _tcscpy(m_lpszDomain, p2);
            }
            else{
               throw (CLocalException(_T("failed to parse LdapServiceName")));
            }
         }
      }
      else{
         throw (CLocalException(_T("failed to get LdapServiceName")));
      }
      ldap_value_free(pVal);



   } // try

   catch(CLocalException &e){
      //
      // PREFIX: PREFIX complains that we can potentially dereference the NULL
      // pointer e.  PREFIX appears to be just plain wrong here.  There is no
      // way that e can be NULL, and no way that either of it's two member
      // variables could be dereferenced as NULL.
      //
      dprintf(DBG_ERROR, _T("Error<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
      INVALIDATE;
   }

   if(pMsg)
      ldap_msgfree(pMsg);

   return m_bValid;
}










/******************  CONFIGSTORE *******************/

/*+++
class   : ConfigStore
Description:
Remarks    : none.
---*/

ConfigStore::ConfigStore(LPTSTR pDest_){


#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s1);
#endif



   m_bValid = TRUE;
   m_pDest=pDest_;


   if(CreateDomainList() &&
      CreateServerList() &&
      AssocDomainServers() &&
      CreateDomainHierarchy()){
      dprintf(DBG_FLOW, _T("Created configuration store\n"));
   }
   else{
      dprintf(DBG_ERROR, _T("Failed to create configuration store\n"));
   }
}




ConfigStore::ConfigStore(LDAP *ld){

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s1);
#endif


   m_bValid = TRUE;
   m_pDest=NULL;


   if(CreateDomainList(ld) &&
      CreateServerList(ld) &&
      AssocDomainServers() &&
      CreateDomainHierarchy()){
      dprintf(DBG_FLOW, _T("Created configuration store\n"));
   }
   else{
      dprintf(DBG_ERROR, _T("Failed to create configuration store\n"));
   }

}





/*+++
Function   : Destructor
Description: nothing to do here yet
Parameters :
Return     :
Remarks    : none.
---*/
ConfigStore::~ConfigStore(void){

   //
   // delete domain list
   //
   vector<DomainInfo*>::iterator itDmn;

   for(itDmn = DomainList.begin(); itDmn != DomainList.end(); itDmn++){
      delete (*itDmn);
   }
   if(!DomainList.empty()){
      DomainList.erase(DomainList.begin(), DomainList.end());
   }

   //
   // delete server list
   //
   vector<ServerInfo*>::iterator itSvr;
   for(itSvr = ServerList.begin(); itSvr != ServerList.end(); itSvr++){
      delete (*itSvr);
   }
   if(!ServerList.empty()){
      ServerList.erase(ServerList.begin(), ServerList.end());
   }



#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s2);
   if ( _CrtMemDifference( &s3, &s1, &s2 ) ){

    OutputDebugString("*** [ConfigStore] _CrtMemDifference detected memory leak ***\n");
    _CrtMemDumpStatistics( &s3 );
    _CrtMemDumpAllObjectsSince(&s3);
    OutputDebugString("*** [ConfigStore] end of dump ***\n");

   }
   ASSERT(_CrtCheckMemory());
#endif


}



BOOL ConfigStore::CreateDomainList(LDAP *ld_){

   VALIDATE(FALSE);

   //
   // Create server for initial info
   //

   ServerInfo *svr=NULL;

   if(ld_){
      svr = new ServerInfo(ld_);
   }
   else{
      svr = new ServerInfo(m_pDest);
   }

   if(!svr || !svr->valid()){
     delete svr;
     return INVALIDATE;
   }

   LDAPMessage *res=NULL, *entry=NULL;
   LDAP_TIMEVAL tv = { 120, 0};
   ULONG ulErr = 0;
   LPTSTR attrs[] = { _T("dnsRoot"),
                      _T("nCName"),
                      _T("Name"),
                      _T("trustParent"),
                      NULL};
   LPTSTR *vals=NULL;
   INT i=0, iDomains=0;

   dprintf(DBG_FLOW, _T("Call: ConfigStore::CreateDomainList\n"));


   try{

      TCHAR szSysFlagVal[8];
      CHAR szFilter[MAXSTR];

      //
      // construct filter
      //
      _itoa(FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN, szSysFlagVal, 10);
      _stprintf(szFilter, _T("(& (objectClass=crossRef)(systemFlags:%s:=%s))"),
                         LDAP_MATCHING_RULE_BIT_AND,
                         szSysFlagVal);
//      CHAR szFilter[] = {_T("(& (objectClass=crossRef)(systemFlags=3))")};

      dprintf(DBG_FLOW, _T("Searching %s for domain partitions...\n"), svr->m_lpszConfigNC);
      ulErr = ldap_search_st(svr->ld(),
                           svr->m_lpszConfigNC,
                           LDAP_SCOPE_SUBTREE,
                           szFilter,
                           attrs,
                           FALSE,
                           &tv,
                           &res);
      if(ulErr != LDAP_SUCCESS){
         throw(CLocalException(ldap_err2string(ulErr), ulErr));
      }
      //
      // Count partitions
      //
      for(entry = ldap_first_entry(svr->ld(), res), iDomains=0;
          entry != NULL;
          entry = ldap_next_entry(svr->ld(), entry), iDomains++);

      if(iDomains == 0){
         throw(CLocalException(_T("Retrieved 0 partitions!\n")));
      }

      DomainList.reserve(iDomains);



      //
      // Prepare partition list
      //
      dprintf(DBG_FLOW, _T("retrieved %d domains\n"), iDomains);

      for(i=0, entry = ldap_first_entry(svr->ld(), res);
          entry != NULL;
          entry = ldap_next_entry(svr->ld(), entry), i++){

         LPTSTR pNcName = NULL, pDnsRoot=NULL, pFlatName=NULL;
         LPTSTR pTrustParent=NULL;

         //
         // Get partition name
         //
         LPTSTR pTmpDn = ldap_get_dn(svr->ld(), entry);
         assert(pTmpDn);
         LPTSTR pDn = new TCHAR[_tcslen(pTmpDn)+1];
         _tcscpy(pDn, pTmpDn);
         ldap_memfree(pTmpDn);

         //
         // Get DnsRoot
         //
         vals = ldap_get_values(svr->ld(), entry, _T("dnsRoot"));
         assert(vals != NULL && vals[0] != NULL);

         pDnsRoot = new TCHAR[_tcslen(vals[0])+sizeof(TCHAR)];
         assert(pDnsRoot);
         _tcscpy(pDnsRoot, vals[0]);
         dprintf(DBG_FLOW, _T("\tpDnsRoot[%d] = %s\n"), i, pDnsRoot);

         ldap_value_free(vals);


         //
         // Get nc name
         //
         vals = ldap_get_values(svr->ld(), entry, _T("nCName"));
         assert(vals != NULL && vals[0] != NULL);

         pNcName = new TCHAR[_tcslen(vals[0])+sizeof(TCHAR)];
         assert(pNcName);
         _tcscpy(pNcName, vals[0]);
         dprintf(DBG_FLOW, _T("\tpNcName[%d] = %s\n"), i, pNcName);

         ldap_value_free(vals);

         //
         // Get flat name
         //
         vals = ldap_get_values(svr->ld(), entry, _T("Name"));
         assert(vals != NULL && vals[0] != NULL);

         pFlatName = new TCHAR[_tcslen(vals[0])+sizeof(TCHAR)];
         assert(pFlatName);
         _tcscpy(pFlatName, vals[0]);
         dprintf(DBG_FLOW, _T("\tpFlatName[%d] = %s\n"), i, pFlatName);

         ldap_value_free(vals);

         //
         // Get trustParent
         //
         vals = ldap_get_values(svr->ld(), entry, _T("trustParent"));
         if(vals && vals[0]){

            //
            // none enterprise root: enterprise root, will not have a trust parent
            //
            pTrustParent = new TCHAR[_tcslen(vals[0])+sizeof(TCHAR)];
            assert(pTrustParent);
            _tcscpy(pTrustParent, vals[0]);
            dprintf(DBG_FLOW, _T("\tpTrustParent[%d] = %s\n"), i, pTrustParent);

            ldap_value_free(vals);
         }


         //
         // Create DomainInfo
         //
         DomainList.push_back(new DomainInfo(pNcName, pDnsRoot, pFlatName, pTrustParent, pDn));
      }
   }     // try
   catch(CLocalException &e){
      dprintf(DBG_ERROR, _T("Error<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
      INVALIDATE;
   }

   ldap_msgfree(res);
   delete svr;

   return m_bValid;
}




/*+++
Function   : CreateServerList
Description: Query NTDS for a list of all servers.
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ConfigStore::CreateServerList(LDAP *ld_){


   VALIDATE(NULL);
   //
   // Create server for initial info
   //

   ServerInfo *svr=NULL;
   BOOL bStatus = TRUE;

   if(ld_){
      svr = new ServerInfo(ld_);
   }
   else{
      svr = new ServerInfo(m_pDest);
   }

   if(!svr || !svr->valid()){
      delete svr;
      return INVALIDATE;
   }

   LDAPMessage *res=NULL, *entry=NULL;
   LDAP_TIMEVAL tv = { 120, 0};
   ULONG ulErr = 0;
   LPTSTR attrs[] = { _T("Name"), NULL};

   LPTSTR *vals=NULL;
   INT i=0, iServers=0;

   dprintf(DBG_FLOW, _T("Call: ConfigStore::CreateServerList\n"));


   try{

      dprintf(DBG_FLOW, _T("Searching %s for servers...\n"), svr->m_lpszConfigNC);
      ulErr = ldap_search_st(svr->ld(),
                           svr->m_lpszConfigNC,
                           LDAP_SCOPE_SUBTREE,
                           _T("objectClass=Server"),
                           attrs,
                           FALSE,
                           &tv,
                           &res);
      if(ulErr != LDAP_SUCCESS){
         throw(CLocalException(ldap_err2string(ulErr), ulErr));
      }
      //
      // Count servers
      //
      for(entry = ldap_first_entry(svr->ld(), res), iServers=0;
          entry != NULL;
          entry = ldap_next_entry(svr->ld(), entry), iServers++);

      if(iServers == 0){
         ldap_msgfree(res);
         throw(CLocalException(_T("Retrieved 0 servers!\n")));
      }


      ServerList.reserve(iServers);


      //
      // Prepare server list
      // Any Server will be in the least. If it isn't nTDSDSA, it'll show up
      // an non-connected since ldap-based load will fail.
      //
      dprintf(DBG_FLOW, _T("retrieved %d servers\n"), iServers);

      for(i=0, entry = ldap_first_entry(svr->ld(), res);
          entry != NULL;
          entry = ldap_next_entry(svr->ld(), entry), i++){

         LPTSTR pFlatName=NULL;

         //
         // Get flat name
         //
         vals = ldap_get_values(svr->ld(), entry, _T("Name"));
         assert(vals != NULL && vals[0] != NULL);

         pFlatName = new TCHAR[_tcslen(vals[0])+sizeof(TCHAR)];
         assert(pFlatName);
         _tcscpy(pFlatName, vals[0]);
         dprintf(DBG_FLOW, _T("\tpFlatName[%d] = %s\n"), i, pFlatName);

         ldap_value_free(vals);

         //
         // Create ServerInfo & add to list
         //
         ServerInfo *pCurrSvr= new ServerInfo(pFlatName);
         if(!pCurrSvr->valid()){
            dprintf(DBG_ERROR, _T("Error: Cannot connect to server %s\n"), pFlatName);
            pCurrSvr->m_lpszFlatName = pFlatName;
         }
         //
         // Get minimal info but leave in invalid state
         //
         LPTSTR dn = ldap_get_dn(svr->ld(), entry);
         bStatus = LoadNTDSDsaServer(svr->ld(), dn, pCurrSvr);
         dprintf(DBG_FLOW, _T("LoadUnavailServer returned 0x%X\n"), bStatus);
         ldap_memfree(dn);

         ServerList.push_back(pCurrSvr);
      }

      //
      // Associate domains w/ servers
      //
   }     // try
   catch(CLocalException &e){
      dprintf(DBG_ERROR, _T("Error<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
      INVALIDATE;
   }

   ldap_msgfree(res);
   delete svr;

   return m_bValid;
}



BOOL ConfigStore::LoadNTDSDsaServer(LDAP *ld, LPTSTR dn, ServerInfo *pSvr){

   LDAPMessage *res=NULL, *entry=NULL;
   LDAP_TIMEVAL tv = { 120, 0};
   ULONG ulErr = 0;
   LPTSTR attrs[] = { _T("hasMasterNCs"),
                      _T("Options"),
                      NULL};

   LPTSTR *vals=NULL;
   INT i=0;
   INT cbVals=0;

   dprintf(DBG_FLOW, _T("Call: ConfigStore::LoadNTDSDsaServer\n"));


   try{

      //
      // Loading nTDSDSA server
      //
      dprintf(DBG_FLOW, _T("Searching %s for ntdsdsa...\n"), dn);
      ulErr = ldap_search_st(ld,
                           dn,
                           LDAP_SCOPE_ONELEVEL,
                           _T("objectClass=nTDSDSA"),
                           attrs,
                           FALSE,
                           &tv,
                           &res);
      if(ulErr != LDAP_SUCCESS){
         throw(CLocalException(ldap_err2string(ulErr), ulErr));
      }
      //
      // Count servers
      //
      entry = ldap_first_entry(ld, res);
      if(!entry){
         throw(CLocalException(ldap_err2string(ulErr), ulErr));
      }

      if(!pSvr->valid()){
         //
         // Get NC's for unavailable servers (avail ones get NC's at connect from
         // operational attributes query
         //
         vals = ldap_get_values(ld, entry, _T("hasMasterNCs"));
         assert(vals != NULL && vals[0] != NULL);

         cbVals = ldap_count_values(vals);
         assert(cbVals != 0);

         for(i=0; i<cbVals; i++){
            assert(vals[i]);
            if(!_tcsnicmp(_T("CN=Schema"), vals[i], _tcslen(_T("CN=Schema")))){
               //
               // got schema
               //
               pSvr->m_lpszSchemaNC = new TCHAR[_tcslen(vals[i])+1];
               if (!pSvr->m_lpszSchemaNC) {
                   throw(CLocalException(_T("Could not allocate memory!\n")));
               }
               
               _tcscpy(pSvr->m_lpszSchemaNC, vals[i]);
            }
            else if(!_tcsnicmp(_T("CN=Configuration"), vals[i], _tcslen(_T("CN=Configuration")))){
               //
               // got Config
               //
               pSvr->m_lpszConfigNC = new TCHAR[_tcslen(vals[i])+1];
               if (!pSvr->m_lpszConfigNC) {
                   throw(CLocalException(_T("Could not allocate memory!\n")));
               }
               
               _tcscpy(pSvr->m_lpszConfigNC, vals[i]);
            }
            else{
               //
               // got data NC
               //
               pSvr->m_lpszDefaultNC = new TCHAR[_tcslen(vals[i])+1];
               if (!pSvr->m_lpszDefaultNC) {
                   throw(CLocalException(_T("Could not allocate memory!\n")));
               }

               _tcscpy(pSvr->m_lpszDefaultNC, vals[i]);
            }
         }

         ldap_value_free(vals);
      }

      //
      // Get NTDSDSA Options
      //
      vals = ldap_get_values(ld, entry, _T("Options"));
      if(vals != NULL && vals[0] != NULL){
         //
         // Options exist
         //
         pSvr->m_dwOptions = (DWORD)atol(vals[0]);

      }
      ldap_value_free(vals);


   }     // try
   catch(CLocalException &e){
      //
      // PREFIX: PREFIX complains that we can potentially dereference the NULL
      // pointer e.  PREFIX appears to be just plain wrong here.  There is no
      // way that e can be NULL, and no way that either of it's two member
      // variables could be dereferenced as NULL.
      //
      dprintf(DBG_WARN, _T("Warning<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
   }

   ldap_msgfree(res);

   return m_bValid;

}


/*+++
Function   : CreateDomainHierarchy
Description: link domain list in a hierarchy
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ConfigStore::CreateDomainHierarchy(void){

   INT i=0;

   dprintf(DBG_FLOW, _T("Call: ConfigStore::CreateDomainHierarchy\n"));
   VALIDATE(m_bValid);

   if(DomainList.size() == 0 || ServerList.size() == 0){
      dprintf(DBG_ERROR, _T("Error: found %d domains & %d servers. aborting\n"),
                                         DomainList.size(), ServerList.size());
      return INVALIDATE;
   }


   //
   // traverse all domains:
   // - no trust parent => root domain (nothing to do)
   // - if we have a trust parent, find it's domainInfo object & add it to that guys
   //   child list
   //
   for(i=0; i<DomainList.size(); i++){
      LPTSTR pUpDn = (LPTSTR)DomainList[i]->GetTrustParent();
      vector<DomainInfo*>::iterator itDmn;

      if(pUpDn == NULL)
         continue;

      if(DomainList.end() !=
         (itDmn = find_if(DomainList.begin(), DomainList.end(), IsDomain(pUpDn)))){
         //
         // (*itDmn) is the parent of DomainList[i]
         //
         (*itDmn)->ChildDomainList.push_back(DomainList[i]);
      }
   }

   return m_bValid;
}


/*+++
Function   : AssocDomainServers
Description: link (associate) a domain w/ a list of svrs & a server w/ it's parent domain
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ConfigStore::AssocDomainServers(void){

   VALIDATE(m_bValid);
   INT iDmn=0, iSvr=0;

   //
   // for all domains
   //
   for(iDmn= 0; iDmn < DomainList.size(); iDmn++){

      //
      // for all servers
      //
      for(iSvr= 0; iSvr<ServerList.size(); iSvr++){
         if(ServerList[iSvr]->m_lpszDefaultNC && DomainList[iDmn]->GetNCName()){
            //
            // we have valid strings to compare NC's with.
            //
            if(!_tcsicmp(ServerList[iSvr]->m_lpszDefaultNC, DomainList[iDmn]->GetNCName())){
               //
               // got a match
               //
               DomainList[iDmn]->ServerList.push_back(ServerList[iSvr]);
               ServerList[iSvr]->pDomainInfo = DomainList[iDmn];
            }
         }
      }
   }

#if 0
   // ***** BUGBUG: debugging. Rm later. Seems consistent for now *****
   //
   // for all domains
   //
   vector<DomainInfo*>::iterator itDmn;
   vector<ServerInfo*>::iterator itSvr;
   _tprintf(_T("Domain DC list\n"));
   for(itDmn= DomainList.begin();
       itDmn != DomainList.end();
       itDmn++){

      _tprintf(_T("\nDomain %s is hosted on:\n"), (*itDmn)->GetFlatName());
      //
      // for all servers
      //
      for(itSvr= (*itDmn)->ServerList.begin();
          itSvr != (*itDmn)->ServerList.end();
          itSvr++){
            _tprintf(_T(" %s\n"), (*itSvr)->m_lpszFlatName);
            _tprintf(_T(" (pointing back at:%s)\n"), (*itSvr)->pDomainInfo->GetFlatName());
      }
   }
#endif

   return m_bValid;
}




/*+++
Function   : GetServerList
Description: Retrive the associated server list of a domain
Parameters : lpDomain: name of domain; ServerList: OUT required server list
Return     : TRUE if we found it, FALSE otherwise
Remarks    : none.
---*/
BOOL ConfigStore::GetServerList(LPTSTR lpDomain, vector<ServerInfo*> &ServerList){

   BOOL bStatus = FALSE;

   vector<DomainInfo*>::iterator itDmn;

   if(lpDomain){
      if(DomainList.end() !=
         (itDmn = find_if(DomainList.begin(), DomainList.end(), IsDomain(lpDomain)))){
         ServerList = (*itDmn)->ServerList;
         bStatus = TRUE;
      }
      else{
         //
         // Couldn't find any domain
         //
         bStatus = FALSE;
      }

   }

   return bStatus;
}


#endif

/******************* EOF *********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\convdn\convdn.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       convdn.c
//
//--------------------------------------------------------------------------


#include <NTDSpch.h>
#pragma hdrstop

#include <drs.h>

// Maximum characters to search for a token. Should fit in
// the max-length token that we are interested in, currently
// defaultObjectCategory

#define MAX_TOKEN_LENGTH  25

// Max length of a line to be read or written out
#define MAX_BUFFER_SIZE   10000

// Suffix to put at the end of the input file to create output file
#define OutFileSuffix ".DN"

#define CONFIG_STR "cn=configuration,"

// Globals to store names
char *pInFile, *pNewDomainDN, *pNewConfigDN, *pNewRootDomainDN;
BOOL fDomainOnly = FALSE;

// Global to read-in, write-out a line
char line[MAX_BUFFER_SIZE];


// Internal functions
int  DoDNConvert( FILE *pInp, char *pDomainDN, char *pConfigDN );
BOOL IsDNToken( char *token );
int  DNChange( char *pLine, char *pDomainDN, 
               char *pRootDomainDN,  BOOL *fDomainObj );


///////////////////////////////////////////////////////////////
// Routine Description:
//      Processes command line arguments and loads into appropriate
//      globals
//
// Arguments:
//      argc - no. of command line arguments
//      argv - pointer to command line arguments
//
// Return Value:
//      0 on success, non-0 on error
///////////////////////////////////////////////////////////////

int ProcessCommandLine(int argc, char **argv)
{
    BOOL fFoundDomainDN = FALSE;
    BOOL fFoundConfigDN = FALSE;
    int count = 0, len;
 
    if (argc < 7) return 1;
   

    // First argument must be the /f followed by the input file name
    if (_stricmp(argv[1],"/f")) {
       printf("Missing input file name\n");
       return 1;
    }
    pInFile = argv[2];

   
    // Must be followed by /d for the new domain dn
    if (_stricmp(argv[3],"/d")) return 1;
 
    pNewDomainDN = argv[4];
 
    // Must be followed by /c for the new config dn
    if (_stricmp(argv[5],"/c")) return 1;

    pNewConfigDN = argv[6];

    // See if only domain NC changes are needed
    if ( argc == 8 ) {
       if (_stricmp(argv[7],"/DomainOnly")) {
          // unknown argument
          printf("Unknown option on command line\n");
          return 1;
       }
       // Otherwise, DomainOnly option is specified
       fDomainOnly = TRUE;
    }

   return 0;
 
}



void UsagePrint()
{
   printf("Command line errored\n");
   printf("Usage: ConvertDN /f <InFile> /d <New Domain DN> /c <New Config DN>\n");
   printf("InFile:  Input file name \n");
   printf("New Domain DN: DN of the domain to replace with\n");
   printf("New Config DN: DN of the configuration container\n");
   printf("\nExample: ConvertDN /f MyFile /d dc=Foo1,dc=Foo2 /s cn=Configuration,dc=Foo2\n");
}


void __cdecl main( int argc, char **argv )
{
    ULONG   i, Id;
    FILE   *pInp;
 

    if ( ProcessCommandLine(argc, argv)) 
      {
         UsagePrint();
         exit( 1 );
      };

    // Open the input file for reading
    if ( (pInp = fopen(pInFile,"r")) == NULL) {
       printf("Unable to open Input file %s\n", pInFile);
       exit (1);
    }


    // Ok, now go ahead and change the DN
    if (DoDNConvert(pInp, pNewDomainDN, pNewConfigDN)) {
       printf("DN Conversion failed\n");
       fclose(pInp);
       exit(1);
    }
    fclose(pInp);

}

////////////////////////////////////////////////////////////////////
//
// Routine Decsription:
//       Converts DNs in input file and writes to output file
//
// Arguments:
//       fInp : File pointer to input file
//       fOupt : File pointer to output file
//
// Return Value:
//        None
////////////////////////////////////////////////////////////////////

int DoDNConvert(FILE *pInp, char *pDomainDN, char *pConfigDN)
{
    int   i, len;
    char  token[MAX_TOKEN_LENGTH + 1];
    BOOL  fDomainObj, fSkip = FALSE;
    char  *pOutFile;
    FILE  *pOutp;
    char  *pRootDomainDN;
    int   lineNo;
   

    // Create the output file name and open it
    pOutFile = alloca( (strlen(pInFile) + 
                         strlen(OutFileSuffix) + 1)*sizeof(char));
    strcpy(pOutFile, pInFile);
    strcat(pOutFile, OutFileSuffix);

    if ( (pOutp = fopen(pOutFile, "w")) == NULL) {
       printf("Unable to open output file %s\n", pOutFile);
      return 1; 
    }

    // Create the new root domain dn from the config dn

    len = strlen("CN=configuration");
    if ( _strnicmp(pConfigDN, "CN=configuration", len)) {
        // Bad config DN specified
        printf("Bad Config DN specified\n");
        fclose(pOutp);
        return 1;
     }

    pRootDomainDN = &(pConfigDN[len + 1]);


    lineNo = 1;
    while ( !feof(pInp) ) {
        if ( fgets( line, MAX_BUFFER_SIZE, pInp ) == NULL ) {
           // error reading line
           break;
        }
 
        // isolate the first token  from the line
        i = 0;
   
        while ( (i <= MAX_TOKEN_LENGTH) &&
                     (line[i] != ':') && (line[i] != '\n')
              ) {
           token[i] = line[i];
           i++;
        }

        if ( line[i] == ':' ) {
          // ok, got a token. Null-terminate it and check if it 
          // is one of those we want changed. 
          
          token[i] = '\0';

          if ( _stricmp(token,"dn") == 0 ) {
            // It is a dn. Check if it is in domain NC or under config
             if ( DNChange(line, pDomainDN, pRootDomainDN, &fDomainObj) ) {
               // some error occured
               printf("Cannot convert DN in line %s\n", line);
             }
             if ( !fDomainObj && fDomainOnly ) {
                 // This is not the dn of a domain object
                 // so if DomainOnly is specified, skip this object
                 // Note that all lines in the file are skipped until
                 // we reach the dn of a domain object
                 fSkip = TRUE;
             }
             else {
                 fSkip = FALSE;
             }
          }

          if ( !fSkip ) {
             // Check for other DS-DN syntaxed tokens for this object          
             if (IsDNToken(token) ) {
                // change the dn in the line
                if ( DNChange(line, pDomainDN, pRootDomainDN, &fDomainObj) ) {
                  // some error occured
                  printf("Cannot convert DN in line no. %d\n", lineNo);
                  fclose(pInp);
                  fclose(pOutp);
                  break;
                }
             }
          }
        }

         // At this point, either the line read does not need any 
         // conversion, or it is already converted. So write the line
         // out to the output file if it is not to be skipped

        if ( !fSkip ) {
           fputs( line, pOutp);
        }
        lineNo++;
    }

    // check if bailed out of the while loop before feof is reached
    if ( !feof(pInp) ) {
       // error before end
       printf("Error reading line no. %d\n", lineNo);
       fclose(pOutp);
       return 1;
    }
    fclose(pOutp);
    return 0;
}

// List of attributes with DS-DN syntax (other than dn) that can occur 
// in the ldif file right now. If any other attributes with DS-DN syntax 
// can occur  in the ldif file, this list needs to be modified

char *TokenList[] = {
     "defaultObjectCategory",
     "objectCategory",
};

int numToken = sizeof(TokenList) / sizeof(TokenList[0]);


BOOL IsDNToken(char *token)
{
    int i;
 
    for ( i=0; i<numToken; i++) {
       if ( _stricmp(token, TokenList[i]) == 0 ) {
          return TRUE;
       }
     }
     return FALSE;
}

///////////////////////////////////////////////////////////////////
//
// Decsription:
//     Changes the DN in a line appropriately depending on whether
//     it is dn in the domain NC or in config/schema NC
//
// Argument:
//     line - pointer to line to convert
//     pDomainDN - pointer to domain DN string
//     pRootDomainDN - pointer to root domain DN string
//     fDomainObj - BOOL to return if this was a dn in the domain NC
//
// Return Value:
//     0 on success, 1 on error
//
////////////////////////////////////////////////////////////////////

int DNChange(char *pLine, 
             char *pDomainDN, 
             char *pRootDomainDN, 
             BOOL *fDomainObj)
{
    int  i = 0, j = 0, len;
    BOOL fFound = FALSE;


    while ( !fFound && (pLine[i] != '\n') ) {
       if ( _strnicmp( &(pLine[i]), "dc=", 3) == 0 ) {
          // ok, found the "dc="
          fFound = TRUE;
       }
       else {
         i++;
       }
    }

    if (!fFound) {
      // Didn't find a dc=, nothing to do
      return 0;
    } 

    // check if this is a domain NC object or one under configuration
    len = strlen(CONFIG_STR);

    if ( i > len) {
       if (_strnicmp( &(pLine[i-len]), CONFIG_STR, len) == 0) {
          *fDomainObj = FALSE;
       }
       else {
          *fDomainObj = TRUE;
       }
    }
    else {
        // cannot possibly have cn=configuration before the dc=
        *fDomainObj = TRUE;
    }

 
    // now replace the rest of the line with the new dn given
    if ( *fDomainObj ) {
       strcpy( &(pLine[i]), pDomainDN);
    }
    else {
       strcpy( &(pLine[i]), pRootDomainDN);
    }

    // do a little jugglery to put the '\n' at the end before the null
    i = strlen( pLine );
    pLine[i++] = '\n';
    pLine[i] = '\0';
    

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\csvds\import.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    import.cxx

Abstract:
    
    Import operations of CSV

Author:

    Felix Wong [FelixW]    22-Jul-1997
    
++*/

#include "csvde.hxx"
#pragma hdrstop

CLexer *g_pLexer = NULL;
int g_iDN = -1;
PWSTR g_szFrom = NULL;
PWSTR g_szTo = NULL;
long g_cAttributeTotal = 0;
DWORD g_cLine = 0;
DWORD g_cColumn = 0;
extern PWSTR szFileFlagR;
extern BOOLEAN g_fUnicode;

//+---------------------------------------------------------------------------
// Function:    InitEntry
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR InitEntry(csv_entry *pEntry, DWORD dwEntry)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;

    pEntry->ppMod = (LDAPMod **)MemAlloc((dwEntry + 1) * sizeof(LDAPMod *));
    if (!pEntry->ppMod) {
        hr = DIREXG_OUTOFMEMORY;
    }

    pEntry->ppModAfter[1] = NULL;
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    FreeEntryInfo
//
// Synopsis:    Free information containing in the Entry
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void FreeEntryInfo(csv_entry *pEntry)
{
    if (pEntry->szDN) {
        MemFree(pEntry->szDN);
        pEntry->szDN = NULL;
    }
    if (pEntry->ppMod) {
        FreeMod(pEntry->ppMod);
    }
    if (pEntry->ppModAfter[0]) {
        FreeMod(pEntry->ppModAfter);
        pEntry->ppModAfter[0] = NULL;
    }
}

//+---------------------------------------------------------------------------
// Function:    FreeEntry
//
// Synopsis:    Free the entry
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void FreeEntry(csv_entry *pEntry)
{
    if (pEntry->ppMod) {
        MemFree(pEntry->ppMod);
        pEntry->ppMod = NULL;
    }
}


//+---------------------------------------------------------------------------
// Function:    PrintMod
//
// Synopsis:    Print out the values in the LDAP MOD structure
//
// Arguments:   LDAPMod **pMod
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
PrintMod(LDAPMod **ppMod, DWORD dwType)
{
    DWORD        cAttribute = 0;
    PWSTR       *string_array;
    struct       berval **ber_array;
   
    if (!ppMod) {
        return DIREXG_ERROR;
    }
    
    while(*ppMod) {
        if ( (*ppMod)->mod_op == (((*ppMod)->mod_op)|LDAP_MOD_BVALUES) ) {
            
            //
            // BVALUE
            //
            SelectivePrint2(dwType,
                           L"Attribute %d) %s:",
                           cAttribute,
                           (*ppMod)->mod_type); 
            ber_array=(*ppMod)->mod_bvalues;
            if (ber_array) {
                while (*ber_array) {
                    SelectivePrint( dwType,
                                    MSG_CSVDE_UNPRINTABLEBINARY,
                                    (*ber_array)->bv_len);
                    ber_array++;
                }
            }
            
            SelectivePrint2( dwType,
                            L"\r\n");
        } else {
            
            //
            // STRING
            //
            SelectivePrint2(dwType,
                           L"Attribute %d) %s:",
                           cAttribute,
                           (*ppMod)->mod_type); 
            string_array=(*ppMod)->mod_values;
            if (string_array) {
                while (*string_array) {
                    SelectivePrint2(dwType,
                                    L" %s",
                                    (*string_array));
                    string_array++;
                }
            }
            SelectivePrint2( dwType,
                            L"\r\n");
        }   
        
        ppMod++;
        cAttribute++;
    }
    SelectivePrint2( dwType,
                    L"\r\n");
    return DIREXG_SUCCESS;
}


//+---------------------------------------------------------------------------
// Function:    FreeMod
//
// Synopsis:    Free out the Mod memory
//
// Arguments:   LDAPMod **ppMod
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
FreeMod(LDAPMod** ppMod) {
    
   PWSTR *string_array;
   struct berval **ber_array;
   
   while(*ppMod) {
        if ( (*ppMod)->mod_op == (((*ppMod)->mod_op)|LDAP_MOD_BVALUES )) {
            // BVALUE
            ber_array=(*ppMod)->mod_bvalues;

            while (*ber_array) {
                MemFree ((*ber_array)->bv_val);            //MemFree the byte blob
                MemFree (*ber_array);                      //MemFree the struct
                ber_array++;
            }
            MemFree((*ppMod)->mod_bvalues);
        } else {
            // STRING
            string_array=(*ppMod)->mod_values;

            while (*string_array) {
                MemFree (*string_array);
                string_array++;
            }
            
            MemFree((*ppMod)->mod_values);
        }   
        MemFree ((*ppMod)->mod_type);
        MemFree(*ppMod);
        *ppMod = NULL;
        ppMod++;
   }
   return DIREXG_SUCCESS;
}

//+---------------------------------------------------------------------------
// Function:    MakeAttribute
//
// Synopsis:    Make an attribute
//
// Arguments:   LDAPMod *pMod
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
MakeAttribute(LDAPMod **ppAttribute, 
              LDAPMod **ppAttributeMod,
              PWSTR szType, 
              PWSTR *pszVal, 
              DWORD cValue, 
              BOOLEAN bBinary,
                          BOOLEAN *pfAfter) 
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    LDAPMod *pAttribute = NULL;
    DWORD cValueCur = 0;

    pAttribute = (LDAPMod *)MemAlloc(sizeof(LDAPMod));
    if (!pAttribute ) {
         hr = DIREXG_OUTOFMEMORY;
         DIREXG_BAIL_ON_FAILURE(hr);
    }
    memset(pAttribute, 0 ,sizeof(LDAPMod));

    if (!bBinary) {       
        pAttribute->mod_op=LDAP_MOD_ADD;

        pAttribute->mod_type = MemAllocStrW(szType);
        if (!pAttribute->mod_type) {
             hr = DIREXG_OUTOFMEMORY;
             DIREXG_BAIL_ON_FAILURE(hr);
        }           

        pAttribute->mod_values = (PWSTR*)MemAlloc((cValue+1)*sizeof(PWSTR));
        if (!pAttribute->mod_values) {
             hr = DIREXG_OUTOFMEMORY;
             DIREXG_BAIL_ON_FAILURE(hr);
        }
        memset(pAttribute->mod_values, 0 ,sizeof((cValue+1)*sizeof(PWSTR)));

        while (cValueCur < cValue) {
            PWSTR szFinal = NULL;
            BOOL  fNeedToFree = FALSE;
            if (g_szFrom) {
                hr = SubString(*pszVal,
                               g_szFrom,
                               g_szTo,
                               &szFinal);
                DIREXG_BAIL_ON_FAILURE(hr);
                if (!szFinal) { 
                    szFinal = *pszVal;
                }
                else {
                    fNeedToFree = TRUE;
                }
            }
            else {
                szFinal = *pszVal;
            }
            pszVal++;
            (pAttribute->mod_values)[cValueCur]=MemAllocStrW(szFinal);
            if (!(pAttribute->mod_values)[cValueCur]) {
                 hr = DIREXG_OUTOFMEMORY;
                 DIREXG_BAIL_ON_FAILURE(hr);
            }
            cValueCur++;

            if (fNeedToFree) {
                MemFree(szFinal);
            }
        }

        (pAttribute->mod_values)[cValueCur] = NULL;  
    
    } 
    else {

        pAttribute->mod_op=LDAP_MOD_ADD|LDAP_MOD_BVALUES;
        pAttribute->mod_type = MemAllocStrW(szType);
        if (!pAttribute->mod_type) {
             hr = DIREXG_OUTOFMEMORY;
             DIREXG_BAIL_ON_FAILURE(hr);
        }

        pAttribute->mod_bvalues =
                (struct berval **)MemAlloc((cValue+1)*sizeof(struct berval *));
        if (!pAttribute->mod_bvalues) {
             hr = DIREXG_OUTOFMEMORY;
             DIREXG_BAIL_ON_FAILURE(hr);
        }
        memset(pAttribute->mod_bvalues, 0 ,sizeof((cValue+1)*sizeof(struct berval *)));

        while (cValueCur < cValue) {
            (pAttribute->mod_bvalues)[cValueCur] =
                                (struct berval *)MemAlloc(sizeof(struct berval));
            if (!(pAttribute->mod_bvalues)[cValueCur]) {
                 hr = DIREXG_OUTOFMEMORY;
                 DIREXG_BAIL_ON_FAILURE(hr);
            }
            
            hr = StringToBVal(*pszVal++,
                              ((pAttribute->mod_bvalues)[cValueCur]));
            DIREXG_BAIL_ON_FAILURE(hr);
             
            cValueCur++;
        }
        (pAttribute->mod_values)[cValueCur] = NULL;  
    }

    //
    // Extra logic added to do modify member attribute separately
    //
    if (_wcsicmp(szType,L"member")==0) {
        *ppAttributeMod = pAttribute;
        *pfAfter = TRUE;
    }
    else {
        *ppAttribute = pAttribute;
        *pfAfter = FALSE;
    }

    return hr;
error:
    if (pAttribute) {
        if (!bBinary) {       
            if (pAttribute->mod_type) {
                MemFree(pAttribute->mod_type);
            }
            if (pAttribute->mod_values) {   
                DWORD k=0;
                while ((pAttribute->mod_values)[k]) {
                    MemFree((pAttribute->mod_values)[k]);
                    k++;
                }
                MemFree(pAttribute->mod_values);
            }
        } 
        else {
            if (pAttribute->mod_type) {
                MemFree(pAttribute->mod_type);
            }
            if (pAttribute->mod_bvalues) {  
                DWORD k=0;
                while ((pAttribute->mod_bvalues)[k]) {
                    if ((pAttribute->mod_bvalues)[k]->bv_val)
                        MemFree((pAttribute->mod_bvalues)[k]->bv_val);
                    MemFree((pAttribute->mod_bvalues)[k]);
                    k++;
                }
                MemFree(pAttribute->mod_bvalues);
            }
        }
        MemFree(pAttribute);
    }
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    GetNextEntry
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
GetNextEntry(csv_entry *pEntry, PWSTR *rgAttribute)
{
    PWSTR   szToken = NULL;
    DWORD   cAttributes = 0;
    DWORD   dwToken;
    long    iIndex = 0;
    CStringPlex StringPlex;
    BOOLEAN bBinary = FALSE;
    DIREXG_ERR hr = DIREXG_ERROR;
    CString StrDN;

    pEntry->ppModAfter[0] = NULL;
    pEntry->szDN = NULL;
    
    iIndex = 0; 
    do {
        BOOLEAN fAfter = FALSE;
        bBinary = FALSE;

        if (szToken) {
            MemFree(szToken);
            szToken = NULL;
        }

        hr = StringPlex.Init();
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = g_pLexer->GetNextToken(&szToken, &dwToken);
        DIREXG_BAIL_ON_FAILURE(hr);
    
        if (dwToken == TOKEN_END) {
            if (iIndex == 0) {
                // First entry is null, implies no more entries
                hr = DIREXG_NOMORE_ENTRY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            else {
                // Reaches the end, done
                break;
            }
        }

        if (dwToken == TOKEN_COMMA) {
            iIndex++;
            continue;
        }

        if (dwToken != TOKEN_IDENTIFIER && dwToken != TOKEN_HEX) {
            //
            // index count starts at 0, and thus iIndex+1 is the current entry
            // number
            //
            SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_CSVDE_EXPECTIDHEX,iIndex+1,g_cColumn);
            hr = DIREXG_ERROR;
            goto error;
        }


        if (iIndex == g_iDN) {
            if (g_szFrom) {
                pEntry->szDN = NULL;
                hr = SubString(szToken,
                               g_szFrom,
                               g_szTo,
                               &pEntry->szDN );
                DIREXG_BAIL_ON_FAILURE(hr);
                if (!pEntry->szDN ) { 
                    pEntry->szDN = MemAllocStrW(szToken);
                }
            }
            else {
                pEntry->szDN = MemAllocStrW(szToken);
            }

            if (!pEntry->szDN) {
                hr = DIREXG_OUTOFMEMORY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            MemFree(szToken);
            szToken = NULL;
            hr = g_pLexer->GetNextToken(&szToken, &dwToken);
            DIREXG_BAIL_ON_FAILURE(hr);
            iIndex++;
            continue;
        }

        hr = StringPlex.AddElement(szToken);
        DIREXG_BAIL_ON_FAILURE(hr);
        if (dwToken == TOKEN_HEX) {
            bBinary = TRUE;
        }
        MemFree(szToken);
        szToken = NULL;
        
        hr = g_pLexer->GetNextToken(&szToken, &dwToken);
        DIREXG_BAIL_ON_FAILURE(hr);
        
        while (dwToken == TOKEN_SEMICOLON) {
            
            if (szToken) {
                MemFree(szToken);
                szToken = NULL;
            }
            //
            // Multivalue
            //
            hr = g_pLexer->GetNextToken(&szToken, &dwToken);
            DIREXG_BAIL_ON_FAILURE(hr);
            if (dwToken != TOKEN_IDENTIFIER && dwToken != TOKEN_HEX) {
                SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_CSVDE_EXPECTIDHEX,iIndex+1,g_cColumn);
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
    
            hr = StringPlex.AddElement(szToken);
            DIREXG_BAIL_ON_FAILURE(hr);
            if (dwToken == TOKEN_HEX && (!bBinary)) {
                SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_CSVDE_ERROR_INCONVALUES,iIndex+1,g_cColumn);
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            if (szToken) {
                MemFree(szToken);
                szToken = NULL;
            }

            hr = g_pLexer->GetNextToken(&szToken, &dwToken);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
        hr = MakeAttribute(&(pEntry->ppMod[cAttributes]), 
                           &(pEntry->ppModAfter[0]),                
                           rgAttribute[iIndex], 
                           StringPlex.Plex(),
                           StringPlex.NumElements(),
                           bBinary,
                           &fAfter);
        DIREXG_BAIL_ON_FAILURE(hr);
        
        if (!fAfter) {
            cAttributes++;
        }
        iIndex++;
    }
    while (dwToken == TOKEN_COMMA && (iIndex != g_cAttributeTotal));

    if (dwToken == TOKEN_COMMA) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_INVALIDNUM_ATTR);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if (dwToken != TOKEN_END) {
        //
        // We are telling the entry number before the failure, and its thus
        // iIndex, (iIndex+1 is the current entry)
        //
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_EXPECT_COMMA,iIndex,g_cColumn);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
         
    pEntry->ppMod[cAttributes] = NULL; 
    
    if (szToken) {
        MemFree(szToken);
    }
    return DIREXG_SUCCESS;

error:
    pEntry->ppMod[cAttributes] = NULL; 
    FreeEntryInfo(pEntry);
    FreeEntry(pEntry);
    if (szToken) {
        MemFree(szToken);
    }
    return hr;
}            

//+---------------------------------------------------------------------------
// Function:    DSImport
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR 
DSImport(LDAP *pLdap, 
         ds_arg *pArg)
{
    DIREXG_ERR     hr = DIREXG_ERROR;
    int         ldap_err;
    csv_entry   CSVEntry;
    FILE        *pFileIn = NULL;
    PWSTR       *rgAttribute = NULL;
    DWORD       cAttribute = 0;
    DWORD       cLine = 0;
    DWORD       cAdded = 0;
    long        i = 0;

    //
    // Initializing Variables
    //
    CSVEntry.szDN = NULL;
    CSVEntry.ppMod = NULL;
    CSVEntry.ppModAfter[0] = NULL;
    
    SelectivePrint( PRT_STD|PRT_LOG,
                    MSG_CSVDE_IMPORTDIR,
                    pArg->szFilename);
    
    //
    // If Unicode is not enabled by use, we'll test if the file is Unicode
    // by checking if it has the first byte as FFFE
    //
    if (pArg->fUnicode == FALSE) {
        if ((pFileIn = _wfopen(pArg->szFilename, L"rb")) == NULL) {
            SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_CSVDE_ERROR_OPENINPUT);
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if (fgetwc(pFileIn) == UNICODE_MARK) {
            pArg->fUnicode = TRUE;
        };
        fclose(pFileIn);
    }

    //
    // Setting the default File Read Flags
    //
    if (pArg->fUnicode == FALSE) {
        szFileFlagR = L"rt";
    }
    else {
        szFileFlagR = L"rb";    // Use binary if Unicode
        g_fUnicode = TRUE;
    }

    if ((pFileIn = _wfopen(pArg->szFilename, szFileFlagR)) == NULL) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_ERROR_OPENINPUT);
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    g_pLexer = new CLexer();
    if (!g_pLexer) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    hr = g_pLexer->Init(pFileIn);
    DIREXG_BAIL_ON_FAILURE(hr);

    //
    // If it is Unicode, we might have a leading byte FFFE. In that case, we'll
    // bypass it
    //
    if (pArg->fUnicode) {
        WCHAR charw = g_pLexer->NextChar();
        if (charw != UNICODE_MARK) {
            g_pLexer->PushbackChar();
        }
    }

    g_szFrom = pArg->szFromDN;
    g_szTo = pArg->szToDN;
    
    //
    // Getting Attribute Names from first line
    //
    cLine = 1;

    hr = GetAttributeType(&rgAttribute,
                          &cAttribute);
    DIREXG_BAIL_ON_FAILURE(hr);
    g_cAttributeTotal = cAttribute;

    hr = InitEntry(&CSVEntry,
                   cAttribute);
    DIREXG_BAIL_ON_FAILURE(hr);

    SelectivePrint( PRT_STD|PRT_LOG,
                    MSG_CSVDE_LOADING,
                    pArg->szFilename);
    SelectivePrint2( PRT_STD_VERBOSEONLY|PRT_LOG,
                    L"\r\n");
    TrackStatus();

    //
    // Getting Entry information one by one
    //
    cLine++;
    while ((hr = GetNextEntry(&CSVEntry,
                              rgAttribute)) == DIREXG_SUCCESS) {
        SelectivePrint2( PRT_STD_VERBOSEONLY|PRT_LOG,
                        L"%d: %s\r\n",
                        cLine,
                        CSVEntry.szDN);
        PrintMod(CSVEntry.ppMod, 
                 PRT_LOG);
        ldap_err = ldap_add_s(pLdap, 
                              CSVEntry.szDN, 
                              CSVEntry.ppMod);
        if (ldap_err != LDAP_SUCCESS) {
            PrintMod(CSVEntry.ppMod, 
                     PRT_ERROR);
            if (pArg->fSkipExist && 
                    (ldap_err == LDAP_ALREADY_EXISTS || 
                     ldap_err == LDAP_CONSTRAINT_VIOLATION ||
                     ldap_err == LDAP_ATTRIBUTE_OR_VALUE_EXISTS)) {
                //
                // Error that can be ignored
                //
                if (ldap_err == LDAP_ALREADY_EXISTS) {
                    SelectivePrint2( PRT_ERROR,
                                    L"%d: ",
                                    cLine);
                    SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_CSVDE_ENTRYEXIST);
                }
                else if (ldap_err == LDAP_ATTRIBUTE_OR_VALUE_EXISTS) {
                    SelectivePrint2( PRT_ERROR,
                                    L"%d: ",
                                    cLine);
                    SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_CSVDE_ATTRVALEXIST);
                }
                else {
                    SelectivePrint2( PRT_ERROR,
                                    L"%d: ",
                                    cLine);
                    SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_CSVDE_CONSTRAINTVIOLATE);
                }
                TrackStatus();
            }
            else {
                //
                // Unignorable errors -> program termination
                //
                SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_CSVDE_ADDERROR,
                                cLine, 
                                ldap_err2string(ldap_err));
                hr = ldap_err;
                OutputExtendedError(pLdap);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
        else {
            //
            // SUCCESS
            //
            TrackStatus();
            SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG,
                            MSG_CSVDE_ENTRYMODIFIED);
            cAdded++;
        }

        //
        // Extra logic adding to take care of members separately
        //
        if (CSVEntry.ppModAfter[0]) {
            ldap_err = ldap_modify_s(pLdap, 
                                  CSVEntry.szDN, 
                                  CSVEntry.ppModAfter);
            if (ldap_err != LDAP_SUCCESS) {
                SelectivePrint2( PRT_ERROR,
                                L"%d: ",
                                cLine);
                SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                MSG_CSVDE_MEMATTR_CANTMODIFIED);
                TrackStatus();
            }
            else {
                //
                // SUCCESS
                //
                SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG,
                                MSG_CSVDE_ENTRYMODIFIED);
            }
        }

        FreeEntryInfo(&CSVEntry);
        cLine++;
    }
    if (hr == DIREXG_NOMORE_ENTRY) {
        hr = DIREXG_SUCCESS;
    }
    else {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_PARSE_ERROR,
                        g_cLine);
    }
error:    
    if ((cAdded > 1) || (cAdded == 0)) {
        SelectivePrint( PRT_STD|PRT_LOG,
                        MSG_CSVDE_MODIFIY_SUCCESS,
                        cAdded);
    }
    else if (cAdded == 1) {
        SelectivePrint( PRT_STD|PRT_LOG,
                        MSG_CSVDE_MODIFY_SUCCESS_1);
    }
    if (g_pLexer) {
        delete g_pLexer;
        g_pLexer = NULL;
    }
    if (rgAttribute) {
        for (i=0;i<(long)cAttribute;i++) {
            MemFree(rgAttribute[i]);
        }
        MemFree(rgAttribute);
    }
    if (pFileIn) {
        fclose(pFileIn);
    }
    FreeEntryInfo(&CSVEntry);
    FreeEntry(&CSVEntry);
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    GetAttributeType
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
GetAttributeType(PWSTR **prgAttribute, DWORD *pcAttribute)
{
    PWSTR  szToken = NULL;
    DWORD   cAttribute = 0;
    DWORD   dwToken;
    DIREXG_ERR hr = DIREXG_ERROR;
    DWORD   i;
    CStringPlex StringPlex;
    BOOLEAN bFound = FALSE;

    hr = StringPlex.Init();
    DIREXG_BAIL_ON_FAILURE(hr);

    //
    // Getting Attributes
    //
    hr = g_pLexer->GetNextToken(&szToken, &dwToken);
    DIREXG_BAIL_ON_FAILURE(hr);
    if (dwToken != TOKEN_IDENTIFIER) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_ERROR_READATTRLIST);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    hr = StringPlex.AddElement(szToken);
    DIREXG_BAIL_ON_FAILURE(hr);
    if (szToken) {
        MemFree(szToken);
        szToken = NULL;
    }

    hr = g_pLexer->GetNextToken(&szToken, &dwToken);
    DIREXG_BAIL_ON_FAILURE(hr);

    while (dwToken == TOKEN_COMMA) {
        if (szToken) {
            MemFree(szToken);
            szToken = NULL;
        }

        hr = g_pLexer->GetNextToken(&szToken, &dwToken);
        DIREXG_BAIL_ON_FAILURE(hr);
        
        if (dwToken != TOKEN_IDENTIFIER) {
            SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_CSVDE_ERROR_READATTRLIST);
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
        hr  = StringPlex.AddElement(szToken);
        DIREXG_BAIL_ON_FAILURE(hr);
        if (szToken) {
            MemFree(szToken);
            szToken = NULL;
        }

        hr = g_pLexer->GetNextToken(&szToken, &dwToken);
        DIREXG_BAIL_ON_FAILURE(hr);

        cAttribute++;
    }

    if (dwToken != TOKEN_END) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_ERROR_READATTRLIST);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    hr = StringPlex.GetCopy(prgAttribute);
    DIREXG_BAIL_ON_FAILURE(hr);
    *pcAttribute = StringPlex.NumElements();

    bFound = FALSE;
    i = 0;
    while (i < (*pcAttribute)) {
        if (g_iDN == -1) {
            if (_wcsicmp((*prgAttribute)[i], L"DN") == 0) {
                g_iDN = i;
            }
        }
        if (!bFound) {
            if (_wcsicmp((*prgAttribute)[i], L"objectClass") == 0) {
                bFound = TRUE;
            }
        }
        i++;
    }
    
    if (g_iDN == -1) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_DN_NOTDEF);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    if (!bFound) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_OBJCLASS_NOTDEF);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

error:
    if (szToken) {
        MemFree(szToken);
        szToken = NULL;
    }
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    StringToBVal
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR StringToBVal(PWSTR szInput,
                     struct berval *pBVal)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    DWORD cchInput;
    WCHAR chFirst, chSecond;
    BYTE bFirst = 0, bSecond = 0;
    BYTE bByte;
    BYTE *pByte = NULL;
    BYTE *pByteReturn = NULL;

    cchInput = wcslen(szInput);
    if ((cchInput % 2) != 0) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_INVALIDHEX);
         hr = DIREXG_OUTOFMEMORY;
         DIREXG_BAIL_ON_FAILURE(hr);
    }
    cchInput = cchInput / 2;

    pByte = (BYTE*)MemAlloc(sizeof(WCHAR) * cchInput);  
    if (!pByte) {
         hr = DIREXG_OUTOFMEMORY;
         DIREXG_BAIL_ON_FAILURE(hr);
    }
    pByteReturn = pByte;

    _wcslwr(szInput);
    while (*szInput) {
        chFirst = *szInput++;
        chSecond = *szInput++;
        
        if (chFirst >= 'a' && chFirst <= 'f') {
            bFirst = chFirst - 'a' + 10;
        }
        else if (chFirst >= '0' && chFirst <= '9') {
            bFirst = chFirst - '0';
        }
        else {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        if (chSecond >= 'a' && chSecond <= 'f') {
            bSecond = chSecond - 'a' + 10;
        }
        else if (chSecond >= '0' && chSecond <= '9') {
            bSecond = chSecond - '0';
        }
        else {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        bByte = (BYTE)(bFirst * 16 + bSecond);
        *(pByte++) = bByte;
    }
    pBVal->bv_val = (char*)pByteReturn; 
    pBVal->bv_len = cchInput;
    return hr;
error:
    if (pByteReturn) {
        MemFree(pByteReturn);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\csvds\export.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    export.cxx

ABSTRACT:

DETAILS:
    
CREATED:

    09/02/97    Felix Wong (felixw)

REVISION HISTORY:

--*/


#include "csvde.hxx"
#pragma hdrstop

#define ATTRIBUTE_INC 100

//
// Global Variables
//

PWSTR g_szPrimaryGroup = L"primaryGroupID";
PSTR g_szDefaultGroup = "513";

PWSTR g_rgszOmit[] = { L"replPropertyMetaData",
                       NULL };

PWSTR rgszAttrList[] = { L"ldapDisplayName",
                         L"linkid",
                         NULL };

PWSTR rgszSchemaList[] = { L"schemaNamingContext",
                           L"defaultNamingContext",
                           L"supportedControl",
                           NULL };

typedef struct _hashcachestring {
    PWCHAR   value;
    ULONG    length;
    BOOLEAN  bUsed;
} HASHCACHESTRING;

extern BOOLEAN g_fDot;

ULONG g_nBacklinkCount = 0;
HASHCACHESTRING* g_BacklinkHashTable = NULL;       

// Global Attribute Entry Table
AttributeEntry* g_rgAttribute = NULL;
long g_iAttributeNext = 0;
long g_rgAttributeMax = 0;

// Whether appending of file is necessary
BOOLEAN g_fAppend = FALSE;
PRTL_GENERIC_TABLE  g_pOmitTable = NULL;

PWSTR g_szReturn = NULL;

enum CLASS_LOC {
    LOC_NOTSET,
    LOC_FIRST,
    LOC_LAST
};

int nClassLast = LOC_NOTSET; 

DIREXG_ERR 
ConvertUTF8ToUnicode(
    PBYTE pVal,
    DWORD dwLen,
    PWSTR *pszValue,
    DWORD *pdwLen);

BOOLEAN 
IsUTF8String(
    PCSTR pSrcStr,
    int cchSrc);

PWSTR szFileFlagR;
PWSTR szFileFlagW;

extern BOOLEAN g_fUnicode;

//+---------------------------------------------------------------------------
// Function:   DSExport 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR DSExport(LDAP *pLdap, ds_arg *pArg)
{
    DIREXG_ERR             hr = DIREXG_SUCCESS;
    DWORD               iszOmit;//, iAttribute;
    PRTL_GENERIC_TABLE  pAttrTable = NULL;
    NAME_MAP            NameMap;
    PNAME_MAP           pNameMap = NULL;
    int                 search_err;
    LDAPMessage         *pSearchMessage = NULL;
    LDAPMessage         *pMessage = NULL;
    FILE                *pFileTemp = NULL;
    FILE                *pFileAppend = NULL;
    PLDAPSearch         pSearch = NULL;
    WCHAR                szTempPath[MAX_PATH];
    WCHAR                szTempFile[MAX_PATH] = L"";
    WCHAR                szAppendPath[MAX_PATH];
    WCHAR                szAppendFile[MAX_PATH] = L"";
    DWORD               cEntriesExported = 0;
    BOOLEAN             fNewElem;
    BOOLEAN             fSearchStart = TRUE; 
    PWSTR               pszRootDN = NULL;
    DWORD               dwFlag = 0;

    BOOL            fPagingAvail = FALSE;
    BOOL            *pfPagingAvail = &fPagingAvail;
    BOOL            fSAMAvail = FALSE;
    
    //
    // If paging is off already, we don't need to ask whether paging is 
    // available or not.
    // pfPagingAvail is used to pass into InitExport to get paging status.
    //
    if (!pArg->fPaged) {
        pfPagingAvail = NULL;
    }

    if (pArg->fUnicode) {
        szFileFlagW = L"wb";
        szFileFlagR = L"rb";
        g_szReturn = L"\r\n";
        g_fUnicode = TRUE;
    }
    else {
        szFileFlagW = L"wt";
        szFileFlagR = L"rt";
        g_szReturn = L"\n";   // Text mode operation already prepends \n with \r
    }

    SelectivePrint(PRT_STD|PRT_LOG,
                   MSG_CSVDE_EXPORTING,
                   pArg->szFilename);
    
    SelectivePrint(PRT_STD|PRT_LOG,
                   MSG_CSVDE_SEARCHING);

    //***********************************************************
    // Variable Initialization Stage 
    // (SAMTable, pFileTemp, pFileAppend, pOmitTable, pAttrTable)
    //***********************************************************

    //
    // Creating SAM Table
    //
    hr = CreateSamTables(); 
    DIREXG_BAIL_ON_FAILURE(hr);

    if (pArg->fSAM) {
        dwFlag |= INIT_BACKLINK;
    }
    if (pArg->szRootDN == NULL) {
        dwFlag |= INIT_NAMINGCONTEXT;
    }

    hr = CreateOmitBacklinkTable(pLdap,
                                 pArg->omitList,
                                 dwFlag,
                                 &pszRootDN,
                                 pfPagingAvail,
                                 &fSAMAvail);    
    DIREXG_BAIL_ON_FAILURE(hr);

    //
    // If RootDN is NULL, we check if InitExport returns the naming context
    // correctly
    //
    if (pArg->szRootDN == NULL) {
        //
        // Output error message if we failed to get default naming context
        //
        if (pszRootDN == NULL) {
            SelectivePrint(PRT_STD,
                           MSG_CSVDE_ROOTDN_NOTAVAIL); 
            /*
            hr = ERROR_INVALID_PARAMETER;
            BAIL();
            */
        }
        else {
        //
        // else use it
        //
            pArg->szRootDN = pszRootDN;
        }
    }

    //
    // If we asked for SAM and it is not available, output error message and
    // turn off SAM logic, but still go on
    // 
    if (pArg->fSAM && (fSAMAvail == FALSE)) {
        SelectivePrint(PRT_STD,
                       MSG_CSVDE_SAM_NOTAVAIL); 
        pArg->fSAM = FALSE;
    }

    //
    // If the user requests paging, but it is not available, we'll inform the
    // user and turn off paging
    //
    if (pArg->fPaged) {

        //
        // If user requested paging, we must have passed in a valid entry
        // to initExport to get back status
        //
        ASSERT(pfPagingAvail);

        if (fPagingAvail == FALSE) {
            SelectivePrint(PRT_STD,
                           MSG_CSVDE_PAGINGNOTAVAIL); 
            pArg->fPaged = FALSE;
        }
    }

    //
    // Creating temporary file
    //
    if (!(GetTempPath(MAX_PATH, szTempPath))) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_CREATETEMP);    
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if (!(GetTempFileName(szTempPath, 
                          L"csva", 
                          0, 
                          szTempFile))) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_CREATETEMP);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if ((pFileTemp = _wfopen(szTempFile, 
                             szFileFlagW)) == NULL) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_OPENTEMP);
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    //
    // Creating Append file (only create if SAM logic is active)
    //
    if (pArg->fSAM) {
        if (!(GetTempPath(MAX_PATH, szAppendPath))) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERROR_CREATETEMP);        
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
        if (!(GetTempFileName(szAppendPath, 
                              L"csvb", 
                              0, 
                              szAppendFile))) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERROR_CREATETEMP);
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if ((pFileAppend = _wfopen(szAppendFile, 
                                   szFileFlagW)) == NULL) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERROR_OPENTEMP);
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Generating Attribute table
    //
    pAttrTable = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pAttrTable) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    RtlInitializeGenericTable(pAttrTable, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    g_rgAttribute = (AttributeEntry*)MemAlloc(sizeof(AttributeEntry) * 
                                            ATTRIBUTE_INC);
    if (!g_rgAttribute) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    g_rgAttributeMax = ATTRIBUTE_INC;
    g_iAttributeNext = 0;

    if (pArg->fPaged) {
        // ****************
        // PAGED SEARCH
        // ****************
        pSearch = ldap_search_init_page( pLdap,
                                          pArg->szRootDN,
                                          pArg->dwScope, 
                                          pArg->szFilter, 
                                          pArg->attrList,  
                                          FALSE,
                                          NULL,        // server controls
                                          NULL,
                                          0,
                                          0,
                                          NULL         // sort keys
                                        );
    
        search_err = LDAP_SUCCESS;
    
        if (pSearch == NULL) {
            search_err = LdapGetLastError();
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_SEARCHFAILED);
            hr = search_err;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    
        while ((search_err == LDAP_SUCCESS) && (pSearch != NULL)) {
    
            ULONG totalCount;
    
            search_err = ldap_get_next_page_s(  pLdap,
                                                pSearch,
                                                NULL,
                                                256,
                                                &totalCount,
                                                &pSearchMessage );
    
            if (fSearchStart) {
                SelectivePrint(PRT_STD|PRT_LOG,
                               MSG_CSVDE_WRITINGOUT);
                SelectivePrint2(PRT_STD_VERBOSEONLY|PRT_LOG,
                               L"\r\n");

                fSearchStart = FALSE;
                g_fDot = TRUE;  // Turn on dots so that a 'new line' WCHAR will
                                // be added before printing next statement.
            }
    
            if (pSearchMessage != NULL) {
                ULONG rc;
                PWSTR  matchedDNs = NULL;
                PWSTR  errors     = NULL;
                PWSTR  *referrals  = NULL;
                search_err = ldap_parse_result( pLdap,
                                                 pSearchMessage,
                                                 &rc,
                                                 &matchedDNs,
                                                 &errors,
                                                 &referrals,
                                                 NULL,
                                                 FALSE      // don't MemFree it.
                                                );
    
                if (referrals != NULL) {
                    PWSTR  *val = referrals;
                    while (*val != NULL) {
                        val++;
                    }
                    ldap_value_free( referrals );
                }
    
                if (errors != NULL) {
                    ldap_memfree( errors );
                }
    
                if (matchedDNs != NULL) {
                    ldap_memfree( matchedDNs );
                }

            
                //
                // Step through each pMessage
                //
                for ( pMessage = ldap_first_entry(pLdap, 
                                                  pSearchMessage ); 
                      pMessage != NULL; 
                      pMessage = ldap_next_entry(pLdap, 
                                                 pMessage ) ) { 
                    hr = GenerateEntry(pLdap, 
                                       pMessage, 
                                       pArg->omitList,
                                       pArg->fSAM,
                                       pArg->fBinary,
                                       pFileTemp,
                                       pFileAppend,
                                       pAttrTable);
                    DIREXG_BAIL_ON_FAILURE(hr);
                    cEntriesExported++;
                }
            }
            ldap_msgfree(pSearchMessage);
            pSearchMessage = NULL;
        }


        if ((search_err != LDAP_SUCCESS) && (search_err != LDAP_NO_RESULTS_RETURNED)) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_SEARCHFAILED);
            OutputExtendedError(pLdap);
            hr = search_err;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
    }
    else {
        // ****************
        // NON-PAGED SEARCH
        // ****************
        if ( (search_err=ldap_search_s(pLdap, 
                                       pArg->szRootDN, 
                                       pArg->dwScope, 
                                       pArg->szFilter, 
                                       pArg->attrList,  
                                       0, 
                                       &pSearchMessage))!= LDAP_SUCCESS ) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_SEARCHERROR, 
                           ldap_err2string(search_err));
            OutputExtendedError(pLdap);
            hr = search_err;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

    
         //
         // Step through each pMessage
         //
         SelectivePrint(PRT_STD|PRT_LOG,
                        MSG_CSVDE_WRITINGOUT);
         SelectivePrint2(PRT_STD_VERBOSEONLY|PRT_LOG,
                        L"\r\n");
         TrackStatus();
         
         for ( pMessage = ldap_first_entry(pLdap, 
                                           pSearchMessage ); 
               pMessage != NULL; 
               pMessage = ldap_next_entry(pLdap, 
                                          pMessage ) ) { 
             hr = GenerateEntry(pLdap, 
                                pMessage, 
                                pArg->omitList,
                                pArg->fSAM,
                                pArg->fBinary,
                                pFileTemp,
                                pFileAppend,
                                pAttrTable);
             DIREXG_BAIL_ON_FAILURE(hr);
             cEntriesExported++;
        }
    }

    if (cEntriesExported == 0) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_NOENTRIES);
        hr = DIREXG_SUCCESS;
        goto error;
    }

    if (pFileAppend) {
        fclose(pFileAppend);
        pFileAppend = NULL;

        //
        // If there are entries appended
        //
        if (g_fAppend) { 
            if ((pFileAppend = _wfopen(szAppendFile, 
                                       L"rb")) == NULL) {
                SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_CSVDE_ERROR_OPENTEMP);
                hr = DIREXG_FILEERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            hr = AppendFile(pFileAppend,
                            pFileTemp);
            if (hr != DIREXG_SUCCESS) {
                SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_CSVDE_ERROR_READTEMP);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }   
    }

    if (pFileTemp) {
        fclose(pFileTemp);
        pFileTemp = NULL;
    }

    if (pFileAppend) {
        fclose(pFileAppend);
        pFileAppend = NULL;
    }

    SelectivePrint(PRT_STD|PRT_LOG,
                   MSG_CSVDE_EXPORTCOMPLETED);

    hr = UpdateFile(szTempFile,
                    pArg->szFilename,
                    pArg);
    DIREXG_BAIL_ON_FAILURE(hr);

    SelectivePrint(PRT_STD|PRT_LOG,
                   MSG_CSVDE_NUMEXPORTED,
                   cEntriesExported);

error:

    if (pFileAppend) {
        fclose(pFileAppend);
        pFileAppend = NULL;
    }

    if (pFileTemp) {
        fclose(pFileTemp);
        pFileTemp = NULL;
    }


#ifndef LEAVE_TEMP_FILES
    if (szTempFile[0]) {
        DeleteFile(szTempFile);
        INFO(("Deleting temp file: %S",szTempFile));
    }
    if (szAppendFile[0]) {
        DeleteFile(szAppendFile);
        INFO(("Deleting temp file: %S",szAppendFile));
    }

#endif

    DestroySamTables();

    if (g_BacklinkHashTable) {
        UINT i;
        for (i=0;i<g_nBacklinkCount;i++) {
            if (g_BacklinkHashTable[i].bUsed) {
                MemFree(g_BacklinkHashTable[i].value);
            }
        }
        MemFree(g_BacklinkHashTable);
        g_BacklinkHashTable = NULL;
    }

    if (pszRootDN) {
        MemFree(pszRootDN);
    }

    if (pSearch != NULL) {
        ldap_search_abandon_page( pLdap, pSearch );
        pSearch = NULL;
    }

    if (pSearchMessage) {
        ldap_msgfree(pSearchMessage);
        pSearchMessage = NULL;
    }

    if (g_pOmitTable) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(g_pOmitTable, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(g_pOmitTable, TRUE)) {
            PWSTR szLinkDN;
            szLinkDN = pNameMap->szName;
            RtlDeleteElementGenericTable(g_pOmitTable, pNameMap);
            MemFree(szLinkDN);
        }
        MemFree(g_pOmitTable);
        g_pOmitTable = NULL;
    } 

    if (pAttrTable) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pAttrTable, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pAttrTable, TRUE)) {
            PWSTR szName = pNameMap->szName;
            RtlDeleteElementGenericTable(pAttrTable, pNameMap);
            MemFree(szName);
        }
        MemFree(pAttrTable);
        pAttrTable = NULL;
    }       

    if (g_rgAttribute) {
        // Not necessary because same value is stored in pAttrTable
        /*
        for (iAttribute=0;iAttribute<g_iAttributeNext;iAttribute++) {
            MemFree(g_rgAttribute[iAttribute].szValue);
        }
        */
        MemFree(g_rgAttribute);
    }
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:    GenerateEntry
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    03-9-97   felixw         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR GenerateEntry(LDAP                  *pLdap, 
                         LDAPMessage           *pMessage, 
                         PWSTR                 *rgszOmit, 
                         BOOLEAN               fSamLogic,
                         BOOLEAN               fBinaryOutput,
                         FILE                  *pFileOut,
                         FILE                  *pFileOutAppend,
                         PRTL_GENERIC_TABLE    pAttrTable)
{
    struct berval     **rgpVals = NULL;
    PWSTR       szDN = NULL;
    PWSTR       szTemp = NULL;
    PWSTR       szAttribute = NULL;
    PWSTR       szOutput = NULL;
    PWSTR       szDNNew = NULL;
    PWSTR       szBinary = NULL;
    BOOLEAN     fObjectClass;
    BOOLEAN     fBinary;
    long        i;
    DWORD       cVal;
    long        iAttribute;          
    CString     String;
    DIREXG_ERR     hr = DIREXG_SUCCESS;
    BOOLEAN     fAppend = FALSE;
    PWSTR pszValStr = NULL;
    DWORD dwValSize;
    PWSTR       szNewValue = NULL;
    PWSTR       szFinalValue = NULL;
    int nNumOfLineFeeds;

    TrackStatus();

    // ***********************************************
    // Initializing the attribute array for this entry
    // ***********************************************
    for (i=0;i<g_rgAttributeMax;i++) {
        g_rgAttribute[i].bExist = FALSE;
    }
    
    // ***********************************************
    // Update Attribute Table with current entry
    // ***********************************************
    hr = UpdateAttributeTable(pLdap,
                              pMessage,
                              fSamLogic,
                              fBinaryOutput,
                              &fAppend,
                              pAttrTable);
    DIREXG_BAIL_ON_FAILURE(hr);

    if (fAppend) {
        pFileOut = pFileOutAppend;
        g_fAppend = TRUE;
    }

    // *****************************
    // Getting the DN for this entry
    // *****************************
    szDN = ldap_get_dn( pLdap, 
                        pMessage );
    if (!szDN) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERRORGETDN);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    ASSERT(szDNNew == NULL);

    //
    // For a DN, we'll fix everything except escaping. DNs should always be
    // LDAP escaped.
    //
    hr = FixSpecialCharacters(szDN,
                              &szDNNew,
                              FIX_ALPHASEMI|FIX_COMMA|FIX_ESCAPE | COUNT_LF,
                              &nNumOfLineFeeds);
    DIREXG_BAIL_ON_FAILURE(hr);
    if (!szDNNew) {
        szDNNew = MemAllocStrW(szDN);
    }
    
    if(fwprintf(pFileOut,
                L"%d %d:",
                g_iAttributeNext, nNumOfLineFeeds)==EOF) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERRORWRITE);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    if(fwprintf(pFileOut,
                L"%s",
               szDNNew)==EOF) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_WRITE);
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    //
    // If this is not the only value, output the comma
    //
    if (g_iAttributeNext > 0) {
            if(fputws(L",", 
                      pFileOut)==WEOF) {
                    SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                                   MSG_CSVDE_ERRORWRITE);                      
                    hr = DIREXG_ERROR;
                    DIREXG_BAIL_ON_FAILURE(hr);
            }
    }

    // ***********************
    // Outputing current Entry
    // ***********************
    for (iAttribute=0; iAttribute < g_iAttributeNext; iAttribute++) {
        
        //
        // Skip if not exist
        //
        if (g_rgAttribute[iAttribute].bExist == FALSE) {
            goto done;
        }
        
        //
        // Collecting data for current Attribute
        //
        szAttribute = g_rgAttribute[iAttribute].szValue;
        rgpVals = ldap_get_values_len(pLdap, 
                                      pMessage, 
                                      szAttribute );
        cVal = ldap_count_values_len(rgpVals);
        fObjectClass = (_wcsicmp(L"objectClass",
                                 szAttribute) == 0);
        fBinary = CheckBinary(rgpVals,
                              cVal);
                            
        hr = String.Init();
        DIREXG_BAIL_ON_FAILURE(hr);
     
        //
        // Getting Each Value
        //
        for (i=0; i<(long)cVal; i++) {
      
            //
            // Only print last value if ObjectClass   
            //
            if(fObjectClass) {
                if (nClassLast == LOC_NOTSET) {
                    hr = ConvertUTF8ToUnicode((unsigned char*)rgpVals[i]->bv_val,
                                              rgpVals[i]->bv_len,
                                              &pszValStr,
                                              &dwValSize);
                    DIREXG_BAIL_ON_FAILURE(hr);
                    if ( _wcsicmp( pszValStr, L"top") == 0 ) {
                        nClassLast = LOC_LAST;
                    }
                    else {
                        nClassLast = LOC_FIRST;
                    }
                    MemFree(pszValStr);
                    pszValStr = NULL;
                }
                if (nClassLast == LOC_LAST) {
                    if (rgpVals[i+1]!=NULL) {
                        continue;
                    }
                }
                else {
                    if (i!=0) {
                        break;
                    }
                }
            }


            // 
            // Getting the current attribute value
            //
            if (fBinary) {
                hr = BValToString((unsigned char*)rgpVals[i]->bv_val, 
                                  rgpVals[i]->bv_len,
                                  &szBinary);                           
                DIREXG_BAIL_ON_FAILURE(hr);
                szTemp = szBinary;
            }
            else {
                ASSERT(pszValStr == NULL);
                hr = ConvertUTF8ToUnicode((unsigned char*)rgpVals[i]->bv_val,
                                          rgpVals[i]->bv_len,
                                          &pszValStr,
                                          &dwValSize);
                DIREXG_BAIL_ON_FAILURE(hr);
                szTemp = pszValStr;                           

                //
                // fix &, ; and /, we'll do ',' at the end
                //
                ASSERT(szNewValue == NULL);
                hr = FixSpecialCharacters(szTemp,
                                          &szNewValue,
                                          FIX_ALPHASEMI|FIX_ESCAPE,
                                          &nNumOfLineFeeds);
                DIREXG_BAIL_ON_FAILURE(hr);
                if (szNewValue) {
                    szTemp = szNewValue;
                }

            }

            if (fObjectClass) {
                hr = String.Append(szTemp);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            else {

                if (i==0) {
                    hr = String.Append(szTemp);
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                else {
                    hr = String.Append(L";");
                    DIREXG_BAIL_ON_FAILURE(hr);
                    hr = String.Append(szTemp);
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            }

            if (szBinary) {
                MemFree(szBinary);
                szBinary = NULL;
            }
            if (pszValStr) {
                MemFree(pszValStr);
                pszValStr = NULL;
            }
            if (szNewValue) {
                MemFree(szNewValue);
                szNewValue = NULL;
            }
        }
        ldap_value_free_len(rgpVals);
        rgpVals = NULL;

        szTemp = String.String();
        ASSERT(szFinalValue == NULL);
        hr = FixSpecialCharacters(szTemp,
                                  &szFinalValue,
                                  FIX_COMMA,
                                  &nNumOfLineFeeds);
        DIREXG_BAIL_ON_FAILURE(hr);
        if (szFinalValue) {
            szTemp = szFinalValue;
        }
        
        if(fwprintf(pFileOut,
                    L"%s", 
                    szTemp)==EOF) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERRORWRITE);                    
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        if (szFinalValue) {
            MemFree(szFinalValue);
            szFinalValue = NULL;
        }

done:
        //
        // Output COMMA as long as it is not the last one
        //
        if ((iAttribute + 1) < g_iAttributeNext) {
            if(fputws(L",", 
                      pFileOut)==WEOF) {
                SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_CSVDE_ERRORWRITE);                      
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
    }   

    if(fputws(g_szReturn,
              pFileOut)==WEOF) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_WRITE);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    SelectivePrint(PRT_STD_VERBOSEONLY|PRT_LOG,
                   MSG_CSVDE_EXPORT_ENTRY,
                   szDNNew);

error:
    if (szFinalValue) {
        MemFree(szFinalValue);
        szFinalValue = NULL;
    }
    if (szNewValue) {
        MemFree(szNewValue);
        szNewValue = NULL;
    }
    if (pszValStr) {
        MemFree(pszValStr);
        pszValStr = NULL;
    }
    if (szDN) {
        ldap_memfree(szDN);
    }
    if (szBinary) {
        MemFree(szBinary);
    }
    if (rgpVals) {
        ldap_value_free_len(rgpVals);
        rgpVals = NULL;
    }
    if (szDNNew) {
        MemFree(szDNNew);
    }
    return hr;
}

//+---------------------------------------------------------------------------
// Function:   UpdateFile
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR UpdateFile(PWSTR szFileIn, 
                   PWSTR szFileOut,
                   ds_arg *pArg)
{
    FILE *pFileOut = NULL;
    FILE *pFileIn = NULL;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    DWORD cAttribute;
    long iAttribute;
    DWORD i;
    DWORD cComma = 0;
    DWORD cLine = 0;
    PWSTR szCurrent = NULL;
    PWSTR szLine = NULL;
    PWSTR szSub = NULL;
    CString String;

    //
    // Opening both Input and Output file
    //
    if ((pFileOut = _wfopen(szFileOut, 
                            szFileFlagW)) == NULL) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_OPENOUTPUT, 
                       szFileOut);
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if ((pFileIn = _wfopen(szFileIn, 
                           szFileFlagR)) == NULL) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_OPENAPPPEND, 
                       szFileIn);
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    if (pArg->fUnicode) {
        if(fputwc(UNICODE_MARK,
                          pFileOut)==WEOF) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERRORWRITE);                          
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Outputing attribute line
    //
    if (!pArg->fSpanLine) {
        if(fputws(L"DN,",
                  pFileOut)==WEOF) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERRORWRITE);                  
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    else {
        SelectivePrint(PRT_STD|PRT_LOG,
                       MSG_CSVDE_ORGANIZE_OUTPUT, 
                       szFileIn);
        if(fputws(L"DN,&",
                  pFileOut)==WEOF) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERRORWRITE);                  
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if(fputws(g_szReturn,
                  pFileOut)==WEOF) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERRORWRITE);                  
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    for (iAttribute=0; iAttribute < (g_iAttributeNext - 1); iAttribute++) {
        if(fwprintf(pFileOut,
                    L"%s",
                    g_rgAttribute[iAttribute].szValue)==WEOF) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERRORWRITE);                     
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if (pArg->fSpanLine) {
            if(fputws(L",&",
                      pFileOut)) {
                SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_CSVDE_ERRORWRITE);   
                hr = DIREXG_FILEERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            if(fputws(g_szReturn,
                      pFileOut)) {
                SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_CSVDE_ERRORWRITE);                       
                hr = DIREXG_FILEERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
        else {
            if(fputws(L",",
                      pFileOut)) {
                SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_CSVDE_ERRORWRITE);                         
                hr = DIREXG_FILEERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
    }
    if(fwprintf(pFileOut,
                L"%s",
                g_rgAttribute[iAttribute].szValue)==WEOF) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERRORWRITE);                   
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if(fputws(g_szReturn,
              pFileOut)) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERRORWRITE);                 
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if (pArg->fSpanLine) {
        if(fputws(g_szReturn,
                 pFileOut)) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERRORWRITE);                    
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Outputing values
    //
    int scanResult;
    int nNumOfLineFeeds;
    scanResult = fwscanf(pFileIn,
                         L"%d %d:",
                         &cAttribute, &nNumOfLineFeeds);
    while ((scanResult != WEOF) && (scanResult != 0)) {

        PWSTR szCompleteLine = NULL;
        CString cstrCompleteLine;
        hr = cstrCompleteLine.Init();
        DIREXG_BAIL_ON_FAILURE(hr);

        // get a complete line
        for (;;) {
            hr = GetLine(pFileIn,
                                &szLine);
            DIREXG_BAIL_ON_FAILURE(hr);
            
            if (!szLine) {
                SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_CSVDE_ERROR_READTEMP);
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }

            hr = cstrCompleteLine.Append(szLine);
            DIREXG_BAIL_ON_FAILURE(hr);

            if (nNumOfLineFeeds-- == 0)
                break;

            hr = cstrCompleteLine.Append(L"\n");
            DIREXG_BAIL_ON_FAILURE(hr);
            
            MemFree(szLine);
            szLine = NULL;            
        }

        szCompleteLine = cstrCompleteLine.String();

        hr = String.Init();
        DIREXG_BAIL_ON_FAILURE(hr);

        cLine++;
        cComma = g_iAttributeNext - cAttribute;

        if (pArg->fSpanLine) {
            TrackStatus();
            PWSTR szNewLine = NULL;
            hr = SpanLines(szCompleteLine, &szNewLine);
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        hr = String.Append(szCompleteLine);
        DIREXG_BAIL_ON_FAILURE(hr);

        if (cComma == 0) {
            if (pArg->fSpanLine)
                String.Append(g_szReturn);
        }
        else {
            for (i=0;i<cComma;i++) {
                if (!pArg->fSpanLine) {
                    hr = String.Append(L",");
                }
                else {
                    if (i == (cComma - 1))
                        hr = String.Append(L",");
                    else
                        hr = String.Append(L",&");
                    DIREXG_BAIL_ON_FAILURE(hr);
                    hr = String.Append(g_szReturn);
                }
                DIREXG_BAIL_ON_FAILURE(hr);
            } 
        }      
        
        szCurrent = String.String(); 

        //
        // Do Substring substitution if necessary
        //
        if (pArg->szFromDN) {
            hr = SubString(szCurrent,
                           pArg->szFromDN,
                           pArg->szToDN,
                           &szSub);
            DIREXG_BAIL_ON_FAILURE(hr);
            if (szSub) { 
                szCurrent = szSub;
            }
        }
        
        if(fwprintf(pFileOut,
                   L"%s",
                   szCurrent)==WEOF) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERRORWRITE);                   
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if(fputws(g_szReturn,
                  pFileOut)) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERRORWRITE);                  
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if (szSub) {
            MemFree(szSub);
            szSub = NULL;
        }
        scanResult = fwscanf(pFileIn,
                             L"%d %d:",
                             &cAttribute,
                             &nNumOfLineFeeds);
    }    

error: 
    if (szLine) {
        MemFree(szLine);
    }
    if (szSub) {
        MemFree(szSub);
    }
    if (pFileOut) {
        fclose(pFileOut);
    }
    if (pFileIn) {
        fclose(pFileIn);
    }
    return hr;
}

//+---------------------------------------------------------------------------
// Function:   ParseDN
//
// Synopsis:   Return the parent dn and rdn. Use existing string. No MemFree
//             required.
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR ParseDN(PWSTR szDN,
                PWSTR *pszParentDN,
                PWSTR *pszRDN)
{
    PWSTR szCurrent = NULL;

    szCurrent = wcsstr(szDN, L",");
    if (!szCurrent) {
        return DIREXG_ERROR;
    }
    *pszRDN = szDN;
    *szCurrent = '\0';
    *pszParentDN = szCurrent + 1;
    
    return DIREXG_SUCCESS;
}

//+---------------------------------------------------------------------------
// Function:   FixSpecialCharacters
//
// Synopsis:   Surround string with double quotes if necessary, also change 
//             all internal double quotes to double, double quotes L" -> L"". 
//             If string is unchanged, output = NULL;
//             Also turn '&' into '\&'
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR FixSpecialCharacters(PWSTR szInput, PWSTR *pszResult, DWORD dwMode, int *nNumOfLineFeeds)
{
    PWSTR szCurrent = NULL;
    PWSTR szSubComma = NULL;
    PWSTR szSubComma2 = NULL;
    DWORD cchInput;
    PWSTR szSemi = NULL;
    PWSTR szAmper = NULL;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    BOOLEAN fChanged = FALSE;

    *pszResult = NULL;

    if (dwMode & FIX_ESCAPE) {
        if (wcsstr(szInput,L"\\")) {
            hr = SubString(szInput,
                           L"\\",
                           L"\\\\",
                           &szSubComma2);
            DIREXG_BAIL_ON_FAILURE(hr);
           
            if (szSubComma2) {
                szInput = szSubComma2;
                fChanged = TRUE;
            }
        }
    }

    if (dwMode & FIX_ALPHASEMI) {

        if (wcsstr(szInput,L";")) {
            hr = SubString(szInput,
                           L";",
                           L"\\;",
                           &szSemi);
            DIREXG_BAIL_ON_FAILURE(hr);
           
            if (szSemi) {
                szInput = szSemi;
                fChanged = TRUE;
            }
        }

        if (wcsstr(szInput,L"X'")) {
            hr = SubString(szInput,
                           L"X'",
                           L"\\X'",
                           &szAmper);
            DIREXG_BAIL_ON_FAILURE(hr);
           
            if (szAmper) {
                szInput = szAmper;
                fChanged = TRUE;
            }
        }
    
#ifdef SPANLINE_SUPPORT
        if (wcsstr(szInput,L"&")) {
            hr = SubString(szInput,
                           L"&",
                           L"\\&",
                           &szAmper);
            DIREXG_BAIL_ON_FAILURE(hr);
           
            if (szAmper) {
                szInput = szAmper;
                fChanged = TRUE;
            }
        }
#endif
    }

    if (dwMode & FIX_COMMA) {
        //
        // If comma exist in a string, we'll surround it with double quotes, 
        // however adding double quotes also requires us to turn all internal double 
        // quotes to double, double quotes -> '"' to '""'
        //
        if (wcsstr(szInput,L",") || wcsstr(szInput,L"\"") ) {
    
            hr = SubString(szInput,
                           L"\"",
                           L"\"\"",
                           &szSubComma);
            DIREXG_BAIL_ON_FAILURE(hr);
           
            if (szSubComma) {
                szInput = szSubComma;
            }
    
            cchInput = wcslen(szInput);
    
            //
            // need 2 WCHAR for double quotes and 1 for null termination
            //
            szCurrent = (PWSTR)MemAlloc(sizeof(WCHAR) * (cchInput + 3));
            if (!szCurrent) {
                hr = DIREXG_OUTOFMEMORY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            wcscpy(szCurrent,L"\"");
            wcscat(szCurrent,szInput);
            wcscat(szCurrent,L"\"");
            *pszResult = szCurrent;
        }
    }

    *nNumOfLineFeeds = 0;
    if (dwMode & COUNT_LF) {
        WCHAR* szTemp = szInput;
        while ((szTemp = wcsstr(szTemp, L"\n"))) {
            szTemp++;
            (*nNumOfLineFeeds)++;
        }
    }

    if ((*pszResult == NULL) && fChanged) {
        cchInput = wcslen(szInput);

        //
        // need 2 WCHAR for double quotes and 1 for null termination
        //
        szCurrent = (PWSTR)MemAlloc(sizeof(WCHAR) * (cchInput + 1));
        if (!szCurrent) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        wcscpy(szCurrent,szInput);
        *pszResult = szCurrent;
    }

error:
    if (szSemi) {
        MemFree(szSemi);
    }
    if (szAmper) {
        MemFree(szAmper);
    }
    if (szSubComma) {
        MemFree(szSubComma);
    }
    if (szSubComma2) {
        MemFree(szSubComma2);
    }
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:   FixMutliValueAttribute
//
// Synopsis:   In cases where multivalued attributes occur, we have to replace
//             all value separators to be escaped/
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-19-98   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR FixMutliValueAttribute(PWSTR szInput, PWSTR *pszResult)
{
    PWSTR  szCurrent = NULL;
    PWSTR szSub = NULL;      // Sub ampersand
    DWORD cchInput;
    DIREXG_ERR hr = DIREXG_SUCCESS;

    *pszResult = NULL;

    //
    // ';' is a special character, if it exist in the string, substitue all 
    // ';' with '\;'
    //  
    if (wcsstr(szInput,L";")) {
        hr = SubString(szInput,
                       L";",
                       L"\\;",
                       &szSub);
        DIREXG_BAIL_ON_FAILURE(hr);
        if (szSub) {
            *pszResult = szSub;
        }
    }
    
    return (hr);

error:
    if (szSub) {
        MemFree(szSub);
    }

    return (hr);
}

                    
//+---------------------------------------------------------------------------
// Function:   CheckBinary
//
// Synopsis:   Checks whether the berval is binary 
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
BOOLEAN CheckBinary(struct berval **rgpVals,
                    DWORD cVal)
{
    DWORD i,j;
    BOOLEAN fBinary = FALSE;     

    for (i=0; i<cVal;i++) {

        if (!g_fUnicode) {

            //
            // If not outputing Unicode, must treat all characters
            // outside printable ASCII range as binary
            //
    
            for (j=0; j<rgpVals[i]->bv_len; j++) {
                if (((rgpVals[i]->bv_val)[j]<0x20) ||
                    ((rgpVals[i]->bv_val)[j]>0x7E)) {
                        fBinary = TRUE;
                        break;
                }
            }
        }
        else {

            //
            // If outputing Unicode, the string (1) must be UTF-8,
            // and (2) when converted to Unicode, must contain
            // no characters < 0x20.  Otherwise, it's binary.
            //

            // Check condition (1)
            if (!IsUTF8String(rgpVals[i]->bv_val,
                              rgpVals[i]->bv_len)) {
                fBinary = TRUE;
            }
            else {

                // Check condition (2)
                PWCHAR pszUnicode = NULL;
                DWORD dwLen;
            
                ConvertUTF8ToUnicode(
                    (unsigned char*)rgpVals[i]->bv_val,
                    rgpVals[i]->bv_len,
                    &pszUnicode,
                    &dwLen
                    );

                if (pszUnicode) {

                    dwLen /= sizeof(WCHAR);
                
                    for (j=0; j < dwLen-1; j++) {
                        if (pszUnicode[j] < 0x20) {
                            fBinary = TRUE;
                            break;
                        }
                    }

                    MemFree(pszUnicode);
                    pszUnicode = NULL;
                }
                else {

                    // If ConvertUTF8ToUnicode failed,
                    // just treat it as binary.
                    fBinary = TRUE;
                }
            }
        }
        
        if (fBinary) 
            break;
    }
    
    return fBinary;
}

//+---------------------------------------------------------------------------
// Function:   BValToString
//
// Synopsis:   Converts a binary value to string    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR BValToString(BYTE *pbVal, 
                     DWORD cbVal,
                     PWSTR *pszReturn)
{
    PWSTR szReturn = NULL;
    PWSTR szCurrent = NULL;
    DWORD i;

    //
    // Each byte will turn into a two digit hex
    // we need 4 extra WCHAR for L"X" L"'" L"'" and null-termination
    //
    szReturn = (PWSTR)MemAlloc(sizeof(WCHAR) * (cbVal*2+4));
    if (!szReturn) {
        return DIREXG_OUTOFMEMORY;
    }

    szCurrent = szReturn;
    *szCurrent++ = 'X';
    *szCurrent++ = '\'';
    for (i=0; i<cbVal; i++) {
        swprintf(szCurrent,
                 L"%02x",
                 pbVal[i]);
        szCurrent+=2;
    }
    *szCurrent++ = '\'';
    *szCurrent = (WCHAR)NULL;
    *pszReturn = szReturn;
    return DIREXG_SUCCESS;
}


//+---------------------------------------------------------------------------
// Function:  UpdateSpecialVars 
//
// Synopsis:   Check whether it is a SAM object, or if it is a special object,
//             where they have members
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void UpdateSpecialVars(LDAP         *pLdap, 
                       LDAPMessage  *pMessage, 
                       DWORD        *pdwCheckAttr,
                       DWORD        *pdwSpecialAction)
{                     
    DWORD             dwCheckAttr = 0;
    DWORD             dwSpecialAction = 0;
    DWORD             i;
    struct berelement *pBerElement = NULL;
    PWSTR             *rgszValue = NULL;
    PWSTR             szAttribute = NULL;
    PWSTR             szTemp = NULL;

    // ****************************************
    // Checking if iCheckAttr or iSpecialAction
    // ****************************************
    for (szAttribute = ldap_first_attribute( pLdap, pMessage, &pBerElement );
         szAttribute != NULL;
         szAttribute = ldap_next_attribute( pLdap, pMessage, pBerElement ) ) {
         
        rgszValue = ldap_get_values(pLdap, pMessage, szAttribute );
        if (_wcsicmp(L"objectClass",szAttribute) == 0) {
            for (i=0; rgszValue[i]!=NULL; i++) {
                //
                // check whether it is a SAM object
                //
                if (dwCheckAttr == 0) {
                    dwCheckAttr = CheckObjectSam(rgszValue[i]);
                }

                //
                // check whether it is a special object
                //
                if (dwSpecialAction == 0) { 
                    dwSpecialAction = CheckObjectSpecial(rgszValue[i]);
                }

                if (dwCheckAttr && dwSpecialAction) {
                    break;
                }
            }
        }
        ldap_value_free(rgszValue);
        rgszValue = NULL;
        if (dwCheckAttr && dwSpecialAction) {
            break;
        }
    }
    *pdwCheckAttr = dwCheckAttr;
    *pdwSpecialAction = dwSpecialAction;
}

//+---------------------------------------------------------------------------
// Function:  UpdateAttributeTable 
//
// Synopsis:  Update the attribute Table 
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR UpdateAttributeTable(LDAP         *pLdap, 
                             LDAPMessage  *pMessage,
                             BOOLEAN       fSamLogic,
                             BOOLEAN       fBinaryOutput,
                             BOOLEAN       *pfAppend,
                             PRTL_GENERIC_TABLE    pAttrTable)
{
    struct berelement *pBerElement = NULL;
    struct berval     **rgpVals = NULL;
    PWSTR             szAttribute = NULL;
    DWORD             cVal;
    NAME_MAP          NameMap;
    PNAME_MAP         pNameMap = NULL;
    NAME_MAP          NtiAttr;
    DIREXG_ERR           hr = DIREXG_SUCCESS;
    BOOLEAN           fNewElem;
    DWORD             dwCheckAttr;
    DWORD             dwSpecialAction;

    UpdateSpecialVars(pLdap,
                      pMessage,
                      &dwCheckAttr,
                      &dwSpecialAction);
    
    for ( szAttribute = ldap_first_attribute( pLdap, pMessage, &pBerElement );
          szAttribute != NULL;
          szAttribute = ldap_next_attribute( pLdap, pMessage, pBerElement ) ) {
        
        rgpVals = ldap_get_values_len(pLdap, 
                                      pMessage, 
                                      szAttribute );
        cVal = ldap_count_values_len(rgpVals);
        
        //
        // Omit Entries for Special cases
        // 1)Check SAM logic,  2)Check Omit table
        //
        if (dwCheckAttr && 
            fSamLogic && 
            CheckAttrSam(szAttribute, dwCheckAttr)) {
            ldap_value_free_len(rgpVals);
            rgpVals = NULL;
            continue;
        }
        NameMap.szName = szAttribute;
        NameMap.index = 0;
        if (RtlLookupElementGenericTable(g_pOmitTable, 
                                         &NameMap)) {
            ldap_value_free_len(rgpVals);
            rgpVals = NULL;                                         
            continue;
        }
    
        if (fSamLogic && 
            ((_wcsicmp(L"objectGUID", szAttribute) == 0) ||
             (_wcsicmp(L"isCriticalSystemObject", szAttribute) == 0))
           ) {
            ldap_value_free_len(rgpVals);
            rgpVals = NULL;                                         
            continue;
        }

        //
        // If sam logic on and is member, output to append
        //
        if (fSamLogic) { 
            if (SCGetAttByName(wcslen(szAttribute),
                               szAttribute) == TRUE) {
                if (wcscmp(szAttribute,g_szPrimaryGroup) == 0) {
                    if ((rgpVals[0]->bv_len == strlen(g_szDefaultGroup)) && 
                        (memcmp(rgpVals[0]->bv_val,
                                g_szDefaultGroup,
                                strlen(g_szDefaultGroup)*sizeof(CHAR)) == 0)
                        ) {
                        //
                        // If the primarygroup value is the same as default,
                        // we just ignore it when the object is actually
                        // being created, the default value will be put in
                        //                
                        ldap_value_free_len(rgpVals);
                        rgpVals = NULL;                                         
                        continue;
                    }
                    else {
                        //
                        // If the value is not default, we will append it
                        // (treat it as backlink). It cannot accompany the
                        // rest of the object because this operation will
                        // fail if the group does not exist yet
                        //
                        *pfAppend = TRUE;
                    }
                }
                else {
                    *pfAppend = TRUE;
                }
            }
        }
    
        //
        // Omit Entries for Binary
        //
        if (!fBinaryOutput) {
            BOOLEAN fReturn;
            fReturn =  CheckBinary(rgpVals,
                                   cVal);
            if (fReturn) {
                ldap_value_free_len(rgpVals);
                rgpVals = NULL;                                         
                continue;
            }
        }
        
        //
        // Looking for current Attribute in attribute Table, add if not exist
        //
        NtiAttr.szName = szAttribute;
        if (!NtiAttr.szName) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        pNameMap = (PNAME_MAP)RtlLookupElementGenericTable (pAttrTable,
                                                            &NtiAttr);
        if (!pNameMap) {
            NtiAttr.index = g_iAttributeNext;
    
            if (g_iAttributeNext >= g_rgAttributeMax) {
                AttributeEntry* pTemp = NULL;
                pTemp = (AttributeEntry*)MemRealloc(g_rgAttribute,
                                        sizeof(AttributeEntry) * 
                                        (g_rgAttributeMax),
                                        sizeof(AttributeEntry) * 
                                        (g_rgAttributeMax + ATTRIBUTE_INC));
                if (!pTemp) {
                    hr = DIREXG_OUTOFMEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                g_rgAttribute = pTemp;
                g_rgAttributeMax += ATTRIBUTE_INC;
            }
            NtiAttr.szName = MemAllocStrW(szAttribute);
            if (!NtiAttr.szName) {
                hr = DIREXG_OUTOFMEMORY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            g_rgAttribute[g_iAttributeNext].bExist = TRUE;
            g_rgAttribute[g_iAttributeNext].szValue = NtiAttr.szName;
            g_iAttributeNext++;
    
            RtlInsertElementGenericTable(pAttrTable,
                                         &NtiAttr,
                                         sizeof(NAME_MAP), 
                                         &fNewElem);          
        }
        else {
            g_rgAttribute[pNameMap->index].bExist = TRUE;
        }
        ldap_value_free_len(rgpVals);
        rgpVals = NULL;
    }
error:
    if (rgpVals) {
        ldap_value_free_len(rgpVals);
        rgpVals = NULL;
    }
    return (hr);
}


//+---------------------------------------------------------------------------
// Function:  SpanLines 
//
// Synopsis:   Special function added to convert file into multiple lines   
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR SpanLines(PWSTR szInput, PWSTR *pszOutput)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    BOOLEAN fInQuote = FALSE;
    DWORD dwState = 0;
    CString strOutput;
    WCHAR c[2];
    c[1] = '\0';    

    hr = strOutput.Init();
    DIREXG_BAIL_ON_FAILURE(hr);


    while (*szInput) {
        if (fInQuote) {
            if (*szInput == '"')
            {
                if ((*(szInput+1)) == '"') {
                    //
                    // Add both of them if they are '""'
                    //
                    c[0] = *szInput++;
                    strOutput.Append(c);
                }
                else {
                    fInQuote = FALSE;
                }
            }
        }
        else {
            if (*szInput == '"') {
                fInQuote = TRUE;
            }
            else if (*szInput == ','){
                if (*(szInput+1)) {
                    c[0] = *szInput++;
                    strOutput.Append(c);
                    strOutput.Append(L"&");             
                    strOutput.Append(g_szReturn);
                    continue;
                }
                else {
                    c[0] = *szInput++;
                    strOutput.Append(c);
                    continue;
                }
            }
        }
        
        c[0] = *szInput++;
        strOutput.Append(c);
    }

    hr = strOutput.GetCopy(pszOutput);
error:
    return hr;
}

__inline ULONG SCNameHash(ULONG size, PWCHAR pVal, ULONG count)
{
    ULONG val=0;
    while(size--) {
        // Map A->a, B->b, etc.  Also maps @->', but who cares.
        val += (*pVal | 0x20);
        pVal++;
    }
    return (val % count);
}


int 
SCGetAttByName(
        ULONG ulSize,
        PWCHAR pVal
        )
/*++

Routine Description:

    Find an attcache given its name.

Arguments:
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppAttcache - the attribute cache returned

Return Value:
    Returns non-zero if exist, 0 otherwise.

--*/
{
    ULONG i;

    if (!g_BacklinkHashTable) {
        return FALSE;
    }

    i = SCNameHash(ulSize,pVal,g_nBacklinkCount);
    if (i >= g_nBacklinkCount) {
        // should never happen (SCNameHash should always return a value
        // of i that's in range)
        i=0;
    }

    while ((g_BacklinkHashTable[i].bUsed &&            // this hash spot refers to an object,
          ((g_BacklinkHashTable[i].length != ulSize * sizeof(WCHAR))|| // but the size is wrong
           _memicmp(g_BacklinkHashTable[i].value,pVal,ulSize* sizeof(WCHAR))))) // or the value is wrong
    {

        i++;
        
        if (i >= g_nBacklinkCount) {
            i=0;
        }
    }
    
    return (g_BacklinkHashTable[i].bUsed);
}


int 
SCInsert(
        ULONG ulSize,
        PWCHAR pVal
        )
/*++

Routine Description:

    Find an attcache given its name.

Arguments:
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppAttcache - the attribute cache returned

Return Value:
    Returns TRUE if successfull, return 0 if duplicate

--*/
{ 
    ULONG i = SCNameHash(ulSize,pVal,g_nBacklinkCount);

    if (i >= g_nBacklinkCount) {
        // should never happen (SCNameHash should always return a value
        // of i that's in range)
        i=0;
    }

    while (g_BacklinkHashTable[i].bUsed)
    {
        if ((g_BacklinkHashTable[i].length == (ulSize* sizeof(WCHAR))) && 
            (_memicmp(g_BacklinkHashTable[i].value,pVal,(ulSize* sizeof(WCHAR))) == 0)) {
            return FALSE;   
        }

        i++;

        if (i >= g_nBacklinkCount) {
            i=0;
        }
    }
    
    g_BacklinkHashTable[i].length = (ulSize* sizeof(WCHAR));
    g_BacklinkHashTable[i].value = (PWSTR)MemAlloc(ulSize* sizeof(WCHAR));
    if (!g_BacklinkHashTable[i].value) {
        return FALSE;
    }

    memcpy(g_BacklinkHashTable[i].value,
           pVal,
           ulSize* sizeof(WCHAR));

    g_BacklinkHashTable[i].bUsed = TRUE;

    return TRUE;
}


//+---------------------------------------------------------------------------
// Function:    CreateBacklinkTable
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    31-1-98   Felix Wong Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR CreateOmitBacklinkTable(LDAP *pLdap, 
                                   PWSTR *rgszOmit,
                                   DWORD dwFlag,
                                   PWSTR *ppszNamingContext,
                                   BOOL *pfPagingAvail,
                                   BOOL *pfSAMAvail)
{
    LDAPMessage     *pSearchMessage = NULL;
    LDAPMessage     *pMessage = NULL;
    struct berelement *pBerElement = NULL;
    PWSTR *rgszValue = NULL;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    ULONG nCount = 0;
    PWSTR szTemp = NULL;
    PWSTR szAttribute = NULL;
    ULONG i;
    NAME_MAP    NtiElem;
    BOOLEAN bNewElem;
    ULONG iLinkID = 0;
    PWSTR szLinkCN = NULL;
    PWSTR szSchemaPath = NULL;
    BOOLEAN bNamingContext = (BOOLEAN)(dwFlag & INIT_NAMINGCONTEXT);
    BOOLEAN bBacklink = (BOOLEAN)(dwFlag & INIT_BACKLINK);
    BOOL fPagingAvail = FALSE;
    BOOL fSAMAvail = FALSE;

    //
    // Generating OMIT table
    //
    g_pOmitTable = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!g_pOmitTable) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    RtlInitializeGenericTable(g_pOmitTable, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    
    if (rgszOmit) {
        i = 0;
        while(rgszOmit[i]) {
            NtiElem.szName = MemAllocStrW(rgszOmit[i]);
            if (!NtiElem.szName) {
                hr = DIREXG_OUTOFMEMORY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            NtiElem.index = 0;
            RtlInsertElementGenericTable(g_pOmitTable,
                                         &NtiElem,
                                         sizeof(NAME_MAP), 
                                         &bNewElem);
            if (!bNewElem) {
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            i++;
        }
    }
    
    //
    // We search rootdse either we search for backlinks, need to get the 
    // base context, or if we need to check whether paging is available or not
    //
    if (bBacklink || bNamingContext || pfPagingAvail) {
        if ( (ldap_search_s(pLdap, 
                           NULL, 
                           LDAP_SCOPE_BASE, 
                           L"(objectClass=*)", 
                           rgszSchemaList,  
                           0, 
                           &pSearchMessage))!= LDAP_SUCCESS ) {
            //
            // RootDSE search fails
            // pfPagingAvail will be FALSE as well
            //
            if (ppszNamingContext)
                *ppszNamingContext = NULL;
            BAIL();         
        }
        
        for ( pMessage = ldap_first_entry( pLdap, 
                                           pSearchMessage ); 
              pMessage != NULL; 
              pMessage = ldap_next_entry( pLdap, 
                                             pMessage ) ) { 
            for (   szAttribute = ldap_first_attribute( pLdap, pMessage, &pBerElement );
                    szAttribute != NULL;
                    szAttribute = ldap_next_attribute( pLdap, pMessage, pBerElement ) ) {
                 
                    rgszValue = ldap_get_values(pLdap, pMessage, szAttribute );
                    if (rgszValue == NULL) {
                        hr = DIREXG_ERROR;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                    if (_wcsicmp(L"schemaNamingContext",szAttribute) == 0) {
                        szSchemaPath =MemAllocStrW(rgszValue[0]);
                        if (!szSchemaPath) {
                            hr = DIREXG_OUTOFMEMORY;
                            DIREXG_BAIL_ON_FAILURE(hr);
                        }
                    }
                    else if (_wcsicmp(L"defaultNamingContext",szAttribute) == 0) {
                        (*ppszNamingContext)=(PWSTR )MemAllocStrW(rgszValue[0]);
                        if (!(*ppszNamingContext)) {
                            hr = DIREXG_OUTOFMEMORY;
                            DIREXG_BAIL_ON_FAILURE(hr);
                        }
                    }
                    else if (_wcsicmp(L"supportedControl",szAttribute) == 0) {
                        DWORD i = 0;
                        while (rgszValue[i]) {
                            if (wcscmp(rgszValue[i],LDAP_PAGED_RESULT_OID_STRING_W) == 0) {
                                fPagingAvail = TRUE;
                                break;
                            }
                            i++;
                        }
                    }
                    else {
                        hr = DIREXG_ERROR;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                    ldap_value_free(rgszValue );
                    rgszValue = NULL;
            }
        }
    
        if (pSearchMessage) {
            ldap_msgfree(pSearchMessage);
            pSearchMessage = NULL;
        }
    }

    if (bBacklink) {
        if ( (ldap_search_s(pLdap, 
                           szSchemaPath,
                           LDAP_SCOPE_ONELEVEL, 
                           L"(&(objectClass= attributeSchema)(|(linkid=*)(attributeSyntax=2.5.5.1)))", 
                           rgszAttrList,  
                           0, 
                           &pSearchMessage))!= LDAP_SUCCESS ) {
            BAIL();         
        }
        MemFree(szSchemaPath);
        szSchemaPath = NULL;
        
        nCount = ldap_count_entries(pLdap,
                                    pSearchMessage);
        nCount *= 2;
        
        g_nBacklinkCount = nCount;
        if (nCount == 0) {
            g_BacklinkHashTable = NULL;
        }
        else {
            g_BacklinkHashTable = (HASHCACHESTRING*)MemAlloc(g_nBacklinkCount * sizeof(HASHCACHESTRING));     
            if (!g_BacklinkHashTable) {
                hr = DIREXG_OUTOFMEMORY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            memset(g_BacklinkHashTable,0,g_nBacklinkCount * sizeof(HASHCACHESTRING));
        }

        if (SCInsert(wcslen(g_szPrimaryGroup),
                     g_szPrimaryGroup) == FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        for ( pMessage = ldap_first_entry( pLdap, 
                                              pSearchMessage ); 
              pMessage != NULL; 
              pMessage = ldap_next_entry( pLdap, 
                                             pMessage ) ) { 

            BOOLEAN bLinkIDPresent = FALSE;
            szLinkCN = NULL;
            for (   szAttribute = ldap_first_attribute( pLdap, pMessage, &pBerElement );
                    szAttribute != NULL;
                    szAttribute = ldap_next_attribute( pLdap, pMessage, pBerElement ) ) {
                rgszValue = ldap_get_values(pLdap, pMessage, szAttribute );
                if (rgszValue == NULL) {
                    hr = DIREXG_ERROR;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!_wcsicmp(L"ldapdisplayname",szAttribute)) {
                    szLinkCN = MemAllocStrW(rgszValue[0]);
                    if (!szLinkCN) {
                        hr = DIREXG_OUTOFMEMORY;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                }
                else {
                    szTemp = MemAllocStrW(rgszValue[0]);
                    if (!szTemp) {
                        hr = DIREXG_OUTOFMEMORY;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                    iLinkID = _wtoi(szTemp);
                    MemFree(szTemp);
                    szTemp = NULL;
                    bLinkIDPresent = TRUE;
                }
                ldap_value_free(rgszValue);
                rgszValue = NULL;
            }
            if (!szLinkCN) {
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            //
            // If it is not a linked ID (and thus a DN type attribute) or if it
            // is the source linked ID (source linked ID are even while
            // targets are odd)
            //
            if (((!bLinkIDPresent) || ((iLinkID % 2) == 0))) {
                //
                // Ignore 'distinguishname and objectcategory' because they are
                // DN attributes that exist in every object
                //
                if ((wcscmp(szLinkCN, L"objectCategory") == 0) ||
                    (wcscmp(szLinkCN, L"distinguishedName") == 0)) {
                    MemFree(szLinkCN);
                    szLinkCN = NULL;
                    continue;
                }

                //
                // Insert into Backlink Hash
                //
                if (SCInsert(wcslen(szLinkCN),
                             szLinkCN) == FALSE) {
                        hr = DIREXG_ERROR;
                        DIREXG_BAIL_ON_FAILURE(hr);
                }
                MemFree(szLinkCN);
                szLinkCN = NULL;
            }
            else {
                //
                // Insert into our Omit Table
                //
                NtiElem.szName = szLinkCN;
                NtiElem.index = 0;
                RtlInsertElementGenericTable(g_pOmitTable,
                                             &NtiElem,
                                             sizeof(NAME_MAP), 
                                             &bNewElem);
                if (!bNewElem) {
                    hr = DIREXG_ERROR;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                szLinkCN = NULL;
            }
        }
            
        if (pSearchMessage) {
            ldap_msgfree(pSearchMessage);
            pSearchMessage = NULL;
        }
        fSAMAvail = TRUE;
    }

    i = 0;
    while(g_rgszOmit[i]) {
        NtiElem.szName = MemAllocStrW(g_rgszOmit[i]);
        if (!NtiElem.szName) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        NtiElem.index = 0;
        RtlInsertElementGenericTable(g_pOmitTable,
                                     &NtiElem,
                                     sizeof(NAME_MAP), 
                                     &bNewElem);
                    //
                    // If there is a duplicate entry already
                    //
        if (!bNewElem) {
                            MemFree(NtiElem.szName);
        }
        i++;
    }

error:
    if (rgszValue) {
        ldap_value_free(rgszValue);
        rgszValue = NULL;
    }
    if (szLinkCN) {
        MemFree(szLinkCN);
    }
    if (pSearchMessage) {
        ldap_msgfree(pSearchMessage);
    }
    if (szTemp) {
        MemFree(szTemp);
    }
    if (szSchemaPath) {
        MemFree(szSchemaPath);
    }
    if (pfPagingAvail) {
        *pfPagingAvail = fPagingAvail;
    }
    if (pfSAMAvail) {
        *pfSAMAvail = fSAMAvail;
    }
    return hr;

}

DIREXG_ERR 
ConvertUTF8ToUnicode(
    PBYTE pVal,
    DWORD dwLen,
    PWSTR *pszValue,
    DWORD *pdwLen
    )

/*++

Routine Description:

    Convert a Value from the Ansi syntax to Unicode

Arguments:

    *ppVal - pointer to value to convert
    *pdwLen - pointer to length of string in bytes

Return Value:

    S_OK on success, error code otherwise

--*/

{
    HRESULT hr = S_OK;
    PWSTR pszUnicode = NULL;
    int nReturn = 0;

    //
    // Allocate memory for the Unicode String
    //
    pszUnicode = (PWSTR)MemAlloc((dwLen + 1) * sizeof(WCHAR));
    if (!pszUnicode) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    nReturn = LdapUTF8ToUnicode((PSTR)pVal,
                                dwLen,
                                pszUnicode,
                                dwLen + 1);

    //
    // NULL terminate it
    //

    pszUnicode[nReturn] = '\0';

    *pszValue = pszUnicode;
    *pdwLen = (nReturn + 1) * sizeof(WCHAR);

error:
    return hr;
}


#define BIT7(a)           ((a) & 0x80)
#define BIT6(a)           ((a) & 0x40)


BOOLEAN IsUTF8String(
    PCSTR pSrcStr,
    int cchSrc
    )

/*++

Routine Description:

    Given a string, this function checks whether it is a valid UTF8 String. 
    For details about the UTF8 format, please refer to rfc2279.

Arguments:
    pSrcStr - input string
    cchSrc - number of bytes    

Return Value:

    Whether this is a UTF8 string or not

--*/

{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    PCSTR pUTF8 = pSrcStr;
    char UTF8;


    while (cchSrc--)
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //

            //
            // If we are expecting trailing bytes, this is probably an invalid
            // utf8 string
            //
            if (nTB > 0) {
                return FALSE;
            }
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;
            }
            else {
                //
                // Found a trail byte with no leading byte
                //
                return FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                return FALSE;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                if (nTB>3) {
                    return FALSE;
                }
                //
                //  decrement the number of bytes to follow.
                //
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    // We are still expecting trailing bytes, but we can't find any
    //
    if (nTB > 0) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\clntutl\src\thrdmgr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       thrdmgr.cxx
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : thrdmgr.cpp
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 9/17/1996
*    Description : declaration of SvrType class
*
*    Revisions   : <date> <name> <description>
*                         7/29/97 eyals      general fix bugs & clean up
*******************************************************************/



#ifndef THRDMGR_CXX
#define THRDMGR_CXX



// include //
#include "helper.h"
#include "ThrdMgr.hxx"


// defines //
#define ABORT_LOOP_LIMIT            100


// types //



///////////////////////////////////////////////////////
//
// class ThrdMgr: base object defintion
//



/*+++
Function   : constructor
Description:
Parameters :
Return     :
Remarks    : none.
---*/
ThrdMgr::ThrdMgr(void){

	dprintf(DBG_FLOW, _T("[ThrdMgr] constructor entry"));
	m_hThrd = NULL;
	m_dwThrd = (ULONG)-1;
	m_bRunning = FALSE;

}





/*+++
Function   : destructor
Description:
Parameters :
Return     :
Remarks    : none.
---*/
ThrdMgr::~ThrdMgr(void){

	DWORD cnt = 0, dwId=0;
	//
	// release thread if paused
	//

	dprintf(DBG_FLOW, _T("[ThrdMgr] destructor entry"));
	while(m_hThrd != NULL && (dwId = resumeThread()) > 1 && dwId != 0xFFFFFFFF){
		if(cnt++ > ABORT_LOOP_LIMIT){
			dprintf(DBG_ERROR, _T("[ThrdMgr::~ThrdMgr] Error: Infinite loop trapped"));
			TerminateThread(m_hThrd, 0xffffffff);
   		m_bRunning = FALSE;
         CloseHandle(m_hThrd);
			m_hThrd = NULL;
			break;
		}
	}
	//
	// Now Tell thread that it's time to quit, & wait for it
	//
	if(m_hThrd != NULL){
		WaitForThread();
		m_bRunning = FALSE;     // just to make sure it is set appropriately.
      m_hThrd = NULL;
	}

}








/*+++
Function   : startThread
Description: Start the thread execution
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ThrdMgr::startThread(void){

	m_hThrd= CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)threadFunc, this, 0, &m_dwThrd);
	dprintf(DBG_FLOW, _T("[ThrdMgr] forked thread 0x%x"), m_dwThrd);
   return (m_hThrd != NULL ? TRUE : FALSE);

}



/*+++
Function   : pauseThread
Description: pauses the thread
Parameters :
Return     :
Remarks    : none.
---*/
void ThrdMgr::pauseThread(void){

	DWORD dwRet;
	if(m_hThrd != NULL){
		dprintf(DBG_FLOW, _T("[ThrdMgr] suspended thread 0x%x"), m_hThrd);
		dwRet = SuspendThread(m_hThrd);
      if(dwRet != 0xFFFFFFFF){
         m_bRunning = FALSE;
      }
      else
         dprintf(DBG_WARN, _T("[ThrdMgr] SuspendThread returned error 0x%X.\n"), GetLastError());
	}
	else
		dprintf(DBG_WARN, _T("[ThrdMgr] attempt to suspend an unavailable thread"));
	dprintf(DBG_FLOW, _T("[ThrdMgr] paused"));

}





/*+++
Function   : resumeThread
Description: resume thread execution
Parameters :
Return     :
Remarks    : none.
---*/
DWORD ThrdMgr::resumeThread(void){

	DWORD dwRet = 0;
	if(m_hThrd != NULL){
		dprintf(DBG_FLOW, _T("[ThrdMgr] resumed thread 0x%x"), m_hThrd);
		dwRet = ResumeThread(m_hThrd);
      if(dwRet != 0xFFFFFFFF){
         m_bRunning = TRUE;
      }
      else
         dprintf(DBG_WARN, _T("[ThrdMgr] ResumeThread failed. 0x%X\n"), GetLastError());
	}
	else
		dprintf(DBG_WARN, _T("[ThrdMgr] attempt to resume an unavailable thread"));
	dprintf(DBG_FLOW, _T("[ThrdMgr] resumed"));

	return dwRet;
}




/*+++
Function   : WaitForThread
Description:  waits for thread to terminate.
Parameters :
Return     :
Remarks    : Note that we close the handle as well.
---*/
DWORD ThrdMgr::WaitForThread(DWORD dwTimeout){

   DWORD dwRet = WaitForSingleObject(m_hThrd, dwTimeout);
   CloseThread();
   return(dwRet);

}







/*+++
Function   : threadFunc
Description: callback function to CreateThread
Parameters : pointer to calling class
Return     :
Remarks    : none.
---*/
DWORD __stdcall threadFunc(LPVOID lpParam){


	ThrdMgr *obj = (ThrdMgr *)lpParam;
	BOOL bRet = TRUE;

					
	if(obj != NULL){
		dprintf(DBG_FLOW, _T("[ThrdMgr!threadFunc] Starting thread '%s'"), obj->name());
      obj->SetRunning(TRUE);
		bRet = obj->run();
      obj->SetRunning(FALSE);
	}
	else{
		dprintf(DBG_ERROR, _T("[ThrdMgr!threadFunc] Error: Invalid ThrdMgr"), obj->name());
		bRet = FALSE;
	}

	dprintf(DBG_FLOW, _T("[ThrdMgr!threadFunc] Terminating thread '%s'"), obj->name());

	return bRet;
}




#endif




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\csvds\samcheck.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    samcheck.cxx

ABSTRACT:

DETAILS:
    
CREATED:

    09/02/97    Felix Wong (felixw)

REVISION HISTORY:

--*/


#include "csvde.hxx"
#pragma hdrstop
#include "samrestrict.h"

PRTL_GENERIC_TABLE g_pSpecial = NULL;

//+---------------------------------------------------------------------------
// Function:    CreateSamTables
//
// Synopsis:    
//    The goal of this routine is to set up the tables necessary for the SAM
//    exclusions. These tables are generated form the arrays found in
//    samrestrict.h, which are PAINFULLY hand generated from 
//    src\dsamain\src\mappings.c 
//    The pointers to the tables are also declared in samrestrict.h.
//    There are 6 tables that the lookup functions will need. One if for 
//    samCheckObject() to check whether the objectClass in LL_ldap_parse() is 
//    one under our watch. The remaining 5 are for each of the objects so that 
//    samCheckAttr() can find out whether the attribute we want to add is on 
//    the prohibited list. Called from LL_init()
//
// Arguments:   
//    None. We access the tables and variables in samrestrict.h  
//
// Returns:     
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR CreateSamTables() {
    long i;
    NAME_MAP    NameMap;
    PNAME_MAP   pNameMap = NULL;
    PNAME_MAP   pNameMapT = NULL;
    BOOLEAN     fNewElem;
    DIREXG_ERR     hr = DIREXG_SUCCESS;
    
    //
    // Objects specially considered for SAM operation
    //
    pSamObjects = (PRTL_GENERIC_TABLE)MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pSamObjects) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pSamObjects, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszSamObjects[i]) {
        NameMap.szName = g_rgszSamObjects[i];
        NameMap.index = i+1;
        RtlInsertElementGenericTable(pSamObjects,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }
 
    
    //
    // Objects specially considered for SAM Server 
    //
    pServerAttrs = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pServerAttrs) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pServerAttrs, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszServerSAM[i]) {
        NameMap.szName=g_rgszServerSAM[i];
        NameMap.index=0;
        RtlInsertElementGenericTable(pServerAttrs,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }

    //
    // Objects specially considered for Domain
    //
    pDomainAttrs = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pDomainAttrs) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pDomainAttrs, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszDomainSAM[i]) {
        NameMap.szName = g_rgszDomainSAM[i];
        NameMap.index = 0;
        RtlInsertElementGenericTable(pDomainAttrs,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }

    //
    // Objects specially considered for Group
    //
    pGroupAttrs = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pGroupAttrs) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pGroupAttrs, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszGroupSAM[i]) {
        NameMap.szName = g_rgszGroupSAM[i];
        NameMap.index = 0;
        RtlInsertElementGenericTable(pGroupAttrs,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }

    //
    // Objects specially considered for Local Group
    //
    pLocalGroupAttrs = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pLocalGroupAttrs) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pLocalGroupAttrs, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszLocalGroupSAM[i]) {
        NameMap.szName = g_rgszLocalGroupSAM[i];
        NameMap.index = 0;
        RtlInsertElementGenericTable(pLocalGroupAttrs,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }
    
    //
    // Objects specially considered for User
    //
    pUserAttrs = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pUserAttrs) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pUserAttrs, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszUserSAM[i]) {
        NameMap.szName = g_rgszUserSAM[i];
        NameMap.index = 0;
        RtlInsertElementGenericTable(pUserAttrs,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }

    g_pSpecial = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!g_pSpecial) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    RtlInitializeGenericTable(g_pSpecial, NtiComp, NtiAlloc, NtiFree, NULL);
    
    //
    // Objects specially considered for special
    //
    i = 0;
    while(g_rgszSpecialClass[i]) {
        NameMap.szName = g_rgszSpecialClass[i];
        NameMap.index = g_rgAction[i];  
        if (NameMap.index==0) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        RtlInsertElementGenericTable(g_pSpecial,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }
error:
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    DestroySamTables
//
// Synopsis:    
//    Destroy the tables created by CreateSamTables()
//    called from LL_end().
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
void DestroySamTables() {
    
     PNAME_MAP   pNameMap = NULL;
     
     if (pSamObjects) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pSamObjects, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pSamObjects, TRUE)) 
        {
            RtlDeleteElementGenericTable(pSamObjects, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pSamObjects)==FALSE) {
        }   
            
        MemFree(pSamObjects);
        pSamObjects = NULL;
     }

     if (pServerAttrs) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pServerAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pServerAttrs, TRUE)) 
        {
            RtlDeleteElementGenericTable(pServerAttrs, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pServerAttrs)==FALSE) {
        }   
            
        MemFree(pServerAttrs);
        pServerAttrs = NULL;
     }

     if (pDomainAttrs) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pDomainAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pDomainAttrs, TRUE)) 
        {
            RtlDeleteElementGenericTable(pDomainAttrs, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pDomainAttrs)==FALSE) {
        }   
            
        MemFree(pDomainAttrs);
        pDomainAttrs=NULL;
     }
 
     if (pGroupAttrs) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pGroupAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pGroupAttrs, TRUE)) 
        {
          RtlDeleteElementGenericTable(pGroupAttrs, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pGroupAttrs)==FALSE) {
        }   
            
        MemFree(pGroupAttrs);
        pGroupAttrs=NULL;
     }

     if (pLocalGroupAttrs) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pLocalGroupAttrs, 
                                                            TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pLocalGroupAttrs, 
                                                            TRUE)) 
        {
            RtlDeleteElementGenericTable(pLocalGroupAttrs, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pLocalGroupAttrs)==FALSE) {
        }   
            
        MemFree(pLocalGroupAttrs);
        pLocalGroupAttrs=NULL;
     }
 
     if (pUserAttrs) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pUserAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pUserAttrs, TRUE)) 
        {
            RtlDeleteElementGenericTable(pUserAttrs, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pUserAttrs)==FALSE) {
        }   
            
        MemFree(pUserAttrs);
        pUserAttrs=NULL;
     }

     if (g_pSpecial) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(g_pSpecial, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(g_pSpecial, TRUE)) 
        {
            RtlDeleteElementGenericTable(g_pSpecial, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(g_pSpecial)==FALSE) {
        }   
            
        MemFree(g_pSpecial);
        g_pSpecial=NULL;
     }
}

//+---------------------------------------------------------------------------
// Function:    CheckObjectSam
//
// Synopsis:    
//  CheckObjectSam() - this function will be called 
//  from LL_ldap_parse() to determine whether the
//  object we are looking at is on our sam watch list.
//
// Arguments:   
//  class - a value of the objectClass attribute.
//          This function will be called 
//          on every value of objectClass received to 
//          determine whether this object or any of its
//          ancestors are on our watch list.
//
// Returns:     
//          0 if the object was not found
//          or 1-5 indicating which table samCheckAttr()
//          should look at it. This number was set by CreateSamTables()
//          in the index member of the table entry.
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
int CheckObjectSam(PWSTR szObjectClass) 
{
    NAME_MAP    NameMap;
    PNAME_MAP   pElemTemp = NULL;

    NameMap.szName = szObjectClass;
    NameMap.index = 0; 

    pElemTemp = (PNAME_MAP)RtlLookupElementGenericTable(pSamObjects, 
                                                        &NameMap);

    if (pElemTemp) {
        return pElemTemp->index;
    } 
    else {
        return 0;
    }
}

//+---------------------------------------------------------------------------
// Function:    CheckObjectSpecial
//
// Synopsis:    
//       to determine whether the object we are looking at is on 
//       our special list.
//
// Arguments:   
//    class - a value of the objectClass attribute.
//            This function will be called 
//            on every value of objectClass received to 
//            determine whether this object or any of its
//            ancestors are on our list.
//
// Returns:     
//       0 if the object was not found
//       or the action code. (defined in samrestrict.h)
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
int CheckObjectSpecial(PWSTR szObjectClass) 
{
    NAME_MAP    NameMap;
    PNAME_MAP   pElemTemp = NULL;

    NameMap.szName = szObjectClass;
    NameMap.index = 0; 

    pElemTemp = (PNAME_MAP)RtlLookupElementGenericTable(g_pSpecial, 
                                                        &NameMap);

    if (pElemTemp) {
        return pElemTemp->index;
    } else {
        return 0;
    }
}

//+---------------------------------------------------------------------------
// Function:    CheckAttrSam
//
// Synopsis:    
//      Given the number of the table to look at and
//      an attribute name, this function will figure out
//      if the attribute is on the L"no-no" list. This function 
//      gets the number returned by CheckObjectSam();
//
// Arguments:   
//      attribute: the name of the attrbiute to look up
//      table:     the number of the table to look at
//
// Returns:     
//      TRUE  - this attrbiute is prohibited
//      FALSE - this attribute is allowed
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
BOOL CheckAttrSam(PWSTR szAttribute, int table) {
    
    NAME_MAP    NameMap;
    PNAME_MAP   pNameMapT;

    NameMap.szName = szAttribute;
    NameMap.index = 0; //and it doesn't really matter what we set this to

    switch(table) {
        case 1:   
            pNameMapT = (PNAME_MAP)RtlLookupElementGenericTable(pServerAttrs, 
                                                                &NameMap);  
            break;
        case 2:   
            pNameMapT = (PNAME_MAP)RtlLookupElementGenericTable(pDomainAttrs, 
                                                                &NameMap);  
            break;
        case 3:   
            pNameMapT = (PNAME_MAP)RtlLookupElementGenericTable(pGroupAttrs, 
                                                                &NameMap);  
            break;
        case 4:   
           pNameMapT = (PNAME_MAP)RtlLookupElementGenericTable(pLocalGroupAttrs, 
                                                               &NameMap);  
            break;
        case 5:   
            pNameMapT = (PNAME_MAP)RtlLookupElementGenericTable(pUserAttrs, 
                                                                &NameMap);  
            break;
        default:  
            return FALSE;
    }

    if (pNameMapT) {
        return TRUE;
    } else {
        return FALSE;
    }

}

//+---------------------------------------------------------------------------
// Function:    Name to Index Function calls
//
// Synopsis:    
//      Lets use RTL_GENERIC_TABLE to improve the efficiency of nametable_op
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
PVOID NtiAlloc( RTL_GENERIC_TABLE *pTable, CLONG ByteSize )
{
    return(MemAlloc(ByteSize));
}

VOID NtiFree ( RTL_GENERIC_TABLE *pTable, PVOID pvBuffer )
{
    MemFree(pvBuffer);
}


RTL_GENERIC_COMPARE_RESULTS
NtiComp( PRTL_GENERIC_TABLE  pTable,
         PVOID               pvFirstStruct,
         PVOID               pvSecondStruct ) 
{
    PNAME_MAP pNameMap1 = (PNAME_MAP)pvFirstStruct;
    PNAME_MAP pNameMap2 = (PNAME_MAP)pvSecondStruct;
  
    PWSTR szName1 = pNameMap1->szName;
    PWSTR szName2 = pNameMap2->szName;
    
    int diff;

    diff = _wcsicmp(szName1, szName2);

    if (diff<0) {
        return GenericLessThan;
    } 
    else if (diff == 0) {
        return GenericEqual;
    } 
    else {
        return GenericGreaterThan;
    }
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\csvds\samrestrict.h ===
#ifndef _SAM_H
#define _SAM_H

/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    samrestrict.h

ABSTRACT:
    
    Ldap display names of SAM read-only attrbiutes.

DETAILS:

    We have the problem that if we export out SAM objects,
    we can't put them back in with all the attributes we 
    get because some of them are SAM read only.
    This header contains the read onlys listed by
    their ldapDisplayNames, for each Sam object type.  
    
    
CREATED:

    07/14/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/

/*
 * The server and domain are here only for completeness, its not actually
 * relevant and is not expected and won't work for import/export operations.
 */


//
// CLASS_SAM_SERVER, SampServerObjectType (ldapdisplayname: samServer) 
//
PWSTR g_rgszServerSAM[] = {
     L"revision",  //SAMP_FIXED_SERVER_REVISION_LEVEL, ATT_REVISION
     L"objectSid", //not in mappings.c, but still required!, ATT_OBJECT_SID
     NULL
};


//
// CLASS_SAM_DOMAIN, SampDomainObjectType (ldapdisplayname: domain) 
//
PWSTR g_rgszDomainSAM[] = {
    L"objectSid",                // SAMP_DOMAIN_SID, ATT_OBJECT_SID
    L"domainReplica",            // SAMP_DOMAIN_REPLICA, ATT_DOMAIN_REPLICA
    L"creationTime",             // SAMP_FIXED_DOMAIN_CREATION_TIME, 
                                // ATT_CREATION_TIME
    L"modifiedCount",            // SAMP_FIXED_DOMAIN_MODIFIED_COUNT,
                                // ATT_MODIFIED_COUNT
    L"modifiedCountAtLastProm",  // SAMP_FIXED_DOMAIN_MODCOUNT_LAST_PROMOTION, 
                                // ATT_MODIFIED_COUNT_AT_LAST_PROM
    L"nextRid",                  // SAMP_FIXED_DOMAIN_NEXT_RID, ATT_NEXT_RID
    L"serverState",              // SAMP_FIXED_DOMAIN_SERVER_STATE, 
                                // ATT_SERVER_STATE
    L"sAMAccountType",           // SAMP_DOMAIN_ACCOUNT_TYPE, 
                                // ATT_SAM_ACCOUNT_TYPE
    L"uASCompat",               // SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED,
                                //  ATT_UAS_COMPAT
    NULL
};


//
// CLASS_GROUP, SampGroupObjectType (ldapdisplayname: group) 
//
PWSTR g_rgszGroupSAM[] = {
    L"rid",                 // SAMP_FIXED_GROUP_RID, ATT_RID
    L"sAMAccountType",      // SAMP_GROUP_ACCOUNT_TYPE, ATT_SAM_ACCOUNT_TYPE
    L"objectSid",           // not in mappings.c, but still required!, 
                           // ATT_OBJECT_SID
    L"memberOf",            // SAMP_USER_GROUPS, ATT_MEMBER
    L"isCriticalSystemObject", // SAMP_FIXED_GROUP_IS_CRITICAL,
                               //  ATT_IS_CRITICAL_SYSTEM_OBJECT
    NULL
};


//
// CLASS_LOCALGROUP, SampAliasObjectType (ldapdisplayname: localGroup) 
//
PWSTR g_rgszLocalGroupSAM[] = {
    L"rid",                // SAMP_FIXED_ALIAS_RID, ATT_RID
    L"sAMAccountType",     // SAMP_ALIAS_ACCOUNT_TYPE, ATT_SAM_ACCOUNT_TYPE
    L"objectSid",          // not in mappings.c, but still required!, ATT_OBJECT_SID
    L"isCriticalSystemObject", // SAMP_FIXED_GROUP_IS_CRITICAL,
                               //  ATT_IS_CRITICAL_SYSTEM_OBJECT
    NULL
};


//
// CLASS_USER, SampUserObjectType (ldapdisplayname: user)
//
PWSTR g_rgszUserSAM[] = {
    L"memberOf",                // SAMP_USER_GROUPS, ATT_MEMBER
    L"dBCSPwd",                 // SAMP_USER_DBCS_PWD, ATT_DBCS_PWD
    L"ntPwdHistory",            // SAMP_USER_NT_PWD_HISTORY, ATT_NT_PWD_HISTORY
    L"lmPwdHistory",            // SAMP_USER_LM_PWD_HISTORY, ATT_LM_PWD_HISTORY
    L"lastLogon",               // SAMP_FIXED_USER_LAST_LOGON, ATT_LAST_LOGON
    L"lastLogoff",              // SAMP_FIXED_USER_LAST_LOGOFF, ATT_LAST_LOGOFF
    L"badPasswordTime",         // SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME, 
                               // ATT_BAD_PASSWORD_TIME
    L"rid",                     // SAMP_FIXED_USER_USERID, ATT_RID
    L"badPwdCount",             // SAMP_FIXED_USER_BAD_PWD_COUNT, 
                               // ATT_BAD_PWD_COUNT
    L"logonCount",              // SAMP_FIXED_USER_LOGON_COUNT, ATT_LOGON_COUNT
    L"sAMAccountType",          // SAMP_USER_ACCOUNT_TYPE, ATT_SAM_ACCOUNT_TYPE
    L"supplementalCredentials", // SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS,
                               // ATT_SUPPLEMENTAL_CREDENTIALS
    L"objectSid",               // not in mappings.c, but still required!, 
                               // ATT_OBJECT_SID
    L"pwdLastSet",
    L"isCriticalSystemObject",  // SAMP_FIXED_USER_IS_CRITICAL,
                                //  ATT_IS_CRITICAL_SYSTEM_OBJECT
    L"lastLogonTimestamp",      // SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP,
                                //  ATT_LAST_LOGON_TIMESTAMP
    NULL
};


PWSTR g_rgszSamObjects[] = {
    L"samServer",
    L"domain",
    L"group",
    L"localGroup",
    L"user",
    NULL
};
    
PRTL_GENERIC_TABLE pSamObjects=NULL;
PRTL_GENERIC_TABLE pServerAttrs=NULL;
PRTL_GENERIC_TABLE pDomainAttrs=NULL;
PRTL_GENERIC_TABLE pGroupAttrs=NULL;
PRTL_GENERIC_TABLE pLocalGroupAttrs=NULL;
PRTL_GENERIC_TABLE pUserAttrs=NULL;

/*Although not restricted to SAM type stuff 
 (but currently only used for such), 
 the two tables below list any objects that we must do special 
 outputting for and their associated special actions. 
 This will we setup into tables in the table creation
 function and used in LL_ldap_parse()*/

PWSTR g_rgszSpecialClass[] = {
    L"domain",
    L"group",
    L"localGroup",
    NULL
};


int g_rgAction[] = {
    S_MEM,
    S_MEM,
    S_MEM,
    0
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\csvds\lexer.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lexer.cxx

Abstract:
    
    Lexer for CSV

Author:

    Felix Wong [FelixW]    22-Jul-1997
    
++*/

#include "csvde.hxx"
#pragma hdrstop

extern DWORD g_cColumn;
extern BOOLEAN g_fBackwardCompatible;

CToken::CToken()
{
    m_szToken = NULL;
    m_dwMax = 0;
    m_dwCur = 0;
}   

DIREXG_ERR CToken::Init()
{
    m_szToken = (PWSTR)MemAlloc(sizeof(WCHAR) * MAX_TOKEN_LENGTH);
    if (!m_szToken) {
        return DIREXG_OUTOFMEMORY;
    }
    memset(m_szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);
    m_dwMax = MAX_TOKEN_LENGTH;
    m_dwCur = 0;
    return DIREXG_SUCCESS;
}

DIREXG_ERR CToken::Advance(WCHAR ch)
{
    if (m_dwCur >= m_dwMax) {
        PWSTR szTokenTemp = (PWSTR)MemAlloc(sizeof(WCHAR) * 
                                          (MAX_TOKEN_LENGTH+m_dwMax));
        if (!szTokenTemp) {
            return DIREXG_OUTOFMEMORY;
        }
        m_dwMax += MAX_TOKEN_LENGTH;
        memset(szTokenTemp, 0, sizeof(WCHAR) * m_dwMax);
        memcpy(szTokenTemp, m_szToken, m_dwCur);
        MemFree(m_szToken);
        m_szToken = szTokenTemp;
    }
    m_szToken[m_dwCur] = ch;
    m_dwCur++; 
    return DIREXG_SUCCESS;
}

DIREXG_ERR CToken::Backup()
{
    m_szToken[m_dwCur-1] = '\0';
    m_dwCur--; 
    return DIREXG_SUCCESS;
}

CToken::~CToken()
{
    if (m_szToken) {
        MemFree(m_szToken);
    }
}

//+---------------------------------------------------------------------------
// Function:    CLexer::CLexer
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer():
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
}

DIREXG_ERR CLexer::Init(FILE *pFile) 
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR szBuffer = NULL;

    if (!pFile) {
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    m_pFile = pFile;
    hr = GetLine(m_pFile,
                 &szBuffer);
    DIREXG_BAIL_ON_FAILURE(hr);
    if (!szBuffer) {
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if (_Buffer) {
        MemFree(_Buffer);
    }
    _Buffer = szBuffer;
    _ptr = _Buffer;
    m_fQuotingOn = FALSE;
error:
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    CLexer::~CLexer
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    if (_Buffer) {
        MemFree(_Buffer);
    }
}

//+---------------------------------------------------------------------------
// Function:    CLexer::GetNextToken
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
CLexer::GetNextToken(PWSTR *pszToken, LPDWORD pdwToken)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    WCHAR c;
    DWORD state = 0;
    BOOL fEscapeOn = FALSE;
    BOOL fHexOn = FALSE;
    CToken Token;
                    
    _dwEndofString = 0;

    hr = Token.Init();
    DIREXG_BAIL_ON_FAILURE(hr);

    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();

        switch (state) {
        
        case  0:
#ifdef SPANLINE_SUPPORT
            if (c == TEXT('&')) {
                NextLine();
                break;
            }
            else 
#endif
            if (c == TEXT(' ')) {
                break;
            }
            else if (c == TEXT('"')) {
                if (!m_fQuotingOn) {
                    m_fQuotingOn = TRUE;
                    state = 1;
                }
                else {
                    //
                    // L" is on, now we see another one. Since it is the 
                    // beginning of a token, it must be double L"", an 
                    // instring L". If it indicates the closing L", it would 
                    // have already been recognized by last token.
                    //
                    WCHAR cNext = NextChar();
                    if (cNext == TEXT('"')) {
                        hr = Token.Advance(c);
                        DIREXG_BAIL_ON_FAILURE(hr);
                        _dwLastTokenLength++;
                        state = 1;
                        break;
                    }
                    else {
                        hr = DIREXG_ERROR;
                        BAIL();
                    }
                }
            }
            else if (c == TEXT('\\')) {
                fEscapeOn = TRUE;
                state = 1;
            }
            else if (c == TEXT(';')) {
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
                *pdwToken = TOKEN_SEMICOLON;
                _dwLastToken = *pdwToken;
                goto done;
            }
            else if (c == TEXT(',') && (!m_fQuotingOn)) {
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                goto done;
            }
            else if (c == TEXT('X')) {
                WCHAR cNext = NextChar();
                if (cNext == TEXT('\'')) {
                    fHexOn = TRUE;
                }
                else {
                    hr = Token.Advance(c);
                    DIREXG_BAIL_ON_FAILURE(hr);
                    _dwLastTokenLength++;
                    PushbackChar();
                }
                state = 1;
                break;
            }else if (c == TEXT('\0') || c == TEXT('\n')){
                PWSTR szBuffer = NULL;
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                
                //
                // Try getting next line as well
                //
                hr = GetLine(m_pFile,
                             &szBuffer);
                DIREXG_BAIL_ON_FAILURE(hr);
                if (szBuffer) {
                    MemFree(_Buffer);
                    _Buffer = szBuffer;
                    _ptr = _Buffer;
                }
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
                goto done;
            }
            else {
                state = 1;
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
            }
            break;

        //
        // Deals with second character for identifiers/strings/hex
        //          
        case 1:
            if ((fEscapeOn || m_fQuotingOn) && 
                (c == TEXT('\n') || c == TEXT('\0'))) {
                hr = DIREXG_ERROR;
                BAIL();
            }
            if (fHexOn) {
                if ((c == TEXT('\n')) || (c == TEXT('\0')) || (c == TEXT(','))) {
                    // HEX is on, it must be closed by L"'"
                    hr = DIREXG_ERROR;
                    BAIL();
                }
                else if (c == TEXT('\'')) {
                    *pdwToken = TOKEN_HEX;
                    _dwLastToken = *pdwToken;
                    goto done;
                }
                else if ( ((c < TEXT('0')) || (c > TEXT('9'))) &&
                          ((c < TEXT('a')) || (c > TEXT('f'))) &&
                          ((c < TEXT('A')) || (c > TEXT('F'))) ) {
                    hr = DIREXG_ERROR;
                    BAIL();
                }
            }
            if (fEscapeOn) {
                // escape is on, get next WCHAR regardless of its value
                fEscapeOn = FALSE;
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            if (m_fQuotingOn) {
                //
                // If quoting is on, ignore these following characters
                //
            
                //
                // Only the secret backward compatible option is turned on,
                // we'll treat ';' inside quotes as a non-special character as
                // well. under the new format, quoting does not make special
                // characters non-special
                //
                if (c == TEXT(',') || (g_fBackwardCompatible && c == TEXT(';'))) {
                    hr = Token.Advance(c);
                    DIREXG_BAIL_ON_FAILURE(hr);
                    _dwLastTokenLength++;
                    break;
                }
                else if (c == TEXT('"')) {
                    // Single L" means the end of quote
                    // double L" means an actual L"
                    WCHAR cNext = NextChar();
                    if (cNext == TEXT('"')) {
                        hr = Token.Advance(c);
                        DIREXG_BAIL_ON_FAILURE(hr);
                        _dwLastTokenLength++;
                        break;
                    }
                    else {
                        PushbackChar();
                        m_fQuotingOn = FALSE;
                        *pdwToken = TOKEN_IDENTIFIER;
                        _dwLastToken = *pdwToken;
                        goto done;
                    }
                }
            }
#ifdef SPANLINE_SUPPORT
            if ((c == TEXT('&'))) {
                NextLine();
                break;
            }
            else 
#endif
            if (c == TEXT('\\')) {
                fEscapeOn = TRUE;
                break;
            }
            else if ((c == TEXT(';'))) {
                PushbackChar();
                if (!fHexOn) {
                    *pdwToken = TOKEN_IDENTIFIER;
                }
                else {
                    *pdwToken = TOKEN_HEX;
                }
                _dwLastToken = *pdwToken;
                goto done;
            }
            else if (c == TEXT('\n') || c == TEXT('\0') || c == TEXT(',')) {
                PushbackChar();
                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                goto done;
            }
            else {
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
                break;
            }
        
        default:
            hr = DIREXG_ERROR;
            BAIL();
        }
    }
done:
    *pszToken = MemAllocStrW(Token.m_szToken);
    if (!(*pszToken)) {
        return DIREXG_OUTOFMEMORY;
    }
    return DIREXG_SUCCESS;
error:
    if (hr == DIREXG_ERROR) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_SYNTAXATCOLUMN,g_cColumn);
    }
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    CLexer::NextChar
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    PWSTR szBuffer;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    
    if (_ptr == NULL || *_ptr == TEXT('\0')) {
        _dwEndofString = TRUE;
        return(TEXT('\0'));
    }

    //
    // We increment the column counter everytime right after we got a new
    // character
    //
    g_cColumn++;
    return(*_ptr++);
}


//+---------------------------------------------------------------------------
// Function:    CLexer::NextChar
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
CLexer::NextLine()
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR szBuffer = NULL;
    DWORD cchCurrent, cchNew, cchDistance;
    DWORD dwLength;
    PWSTR szNew = NULL;
    PWSTR szCheck = NULL;

    // 
    // Making sure that after the &, there is nothing, or else bail out
    //
    if (*_ptr != '\0') {
        szCheck = _ptr + 1;
        while (*szCheck != '\0') {
            if (*szCheck != ' ') {
                SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_CSVDE_LINECON);
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            szCheck++;
        }
    }

    hr = GetLine(m_pFile,
                 &szBuffer);
    DIREXG_BAIL_ON_FAILURE(hr);
    if (!szBuffer) {
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    cchDistance = (DWORD)(_ptr - _Buffer);
    cchCurrent = wcslen(_Buffer);
    cchNew = wcslen(szBuffer);
    
    // +1 for null-termination, -1 for '&'
    szNew = (PWSTR)MemAlloc(sizeof(WCHAR) * (cchCurrent + cchNew + 1));
    if (!szNew) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    wcscpy(szNew, _Buffer);
    dwLength = wcslen(szNew);
    szNew[dwLength-1] = '\0';
    wcscat(szNew, szBuffer);
    _ptr = szNew + cchDistance -1;
    MemFree(_Buffer);
    _Buffer = szNew;
error:
    if (szBuffer) {
        MemFree(szBuffer);
    }
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    CLexer::PushBackToken
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        return(DIREXG_SUCCESS);
    }
    _ptr -= _dwLastTokenLength;

    return(DIREXG_SUCCESS);
}


//+---------------------------------------------------------------------------
// Function:    CLexer::PushBackChar
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }

    //
    // We decrement the column count whenver we push back a character
    //
    g_cColumn--;
    _ptr--;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\csvds\main.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    main.cxx

ABSTRACT:

    The CSV Bulk Import/Export Utility

DETAILS:
    
CREATED:

    08/10/97       Felix Wong (felixw)

REVISION HISTORY:

--*/

#include "csvde.hxx"
#pragma hdrstop
#include <locale.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <dsrole.h>

//
// Global variables (necessary for printouts)
//
FILE *g_pFileLog = NULL;            // Status log
FILE *g_pFileErrorLog = NULL;       // Error log              
BOOLEAN g_fVerbose = FALSE;         // SelectivePrint needs this info
BOOLEAN g_fWriteLogs = FALSE;       // Should we write to csv.log and csv.err 
BOOLEAN g_fDot = FALSE;             // Info for Status Tracker
BOOLEAN g_fError = FALSE;
PWSTR g_szDefaultFilter = L"(objectClass=*)";
PWSTR g_szErrorFilename = NULL;

BOOLEAN g_fUnicode = FALSE;         // whether we are using UNICODE or not
BOOLEAN g_fBackwardCompatible = FALSE;

DWORD GetDCName(BOOLEAN fWritable, PWSTR *pszDCName);
BOOL GetPassword(PWSTR szBuffer, DWORD dwLength, DWORD *pdwLengthReturn);
#define     CR              0xD
#define     BACKSPACE       0x8
#define     NULLC           '\0'
#define     NEWLINE         '\n'

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   );

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   );


//+---------------------------------------------------------------------------
// Function: InitArgument    
//
// Synopsis: Initialization of Argument variables to default settings
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void InitArgument(ds_arg *pArg)
{
    pArg->dwPort = 389;
    pArg->szGenFile = NULL;    
    pArg->szFilename = NULL;
    pArg->szDSAName = NULL;
    pArg->szRootDN = NULL;
    pArg->szFilter = NULL;
    pArg->szFromDN = NULL;
    pArg->szToDN = NULL;
    pArg->attrList = NULL;
    pArg->omitList = NULL;
    pArg->dwScope = -1;
    pArg->creds.User = NULL;
    pArg->creds.Domain = NULL;
    pArg->creds.Password = NULL;
    pArg->fCopiedPassword = FALSE;
    pArg->fActive = TRUE;
    pArg->fSimple = FALSE;
    pArg->fExport = TRUE; 
    pArg->fVerbose = FALSE; 
    pArg->fSAM = FALSE;
    pArg->fErrorExplain = TRUE;
    pArg->fPaged = TRUE;
    pArg->fSkipExist = FALSE;
    pArg->fBinary = TRUE;
    pArg->fSpanLine = FALSE;
    pArg->szLocation = NULL;
    pArg->fUnicode = FALSE;
}         


//+---------------------------------------------------------------------------
// Function: FreeArgument   
//
// Synopsis: Free argument variables   
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void FreeArgument(ds_arg *pArg)
{
    if (pArg->szFromDN) {
        MemFree(pArg->szFromDN);
    }
    if (pArg->szToDN) {
        MemFree(pArg->szToDN);
    }
    if (pArg->attrList) {
        MemFree(pArg->attrList);
    }
    if (pArg->omitList) {
        MemFree(pArg->omitList);
    }
}




//+---------------------------------------------------------------------------
// Function:  Main  
//
// Synopsis: Main Program Entry
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
extern "C" int __cdecl wmain(
    IN  int     argc,
    IN  PWSTR  argv[]
)
{
    
    DIREXG_ERR hr = DIREXG_SUCCESS;
    LDAP    *pLdap = NULL;
    unsigned long err;
    ds_arg Argument;
    int error;
    VOID *data;
    PWSTR szLogfileName = NULL;
    PWSTR szDSAName = NULL;
    PWSTR pszPassword = NULL;
    
    setlocale(LC_ALL, "");
    // Specification ".OCP" have a side effect to fgetws()
    // Because, we are using ANSI input files, this is causing our call to fgetws()
    // to a German file to get back some strings incorrectly.
    // setlocale(LC_ALL, ".OCP");

    InitMem();
    InitArgument(&Argument);
    SetThreadUILanguage(0);
    
    hr = ProcessArgs(argc,
                     argv,
                     &Argument);
    DIREXG_BAIL_ON_FAILURE(hr);

    //
    // Setting up Logfile location
    //
    if (Argument.szLocation) {

        g_fWriteLogs = TRUE;
    
        CString str;
        hr = str.Init();
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(Argument.szLocation);
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(L"\\");
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(L"csv.log");
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.GetCopy(&szLogfileName); 
        DIREXG_BAIL_ON_FAILURE(hr);

        hr = str.Init();
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(Argument.szLocation);
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(L"\\");
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.Append(L"csv.err");
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = str.GetCopy(&g_szErrorFilename); 
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    else {
        szLogfileName = MemAllocStrW(L"csv.log");
        if (!szLogfileName) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        g_szErrorFilename = MemAllocStrW(L"csv.err");
        if (!g_szErrorFilename) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    if (g_fWriteLogs) {
        if ((g_pFileLog = _wfopen(szLogfileName , 
                                  L"wb")) == NULL) {
            SelectivePrint(PRT_STD,
                           MSG_CSVDE_UNABLEOPEN);
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        if(fputwc(UNICODE_MARK,
                  g_pFileLog)==WEOF) {
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Required by SelectivePrint
    //
    g_fVerbose = Argument.fVerbose;

    if (Argument.szDSAName == NULL) {
        DWORD dwError = GetDCName(!Argument.fExport, &szDSAName);
        if (dwError == 0) {
            Argument.szDSAName = szDSAName;
        }
        else {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_NODCAVAILABLE);
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    // If the user inputs '*', we'll get the password without 
    // echoing the output
    //
    
    if (Argument.creds.Password && 
        (wcscmp(Argument.creds.Password,L"*") == 0)) {
        WCHAR szBuffer[PWLEN+1];
        DWORD dwLength;

        SelectivePrint(PRT_STD,
                       MSG_CSVDE_GETPASSWORD,
                       Argument.szDSAName);

        if (GetPassword(szBuffer,PWLEN+1,&dwLength)) {
            pszPassword = MemAllocStrW_E(szBuffer);   
            SecureZeroMemory(szBuffer, sizeof(szBuffer));
            Argument.creds.Password = pszPassword;
            Argument.creds.PasswordLength = dwLength;
            Argument.fCopiedPassword = TRUE;
        }
        else {
            SelectivePrint(PRT_STD,
                           MSG_CSVDE_PASSWORDTOLONG,
                           Argument.szDSAName);
            SecureZeroMemory(szBuffer, sizeof(szBuffer));                           
            hr = ERROR_INVALID_PARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    
    //
    // CONNECTION section
    //
    SelectivePrint(PRT_STD|PRT_LOG,
                   MSG_CSVDE_CONNECT,
                   Argument.szDSAName);
    
    if ( (pLdap = ldap_open( Argument.szDSAName, 
                             Argument.dwPort )) == NULL )  {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_CONNECT_FAIL);
        hr = DIREXG_LDAP_CONNECT_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    data = (VOID*)LDAP_OPT_OFF;
    ldap_set_option( pLdap, LDAP_OPT_REFERRALS, &data );
    data = (VOID*)LDAP_VERSION3 ;
    ldap_set_option( pLdap, LDAP_OPT_VERSION, &data );

    if (Argument.creds.User) {
        if (Argument.fSimple) {  
            SelectivePrint(PRT_STD|PRT_LOG,
                           MSG_CSVDE_SIMPLEBIND,
                           Argument.creds.User);
            if ( (err=ldap_simple_bind_s( pLdap, 
                                          (PWSTR )Argument.creds.User, 
                                          (PWSTR )Argument.creds.Password)) 
                                                        != LDAP_SUCCESS ) {
                if (err != LDAP_INVALID_CREDENTIALS) {
                    //
                    // If it is not invalid crednetials, we'll fall to version
                    // 2 and try again
                    //
                    data = (VOID*)LDAP_VERSION2 ;
                    ldap_set_option( pLdap, LDAP_OPT_VERSION, &data );
                    if ( (err=ldap_simple_bind_s( pLdap, 
                                                  (PWSTR )Argument.creds.User, 
                                                  (PWSTR )Argument.creds.Password)) 
                                                                != LDAP_SUCCESS ) {
                        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                                       MSG_CSVDE_SIMPLEBINDRETURN, 
                                       ldap_err2string(err) );
                        hr = err;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                }
                else {
                    SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                                   MSG_CSVDE_SIMPLEBINDRETURN, 
                                   ldap_err2string(err) );
                    hr = err;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            }
        } 
        else { 
            SelectivePrint(PRT_STD|PRT_LOG,
                           MSG_CSVDE_SSPI,
                           Argument.creds.User,
                           Argument.creds.Domain);
            Argument.creds.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
            if ( (err=ldap_bind_s( pLdap, 
                                   NULL, 
                                   (PWSTR )&(Argument.creds), 
                                   LDAP_AUTH_SSPI)) != LDAP_SUCCESS ) {
                SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_CSVDE_SSPIRETURN, 
                               ldap_err2string(err) );
                hr = err;
                DIREXG_BAIL_ON_FAILURE(hr);
            }   
        } 
    }
    else {
        SelectivePrint(PRT_STD|PRT_LOG,
                       MSG_CSVDE_SSPILOCAL);
        if ( (err = ldap_bind_s( pLdap, 
                                 NULL, 
                                 NULL, 
                                 LDAP_AUTH_SSPI)) != LDAP_SUCCESS ) {
            SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_CSVDE_SSPILOCALRETURN, 
                            ldap_err2string(err) );
            hr = err;
            DIREXG_BAIL_ON_FAILURE(hr);
        }   
    }

    //
    // Destroy our copy of the password so it's not sitting around
    // in memory after we're done with it.  We only do this if we
    // made a copy of it --- if it's in the command-line buffer,
    // we can't do anything about it (and entering a password on the
    // command-line isn't very secure anyway).
    //
    if (Argument.fCopiedPassword && Argument.creds.Password) {
        SecureZeroMemory(Argument.creds.Password, wcslen(Argument.creds.Password)*sizeof(WCHAR));
    }


    
    //
    //  ACTION section
    //
    if (Argument.fExport) {
        hr = DSExport(pLdap, 
                      &Argument);
    } else {    
        hr = DSImport(pLdap, 
                      &Argument);
    }    
    
    //
    // Printing results
    //
    if (hr == DIREXG_SUCCESS) {
        SelectivePrint2(PRT_STD|PRT_LOG,
                        L"\r\n");
        SelectivePrint(PRT_STD|PRT_LOG,
                       MSG_CSVDE_COMPLETE);
    }
    else if (hr == DIREXG_OUTOFMEMORY) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_MEMERROR);
    }
    else {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROROCCUR);
    }

error:  

    if ((hr != ERROR_SUCCESS) && !g_fWriteLogs) {

        // Tell the user how to get the logs if an error occurred
        SelectivePrint(PRT_STD, MSG_CSVDE_NOLOGSWRITTEN);
    }

    if (pszPassword) {
        MemFree(pszPassword);
        pszPassword = NULL;
    }
    if (szDSAName) {
        MemFree(szDSAName);          
    }
    if (g_szErrorFilename) {
        MemFree(g_szErrorFilename);
    }
    if (szLogfileName) {
        MemFree(szLogfileName);
    }
    if (g_pFileLog) {
        fclose(g_pFileLog);
    }
    if (g_pFileErrorLog) {
        fclose(g_pFileErrorLog);
    }

    if (pLdap) {
        ldap_unbind(pLdap);
        pLdap = NULL;
    }
    FreeArgument(&Argument);
    DumpMemoryTracker();
    return(hr);
}


//+---------------------------------------------------------------------------
// Function:  ProcessArgs  
//
// Synopsis:  Process the Argument list passed into Main()  
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR 
ProcessArgs(
    int argc,
    PWSTR  argv[],
    ds_arg* pArg   
    )
{
    int i;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    BOOLEAN bCredentials = FALSE;
    BOOLEAN rgbUsed[26];
    int cKey;

    memset(rgbUsed,0,sizeof(BOOLEAN) * 26);

    if (argc == 1) {
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }


    for (i=1; i < argc; i++) {

        if ((argv[i][0] != '-') && (argv[i][0] != '/')) {
            SelectivePrint(PRT_STD,
                           MSG_CSVDE_BADARGUMENT,
                           argv[i]);
            hr = DIREXG_BADPARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
        cKey = argv[i][1];
        if ((cKey >= 'a') && (cKey <= 'z')) {
            cKey = _toupper(argv[i][1]);
        }
        if ((cKey >= 'A') && (cKey <= 'Z')) {
            if (rgbUsed[cKey-'A']) {
                SelectivePrint( PRT_STD,MSG_CSVDE_ARGUMENTTWICE, argv[i]);
                hr = DIREXG_BADPARAMETER;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            else {
                rgbUsed[cKey-'A'] = TRUE;
            }
        }
        else {
            SelectivePrint( PRT_STD,MSG_CSVDE_UNKNOWN);
            hr = DIREXG_BADPARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        switch (argv[i][1]) {

            case 'z':
            case 'Z':
                g_fBackwardCompatible = TRUE;
                break;

            case 'g':
            case 'G':
                pArg->fPaged = FALSE;
                break;

            case 'i':
            case 'I':
                pArg->fExport = FALSE;      
                break;

            case 'j':
            case 'J':
                if (++i >= argc) {
                    SelectivePrint( PRT_STD,MSG_CSVDE_INVALID_LOGFILE);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szLocation = argv[i];
                break;

            case 't':
            case 'T':
                if ((++i >= argc) || (!argv[i])) {
                    SelectivePrint( PRT_STD,MSG_CSVDE_INVALID_PARAM_PORT);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->dwPort = _wtoi(argv[i]);
                if (pArg->dwPort == 0) {
                    // If dwPort returns 0, we check whether it is really 0 or if it was
                    // a failure in _wtoi
                    if (wcscmp(argv[i],L"0") != 0) {
                        SelectivePrint( PRT_STD,MSG_CSVDE_INVALID_PARAM_PORT);
                        hr = DIREXG_BADPARAMETER;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                }
                break;
        
            case 'f':
            case 'F':
                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_FILENAME);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szGenFile = argv[i];
                pArg->szFilename = argv[i];
                break;
            
            case 's':
            case 'S':
                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_SERVERNAME);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szDSAName = argv[i];
                break;

            case 'v':
            case 'V':
                pArg->fVerbose = TRUE;
                break;

            case 'u':
            case 'U':
                pArg->fUnicode = TRUE;
                break;

            case '?':
                PrintUsage();       
                break;

            //
            // Export Parameters
            //

            case 'd':
            case 'D':
                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_ROOTDN);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szRootDN = argv[i];
                break;

            case 'r':
            case 'R':
                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_FILTER);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szFilter = argv[i];
                break;

            case 'p':
            case 'P':
                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_SCOPE);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_SCOPE);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                if (!_wcsicmp(argv[i], L"Base" ))
                    pArg->dwScope = LDAP_SCOPE_BASE;
                else if (!_wcsicmp(argv[i], L"OneLevel" ))
                    pArg->dwScope = LDAP_SCOPE_ONELEVEL;
                else if (!_wcsicmp(argv[i], L"Subtree" ))
                    pArg->dwScope = LDAP_SCOPE_SUBTREE;
                else {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_BADSCOPE);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                break;

            case 'c':
            case 'C':
            {
                PWSTR pszTrimmedString, pszBuffer;
                
                if ((i+2) >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_FROMDN);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                // the "from" value
                i++;
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_FROMDN);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                pszBuffer = MemAllocStrW(argv[i]);
                if (pszBuffer == NULL) {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszTrimmedString = RemoveWhiteSpaces(pszBuffer);
                pArg->szFromDN = MemAllocStrW(pszTrimmedString);
                if (pArg->szFromDN == NULL) {
                    MemFree(pszBuffer);            
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                MemFree(pszBuffer);


                // the "to" value
                i++;
                if (!argv[i]) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_FROMDN);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                pszBuffer = MemAllocStrW(argv[i]);
                if (pszBuffer == NULL) {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszTrimmedString = RemoveWhiteSpaces(pszBuffer);
                pArg->szToDN = MemAllocStrW(pszTrimmedString);
                if (pArg->szToDN == NULL) {
                    MemFree(pszBuffer);            
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                MemFree(pszBuffer);                
                break;
            }
            

            case 'l':
            case 'L':
            {
                PWSTR *rgszArgument = NULL;

                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_ATTR);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_ATTR);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                hr = GetAllEntries(argv[i],
                                   &rgszArgument);
                DIREXG_BAIL_ON_FAILURE(hr);

                pArg->attrList = rgszArgument;
                break;
            }

            case 'o':
            case 'O':
            {
                PWSTR *rgszArgument = NULL;

                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_ATTR2);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_ATTR2);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                hr = GetAllEntries(argv[i],
                                   &rgszArgument);
                DIREXG_BAIL_ON_FAILURE(hr);

                pArg->omitList = rgszArgument;
                break;
            }

            case 'm':
            case 'M':
                pArg->fSAM = TRUE;
                break;

            case 'n':
            case 'N':
                pArg->fBinary = FALSE;
                break;

#ifdef SPANLINE_SUPPORT
            case 'e':
            case 'E':
                pArg->fSpanLine = TRUE;
                break;
#endif

            //
            // Import Parameters
            //
            
            case 'k':
            case 'K':
                pArg->fSkipExist = TRUE;
                break;

            //
            // Credentials Establishment
            //
                
            case 'a':
            case 'A':
                if (bCredentials) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_DUPCRED);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                if ((i+2) >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_REQUSRDOMPWD);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                bCredentials = TRUE;
                pArg->fSimple = TRUE; 
                
                i++;
                pArg->creds.User = (PWSTR )argv[i];
                if (!pArg->creds.User) {
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.UserLength = wcslen(argv[i]);

                i++;
                pArg->creds.Password = (PWSTR )argv[i];
                if (!pArg->creds.Password) {
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.PasswordLength = wcslen(argv[i]);
                break;
            
            case 'b':
            case 'B':
                if (bCredentials) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_DUPCRED);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                if ((i+3) >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_REQUSRDOMPWD);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                bCredentials = TRUE;

                i++;
                pArg->creds.User = (PWSTR )argv[i];
                if (!pArg->creds.User) {
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.UserLength = wcslen(argv[i]);

                i++;
                pArg->creds.Domain = (PWSTR )argv[i];
                if (!pArg->creds.Domain) {
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.DomainLength = wcslen(argv[i]);
                
                i++;
                pArg->creds.Password = (PWSTR )argv[i];
                if (!pArg->creds.Password) {
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.PasswordLength = wcslen(argv[i]);
                break;
                
            //
            // Temporary Setting
            //
            /*
            case 'c':
            case 'C':
                pArg->fActive = FALSE;       
                break;
            */
            default:
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_UNKNOWN);
                hr = DIREXG_BADPARAMETER;
                DIREXG_BAIL_ON_FAILURE(hr);
        } 
    } 
        
    // 
    // Checking Mandatory Options
    //
    if (hr == DIREXG_SUCCESS) {
        if (!pArg->szFilename) {
            SelectivePrint(PRT_STD,
                           MSG_CSVDE_BADARG_REQFILE);
            hr = DIREXG_BADPARAMETER;
        }
        
        if (!pArg->fExport) {
            // Require for Import

            // Not Require
            if (pArg->szRootDN) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQROOTDN);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->szFilter) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQFILTER);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->dwScope != -1) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQSCOPE);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->fSAM) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQSAM);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->omitList) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQOMIT);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->attrList) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQATTR);
                hr = DIREXG_BADPARAMETER;
            }
            if (!pArg->fBinary) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQBINARY);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->fSpanLine) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQSPAN);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->fPaged == FALSE) { 
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQPAGE);
                hr = DIREXG_BADPARAMETER;
            }
        }
        else {
            // Require for Export
            if (!pArg->szFilter) {
                pArg->szFilter = g_szDefaultFilter;
            }
            if (pArg->dwScope == -1) {
                pArg->dwScope = LDAP_SCOPE_SUBTREE;
            }

            // Not Require
            if (pArg->fSkipExist) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQ_SKIP);
                hr = DIREXG_BADPARAMETER;
            }

        }
    }
error:  
    if (hr != DIREXG_SUCCESS) {
        PrintUsage();
    }
    return (hr);
}


//***************************
//  UTILITIES SECTION
//***************************

//+---------------------------------------------------------------------------
// Function:  RemoveWhiteSpaces  
//
// Synopsis:  Removes trailing and starting white spaces  
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
PWSTR
RemoveWhiteSpaces(
    PWSTR pszText)
{
    PWSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && isspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!isspace(*pChar))
            break;
        else
            *pChar = '\0';
    }
    return pszText;
}

//+---------------------------------------------------------------------------
// Function:  PrintUsage  
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void PrintUsage() {
    SelectivePrint(PRT_STD,
                   MSG_CSVDE_HELP);
}



//+---------------------------------------------------------------------------
// Function:   SelectivePrint 
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrint(
    DWORD dwTarget, DWORD messageID, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    WCHAR    messagebuffer[4096];
    va_list ap;
    DWORD dwSize;
    messagebuffer[0] = '\0';

    va_start(ap, messageID);

    if (FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, 
                      NULL, 
                      messageID, 
                      0, 
                      messagebuffer, 
                      4095, 
                      &ap) == 0) {
        DWORD WinError = GetLastError();
        ERR(("Format message failed with %d\n",WinError));
        BAIL();
    }
    dwSize = wcslen(messagebuffer);
    /*
    if (messagebuffer[dwSize-2] == '\r') {
            messagebuffer[dwSize-2] = '\n';
            messagebuffer[dwSize-1] = '\0';
    }
    */

    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_fwprintf(stdout,messagebuffer);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        My_fwprintf(stdout,messagebuffer);
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_fwprintf(stdout,messagebuffer);
    }

    if (g_fWriteLogs) {
        if (dwTarget & PRT_LOG) {
            fwprintf(g_pFileLog,messagebuffer);
        }
        if (dwTarget & PRT_ERROR) {
            if (!g_fError) {
                g_fError = TRUE;
            }
            if (!g_pFileErrorLog) {   // If log file is not opened
                if (!bTriedOpen) {          // If we haven't tried
                    if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                   L"wb")) == NULL) {
                        SelectivePrint(PRT_STD,
                                       MSG_CSVDE_UNABLEOPENERR);
                        bTriedOpen = TRUE;
                        goto error;
                    }
                    if(fputwc(UNICODE_MARK,
                              g_pFileErrorLog)==WEOF) {
                        goto error;
                    }
                }
                else {
                    goto error;
                }
            }
            fwprintf(g_pFileErrorLog,messagebuffer);
        }
    }
error:
    va_end(ap);
    return;
}


//+---------------------------------------------------------------------------
// Function:   SelectivePrint2
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrint2(
    DWORD dwTarget, PWSTR pszfmt, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    va_list args;
    va_start(args, pszfmt);

    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_vfwprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        My_vfwprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_vfwprintf(stdout,pszfmt,args);
    }

    if (g_fWriteLogs) {
        if (dwTarget & PRT_LOG) {
            vfwprintf(g_pFileLog,pszfmt,args);
        }
        if (dwTarget & PRT_ERROR) {
            if (!g_fError) {
                g_fError = TRUE;
            }
            if (!g_pFileErrorLog) {   // If log file is not opened
                if (!bTriedOpen) {          // If we haven't tried
                    if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                   L"wb")) == NULL) {
                        SelectivePrint(PRT_STD,
                                       MSG_CSVDE_UNABLEOPENERR);
                        bTriedOpen = TRUE;
                        goto error;
                    }
                    if(fputwc(UNICODE_MARK,
                              g_pFileErrorLog)==WEOF) {
                        goto error;
                    }
                }
                else {
                    goto error;
                }
            }
            vfwprintf(g_pFileErrorLog,pszfmt,args);
        }
    }
    va_end(args);
error:
    return;
}

#define UNIT    2           // This is the number of entries each dot represents
#define DOTS    20          // This is the number of dots before we roll back

//+---------------------------------------------------------------------------
// Function:   TrackStatus
//
// Synopsis:   Print a dot to indicate status, turn on g_fDot to indicate
//             that a dot has been printed. Any subsequent outputs require
//             a carriage return. (handled by SelectivePrint)
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void TrackStatus()
{
/*
    //  
    // This static count keeps track of where we are
    //
    static DWORD dwCount = 0;

    if (!g_fVerbose) {
        if (dwCount == (DOTS*UNIT)) {
            DWORD i;
            for (i=0;i<DOTS;i++) {
                printf("%c",BACKSPACE);
            }
            for (i=0;i<DOTS;i++) {
                printf("%c",' ');
            }
            for (i=0;i<DOTS;i++) {
                printf("%c",BACKSPACE);
            }
            dwCount = 0;
        }
        //
        // Only if we reached UNIT we'll print out a dot now
        //
        if (dwCount % UNIT == 0)
            wprintf(L".");
        dwCount++;
        g_fDot = TRUE;
    }
*/

    if (!g_fVerbose) {
        wprintf(L".");
        g_fDot = TRUE;
    }
}

//+---------------------------------------------------------------------------
// Function:   GetNextEntry 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR GetNextEntry(PWSTR szInput, 
                     PWSTR *pszEntry,
                     PWSTR *pszNext)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR szFinal = szInput;
    
    while ((*szFinal != ',') && (*szFinal != '\0')) {
        if (*szFinal == '\\') {
            szFinal++;
            if (*szFinal == '\0') {
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
        szFinal++;
    }

    if (*szFinal == ',') {
        *szFinal = '\0';
        *pszEntry = RemoveWhiteSpaces(szInput);
        *pszNext = szFinal+1;
        return (DIREXG_SUCCESS);
    }
    else {
        *pszEntry = RemoveWhiteSpaces(szInput);
        *pszNext = NULL;
        return (DIREXG_SUCCESS);
    }
error:
    return hr;
}



//+---------------------------------------------------------------------------
// Function:  GetAllEntries  
//
// Synopsis:  Get all the entries from a list of comma separated values
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR GetAllEntries(PWSTR szInput, 
                      PWSTR **ppszOutput)
{
    DWORD cNumberAttributes = 0;
    PWSTR *pszReturn = NULL;
    PWSTR szCurrent = NULL;
    PWSTR szEntry = NULL;
    PWSTR szNext = NULL;     
    DIREXG_ERR hr = DIREXG_SUCCESS;

    DWORD cNumberNeeded = 1;

    // Allocating array to store entries    
    szCurrent = szInput;
    while (*szCurrent != '\0') {
        if (*szCurrent == '\\') {
            if (*(szCurrent+1) == '\0') {
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            szCurrent+=2;
            continue;
        }
        if (*szCurrent == ',') {
            cNumberNeeded++;
        }
        szCurrent++;
    }
    pszReturn = (PWSTR*)MemAlloc((cNumberNeeded+1)*sizeof(PWSTR));
    if (!pszReturn) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    szCurrent = szInput;
    hr = GetNextEntry(szCurrent,
                      &szEntry,
                      &szNext);
    DIREXG_BAIL_ON_FAILURE(hr);

    pszReturn[cNumberAttributes] = szEntry;
    cNumberAttributes++;

    while (szNext) {
        szCurrent = szNext;
        hr = GetNextEntry(szCurrent,
                          &szEntry,
                          &szNext);
        DIREXG_BAIL_ON_FAILURE(hr);
        pszReturn[cNumberAttributes] = szEntry;
        cNumberAttributes++;
    }
    pszReturn[cNumberAttributes] = NULL;

    cNumberAttributes--;

    *ppszOutput = pszReturn;

error:
    return hr;
}
DWORD GetDCName(BOOLEAN fWritable, PWSTR *pszDSName)
{
    DWORD dwError = 0;
    PDOMAIN_CONTROLLER_INFOW pDomainControllerInfo = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDSRole = NULL;

    *pszDSName = NULL;

    //
    // Get the role of the machine
    //
    dwError = DsRoleGetPrimaryDomainInformation(NULL,
                                                DsRolePrimaryDomainInfoBasic,
                                                (PBYTE*) &pDSRole);
    if (dwError != NO_ERROR) {
        goto error;
    }

    //
    // Set the property
    //
    if ((pDSRole->MachineRole == DsRole_RoleBackupDomainController) ||
        (pDSRole->MachineRole == DsRole_RolePrimaryDomainController)) {
        //
        // The current machine is the DC, we are done
        //
        goto error;
    }

    //
    // If the current machine is not the DC, get the DC of the domain
    //
    if (fWritable) {
        //
        // Looking for a writable server
        //
        dwError = DsGetDcNameW(NULL, //ComputerName 
                               NULL, //DomainName 
                               NULL, //DomainGuid 
                               NULL, //SiteName 
                               DS_DIRECTORY_SERVICE_REQUIRED|DS_WRITABLE_REQUIRED,
                               &pDomainControllerInfo);
    }
    else {
        //
        // Looking for a GC first, if it fails, goto any DC
        //
        dwError = DsGetDcNameW(NULL, //ComputerName 
                               NULL, //DomainName 
                               NULL, //DomainGuid 
                               NULL, //SiteName 
                               DS_DIRECTORY_SERVICE_REQUIRED|DS_GC_SERVER_REQUIRED,
                               &pDomainControllerInfo);
        if (dwError != 0) {
            dwError = DsGetDcNameW(NULL, //ComputerName 
                                   NULL, //DomainName 
                                   NULL, //DomainGuid 
                                   NULL, //SiteName 
                                   DS_DIRECTORY_SERVICE_REQUIRED,
                                   &pDomainControllerInfo);
        }
    }

    if (dwError == 0) {
        if ((pDomainControllerInfo) && 
            (pDomainControllerInfo->DomainControllerName)) {
            *pszDSName = MemAllocStrW(pDomainControllerInfo->DomainControllerName+2);
        }
        else {
            ASSERT(("DsGetDC returns 0 but has no info!\n"));
        }
    }

error:
    if (pDSRole) {
        DsRoleFreeMemory(pDSRole);
    }
    if (pDomainControllerInfo) {
        NetApiBufferFree(pDomainControllerInfo);
    }
    return dwError;
}

BOOL
GetPassword(
    PWSTR  szBuffer,
    DWORD  dwLength,
    DWORD  *pdwLengthReturn
    )
{
    WCHAR   ch;
    PWSTR   pszBufCur = szBuffer;
    DWORD   c;
    int     err;
    DWORD   mode;

    //
    // make space for NULL terminator
    //
    dwLength -= 1;                  
    *pdwLengthReturn = 0;               

    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), 
                        &mode)) {
        return FALSE;
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), 
                          &ch, 
                          1, 
                          &c, 
                          0);
        if (!err || c != 1)
            ch = 0xffff;
    
        if ((ch == CR) || (ch == 0xffff))    // end of line
            break;

        if (ch == BACKSPACE) {  // back up one or two 
            //
            // IF pszBufCur == buf then the next two lines are a no op.
            // Because the user has basically backspaced back to the start
            //
            if (pszBufCur != szBuffer) {
                pszBufCur--;
                (*pdwLengthReturn)--;
            }
        }
        else {

            *pszBufCur = ch;

            if (*pdwLengthReturn < dwLength) 
                pszBufCur++ ;                   // don't overflow buf 
            (*pdwLengthReturn)++;            // always increment pdwLengthReturn 
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    //
    // NULL terminate the string
    //
    *pszBufCur = NULLC;         
    putchar(NEWLINE);

    return((*pdwLengthReturn <= dwLength) ? TRUE : FALSE);
}


 /***
 * My_fwprintf(stream, format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW.
 * Note: This My_fwprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(str, format, args);

    va_end(args);

    return cchWChar;
}


int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   )
{

    HANDLE hOut;
    DWORD currentMode;
    const DWORD dwBufferMessageSize = 4096;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    DWORD  cchWChar;
    WCHAR  szBufferMessage[dwBufferMessageSize];
    _vsnwprintf( szBufferMessage, dwBufferMessageSize, format, argptr );
    szBufferMessage[dwBufferMessageSize-1] = L'\0';

    cchWChar = wcslen(szBufferMessage);

    //  if it is console, we can use WriteConsoleW
    if (GetFileType(hOut) == FILE_TYPE_CHAR && GetConsoleMode(hOut, &currentMode)) {
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
    }
    //  otherwise, we need to convert Unicode to potential character sets
    //  and use WriteFile
    else {
        int charCount = WideCharToMultiByte(GetConsoleOutputCP(), 0, szBufferMessage, -1, 0, 0, 0, 0);
        char* szaStr = new char[charCount];
        if (szaStr != NULL) {
            DWORD dwBytesWritten;
            WideCharToMultiByte(GetConsoleOutputCP(), 0, szBufferMessage, -1, szaStr, charCount, 0, 0);
            WriteFile(hOut, szaStr, charCount - 1, &dwBytesWritten, 0);
            delete[] szaStr;
        }
        else
            cchWChar = 0;
    }
    return cchWChar;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\csvds\utils.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    util.cxx

Abstract:
    
    Utilities

Author:

    Felix Wong [FelixW]    06-Sep-1997
    
++*/

#include "csvde.hxx"
#pragma hdrstop

extern BOOLEAN g_fUnicode;
extern DWORD g_cLine;
extern DWORD g_cColumn;

//+---------------------------------------------------------------------------
// Class:  CStringPlex
//
// Synopsis: A Class that encapsulates an array of zero terminated strings    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CStringPlex::CStringPlex()
{
    m_cszMax = 0;
    m_iszNext = 0;
    m_rgsz = NULL;
}

CStringPlex::~CStringPlex()
{
    Free();
}

DIREXG_ERR CStringPlex::GetCopy(PWSTR **prgszReturn)
{
    PWSTR *rgszReturn = NULL;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    DWORD i;

    if (m_iszNext == 0) {
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    rgszReturn = (PWSTR*)MemAlloc( m_iszNext * sizeof(PWSTR) );
    if (!rgszReturn) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    memset(rgszReturn, 0, m_iszNext * sizeof(PWSTR) );

    for (i=0;i<m_iszNext;i++) {
        rgszReturn[i] = MemAllocStrW(m_rgsz[i]); 
        if (!rgszReturn[i]) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    
    *prgszReturn = rgszReturn;
    return hr;

error:
    if (rgszReturn) {
        i = 0;
        while ((i<m_iszNext) && rgszReturn[i]) {
            MemFree(rgszReturn[i]);
            i++;
        }
        MemFree (rgszReturn);
    }
    return hr;
}

DWORD CStringPlex::NumElements()
{
    return m_iszNext;
}

PWSTR *CStringPlex::Plex()
{
    return m_rgsz;
}


DIREXG_ERR CStringPlex::Init()
{
    DIREXG_ERR hr = DIREXG_SUCCESS;

    Free();

    m_rgsz = (PWSTR*)MemAlloc( STRINGPLEX_INC * sizeof(PWSTR) );
    if (!m_rgsz ) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    m_cszMax = STRINGPLEX_INC;
    m_iszNext = 0;
    memset(m_rgsz, 0, STRINGPLEX_INC * sizeof(PWSTR) );

error:
    return hr;
}

DIREXG_ERR CStringPlex::AddElement(PWSTR szValue)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR *rgszT = NULL;

    if (!szValue) {
        return DIREXG_ERROR;
    }

    //
    // If next index is larger than largest index
    //
    if (m_iszNext > (m_cszMax-1)) {
        rgszT = (PWSTR*)MemRealloc(m_rgsz , 
                                (m_cszMax)*sizeof(PWSTR),
                                (m_cszMax + STRINGPLEX_INC)*sizeof(PWSTR));
        if (!rgszT) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        m_rgsz = rgszT;
        m_cszMax+=STRINGPLEX_INC;
    }

    m_rgsz [m_iszNext] = MemAllocStrW(szValue);
    if (!m_rgsz [m_iszNext]) {
         hr = DIREXG_OUTOFMEMORY;
         DIREXG_BAIL_ON_FAILURE(hr);
    }
    m_iszNext++;
error:
    return hr;
}

void CStringPlex::Free()
{
    DWORD isz = 0;

    if (m_rgsz) {
        for (isz=0;isz<m_iszNext;isz++) {
            if (m_rgsz[isz]) {
                MemFree(m_rgsz[isz]);
            }
        }
        MemFree (m_rgsz);
        m_rgsz = NULL;
    }
    m_cszMax = 0;
    m_iszNext = 0;
}

//+---------------------------------------------------------------------------
// Class:  CString
//
// Synopsis: A class that encapsulates a variable size string    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CString::CString()
{
    m_sz = NULL;
    m_ichNext = 0;
    m_cchMax = 0;
}

CString::~CString()
{
    Free();
}

DIREXG_ERR CString::Init()
{
    Free();
    m_sz = (PWSTR)MemAlloc(STRING_INC * sizeof(WCHAR));
    if (!m_sz) {
        return DIREXG_OUTOFMEMORY;
    }
    m_cchMax = STRING_INC;
    m_ichNext = 0;
    m_sz[0] = '\0';
    return DIREXG_SUCCESS;
}

DIREXG_ERR CString::GetCopy(PWSTR *pszReturn)
{
    PWSTR szReturn = NULL;
    szReturn = MemAllocStrW(m_sz);
    if (!szReturn) {
        return DIREXG_OUTOFMEMORY;
    }
    *pszReturn = szReturn;
    return DIREXG_SUCCESS;
}

PWSTR CString::String()
{
    return m_sz;
}


DIREXG_ERR CString::Append(PWSTR szAppend)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR szT;
    DWORD cchResult;
    DWORD cchAppend;
    
    cchAppend = wcslen(szAppend);
    if ((cchAppend + m_ichNext) > (m_cchMax - 1)) {
        //
        // If normal addition of memory is not enough
        //
        if ((cchAppend + m_ichNext) > (m_cchMax + STRING_INC - 1)) {
            cchResult = m_cchMax + STRING_INC + cchAppend;
        }
        else {
            cchResult = m_cchMax + STRING_INC;
        }
        szT = (PWSTR)MemRealloc(m_sz, 
                                    sizeof(WCHAR) * m_cchMax,
                                    sizeof(WCHAR) * cchResult);
        if (!szT) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        m_sz = szT;
        m_cchMax = cchResult;
    }
    m_ichNext += cchAppend;
    wcscat(m_sz, szAppend);

error:
    return hr;
}

DIREXG_ERR CString::Backup()
{
    DIREXG_ERR hr = DIREXG_ERROR;

    if (m_sz && (m_ichNext > 0)) {
        m_sz[m_ichNext-1] = '\0';
        m_ichNext--;
        hr = DIREXG_SUCCESS;
    }
    return hr;
}

void CString::Free()
{
    if (m_sz) {
        MemFree(m_sz);
        m_sz = NULL;
    }
    m_ichNext = 0;
    m_cchMax = 0;
}


//+---------------------------------------------------------------------------
// Function:  SubString
//
// Synopsis:  substitute every occurences of 'szFrom' to 'szTo'. Will allocate
//            a return string. It must be MemFreed by MemFree()  
//            If the intput does not contain the 'szFrom', it will just return 
//            DIREXG_SUCCESS with szOutput = NULL;
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR SubString(PWSTR szInput,
                  PWSTR szFrom,
                  PWSTR szTo,
                  PWSTR *pszOutput)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR szOutput = NULL;
    PWSTR szLast = NULL;
    PWSTR szReturn = NULL;
    DWORD cchToCopy = 0;            // count of number of WCHAR to copy
    DWORD cchReturn = 0;
    DWORD cchFrom;
    DWORD cchTo;
    DWORD cchInput;
    DWORD cSubString = 0;       // count of number of substrings in input

    cchFrom    = wcslen(szFrom);
    cchTo      = wcslen(szTo);
    cchInput   = wcslen(szInput);
    *pszOutput = NULL;

    //
    // Does the substring exist?
    //
    szOutput = wcsistr(szInput,
                      szFrom);
    if (!szOutput) {
        *pszOutput = NULL;
        return DIREXG_SUCCESS;
    }

    // 
    // Counting substrings
    //
    while (szOutput) {
        szOutput += cchFrom;
        cSubString++;
        szOutput = wcsistr(szOutput,
                          szFrom);
    }

    //
    // Allocating return string
    //
    cchReturn = cchInput + ((cchTo - cchFrom) * cSubString) + 1;
    szReturn = (PWSTR)MemAlloc(sizeof(WCHAR) * cchReturn);
    if (!szReturn) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    };
    szReturn[0] = '\0';
    
    //
    // Copying first string before sub
    //
    szOutput = wcsistr(szInput,
                      szFrom);
    cchToCopy = (DWORD)(szOutput - szInput);
    wcsncat(szReturn,
            szInput,
            cchToCopy);
    
    //
    // Copying 'To' String over
    //
    wcscat(szReturn,
           szTo);
    szInput = szOutput + cchFrom;

    //
    // Test for more 'from' string
    //
    szOutput = wcsistr(szInput,
                      szFrom);
    while (szOutput) {
        cchToCopy = (DWORD)(szOutput - szInput);
        wcsncat(szReturn,
                szInput,
                cchToCopy);
        wcscat(szReturn,
                szTo);
        szInput= szOutput + cchFrom;
        szOutput = wcsistr(szInput,
                          szFrom);
    }

    wcscat(szReturn,
           szInput);
    *pszOutput = szReturn;

error:
    return (hr);
}


//+---------------------------------------------------------------------------
// Function:  wcsistr
//
// Synopsis:  Case-insensitive version of wcsstr.
//            Based off the Visual C++ 6.0 CRT
//            sources.
//
// Arguments: wcs1 --- string to be searched
//            wcs2 --- substring to search for
//
// Returns:   ptr to first occurrence of wcs1 in wcs2, or NULL
//
// Modifies:      -
//
// History:    9-28-00   MattRim         Created.
//
//----------------------------------------------------------------------------

wchar_t * __cdecl wcsistr (
        const wchar_t * wcs1,
        const wchar_t * wcs2
        )
{
        wchar_t *cp = (wchar_t *) wcs1;
        wchar_t *s1, *s2;
        wchar_t cs1, cs2;

        while (*cp)
        {
                s1 = cp;
                s2 = (wchar_t *) wcs2;

                cs1 = *s1;
                cs2 = *s2;

                if (iswupper(cs1))
                    cs1 = towlower(cs1);

                if (iswupper(cs2))
                    cs2 = towlower(cs2);


                while ( *s1 && *s2 && !(cs1-cs2) ) {

                    s1++, s2++;

                    cs1 = *s1;
                    cs2 = *s2;

                    if (iswupper(cs1))
                        cs1 = towlower(cs1);

                    if (iswupper(cs2))
                        cs2 = towlower(cs2);
                }

                if (!*s2)
                        return(cp);

                cp++;
        }

        return(NULL);
}







//+---------------------------------------------------------------------------
// Function:  GetLine
//
// Synopsis:  will return the new line in the allocated buffer, must be MemFreed
//            by user
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR GetLine(FILE* pFileIn,
                   PWSTR *pszLine)
{
    CString String;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    WCHAR szValue[256];
    PWSTR szReturn = NULL;
    DWORD dwLength;

    hr = String.Init();
    DIREXG_BAIL_ON_FAILURE(hr);

    do {
        szReturn = fgetws(szValue,
                          256,
                          pFileIn);
        //
        // We increment the line counter everytime right after we get a new line
        //
        g_cLine++;

        //
        // Restart the column counter to start from 0 because it is a newline
        //
        g_cColumn = 0;
    }
    while (szReturn && (szReturn[0] == '\n' || szReturn[0] == '\r'));

    while (szReturn) {
        hr = String.Append(szValue);
        DIREXG_BAIL_ON_FAILURE(hr);

        //
        // If the whole line isn't filled, we know this line is terminated by an end
        // If it is filled, and the last char is carriage return, then we know the line
        // has termianted as well.
        //
        if ((wcslen(szReturn) != 255) || (szReturn[254] == '\n')) {
            break;
        }
        szReturn = fgetws(szValue,
                          256,
                          pFileIn);
    }

    //
    // If it is not end of file, an error has occurred
    //
    if ((szReturn == 0) && (feof(pFileIn) == FALSE)) {
        *pszLine = NULL;
        goto error;
    }

    hr = String.GetCopy(pszLine);
    DIREXG_BAIL_ON_FAILURE(hr);

    dwLength = wcslen(*pszLine);
    if ((dwLength>1) && ((*pszLine)[dwLength-1] == '\n')) {
        (*pszLine)[dwLength-1] = '\0';
    }

    //
    // In unicode mode, \r will be passed back to us as well. We'll have to back
    // that up too
    //
    if (g_fUnicode && (dwLength>0)) {
        dwLength--;
        if ((dwLength>0) && ((*pszLine)[dwLength-1] == '\r')) {
            (*pszLine)[dwLength-1] = '\0';
        }
    }


error:
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:   AppendFile 
//
// Synopsis:   Append fileAppend to fileTarget
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR AppendFile(FILE* pFileAppend,
                   FILE* pFileTarget)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    unsigned char szBuffer[100];
    DWORD cchRead = 0;
    DWORD cchWrite = 0;

    while (!feof(pFileAppend)) {
        cchRead = fread(szBuffer, 
                        sizeof(unsigned char), 
                        1, 
                        pFileAppend);
        if ((ferror(pFileAppend)) || ((cchRead == 0) &&(!feof(pFileAppend)))) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        if (cchRead > 0) {
            cchWrite = fwrite(szBuffer, 
                              sizeof(unsigned char), 
                              cchRead, 
                              pFileTarget);
            if (cchWrite == 0) {
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
    }
error:
    return hr;
}

void OutputExtendedError(LDAP *pLdap) {
    DWORD dwWinError = NULL;
    DWORD dwError;
    DWORD dwLen;
    WCHAR szMsg[MAX_PATH];

    dwError = ldap_get_optionW( pLdap, LDAP_OPT_SERVER_EXT_ERROR, &dwWinError);
    if (dwError == LDAP_SUCCESS) {
        if (dwWinError) {
            dwLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                  NULL,
                                  dwWinError,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  szMsg,
                                  MAX_PATH,
                                  NULL);
            if (dwLen == 0) {
                _itow(dwWinError, szMsg, 10);
            }
            else {
                //
                // If we get a message, we'll remove all the linefeeds in it
                // and replace it with a space, except the last one
                //
                PWSTR pszNew = szMsg;
                while (pszNew && (pszNew = wcsstr(pszNew,L"\r\n"))) {
                    if ((*(pszNew+2))) {
                        wcscpy(pszNew, L" ");                                           
                        wcscpy(pszNew+1, (pszNew + 2));
                    }
                    else {
                        wcscpy(pszNew, (pszNew + 2));
                    }
                }
            }

            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_CSVDE_EXTENDERROR, 
                            szMsg);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dbdump\dbdump.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbdump.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <process.h>
#include <dsjet.h>
#include <ntdsa.h>
#include <scache.h>
#include <mdglobal.h>
#include <dbglobal.h>
#include <attids.h>
#include <..\..\ntdsa\dblayer\dbintrnl.h>
#include <dbopen.h>
#include <dsconfig.h>
#include <ctype.h>
#include <direct.h>
#include <ntdsa.h>
#include <dsutil.h>

#include <crypto\md5.h>


JET_INSTANCE    jetInstance = 0;
JET_SESID   sesid;
JET_DBID    dbid;
JET_TABLEID tblid;
char        *szIndex = SZDNTINDEX;
BOOL        fCloseJet = FALSE;
BOOL        fCountByContainer = FALSE;
BOOL            fbCountSDs = FALSE, fbCountClasses = FALSE;
DWORD           fSplit = 0;

char *szColNames[] = {
    SZDNT,
    SZPDNT,
    SZRDNATT,
    SZCNT,
    SZISVISIBLEINAB,
    SZNCDNT,
    SZOBJ,
    SZDELTIME,
    SZRDNTYP,
    SZGUID,
    SZINSTTYPE,
    SZSID,
    SZOBJCLASS
};

char *szSDColNames[] = {
    SZDNT,
    SZNTSECDESC,
    SZGUID,
    SZRDNATT
};

ULONG       ulDnt;
ULONG       ulPdnt;
long        lCount;
BYTE        bIsVisibleInAB;
ULONG       ulNcDnt;
BYTE        bObject;
DSTIME          DelTime;
ULONG       ulRdnType;
WCHAR       szRdn[MAX_RDN_SIZE];
GUID            Guid;
NT4SID          Sid;
ULONG           insttype;
char            *gszDBName = NULL;
DWORD           objClass;

char        sdBuffer [64 * 1024];

DWORD dwEstimatedCount;

JET_RETRIEVECOLUMN jrc[] =  {
    {0, &ulDnt, sizeof(ulDnt), 0, 0, 0, 1, 0, 0},
    {0, &ulPdnt, sizeof(ulPdnt), 0, 0, 0, 1, 0, 0},
    {0, szRdn, sizeof(szRdn), 0, 0, 0, 1, 0, 0},
    {0, &lCount, sizeof(lCount), 0, 0, 0, 1, 0, 0},
    {0, &bIsVisibleInAB, sizeof(bIsVisibleInAB), 0, 0, 0, 1, 0, 0},
    {0, &ulNcDnt, sizeof(ulNcDnt), 0, 0, 0, 1, 0, 0},
    {0, &bObject, sizeof(bObject), 0, 0, 0, 1, 0, 0},
    {0, &DelTime, sizeof(DelTime), 0, 0, 0, 1, 0, 0},
    {0, &ulRdnType, sizeof(ulRdnType), 0, 0, 0, 1, 0, 0},
    {0, &Guid, sizeof(Guid), 0, 0, 0, 1, 0, 0},
    {0, &insttype, sizeof(insttype), 0, 0, 0, 1, 0, 0},
    {0, &Sid, sizeof(Sid), 0, 0, 0, 1, 0, 0},
    {0, &objClass, sizeof (objClass), 0, 0, 0, 1, 0, 0}
};

#define cFixedColumns (sizeof(jrc)/sizeof(jrc[0]))

JET_RETRIEVECOLUMN jSDCols[] =  {
    {0, &ulDnt, sizeof(ulDnt), 0, 0, 0, 1, 0, 0},
    {0, &sdBuffer, sizeof(sdBuffer), 0, 0, 0, 1, 0, 0}
};

#define cSDFixedColumns (sizeof(jSDCols)/sizeof(jSDCols[0]))


void JetError(JET_ERR err, char *szJetCall);
void OpenJet(void);
int CloseJet(void);
ULONG WalkDB(void);
ULONG CountSDs(void);
void DisplayRecord(void);
void DumpHidden(void);

void ShowUsage(int i, int line) {
    fprintf(stderr,
        "Usage: dbdump [/d database_name] [ [/c datatable_JET_index_name] | [/s] | [/s1] | [/s2] | [/o]\\n");
    fprintf(stderr, "    Switches:"
        "\n\t d - select database to open"
        "\n\t s - count unique security descriptors (also split into inherited / explicit part)"
        "\n\t s1 - count unique security descriptors (without splitting)"
        "\n\t s2 - count unique security descriptors (after splitting)"
        "\n\t o - count by objectClass"
    "\n\t c - displays record count per container "
        "\n\t      (only valid\n\t     in conjuction with the PDNT_index)\n");
//    fprintf(stderr, "problem with argument %d on line %d\n");
}

//
// main
//

int __cdecl main(int argc, char *argv[])
{
    ULONG ulRecCount;
    int   i;

    for (i=1; i<argc; i++) {
    if ((*argv[i] == '-') || (*argv[i] == '/')) {
      switch(tolower(argv[i][1])) {
          case 'c':
        ++i;
        if (i == argc) {
            ShowUsage(i, __LINE__);
            exit(1);
        }
        fCountByContainer = TRUE;
        szIndex = argv[i];
        break;

          case 'd':
        ++i;
        if (i == argc) {
            ShowUsage(i, __LINE__);
            exit(1);
        }
        gszDBName = argv[i];
        break;

              case 's':
                fbCountSDs = TRUE;
                if (argv[i][2] == '1') {
                    fSplit = 1;
                    fprintf (stderr, "Dumping SD usage (non splitted)\n");
                }
                else if (argv[i][2] == '2') {
                    fSplit = 2;
                    fprintf (stderr, "Dumping SD usage (splitted)\n");
                }
                else {
                    fprintf (stderr, "Dumping SD usage (splitted & non splitted)\n");
                }

                ++i;
                break;

              case 'o':
                ++i;
                fprintf (stderr, "Dumping ObjectClass usage\n");
                fbCountClasses = TRUE;
                break;

          default:
        ShowUsage(i, __LINE__);
        exit(1);
          }
    }
    else {
        ShowUsage(i, __LINE__);
        exit(1);
    }
    }

    if (fCountByContainer && _stricmp(szIndex,"PDNT_index"))
    {
        fprintf(stderr, "Invalid combination: container counts and %s index\n",
        szIndex);
        exit(1);
    }

    OpenJet();

    if (!fbCountSDs) {
        ulRecCount = WalkDB();
    }
    else {
        ulRecCount = CountSDs();
    }
    fprintf(stdout, "\nTotal records: %u\n", ulRecCount);
    CloseJet();
    return 0;
}


void JetError(JET_ERR err, char *szJetCall)
{
    fprintf(stderr, "%s returned %d\n", szJetCall, err);

    if (fCloseJet)
        CloseJet();

    exit(1);
}

void OpenJet(void)
{
    JET_ERR err;
    DWORD dwType;
    DWORD indexCount;
    JET_COLUMNDEF coldef;
    int i;


    // set flag to close jet on error
    fCloseJet = TRUE;

    DBSetRequiredDatabaseSystemParameters (&jetInstance);

    err = DBInitializeJetDatabase(&jetInstance, &sesid, &dbid, gszDBName, FALSE);
    if (err != JET_errSuccess) {
        JetError(err, "DBInit");
    }

    DumpHidden();

    if (err = JetOpenTable(sesid, dbid, SZDATATABLE, NULL, 0, 0, &tblid))
    JetError(err, "JetOpenTable");

    if (err =  JetSetCurrentIndex(sesid, tblid, szIndex))
    JetError(err, "JetSetCurrentIndex");

    JetIndexRecordCount( sesid, tblid, &indexCount, 0xFFFFFFFF );
    fprintf(stdout,"JetIndexRecordCount returned %d\n\n",indexCount);
    dwEstimatedCount = indexCount;

    for (i=0; i< cFixedColumns; i++)
    {
        if (err = JetGetTableColumnInfo(sesid, tblid, szColNames[i], &coldef,
                    sizeof(coldef), 0))
        {
            JetError(err, "JetGetTableColumnInfo");
        }

        jrc[i].columnid = coldef.columnid;
    }


    for (i=0; i< cSDFixedColumns; i++)
    {
        if (err = JetGetTableColumnInfo(sesid, tblid, szSDColNames[i], &coldef,
                    sizeof(coldef), 0))
        {
            JetError(err, "JetGetTableColumnInfo");
        }

        jSDCols[i].columnid = coldef.columnid;
    }
}


int CloseJet(void)
{
    JET_ERR err;

    if (sesid != 0) {
        if(dbid != 0) {
            // JET_bitDbForceClose not supported in Jet600.
            if ((err = JetCloseDatabase(sesid, dbid, 0)) != JET_errSuccess) {
                return err;
            }
            dbid = 0;
        }

        if ((err = JetEndSession(sesid, JET_bitForceSessionClosed)) != JET_errSuccess) {
            return err;
        }
        sesid = 0;

        JetTerm(jetInstance);
        jetInstance = 0;
    }
    return JET_errSuccess;
}


typedef struct _HASH_ENTRY HASH_ENTRY;

struct _HASH_ENTRY {
    HASH_ENTRY   *next;

    DWORD         key[4];
    ULONG         count;
};

HASH_ENTRY* AddNode (
        HASH_ENTRY **pHashTable,
        DWORD dwHashSize,
        DWORD *key,
        DWORD dwLeafSize,
        BOOL* pNewLeafCreated)
{
    HASH_ENTRY *pNode = NULL;
    DWORD hashValue;

    // compute hash
    hashValue = (key[0] ^ key[1] ^ key[2] ^ key[3]) % dwHashSize;

    for (pNode = pHashTable[hashValue]; pNode != NULL; pNode = pNode->next) {
        if (memcmp(pNode->key, key, sizeof(pNode->key)) == 0) {
            // found it!
            break;
        }
    }

    if (pNode) {
        *pNewLeafCreated = FALSE;
    }
    else {
        pNode = (HASH_ENTRY*)malloc (dwLeafSize);
        if (!pNode) {
            fprintf (stderr, "Out of memory\n");
            *pNewLeafCreated = FALSE;
            return NULL;
        }
        memset(pNode, 0, dwLeafSize);
        *pNewLeafCreated = TRUE;
        pNode->count = 0;
        memcpy (pNode->key, key, sizeof(pNode->key));

        pNode->next = pHashTable[hashValue];
        pHashTable[hashValue] = pNode;
    }

    pNode->count++;
    return pNode;
}

typedef VOID (*TpfnPrintNode)(HASH_ENTRY* pNode);

VOID TraverseHashTable (HASH_ENTRY** pHashTable, DWORD dwHashSize, TpfnPrintNode pfnPrintNode)
{
    HASH_ENTRY* pNode;
    DWORD i;

    for (i = 0; i < dwHashSize; i++) {
        for (pNode = pHashTable[i]; pNode != NULL; pNode = pNode->next) {
            (*pfnPrintNode)(pNode);
        }
    }
}


typedef struct {
    HASH_ENTRY  base;
    USHORT      sdLength;         // total SD length (bytes)
    SECURITY_DESCRIPTOR_CONTROL sdControl;
    BYTE        ExplicitAceCount;
    BYTE        InheritedAceCount;
    BYTE        ExplicitDenyAceCount;
    BYTE        InheritedDenyAceCount;
    char        sdType;
} SD_ENTRY;

ULONG ulTotalCount = 0;
ULONG ulUnique = 0;
ULONGLONG ulTotalSize = 0;
ULONGLONG ulTotalUniqueSize = 0;
ULONG ulMaxLength = 0;
ULONG ulMinLength = (ULONG)-1;
ULONG ulMaxAceCount = 0;
ULONG ulMinAceCount = (ULONG)-1;
ULONGLONG ulAvgAceCount = 0;
ULONGLONG ulDenyAceSDs = 0;
ULONGLONG ulDenyAceObjects = 0;

VOID PrintNodeSD(HASH_ENTRY* pNode) {
    SD_ENTRY* pSDNode = (SD_ENTRY*)pNode;
    BYTE aceCount = pSDNode->ExplicitAceCount + pSDNode->InheritedAceCount;

    printf("%7d %1c %6d %3d %3d %3d %3d %3d %04x\n",
           pSDNode->base.count,                                         // SD refcount
           pSDNode->sdType,                                             // SD type
           pSDNode->sdLength,                                           // SD size
           aceCount,
           pSDNode->ExplicitAceCount,                                   
           pSDNode->InheritedAceCount,                                  
           pSDNode->ExplicitDenyAceCount,
           pSDNode->InheritedDenyAceCount,
           pSDNode->sdControl
           );
    ulTotalCount += pSDNode->base.count;
    ulUnique++;
    ulTotalUniqueSize += pSDNode->sdLength;
    ulTotalSize += (ULONGLONG)pSDNode->base.count * pSDNode->sdLength;
    ulMaxLength = max(ulMaxLength, pSDNode->sdLength);
    ulMinLength = min(ulMinLength, pSDNode->sdLength);
    ulMaxAceCount = max(ulMaxAceCount, aceCount);
    ulMinAceCount = min(ulMinAceCount, aceCount);
    ulAvgAceCount += aceCount;
    if (pSDNode->ExplicitDenyAceCount > 0 || pSDNode->InheritedDenyAceCount > 0) {
        ulDenyAceObjects += pSDNode->base.count;
        ulDenyAceSDs++;
    }
}

VOID PrintNodeObjectClass(HASH_ENTRY* pNode) {
    printf("%7d %7x %d %d\n",
           pNode->count,
           pNode->key[0],
           pNode->key[1],
           pNode->key[2]
           );
    ulTotalCount += pNode->count;
}

#define INHERIT_FLAGS (INHERITED_ACE)
#define MAXDWORD    0xffffffff

BOOL
SplitACL (PACL pAcl,
          PACL *ppACLexplicit,
          PACL *ppACLinherit)
{
    DWORD         dwErr;
    WORD          i;
    ACE_HEADER   *pAce;
    DWORD         dwExplicit = 0,
                  dwInherit = 0;

    DWORD         dwExplicitSize = 0,
                  dwInheritSize = 0;

    for ( i = 0; i < pAcl->AceCount; i++ )
    {
        if ( !GetAce(pAcl, i, (LPVOID *) &pAce) )
        {
            return FALSE;
        }
        else
        {
            if (pAce->AceFlags & INHERIT_FLAGS) {
                dwInherit++;
                dwInheritSize += pAce->AceSize;
            }
            else {
                dwExplicit++;
                dwExplicitSize += pAce->AceSize;
            }
        }
    }

    *ppACLinherit = NULL;
    *ppACLexplicit = NULL;

    if (dwInherit) {
        //dwInheritSize += sizeof (ACE_HEADER);

        *ppACLinherit = (PACL) malloc (dwInheritSize);

        if (!*ppACLinherit) {
            fprintf (stderr, "Out of memory\n");
            return FALSE;
        }

        if (InitializeAcl(*ppACLinherit,
                          dwInheritSize,
                          pAcl->AclRevision) ) {

            for ( i = 0; i < pAcl->AceCount; i++ )
            {
                if ( !GetAce(pAcl, i, (LPVOID *) &pAce) )
                {
                    return FALSE;
                }
                else if (pAce->AceFlags & INHERIT_FLAGS) {
                    if (AddAce(*ppACLinherit,
                                pAcl->AclRevision,
                                MAXDWORD,
                                pAce,
                                1)) {

                        dwErr = GetLastError();
                        fprintf (stderr, "Error: AddAce1 ==> 0x%x\n", dwErr);
                        return FALSE;
                    }
                }
            }
        }
    }



    if (dwExplicit) {
        //dwExplicitSize += sizeof (ACL_HEADER);

        *ppACLexplicit = (PACL) malloc (dwExplicitSize);
        if (!*ppACLexplicit) {
            fprintf (stderr, "Out of memory\n");
            return FALSE;
        }

        if (InitializeAcl(*ppACLexplicit,
                          dwExplicitSize,
                          pAcl->AclRevision) ) {

            for ( i = 0; i < pAcl->AceCount; i++ )
            {
                if ( !GetAce(pAcl, i, (LPVOID *) &pAce) )
                {
                    return FALSE;
                }
                else if ( !(pAce->AceFlags & INHERIT_FLAGS) ) {
                    if (AddAce(*ppACLexplicit,
                                pAcl->AclRevision,
                                MAXDWORD,
                                pAce,
                                1)) {

                        dwErr = GetLastError();
                        fprintf (stderr, "Error: AddAce2 ==> 0x%x\n", dwErr);
                        return FALSE;
                    }
                }
            }
        }
    }

    return TRUE;
}



BOOL BreakSDApart (
            PSECURITY_DESCRIPTOR pSD,
            DWORD cSDlen,
            PSECURITY_DESCRIPTOR *ppSD_explicit,
            DWORD *pcSD_explicit,
            PSECURITY_DESCRIPTOR *ppSD_inherit,
            DWORD *pcSD_inherit)
{
    DWORD dwErr;

    DWORD dwAbsoluteSDSize,
          dwDaclSize,
          dwSaclSize,
          dwOwnerSize,
          dwPrimaryGroupSize;

    BOOL  bDPresent, bDDefaulted;
    BOOL  bSPresent, bSDefaulted;

    PSECURITY_DESCRIPTOR pSDabsolute = NULL;
    PACL pDacl, pSacl, pDacltmp, pSacltmp;
    PACL pDACLexplicit = NULL, pSACLexplicit = NULL;
    PACL pDACLinherit = NULL, pSACLinherit = NULL;

    PSID pOwner;
    PSID pPrimaryGroup;


    if (!cSDlen) {
        return FALSE;
    }

    if (*ppSD_explicit) {
        free (*ppSD_explicit);
        *ppSD_explicit = NULL;
        *pcSD_explicit = 0;
    }
    if (*ppSD_inherit) {
        free (*ppSD_inherit);
        *ppSD_inherit = NULL;
        *pcSD_inherit = 0;
    }

    pDacl = pSacl = pOwner = pPrimaryGroup = NULL;

    dwAbsoluteSDSize = dwDaclSize = dwSaclSize = dwOwnerSize =
          dwPrimaryGroupSize = 0;

    if (!MakeAbsoluteSD(pSD,
                       pSDabsolute,
                       &dwAbsoluteSDSize,
                       pDacl,
                       &dwDaclSize,
                       pSacl,
                       &dwSaclSize,
                       pOwner,
                       &dwOwnerSize,
                       pPrimaryGroup,
                       &dwPrimaryGroupSize) ) {
        dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER) {
            fprintf (stderr, "Error: DNT=%d, MakeAbsoluteSD1 ==> 0x%x\n", ulDnt, dwErr);
            return FALSE;
        }
    }

    pSDabsolute = (PSECURITY_DESCRIPTOR) malloc (dwAbsoluteSDSize);
    pDacl = (PACL)malloc (dwDaclSize);
    pSacl = (PACL)malloc (dwSaclSize);
    pOwner = (PSID)malloc (dwOwnerSize);
    pPrimaryGroup = (PSID)malloc (dwPrimaryGroupSize);

    if (!pSDabsolute || !pDacl || !pSacl || !pOwner || !pPrimaryGroup) {
        fprintf (stderr, "Out of memory\n");
        return FALSE;
    }


    if (!MakeAbsoluteSD(pSD,
                       pSDabsolute,
                       &dwAbsoluteSDSize,
                       pDacl,
                       &dwDaclSize,
                       pSacl,
                       &dwSaclSize,
                       pOwner,
                       &dwOwnerSize,
                       pPrimaryGroup,
                       &dwPrimaryGroupSize) ) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: DNT=%d, MakeAbsoluteSD2 ==> 0x%x\n", ulDnt, dwErr);
        return FALSE;
    }


    if ( !GetSecurityDescriptorDacl(pSDabsolute,
                                    &bDPresent,
                                    &pDacltmp,
                                    &bDDefaulted) )
    {
        dwErr = GetLastError();
        fprintf (stderr, "Error: DNT=%d, GetSecurityDescriptorDacl1 ==> 0x%x\n", ulDnt, dwErr);
        return FALSE;
    }

    if (bDPresent) {
        if (pDacltmp) {
            SplitACL (pDacltmp, &pDACLexplicit, &pDACLinherit);
        }
        else {
            pDACLexplicit = pDACLinherit = NULL;
            bDPresent = FALSE;
        }
    }


    if ( !GetSecurityDescriptorSacl(pSDabsolute,
                                    &bSPresent,
                                    &pSacltmp,
                                    &bSDefaulted) )
    {
        dwErr = GetLastError();
        fprintf (stderr, "Error: DNT=%d, GetSecurityDescriptorSacl1 ==> 0x%x\n", ulDnt, dwErr);
        return FALSE;
    }

    if (bSPresent) {
        if (pSacltmp) {
            SplitACL (pSacltmp, &pSACLexplicit, &pSACLinherit);
        }
        else {
            pSACLexplicit = pSACLinherit = NULL;
            bSPresent = FALSE;
        }
    }


    // MAKE explicit SD
    //

    if (!SetSecurityDescriptorDacl(pSDabsolute,
                                   bDPresent,
                                   pDACLexplicit,
                                   bDDefaulted)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorDacl1 ==> 0x%x\n", dwErr);
        return FALSE;
    }

    if (!SetSecurityDescriptorSacl(pSDabsolute,
                                   bSPresent,
                                   pSACLexplicit,
                                   bSDefaulted)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorDacl1 ==> 0x%x\n", dwErr);
        return FALSE;
    }


    if (!SetSecurityDescriptorGroup(pSDabsolute,
                                    pPrimaryGroup,
                                    FALSE)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorGroup ==> 0x%x\n", dwErr);
        return FALSE;
    }

    if (!SetSecurityDescriptorOwner(pSDabsolute,
                                    pOwner,
                                    FALSE)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorOwner ==> 0x%x\n", dwErr);
        return FALSE;
    }


    if (!MakeSelfRelativeSD(pSDabsolute,
                           *ppSD_explicit,
                           pcSD_explicit)) {

        dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER) {
            fprintf (stderr, "Error: MakeSelfRelativeSD1 ==> 0x%x\n", dwErr);
            return FALSE;
        }
    }

    *ppSD_explicit = (PSECURITY_DESCRIPTOR) malloc (*pcSD_explicit);

    if (!MakeSelfRelativeSD(pSDabsolute,
                           *ppSD_explicit,
                           pcSD_explicit)) {

        dwErr = GetLastError();
        fprintf (stderr, "Error: MakeSelfRelativeSD2 ==> 0x%x\n", dwErr);
        return FALSE;
    }


    // MAKE inherited SD
    //

    if (!SetSecurityDescriptorDacl(pSDabsolute,
                                   bDPresent,
                                   pDACLinherit,
                                   bDDefaulted)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorDacl1 ==> 0x%x\n", dwErr);
        return FALSE;
    }

    if (!SetSecurityDescriptorSacl(pSDabsolute,
                                   bSPresent,
                                   pSACLinherit,
                                   bSDefaulted)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorDacl1 ==> 0x%x\n", dwErr);
        return FALSE;
    }


    if (!SetSecurityDescriptorGroup(pSDabsolute,
                                    NULL,
                                    FALSE)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorGroup ==> 0x%x\n", dwErr);
        return FALSE;
    }

    if (!SetSecurityDescriptorOwner(pSDabsolute,
                                    NULL,
                                    FALSE)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorOwner ==> 0x%x\n", dwErr);
        return FALSE;
    }


    if (!MakeSelfRelativeSD(pSDabsolute,
                           *ppSD_inherit,
                           pcSD_inherit)) {

        dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER) {
            fprintf (stderr, "Error: MakeSelfRelativeSD3 ==> 0x%x\n", dwErr);
            return FALSE;
        }
    }

    *ppSD_inherit = (PSECURITY_DESCRIPTOR) malloc (*pcSD_inherit);

    if (!MakeSelfRelativeSD(pSDabsolute,
                           *ppSD_inherit,
                           pcSD_inherit)) {

        dwErr = GetLastError();
        fprintf (stderr, "Error: MakeSelfRelativeSD4 ==> 0x%x\n", dwErr);
        return FALSE;
    }



    free (pSDabsolute);
    free (pDacl);
    free (pSacl);
    free (pOwner);
    free (pPrimaryGroup);
    free (pDACLexplicit);
    free (pSACLexplicit);
    free (pDACLinherit);
    free (pSACLinherit);

    return TRUE;
}

BOOL AnalyzeSD(PSECURITY_DESCRIPTOR pSD, DWORD cbSD, SD_ENTRY* pSDNode) {
    PACL pAcl;
    BOOL fPresent;
    BOOL fDefaulted;
    DWORD i;
    ACE_HEADER* pAce;

    pSDNode->sdLength = (USHORT)cbSD;
    if (cbSD == 0) {
        return FALSE;
    }
    GetSecurityDescriptorControl(pSD, &pSDNode->sdControl, &i);

    GetSecurityDescriptorDacl(pSD, &fPresent, &pAcl, &fDefaulted);
    if (fPresent && pAcl != NULL) {
        for (i = 0; i < pAcl->AceCount; i++) {
            if ( !GetAce(pAcl, i, (LPVOID *) &pAce) ) return FALSE;
            if (pAce->AceFlags & INHERIT_FLAGS) {
                pSDNode->InheritedAceCount++;
            }
            else {
                pSDNode->ExplicitAceCount++;
            }
            if (pAce->AceType == ACCESS_DENIED_ACE_TYPE || pAce->AceType == ACCESS_DENIED_OBJECT_ACE_TYPE) {
                if (pAce->AceFlags & INHERIT_FLAGS) {
                    pSDNode->InheritedDenyAceCount++;
                }
                else {
                    pSDNode->ExplicitDenyAceCount++;
                }
            }

        }
    }
    return TRUE;
}

HASH_ENTRY** pHash = NULL, **pSplitSDHash = NULL;
DWORD dwHashSize, dwSplitSDHashSize;

ULONG CountSDs(void)
{
    JET_ERR err;
    ULONG ulRecCount = 0, ulSDCount = 0;
    SD_ENTRY* pSDNode;
    BOOL     fNewNode;

    MD5_CTX Md5Context;

    PSECURITY_DESCRIPTOR pSDexplicit = NULL, pSDinherited = NULL;
    DWORD cSDexplicit_len = 0, cSDinherited_len = 0;

    fprintf(stderr, "Counting Unique SDs\n");
    fprintf(stderr, "%12s %12s\n", "Objects", "SDs");

    // create hash table(s)
    dwHashSize = dwEstimatedCount / 40;
    if (dwHashSize < 100) dwHashSize = 100;
    pHash = (HASH_ENTRY**) malloc(dwHashSize * sizeof(HASH_ENTRY*));
    if (pHash == NULL) {
        fprintf(stderr, "Out of memory.\n");
        JetError(0, "malloc");
    }
    memset(pHash, 0, dwHashSize * sizeof(HASH_ENTRY*));
    if (fSplit != 1) {
        dwSplitSDHashSize = dwEstimatedCount / 40;
        if (dwSplitSDHashSize < 100) dwSplitSDHashSize = 100;
        pSplitSDHash = (HASH_ENTRY**) malloc(dwSplitSDHashSize * sizeof(HASH_ENTRY*));
        if (pSplitSDHash == NULL) {
            fprintf(stderr, "Out of memory.\n");
            JetError(0, "malloc");
        }
        memset(pSplitSDHash, 0, dwHashSize * sizeof(HASH_ENTRY*));
    }

    err = JetMove(sesid, tblid, JET_MoveFirst, 0);

    while (!err) {

        ulRecCount++;

        err = JetRetrieveColumns(sesid,
                                tblid,
                                jSDCols,
                                cSDFixedColumns);

        if (err && (err != JET_wrnColumnNull)) {
            DWORD i;

            for (i=0; i < cSDFixedColumns; i++) {
                printf("-- Column %d, error %d, actual size %u\n", i, jSDCols[i].err, jSDCols[i].cbActual);
            }
            JetError(err, "JetRetrieveColumns");
        }
        if (ulDnt == 2 || jSDCols[1].err == JET_wrnColumnNull) {
            goto next;
        }

        if (!fSplit || fSplit == 1) {

            MD5Init(&Md5Context);

            MD5Update(
                &Md5Context,
                jSDCols[1].pvData,
                jSDCols[1].cbActual
                );

            MD5Final(
                &Md5Context
                );

            pSDNode = (SD_ENTRY*) AddNode (pHash, dwHashSize, (PDWORD)Md5Context.digest, sizeof(SD_ENTRY), &fNewNode);
            if (fNewNode) {
                AnalyzeSD((PSECURITY_DESCRIPTOR)jSDCols[1].pvData, jSDCols[1].cbActual, pSDNode);
                pSDNode->sdType = ' ';
                ulSDCount++;
            }
        }

        if (!fSplit || fSplit == 2) {

            BreakSDApart (
                    jSDCols[1].pvData,
                    jSDCols[1].cbActual,
                    &pSDexplicit,
                    &cSDexplicit_len,
                    &pSDinherited,
                    &cSDinherited_len);

            if (cSDinherited_len) {
                MD5Init(&Md5Context);

                MD5Update(
                    &Md5Context,
                    pSDinherited,
                    cSDinherited_len
                    );

                MD5Final(
                    &Md5Context
                    );

                pSDNode = (SD_ENTRY*) AddNode (pSplitSDHash, dwSplitSDHashSize, (PDWORD)Md5Context.digest, sizeof(SD_ENTRY), &fNewNode);
                if (fNewNode) {
                    AnalyzeSD(pSDinherited, cSDinherited_len, pSDNode);
                    pSDNode->sdType = 'I';
                }
            }

            if (cSDexplicit_len) {
                MD5Init(&Md5Context);

                MD5Update(
                    &Md5Context,
                    pSDexplicit,
                    cSDexplicit_len
                    );

                MD5Final(
                    &Md5Context
                    );

                pSDNode = (SD_ENTRY*) AddNode (pSplitSDHash, dwSplitSDHashSize, (PDWORD)Md5Context.digest, sizeof(SD_ENTRY), &fNewNode);
                if (fNewNode) {
                    AnalyzeSD(pSDexplicit, cSDexplicit_len, pSDNode);
                    pSDNode->sdType = 'E';
                }
            }
        }


        if (ulRecCount % 256 == 0) {
            fprintf (stderr, "%12u %12u\r", ulRecCount, ulSDCount);
        }

next:
        err = JetMove(sesid, tblid, JET_MoveNext, 0);

    }

    if (err != JET_errNoCurrentRecord)
        JetError(err, "JetMove");


    fprintf (stderr, "%12u %12u\n\n", ulRecCount, ulSDCount);

    if (!fSplit || fSplit == 1) {
        printf("SD stats:\n%7s %1s %6s %3s %3s %3s %3s %3s %4s\n",
                "Count", "T", "Length", "ACE", "Exp", "Inh", "DnE", "DnI", "Ctrl");
        TraverseHashTable(pHash, dwHashSize, PrintNodeSD);
        printf("\n\n\n\n");
        printf("Unique SDs:        %12u\n", ulUnique);
        printf("Total  SDs:        %12u\n", ulTotalCount);
        printf("Unique total size: %12u\n", ulTotalUniqueSize);
        printf("Total SD size:     %12u\n\n", ulTotalSize);
        printf("Min SD size:       %12u\n", ulMinLength);
        printf("Max SD size:       %12u\n", ulMaxLength);
        printf("Min ACE count:     %12u\n", ulMinAceCount);
        printf("Max ACE count:     %12u\n", ulMaxAceCount);
        printf("Avg ACE count:     %12u\n\n", ulAvgAceCount / ulUnique);
        printf("Deny ACE stats:\n");
        printf("  SDs count:       %12u\n", ulDenyAceSDs);
        printf("  Objects count:   %12u\n", ulDenyAceObjects);
        printf("\n\n\n\n");
    }

    if (!fSplit || fSplit == 2) {
        ulUnique = ulTotalCount = 0;
        ulTotalUniqueSize = ulTotalSize = 0;

        printf("Split SD stats:\n%7s %1s %6s %3s %3s %3s %3s %3s %4s\n",
                "Count", "T", "Length", "ACE", "Exp", "Inh", "DnE", "DnI", "Ctrl");
        TraverseHashTable(pSplitSDHash, dwSplitSDHashSize, PrintNodeSD);
        printf("\n\n");
        printf("Unique SDs:        %12u\n", ulUnique);
        printf("Total  SDs:        %12u\n", ulTotalCount);
        printf("Unique total size: %12u\n", ulTotalUniqueSize);
        printf("Total SD size:     %12u\n", ulTotalSize);
        printf("\n\n\n\n");
    }

    return ulRecCount;
}


/*        1         2         3         4         5         6         7
 123456789012345678901234567890123456789012345678901234567890123456789012345678
*/
char szLabel[] =
"   DNT   PDNT  NCDNT RefCnt V O IT Deletion Time     RdnTyp CC  RDN                  GUID                                 SID  ObjectClass\n\n";

ULONG WalkDB(void)
{
    JET_ERR err;
    ULONG ulRecCount = 0;
    ULONG ulContainerCount = 0;
    ULONG ulOldPdnt = 0xffffffff;

    DWORD Key[4];
    BOOL fNewNode;

    // display header
    fprintf(stdout,szLabel);

    if (fbCountClasses) {
        dwHashSize = 5000;
        pHash = (HASH_ENTRY**)malloc(dwHashSize * sizeof(HASH_ENTRY*));
        if (pHash == NULL) {
            fprintf(stderr, "Out of memory.\n");
            JetError(0, "malloc");
        }
        memset(pHash, 0, dwHashSize * sizeof(HASH_ENTRY*));
    }

    err = JetMove(sesid, tblid, JET_MoveFirst, 0);

    while (!err)
    {
        ulRecCount++;
    
        err = JetRetrieveColumns(sesid,
            tblid,
            jrc,
            cFixedColumns);
    
        if (err &&
           (err != JET_wrnColumnNull))
        {
            DWORD i;

            for (i=0; i < cFixedColumns; i++) {
                printf("-- Column %d, error %d, actual size %u\n", i, jrc[i].err, jrc[i].cbActual);
            }

            JetError(err, "JetRetrieveColumns");
        }
    
        if (fCountByContainer)
        {
            if (jrc[1].err)
                ulPdnt = 0;
    
            if (ulPdnt != ulOldPdnt)
            {
            if (ulOldPdnt != 0xffffffff)
            {
                fprintf(stdout,"Records in container %u: %u\n\n",
                ulOldPdnt, ulContainerCount);
            }
            ulContainerCount = 0;
            ulOldPdnt = ulPdnt;
            }
            ulContainerCount++;
        }

        if (fbCountClasses) {
            Key[0]= jrc[12].cbActual ? objClass : 0;
            Key[1]= jrc[6].cbActual ? bObject : 0;
            Key[2]= jrc[7].cbActual ? 1 : 0;  // deleted time
            Key[3]=0;

            AddNode (pHash, dwHashSize,
                     Key,
                     sizeof(HASH_ENTRY),
                     &fNewNode);

            if (ulRecCount % 100 == 0) {
                fprintf (stderr, "%9d             \r", ulRecCount);
            }
        }

        if (!fbCountClasses) {
            DisplayRecord();
        }

        err = JetMove(sesid, tblid, JET_MoveNext, 0);
    }

    if (err != JET_errNoCurrentRecord)
        JetError(err, "JetMove");


    if (fCountByContainer)
    {
        fprintf(stdout,"Records in container %u: %u\n\n",
            ulOldPdnt, ulContainerCount);
    }

    if (fbCountClasses) {
        TraverseHashTable(pHash, dwHashSize, PrintNodeObjectClass);
        printf("Objects Counted: %d\r", ulTotalCount);
    }

    return ulRecCount;
}


/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/* This routine does in place swap of the the last sub-authority of the SID */
void
InPlaceSwapSid(PSID pSid)
{
    ULONG ulSubAuthorityCount;

    ulSubAuthorityCount= *(RtlSubAuthorityCountSid(pSid));
    if (ulSubAuthorityCount > 0)
    {
        PBYTE  RidLocation;
        BYTE   Tmp[4];

        RidLocation =  (PBYTE) RtlSubAuthoritySid(
                             pSid,
                             ulSubAuthorityCount-1
                             );

        //
        // Now byte swap the Rid location
        //

        Tmp[0] = RidLocation[3];
        Tmp[1] = RidLocation[2];
        Tmp[2] = RidLocation[1];
        Tmp[3] = RidLocation[0];

        RtlCopyMemory(RidLocation,Tmp,sizeof(ULONG));
    }
}


void DisplayRecord(void)
{
    char szDelTime[SZDSTIME_LEN];
    int i, j;

    // DNT
    if (!jrc[0].err)
    fprintf(stdout, "%6u ", ulDnt);
    else
    fprintf(stdout, "     - ");

    // PDNT
    if (!jrc[1].err)
    fprintf(stdout, "%6u ", ulPdnt);
    else
    fprintf(stdout, "     - ");

    // NC DNT
    if (!jrc[5].err)
    fprintf(stdout, "%6u ", ulNcDnt);
    else
    fprintf(stdout, "     - ");

    // RDN
    if (jrc[2].err)
    szRdn[0] = L'\0';
    else
        szRdn[jrc[2].cbActual/sizeof(WCHAR)] = L'\0';

    // refernce count
    if (!jrc[3].err)
    fprintf(stdout, "%6d ", lCount);
    else
    fprintf(stdout, "     - ");

    // Is visbible in AB
    if (!jrc[4].err)
    fprintf(stdout, "%1u ", (ULONG) bIsVisibleInAB);
    else
    fprintf(stdout, "- ");

    // object flag
    if (!jrc[6].err)
    fprintf(stdout, "%1u ", (ULONG) bObject);
    else
    fprintf(stdout, "- ");

    // Instance type
    if (!jrc[10].err)
        fprintf(stdout, "%2d ", insttype);
    else
        fprintf(stdout, " - ");

    // deletion time
    if (!jrc[7].err)
    fprintf(stdout, "%s ", DSTimeToDisplayString(DelTime, szDelTime));
    else
    fprintf(stdout, "                  ");

    // RDN type
    if (!jrc[8].err)
    fprintf(stdout, "%6u ", ulRdnType);
    else
    fprintf(stdout, "     - ");

    fprintf(stdout, "%03d ",jrc[2].cbActual);

    fprintf(stdout, "%-20S ", szRdn);

    // Guid
    if (!jrc[9].err) {
        LPSTR       pszGuid = NULL;
        RPC_STATUS  rpcStatus;

        rpcStatus = UuidToString(&Guid, &pszGuid);
        if (0 != rpcStatus) {
            fprintf(stderr, "UuidToString failed with error %d\n", rpcStatus);
            fprintf(stdout, "!! UuidToString failed with error %d", rpcStatus);
        }
        else {
            fprintf(stdout, "%s ", pszGuid);
            RpcStringFree(&pszGuid);
        }
    }
    else
    fprintf(stdout,"no guid                              ");

    // SID
    if (!jrc[11].err) {
        WCHAR SidText[128];
        UNICODE_STRING us;

        SidText[0] = L'\0';
        us.MaximumLength = sizeof(SidText);
        us.Length = 0;
        us.Buffer = SidText;

        InPlaceSwapSid(&Sid);
        RtlConvertSidToUnicodeString(&us, &Sid, FALSE);
        fprintf(stdout, "%ls", SidText);
    }
    else {
    fprintf(stdout, "no sid");
    }

    // objectClass
    if (!jrc[12].err)
    fprintf(stdout, " %6x ", objClass);
    else
    fprintf(stdout, "   - ");




    // newline
    fprintf(stdout, "\n");
}

void DumpHidden()
{
    JET_ERR err;
    JET_COLUMNDEF coldef;
    JET_COLUMNID dsaid;
    JET_COLUMNID dsstateid;
    JET_COLUMNID usnid;
    DWORD actuallen;
    DWORD dntDSA;
    DWORD dwState;
    USN   usn;

    if (err = JetOpenTable(sesid, dbid, SZHIDDENTABLE, NULL, 0, 0, &tblid))
    JetError(err, "JetOpenTable");

    /* Get USN column ID */

    JetGetTableColumnInfo(sesid,
              tblid,
              SZUSN,
              &coldef,
              sizeof(coldef),
              0);
    usnid = coldef.columnid;

    /* Get DSA name column ID */

    JetGetTableColumnInfo(sesid,
              tblid,
              SZDSA,
              &coldef,
              sizeof(coldef),
              0);
    dsaid = coldef.columnid;

    /* Get DSA installation state column ID */

    JetGetTableColumnInfo(sesid,
              tblid,
              SZDSSTATE,
              &coldef,
              sizeof(coldef),
              0);
    dsstateid = coldef.columnid;

    JetMove(sesid,
        tblid,
        JET_MoveFirst,
        0);

    JetRetrieveColumn(sesid,
              tblid,
              usnid,
              &usn,
              sizeof(usn),
              &actuallen,
              0,
              NULL);

    JetRetrieveColumn(sesid,
              tblid,
              dsaid,
              &dntDSA,
              sizeof(dntDSA),
              &actuallen,
              0,
              NULL);

    JetRetrieveColumn(sesid,
              tblid,
              dsstateid,
              &dwState,
              sizeof(dwState),
              &actuallen,
              0,
              NULL);


    printf("Hidden record: DSA dnt = %d, current USN = %ld, state = %d\n",
       dntDSA,
       usn,
       dwState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\common\bindings.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    common\bindings.c

ABSTRACT:

    This file has all the binding type functions, for getting Cached LDAP, DS,
    or Net Use/Named Pipe bindings.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

--*/

#include <ntdspch.h>

#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>

#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>
#include <permit.h>

#include <netevent.h>

#include "dcdiag.h"
#include "ldaputil.h"
#include "ndnc.h"


// Code.Improvement move this function here from intersite.c
VOID
InitLsaString(
    OUT  PLSA_UNICODE_STRING pLsaString,
    IN   LPWSTR              pszString
    );


// ===========================================================================
// Ldap connections/binding (ldap_init(), ldap_bind(), ldap_unbind(), etc)
// ===========================================================================

DWORD
DcDiagCacheServerRootDseAttrs(
    IN LDAP *hLdapBinding,
    IN PDC_DIAG_SERVERINFO pServer
    )

/*++

Routine Description:

    Reads server-specific Root DSE attributes and caches them in the server
    object.

    Helper routine for GetLdapBinding(). This may also be called by GatherInfo,
    which constructs the ldap binding to the home server directly without calling
    GetLdapBinding().

    In order to help diagnose binding errors, it is necessary to obtain Root DSE
    attributes before the bind takes place. We report errors here in this routine
    to help identify contributing factors to a bind failure.

Arguments:

    hLdapBinding - Binding to server that is going to be queried
    pServer - Server corresponding to binding, to receive attributes

Return Value:

    DWORD -

--*/

{
    DWORD dwRet;
    LPWSTR  ppszRootDseServerAttrs [] = {
        L"currentTime",
        L"highestCommittedUSN",
        L"isSynchronized",
        L"isGlobalCatalogReady",
        NULL };
    LDAPMessage *              pldmEntry = NULL;
    LDAPMessage *              pldmRootResults = NULL;
    LPWSTR *                   ppszValues = NULL;

    dwRet = ldap_search_sW (hLdapBinding,
                            NULL,
                            LDAP_SCOPE_BASE,
                            L"(objectCategory=*)",
                            ppszRootDseServerAttrs,
                            0,
                            &pldmRootResults);
    if (dwRet != ERROR_SUCCESS) {
        dwRet = LdapMapErrorToWin32(dwRet);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP search failed with error %d,\n",
                     pServer->pszName, dwRet);
        PrintMessage(SEV_ALWAYS, L"%s.\n", Win32ErrToString(dwRet));
        goto cleanup;
    }
    if (pldmRootResults == NULL) {
        dwRet = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    pldmEntry = ldap_first_entry (hLdapBinding, pldmRootResults);
    if (pldmEntry == NULL) {
        dwRet = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    //
    // Attribute: currentTime
    //

    ppszValues = ldap_get_valuesW( hLdapBinding, pldmEntry, L"currentTime" );
    if ( (ppszValues) && (ppszValues[0]) ) {
        SYSTEMTIME systemTime;

        PrintMessage( SEV_DEBUG, L"%s.currentTime = %ls\n",
                      pServer->pszName,
                      ppszValues[0] );

        dwRet = DcDiagGeneralizedTimeToSystemTime((LPWSTR) ppszValues[0], &systemTime);
        if(dwRet == ERROR_SUCCESS){
            SystemTimeToFileTime(&systemTime, &(pServer->ftRemoteConnectTime) );
            GetSystemTime( &systemTime );
            SystemTimeToFileTime( &systemTime, &(pServer->ftLocalAcquireTime) );
        } else {
            PrintMessage( SEV_ALWAYS, L"[%s] Warning: Root DSE attribute %ls is has invalid value %ls\n",
                          pServer->pszName, L"currentTime", ppszValues[0] );
            // keep going, not fatal
        }
    } else {
        PrintMessage( SEV_ALWAYS, L"[%s] Warning: Root DSE attribute %ls is missing\n",
                     pServer->pszName, L"currentTime" );
        // keep going, not fatal
    }
    ldap_value_freeW(ppszValues );

    //
    // Attribute: highestCommittedUSN
    //

    ppszValues = ldap_get_valuesW( hLdapBinding, pldmEntry, L"highestCommittedUSN" );
    if ( (ppszValues) && (ppszValues[0]) ) {
        pServer->usnHighestCommittedUSN = _wtoi64( *ppszValues );
    } else {
        PrintMessage( SEV_ALWAYS, L"[%s] Warning: Root DSE attribute %ls is missing\n",
                     pServer->pszName, L"highestCommittedUSN" );
        // keep going, not fatal
    }
    ldap_value_freeW(ppszValues );
    PrintMessage( SEV_DEBUG, L"%s.highestCommittedUSN = %I64d\n",
                  pServer->pszName,
                  pServer->usnHighestCommittedUSN );

    //
    // Attribute: isSynchronized
    //

    ppszValues = ldap_get_valuesW( hLdapBinding, pldmEntry, L"isSynchronized" );
    if ( (ppszValues) && (ppszValues[0]) ) {
        pServer->bIsSynchronized = (_wcsicmp( ppszValues[0], L"TRUE" ) == 0);
    } else {
        PrintMessage( SEV_ALWAYS, L"[%s] Warning: Root DSE attribute %ls is missing\n",
                     pServer->pszName, L"isSynchronized" );
        // keep going, not fatal
    }
    ldap_value_freeW(ppszValues );
    PrintMessage( SEV_DEBUG, L"%s.isSynchronized = %d\n",
                  pServer->pszName,
                  pServer->bIsSynchronized );
    if (!pServer->bIsSynchronized) {
        PrintMsg( SEV_ALWAYS, DCDIAG_INITIAL_DS_NOT_SYNCED, pServer->pszName );
    }

    //
    // Attribute: isGlobalCatalogReady
    //

    ppszValues = ldap_get_valuesW( hLdapBinding, pldmEntry, L"isGlobalCatalogReady" );
    if ( (ppszValues) && (ppszValues[0]) ) {
        pServer->bIsGlobalCatalogReady = (_wcsicmp( ppszValues[0], L"TRUE" ) == 0);
    } else {
        PrintMessage( SEV_ALWAYS, L"[%s] Warning: Root DSE attribute %ls is missing\n",
                     pServer->pszName, L"isGlobalCatalogReady" );
        // keep going, not fatal
    }
    ldap_value_freeW(ppszValues );
    PrintMessage( SEV_DEBUG, L"%s.isGlobalCatalogReady = %d\n",
                  pServer->pszName,
                  pServer->bIsGlobalCatalogReady );

cleanup:

    if (pldmRootResults) {
        ldap_msgfree (pldmRootResults);
    }

    return dwRet;
} /* DcDiagCacheServerRootDseAttrs */

DWORD
DcDiagGetLdapBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    IN   BOOL                                bUseGcPort,
    OUT  LDAP * *                            phLdapBinding
    )
/*++

Routine Description:

    This returns a LDAP binding from ldap_init() and ldap_bind_sW().  The
    function caches the binding handle and the error.  This function also
    turns off referrals.

Arguments:

    pServer - Server for which binding is desired
    gpCreds - Credentials
    bUseGcPort - Whether to bind to the GC port
    phLdapBinding - Returned binding, on success. Also cached.

Return Value:

    NOTE - DO NOT unbind the ldap handle.
    DWORD - Win32 error return

--*/
{
    DWORD                                    dwRet;
    LDAP *                                   hLdapBinding;
    LPWSTR                                   pszServer = NULL;
    ULONG                                    ulOptions = PtrToUlong(LDAP_OPT_ON);

    // Return cached failure if stored
    // Success can mean never tried, or binding present
    dwRet = bUseGcPort ? pServer->dwGcLdapError : pServer->dwLdapError;
    if(dwRet != ERROR_SUCCESS){
        return dwRet;
    }

    // Return cached binding if stored
    hLdapBinding = bUseGcPort ? pServer->hGcLdapBinding : pServer->hLdapBinding;
    if (hLdapBinding != NULL) {
        *phLdapBinding = hLdapBinding;
        return ERROR_SUCCESS;
    }

    // Try to refresh the cache by contacting the server

    if(pServer->pszGuidDNSName == NULL){
        // This means that the Guid name isn't specified, use normal name.
        pszServer = pServer->pszName;
    } else {
        pszServer = pServer->pszGuidDNSName;
    }
    Assert(pszServer);

    //
    // There is no existing ldap binding of the kind we want.  so create one
    //

    hLdapBinding = ldap_initW(pszServer, bUseGcPort ? LDAP_GC_PORT : LDAP_PORT);
    if(hLdapBinding == NULL){
        dwRet = GetLastError();
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP connection failed with error %d,\n",
                     pServer->pszName,
                     dwRet);
        PrintMessage(SEV_ALWAYS,
                     L"%s.\n",
                     Win32ErrToString(dwRet));
        goto cleanup;
    }

    // use only A record dns name discovery
    (void)ldap_set_optionW( hLdapBinding, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions);

    // Set Ldap referral option
    dwRet = ldap_set_option(hLdapBinding, LDAP_OPT_REFERRALS, LDAP_OPT_OFF);
    if(dwRet != LDAP_SUCCESS){
        dwRet = LdapMapErrorToWin32(dwRet);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP setting options failed with error %d,\n",
                     pServer->pszName,
                     dwRet);
        PrintMessage(SEV_ALWAYS, L"%s.\n",
                     Win32ErrToString(dwRet));
        goto cleanup;
    }

    // Cache some RootDSE attributes we are interested in
    // Do this before binding so we can obtain info to help us diagnose
    // security problems.
    dwRet = DcDiagCacheServerRootDseAttrs( hLdapBinding, pServer );
    if (dwRet) {
        // Error already displayed
        goto cleanup;
    }

    // Perform ldap bind
    dwRet = ldap_bind_sW(hLdapBinding,
                         NULL,
                         (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                         LDAP_AUTH_SSPI);
    if(dwRet != LDAP_SUCCESS){
        dwRet = LdapMapErrorToWin32(dwRet);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP bind failed with error %d,\n",
                     pServer->pszName,
                     dwRet);
        PrintMessage(SEV_ALWAYS, L"%s.\n",
                     Win32ErrToString(dwRet));
        goto cleanup;
    }

cleanup:

    if (!dwRet) {
        *phLdapBinding = hLdapBinding;
    } else {
        if (hLdapBinding) {
            ldap_unbind(hLdapBinding);
            hLdapBinding = NULL;
        }
    }
    if(bUseGcPort){
        pServer->hGcLdapBinding = hLdapBinding;
        pServer->dwGcLdapError = dwRet;
    } else {
        pServer->hLdapBinding = hLdapBinding;
        pServer->dwLdapError = dwRet;
    }

    return dwRet;
} /* DcDiagGetLdapBinding */

DWORD
DcDiagGetDomainNamingFsmoLdapBinding(
    IN   PDC_DIAG_DSINFO                     pDsInfo,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    OUT  PULONG                              piFsmoServer,
    OUT  LPWSTR *                            ppszFsmoServer,
    OUT  LDAP **                             phLdapBinding
    )
/*++

Routine Description:

    This returns a LDAP binding to the Domain Naming FSMO via calls to
    ldap_init() and ldap_bind_sW().  The function caches the binding
    handle.  This function also turns off referrals.

Arguments:

    pDsInfo -
    gpCreds - Credentials
    piFsmoServer - Either this or the next parameter will be returned.
                    -1 if invalid, index into pDsInfo->pServers otherwise.
    ppszFsmoServer -  NULL if invalid, string name of FSMO server otherwise.
    phLdapBinding - Returned binding, on success. Also cached.

Return Value:

    NOTE - DO NOT unbind the ldap handle.
    DWORD - Win32 error return

--*/
{
    DWORD           dwRet = ERROR_SUCCESS;
    LPWSTR          pszHostName = NULL;
    LDAP *          hld = NULL;

    Assert(piFsmoServer);
    Assert(ppszFsmoServer);
    Assert(phLdapBinding);
    
    if(pDsInfo->hCachedDomainNamingFsmoLdap){
        *piFsmoServer = pDsInfo->iDomainNamingFsmo;
        *ppszFsmoServer = pDsInfo->pszDomainNamingFsmo;
        *phLdapBinding = pDsInfo->hCachedDomainNamingFsmoLdap;
        return(ERROR_SUCCESS);
    }

    *piFsmoServer = -1;
    *ppszFsmoServer = NULL;

    // Unfortunately this existing function isn't very in tune with our
    // existing DcDiagGetLdapBinding() structure, so we call this function
    // to get the LDAP * on the right server and then merge the information
    // a little awkwardly into our existing DsInfo struct.
    hld = GetDomNameFsmoLdapBinding(
            pDsInfo->pServers[pDsInfo->ulHomeServer].pszGuidDNSName,
                                    FALSE,
                                    gpCreds,
                                    &dwRet);
    if(hld == NULL || dwRet){
        Assert(hld == NULL);
        Assert(dwRet);
        return(dwRet);
    }
    Assert(hld);

    // Now must set iFsmoServer || pszFsmoServer on pDsInfo
    dwRet = GetRootAttr(hld, L"dnsHostName", &pszHostName);
    if (dwRet) {
        return(dwRet);
    }

    // Set return params
    *piFsmoServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, NULL,
                         pszHostName, NULL);
    if(*piFsmoServer == -1){
        // No existing server object in pServers, so we have to cache
        // this the hard way.
        *phLdapBinding = hld;
        *ppszFsmoServer = pszHostName;
    } else {
        LocalFree(pszHostName);
        ldap_unbind(hld);
        dwRet = DcDiagGetLdapBinding(&pDsInfo->pServers[*piFsmoServer],
                                     gpCreds, FALSE, phLdapBinding);
        if (dwRet) {
            *phLdapBinding = NULL;
        }
    }

    Assert( (*piFsmoServer != -1) || (*ppszFsmoServer != NULL) );
    Assert( *phLdapBinding );
    
    // Cache the binding info on the pDsInfo struct.
    pDsInfo->iDomainNamingFsmo = *piFsmoServer;
    pDsInfo->pszDomainNamingFsmo = *ppszFsmoServer;
    pDsInfo->hCachedDomainNamingFsmoLdap = *phLdapBinding;

    return(ERROR_SUCCESS);
}


// ===========================================================================
// Ds RPC handle binding (DsBind, DsUnBind(), etc)
// ===========================================================================
DWORD
DcDiagGetDsBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    OUT  HANDLE *                            phDsBinding
    )
/*++

Routine Description:

    This returns a Ds Binding from DsBindWithCredW(), this binding is cached, as
    well as the error if there is one.

Arguments:

    pServer - A pointer to the server structure you want the Ds Binding of.
    gpCreds - Credentials.
    phDsBinding - return value for the ds binding handle.

Return Value:

    Returns a standard Win32 error.

    NOTE - DO NOT unbind the ds handle.

--*/
{
    DWORD                                    dwRet;
    LPWSTR                                   pszServer = NULL;

    if(pServer->dwDsError != ERROR_SUCCESS){
        return(pServer->dwDsError);
    }
    if(pServer->pszGuidDNSName == NULL){
        pszServer = pServer->pszName;
    } else {
        pszServer = pServer->pszGuidDNSName;
    }
    Assert(pszServer != NULL);

    if(pServer->hDsBinding == NULL){
        // no exisiting binding stored, hey I have an idea ... lets create one!
        dwRet = DsBindWithSpnEx(pszServer,
                                NULL,
                                (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                                NULL, // use default SPN
                                0, // no flags = impersonation, but no delegation binding
                                &pServer->hDsBinding);
        if(dwRet != NO_ERROR){
            PrintMessage(SEV_ALWAYS,
                         L"[%s] DsBindWithSpnEx() failed with error %d,\n",
                         pServer->pszName,
                         dwRet);
            PrintMessage(SEV_ALWAYS, L"%s.\n",
                         Win32ErrToString(dwRet));
            PrintRpcExtendedInfo(SEV_VERBOSE, dwRet);
            pServer->dwDsError = dwRet;
    	    return(dwRet);
    	}
    } // else we already had a binding in the pServer structure, either way
    //     we now have a binding in the pServer structure. :)
    *phDsBinding = pServer->hDsBinding;
    pServer->dwDsError = ERROR_SUCCESS;
    return(NO_ERROR);

}


// ===========================================================================
// Net Use binding (WNetAddConnection2(), WNetCancelConnection(), etc)
// ===========================================================================
DWORD
DcDiagGetNetConnection(
    IN  PDC_DIAG_SERVERINFO             pServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W *     gpCreds
    )
/*++

Routine Description:

    This routine will make sure there is a net use/unnamed pipe connection
    to the target machine pServer.

Arguments:

    pServer - Server to Add the Net connection to.
    gpCreds - the crdentials.

Return Value:

    DWORD - win 32 error.

--*/
{
    DWORD                               dwToSet = ERROR_SUCCESS;
    LPWSTR                              pszNetUseServer = NULL;
    LPWSTR                              pszNetUseUser = NULL;
    LPWSTR                              pszNetUsePassword = NULL;
    ULONG                               iTemp;

    if(pServer->dwNetUseError != ERROR_SUCCESS){
        return(pServer->dwNetUseError);
    }

    if(pServer->sNetUseBinding.pszNetUseServer != NULL){
        // Do nothing if there already is a net use connection setup.
        Assert(pServer->dwNetUseError == ERROR_SUCCESS);
    } else {
        // INIT ----------------------------------------------------------
        // Always initialize the object attributes to all zeroes.
        InitializeObjectAttributes(
            &(pServer->sNetUseBinding.ObjectAttributes),
            NULL, 0, NULL, NULL);

        // Initialize various strings for the Lsa Services and for
        //     WNetAddConnection2()
        InitLsaString( &(pServer->sNetUseBinding.sLsaServerString),
                       pServer->pszName );
        InitLsaString( &(pServer->sNetUseBinding.sLsaRightsString),
                       SE_NETWORK_LOGON_NAME );

        if(gpCreds != NULL
           && gpCreds->User != NULL
           && gpCreds->Password != NULL
           && gpCreds->Domain != NULL){
            // only need 2 for NULL, and an extra just in case.
            iTemp = wcslen(gpCreds->Domain) + wcslen(gpCreds->User) + 4;
            pszNetUseUser = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR));
            if(pszNetUseUser == NULL){
                dwToSet = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanUpAndExit;
            }
            wcscpy(pszNetUseUser, gpCreds->Domain);
            wcscat(pszNetUseUser, L"\\");
            wcscat(pszNetUseUser, gpCreds->User);
            pszNetUsePassword = gpCreds->Password;
        } // end if creds, else assume default creds ...
        //      pszNetUseUser = NULL; pszNetUsePassword = NULL;

        // "\\\\" + "\\ipc$"
        iTemp = wcslen(pServer->pszName) + 10;
        pszNetUseServer = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR));
        if(pszNetUseServer == NULL){
            dwToSet = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanUpAndExit;
        }
        wcscpy(pszNetUseServer, L"\\\\");
        wcscat(pszNetUseServer, pServer->pszName);
        wcscat(pszNetUseServer, L"\\ipc$");

        // Initialize NetResource structure for WNetAddConnection2()
        pServer->sNetUseBinding.NetResource.dwType = RESOURCETYPE_ANY;
        pServer->sNetUseBinding.NetResource.lpLocalName = NULL;
        pServer->sNetUseBinding.NetResource.lpRemoteName = pszNetUseServer;
        pServer->sNetUseBinding.NetResource.lpProvider = NULL;

        // CONNECT & QUERY -----------------------------------------------
        //net use \\brettsh-posh\ipc$ /u:brettsh-fsmo\administrator ""
        dwToSet = WNetAddConnection2(
            &(pServer->sNetUseBinding.NetResource), // connection details
            pszNetUsePassword, // points to password
            pszNetUseUser, // points to user name string
            0); // set of bit flags that specify

    CleanUpAndExit:

        if(dwToSet == ERROR_SUCCESS){
            // Setup the servers binding struct.
            pServer->sNetUseBinding.pszNetUseServer = pszNetUseServer;
            pServer->sNetUseBinding.pszNetUseUser = pszNetUseUser;
            pServer->dwNetUseError = ERROR_SUCCESS;
        } else {
            // There was an error, print it, clean up, and set error.
            switch(dwToSet){
            case ERROR_SUCCESS:
                Assert(!"This is completely impossible");
                break;
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                PrintMessage(SEV_ALWAYS,
                             L"* You must make sure there are no existing "
                             L"net use connections,\n");
                PrintMessage(SEV_ALWAYS,
                             L"  you can use \"net use /d %s\" or \"net use "
                             L"/d\n", pszNetUseServer);
                PrintMessage(SEV_ALWAYS,
                             L"  \\\\<machine-name>\\<share-name>\"\n");
                break;
            case ERROR_NOT_ENOUGH_MEMORY:
                PrintMessage(SEV_ALWAYS,
                             L"Fatal Error: Not enough memory to complete "
                             L"operation.\n");
                break;
            case ERROR_ALREADY_ASSIGNED:
                PrintMessage(SEV_ALWAYS,
                             L"Fatal Error: The network resource is already "
                             L"in use\n");
                break;
            case STATUS_ACCESS_DENIED:
            case ERROR_INVALID_PASSWORD:
            case ERROR_LOGON_FAILURE:
                // This comes from the LsaOpenPolicy or
                //    LsaEnumerateAccountsWithUserRight or
                //    from WNetAddConnection2
                PrintMessage(SEV_ALWAYS,
                             L"User credentials does not have permission to "
                             L"perform this operation.\n");
                PrintMessage(SEV_ALWAYS,
                             L"The account used for this test must have "
                             L"network logon privileges\n");
                PrintMessage(SEV_ALWAYS,
                             L"for the target machine's domain.\n");
                break;
            case STATUS_NO_MORE_ENTRIES:
                // This comes from LsaEnumerateAccountsWithUserRight
            default:
                PrintMessage(SEV_ALWAYS,
                             L"[%s] An net use or LsaPolicy operation failed "
                             L"with error %d, %s.\n",
                             pServer->pszName,
                             dwToSet,
                             Win32ErrToString(dwToSet));
                break;
            }
            // Clean up any possible allocations.
            if(pszNetUseServer != NULL)    LocalFree(pszNetUseServer);
            if(pszNetUseUser != NULL)      LocalFree(pszNetUseUser);
            pServer->dwNetUseError = dwToSet;
        }
    }

    return(pServer->dwNetUseError);
}


VOID
DcDiagTearDownNetConnection(
    IN  PDC_DIAG_SERVERINFO             pServer
    )
/*++

Routine Description:

    This will tear down the Net Connection added by DcDiagGetNetConnection()

Arguments:

    pServer - The target server.

Return Value:

    DWORD - win 32 error.

--*/
{
    if(pServer->sNetUseBinding.pszNetUseServer != NULL){
        WNetCancelConnection2(pServer->sNetUseBinding.pszNetUseServer,
                              0, FALSE);
        LocalFree(pServer->sNetUseBinding.pszNetUseServer);
        LocalFree(pServer->sNetUseBinding.pszNetUseUser);
        pServer->sNetUseBinding.pszNetUseServer = NULL;
        pServer->sNetUseBinding.pszNetUseUser = NULL;
    } else {
        Assert(!"Bad Programmer, calling TearDown on a closed connection\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\common\dscache.c ===
/*++

Copyright (c) 2001 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dcdiag/common/dscache.c

ABSTRACT:

    This is the central caching and access functions for the DC_DIAG_DSINFO cache.

DETAILS:

CREATED:

    09/04/2001    Brett Shirley (brettsh)
    
        Pulled the caching functions from dcdiag\common\main.c

REVISION HISTORY:


--*/

#include <ntdspch.h>
#include <objids.h>
#include <ntdsa.h>
#include <dnsapi.h>
#include <dsconfig.h> //for DEFAULT_TOMBSTONE_LIFETIME

#include "dcdiag.h"
#include "utils.h"
#include "repl.h" // Need for ReplServerConnectFailureAnalysis()


// For asserts.
#ifdef DBG
    BOOL   gDsInfo_NcList_Initialized = FALSE;
#endif


LPWSTR
DcDiagAllocNameFromDn (
    LPWSTR            pszDn
    )
/*++

Routine Description:

    This routing take a DN and returns the second RDN in LocalAlloc()'d memory.
    This is used to return the server name portion of an NTDS Settings DN.

Arguments:

    pszDn - (IN) DN

Return Value:

   The exploded DN.

--*/
{
    LPWSTR *    ppszDnExploded = NULL;
    LPWSTR      pszName = NULL;

    if (pszDn == NULL) {
        return NULL;
    }

    __try {
        ppszDnExploded = ldap_explode_dnW(pszDn, 1);
        if (ppszDnExploded == NULL) {
            DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
        }

        pszName = (LPWSTR) LocalAlloc(LMEM_FIXED,
                                      (wcslen (ppszDnExploded[1]) + 1)
                                      * sizeof (WCHAR));
        DcDiagChkNull(pszName);

        wcscpy (pszName, ppszDnExploded[1]);
    } __finally {
        if (ppszDnExploded != NULL) {
            ldap_value_freeW (ppszDnExploded);
        }
    }

    return pszName;
}

LPWSTR
DcDiagAllocGuidDNSName (
    LPWSTR            pszRootDomain,
    UUID *            pUuid
    )
/*++

Routine Description:

    This routine makes the GuidDNSName out of the RootDomain and Guid.

Arguments:

    pszRootDomain - (IN) The domain of the server.
    pUuid - (IN) The Guid of the server.

Return Value:

   The GuidDNSName

--*/
{
    LPWSTR            pszStringizedGuid = NULL;
    LPWSTR            pszGuidDNSName = NULL;

    __try {

    if(UuidToStringW (pUuid, &pszStringizedGuid) != RPC_S_OK){
        if(UuidToStringW(pUuid, &pszStringizedGuid) != RPC_S_OUT_OF_MEMORY){
            Assert(!"Ahhh programmer problem, UuidToString() inaccurately reports in"
                   " MSDN that it will only return one of two error codes, but apparently"
                   " it will return a 3rd.  Someone should figure out what to do about"
                   " this.");
        }
    }
    else {
        Assert(pszStringizedGuid);
        DcDiagChkNull (pszGuidDNSName = LocalAlloc (LMEM_FIXED, (wcslen (pszRootDomain) +
                          wcslen (pszStringizedGuid) + 2 + 7) * sizeof (WCHAR)));
                                      // added 9 , for the ".msdcs." string and the NULL char.
        swprintf (pszGuidDNSName, L"%s._msdcs.%s", pszStringizedGuid, pszRootDomain);
    }
    } __finally {

        if (pszStringizedGuid != NULL) RpcStringFreeW (&pszStringizedGuid);

    }

    return pszGuidDNSName;
}

PDSNAME
DcDiagAllocDSName (
    LPWSTR            pszStringDn
    )
/*++

    Ripped from ntdsapi

--*/
{
    PDSNAME            pDsname;
    DWORD            dwLen, dwBytes;

    if (pszStringDn == NULL)
    return NULL;

    dwLen = wcslen (pszStringDn);
    dwBytes = DSNameSizeFromLen (dwLen);

    DcDiagChkNull (pDsname = (DSNAME *) LocalAlloc (LMEM_FIXED, dwBytes));

    pDsname->NameLen = dwLen;
    pDsname->structLen = dwBytes;
    pDsname->SidLen = 0;
    //    memcpy(pDsname->Guid, &gNullUuid, sizeof(GUID));
    memset(&(pDsname->Guid), 0, sizeof(GUID));
    wcscpy (pDsname->StringName, pszStringDn);

    return pDsname;
}

BOOL
DcDiagEqualDNs (
    LPWSTR            pszDn1,
    LPWSTR            pszDn2

    )
/*++

Routine Description:

    The Dns Match function.

Arguments:

    pszDn1 - (IN) Dn number 1 to compare
    pszDn2 - (IN) Dn number 2 to compare

Return Value:

   TRUE if the Dn's match, FALSE otherwise

--*/
{
    PDSNAME            pDsname1 = NULL;
    PDSNAME            pDsname2 = NULL;
    BOOL            bResult;

    __try {

    pDsname1 = DcDiagAllocDSName (pszDn1);
    pDsname2 = DcDiagAllocDSName (pszDn2);

    bResult = NameMatched (pDsname1, pDsname2);

    } __finally {

    if (pDsname1 != NULL) LocalFree (pDsname1);
    if (pDsname2 != NULL) LocalFree (pDsname2);

    }

    return bResult;
}


ULONG
DcDiagGetServerNum(
    PDC_DIAG_DSINFO                 pDsInfo,
    LPWSTR                          pszName,
    LPWSTR                          pszGuidName,
    LPWSTR                          pszDsaDn,
    LPWSTR                          pszDNSName,
    LPGUID                          puuidInvocationId
    )
/*++

Routine Description:

    This function takes the pDsInfo, and returns the index into the
    pDsInfo->pServers array of the server that you specified with pszName,
    or pszGuidName, or pszDsaDn.

Arguments:

    pDsInfo - the enterpise info
    pszName - the flat level dns name (BRETTSH-DEV) to find
    pszGuidName - the guid based dns name (343-13...23._msdcs.root.com)
    pszDsaDn - the distinguished name of the NT DSA object. CN=NTDS Settings,CN=
       brettsh-dev,CN=Configuration,DC=root...
    pszDNSName - the regular DNS name like (brettsh-dev.ntdev.microsoft.com)
    puuidInvocationID - the GUID of an invocation of the dc
       gregjohn

Return Value:

    returns the index into the pServers array of the pDsInfo struct.

--*/
{
    ULONG      ul;

    Assert(pszName || pszGuidName || pszDsaDn || pszDNSName || puuidInvocationId);

    for(ul=0;ul<pDsInfo->ulNumServers;ul++){
        if(
            (pszGuidName &&
             (_wcsicmp(pszGuidName, pDsInfo->pServers[ul].pszGuidDNSName) == 0))
            || (pszName &&
                (_wcsicmp(pszName, pDsInfo->pServers[ul].pszName) == 0))
            || (pszDsaDn &&
                (_wcsicmp(pszDsaDn, pDsInfo->pServers[ul].pszDn) == 0))
            || (pszDNSName &&
                (DnsNameCompare_W(pszDNSName, pDsInfo->pServers[ul].pszDNSName) != 0))
	    || (puuidInvocationId &&
		(memcmp(puuidInvocationId, &(pDsInfo->pServers[ul].uuidInvocationId), sizeof(UUID)) == 0))
	    ){
            return ul;
        }
    }
    return(NO_SERVER);
}

ULONG
DcDiagGetNCNum(
    PDC_DIAG_DSINFO                     pDsInfo,
    LPWSTR                              pszNCDN,
    LPWSTR                              pszDomain
    )
/*++

Description:

    Like DcDiagGetServerNum, this takes the mini-enterprise structure, and
    a variable number of params to match to get the index into pDsInfo->pNCs
    of the NC specified by the other params.

Parameters:

    pDsInfo
    pszNCDN - The DN of the NC to find.
    pszDomain - Not yet implemented, just figured it'd be nice some day.

Return Value:

    The index of the NC if found, otherwise NO_NC.

--*/
{
    ULONG                               iNC;

    Assert(pszNCDN != NULL || pszDomain != NULL);
    Assert(pszDomain == NULL && "The pszDomain is not implemented yet\n");

    for(iNC = 0; iNC < pDsInfo->cNumNCs; iNC++){
        if((pszNCDN &&
            (_wcsicmp(pDsInfo->pNCs[iNC].pszDn, pszNCDN) == 0))
           // Code.Improvement add support for the domain name.
           ){
            // Got the right NC, return it.
            return(iNC);
        }
    } // end for each NC

    // Couldn't find the NC.
    return(NO_NC);
}

ULONG
DcDiagGetMemberOfNCList(
    LPWSTR pszTargetNC,
    PDC_DIAG_NCINFO pNCs,
    INT iNumNCs
    )
/*++

Routine Description:

    This takes a string nc and returns the index into PDC_DIAG_NCINFO
    if that nc string is located.  -1 otherwise.

Arguments:

    pszTargetNC - The NC to match
    pNCs - the info list of NC's to search within
    iNumNCs - the size of the NC info list

Return Value:

    index of the target if found, -1 otherwise

--*/
{
    ULONG                               ul;

    if((pszTargetNC == NULL) || (iNumNCs < 0)){
        return(-1);
    }

    for(ul = 0; (ul < (ULONG)iNumNCs); ul++){
        if(_wcsicmp(pszTargetNC, pNCs[ul].pszDn) == 0){
            return(ul);
        }
    }
    return(-1);
}

BOOL
DcDiagIsMemberOfStringList(
    LPWSTR pszTarget,
    LPWSTR * ppszSources,
    INT iNumSources
    )
/*++

Routine Description:

    This takes a string and returns true if the string is int

Arguments:

    pszTarget - The string to find.
    ppszSources - The array to search for the target string.
    iNumSources - The length of the search array ppszSources.

Return Value:

    TRUE if it found the string in the array, false otherwise.

--*/
{
    ULONG                               ul;

    if(ppszSources == NULL){
        return(FALSE);
    }

    for(ul = 0; (iNumSources == -1)?(ppszSources[ul] != NULL):(ul < (ULONG)iNumSources); ul++){
        if(_wcsicmp(pszTarget, ppszSources[ul]) == 0){
            return(TRUE);
        }
    }
    return(FALSE);
}

ULONG
DcDiagGetSiteFromDsaDn(
    PDC_DIAG_DSINFO                  pDsInfo,
    LPWSTR                           pszDn
    )
/*++

Routine Description:

    This takes the Dn of a server ntds settings object and turns it into a
    index into the pDsInfo->pSites structure of that server.

Arguments:

    pDsInfo - the enterprise info, including pSites.
    pszDn - DN of a NT DSA object, like "CN=NTDS Settings,CN=SERVER_NAME,...

Return Value:

    The index info the pDsInfo->pSites array of the server pszDn.

--*/
{
    LPWSTR                           pszNtdsSiteSettingsPrefix = L"CN=NTDS Site Settings,";
    PDSNAME                          pdsnameServer = NULL;
    PDSNAME                          pdsnameSite = NULL;
    ULONG                            ul, ulTemp, ulRet = NO_SITE;
    LPWSTR                           pszSiteSettingsDn = NULL;

    __try{

        pdsnameServer = DcDiagAllocDSName (pszDn);
        DcDiagChkNull (pdsnameSite = (PDSNAME) LocalAlloc(LMEM_FIXED,
                                         pdsnameServer->structLen));
        TrimDSNameBy (pdsnameServer, 3, pdsnameSite);
        ulTemp = wcslen(pszNtdsSiteSettingsPrefix) +
                 wcslen(pdsnameSite->StringName) + 2;
        DcDiagChkNull( pszSiteSettingsDn = LocalAlloc(LMEM_FIXED,
                                                      sizeof(WCHAR) * ulTemp));
        wcscpy(pszSiteSettingsDn, pszNtdsSiteSettingsPrefix);
        wcscat(pszSiteSettingsDn, pdsnameSite->StringName);

        // Find the site
        for(ul = 0; ul < pDsInfo->cNumSites; ul++){
            if(_wcsicmp(pDsInfo->pSites[ul].pszSiteSettings, pszSiteSettingsDn)
               == 0){
                ulRet = ul;
                __leave;
            }
        }

    } __finally {
        if(pdsnameServer != NULL) LocalFree(pdsnameServer);
        if(pdsnameSite != NULL) LocalFree(pdsnameSite);
        if(pszSiteSettingsDn != NULL) LocalFree(pszSiteSettingsDn);
    }

    return(ulRet);
}

VOID *
GrowArrayBy(
    VOID *            pArray,
    ULONG             cGrowBy,
    ULONG             cbElem
    )
/*++

Routine Description:

    This simply takes the array pArray, and grows it by cGrowBy times cbElem (the
    size of a single element of the array).

Arguments:

    pArray - The array to grow.
    cGrowBy - The number of elements to add to the array.
    cbElem - The sizeof in bytes of a single array element.

Return Value:

    Returns the pointer to the newly allocated array, and a pointer to NULL if
    there was not enough memory.

--*/
{
    ULONG             ulOldSize = 0;
    VOID *            pNewArray;

    if (pArray != NULL) {
        ulOldSize = (ULONG) LocalSize(pArray);
    } // else if pArray is NULL assume that the array
    // has never been allocated, so alloc fresh.

    Assert( (pArray != NULL) ? ulOldSize != 0 : TRUE);
    Assert((ulOldSize % cbElem) == 0);

    pNewArray = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                           ulOldSize + (cGrowBy * cbElem));
    if (pNewArray == NULL) {
        return(pNewArray);
    }

    memcpy(pNewArray, pArray, ulOldSize);
    LocalFree(pArray);

    return(pNewArray);
}

DWORD
DcDiagGenerateSitesList (
    PDC_DIAG_DSINFO                  pDsInfo,
    PDSNAME                          pdsnameEnterprise
    )
/*++

Routine Description:

    This generates and fills in the pDsInfo->pSites array for DcDiagGatherInfo()

Arguments:

    pDsInfo - enterprise info
    pdsnameEnterprise - a PDSNAME of the sites container.

Return Value:

    Win32 error value.

--*/
{
    LPWSTR                     ppszNtdsSiteSearch [] = {
        L"interSiteTopologyGenerator",
        L"options",
        NULL };
    LDAP *                     hld = NULL;
    LDAPMessage *              pldmEntry = NULL;
    LDAPMessage *              pldmNtdsSitesResults = NULL;
    LPWSTR                     pszDn = NULL;
    ULONG                      ulTemp;
    DWORD                      dwWin32Err = NO_ERROR;
    LPWSTR *                   ppszTemp = NULL;
    LDAPSearch *               pSearch = NULL;
    ULONG                      ulTotalEstimate = 0;
    ULONG                      ulCount = 0;
    DWORD                      dwLdapErr;

    __try {

        hld = pDsInfo->hld;

	pDsInfo->pSites = NULL;

	pSearch = ldap_search_init_page(hld,
					pdsnameEnterprise->StringName,
					LDAP_SCOPE_SUBTREE,
					L"(objectCategory=ntDSSiteSettings)",
					ppszNtdsSiteSearch,
					FALSE, NULL, NULL, 0, 0, NULL);
	if(pSearch == NULL){
	    dwLdapErr = LdapGetLastError();
	    DcDiagException(LdapMapErrorToWin32(dwLdapErr));
	}

	dwLdapErr = ldap_get_next_page_s(hld,
					 pSearch,
					 0,
					 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					 &ulTotalEstimate,
					 &pldmNtdsSitesResults);
	if(dwLdapErr == LDAP_NO_RESULTS_RETURNED){	
	    PrintMessage(SEV_ALWAYS, L"Could not find any Sites in the AD, dcdiag could not\n");
	    PrintMessage(SEV_ALWAYS, L"Continue\n");
	    DcDiagException(ERROR_DS_OBJ_NOT_FOUND);
	}
	while(dwLdapErr == LDAP_SUCCESS){
	    pDsInfo->pSites = GrowArrayBy(pDsInfo->pSites,
					  ldap_count_entries(hld, pldmNtdsSitesResults),
					  sizeof(DC_DIAG_SITEINFO));
	    DcDiagChkNull(pDsInfo->pSites);

	    // Walk through all the sites ...
	    pldmEntry = ldap_first_entry (hld, pldmNtdsSitesResults);
	    for (; pldmEntry != NULL; ulCount++) {
		// Get the site common/printable name
		if ((pszDn = ldap_get_dnW (hld, pldmEntry)) == NULL){
		    DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
		}
		DcDiagChkNull (pDsInfo->pSites[ulCount].pszSiteSettings =
			       LocalAlloc(LMEM_FIXED,
					  (wcslen (pszDn) + 1) * sizeof (WCHAR)));
		wcscpy (pDsInfo->pSites[ulCount].pszSiteSettings , pszDn);
		ppszTemp = ldap_explode_dnW(pszDn, TRUE);
		if(ppszTemp != NULL){
		    pDsInfo->pSites[ulCount].pszName = LocalAlloc(LMEM_FIXED,
			                  sizeof(WCHAR) * (wcslen(ppszTemp[1]) + 2));
		    if(pDsInfo->pSites[ulCount].pszName == NULL){
			DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
		    }
		    wcscpy(pDsInfo->pSites[ulCount].pszName, ppszTemp[1]);
		    ldap_value_freeW(ppszTemp);
		    ppszTemp = NULL;
		} else {
		    pDsInfo->pSites[ulCount].pszName = NULL;
		}

		// Get the Intersite Topology Generator attribute
		ppszTemp = ldap_get_valuesW(hld, pldmEntry,
					    L"interSiteTopologyGenerator");
		if(ppszTemp != NULL){
		    ulTemp = wcslen(ppszTemp[0]) + 2;
		    pDsInfo->pSites[ulCount].pszISTG = LocalAlloc(LMEM_FIXED,
						    sizeof(WCHAR) * ulTemp);
		    if(pDsInfo->pSites[ulCount].pszISTG == NULL){
			return(GetLastError());
		    }
		    wcscpy(pDsInfo->pSites[ulCount].pszISTG, ppszTemp[0]);
		    ldap_value_freeW(ppszTemp);
		    ppszTemp = NULL;
		} else {
		    pDsInfo->pSites[ulCount].pszISTG = NULL;
		}

		// Get Site Options
		ppszTemp = ldap_get_valuesW (hld, pldmEntry, L"options");
		if (ppszTemp != NULL) {
		    pDsInfo->pSites[ulCount].iSiteOptions = atoi ((LPSTR) ppszTemp[0]);
		    ldap_value_freeW(ppszTemp);
		    ppszTemp = NULL;
		} else {
		    pDsInfo->pSites[ulCount].iSiteOptions = 0;
		}

                pDsInfo->pSites[ulCount].cServers = 0;

		ldap_memfreeW (pszDn);
		pszDn = NULL;

		pldmEntry = ldap_next_entry (hld, pldmEntry);
	    } // end for each site

	    ldap_msgfree(pldmNtdsSitesResults);
            pldmNtdsSitesResults = NULL;

	    dwLdapErr = ldap_get_next_page_s(hld,
					     pSearch,
					     0,
					     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					     &ulTotalEstimate,
					     &pldmNtdsSitesResults);
	} // end of while loop for each page

	if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
	    DcDiagException(LdapMapErrorToWin32(dwLdapErr));
	}

	ldap_search_abandon_page(hld, pSearch);
        pSearch = NULL;

        pDsInfo->cNumSites = ulCount;

    } __except (DcDiagExceptionHandler(GetExceptionInformation(),
                                       &dwWin32Err)){
    }

    // Note we do not unbind the Ds or Ldap connections, because they have been saved for later use.
    if (pszDn != NULL) { ldap_memfreeW (pszDn); }
    if (ppszTemp != NULL) { ldap_value_freeW (ppszTemp); }
    if (pldmNtdsSitesResults != NULL) { ldap_msgfree (pldmNtdsSitesResults); }
    if (pSearch != NULL) { ldap_search_abandon_page(hld, pSearch); }
    // DONT FREE pdsnameEnterprise it is done in GatherInfo()

    return dwWin32Err;
}


DWORD
DcDiagGenerateServersList(
    PDC_DIAG_DSINFO                  pDsInfo,
    LDAP *                           hld,
    PDSNAME                          pdsnameEnterprise
    )
/*++

Routine Description:

    This function will generate the pServers list for the pDsInfo structure, it
    does this with a paged search for every objectCategory=ntdsa under the
    enterprise container.  Just a helper for DcDiagGatherInfo().

Arguments:

    pDsInfo - Contains the pServers array to create.
    hld - the ldap binding to read server objects from
    pdsnameEnterprise - the DN of the top level enterprise container in the
	config container.

Return Value:

    Returns ERROR_SUCCESS, but does throw an exception on any error, so it is
    essential to surround with a __try{}__except(){} as that in DsDiagGatherInfo().

--*/
{
    LPWSTR  ppszNtdsDsaSearch [] = {
                L"objectGUID",
                L"options",
                L"invocationId",
                L"msDS-HasMasterNCs", L"hasMasterNCs",
                L"hasPartialReplicaNCs",
                NULL };
    LDAPMessage *              pldmResult = NULL;
    LDAPMessage *              pldmEntry = NULL;
    struct berval **           ppbvObjectGUID = NULL;
    struct berval **           ppbvInvocationId = NULL;
    LPWSTR                     pszDn = NULL;
    LPWSTR *                   ppszOptions = NULL;
    LPWSTR                     pszServerObjDn = NULL;
    ULONG                      ul;
    LDAPSearch *               pSearch = NULL;
    ULONG                      ulTotalEstimate = 0;
    DWORD                      dwLdapErr;
    ULONG                      ulSize;
    ULONG                      ulCount = 0;

    __try{

	PrintMessage(SEV_VERBOSE, L"* Identifying all servers.\n");

	pSearch = ldap_search_init_page(hld,
					pdsnameEnterprise->StringName,
					LDAP_SCOPE_SUBTREE,
					L"(objectCategory=ntdsDsa)",
					ppszNtdsDsaSearch,
					FALSE,
					NULL,    // ServerControls
					NULL,    // ClientControls
					0,       // PageTimeLimit
					0,       // TotalSizeLimit
					NULL);   // sort key

	if(pSearch == NULL){
	    dwLdapErr = LdapGetLastError();
	    DcDiagException(LdapMapErrorToWin32(dwLdapErr));
  	}
	
	dwLdapErr = ldap_get_next_page_s(hld,
					 pSearch,
					 0,
					 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					 &ulTotalEstimate,
					 &pldmResult);
	if(dwLdapErr != LDAP_SUCCESS){
	    DcDiagException(LdapMapErrorToWin32(dwLdapErr));
	}

	while(dwLdapErr == LDAP_SUCCESS){

            pDsInfo->pServers = GrowArrayBy(pDsInfo->pServers,
                                            ldap_count_entries(hld, pldmResult),
                                            sizeof(DC_DIAG_SERVERINFO));
            DcDiagChkNull(pDsInfo->pServers);

            pldmEntry = ldap_first_entry (hld, pldmResult);
            for (; pldmEntry != NULL; ulCount++) {

                if ((pszDn = ldap_get_dnW (hld, pldmEntry)) == NULL) {
                    DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
                }

                if ((ppbvObjectGUID = ldap_get_values_lenW (hld, pldmEntry, L"objectGUID")) == NULL) {
                    DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
                }

                memcpy ((LPVOID) &(pDsInfo->pServers[ulCount].uuid),
                        (LPVOID) ppbvObjectGUID[0]->bv_val,
                        ppbvObjectGUID[0]->bv_len);
                ldap_value_free_len (ppbvObjectGUID);
                ppbvObjectGUID = NULL;
                if ((ppbvInvocationId = ldap_get_values_lenW (hld, pldmEntry, L"invocationId")) == NULL) {
                    DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
                }
                memcpy ((LPVOID) &pDsInfo->pServers[ulCount].uuidInvocationId,
                        (LPVOID) ppbvInvocationId[0]->bv_val,
                        ppbvInvocationId[0]->bv_len);
                ldap_value_free_len (ppbvInvocationId);
                ppbvInvocationId = NULL;

                // Set pszDn.
                ppszOptions = ldap_get_valuesW (hld, pldmEntry, L"options");
                DcDiagChkNull (pDsInfo->pServers[ulCount].pszDn = LocalAlloc
                               (LMEM_FIXED, (wcslen (pszDn) + 1) * sizeof(WCHAR)));
                wcscpy (pDsInfo->pServers[ulCount].pszDn, pszDn);
                // Set pszName.
                pDsInfo->pServers[ulCount].pszName = DcDiagAllocNameFromDn (pszDn);
                // Set pszDNSName.
                pszServerObjDn = DcDiagTrimStringDnBy(pDsInfo->pServers[ulCount].pszDn,
                                                      1);
                DcDiagChkNull(pszServerObjDn);
                // CODE.IMPROVEMENT: get both attributes at same time
                DcDiagGetStringDsAttributeEx(hld, pszServerObjDn, L"dNSHostName",
                                             &(pDsInfo->pServers[ulCount].pszDNSName));
                DcDiagGetStringDsAttributeEx(hld, pszServerObjDn, L"serverReference",
                                             &(pDsInfo->pServers[ulCount].pszComputerAccountDn));

                pDsInfo->pServers[ulCount].iSite = DcDiagGetSiteFromDsaDn(pDsInfo, pszDn);
                pDsInfo->pSites[pDsInfo->pServers[ulCount].iSite].cServers++;

                pDsInfo->pServers[ulCount].bDsResponding = TRUE;
                pDsInfo->pServers[ulCount].bLdapResponding = TRUE;
                pDsInfo->pServers[ulCount].bDnsIpResponding = TRUE;

                pDsInfo->pServers[ulCount].pszGuidDNSName = DcDiagAllocGuidDNSName (
                                                                                   pDsInfo->pszRootDomain, &pDsInfo->pServers[ulCount].uuid);
                pDsInfo->pServers[ulCount].ppszMasterNCs = ldap_get_valuesW(hld,
                                                                            pldmEntry,
                                                                            L"msDS-HasMasterNCs");
                if (NULL == pDsInfo->pServers[ulCount].ppszMasterNCs) {
                    // Fail over to the "old" hasMasterNCs
                    pDsInfo->pServers[ulCount].ppszMasterNCs = ldap_get_valuesW(hld,
                                                                                pldmEntry,
                                                                                L"hasMasterNCs");
                }
                pDsInfo->pServers[ulCount].ppszPartialNCs = ldap_get_valuesW(hld,
                                                                             pldmEntry,
                                                                             L"hasPartialReplicaNCs");

                if (ppszOptions == NULL) {
                    pDsInfo->pServers[ulCount].iOptions = 0;
                } else {
                    pDsInfo->pServers[ulCount].iOptions = atoi ((LPSTR) ppszOptions[0]);
                    ldap_value_freeW (ppszOptions);
                    ppszOptions = NULL;
                }
                ldap_memfreeW (pszDn);
                pszDn = NULL;
                pldmEntry = ldap_next_entry (hld, pldmEntry);
            } // end for each server for this page.

            ldap_msgfree(pldmResult);
            pldmResult = NULL;

            dwLdapErr = ldap_get_next_page_s(hld,
                                             pSearch,
                                             0,
                                             DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                             &ulTotalEstimate,
                                             &pldmResult);
	} // end while there are more pages ...
	if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
	    DcDiagException(LdapMapErrorToWin32(dwLdapErr));
	}

	pDsInfo->ulNumServers = ulCount;

    } finally {
	if (pSearch != NULL) { ldap_search_abandon_page(hld, pSearch); }
        if (ppbvObjectGUID != NULL) { ldap_value_free_len (ppbvObjectGUID); }
        if (pldmResult != NULL) { ldap_msgfree (pldmResult); }
        if (pszServerObjDn != NULL) { LocalFree(pszServerObjDn); }
        if (pszDn != NULL) { ldap_memfreeW (pszDn); }
    }

    return(ERROR_SUCCESS);
} // End DcDiagGenerateServersList()
                    
BOOL
DcDiagIsNdnc(
    PDC_DIAG_DSINFO                  pDsInfo,
    ULONG                            iNc
    )
/*++

Routine Description:

    This function tells you whether the NC (iNc) is an NDNC (or as
    we call them to customers Application Directory Partitions.

Arguments:

    pDsInfo - Contains the pNCs array to use.
    iNc - index into the pNCs array of the NC of interest.

Return Value:

    Returns a TRUE if we could verify that this NC is an NDNC, and
    return FALSE if we could not verify this or if the NC definately
    wasn't an NDNC.  Note this function returns FALSE if the NC
    is a currently disabled NDNC.

--*/
{
    ULONG         iCrVer;
    DWORD         dwRet, dwError = 0;

    Assert(gDsInfo_NcList_Initialized);

    dwRet = DcDiagGetCrossRefInfo(pDsInfo,
                                  iNc,
                                  CRINFO_SOURCE_ANY | CRINFO_DATA_BASIC,
                                  &iCrVer,
                                  &dwError);
    if(dwRet){
        // This should error very rarely, not quite an assertable 
        // condition however.
        return(FALSE);
    }
    Assert(iCrVer != -1 && iCrVer != pDsInfo->pNCs[iNc].cCrInfo);

    if (pDsInfo->pNCs[iNc].aCrInfo[iCrVer].bEnabled
        && (pDsInfo->pNCs[iNc].aCrInfo[iCrVer].ulSystemFlags & FLAG_CR_NTDS_NC)
        && !(pDsInfo->pNCs[iNc].aCrInfo[iCrVer].ulSystemFlags & FLAG_CR_NTDS_DOMAIN)
        && (iNc != pDsInfo->iConfigNc)
        && (iNc != pDsInfo->iSchemaNc)
        ) {
        return(TRUE);
    }
    return(FALSE);
}


void
DcDiagAddTargetsNcsToNcTargets(
    PDC_DIAG_DSINFO                  pDsInfo,
    ULONG                            iServer
    )
/*++
Routine Description:

    This adds the NCs in this servers ppszMasterNCs and any NCs for which
    this server is supposed to become the first replica of to the list of
    target NCs to test in pDsInfo->pulNcTargets.

Arguments:

    pDsInfo - The array of target NCs (pDsInfo->pulNcTargets).

    iServer - The index of the server to add the NCs of.

--*/
{
    ULONG    iLocalNc, iTargetNc;
    LONG     iNc;

    if(pDsInfo->pszNC){
        // In this case, we've already set up the pulNcTargets array.
        return;
    }

    //
    // First add all locally instantiated writeable NCs.
    //
    for(iLocalNc = 0; pDsInfo->pServers[iServer].ppszMasterNCs[iLocalNc] != NULL; iLocalNc++){
        iNc = DcDiagGetMemberOfNCList(pDsInfo->pServers[iServer].ppszMasterNCs[iLocalNc],
                                      pDsInfo->pNCs, 
                                      pDsInfo->cNumNCs);
        if(iNc == -1){
            Assert(!"Hey what's up this definately should've been added already.");
            DcDiagException(ERROR_INVALID_PARAMETER);
        }
        
        for(iTargetNc = 0; iTargetNc < pDsInfo->cNumNcTargets; iTargetNc++){
            if(pDsInfo->pulNcTargets[iTargetNc] == iNc){
                // We've already got this one
                break;
            }
        }
        if(iTargetNc != pDsInfo->cNumNcTargets){
            // We found this NC (iNc) already in the pulNcTargets, so skip.
            continue;
        }

        // Add iNc to the target NCs array.
        pDsInfo->pulNcTargets = GrowArrayBy(pDsInfo->pulNcTargets,
                                            1,
                                            sizeof(ULONG));
        DcDiagChkNull(pDsInfo->pulNcTargets);
        pDsInfo->pulNcTargets[pDsInfo->cNumNcTargets] = iNc;
        pDsInfo->cNumNcTargets++;
    }

    //
    // Second walk all the NCs and see if this server is the first replica
    // for one of them.
    //
    // Code.Improvement It'd be slightly better to seperate this into a 
    // seperate  function that walks each CR and then searches for a server 
    // with a matching dNSRoot for server name, and then add it.
    for(iNc = 0; (ULONG) iNc < pDsInfo->cNumNCs; iNc++){
        // If the NC is not enabled, and the first server matches this one,
        // add it to the target NCs array.
        if(! pDsInfo->pNCs[iNc].aCrInfo[0].bEnabled
           // BUGBUG is there a more official way to compare DNS names?
           && pDsInfo->pNCs[iNc].aCrInfo[0].pszDnsRoot
           && (_wcsicmp(pDsInfo->pNCs[iNc].aCrInfo[0].pszDnsRoot,
                       pDsInfo->pServers[iServer].pszDNSName) == 0) ){
            // Add this one, it's supposed to be the first replica.

            pDsInfo->pulNcTargets = GrowArrayBy(pDsInfo->pulNcTargets,
                                                1,
                                                sizeof(ULONG));
            DcDiagChkNull(pDsInfo->pulNcTargets);
            pDsInfo->pulNcTargets[pDsInfo->cNumNcTargets] = iNc;
            pDsInfo->cNumNcTargets++;
        }
    }

}


DWORD
DcDiagGatherInfo (
    LPWSTR                           pszServerSpecifiedOnCommandLine,
    LPWSTR                           pszNCSpecifiedOnCommandLine,
    ULONG                            ulFlags,
    SEC_WINNT_AUTH_IDENTITY_W *      gpCreds,
    PDC_DIAG_DSINFO                  pDsInfo
    )
/*++

Routine Description:

    This is the function that basically sets up pDsInfo and gathers all the
    basic info and stores it in the DS_INFO structure and this is then passed
    around the entire program.  AKA this set up some "global" variables.

    Note that this routine constructs the forest and per-server information
    based on talking to the home server. Information that is specific to a server,
    for example certain root dse attributes, are obtained later when a binding
    is made to that server. An exception to this is the home server, for which
    we have a binding at this point, and can obtain its server-specific info
    right away.

Arguments:
    pszServerSpecifiedOnCommandLine - (IN) if there was a server on the command
        line, then this points to that string.  Note that currently 28 Jun 1999
        this is a required argument to dcdiag.
    pszNCSpecifiedOnCommandLine - (IN) Optional command line parameter to
        analyze only one NC for all tests.
    ulFlags - (IN) Command line switches & other optional parameters to dcdiag.
    gpCreds - (IN) Command line credentials if any, otherwise NULL.
    pDsInfo - (OUT) The global record for basically the rest of the program

Return Value:

    Returns a standare Win32 error.

--*/
{
    LPWSTR  ppszNtdsSiteSettingsSearch [] = {
                L"options",
                NULL };
    LPWSTR  ppszRootDseForestAttrs [] = {
                L"rootDomainNamingContext",
                L"dsServiceName",
                L"configurationNamingContext",
                NULL };

    LDAP *                     hld = NULL;
    LDAPMessage *              pldmEntry = NULL;

    LDAPMessage *              pldmRootResults = NULL;
    LPWSTR *                   ppszRootDNC = NULL;
    LPWSTR *                   ppszConfigNc = NULL;
    PDS_NAME_RESULTW           pResult = NULL;
    PDSNAME                    pdsnameService = NULL;
    PDSNAME                    pdsnameEnterprise = NULL;
    PDSNAME                    pdsnameSite = NULL;

    LDAPMessage *              pldmNtdsSiteSettingsResults = NULL;
    LDAPMessage *              pldmNtdsSiteDsaResults = NULL;
    LDAPMessage *              pldmNtdsDsaResults = NULL;

    LPWSTR *                   ppszSiteOptions = NULL;

    DWORD                      dwWin32Err, dwWin32Err2;
    ULONG                      iServer, iNC, iHomeSite;
    LPWSTR                     pszHomeServer = L"localhost"; // Default is localhost

    LPWSTR                     pszNtdsSiteSettingsPrefix = L"CN=NTDS Site Settings,";
    LPWSTR                     pszSiteSettingsDn = NULL;

    INT                        iTemp;
    HANDLE                     hDS = NULL;
    LPWSTR *                   ppszServiceName = NULL;
    LPWSTR                     pszDn = NULL;
    LPWSTR *                   ppszOptions = NULL;

    DC_DIAG_SERVERINFO         HomeServer = { 0 };
    BOOL                       fHomeNameMustBeFreed = FALSE;
    ULONG                      ulOptions;

    LPWSTR                     pszDirectoryService = L"CN=Directory Service,CN=Windows NT,CN=Services,";
    LPWSTR                     rgpszDsAttrsToRead[] = {L"tombstoneLifetime", NULL};
    LPWSTR                     rgpszPartAttrsToRead[] = {L"msDS-Behavior-Version", NULL};
    LPWSTR                     pszDsDn = NULL;
    LDAPMessage *              pldmDsResults = NULL;
    LDAPMessage *              pldmPartResults = NULL;
    LPWSTR *                   ppszTombStoneLifeTimeDays;
    LPWSTR *                   ppszForestBehaviorVersion;


    pDsInfo->pServers = NULL;
    pDsInfo->pszRootDomain = NULL;
    pDsInfo->pszNC = NULL;
    pDsInfo->ulHomeServer = 0;
    pDsInfo->iDomainNamingFsmo = -1;
    pDsInfo->pulNcTargets = NULL;
    pDsInfo->cNumNcTargets = 0;
    pDsInfo->hCachedDomainNamingFsmoLdap = NULL;
    dwWin32Err = NO_ERROR;

    // Some initial specifics
    pDsInfo->pszNC = pszNCSpecifiedOnCommandLine;
    pDsInfo->ulFlags = ulFlags;

    // Exceptions should be raised when errors are detected so cleanup occurs.
    __try{

        HomeServer.pszDn = NULL;
        HomeServer.pszName = NULL;
        HomeServer.pszGuidDNSName = NULL;
        HomeServer.ppszMasterNCs = NULL;
        HomeServer.ppszPartialNCs = NULL;
        HomeServer.hLdapBinding = NULL;
        HomeServer.hDsBinding = NULL;

        if (pszServerSpecifiedOnCommandLine == NULL) {
            if (pszNCSpecifiedOnCommandLine != NULL) {
                // Derive the home server from the domain if specified
                HomeServer.pszName = findServerForDomain(
                                                        pszNCSpecifiedOnCommandLine );
                if (HomeServer.pszName == NULL) {
                    // We have had an error trying to get a home server.
                    DcDiagException (ERROR_DS_UNAVAILABLE);
                } else {
                    fHomeNameMustBeFreed = TRUE;
                }
            } else {
                // Try using the local machine if no domain or server is specified.
                HomeServer.pszName = findDefaultServer(TRUE);
                if (HomeServer.pszName == NULL) {
                    // We have had an error trying to get a home server.
                    DcDiagException (ERROR_DS_UNAVAILABLE);
                } else {
                    fHomeNameMustBeFreed =TRUE;
                }
            }
        } else {
            // The server is specified on the command line.
            HomeServer.pszName = pszServerSpecifiedOnCommandLine;
        }
        Assert(HomeServer.pszName != NULL &&
               "Inconsistent code, programmer err, this shouldn't be going off");
        Assert(HomeServer.pszGuidDNSName == NULL &&
               "This variable needs to be NULL to boot strap the the pDsInfo struct"
               " and be able to call ReplServerConnectFailureAnalysis() to work"
               " correctly");

        PrintMessage(SEV_VERBOSE,
                     L"* Connecting to directory service on server %s.\n",
                     HomeServer.pszName);

        dwWin32Err = DcDiagGetLdapBinding(&HomeServer,
                                          gpCreds,
                                          FALSE,
                                          &hld);
        if (dwWin32Err != ERROR_SUCCESS) {
            // If there is an error, ReplServerConnectFailureAnalysis() will print it.
            dwWin32Err2 = ReplServerConnectFailureAnalysis(&HomeServer, gpCreds);
            if (dwWin32Err2 == ERROR_SUCCESS) {
                PrintMessage(SEV_ALWAYS, L"[%s] Unrecoverable LDAP Error %ld:\n",
                             HomeServer.pszName,
                             dwWin32Err);
                PrintMessage(SEV_ALWAYS, L"%s", Win32ErrToString (dwWin32Err));
            }
            DcDiagException (ERROR_DS_DRA_CONNECTION_FAILED);
        }

        pDsInfo->hld = hld;

        // Do an DsBind()
        dwWin32Err = DsBindWithSpnExW(HomeServer.pszName,
                                      NULL,
                                      (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                                      NULL,
                                      0,
                                      &hDS);

        if (dwWin32Err != ERROR_SUCCESS) {
            // If there is an error, ReplServerConnectFailureAnalysis() will print it.
            dwWin32Err2 = ReplServerConnectFailureAnalysis(&HomeServer, gpCreds);
            if (dwWin32Err2 == ERROR_SUCCESS) {
                PrintMessage(SEV_ALWAYS, L"[%s] Directory Binding Error %ld:\n",
                             HomeServer.pszName,
                             dwWin32Err);
                PrintMessage(SEV_ALWAYS, L"%s\n", Win32ErrToString (dwWin32Err));
                PrintMessage(SEV_ALWAYS, L"This may limit some of the tests that can be performed.\n");
            }
        }

        // Do some ldapping.
        DcDiagChkLdap (ldap_search_sW ( hld,
                                        NULL,
                                        LDAP_SCOPE_BASE,
                                        L"(objectCategory=*)",
                                        ppszRootDseForestAttrs,
                                        0,
                                        &pldmRootResults));

        pldmEntry = ldap_first_entry (hld, pldmRootResults);
        ppszRootDNC = ldap_get_valuesW (hld, pldmEntry, L"rootDomainNamingContext");

        DcDiagChkNull (pDsInfo->pszRootDomainFQDN = (LPWSTR) LocalAlloc(LMEM_FIXED,
                                                                        (wcslen(ppszRootDNC[0]) + 1) * sizeof(WCHAR)) );
        wcscpy(pDsInfo->pszRootDomainFQDN, ppszRootDNC[0]);

        ppszConfigNc = ldap_get_valuesW (hld, pldmEntry, L"configurationNamingContext");
        DcDiagChkNull (pDsInfo->pszConfigNc = (LPWSTR) LocalAlloc(LMEM_FIXED,
                                                                  (wcslen(ppszConfigNc[0]) + 1) * sizeof(WCHAR)) );
        wcscpy(pDsInfo->pszConfigNc, ppszConfigNc[0]);

        DcDiagChkErr (DsCrackNamesW ( NULL,
                                      DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                      DS_FQDN_1779_NAME,
                                      DS_CANONICAL_NAME_EX,
                                      1,
                                      ppszRootDNC,
                                      &pResult));
        DcDiagChkNull (pDsInfo->pszRootDomain = (LPWSTR) LocalAlloc (LMEM_FIXED,
                                                                     (wcslen (pResult->rItems[0].pDomain) + 1) * sizeof (WCHAR)));
        wcscpy (pDsInfo->pszRootDomain, pResult->rItems[0].pDomain);

        //get the tombstone lifetime.
        // Construct dn to directory service object 
        DcDiagChkNull( pszDsDn = LocalAlloc(LMEM_FIXED, (wcslen( *ppszConfigNc ) + wcslen( pszDirectoryService ) + 1)*sizeof(WCHAR)) );
        wcscpy( pszDsDn, pszDirectoryService );
        wcscat( pszDsDn, *ppszConfigNc );

        // Read tombstone lifetime, if present
        dwWin32Err = ldap_search_sW(hld, pszDsDn, LDAP_SCOPE_BASE, L"(objectClass=*)",
                                    rgpszDsAttrsToRead, 0, &pldmDsResults);
        if (dwWin32Err == LDAP_NO_SUCH_ATTRIBUTE) {
            // Not present - use default
            pDsInfo->dwTombstoneLifeTimeDays = DEFAULT_TOMBSTONE_LIFETIME; 
        } else if (dwWin32Err != LDAP_SUCCESS) {
            DcDiagException (LdapMapErrorToWin32(dwWin32Err));
        } else if (pldmDsResults == NULL) {
            DcDiagException (ERROR_DS_PROTOCOL_ERROR);
        } else {
            ppszTombStoneLifeTimeDays = ldap_get_valuesW(hld, pldmDsResults, L"tombstoneLifetime"); 
            if (ppszTombStoneLifeTimeDays == NULL) {
                // Not present - use default
                pDsInfo->dwTombstoneLifeTimeDays = DEFAULT_TOMBSTONE_LIFETIME;
            } else {
                pDsInfo->dwTombstoneLifeTimeDays = wcstoul( *ppszTombStoneLifeTimeDays, NULL, 10 );
            }
        }

        ppszServiceName = ldap_get_valuesW (hld, pldmEntry, L"dsServiceName");
        pdsnameService = DcDiagAllocDSName (ppszServiceName[0]);
        DcDiagChkNull (pdsnameEnterprise = (PDSNAME) LocalAlloc (LMEM_FIXED, pdsnameService->structLen));
        DcDiagChkNull (pdsnameSite = (PDSNAME) LocalAlloc (LMEM_FIXED, pdsnameService->structLen));
        TrimDSNameBy (pdsnameService, 4, pdsnameEnterprise);
        TrimDSNameBy (pdsnameService, 3, pdsnameSite);

        iTemp = wcslen(pszNtdsSiteSettingsPrefix) + wcslen(pdsnameSite->StringName) + 2;
        DcDiagChkNull( pszSiteSettingsDn = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR)) );
        wcscpy(pszSiteSettingsDn, pszNtdsSiteSettingsPrefix);
        wcscat(pszSiteSettingsDn, pdsnameSite->StringName);

        PrintMessage(SEV_VERBOSE, L"* Collecting site info.\n");
        DcDiagChkLdap (ldap_search_sW ( hld,
                                        pszSiteSettingsDn,
                                        LDAP_SCOPE_BASE,
                                        L"(objectClass=*)",
                                        ppszNtdsSiteSettingsSearch,
                                        0,
                                        &pldmNtdsSiteSettingsResults));

        pldmEntry = ldap_first_entry (hld, pldmNtdsSiteSettingsResults);
        ppszSiteOptions = ldap_get_valuesW (hld, pldmEntry, L"options");
        if (ppszSiteOptions == NULL) {
            pDsInfo->iSiteOptions = 0;
        } else {
            pDsInfo->iSiteOptions = atoi ((LPSTR) ppszSiteOptions[0]);
        }

        // Get/Enumerate Site Information ---------------------------------------
        if (DcDiagGenerateSitesList(pDsInfo, pdsnameEnterprise) != ERROR_SUCCESS) {
            DcDiagChkNull(NULL);
        }

        // Get/Enumerate Server Information -------------------------------------
        if (DcDiagGenerateServersList(pDsInfo, hld, pdsnameEnterprise) != ERROR_SUCCESS) {
            DcDiagChkNull(NULL);
        }

        // Set the home server's info
        pDsInfo->ulHomeServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, ppszServiceName[0], NULL, NULL);
        if (pDsInfo->ulHomeServer == NO_SERVER) {
            PrintMessage(SEV_ALWAYS, L"There is a horrible inconsistency in the directory, the server\n");
            PrintMessage(SEV_ALWAYS, L"%s\n", ppszServiceName[0]);
            PrintMessage(SEV_ALWAYS, L"could not be found in it's own directory.\n");
            DcDiagChkNull(NULL);
        }
        pDsInfo->pServers[pDsInfo->ulHomeServer].hDsBinding = hDS;
        pDsInfo->pServers[pDsInfo->ulHomeServer].hLdapBinding = hld;
        pDsInfo->pServers[pDsInfo->ulHomeServer].hGcLdapBinding = NULL;

        pDsInfo->pServers[pDsInfo->ulHomeServer].bDnsIpResponding = TRUE;
        pDsInfo->pServers[pDsInfo->ulHomeServer].bDsResponding = TRUE;
        pDsInfo->pServers[pDsInfo->ulHomeServer].bLdapResponding = TRUE;

        pDsInfo->pServers[pDsInfo->ulHomeServer].dwLdapError = ERROR_SUCCESS;
        pDsInfo->pServers[pDsInfo->ulHomeServer].dwGcLdapError = ERROR_SUCCESS;
        pDsInfo->pServers[pDsInfo->ulHomeServer].dwDsError = ERROR_SUCCESS;

        dwWin32Err = DcDiagCacheServerRootDseAttrs( hld,
                                                    &(pDsInfo->pServers[pDsInfo->ulHomeServer]) );
        if (dwWin32Err) {
            // Error already logged
            DcDiagException (dwWin32Err);
        }

        // Get/Enumerate NC's Information ---------------------------------------
        // note must be called after DcDiagGetServersList
        if (DcDiagGenerateNCsList(pDsInfo, hld) != ERROR_SUCCESS) {
            DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
        }

        // Validate pszNc
        if (pDsInfo->pszNC) {
            BOOL fFound = FALSE;
            for ( iNC = 0; iNC < pDsInfo->cNumNCs; iNC++ ) {
                if (_wcsicmp( pDsInfo->pszNC, pDsInfo->pNCs[iNC].pszDn ) == 0) {
                    fFound = TRUE;
                    break;
                }
            }
            if (!fFound) {
                PrintMessage( SEV_ALWAYS, L"Naming context %ws cannot be found.\n",
                              pDsInfo->pszNC );
                DcDiagException ( ERROR_INVALID_PARAMETER );
            }
            DcDiagChkNull( pDsInfo->pulNcTargets = LocalAlloc(LMEM_FIXED, sizeof(ULONG)) );
            pDsInfo->cNumNcTargets = 1;
            pDsInfo->pulNcTargets[0] = iNC;
        } 

        // Set ulHomeSite
        pDsInfo->iHomeSite = DcDiagGetSiteFromDsaDn(pDsInfo, pDsInfo->pServers[pDsInfo->ulHomeServer].pszDn);

        // Do one of the 3 targeting options single server {default}, site wide, or enterprise
        if (pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_ENTERPRISE) {
            // Test Whole Enterprise
            DcDiagChkNull( pDsInfo->pulTargets = LocalAlloc(LMEM_FIXED, (pDsInfo->ulNumServers * sizeof(ULONG))) );
            pDsInfo->ulNumTargets = 0;
            for (iServer=0; iServer < pDsInfo->ulNumServers; iServer++) {
                if (pDsInfo->pszNC == NULL || DcDiagHasNC(pDsInfo->pszNC,
                                                          &(pDsInfo->pServers[iServer]),
                                                          TRUE, TRUE)) {
                    pDsInfo->pulTargets[pDsInfo->ulNumTargets] = iServer;
                    pDsInfo->ulNumTargets++;
                    // Add writeable NCs and disabled NDNCs to Target NCs
                    DcDiagAddTargetsNcsToNcTargets(pDsInfo, iServer);
                }
            }
        } else if (pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_SITE) {
            // Test just this site
            pDsInfo->ulNumTargets = 0;

            pDsInfo->pulTargets = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                             pDsInfo->ulNumServers * sizeof(ULONG));
            DcDiagChkNull(pDsInfo->pulTargets);
            for (iServer = 0; iServer < pDsInfo->ulNumServers; iServer++) {
                if (pDsInfo->pServers[iServer].iSite == pDsInfo->iHomeSite) {
                    if (pDsInfo->pszNC == NULL || DcDiagHasNC(pDsInfo->pszNC,
                                                              &(pDsInfo->pServers[iServer]),
                                                              TRUE, TRUE)) {
                        pDsInfo->pulTargets[pDsInfo->ulNumTargets] = iServer;
                        pDsInfo->ulNumTargets++;
                        // Add writeable NCs and disabled NDNCs to Target NCs
                        DcDiagAddTargetsNcsToNcTargets(pDsInfo, iServer);
                    }
                }
            }
        } else {
            // Test just this server
            DcDiagChkNull( pDsInfo->pulTargets = LocalAlloc(LMEM_FIXED, sizeof(ULONG)) );
            pDsInfo->ulNumTargets = 1;
            pDsInfo->pulTargets[0] = pDsInfo->ulHomeServer;
            // Add writeable NCs and disabled NDNCs to Target NCs
            DcDiagAddTargetsNcsToNcTargets(pDsInfo, pDsInfo->ulHomeServer);
        }

        iTemp = sizeof(WCHAR) * (wcslen(WSTR_SMTP_TRANSPORT_CONFIG_DN) + wcslen(pDsInfo->pNCs[pDsInfo->iConfigNc].pszDn) + 1);
        pDsInfo->pszSmtpTransportDN = LocalAlloc(LMEM_FIXED, iTemp);
        DcDiagChkNull( pDsInfo->pszSmtpTransportDN );
        wcscpy(pDsInfo->pszSmtpTransportDN, WSTR_SMTP_TRANSPORT_CONFIG_DN);
        wcscat(pDsInfo->pszSmtpTransportDN, pDsInfo->pNCs[pDsInfo->iConfigNc].pszDn);

        pDsInfo->pszPartitionsDn = LocalAlloc(LMEM_FIXED, 
                (wcslen(DCDIAG_PARTITIONS_RDN) + wcslen(pDsInfo->pNCs[pDsInfo->iConfigNc].pszDn) + 1) * sizeof(WCHAR));
        DcDiagChkNull(pDsInfo->pszPartitionsDn);
        wcscpy(pDsInfo->pszPartitionsDn, DCDIAG_PARTITIONS_RDN);
        wcscat(pDsInfo->pszPartitionsDn, pDsInfo->pNCs[pDsInfo->iConfigNc].pszDn);

        // Read forest version, if present
        dwWin32Err = ldap_search_sW(hld, pDsInfo->pszPartitionsDn, LDAP_SCOPE_BASE, L"(objectClass=*)",
                                    rgpszPartAttrsToRead, 0, &pldmPartResults);
        if (dwWin32Err == LDAP_NO_SUCH_ATTRIBUTE) {
            // Not present - use default
            pDsInfo->dwForestBehaviorVersion = 0;
        } else if (dwWin32Err != LDAP_SUCCESS) {
            DcDiagException (LdapMapErrorToWin32(dwWin32Err));
        } else if (pldmDsResults == NULL) {
            DcDiagException (ERROR_DS_PROTOCOL_ERROR);
        } else {
            ppszForestBehaviorVersion = ldap_get_valuesW(hld, pldmPartResults, L"msDS-Behavior-Version"); 
            if (ppszForestBehaviorVersion == NULL) {
                // Not present - use default
                pDsInfo->dwForestBehaviorVersion = 0;
            } else {
                pDsInfo->dwForestBehaviorVersion = wcstoul( *ppszForestBehaviorVersion, NULL, 10 );
            }
        }

        PrintMessage(SEV_VERBOSE, L"* Found %ld DC(s). Testing %ld of them.\n",
                     pDsInfo->ulNumServers,
                     pDsInfo->ulNumTargets);

        PrintMessage(SEV_NORMAL, L"Done gathering initial info.\n");

    }  __except (DcDiagExceptionHandler(GetExceptionInformation(),
                                        &dwWin32Err)){
        if (pDsInfo->pServers != NULL) {
            for (iServer = 0; iServer < pDsInfo->ulNumServers; iServer++) {
                if (pDsInfo->pServers[iServer].pszDn != NULL)
                    LocalFree (pDsInfo->pServers[iServer].pszDn);
                if (pDsInfo->pServers[iServer].pszName != NULL)
                    LocalFree (pDsInfo->pServers[iServer].pszName);
                if (pDsInfo->pServers[iServer].pszGuidDNSName != NULL)
                    LocalFree (pDsInfo->pServers[iServer].pszGuidDNSName);
            }
            LocalFree (pDsInfo->pServers);
            pDsInfo->pServers = NULL;
        }
        if (pDsInfo->pszRootDomain != NULL) LocalFree (pDsInfo->pszRootDomain);
    }

    // Note we do not unbind the Ds or Ldap connections, because they have been saved for later use.
    if (ppszOptions != NULL) ldap_value_freeW (ppszOptions);
    if (pszDn != NULL) ldap_memfreeW (pszDn);
    if (pldmNtdsDsaResults != NULL) ldap_msgfree (pldmNtdsDsaResults);
    if (pldmNtdsSiteDsaResults != NULL) ldap_msgfree (pldmNtdsSiteDsaResults);
    if (ppszSiteOptions != NULL) ldap_value_freeW (ppszSiteOptions);
    if (pldmNtdsSiteSettingsResults != NULL) ldap_msgfree (pldmNtdsSiteSettingsResults);
    if (pdsnameEnterprise != NULL) LocalFree (pdsnameEnterprise);
    if (pdsnameSite != NULL) LocalFree (pdsnameSite);
    if (pdsnameService != NULL) LocalFree (pdsnameService);
    if (ppszServiceName != NULL) ldap_value_freeW (ppszServiceName);
    if (pszSiteSettingsDn != NULL) LocalFree (pszSiteSettingsDn);
    if (pResult != NULL) DsFreeNameResultW(pResult);
    if (ppszRootDNC != NULL) ldap_value_freeW (ppszRootDNC);
    if (ppszConfigNc != NULL) ldap_value_freeW (ppszConfigNc);
    if (pldmRootResults != NULL) ldap_msgfree (pldmRootResults);
    if (fHomeNameMustBeFreed && HomeServer.pszName) { LocalFree(HomeServer.pszName); }

    if (pldmDsResults != NULL) ldap_msgfree(pldmDsResults);
    if (pldmPartResults != NULL) ldap_msgfree(pldmPartResults);
    if (pszDsDn != NULL) LocalFree(pszDsDn);

    return dwWin32Err;
}

VOID
DcDiagFreeDsInfo (
    PDC_DIAG_DSINFO        pDsInfo
    )
/*++

Routine Description:

    Free the pDsInfo variable.

Arguments:

    pDsInfo - (IN) This is the pointer to free ... it is assumed to be
    DC_DIAG_DSINFO type

Return Value:

--*/
{
    ULONG            ul, ulInner;

    // Free NCs
    if(pDsInfo->pNCs != NULL){
        for(ul = 0; ul < pDsInfo->cNumNCs; ul++){
            LocalFree(pDsInfo->pNCs[ul].pszDn);
            LocalFree(pDsInfo->pNCs[ul].pszName);
            for(ulInner = 0; ulInner < (ULONG) pDsInfo->pNCs[ul].cCrInfo; ulInner++){
                if(pDsInfo->pNCs[ul].aCrInfo[ulInner].pszSourceServer){
                    LocalFree(pDsInfo->pNCs[ul].aCrInfo[ulInner].pszSourceServer);
                }
                if(pDsInfo->pNCs[ul].aCrInfo[ulInner].pszDn){
                    LocalFree(pDsInfo->pNCs[ul].aCrInfo[ulInner].pszDn);
                }
                if(pDsInfo->pNCs[ul].aCrInfo[ulInner].pszDnsRoot){
                    LocalFree(pDsInfo->pNCs[ul].aCrInfo[ulInner].pszDnsRoot);
                }
                if(pDsInfo->pNCs[ul].aCrInfo[ulInner].pszSDReferenceDomain) {
                    LocalFree(pDsInfo->pNCs[ul].aCrInfo[ulInner].pszSDReferenceDomain);
                }
                if(pDsInfo->pNCs[ul].aCrInfo[ulInner].pszNetBiosName) {
                    LocalFree(pDsInfo->pNCs[ul].aCrInfo[ulInner].pszNetBiosName);
                }
                if(pDsInfo->pNCs[ul].aCrInfo[ulInner].pdnNcName) {
                    LocalFree(pDsInfo->pNCs[ul].aCrInfo[ulInner].pdnNcName);
                }
                if(pDsInfo->pNCs[ul].aCrInfo[ulInner].aszReplicas) {
                    ldap_value_freeW (pDsInfo->pNCs[ul].aCrInfo[ulInner].aszReplicas);
                }
            }
            LocalFree(pDsInfo->pNCs[ul].aCrInfo);
        }
        LocalFree(pDsInfo->pNCs);
    }

    // Free servers
    for (ul = 0; ul < pDsInfo->ulNumServers; ul++) {
        LocalFree (pDsInfo->pServers[ul].pszDn);
        LocalFree (pDsInfo->pServers[ul].pszName);
        LocalFree (pDsInfo->pServers[ul].pszGuidDNSName);
        LocalFree (pDsInfo->pServers[ul].pszDNSName);
        LocalFree (pDsInfo->pServers[ul].pszComputerAccountDn);
        if(pDsInfo->pServers[ul].ppszMasterNCs != NULL) {
            ldap_value_freeW (pDsInfo->pServers[ul].ppszMasterNCs);
        }
        if(pDsInfo->pServers[ul].ppszPartialNCs != NULL) {
            ldap_value_freeW (pDsInfo->pServers[ul].ppszPartialNCs);
        }
        if (pDsInfo->pServers[ul].pszCollectedDsServiceName) {
            LocalFree(pDsInfo->pServers[ul].pszCollectedDsServiceName);
            pDsInfo->pServers[ul].pszCollectedDsServiceName = NULL;
        }
        if(pDsInfo->pServers[ul].hLdapBinding != NULL){
            ldap_unbind(pDsInfo->pServers[ul].hLdapBinding);
            pDsInfo->pServers[ul].hLdapBinding = NULL;
        }
        if(pDsInfo->pServers[ul].hDsBinding != NULL) {
            DsUnBind( &(pDsInfo->pServers[ul].hDsBinding));
            pDsInfo->pServers[ul].hDsBinding = NULL;
        }
        if(pDsInfo->pServers[ul].sNetUseBinding.pszNetUseServer != NULL){
            DcDiagTearDownNetConnection(&(pDsInfo->pServers[ul]));
        }
    }


    // Free Sites
    if(pDsInfo->pSites != NULL){
        for(ul = 0; ul < pDsInfo->cNumSites; ul++){
            if(pDsInfo->pSites[ul].pszISTG){
                LocalFree(pDsInfo->pSites[ul].pszISTG);
            }
            if(pDsInfo->pSites[ul].pszName){
                LocalFree(pDsInfo->pSites[ul].pszName);
            }
        }
        LocalFree(pDsInfo->pSites);
    }

    LocalFree (pDsInfo->pszRootDomain);
    LocalFree (pDsInfo->pServers);
    LocalFree (pDsInfo->pszRootDomainFQDN);
    LocalFree (pDsInfo->pulTargets);
    LocalFree (pDsInfo->pszPartitionsDn);
}

VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++
Routine Description:

    Dumps the buffer content on to the output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

--*/
{
    DWORD j;
    PULONG LongBuffer;
    ULONG LongLength;

    LongBuffer = Buffer;
    LongLength = min( BufferSize, 512 )/4;

    for(j = 0; j < LongLength; j++) {
        printf("%08lx ", LongBuffer[j]);
    }

    if ( BufferSize != LongLength*4 ) {
        printf( "..." );
    }

}

void
DcDiagPrintCrInfo(
    PDC_DIAG_CRINFO  pCrInfo,
    WCHAR *          pszVar
    )
/*++
Routine Description:

    Prints out a pCrInfo structure.

Arguments:

    pCrInfo - The structure to print.
    pszVar - The string to prefix each line we print with.

--*/
{
    LONG      i;
    
    if (pCrInfo->dwFlags & CRINFO_DATA_NO_CR) {
        wprintf(L"%ws is blank\n", pszVar);
    } else {

        wprintf(L"%ws.dwFlags=0x%08x\n", 
                pszVar, pCrInfo->dwFlags);
        wprintf(L"%ws.pszDn=%ws\n",
                pszVar, pCrInfo->pszDn ? pCrInfo->pszDn : L"(null)");
        wprintf(L"%ws.pszDnsRoot=%ws\n",
                pszVar, pCrInfo->pszDnsRoot ? pCrInfo->pszDnsRoot : L"(null)");
        wprintf(L"%ws.iSourceServer=%d\n",
                pszVar, pCrInfo->iSourceServer);
        wprintf(L"%ws.pszSourceServer=%ws\n",
                pszVar, pCrInfo->pszSourceServer ? pCrInfo->pszSourceServer : L"(null)");
        wprintf(L"%ws.ulSystemFlags=0x%08x\n",
                pszVar, pCrInfo->ulSystemFlags);
        wprintf(L"%ws.bEnabled=%ws\n",
                pszVar, pCrInfo->bEnabled ? L"TRUE" : L"FALSE");
        // ftWhenCreated.
        wprintf(L"%ws.ftWhenCreated=", pszVar);
        DumpBuffer(&pCrInfo->ftWhenCreated, sizeof(pCrInfo->ftWhenCreated));
        wprintf(L"%ws.pszSDReferenceDomain=%ws\n",
                pszVar, pCrInfo->pszSDReferenceDomain ? pCrInfo->pszSDReferenceDomain : L"(null)");
        wprintf(L"%ws.pszNetBiosName=%ws\n",
                pszVar, pCrInfo->pszNetBiosName ? pCrInfo->pszNetBiosName : L"(null)");
        // Code.Improvement - print the pdnNcName string, guid, and sid.
        wprintf(L"%ws.aszReplicas=", pszVar);
        if (pCrInfo->cReplicas != -1) {
            for (i=0; i < pCrInfo->cReplicas; i++) {
                wprintf(L"%ws     %ws\n", pszVar, pCrInfo->aszReplicas[i]);
            }
        }
        
        wprintf(L"\n");
    }

}

VOID
DcDiagPrintDsInfo(
    PDC_DIAG_DSINFO pDsInfo
    )
/*++

Routine Description:

    This will print out the pDsInfo which might be helpful for debugging.

Parameters:

    pDsInfo - [Supplies] This is the struct that needs printing out,
        containing the info about the Active Directory.

  --*/
{
    WCHAR                        pszVar[50];
    ULONG                        ul, ulInner;

    wprintf(L"\n===============================================Printing out pDsInfo\n");
    wprintf(L"\nGLOBAL:"
            L"\n\tulNumServers=%d"
            L"\n\tpszRootDomain=%s"
            L"\n\tpszNC=%s"
            L"\n\tpszRootDomainFQDN=%s"
            L"\n\tpszConfigNc=%s"
            L"\n\tpszPartitionsDn=%s"
            L"\n\tiSiteOptions=%X"
            L"\n\tdwTombstoneLifeTimeDays=%d\n"
            L"\n\tdwForestBehaviorVersion=%d\n"
            L"\n\tHomeServer=%d, %s\n", 
            pDsInfo->ulNumServers,
            pDsInfo->pszRootDomain,
            // This is an optional parameter.
            (pDsInfo->pszNC) ? pDsInfo->pszNC : L"",
            pDsInfo->pszRootDomainFQDN,
            pDsInfo->pszConfigNc,
            pDsInfo->pszPartitionsDn,
            pDsInfo->iSiteOptions,
            pDsInfo->dwTombstoneLifeTimeDays,
            pDsInfo->dwForestBehaviorVersion,
            pDsInfo->ulHomeServer, 
            pDsInfo->pServers[pDsInfo->ulHomeServer].pszName
           );

    for (ul=0; ul < pDsInfo->ulNumServers; ul++) {
        LPWSTR pszUuidObject = NULL, pszUuidInvocation = NULL;
        if (UuidToString( &(pDsInfo->pServers[ul].uuid), &pszUuidObject ) != RPC_S_OK) return;
        if (UuidToString( &(pDsInfo->pServers[ul].uuidInvocationId), &pszUuidInvocation ) != RPC_S_OK) return;
        wprintf(L"\n\tSERVER: pServer[%d].pszName=%s"
                L"\n\t\tpServer[%d].pszGuidDNSName=%s"
                L"\n\t\tpServer[%d].pszDNSName=%s"
                L"\n\t\tpServer[%d].pszDn=%s"
                L"\n\t\tpServer[%d].pszComputerAccountDn=%s"
                L"\n\t\tpServer[%d].uuidObjectGuid=%s"
                L"\n\t\tpServer[%d].uuidInvocationId=%s"
                L"\n\t\tpServer[%d].iSite=%d (%s)"
                L"\n\t\tpServer[%d].iOptions=%x",
                ul, pDsInfo->pServers[ul].pszName,
                ul, pDsInfo->pServers[ul].pszGuidDNSName,
                ul, pDsInfo->pServers[ul].pszDNSName,
                ul, pDsInfo->pServers[ul].pszDn,
                ul, pDsInfo->pServers[ul].pszComputerAccountDn,
                ul, pszUuidObject,
                ul, pszUuidInvocation,
                ul, pDsInfo->pServers[ul].iSite, pDsInfo->pSites[pDsInfo->pServers[ul].iSite].pszName,
                ul, pDsInfo->pServers[ul].iOptions
               );
        // .ftLocalAcquireTime
        wprintf(L"\n\t\tpServer[%d].ftLocalAcquireTime=", ul);
        DumpBuffer(&pDsInfo->pServers[ul].ftLocalAcquireTime, sizeof(FILETIME));
        wprintf(L"\n");
        // .ftRemoteConnectTime
        wprintf(L"\n\t\tpServer[%d].ftRemoteConnectTime=", ul);
        DumpBuffer(&pDsInfo->pServers[ul].ftRemoteConnectTime, sizeof(FILETIME));
        wprintf(L"\n");
        if (pDsInfo->pServers[ul].ppszMasterNCs) {
            wprintf(L"\n\t\tpServer[%d].ppszMasterNCs:", ul);
            for (ulInner = 0; pDsInfo->pServers[ul].ppszMasterNCs[ulInner] != NULL; ulInner++) {
                wprintf(L"\n\t\t\tppszMasterNCs[%d]=%s",
                        ulInner,
                        pDsInfo->pServers[ul].ppszMasterNCs[ulInner]);
            }
        }
        if (pDsInfo->pServers[ul].ppszPartialNCs) {
            wprintf(L"\n\t\tpServer[%d].ppszPartialNCs:", ul);
            for (ulInner = 0; pDsInfo->pServers[ul].ppszPartialNCs[ulInner] != NULL; ulInner++) {
                wprintf(L"\n\t\t\tppszPartialNCs[%d]=%s",
                        ulInner,
                        pDsInfo->pServers[ul].ppszPartialNCs[ulInner]);
            }
        }
        wprintf(L"\n");
        RpcStringFree( &pszUuidObject );
        RpcStringFree( &pszUuidInvocation );
    }

    for (ul=0; ul < pDsInfo->cNumSites; ul++) {
        wprintf(L"\n\tSITES:  pSites[%d].pszName=%s"
                L"\n\t\tpSites[%d].pszSiteSettings=%s"
                L"\n\t\tpSites[%d].pszISTG=%s"
                L"\n\t\tpSites[%d].iSiteOption=%x\n"
                L"\n\t\tpSites[%d].cServers=%d\n",
                ul, pDsInfo->pSites[ul].pszName,
                ul, pDsInfo->pSites[ul].pszSiteSettings,
                ul, pDsInfo->pSites[ul].pszISTG,
                ul, pDsInfo->pSites[ul].iSiteOptions,
                ul, pDsInfo->pSites[ul].cServers);
    }

    if (pDsInfo->pNCs != NULL) {
        for (ul=0; ul < pDsInfo->cNumNCs; ul++) {
            wprintf(L"\n\tNC:     pNCs[%d].pszName=%s",
                    ul, pDsInfo->pNCs[ul].pszName);
            wprintf(L"\n\t\tpNCs[%d].pszDn=%s\n",
                    ul, pDsInfo->pNCs[ul].pszDn);
            for(ulInner = 0; ulInner < (ULONG) pDsInfo->pNCs[ul].cCrInfo; ulInner++){

                wprintf(L"\n");
                swprintf(pszVar, L"\t\t\tpNCs[%d].aCrInfo[%d]", ul, ulInner);
                DcDiagPrintCrInfo(&pDsInfo->pNCs[ul].aCrInfo[ulInner], pszVar);
                wprintf(L"\n");

            }
        }
    }

    wprintf(L"\n\t%d NC TARGETS: ", pDsInfo->cNumNcTargets);
    for (ul = 0; ul < pDsInfo->cNumNcTargets; ul++) {
        wprintf(L"%ws, ", pDsInfo->pNCs[pDsInfo->pulNcTargets[ul]].pszName);
    }

    wprintf(L"\n\t%d TARGETS: ", pDsInfo->ulNumTargets);
    for (ul=0; ul < pDsInfo->ulNumTargets; ul++) {
        wprintf(L"%s, ", pDsInfo->pServers[pDsInfo->pulTargets[ul]].pszName);
    }

    wprintf(L"\n\n=============================================Done Printing pDsInfo\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\common\ldaputil.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldaputil.c

ABSTRACT:

    This gives shortcuts to common ldap code.

DETAILS:

    This is a work in progress to have convienent functions added as needed
    for simplyfying the massive amounts of LDAP code that must be written for
    dcdiag.
    
    All functions should return two types, either a pointer that will be
    a NULL on an error, or will be a win 32 error code.

    All returned results that need alloc'd memory should use LocalAlloc(),
    so that all results can be dealloc'd using LocalFree().

  ===================================================================
  Code.Improvement It would be good to continue to add to this as the
  need arrises.  Things that might be added are:
    DcDiagGetBlobAttribute() ???
    DcDiagGetMultiStringAttribute() ... returns a LPWSTR *, but must use ldap_value_free() on it.
    DcDiagGetMultiBlobAttribute() ??/

CREATED:

    23 Aug 1999  Brett Shirley

--*/

#include <ntdspch.h>
#include <ntdsa.h>    // options
#include <ntldap.h>

#include "dcdiag.h"

FILETIME gftimeZero = {0};

// Other Forward Function Decls
PDSNAME
DcDiagAllocDSName (
    LPWSTR            pszStringDn
    );


DWORD
DcDiagGetStringDsAttributeEx(
    LDAP *                          hld,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    )
/*++

Routine Description:

    This function takes a handle to an LDAP, and gets the
    single string attribute value of the specified attribute
    on the distinquinshed name.

Arguments:

    hld - LDAP connection to use.
    pszDn - The DN containing the desired attribute value.
    pszAttr - The attribute containing the desired value.
    ppszResult - The returned string, in LocalAlloc'd mem.

Return Value:
    
    Win 32 Error.

Note:

    As all LDAPUTIL results, the results should be freed, 
    using LocalFree().

--*/
{
    LPWSTR                         ppszAttrFilter[2];
    LDAPMessage *                  pldmResults = NULL;
    LDAPMessage *                  pldmEntry = NULL;
    LPWSTR *                       ppszTempAttrs = NULL;
    DWORD                          dwErr = ERROR_SUCCESS;
    
    *ppszResult = NULL;

    Assert(hld);

    __try{

        ppszAttrFilter[0] = pszAttr;
        ppszAttrFilter[1] = NULL;
        dwErr = LdapMapErrorToWin32(ldap_search_sW(hld,
                                                   pszDn,
                                                   LDAP_SCOPE_BASE,
                                                   L"(objectCategory=*)",
                                                   ppszAttrFilter,
                                                   0,
                                                   &pldmResults));


        if(dwErr != ERROR_SUCCESS){
            __leave;
        }

        pldmEntry = ldap_first_entry(hld, pldmResults);
        if(pldmEntry == NULL){
            Assert(!L"I think this shouldn't ever happen? BrettSh\n");
            // Need to signal and error of some sort.  Technically the error
            //   is in the ldap session object.
            dwErr = LdapMapErrorToWin32(hld->ld_errno);
            __leave;
        }
        
        ppszTempAttrs = ldap_get_valuesW(hld, pldmEntry, pszAttr);
        if(ppszTempAttrs == NULL || ppszTempAttrs[0] == NULL){
            // Simply means there is no such attribute.  Not an error.
            __leave;
        }

        *ppszResult = LocalAlloc(LMEM_FIXED, 
                           sizeof(WCHAR) * (wcslen(ppszTempAttrs[0]) + 2));
        if(*ppszResult == NULL){
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        wcscpy(*ppszResult, ppszTempAttrs[0]);

    } __finally {
        if(pldmResults != NULL){ ldap_msgfree(pldmResults); }
        if(ppszTempAttrs != NULL){ ldap_value_freeW(ppszTempAttrs); }
    }

    return(dwErr);
}


DWORD
DcDiagGetStringDsAttribute(
    IN  PDC_DIAG_SERVERINFO         prgServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    )
/*++

Routine Description:

    This is a wrapper for the function DcDiagGetStringDsAttributeEx(),
    which takes a hld.  This function uses dcdiag a pServer structure 
    to know who to connect/bind to.  Then it returns the result and
    pResult straight from the Ex() function.

Arguments:

    prgServer - A struct holding the server name/binding info.
    gpCreds - The credentials to use in binding.
    pszDn - The DN holding the attribute value desired.
    pszAttr - The attribute with the desired value.

Return Value:
    
    Win 32 Error.

Note:

    As all LDAPUTIL results, the results should be freed, 
    using LocalFree().

--*/
{
    LDAP *                         hld = NULL;
    DWORD                          dwErr;
    
    dwErr = DcDiagGetLdapBinding(prgServer,
                                 gpCreds,
                                 FALSE,
                                 &hld);
    if(dwErr != ERROR_SUCCESS){
        // Couldn't even bind to the server, return the error.
        return(dwErr);
    }       

    dwErr = DcDiagGetStringDsAttributeEx(hld,
                                         pszDn,
                                         pszAttr,
                                         ppszResult);
    return(dwErr);
}


LPWSTR
DcDiagTrimStringDnBy(
    IN  LPWSTR                      pszInDn,
    IN  ULONG                       ulTrimBy
    )
/*++

Routine Description:

    This routine simply takes a DN as a string, and trims off the number
    of DN parts as specified by ulTrimBy.

Arguments:

    pszInDn - The DN to trim.
    ulTrimBy - Number of parts to trim off the front of the DN.

Return Value:
    
    Returns NULL if there was an error, otherwise a pointer to the new DN.

Note:

    As all LDAPUTIL results, the results should be freed, 
    using LocalFree().

--*/
{
    PDSNAME                         pdsnameOrigDn = NULL;
    PDSNAME                         pdsnameTrimmed = NULL;
    LPWSTR                          pszOutDn;

    Assert(ulTrimBy > 0);
    Assert(ulTrimBy < 50); // insanity check

    // Setup two pdsname structs, for orig & trimmed DNs.
    pdsnameOrigDn = DcDiagAllocDSName(pszInDn);
    if(pdsnameOrigDn == NULL){
        return(NULL);
    }
    pdsnameTrimmed = (PDSNAME) LocalAlloc(LMEM_FIXED, pdsnameOrigDn->structLen);
    if(pdsnameTrimmed == NULL){
        LocalFree(pdsnameOrigDn);
        return(NULL);
    }

    // Trim the DN.
    TrimDSNameBy(pdsnameOrigDn, ulTrimBy, pdsnameTrimmed);

    // Allocate the result and return it.  We could put this back 
    // where the original is, but then callers would have to be changed
    // to expect this.
    Assert(wcslen(pdsnameTrimmed->StringName) <= wcslen(pszInDn));
    pszOutDn = LocalAlloc(LMEM_FIXED, 
                        sizeof(WCHAR) * (wcslen(pdsnameTrimmed->StringName) + 2));
    if(pszOutDn == NULL){
        LocalFree(pdsnameTrimmed);
        LocalFree(pdsnameOrigDn);
        return(NULL);
    }
    wcscpy(pszOutDn, pdsnameTrimmed->StringName);

    // Free temporary memory and return result
    LocalFree(pdsnameOrigDn);
    LocalFree(pdsnameTrimmed);
    return(pszOutDn);
}


BOOL
DcDiagIsStringDnMangled(
    IN  LPWSTR                      pszInDn,
    IN  MANGLE_FOR *                peMangleFor
    )
/*++

Routine Description:

    This routine simply takes a DN as a string, and checks for 
    some form of mangling.
    
Arguments:

    pszInDn - The DN to check for mangling.
    peMangleType - OPTIONAL What kind of mangling.

Return Value:
    
    Returns NULL if there was an error, otherwise a pointer to the new DN.

Note:

    As all LDAPUTIL results, the results should be freed, 
    using LocalFree().

--*/
{
    PDSNAME                         pdsnameDn = NULL;
    DWORD                           dwRet;

    pdsnameDn = DcDiagAllocDSName(pszInDn);
    if(pdsnameDn == NULL){
        DcDiagChkNull(pdsnameDn);
    }

    dwRet = IsMangledDSNAME(pdsnameDn, peMangleFor);
    
    LocalFree(pdsnameDn);

    if (dwRet == ERROR_DS_NAME_UNPARSEABLE) {
        Assert(!"Can we enforce this assert?  This may need to be removed if anyone"
               "ever uses a user specified DN with this function. So far we don't.");
        return(FALSE);
    }
    
    Assert(dwRet == TRUE || dwRet == FALSE);
    return(dwRet);
}

INT
MemWtoi(WCHAR *pb, ULONG cch)
/*++

Routine Description:

    This function will take a string and a length of numbers to convert.

Parameters:
    pb - [Supplies] The string to convert.
    cch - [Supplies] How many characters to convert.

Return Value:
  
    The value of the integers.

  --*/
{
    int res = 0;
    int fNeg = FALSE;

    if (*pb == L'-') {
        fNeg = TRUE;
        pb++;
    }


    while (cch--) {
        res *= 10;
        res += *pb - L'0';
        pb++;
    }
    return (fNeg ? -res : res);
}

DWORD
DcDiagGeneralizedTimeToSystemTime(
    LPWSTR IN                   szTime,
    PSYSTEMTIME OUT             psysTime)
/*++

Routine Description:

    Converts a generalized time string to the equivalent system time.

Parameters:
    szTime - [Supplies] This is string containing generalized time.
    psysTime - [Returns] This is teh SYSTEMTIME struct to be returned.

Return Value:
  
    Win 32 Error code, note could only result from invalid parameter.

  --*/
{
   DWORD       status = ERROR_SUCCESS;
   ULONG       cch;
   ULONG       len;

    //
    // param sanity
    //
    if (!szTime || !psysTime)
    {
       return STATUS_INVALID_PARAMETER;
    }

    len = wcslen(szTime);

    if( len < 15 || szTime[14] != '.')
    {
       return STATUS_INVALID_PARAMETER;
    }

    // initialize
    memset(psysTime, 0, sizeof(SYSTEMTIME));

    // Set up and convert all time fields

    // year field
    cch=4;
    psysTime->wYear = (USHORT)MemWtoi(szTime, cch) ;
    szTime += cch;
    // month field
    psysTime->wMonth = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // day of month field
    psysTime->wDay = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // hours
    psysTime->wHour = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // minutes
    psysTime->wMinute = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // seconds
    psysTime->wSecond = (USHORT)MemWtoi(szTime, (cch=2));

    return status;

}

BOOL
TranslateStringByte(
    IN  WCHAR *str,
    OUT UCHAR *b
    )
//
// This routine translates str which is a hex string to its binary
// representation.  So if str == "f1" the value of *b would be set to 0xf1
// This function assumes the value contained str can be represented within
// a UCHAR.  This function returns if the value can't be translated
//
{
    BOOL fStatus = TRUE;
    WCHAR *temp;
    ULONG Power;
    UCHAR retSum = 0;

    // init the return value
    *b = 0;

    // boundary case
    if ( !str ) {
        return TRUE;
    }

    if ( wcslen(str) > 2) {
        // too big
        return FALSE;
    }

    for ( temp = str, Power = wcslen(str) - 1;
            *temp != L'\0';
                temp++, Power--) {

        WCHAR c = *temp;
        UCHAR value;

        if ( c >= L'a' && c <= L'f' ) {
            value = (UCHAR) (c - L'a') + 10;
        } else if ( c >= L'0' && c <= L'9' ) {
            value = (UCHAR) c - L'0';
        } else {
            // bogus value
            fStatus = FALSE;
            break;
        }

        if ( Power > 0 ) {
            retSum += (UCHAR) (Power*16) * value;
        } else {
            retSum += (UCHAR) value;
        }
    }

    // send the value back
    if ( fStatus) {
        *b = retSum;
    }

    return fStatus;

}

VOID
HexStringToBinary(
    IN WCHAR *  pszHexStr,
    IN ULONG    cBuffer,
    IN BYTE *   pBuffer
    )
/*++

Routine Description:

    Converts a hex-string representation of a sid or guid to binary

Arguments:

    pszHexStr (IN) - String buffer of the form "f69be212302".
    cBuffer (IN) - Count of buffer size in bytes.
    pBuffer (OUT) - Buffer to be filled with binary version of hex string.

--*/
{
    ULONG i;
    ULONG ccHexStrLen, cbHexStrLen;
    BOOL  fStatus;
    WCHAR str[] = L"00";

    Assert(cBuffer);
    Assert(pBuffer);
    Assert(pszHexStr);

    // There are two characters for each byte; the hex string length
    // must be even
    ccHexStrLen = wcslen( pszHexStr );
    Assert( (ccHexStrLen % 2) == 0 );
    cbHexStrLen = ccHexStrLen / 2;

    if( cbHexStrLen > cBuffer){
        // Crap!
        Assert(!"String is too long");
    }

    RtlZeroMemory( pBuffer, cBuffer );

    // Generate the binary sid
    for ( i = 0; i < cbHexStrLen; i++ ) {

        str[0] = pszHexStr[i*2];
        str[1] = pszHexStr[(i*2)+1];

        fStatus = TranslateStringByte( str, &pBuffer[i] );
        if ( !fStatus ) {
            Assert( !"Bad String" );
            return;
        }
    }

    return;
}

void
LdapGetStringDSNameComponents(
    LPWSTR       pszStrDn,
    LPWSTR *     ppszGuid,
    LPWSTR *     ppszSid,
    LPWSTR *     ppszDn
    )
/*++

Routine Description:

    This function takes a string with the format of a DN value returned 
    by LDAP when the LDAP_SERVER_EXTENDED_DN_OID_W server control is 
    provided.  The function expects a format like this:
        "<GUID=3bb021cad36dd1118a7db8dfb156871f>;<SID=0104000000000005150000005951b81766725d2564633b0b>;DC=ntdev,DC=microsoft,DC=com"
        Broken down like this
            <GUID=3bb021cad36dd1118a7db8dfb156871f>;
            <SID=0104000000000005150000005951b81766725d2564633b0b>;
            DC=ntdev,DC=microsoft,DC=com
        Where SID is optional.
        
    The function returns three pointers into the string, the pointers 
    point to the beginning of the GUID hex string (the "3bb0..." above), 
    SID hex string (the "0104..." above), and actual DN value (DC=ntdev...).

Arguments:

    pszStrDn (IN) - The string formatted "DSName" returned by LDAP.
    ppszGuid (OUT) - Pointer to the GUID hex string.  This string 
        according to the extended DN format should have a terminated
        '>' character for the end of the hex string.
    ppszSid (OUT) - Pointer to the SID hex string.  This string 
        according to the extended DN format should have a terminated
        '>' character for the end of the hex string.
    ppszDn (OUT) - Pointer to the DN portion, which should be NULL
        terminated.

Note: Throws exceptions if we fail, which is very unlikely and require 
bad data from LDAP.

--*/
{
    LPWSTR       pszGuid = NULL;
    LPWSTR       pszSid = NULL;
    LPWSTR       pszDn = NULL;

    // Get string DN portion
    pszGuid = wcsstr(pszStrDn, L"<GUID=");
    if (pszGuid) {
        while (*pszGuid != L'=') {
            pszGuid++;
        }
        pszGuid++;
    } else {
        Assert(!"Guid is required!  Why didn't the AD return it.");
        DcDiagException(ERROR_INVALID_PARAMETER);
    }
    // Get string SID portion.
    pszSid = wcsstr(pszGuid, L"<SID=");
    if (pszSid) {
        while (*pszSid != L'=') {
            pszSid++;
        }
        pszSid++;
    }
    // Get string DN portion.
    pszDn = (pszSid) ? pszSid : pszGuid;
    Assert(pszDn);
    if (pszDn) {
        while (*pszDn != L';') {
            pszDn++;
        }
        pszDn++;
    }

    // Set out parameters.
    if (ppszGuid) {
        *ppszGuid = pszGuid;
    }
    if (ppszSid) {
        *ppszSid = pszSid;
    }
    if (ppszDn) {
        *ppszDn = pszDn;
    }
}

DWORD
LdapMakeDSNameFromStringDSName(
    LPWSTR        pszStrDn,
    DSNAME **     ppdnOut
    )
/*++

Routine Description:

    This string takes the format of a DN value returned by LDAP when 
    the LDAP_SERVER_EXTENDED_DN_OID_W server control is provided. See
    LdapGetStringDSNameComponents() for more details on this format.

Arguments:

    pszStrDn (IN) - The string format of a DSNAME.
    ppdnOut (OUT) - A LocalAlloc()'d version of a real DSNAME structure
        like the ones used in ntdsa.dll complete with GUID and SID! 

Returns:

    LDAP Error.
     
NOTE/WARNING:
    This function modifies the string to have a couple '\0's at 
    various places (i.e. the function is destructive), so the string
    may be unusable for your purposes after this function is done.
    However, you will still be able to free it with the regular LDAP
    freeing functions (ldap_value_freeW()).

--*/
{
    LPWSTR        pszDn=NULL, pszGuid=NULL, pszSid=NULL; // Components.
    LPWSTR        pszTemp;
    DSNAME *      pdnOut;

    Assert(ppdnOut);

    //
    // Locate each component of the "string DSNAME".
    //

    LdapGetStringDSNameComponents(pszStrDn, &pszGuid, &pszSid, &pszDn);
    Assert(pszGuid && pszDn);
    if (pszGuid == NULL || pszDn == NULL) {
        return(LDAP_INVALID_SYNTAX);
    }

    //
    // Destructive part, NULL out tail end of each string component
    //
    // Code.Improvement It'd be pretty easy to make this non-destructive I guess,
    // just either restore these characters or, simply make HexStringToBinary()
    // simply stop at '>' instead of the NULL.
    if (pszGuid) {
        pszTemp = pszGuid;
        while (*pszTemp != L'>') {
            pszTemp++;
        }
        *pszTemp = L'\0';
    }
    if (pszSid) {
        pszTemp = pszSid;
        while (*pszTemp != L'>') {
            pszTemp++;
        }
        *pszTemp = L'\0';
    }
    // pszDn is NULL'd at the end by default.

    //
    // Now, actually construct the DSNAME!
    //
    pdnOut = DcDiagAllocDSName(pszDn);
    if (pszGuid) {
        HexStringToBinary(pszGuid, sizeof(pdnOut->Guid), (BYTE *) &(pdnOut->Guid));
    }
    if (pszSid) {
        HexStringToBinary(pszSid, sizeof(pdnOut->Sid), (BYTE *) &(pdnOut->Sid));
        pdnOut->SidLen = GetLengthSid(&(pdnOut->Sid));
        Assert( RtlValidSid( &(pdnOut->Sid) ) );
    }


    // Set out parameter.
    *ppdnOut = pdnOut;
    return(LDAP_SUCCESS);
}

DWORD
LdapFillGuidAndSid(
    LDAP *      hld,
    LPWSTR      pszDn,
    LPWSTR      pszAttr,
    DSNAME **   ppdnOut
    )
/*++

Routine Description:

    This function performs a search for an attribute (pszAttr) on
    an object (pszDn) and then returns a true DSNAME structure for
    that DN value found.  This function does this by using LDAP
    to search for the attribute with the server control for getting
    extended DNs: LDAP_SERVER_EXTENDED_DN_OID_W
    
    Code.Improvement - Be cool to make it so if pszAttr was NULL,
    that we just created the DSNAME structure corresponding to the
    actual pszDn passed in.  Though in that case, just search for
    the objectGuid and sID (?) attributes right on the object.
    
    Note, this will make another round trip to the server, and so
    if conveinent it's preferred to perform your own extended DN
    search, and then you can call LdapMakeDSNameFromStringDSName()
    yourself to make a DSNAME structure.

Arguments:

    hld (IN) - LDAP Binding Handle
    pszDn (IN) - The DN to be part of the base search.
    pszAttr (IN) - The DN valued attribute to retrieve.
    ppdnOut (OUT) - A LocalAlloc()'d version of a real DSNAME structure
        like the ones used in ntdsa.dll complete with GUID and SID! 

Returns:

    LDAP Error.
     
--*/
{
    ULONG         LdapError = LDAP_SUCCESS;
    LDAPMessage   *SearchResult = NULL;
    PLDAPControlW ServerControls[2];
    LDAPControlW  ExtDNcontrol;
    LDAPMessage *Entry;
    WCHAR         *AttrsToSearch[2];
    WCHAR         **Values = NULL;

    AttrsToSearch[0] = pszAttr;
    AttrsToSearch[1] = NULL;

    // Set up the extended DN control.
    ExtDNcontrol.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    ExtDNcontrol.ldctl_iscritical = TRUE;
    ExtDNcontrol.ldctl_value.bv_len = 0;
    ExtDNcontrol.ldctl_value.bv_val = NULL;
    ServerControls[0] = &ExtDNcontrol;
    ServerControls[1] = NULL;

    __try {

        LdapError = ldap_search_ext_sW( hld,
                                        pszDn,
                                        LDAP_SCOPE_BASE,
                                        L"(objectCategory=*)",
                                        AttrsToSearch,
                                        FALSE,
                                        (PLDAPControlW *)ServerControls,
                                        NULL,
                                        NULL,
                                        0,
                                        &SearchResult);

        if ( LDAP_SUCCESS != LdapError ){
            __leave;
        }


        Entry = ldap_first_entry(hld, SearchResult);
        if (Entry == NULL) {
            LdapError = LDAP_OPERATIONS_ERROR;
            __leave;
        }

        Values = ldap_get_valuesW(hld, Entry, pszAttr);
        if (Values == NULL) {
            LdapError = LDAP_OPERATIONS_ERROR;
            __leave;
        }

        Assert(!ldap_next_entry(hld, Entry));

        // Note this function is destructive and cuts up this value we pass in.
        LdapError = LdapMakeDSNameFromStringDSName(Values[0], ppdnOut);

    } __finally {
        if (SearchResult) { ldap_msgfree(SearchResult); }
        if (Values) { ldap_value_freeW(Values); }
    }

    return(LdapError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\common\events.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    common\events.c

ABSTRACT:

    This gives a library of functions that can be used to quickly construct a
    new test on an event log.  First implemented for the File Replication
    Service event log, but hopefully soon there will be a Directory Service
    and System event log tests.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

NOTES:

    An example of how to use this API is in frs/frsevents.c

--*/

#include <ntdspch.h>
#include <netevent.h>

#include "dcdiag.h"
#include "utils.h"

HINSTANCE
GetHLib(
    LPWSTR                          pszEventLog,
    LPWSTR                          pszSource
    )
/*++

Routine Description:

    This routine will return a hLib loaded DLL for event log message retrieving
    purposes.

Arguments:

    pszEventLog - This is the event log to look at, such as "System", or "File
        Replication Service"
    pszSource - This is the Source field from the EVENTLOGRECORD structure,
        which is immediately after the main data.

Return Value:

    hLib - Loaded DLL, or NULL if there is an error.  If there is an error
    use GetLastError() to retrieve the error.

--*/
{
    WCHAR                           pszTemp[MAX_PATH];
    DWORD                           dwRet;
    HKEY                            hk = NULL;
    WCHAR                           pszMsgDll[MAX_PATH];
    HINSTANCE                       hLib;
    DWORD                           dwcbData;
    DWORD                           dwType;
    DWORD                           cchDest;

    // From the event log source name, we know the name of the registry
    // key to look under for the name of the message DLL that contains
    // the messages we need to extract with FormatMessage. So first get
    // the event log source name... 
    wcscpy(pszTemp, L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\");
    if (!pszEventLog || !pszSource ||
        wcslen(pszEventLog) + wcslen(pszSource) + 2 > MAX_PATH - wcslen(pszTemp))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }
    wcscat(pszTemp, pszEventLog);
    wcscat(pszTemp, L"\\");
    wcscat(pszTemp, pszSource);

    // Now open this key and get the EventMessageFile value, which is
    // the name of the message DLL. 
    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, pszTemp, &hk);
    if(dwRet != ERROR_SUCCESS){
        SetLastError(dwRet);
        return(NULL);
    }
    dwcbData = MAX_PATH;
    dwRet = RegQueryValueEx(hk,    // handle of key to query        
                            L"EventMessageFile",   // value name            
                            NULL,                 // must be NULL          
                            &dwType,              // address of type value 
                            (LPBYTE) pszTemp,     // address of value data 
                            &dwcbData);           // length of value data  
    if(dwRet != ERROR_SUCCESS){
        SetLastError(dwRet);
        return(NULL);
    }

    // Expand environment variable strings in the message DLL path name,
    // in case any are there. 
    cchDest = ExpandEnvironmentStrings(pszTemp, pszMsgDll, MAX_PATH);
    if(cchDest == 0 || cchDest >= MAX_PATH){
        SetLastError(-1);
        return(NULL);
    }
    
    // Now we've got the message DLL name, load the DLL.
    hLib = LoadLibraryEx(pszMsgDll, NULL, DONT_RESOLVE_DLL_REFERENCES);
    
    RegCloseKey(hk);
    return(hLib);
}

ULONG
EventExceptionHandler(
    IN const  EXCEPTION_POINTERS * prgExInfo,
    OUT PDWORD                     pdwWin32Err
    )
{
   if(pdwWin32Err != NULL) {
      *pdwWin32Err = prgExInfo->ExceptionRecord->ExceptionCode;
   }
   return EXCEPTION_EXECUTE_HANDLER;
}

#define MAX_INSERT_STRS           16
#define MAX_MSG_LENGTH            1024

DWORD
GetEventString(
    LPWSTR                          pszEventLog,
    PEVENTLOGRECORD                 pEvent,
    LPWSTR *                        ppszMsg
    )
/*++

Routine Description:

    This function will do it's best effort to retrieve and format the string
    associated with this event ID.

Arguments:

    pszEventLog - The name of the event log, like "System", or "File
        Replication System".
    pEvent - A pointer to the event that we wish to retrieve the string of.
    ppszMsg - This is the variable to return the string in.  If there is an
        error then this will be NULL.  Use LocalFree() to free.

Return Value:

    DWORD - win 32 error.

Code.Improvement:
    It would be good to store the hLib's for the future events, it is really
    bad to LoadLibrary() and FreeLibrary() every time.  This would require
    some sort of consistent context.

--*/
{
    LPWSTR                          pszMsgBuf = NULL;
    LPWSTR                          ppszInsertStrs[MAX_INSERT_STRS];
    HINSTANCE                       hLib = NULL;
    LPWSTR                          pszTemp;
    INT                             i;
    DWORD                           dwCount = 0, dwErr = ERROR_SUCCESS;

    *ppszMsg = NULL;

    __try { // defend against bad event log records

       hLib = GetHLib(pszEventLog,
                      (LPWSTR) ((LPBYTE) pEvent + sizeof(EVENTLOGRECORD)));
       if(hLib == NULL){
           return(GetLastError());
       }

       if(pEvent->NumStrings >= MAX_INSERT_STRS){
           Assert(!"That is ALOT of insert strings, check this out\n");
           return(-1);
       }

       pszTemp = (WCHAR *) ((LPBYTE) pEvent + pEvent->StringOffset);

       for (i = 0; i < pEvent->NumStrings && i < MAX_INSERT_STRS; i++){
           ppszInsertStrs[i] = pszTemp;
           pszTemp += wcslen(pszTemp) + 1;     // point to next string 
       }

       dwCount = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                               | FORMAT_MESSAGE_FROM_HMODULE 
                               | FORMAT_MESSAGE_ARGUMENT_ARRAY
                               | 50, //Code.Improvement, remove this when we move
                               // to the new PrintMsg() functions.
                               hLib,
                               pEvent->EventID,
                               MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                               (LPWSTR) &pszMsgBuf,
                               MAX_MSG_LENGTH,
                               (va_list *) ppszInsertStrs);
       if(dwCount == 0){
           Assert(GetLastError() != ERROR_SUCCESS);
           return(GetLastError());
       }

       *ppszMsg = pszMsgBuf;
    }
    __except (EventExceptionHandler(GetExceptionInformation(), &dwErr)) {

        ASSERT(FALSE && "Bad event record!");
        PrintMsg(SEV_ALWAYS, DCDIAG_ERR_BAD_EVENT_REC, dwErr);
        PrintMessage(SEV_ALWAYS, L"\n");
    }

    if (hLib) FreeLibrary(hLib);

    return(dwErr);
}

void 
PrintTimeGenerated(
    PEVENTLOGRECORD              pEvent
    )
/*++

Routine Description:

    This takes an event and simply prints out the time it was generated.

Arguments:

    pEvent - The event to print the time of.

Return Value:

    DWORD - win 32 error.

--*/
{
    FILETIME FileTime, LocalFileTime;
    SYSTEMTIME SysTime;
    __int64 lgTemp;
    __int64 SecsTo1970 = 116444736000000000;

    lgTemp = Int32x32To64(pEvent->TimeGenerated,10000000) + SecsTo1970;

    FileTime.dwLowDateTime = (DWORD) lgTemp;
    FileTime.dwHighDateTime = (DWORD)(lgTemp >> 32);

    FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, &SysTime);

    PrintMessage(SEV_ALWAYS, 
                 L"Time Generated: %02d/%02d/%02d   %02d:%02d:%02d\n",
                 SysTime.wMonth,
                 SysTime.wDay,
                 SysTime.wYear,
                 SysTime.wHour,
                 SysTime.wMinute,
                 SysTime.wSecond);

}

VOID
GenericPrintEvent(
    LPWSTR                          pszEventLog,
    PEVENTLOGRECORD                 pEvent,
    BOOL                            fVerbose
    )
/*++

Routine Description:

    This formats and prints out in a very basic style an event.

Arguments:

    pszEventLog - The event log that pEvent came from, like "System", or
        "File Replication Service"
    pEvent - The event to print.
    fVerbose - Display full text of the message, or only first line

--*/
{
    DWORD                           dwRet;
    LPWSTR                          pszMsgBuf = NULL;
    LPWSTR                          pszType;

    Assert(pEvent);

    switch(pEvent->EventType){
    case EVENTLOG_ERROR_TYPE:
        pszType = L"Error";
        break;
    case EVENTLOG_WARNING_TYPE:
        pszType = L"Warning";
        break;
    case EVENTLOG_INFORMATION_TYPE:
        pszType = L"Information";
        break;
    case EVENTLOG_AUDIT_SUCCESS:
        pszType = L"Audit Success";
        break;
    case EVENTLOG_AUDIT_FAILURE:
        pszType = L"Audit Failure";
        break;
    default:
        pszType = L"Unknown";
    }

    PrintMessage(SEV_ALWAYS, L"An %s Event occured.  EventID: 0x%08X\n",
                 pszType, pEvent->EventID);

    PrintIndentAdj(1);
    PrintTimeGenerated(pEvent);

    dwRet = GetEventString(pszEventLog, pEvent, &pszMsgBuf);
    if(dwRet == ERROR_SUCCESS){
        // Truncate to single line if requested
        if (!fVerbose) {
            LPWSTR pszEnd = wcschr( pszMsgBuf, L'\n' );
            if (pszEnd) {
                *pszEnd = L'\0';
            }
        }
        PrintMessage(SEV_ALWAYS, L"Event String: %s\n", pszMsgBuf);
    } else {
        PrintMessage(SEV_ALWAYS, L"(Event String could not be retrieved)\n");
    }
    LocalFree(pszMsgBuf);   
    PrintIndentAdj(-1);
}



BOOL
EventIsInList(
    DWORD                           dwTarget,
    PDWORD                          paEventsList
    )
/*++

Routine Description:

    A helper routine for PrintSelectEvents, it deterines whether this list has
    the event we want.

Arguments:
 
    dwTarget - The DWORD to search for.
    paEventsList - The list of DWORDs to check

Return Value:

    TRUE if the array paEventsList has the event dwTarget, FALSE otherwise, or
    if teh paEventsList is NULL.

--*/
{
    if(paEventsList == NULL){
        return(FALSE);
    }
    while(*paEventsList != 0){
        if(dwTarget == *paEventsList){
            return(TRUE);
        }
        paEventsList++;
    }
    return(FALSE);
}

DWORD
PrintSelectEvents(
    PDC_DIAG_SERVERINFO             pServer,
    SEC_WINNT_AUTH_IDENTITY_W *     pCreds,
    LPWSTR                          pwszEventLog,
    DWORD                           dwPrintAllEventsOfType,
    PDWORD                          paSelectEvents,
    PDWORD                          paBeginningEvents,
    DWORD                           dwBeginTime,
    VOID (__stdcall *               pfnPrintEventHandler) (PVOID, PEVENTLOGRECORD),
    VOID (__stdcall *               pfnBeginEventHandler) (PVOID, PEVENTLOGRECORD),
    PVOID                           pvContext
   )
/*++

Routine Description:

Arguments:

    pServer - Server with the event log to query,
        EX: "\\brettsh-posh.brettsh-spice.nttest.microsoft.com"
    pCreds - Current user credentials
    pwszEventLog - The name of the event log, EX: "File Replication Server", 
        "Directory Service", "System", "Application", "Security"
    dwPrintAllEventsOfType - The type of events to print all of, valid values
        as of NT 5.0 are: EVENTLOG_INFORMATION_TYPE | EVENTLOG_WARNING_TYPE |
        EVENTLOG_ERROR_TYPE | EVENTLOG_AUDIT_SUCCESS | EVENTLOG_AUDIT_FAILURE
    paSelectEvents - And events that match this 0 terminated list of event IDs,
        will also be printed.  If NULL, then no events will be matched.
    paBeginngingEvents - The routine will only print events after the last one 
        of any of these events that it encounters.  If NULL, then it will go
        all the way to the beginning of the log.
    dwBeginTime - If present, a time_t indicating the earliest record we should
        include in the search.  Once we pass this point and find records earlier
        in the log, we stop the search
    pfnPrintEventHandler - Is the function to be called if an event is to be 
        printed.  Note this function if it didn't know what to make of the 
        event could just call this file's GenericPrintEvent().
    pfnBeginEventHandler - This function will be called when the an beginning
        event from paBeginningEvents is found, so the test can handle the 
        situation.  If a beginning event is never found and the beginning of
        the log is reached this function is called with NULL as the event.
    pvContext - Caller supplied value passed to callback functions

Return Value:

    Win 32 Error, in opening, reading, etc the log.

Notes:

    EX:
        DWORD                paSelectEvents [] = { EVENT_FRS_SYSVOL_NOT_READY,
                                             VENT_FRS_SYSVOL_NOT_READY_PRIMARY,
                                             0 };
        DWORD                paBegin [] = { EVENT_FRS_SYSVOL_READY,
                                            0 };
        PrintSelectEvents(L"\\brettsh-posh.brettsh-spice.nttest.microsoft.com",
                          L"File Replication Service",
                          EVENTLOG_ERROR_TYPE | EVENTLOG_AUDIT_SUCCESS, 
                          paSelectEvents, 
                          paBegin,
                          0, NULL, NULL);
    This will print all errors events and audit failure events, and the events
    EVENT_FRS_SYSVOL_NOT_READY, EVENT_FRS_SYSVOL_NOT_READY_PRIMARY (which 
    happen to be warning type events and so would not otherwise be printed), 
    that are logged after the last EVENT_FRS_SYSVOL_READY event in the "File
    Replication Log" on server brettsh-posh.  Note: that one should pass 
    NULL as paBeginningEvents if one wants to go all the way back to the 
    beginning of the log.

--*/
{
    // Generic opening/return_code event log variables.
    DWORD                           dwNetRet = ERROR_SUCCESS;
    LPWSTR                          pwszUNCServerName = NULL;
    INT                             iTemp;
    HANDLE                          hFrsEventlog = NULL;
    DWORD                           dwErr = ERROR_SUCCESS;
    BOOL                            bSuccess;
    // Reading the event log variables.
    DWORD                           cBufSize = 512;
    DWORD                           cBytesRead = 0;
    DWORD                           cBiggerBuffer = 0;
    PEVENTLOGRECORD                 pBuffer = NULL;
    PEVENTLOGRECORD                 pEvent = NULL;
    DWORD                           cNumRecords = 0;
    // Copying out selected events.
    PEVENTLOGRECORD *               paEventsToPrint = NULL;
    DWORD                           cEventsToPrint = 0;
    // Other misc variables
    INT                             i; // This must be an INT, not a ULONG

    __try{

        // Open Net Use Connection if needed ---------------------------------
        dwNetRet = DcDiagGetNetConnection(pServer, pCreds);
        if(dwNetRet != ERROR_SUCCESS){
            dwErr = dwNetRet;
            __leave; // Don't need print error, cause DcDiagGetNetConn... does.
        }
        
        // Setup Server Name -------------------------------------------------
        iTemp = wcslen(pServer->pszName) + 4;
        pwszUNCServerName = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR));
        if(pwszUNCServerName == NULL){
            dwErr = GetLastError();
            PrintMessage(SEV_ALWAYS, L"FATAL ERROR: Out of Memory\n");
            __leave;
        }
        wcscpy(pwszUNCServerName, L"\\\\");
        wcscat(pwszUNCServerName, pServer->pszName);

        // Open Event Log ----------------------------------------------------
        hFrsEventlog = OpenEventLog(pwszUNCServerName,
                                    pwszEventLog);
        if(hFrsEventlog == NULL){
            dwErr = GetLastError();
            PrintMessage(SEV_ALWAYS, 
                         L"Error %d opening FRS eventlog %s:%s:\n %s\n",
                         dwErr, pwszUNCServerName, pwszEventLog,
                         Win32ErrToString(dwErr));
            __leave;
        }
        
        // Init Events To Print array ----------------------------------------
        bSuccess = GetNumberOfEventLogRecords(hFrsEventlog, &cNumRecords);
        if(bSuccess){
            // Allocate an array to hold the maximum numer of possible events.
            paEventsToPrint = LocalAlloc(LMEM_FIXED, 
                                      sizeof(PEVENTLOGRECORD) * cNumRecords);
            // Code.Improvement, it would be good to make a dynamic array that
            //   grew as needed, because the total number of events in the
            //   log record could be quite large.
            if(paEventsToPrint == NULL){
                dwErr = GetLastError();
                PrintMessage(SEV_ALWAYS, L"FATAL ERROR: Out of Memory\n");
                __leave;
            }
       } else {
            dwErr = GetLastError();
            PrintMessage(SEV_ALWAYS, L"Error %d accessing FRS eventlog: %s\n", 
                         dwErr, Win32ErrToString(dwErr));
            __leave; 
        }
        
        // Start Reading Events ----------------------------------------------
    IncreaseBufferAndRetry:
        
        // Allocate buffer
        pBuffer = LocalAlloc(LMEM_FIXED, cBufSize);
        pEvent = pBuffer;
        
        while(bSuccess = ReadEventLog(hFrsEventlog,
                                      EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ,
                                      0,
                                      pBuffer,
                                      cBufSize,
                                      &cBytesRead,
                                      &cBiggerBuffer)){
            while(cBytesRead > 0){
                
                if (EventIsInList(pEvent->EventID, paBeginningEvents)) {
                    // Run the beginning function, bail and print the 
                    //  other events.
                    dwErr = ERROR_SUCCESS;
                    if(pfnBeginEventHandler != NULL){
                        pfnBeginEventHandler(pvContext, pEvent);
                    }
                    __leave;
                }
                // Exceeded time limit, stop search
                if (dwBeginTime && (pEvent->TimeGenerated < dwBeginTime)) {
                    if(pfnBeginEventHandler != NULL){
                        pfnBeginEventHandler(pvContext, NULL);
                    }
                    dwErr = ERROR_SUCCESS;
                    __leave;
                }

                // Detemine if we should print this event.
                if((dwPrintAllEventsOfType & pEvent->EventType)
                   || EventIsInList(pEvent->EventID, paSelectEvents)){
                    
                    // Copy events to print events array
                    paEventsToPrint[cEventsToPrint] = LocalAlloc(LMEM_FIXED,
                                                             pEvent->Length);
                    if(paEventsToPrint[cEventsToPrint] == NULL){
                        PrintMessage(SEV_ALWAYS, 
                                     L"FATAL ERROR: Out of Memory\n");
                        dwErr = GetLastError();
                        Assert(dwErr != ERROR_SUCCESS);
                        __leave;
                    }
                    memcpy(paEventsToPrint[cEventsToPrint],
                           pEvent,
                           pEvent->Length);
                    cEventsToPrint++;
                    
                }
                
                // Get next already read event.
                cBytesRead -= pEvent->Length;
                pEvent = (EVENTLOGRECORD *) ((LPBYTE) pEvent + pEvent->Length);
            }
            
            // Get another batch of events.
            pEvent = pBuffer;
        }
        
        // Determine if the error was an OK/recoverable error.
        dwErr = GetLastError();
        if (dwErr == ERROR_HANDLE_EOF){
            // This is a legitimate exit path, but we didn't find a 
            //  beginning event, so call the BeginningEventHandler to 
            //  tell the user so.
            if(pfnBeginEventHandler != NULL){
                pfnBeginEventHandler(pvContext, NULL);
            }
            dwErr = ERROR_SUCCESS;
        } else if(dwErr == ERROR_INSUFFICIENT_BUFFER){
            Assert(cBiggerBuffer > cBufSize);
            cBufSize = cBiggerBuffer;
            cBiggerBuffer = 0;
            LocalFree(pBuffer);
            pBuffer = NULL;
            goto IncreaseBufferAndRetry;
        } else {
            PrintMessage(SEV_ALWAYS, 
                         L"An unknown error occured trying to read the event "
                         L"log:\n");
            PrintMessage(SEV_ALWAYS,
                         L"Error(%d):%s\n", dwErr, Win32ErrToString(dwErr));
            __leave;
        }

    } __finally {
        // Clean up the temporary variables for reading the log.
        if(hFrsEventlog) {               CloseEventLog(hFrsEventlog); }
        if(pwszUNCServerName) {          LocalFree(pwszUNCServerName); }
        if(pBuffer) {                    LocalFree(pBuffer); }
    }

    if(dwErr == ERROR_SUCCESS){
        // Count backwards through the paEventsToPrint array, to order them 
        //  in forward chronological order.
        Assert(paEventsToPrint);
        for(i = cEventsToPrint-1; i >= 0; i--){
            Assert(paEventsToPrint[i]);
            if(pfnPrintEventHandler != NULL){
                pfnPrintEventHandler(pvContext, paEventsToPrint[i]);
            } else {
                GenericPrintEvent(pwszEventLog, paEventsToPrint[i], TRUE);
            }
        }
    }

    // Final Cleanup:
    // Free the events printed list.
    if(paEventsToPrint){
        for(i = 0; i < (INT) cEventsToPrint; i++){
            if(paEventsToPrint[i]){
                LocalFree(paEventsToPrint[i]);
            } else {
                Assert(!"cEventsToPrint doesn't agree with number of pointers"
                       " in the array paEventsToPrint[]");
            }
        }
        if(paEventsToPrint) {
            LocalFree(paEventsToPrint);
        }
    }


    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\common\list.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    list.c

ABSTRACT:

    Generic List function.

DETAILS:

CREATED:

    28 Jun 99   Brett Shirley (brettsh)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <dsconfig.h>


#include "dcdiag.h"
#include "repl.h"


// Yeah Yeah, don't even talk to me about this, it is horrible I know.
PDC_DIAG_DSINFO  gpDsInfoHackForQSort = NULL;


DWORD
IHT_PrintListError(
    DWORD                               dwErr
    )
/*++

Description:

    This prints out an error from a "pure" list function (described below in 
    IHT_GetServerList()).

Parameters:
    dwErr is optional, if it is ERROR_SUCCESS, then we use a memory error.

Return Value:
    A win32 err, the value of the error we used.
  
  --*/
{
    if(dwErr == ERROR_SUCCESS){
        dwErr = GetLastError();
        if(dwErr == ERROR_SUCCESS){
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    PrintMsg(SEV_ALWAYS, DCDIAG_UTIL_LIST_GENERIC_LIST_ERROR,
             Win32ErrToString(dwErr));
    return(dwErr);
}

VOID
IHT_PrintServerList(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    )
/*++

Description:

    Prints the server list.

Parameters:

    pDsInfo,
    piServers - a list of servers.
  
  --*/
{
    ULONG                               ii;
    
    PrintIndentAdj(1);
    if(piServers == NULL){
        PrintMsg(SEV_VERBOSE, DCDIAG_UTIL_LIST_PRINTING_NULL_LIST);
        return;
    }
    for(ii = 0; piServers[ii] != NO_SERVER; ii++){
        PrintMsg(SEV_ALWAYS, DCDIAG_UTIL_LIST_SERVER,
                     pDsInfo->pServers[piServers[ii]].pszName);
    }
    if(ii == 0){
        PrintMsg(SEV_ALWAYS, DCDIAG_UTIL_LIST_SERVER_LIST_EMPTY);
    }
    PrintIndentAdj(-1);

}

PULONG
IHT_GetServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    )
/*++

Description:

    This function gets a list of indexs into the pDsInfo->pServers array of all
    the servers in the enterprise.

Parameters:

    pDsInfo.

Return Value:
  
    This is a "pure" list function, in that it returns NULL, or a memory 
    address.  If it returns NULL, then GetLastError() should have the error, 
    even if another pure list function was called in the mean time.  If not it
    is almost certainly a memory error, as this is the only thing that can go
    wrong in pure list functions.  The pure list functions return a NO_SERVER
    terminated list.  The function always returns the pointer to the list.  
    Note most of the list functions modify one of the lists they are passed 
    and passes back that pointer, so if you want the original contents, make
    a copy with IHT_CopyServerList().

  --*/
{
    ULONG                               ii;
    PULONG                              piServers;

    piServers = LocalAlloc(LMEM_FIXED, 
                           sizeof(ULONG) * (pDsInfo->ulNumServers + 1));
    if(piServers == NULL){
        return(NULL);
    }

    for(ii = 0; ii < pDsInfo->ulNumServers; ii++){
        piServers[ii] = ii;
    }
    piServers[ii] = NO_SERVER;

    return(piServers);
}

PULONG
IHT_GetEmptyServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    )
/*++

Description:

    This function returns a list large enough to fit the entire enterprise 
    worth of servers, and has a NO_SERVER as the first element, indicating it
    is empty.

Parameters:

    pDsInfo.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                               ii;
    PULONG                              piServers;

    piServers = LocalAlloc(LMEM_FIXED, 
                           sizeof(ULONG) * (pDsInfo->ulNumServers + 1));
    if(piServers == NULL){
        return(NULL);
    }
    
    piServers[0] = NO_SERVER;

    return(piServers);
}

BOOL
IHT_ServerIsInServerList(
    PULONG                              piServers,
    ULONG                               iTarget
    )
/*++

Description:

    This is a predicate to determine if the server represented by iTarget is 
    contained in the server list piServers.

Parameters:

    pDsInfo.
    iTarget ... the server to look for.

Return Value:
  
    TRUE if iTarget is in piServers, FALSE otherwise.

  --*/
{
    ULONG                               ii;

    if(iTarget == NO_SERVER){
        return(FALSE);
    }

    for(ii = 0; piServers[ii] != NO_SERVER; ii++){
        if(piServers[ii] == iTarget){
            return(TRUE);
        }
    }
    return(FALSE);
}

PULONG
IHT_AddToServerList(
    PULONG                             piServers,
    ULONG                              iTarget
    )
/*++

Description:

    This function returns takes an existing list and if iTarget isn't already
    in that list, it adds iTarget to the end of the list, and NO_SERVER terminates it.

Parameters:

    pDsInfo.
    iTarget ... server to add to list.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                              ii;

    if(piServers == NULL || iTarget == NO_SERVER){
        return NULL;
    }

    for(ii = 0; piServers[ii] != NO_SERVER; ii++){
        if(piServers[ii] == iTarget){
            // shoot already is in list, don't add it again.
            return(piServers);
        }
    }
    
    piServers[ii] = iTarget;
    ii++;
    piServers[ii] = NO_SERVER;
    return(piServers);    
}

PULONG
IHT_TrimServerListBySite(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iSite,
    PULONG                              piServers
    )
/*++

Description:

    This takes a list, and removes any servers that are not in iSite.

Parameters:

    pDsInfo.
    iSite .... site to check for servers are in.
    piServers .... list of servers to trim.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                               ii, iiTarget;
    PULONG                              piTemp;

    piTemp = LocalAlloc(LMEM_FIXED, 
                        sizeof(ULONG) * (pDsInfo->ulNumServers + 1));
    if(piServers == NULL || piTemp == NULL){
        return NULL;
    }

    iiTarget = 0;
    for(ii = 0; piServers[ii] != NO_SERVER; ii++){
        if(pDsInfo->pServers[piServers[ii]].iSite == iSite){
            piTemp[iiTarget] = piServers[ii];
            iiTarget++;
        }
    }

    piTemp[iiTarget] = NO_SERVER;
    memcpy(piServers, piTemp, sizeof(ULONG) * (iiTarget+1));
    LocalFree(piTemp);

    return(piServers);
}

PULONG
IHT_TrimServerListByNC(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iNC,
    BOOL                                bDoMasters,
    BOOL                                bDoPartials,
    PULONG                              piServers
    )
/*++

Description:

    Similar to TrimServerListByNC, except this removes all servers
    the given NC.

Parameters:

    pDsInfo.
    iNC .... NC to check that the servers have.
    bDoMasters ... to check for master NCs.
    bDoPartials ... to check for partial NCs.
    piServers .... list of servers to trim.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                               ii, iiTarget;
    PULONG                              piTemp;

    piTemp = LocalAlloc(LMEM_FIXED, 
                        sizeof(ULONG) * (pDsInfo->ulNumServers + 1));
    if(piServers == NULL || piTemp == NULL){
        return(NULL);
    }

    iiTarget = 0;
    for(ii = 0; piServers[ii] != NO_SERVER; ii++){
        if(DcDiagHasNC(pDsInfo->pNCs[iNC].pszDn, 
                          &(pDsInfo->pServers[piServers[ii]]), 
                          bDoMasters, bDoPartials)){
            piTemp[iiTarget] = piServers[ii];
            iiTarget++;
        }
    }
    piTemp[iiTarget] = NO_SERVER;
    memcpy(piServers, piTemp, sizeof(ULONG) * (iiTarget+1));
    LocalFree(piTemp);

    return(piServers);
}


PULONG
IHT_AndServerLists(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc1,
    IN      PULONG                      piSrc2
    )
/*++

Description:

    This function takes two lists piSrc1 and piSrc2 and ANDs them 
    together and puts them in piSrc1.  What I mean by AND, is that
    if a server index is in piSrc1 AND piSrc2, then it gets to 
    remain in piSrc1
    // IHT_AndServerLists(x, y) -> x = x & y;

Parameters:

    pDsInfo.
    piSrc1 ... The source and destinations list
    piSrc2 ... The second source list.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{

    ULONG                               iiSrc1, iiSrc2, cDstSize;
    PULONG                              piDst;
    
    piDst = IHT_GetEmptyServerList(pDsInfo);

    if(piSrc1 == NULL || piSrc2 == NULL || piDst == NULL){
        return(NULL);
    }

    for(iiSrc1 = 0; piSrc1[iiSrc1] != NO_SERVER; iiSrc1++){
        for(iiSrc2 = 0; piSrc2[iiSrc2] != NO_SERVER; iiSrc2++){
            if(piSrc1[iiSrc1] == piSrc2[iiSrc2]){
                // we have a match.
                IHT_AddToServerList(piDst, piSrc1[iiSrc1]);
            }
        }
    }

    for(cDstSize = 0; piDst[cDstSize] != NO_SERVER; cDstSize++){
        ; // note ';' just getting size.
    }
    memcpy(piSrc1, piDst, sizeof(ULONG) * (cDstSize+1));
    LocalFree(piDst);
    
    return(piSrc1);
}

PULONG
IHT_CopyServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      PULONG                      piSrc
    )
/*++

Description:

    Since most of these list operations "corrupt" the data they use, this
    function is used to make a copy.

Parameters:

    pDsInfo.
    piSrc1 ... list to make copy of.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                               ii;
    PULONG                              piServers = NULL;

    piServers = IHT_GetEmptyServerList(pDsInfo);

    if(piSrc == NULL || piServers == NULL){
        return(NULL);
    }

    for(ii = 0; piSrc[ii] != NO_SERVER; ii++){
        piServers[ii] = piSrc[ii];
    }
    piServers[ii] = NO_SERVER;

    return(piServers);
}

PULONG
IHT_NotServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc
    )
/*++

Description:

    Like the AND function, this simply NOTs a list.  So take all the
    servers in the enterprise, and then remove the servers in piSrc.
    // IHT_AndServerLists(x) -> x = !x;

Parameters:

    pDsInfo.
    piSrc1 ... list to not and return.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                               ii, iiDst;
    PULONG                              piDst;
    
    piDst = IHT_GetEmptyServerList(pDsInfo);

    if(piSrc == NULL || piDst == NULL){
        return(NULL);
    }
    
    iiDst = 0;
    for(ii = 0; ii < pDsInfo->ulNumServers; ii++){
        if(!IHT_ServerIsInServerList(piSrc, ii)){
            piDst[iiDst] = ii;
            iiDst++;
        }
    }

    piDst[iiDst] = NO_SERVER;
    memcpy(piSrc, piDst, sizeof(ULONG) * (iiDst+1));
    LocalFree(piDst);
    
    return(piSrc);
}

INT __cdecl
IHT_IndexedGuidCompare(
    const void *                        elem1,
    const void *                        elem2
    )
/*++

Description:

    This function is used as the comparison for qsort in the function
    IHT_OrderServerListByGuid().

Parameters:

    elem1 - This is the first element and is a pointer to a GUID
    elem2 - This is the second element and is a pointer to a GUID also.

Return Value:
  


  --*/
{
    return(memcmp(&gpDsInfoHackForQSort->pServers[*((INT*)elem1)].uuid,
                  &gpDsInfoHackForQSort->pServers[*((INT*)elem2)].uuid,
                  sizeof(UUID)));
}


PULONG
IHT_OrderServerListByGuid(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    )
/*++

Description:

    This simply takes the piServers list and orders them by GUID.

Parameters:

    pDsInfo ... this is how we get at the GUIDs.
    piServers ... the list to order by GUIDs.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    // THis function orders the servers by Guid.
    ULONG                               cSize;

    if(piServers == NULL){
        return NULL;
    }

    gpDsInfoHackForQSort = pDsInfo;

    // get number of servers ... note semicolon at end.
    for(cSize=0; piServers[cSize] != NO_SERVER; cSize++); 

    // need global hack to do this used gpDsInfoHackForQSort above.
    qsort(piServers, cSize, sizeof(*piServers), IHT_IndexedGuidCompare); 

    // make sure qsort didn't run over bounds or something.
    Assert(piServers[cSize] == NO_SERVER); 
    return(piServers);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\common\nccache.c ===
/*++

Copyright (c) 2001 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dcdiag/common/dscache.c

ABSTRACT:

    This is the caching and access functions for the DC_DIAG_NCINFO and 
    DC_DIAG_CRINFO caching structures that hang off the main DSINFO cache
    from dscache.c

DETAILS:

CREATED:

    09/04/2001    Brett Shirley (brettsh)
    
        Pulled the caching functions from dcdiag\common\main.c

REVISION HISTORY:


--*/

#include <ntdspch.h>
#include <objids.h>

#include "dcdiag.h"

#include "ndnc.h"
#include "utils.h"
#include "ldaputil.h"

#ifdef DBG
extern BOOL  gDsInfo_NcList_Initialized;
#endif

extern  SEC_WINNT_AUTH_IDENTITY_W * gpCreds;

PVOID
CopyAndAllocWStr(
    WCHAR * pszOrig 
    )
/*++
    
    Obviously the function LocalAlloc()s memory and copies the string
    into that memory.  Failure to alloc results in a NULL being returned
    instead of a pointer to the new memory.  Presumes pszOrig string is
    NULL terminated.
    
--*/
{
    ULONG   cbOrig;
    WCHAR * pszNew = NULL;
    if (pszOrig == NULL){
        return(NULL);
    }
    cbOrig = (wcslen(pszOrig) + 1) * sizeof(WCHAR);
    pszNew = LocalAlloc(LMEM_FIXED, cbOrig);
    DcDiagChkNull(pszNew);
    memcpy(pszNew, pszOrig, cbOrig);
    return(pszNew);
}

void
DcDiagFillBlankCrInfo(
    PDC_DIAG_CRINFO                     pCrInfo
    )
/*++

Routine Description:

    Creates a basic blank pCrInfo.  In order to fill a blank pCrInfo,
    we must always use this function, so the pCrInfo data structures
    are always in an expected format.
    
Arguments:

    pCrInfo - A pointer to the info to fill in.

--*/
{
    
    // This sets pszSourceServer, pszDn, pszDnsRoot to NULL,
    // bEnabled to FALSE. and ulSystemFlags to 0.
    memset(pCrInfo, 0, sizeof(DC_DIAG_CRINFO));

    pCrInfo->dwFlags = CRINFO_DATA_NO_CR;
    pCrInfo->iSourceServer = -1;

    pCrInfo->cReplicas = -1;
    pCrInfo->aszReplicas = NULL;
}

void
DcDiagFillNcInfo(
    PDC_DIAG_DSINFO                     pDsInfo,
    LPWSTR                              pszNC,
    PDC_DIAG_NCINFO                     pNcInfo
    )
/*++

Routine Description:

    This fills and NcInfo and it's aCrInfo structure so it meets the
    minimum requirements of a data structure of this type.  Namely
    the pszDn and pszName must be filled in and there must be one
    array slot in aCrInfo filled by DcDiagFillBlankCrInfo().
    
Arguments:

    pDsInfo -
    pszNC - The string NC DN.
    pNcInfo - Pointer to the NcInfo structure to fill.

Return Value:

    Throws exception if it can't allocate memory.

--*/
{
    LPWSTR *                            ppTemp = NULL;

    // pszDn field
    pNcInfo->pszDn = CopyAndAllocWStr(pszNC);

    // pszName field
    ppTemp = ldap_explode_dnW(pNcInfo->pszDn, TRUE);
    DcDiagChkNull(ppTemp);
    pNcInfo->pszName = LocalAlloc(LMEM_FIXED,
                          sizeof(WCHAR) * (wcslen(ppTemp[0]) + 2));
    DcDiagChkNull(pNcInfo->pszName);
    wcscpy(pNcInfo->pszName, ppTemp[0]);
    ldap_value_freeW(ppTemp);

    // fill first aCrInfo slot
    pNcInfo->aCrInfo = LocalAlloc(LMEM_FIXED, sizeof(DC_DIAG_CRINFO));
    DcDiagChkNull(pNcInfo->aCrInfo);
    pNcInfo->cCrInfo = 1;
    
    DcDiagFillBlankCrInfo(&(pNcInfo->aCrInfo[0]));
    pNcInfo->aCrInfo[0].dwFlags |= CRINFO_SOURCE_HOME;

}

void
DcDiagPullLdapCrInfo(
    LDAP *                              hld,
    PDC_DIAG_DSINFO                     pDsInfo,
    LDAPMessage *                       pldmEntry,
    DWORD                               dwDataFlags,
    DC_DIAG_CRINFO *                    pCrInfo
    )
/*++

Routine Description:

    This function takes a LDAPMessage (pldmEntry) and pulls from it 
    all the relevant data according to the dwDataFlags and puts them
    in the pCrInfo.
    
Arguments:

    hld - LDAP handle associated with pldmEntry
    pDsInfo -
    pldmEntry - LDAPMessage * pointing at the CR we want to pull info from.
    dwDataFlags - The type of data we want to pull from the CR:
        CRINFO_DATA_BASIC | CRINFO_DATA_EXTENDED | CRINFO_DATA_REPLICAS
    pCrInfo - The CrInfo structure to fill with the data we pulled from 
        the pldmEntry.

Return Value:

    Throws exception if it can't allocate memory.

--*/
{
    LPWSTR                     pszCrDn = NULL;
    LPWSTR *                   ppszSystemFlags = NULL;
    LPWSTR *                   ppszEnabled = NULL;
    LPWSTR *                   ppszDnsRoot = NULL;
    LPWSTR *                   ppszWhenCreated = NULL;
    LPWSTR *                   ppszSDReferenceDomain = NULL;
    LPWSTR *                   ppszReplicas = NULL;
    LPWSTR *                   ppszNetBiosName = NULL;

    DWORD                      dwRet;
    SYSTEMTIME                 systemTime;
    BOOL                       bEnabled;
    ULONG                      ulSysFlags = 0;
    LONG                       i = -1;
    ULONG                      iTemp;

    Assert(pCrInfo);

    if(dwDataFlags & CRINFO_DATA_BASIC){

        if ((pszCrDn = ldap_get_dn(hld, pldmEntry)) == NULL){
            DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
        }

        if ((ppszDnsRoot = ldap_get_valuesW (hld, pldmEntry, L"dNSRoot")) == NULL){
            DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
        }

        // This attribute might be NULL, such as in the case of a pre-created CR.
        ppszSystemFlags = ldap_get_valuesW (hld, pldmEntry, L"systemFlags");
        if(ppszSystemFlags){
            ulSysFlags = atoi((LPSTR) ppszSystemFlags[0]);
        } else {
            ulSysFlags = 0;
        }

        // This attribute might be NULL.
        ppszEnabled = ldap_get_valuesW (hld, pldmEntry, L"enabled");
        if(ppszEnabled == NULL ||
           _wcsicmp(L"TRUE", ppszEnabled[0]) == 0){
            bEnabled = TRUE;
        } else {
            bEnabled = FALSE;
        }

        Assert(pszCrDn);
        Assert(ppszDnsRoot && ppszDnsRoot[0]);

        // Write the basic CRINFO structure
        //
        // Update flags to indicate basic data is present.
        pCrInfo->dwFlags = (pCrInfo->dwFlags & ~CRINFO_DATA_NO_CR) | CRINFO_DATA_BASIC;
        // Fill in the CRINFO_DATA_BASIC fields.
        pCrInfo->pszDn = CopyAndAllocWStr(pszCrDn);
        pCrInfo->ulSystemFlags = ulSysFlags;
        pCrInfo->pszDnsRoot = CopyAndAllocWStr(ppszDnsRoot[0]);
        pCrInfo->bEnabled = bEnabled;
    
    }
    
    // Fill in additional types of data if requested.
    if (dwDataFlags & CRINFO_DATA_EXTENDED) {

        ppszWhenCreated = ldap_get_valuesW (hld, pldmEntry, L"whenCreated");
        
        if ( (ppszWhenCreated) && (ppszWhenCreated[0]) ) {

            dwRet = DcDiagGeneralizedTimeToSystemTime((LPWSTR) ppszWhenCreated[0], &systemTime);
            if(dwRet == ERROR_SUCCESS){
                SystemTimeToFileTime(&systemTime, &(pCrInfo->ftWhenCreated) );
            } else {
                (*(LONGLONG*)&pCrInfo->ftWhenCreated) = (LONGLONG) 0;
            }
        }
        if(ppszWhenCreated){
            ldap_value_freeW (ppszWhenCreated);
        }
        
        ppszSDReferenceDomain = ldap_get_valuesW (hld, pldmEntry, L"msDS-SDReferenceDomain");
        if (ppszSDReferenceDomain != NULL && ppszSDReferenceDomain[0] != NULL) {
            pCrInfo->pszSDReferenceDomain = CopyAndAllocWStr(ppszSDReferenceDomain[0]);
        }

        ppszNetBiosName = ldap_get_valuesW (hld, pldmEntry, L"nETBIOSName");
        if (ppszNetBiosName != NULL && ppszNetBiosName[0] != NULL) {
            pCrInfo->pszNetBiosName = CopyAndAllocWStr(ppszNetBiosName[0]);
        }

        // Add the extended flags are set data.
        pCrInfo->dwFlags = (pCrInfo->dwFlags & ~CRINFO_DATA_NO_CR) | CRINFO_DATA_EXTENDED;
    }

    if (dwDataFlags & CRINFO_DATA_REPLICAS) {

        // Fill blank replica set for now.
        pCrInfo->cReplicas = 0;
        pCrInfo->aszReplicas = NULL;
        
        // Get the values.
        ppszReplicas = ldap_get_valuesW (hld, pldmEntry, L"msDS-NC-Replica-Locations");
        if (ppszReplicas != NULL) {

            for (iTemp = 0; ppszReplicas[iTemp]; iTemp++) {
                ; // Do nothing counting replicas.
            }
            pCrInfo->cReplicas = iTemp;
            pCrInfo->aszReplicas = ppszReplicas;
        } else {
            pCrInfo->cReplicas = 0;
            pCrInfo->aszReplicas = NULL;
        }

        // Add the replicas flags are set data.
        pCrInfo->dwFlags = (pCrInfo->dwFlags & ~CRINFO_DATA_NO_CR) | CRINFO_DATA_REPLICAS;
    }

    ldap_memfree(pszCrDn);
    ldap_value_freeW (ppszSystemFlags);
    ldap_value_freeW (ppszEnabled);
    ldap_value_freeW (ppszDnsRoot);
    ldap_value_freeW (ppszSDReferenceDomain);
    ldap_value_freeW (ppszNetBiosName);

}

#define   DcDiagCrInfoCleanUp(p)    if (p) { LocalFree(p); p = NULL; }

DWORD
DcDiagRetrieveCrInfo(
    IN   PDC_DIAG_DSINFO                     pDsInfo,
    IN   LONG                                iNC,
    IN   LDAP *                              hld,
    IN   DWORD                               dwFlags,
    OUT  PDWORD                              pdwError,
    OUT  PDC_DIAG_CRINFO                     pCrInfo
    )
/*++

Routine Description:

    This is a Helper function to DcDiagGetCrossRefInfo(), this function
    will retrieve from LDAP any information requested per the dwFlags.  
    Puts LDAP errors encountered in *pdwError.
    
Arguments:
                                
    pDsInfo -
    iNC - index of the NC in pDsInfo->pNCs[iNC].
    hld - LDAP handle of server to query against.
    dwFlags - Specified what data to retrieve.
    pdwError - Return variable for LDAP errors.
    pCrInfo - The CrInfo to fill in with the data we retrieve.

Return Value:

    Returns a CRINFO_RETURN_*, and if it returns a CRINFO_RETURN_LDAP_ERROR
    then *pdwError will be set with the LDAP error that caused our failure.

--*/
{
    PDC_DIAG_NCINFO     pNcInfo = &pDsInfo->pNCs[iNC];
    LONG                iTemp;
    WCHAR *             pszCrDn = NULL;
    WCHAR *             pszPartitions = NULL;
    WCHAR *             pszFilter = NULL;
    ULONG               cFilter = 0;
    BOOL                fLocalBinding = FALSE;
    LDAPMessage *       pldmResults = NULL;
    LDAPMessage *       pldmEntry;
    // Code.Improvement - It'd be nice to generate this list of
    // attribute per the DATA flags passed in.
    LPWSTR              ppszBasicAttrs [] = {
                            L"nCName",
                            L"systemFlags",
                            L"enabled",
                            L"dNSRoot",
                            L"whenCreated",
                            L"msDS-SDReferenceDomain",
                            L"nETBIOSName",
                            NULL, // optionally saved space for "msDS-NC-Replica-Locations"
                            NULL 
                        };

    Assert(gDsInfo_NcList_Initialized);

    Assert(pCrInfo);
    Assert(pdwError);

    if (dwFlags & CRINFO_DATA_REPLICAS) {
        for (iTemp = 0; ppszBasicAttrs[iTemp] != NULL; iTemp++) {
            ; // Do nothing, just want end of array.
        }
        ppszBasicAttrs[iTemp] = L"msDS-NC-Replica-Locations";
    }

    pszCrDn = NULL;
    for(iTemp = 0; iTemp < pNcInfo->cCrInfo; iTemp++){
        if(CRINFO_DATA_BASIC & pNcInfo->aCrInfo[iTemp].dwFlags){
            pszCrDn = pNcInfo->aCrInfo[iTemp].pszDn;
            break;
        }
    }


    if(pszCrDn != NULL){

        *pdwError = ldap_search_sW(hld, 
                                   pszCrDn,
                                   LDAP_SCOPE_BASE,
                                   L"(objectCategory=*)",
                                   ppszBasicAttrs,
                                   FALSE, 
                                   &pldmResults);
        if(*pdwError == LDAP_NO_SUCH_OBJECT){
            if (pldmResults) {
                ldap_msgfree(pldmResults);
            }
            return(CRINFO_RETURN_NO_CROSS_REF);
        }
        if(*pdwError){
            if (pldmResults) {
                ldap_msgfree(pldmResults);
            }
            return(CRINFO_RETURN_LDAP_ERROR);
        }

    } else {

        // Surprising ... we'll we're going to have to do this the hard way.
        *pdwError = GetPartitionsDN(hld, &pszPartitions);
        if(*pdwError){
            return(CRINFO_RETURN_LDAP_ERROR);
        }
        
        cFilter = wcslen(pDsInfo->pNCs[iNC].pszDn) + wcslen(L"(nCName=  )") + 1;
        if(cFilter >= 512){
            // wsprintf() can only handle 1024 bytes, so that seems like a 
            // reasonable limit.
            DcDiagException(ERROR_INVALID_PARAMETER);
        }
        pszFilter = LocalAlloc(LMEM_FIXED, cFilter * sizeof(WCHAR));
        DcDiagChkNull(pszFilter);
        wsprintf(pszFilter, L"(nCName=%ws)", pDsInfo->pNCs[iNC].pszDn);

        *pdwError = ldap_search_sW(hld, 
                                   pszPartitions,
                                   LDAP_SCOPE_ONELEVEL,
                                   pszFilter,
                                   ppszBasicAttrs,
                                   FALSE, 
                                   &pldmResults);
        DcDiagCrInfoCleanUp(pszPartitions);
        DcDiagCrInfoCleanUp(pszFilter);
        if(*pdwError == LDAP_NO_SUCH_OBJECT){
            if (pldmResults) {
                ldap_msgfree(pldmResults);
            }
            return(CRINFO_RETURN_NO_CROSS_REF);
        }
        if(*pdwError){
            if (pldmResults) {
                ldap_msgfree(pldmResults);
            }
            return(CRINFO_RETURN_LDAP_ERROR);
        }
    
    }

    pldmEntry = ldap_first_entry(hld, pldmResults);
    if(pldmEntry == NULL){
        if (pldmResults) {
            ldap_msgfree(pldmResults);
        }
        return(CRINFO_RETURN_NO_CROSS_REF);
    }

    DcDiagPullLdapCrInfo(hld,
                         pDsInfo,
                         pldmEntry,
                         dwFlags & CRINFO_DATA_ALL,
                         pCrInfo);

    // 
    // Hack, pull off some more info, because we want the GUID and SID,
    // and it's annoying to make an extended search for the whole thing.
    //
    if (dwFlags & CRINFO_DATA_EXTENDED) {
        if (pszCrDn == NULL) {
            pszCrDn = ldap_get_dnW(hld, pldmEntry);
            DcDiagChkNull(pszCrDn);
        }

        // Code.Improvement: this isn't the best approach in that it 
        // incurs another round trip ldap call, but it was deemed easier
        // and more maintainable, than the fact that all DNs would've 
        // come back in this new format, and so we'd have to special
        // case things like the SD Reference Domain, and the next person
        // to add a DN attribute, would get confused when regular DNs
        // don't come back.
        *pdwError = LdapFillGuidAndSid(hld, pszCrDn, L"nCName", &(pCrInfo->pdnNcName));
        if (*pdwError == LDAP_NO_SUCH_OBJECT) {
            return(CRINFO_RETURN_NO_CROSS_REF);
        }
        if (*pdwError) {
            return(CRINFO_RETURN_LDAP_ERROR);
        }
    }

    if (pldmResults) {
        ldap_msgfree(pldmResults);
    }
    return(CRINFO_RETURN_SUCCESS);
}

BOOL
ServerIsDomainNamingFsmo(
    IN   PDC_DIAG_DSINFO                     pDsInfo,
    IN   LONG                                iServer,
    IN   LDAP *                              hld
    )
/*++

Routine Description:

    This routine takes a server by both a index in pDsInfo->pServersiServer
    or an LDAP handle and returns TRUE if we can verify that this server
    is the Domain Naming FSMO.
        
Arguments:
                                
    pDsInfo - need for the list of servers
    iServer - index to a server
    hld - LDAP handle to a given server

Return Value:

    TRUE if we positively verified that this server is the Domain Naming
    FSMO.  FALSE if we encountered any errors or verified this server is
    not the Domain Naming FSMO.

--*/
{
    WCHAR *    pszDomNameFsmoDn = NULL;
    WCHAR *    pszNtdsDsaDn = NULL;
    DWORD      dwErr;
    BOOL       bRet;

    // Under the right conditions we can use iServer and 
    // pDsInfo->iDomainNamingFsmo to quickly determine if we're talking
    // to the Domain Naming FSMO.
    if ((iServer != -1) &&
        (pDsInfo->iDomainNamingFsmo != -1) &&
        iServer == pDsInfo->iDomainNamingFsmo ) {
        return(TRUE);
    }

    // Else we need to go off machine to figure out.
    bRet = (0 == GetDomainNamingFsmoDn(hld, &pszDomNameFsmoDn)) &&
           (0 == GetRootAttr(hld, L"dsServiceName", &pszNtdsDsaDn)) &&
           (0 == _wcsicmp(pszDomNameFsmoDn, pszNtdsDsaDn));

    if (pszDomNameFsmoDn) {
        LocalFree(pszDomNameFsmoDn);
    }
    if (pszNtdsDsaDn) {
        LocalFree(pszNtdsDsaDn);
    }

    return(bRet);
}

DWORD
DcDiagGetCrInfoBinding(
    IN   PDC_DIAG_DSINFO                     pDsInfo,
    IN   LONG                                iNC,
    IN   DWORD                               dwFlags,
    OUT  LDAP **                             phld,
    OUT  PBOOL                               pfFreeHld,
    OUT  PDWORD                              pdwError,
    IN OUT PDC_DIAG_CRINFO                   pCrInfo
    )
/*++

Routine Description:

    This routine is a helper function for DcDiagGetCrossRefInfo(), and
    binds to a server and sets certain fields in pCrInfo on behalf of
    that function.
    
    We use dwFlags to determines which server we should bind to, to 
    fufill the client's request.  Will be one of (see below):
        CRINFO_SOURCE_HOME | CRINFO_SOURCE_FSMO | CRINFO_SOURCE_FIRST
    
    It tries to pull a server from dcdiag's binding handle cache first,
    but if it fails to it will return a new LDAP handle along with
    setting pfFreeHld to TRUE.
    
    We also since we have all the information set the following fields
    on pCrInfo:
        dwFlags
        iSourceServer
        pszSourceServer
    
    Finally, we may have the side effect of updating some global pDsInfo
    cache of which server is the Domain Naming FSMO.
        
Arguments:
                                
    pDsInfo - 
    iNC - index of the NC.
    dwFlags - Which server to bind to
        CRINFO_SOURCE_HOME - Use the pDsInfo->ulHomeServer
        CRINFO_SOURCE_FSMO - Use the Domain Naming FSMO server.
        CRINFO_SOURCE_FIRST - Use the first replica server.
    phld - The LDAP * we'll return
    pfFreeHld - Whether to free the LDAP * we got.
    pdwError - Any LDAP errors we encountered if the return value is
        CRINFO_RETURN_LDAP_ERROR.
    pCrInfo - The CrInfo structure to fill in the Flags and source
        server fields of.

Return Value:

    Returns a CRINFO_RETURN_*.

--*/
{
    DWORD                 dwRet = ERROR_SUCCESS;

    // By the end of this function one of these two will be defined,
    // but not both.
    LONG                  iSourceServer = -1;
    WCHAR *               pszSourceServer = NULL;
    LDAP *                hld = NULL;

    LONG                  iCrVer = -1;
    WCHAR *               pszDnsTemp = NULL;

    Assert(phld);
    Assert(pfFreeHld);
    Assert(pdwError);
    Assert(pCrInfo);
    Assert(dwFlags & CRINFO_RETRIEVE_IF_NEC);

    *phld = NULL;
    *pfFreeHld = FALSE;
    *pdwError = ERROR_SUCCESS;

    Assert(gDsInfo_NcList_Initialized);
    
    // pCrInfo->dwFlags & CRINFO_SOURCE_BASIC
    // pCrInfo->iSourceServer ||
    // pCrInfo->pszSourceServer 

    // There's two cases here: 
    //   1) we've already cached some information for the source server
    //      we want in pCrInfo (if iSourceServer or pszSourceServer are
    //      valid) 
    //   2) This is a fresh pCrInfo, meaning nothing cached must go find
    //      the right binding and set the pCrInfo->dwFlags.
    //
    // In case (1) we want to try to pull a cached LDAP binding if 
    // possible (iSourceServer set), and we know we don't have to worry
    // about scope, because we already tried to pull the information
    // before.
    //
    // In case (2) we do have to worry that we don't travel outside the
    // users specified scope of SERVER|SITE|ENTERPRISE.  If possible 
    // we'd like to cache this LDAP binding also.
    // 

    if (pCrInfo->iSourceServer != -1){

        // Handle is probably already cached.
        iSourceServer = pCrInfo->iSourceServer;
        Assert((ULONG) iSourceServer < pDsInfo->ulNumServers);
        *pdwError = DcDiagGetLdapBinding(&pDsInfo->pServers[iSourceServer],
                                         gpCreds, FALSE, &hld);
        if(*pdwError || hld == NULL){
            Assert(*pdwError);
            Assert(hld == NULL);
            return(CRINFO_RETURN_LDAP_ERROR);
        }

    } else if (pCrInfo->pszSourceServer != NULL) {

        if (dwFlags & CRINFO_SOURCE_FSMO) {
            
            // We've got a special caching function for the Domain Naming
            // FSMO as we expect to be talking to it alot.
            *pdwError = DcDiagGetDomainNamingFsmoLdapBinding(pDsInfo,
                                                             gpCreds,
                                                             &iSourceServer,
                                                             &pszSourceServer,
                                                             &hld);
            if(*pdwError || hld == NULL){
                Assert(*pdwError);
                Assert(hld == NULL);
                return(CRINFO_RETURN_LDAP_ERROR);
            }
            Assert( (iSourceServer != -1) || (pszSourceServer != NULL) );
            Assert( (iSourceServer == -1) || (pszSourceServer == NULL) );
       
        } else {
           
           // Most likely we want to talk to a First replica of an NDNC
           // where the server specified wasn't cached in pDsInfo->pServers.

           // This means that the server for this cross-ref isn't in
           // the pDsInfo->pServers cache, so we've got to just refer to
           // it by name.
           pszSourceServer = pCrInfo->pszSourceServer;
           Assert(pszSourceServer);
           hld = GetNdncLdapBinding(pszSourceServer, pdwError, FALSE, gpCreds);
           if (hld == NULL || *pdwError) {
               // Darn error binding to source server.
               Assert(*pdwError);
               Assert(hld == NULL);
               return(CRINFO_RETURN_LDAP_ERROR);
           }
           *pfFreeHld = TRUE;

       }


    } else {

        //
        // Must find the right DC to bind to ...
        //
        // AND must set the pCrInfo->dwFlags first.
        //
        Assert(hld == NULL);

        if (dwFlags & CRINFO_SOURCE_FSMO) {

            pCrInfo->dwFlags = CRINFO_SOURCE_FSMO;

            if ((pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_SITE) ||
                (pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_ENTERPRISE)){
                
                *pdwError = DcDiagGetDomainNamingFsmoLdapBinding(pDsInfo,
                                                                 gpCreds,
                                                                 &iSourceServer,
                                                                 &pszSourceServer,
                                                                 &hld);
                if(*pdwError || hld == NULL){
                    Assert(*pdwError);
                    Assert(hld == NULL);
                    return(CRINFO_RETURN_LDAP_ERROR);
                }
                Assert( (iSourceServer != -1) || (pszSourceServer != NULL) );
                Assert( (iSourceServer == -1) || (pszSourceServer == NULL) );

            } else {

                // In this case we bound to only one server, our only hope 
                // is that one server _is_ the FSMO.  Check that now.
                hld = pDsInfo->hld;
                if (ServerIsDomainNamingFsmo(pDsInfo, pDsInfo->ulHomeServer, hld)) {
                    iSourceServer = pDsInfo->ulHomeServer;
                    pCrInfo->dwFlags |= CRINFO_SOURCE_HOME;
                } else {
                    return(CRINFO_RETURN_OUT_OF_SCOPE);
                }

            }

            Assert(hld);

        } else if (dwFlags & CRINFO_SOURCE_FIRST) {

            pCrInfo->dwFlags = CRINFO_SOURCE_FIRST;
            
            dwRet = DcDiagGetCrossRefInfo(pDsInfo,
                                          iNC,
                                    // Preserve only the retrive flag from client
                                          ((dwFlags & CRINFO_RETRIEVE_IF_NEC) 
                                           | CRINFO_SOURCE_FSMO 
                                           | CRINFO_DATA_BASIC),
                                          &iCrVer,
                                          pdwError);
            if (dwRet) {
                // pdwError was set by call.
                return(dwRet);
            }
            Assert(iCrVer != -1);

            dwRet = GetDnsFromDn(pDsInfo->pNCs[iNC].pszDn, &pszDnsTemp);
            if (dwRet || (pszDnsTemp == NULL) ||
                (_wcsicmp(pszDnsTemp, pDsInfo->pNCs[iNC].aCrInfo[iCrVer].pszDnsRoot) == 0) ||
                pDsInfo->pNCs[iNC].aCrInfo[iCrVer].bEnabled) {
                // We've got a CR that either can't have a first replica, or
                // in some way is already enabled and we can't tell who the
                // first replica was.
                DcDiagCrInfoCleanUp(pszDnsTemp);
                return(CRINFO_RETURN_FIRST_UNDEFINED);
            }
            DcDiagCrInfoCleanUp(pszDnsTemp);
            
            // If we've gotten here, the first replica is defined and it's
            // in the pDsInfo->pNCs[iNC].aCrInfo[iCrVer[.pszDnsRoot.

            iSourceServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, NULL,
                               pDsInfo->pNCs[iNC].aCrInfo[iCrVer].pszDnsRoot,
                                               NULL);
            if(iSourceServer == -1){
                // There is no server to represent this yet.
                
                pszSourceServer = pDsInfo->pNCs[iNC].aCrInfo[iCrVer].pszDnsRoot;
                Assert(pszSourceServer);
                hld = GetNdncLdapBinding(pszSourceServer, pdwError, FALSE, gpCreds);
                if(hld == NULL || *pdwError){
                    Assert(*pdwError);
                    Assert(hld == NULL);
                    return(CRINFO_RETURN_LDAP_ERROR);
                }
                *pfFreeHld = TRUE;

            } else {
                
                *pdwError = DcDiagGetLdapBinding(&pDsInfo->pServers[iSourceServer],
                                                 gpCreds, 
                                                 FALSE,
                                                 &hld);
                if(*pdwError || hld == NULL){
                    Assert(*pdwError);
                    Assert(hld == NULL);
                    return(CRINFO_RETURN_LDAP_ERROR);
                }
            }

        } else {
            Assert(dwFlags & CRINFO_SOURCE_HOME);
            
            // Just use home server.  Easy!  ;)
            pCrInfo->dwFlags = CRINFO_SOURCE_HOME;
            iSourceServer = pDsInfo->ulHomeServer;
            hld = pDsInfo->hld;
        }

    }
    Assert( hld );
    Assert( (iSourceServer != -1) || (pszSourceServer != NULL) );
    Assert( (iSourceServer == -1) || (pszSourceServer == NULL) );

    // OK, so we could have a situation where the HOME, FSMO, and FIRST
    // DC's are all the same DC.  So we can easily figure that out here
    // and probably/possibly save ourselves some repeat queries.
    if (!(pCrInfo->dwFlags & CRINFO_SOURCE_HOME) &&
        iSourceServer == pDsInfo->ulHomeServer) {
        pCrInfo->dwFlags |= CRINFO_SOURCE_HOME;
    }
    
    if (!(pCrInfo->dwFlags & CRINFO_SOURCE_FSMO) &&
        ServerIsDomainNamingFsmo(pDsInfo, iSourceServer, hld)) {
        pCrInfo->dwFlags |= CRINFO_SOURCE_FSMO;
    }
    // We can't really test for and set CRINFO_SOURCE_FIRST, because it'd
    // involve calling DcDiagGetCrossRefinfo(), which would start endless
    // recursion.  It's OK though not to set this however.  It just means
    // that we'll incure an extra lookup into the AD if we're later asked
    // for CRINFO_SOURCE_FIRST and we already had the info from that server.


    *phld = hld;
    pCrInfo->iSourceServer = iSourceServer;
    pCrInfo->pszSourceServer = pszSourceServer;

    return(CRINFO_RETURN_SUCCESS);
}

void
DcDiagMergeCrInfo(
    IN   PDC_DIAG_CRINFO                   pNewCrInfo,
    OUT  PDC_DIAG_CRINFO                   pOldCrInfo
    )
/*++

Routine Description:

    This routine safely merges the new information from pNewCrInfo into
    the old information contained in pOldCrInfo.  This is the one of only
    two ways to actually change the aCrInfo caches, the other is happens
    during the DcDiagGatherInfo() stage (in DcDiagGenerateNCsListCrossRefInfo
    more specifically).
        
Arguments:

    pNewCrInfo - New CR information to use.
    pOldCrInfo - Old CrInformation that gets the new data.

--*/
{
    FILETIME   ft = { 0 };                  

#define MergeCrInfoUpdate(var, blank)     if (pOldCrInfo->var == blank) { \
                                              pOldCrInfo->var = pNewCrInfo->var; \
                                          }
#define MergeCrInfoUpdateFree(var, blank) if (pOldCrInfo->var == blank) { \
                                              pOldCrInfo->var = pNewCrInfo->var; \
                                          } else { \
                                              if (pNewCrInfo->var) { \
                                                  LocalFree(pNewCrInfo->var); \
                                              } \
                                          }

    Assert(gDsInfo_NcList_Initialized);

    Assert( (pNewCrInfo->iSourceServer != -1) || (pNewCrInfo->pszSourceServer != NULL) );
    Assert( (pNewCrInfo->iSourceServer == -1) || (pNewCrInfo->pszSourceServer == NULL) );

    // Set the flags, but elminating the empty entry flag
    pOldCrInfo->dwFlags = (pOldCrInfo->dwFlags & ~CRINFO_DATA_NO_CR) | pNewCrInfo->dwFlags;
    MergeCrInfoUpdate(iSourceServer, -1);
    MergeCrInfoUpdateFree(pszSourceServer, NULL);
    MergeCrInfoUpdateFree(pszDn, NULL);
    MergeCrInfoUpdateFree(pszDnsRoot, NULL);
    MergeCrInfoUpdate(ulSystemFlags, 0);
    MergeCrInfoUpdate(bEnabled, FALSE);
    MergeCrInfoUpdateFree(pszSDReferenceDomain, NULL);
    MergeCrInfoUpdateFree(pszNetBiosName, NULL);
    MergeCrInfoUpdateFree(pdnNcName, NULL);
    if( memcmp(&ft, &pOldCrInfo->ftWhenCreated, sizeof(FILETIME)) == 0 ) {
        memcpy(&pOldCrInfo->ftWhenCreated, &pNewCrInfo->ftWhenCreated, sizeof(FILETIME));
    }   
    MergeCrInfoUpdate(cReplicas, -1);
    MergeCrInfoUpdateFree(aszReplicas, NULL);

    Assert( (pOldCrInfo->iSourceServer != -1) || (pOldCrInfo->pszSourceServer != NULL) );
    Assert( (pOldCrInfo->iSourceServer == -1) || (pOldCrInfo->pszSourceServer == NULL) );
}

DWORD
DcDiagGetCrossRefInfo(
    IN OUT PDC_DIAG_DSINFO                     pDsInfo,
    IN     DWORD                               iNC,
    IN     DWORD                               dwFlags,
    OUT    PLONG                               piCrVer,
    OUT    PDWORD                              pdwError
    )
/*++

Routine Description:

    This is the function for all that ails you.  It's a little complicated but
    it's designed to retrieve all cross-ref info you could possibly need. Simply
    specify the iNC you're interested in, and the dwFlags you want and we'll
    set the *piCrVer you've got.

Arguments:

    pDsInfo - This is listed as an IN & OUT param, because the pNCs cache
        in this structure maybe updated in the process of getting the info
        if the CRINFO_RETREIVE_IF_NEC flag is specified.
    iNC - The index of the NC we're interested in the CR info of.
    dwFlags - Specify one and only one of the CRINFO_SOURCE_* constants, as
        many of the CRINFO_DATA_* constants as you're interested in, and the
        CRINFO_RETRIEVE_IF_NEC flag if you want us to go outside of our cache
        to get any information we're missing.
    piCrVer - The index of the CR info that we found with all the information
        asked for and from the right source.
    pdwError - An additional piece of error information, namely a potential
        LDAP error.  Shouldn't be set unless we returned 
        CRINFO_RETURN_LDAP_ERROR.

Return Value:

    returns one of these values:
        CRINFO_RETURN_SUCCESS - Everything is successful, you should have the 
            fields you want in the *piCrVer provided
        CRINFO_RETURN_OUT_OF_SCOPE - Given our current scope rules, we'd have
            to break the scope rules to get the info you requested. 
        CRINFO_RETURN_LDAP_ERROR - Error is in *pdwError
        CRINFO_BAD_PROGRAMMER - An assertable condition, you're calling the
            function incorrectly.
        CRINFO_RETURN_FIRST_UNDEFINED - CRINFO_SOURCE_FIRST is only defined when
            bEnabled is FALSE on the CR on the Domain Naming FSMO, and the
            dNSRoot attribute points to the first replica server.
        CRINFO_RETURN_NEED_TO_RETRIEVE - We didn't have the information locally
            cached, you need to specify CRINFO_RETRIEVE_IF_NEC to tell us to
            go get the info via LDAP.


--*/
{
    PDC_DIAG_NCINFO     pNcInfo = &pDsInfo->pNCs[iNC];
    PDC_DIAG_CRINFO     pCrInfo = NULL;
    LONG                iCrVer = -1;
    LONG                iFsmoCrVer = -1, iFirstCrVer = -1;
    BOOL                fNoCr = FALSE;
    DWORD               dwRet;
    LDAP *              hld = NULL;
    BOOL                fFreeHld = FALSE;


    Assert(gDsInfo_NcList_Initialized);

    //
    // 1) Validation of parameters
    //
    Assert(piCrVer);
    Assert(pdwError);
    Assert(pNcInfo->aCrInfo && pNcInfo->cCrInfo); // Should always be 1 entry.

    Assert(iNC < pDsInfo->cNumNCs);

    if((dwFlags & CRINFO_SOURCE_OTHER)){
        // Code.Improvement this is not implemented yet, but will need to be.
        Assert(!"Not Implemented yet!");
        return(CRINFO_RETURN_BAD_PROGRAMMER);
    }

    *pdwError = 0;
    *piCrVer = -1;
    

    //
    // 2) Decompile the CRINFO_SOURCE_AUTHORITATIVE into it's logic.
    //
    if(dwFlags & CRINFO_SOURCE_AUTHORITATIVE){
        
        //
        // We've consilidated the admittedly simple logic on where the 
        // "authoritative" cross-ref info is to this clause.
        //

        //
        // The cross-ref is always the most authoritative information unless ...
        //
        dwRet = DcDiagGetCrossRefInfo(pDsInfo,
                                      iNC,
                                      ((dwFlags & ~CRINFO_SOURCE_ALL)
                                       | CRINFO_SOURCE_FSMO
                                       | CRINFO_DATA_BASIC),
                                      &iFsmoCrVer,
                                      pdwError);
        if(dwRet){
            // pdwError should be set by the call
            return(dwRet);
        }

        //
        // ... unless the cross-ref is disabled, and then the first replica
        // is the most authoritative information.
        //
        if(!pNcInfo->aCrInfo[iFsmoCrVer].bEnabled){
            // Uh-oh we really want the first replica ... 
            dwRet = DcDiagGetCrossRefInfo(pDsInfo,
                                          iNC,
                                          ((dwFlags & ~CRINFO_SOURCE_ALL)
                                           | CRINFO_SOURCE_FIRST
                                           | CRINFO_DATA_BASIC),
                                          &iFirstCrVer,
                                          pdwError);
            if (dwRet == CRINFO_RETURN_NO_CROSS_REF) {
                //
                // Success FSMO CR is the most authoritative.
                //
                // In this case the cross-ref hasn't replicated to
                // the first replica yet, so then the version from
                // the Domain Naming FSMO actually is the most/only
                // authoritative version.
                *piCrVer = iFsmoCrVer;
                *pdwError = ERROR_SUCCESS;
                return(CRINFO_RETURN_SUCCESS);
            } else if (dwRet){
                // pdwError should be set by the call.
                return(dwRet);
            } else {
                //
                // Success First Replica CR is the most authoritative.
                //
                *piCrVer = iFirstCrVer;
                *pdwError = ERROR_SUCCESS;
                return(dwRet);
            }
        } else {
            //
            // Success FSMO CR is the most authoritative.
            //
            *piCrVer = iFsmoCrVer;
            *pdwError = ERROR_SUCCESS;
            return(dwRet);
        }
        Assert(!"Uh-oh bad programmer should never get down here!");

    }
    Assert(!(dwFlags & CRINFO_SOURCE_AUTHORITATIVE));


    //
    // 3) Validate that we have the data the user wants ...
    //

    //
    // Simply validate we've got the right info and from the right source.
    //
    for(iCrVer = 0; iCrVer < pNcInfo->cCrInfo; iCrVer++){
        pCrInfo = &pNcInfo->aCrInfo[iCrVer];
        
        //
        // Make sure we have the right source if specified.
        //
        // Since
        //    dwFlags & CRINFO_SOURCE_AUTHORITATIVE was taken care of above.
        //    and if (dwFlags & CRINFO_SOURCE_ANY) then all iCrVer's match
        // Then we only need to worry about the basic types: HOME, FSMO, FIRST, OTHER.
        if((dwFlags & CRINFO_SOURCE_ALL_BASIC) &&
           !(dwFlags & CRINFO_SOURCE_ALL_BASIC & pCrInfo->dwFlags)){
            continue; // Try next CR.
        }

        // 
        // Make sure we have the information the caller asked for.  Must be first.
        //
        if(pCrInfo->dwFlags & CRINFO_DATA_NO_CR){
            fNoCr = TRUE;
            if (dwFlags & CRINFO_SOURCE_ANY) {
                // We don't care about which source so try the next source.
                continue;
            }
        }
        if(dwFlags & CRINFO_DATA_BASIC &&
           !(pCrInfo->dwFlags & CRINFO_DATA_BASIC)){
            continue; // Try next CR.
        }
        if(dwFlags & CRINFO_DATA_EXTENDED &&
           !(pCrInfo->dwFlags & CRINFO_DATA_EXTENDED)){
            continue; // Try next CR.
        }
        if(dwFlags & CRINFO_DATA_REPLICAS &&
           !(pCrInfo->dwFlags & CRINFO_DATA_REPLICAS)){
            continue; // Try next CR.
        }

        //
        // Success. Yeah!
        //
        Assert(iCrVer != pNcInfo->cCrInfo);
        break;
    }

    if (iCrVer == pNcInfo->cCrInfo) {
        if(fNoCr){
            return(CRINFO_RETURN_NO_CROSS_REF);
        }
    }

    //
    // 4) If we've got the info return it.
    //
    //    /--------------------------------------------|
    //    / NOTE THIS IS THE ONLY TRUE SUCCESS BRANCH! |
    //    /--------------------------------------------/
    //    All recursion will end in here in an "apparent" cache
    //    hit or will simply error out.
    //
    if(iCrVer != pNcInfo->cCrInfo){
        *pdwError = ERROR_SUCCESS;
        *piCrVer = iCrVer;
        
        // Just to make sure we've got valid success return params
        Assert(*pdwError == ERROR_SUCCESS);
        Assert(*piCrVer != -1 && *piCrVer != pNcInfo->cCrInfo);
        return(CRINFO_RETURN_SUCCESS);
    }

    // 
    // 5) OK, we don't have the right info, but have we been told
    //    to go get the info if missing?
    //
    if (!(dwFlags & CRINFO_RETRIEVE_IF_NEC)) {
        // Uh-oh we didn't have the information available to us and they
        // didn't ask us to retrieve it if necessary, so we'll bail.
        if((dwFlags & CRINFO_SOURCE_ANY) ||
           (dwFlags & CRINFO_SOURCE_HOME)){
            // If we asked for ANY | HOME source and we got here we've no 
            // info about this CR period.
            return(CRINFO_RETURN_NO_CROSS_REF);
        }
        return(CRINFO_RETURN_NEED_TO_RETRIEVE);
    }

    __try {

        //
        // 6) Need to know if we're updating an already existing piece of
        //    cached info or creating whole new data.
        //
        for(iCrVer = 0; iCrVer < pNcInfo->cCrInfo; iCrVer++){
            if(dwFlags & CRINFO_SOURCE_ALL_BASIC & pNcInfo->aCrInfo[iCrVer].dwFlags){
                break;
            }
        }

        pCrInfo = LocalAlloc(LMEM_FIXED, sizeof(DC_DIAG_CRINFO));
        DcDiagChkNull(pCrInfo);

        if (iCrVer == pNcInfo->cCrInfo) {

            // iCrVer == pNcInfo->cCrInfo means we don't have anything cached ...
            Assert(iCrVer == pNcInfo->cCrInfo);
            DcDiagFillBlankCrInfo(pCrInfo);

        } else {

            // we found a cached structure for, make a copy
            Assert(iCrVer != pNcInfo->cCrInfo);
            memcpy(pCrInfo, &pNcInfo->aCrInfo[iCrVer], sizeof(DC_DIAG_CRINFO));

        }

        // pCrInfo is a copy, and after we're done collecting all the data we
        // want, we update the cache with all the information we've accumulated 
        // in pCrInfo.  iCrVer tells us whether we should put this infromation
        // when we're done.

        // 
        // 7) We've been told to go get the info.  So figure out which 
        //    server we want to bind to first.  Harder than it sounds.
        //
        if(dwFlags & CRINFO_SOURCE_ANY){
            // Just use the home server if we've been requested info from any source.
            dwFlags = (dwFlags & ~CRINFO_SOURCE_ALL) | CRINFO_SOURCE_HOME;
        }
        // We should have a basic type of source at this point FSMO, HOME, or FIRST.
        Assert(!(dwFlags & CRINFO_SOURCE_AUTHORITATIVE) &&
               !(dwFlags & CRINFO_SOURCE_ANY) &&
               (dwFlags & CRINFO_SOURCE_ALL_BASIC));

        //
        // Helper function that returns a CRINFO_RETURN_* and gives us an
        // LDAP binding to the right server.
        //
        dwRet = DcDiagGetCrInfoBinding(pDsInfo,
                                       iNC,
                                       dwFlags,
                                       &hld,
                                       &fFreeHld,
                                       pdwError,
                                       pCrInfo);
        if (dwRet){
            __leave;
        }

        // At least one basic source should be set.
        Assert(pCrInfo->dwFlags & CRINFO_SOURCE_ALL_BASIC);
        Assert(hld);
        Assert((pCrInfo->iSourceServer != -1) || (pCrInfo->pszSourceServer != NULL));
        Assert((pCrInfo->iSourceServer == -1) || (pCrInfo->pszSourceServer == NULL));

        // Since DcDiagGetCrInfoBinding() could've added SOURCE_* flags
        // other than the primary source we have to research the existing
        // CRINFO's for a matching source, because it could turn out that
        // for instance SOURCE_HOME & )FSMO & _FIRST are all the same
        // server and then we only have to cache the information once!!
        for(iCrVer = 0; iCrVer < pNcInfo->cCrInfo; iCrVer++){
            if(pCrInfo->dwFlags & CRINFO_SOURCE_ALL_BASIC & pNcInfo->aCrInfo[iCrVer].dwFlags){
                break;
            }
        }
        
        //
        // 8) Now, we need to actually retrieve the info from the server.
        //

        //
        // Helper function that returns a CRINFO_RETURN_* and fills in
        // most of the fields of pCrInfo via querying LDAP.
        //
        dwRet = DcDiagRetrieveCrInfo(pDsInfo,
                                    iNC,
                                    hld,
                                    dwFlags,
                                    pdwError,
                                    pCrInfo);
        if (dwRet){
            __leave;
        }

        // Some sort of data should have been set in DcDiagRetrieveCrInfo().
        Assert(pCrInfo->dwFlags & CRINFO_DATA_ALL);


        //
        // 9) GREAT!  Now we must merge this new info into the existing
        //    array of CRINFOs.
        //

        if(iCrVer == pNcInfo->cCrInfo){

            // First create a blank CR info on the last position in the array.
            pDsInfo->pNCs[iNC].aCrInfo = GrowArrayBy(pDsInfo->pNCs[iNC].aCrInfo,
                                                     1,
                                                     sizeof(DC_DIAG_CRINFO));
            DcDiagChkNull(pDsInfo->pNCs[iNC].aCrInfo);
            iCrVer = pDsInfo->pNCs[iNC].cCrInfo;
            pDsInfo->pNCs[iNC].cCrInfo++;
            DcDiagFillBlankCrInfo(&pDsInfo->pNCs[iNC].aCrInfo[iCrVer]);

        }

        DcDiagMergeCrInfo(pCrInfo,
                          &(pNcInfo->aCrInfo[iCrVer]));

    } __finally {
        if (pCrInfo) {
            LocalFree(pCrInfo);
        }
        if (fFreeHld && hld){
            ldap_unbind(hld);
        }

    }

    if (dwRet){
        // pdwError should be set if necessary.
        Assert(dwRet != CRINFO_RETURN_LDAP_ERROR || *pdwError);
        return(dwRet);
    }

    // 
    // 10) Re-Validate that we _now_ have the data the user wants
    //
    
    // Once, we've gotten the information we recursively call ourselves
    // to validate the information we've gotten, and to determine if we
    // need to retrieve more information for the CRINFO_SOURCE_AUTHORITATIVE
    // flag.
    dwRet = DcDiagGetCrossRefInfo(pDsInfo,
                                  iNC,
                                  // Now what we need should be cached!
                                  dwFlags & ~CRINFO_RETRIEVE_IF_NEC, 
                                  piCrVer,
                                  pdwError);
    
    return(dwRet);
}

ULONG
DcDiagGetCrSystemFlags(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iNc
    )
/*++

Routine Description:

    This routine gets the system flags for the caller, first trying the CR
    cache and 2nd going off to the Domain Naming FSMO if necessary.
        
Arguments:
                                
    pDsInfo - 
    iNC - index of the NC.

Return Value:

    If we've got an error we return 0, otherwise we return the "systemFlags"
    attribute whatever they may be.

--*/
{
    ULONG                               iCr, dwError, dwRet;
    
    Assert(gDsInfo_NcList_Initialized);
    Assert(pDsInfo->pNCs[iNc].aCrInfo);

    if (pDsInfo->pNCs[iNc].aCrInfo[0].dwFlags & CRINFO_DATA_BASIC) {
        // Basic data is valid, return system flags
        return(pDsInfo->pNCs[iNc].aCrInfo[0].ulSystemFlags);
    } 
    
    // Very very rare case that we've got a blank CRINFO structure, because
    // the original home server didn't have the CR.
    dwRet = DcDiagGetCrossRefInfo(pDsInfo,
                                  iNc,
                                  (CRINFO_SOURCE_FSMO | CRINFO_RETRIEVE_IF_NEC | CRINFO_DATA_BASIC),
                                  &iCr,
                                  &dwError);
    if(dwRet){
        // If we error we're going to have to pretend there are no system flags.
        return(0);
    }
    Assert(iCr != -1);

    return(pDsInfo->pNCs[iNc].aCrInfo[iCr].ulSystemFlags);
}

ULONG
DcDiagGetCrEnabled(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iNc
    )
/*++

Routine Description:

    This routine gets the enabled status of this CR, first trying the
    CR cache and 2nd going off to the Domain Naming FSMO if necessary.
        
Arguments:
                                
    pDsInfo - 
    iNC - index of the NC.

Return Value:

    If there was an error we return FALSE, otherwise we return the 
    "enabled" attribute if the attribute was present, and TRUE if
    the attribute was not present on the CR.  Not present is the
    same as enabled in this context.

--*/
{
    ULONG                               iCr, dwError, dwRet;
    
    Assert(gDsInfo_NcList_Initialized);
    Assert(pDsInfo->pNCs[iNc].aCrInfo);

    if (pDsInfo->pNCs[iNc].aCrInfo[0].dwFlags & CRINFO_DATA_BASIC) {
        // Basic data is valid, return system flags
        return(pDsInfo->pNCs[iNc].aCrInfo[0].bEnabled);
    } 
    
    // Very very rare case that we've got a blank CRINFO structure, because
    // the original home server didn't have the CR.
    dwRet = DcDiagGetCrossRefInfo(pDsInfo,
                                  iNc,
                                  (CRINFO_SOURCE_FSMO | CRINFO_RETRIEVE_IF_NEC | CRINFO_DATA_BASIC),
                                  &iCr,
                                  &dwError);
    if(dwRet){
        // If we error we're going to have to pretend it's not enabled.
        return(FALSE);
    }
    Assert(iCr != -1);

    return(pDsInfo->pNCs[iNc].aCrInfo[iCr].bEnabled);
}

DWORD
DcDiagGenerateNCsListCrossRefInfo(
    PDC_DIAG_DSINFO                     pDsInfo,
    LDAP *                              hld
    )
/*++

Routine Description:

    This fills in the cross ref related info for the NC lists.  This is
    basically a boot strapping function for the CR cache.  When this 
    function finishes, every NC in pDsInfo->pNCs must have a aCrInfo 
    array of at least 1 entry allocated and that entry must have valid
    data or the dwFlags set to CRINFO_SOURCE_HOME | CRINFO_DATA_NO_CR if
    we couldn't find any CR data for the NC.

    Code.Improvement - It would be a major code improvement in some ways
    to either also or just to query the Domain Naming Master if within
    scope, as the Domain Naming Masters info is the usually the most 
    authoritative with respect to cross-refs.

Arguments:

    pDsInfo - hold the nc info to match the cross ref to and the location
    to store such info
	
    hld - the ldap binding to read cross ref info from

Return Value:

    Win32 error value	

--*/
{
    LPWSTR  ppszCrossRefSearch [] = {
        L"nCName",
        L"systemFlags",
        L"enabled",
        L"dNSRoot",
        NULL 
    };
    LDAPSearch *               pSearch = NULL;
    ULONG                      ulTotalEstimate = 0;
    DWORD                      dwLdapErr;
    LDAPMessage *              pldmResult = NULL;
    LDAPMessage *              pldmEntry = NULL;
    ULONG                      ulCount = 0;
    LPWSTR *                   ppszNCDn = NULL;
    PDC_DIAG_CRINFO            pCrInfo = NULL;
    LONG                       iNc;

    Assert(!gDsInfo_NcList_Initialized);

    PrintMessage(SEV_VERBOSE, L"* Identifying all NC cross-refs.\n");

    pSearch = ldap_search_init_page(hld,
				    pDsInfo->pszConfigNc,
				    LDAP_SCOPE_SUBTREE,
				    L"(objectCategory=crossRef)",
				    ppszCrossRefSearch,
				    FALSE,
				    NULL,    // ServerControls
				    NULL,    // ClientControls
				    0,       // PageTimeLimit
				    0,       // TotalSizeLimit
				    NULL);   // sort key

    if(pSearch == NULL){
        dwLdapErr = LdapGetLastError();
        DcDiagException(LdapMapErrorToWin32(dwLdapErr));
    }

    dwLdapErr = ldap_get_next_page_s(hld,
				     pSearch,
				     0,
				     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
				     &ulTotalEstimate,
				     &pldmResult); 
    if(dwLdapErr != LDAP_SUCCESS){
        DcDiagException(LdapMapErrorToWin32(dwLdapErr));
    }

    while(dwLdapErr == LDAP_SUCCESS) {

        pldmEntry = ldap_first_entry (hld, pldmResult);

        for (; pldmEntry != NULL; ulCount++) {
            
            // Must always have the nCName
            if ((ppszNCDn = ldap_get_valuesW (hld, pldmEntry, L"nCName")) == NULL){
                DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
            }
            
            iNc = DcDiagGetMemberOfNCList(*ppszNCDn,
                        pDsInfo->pNCs, 
                        pDsInfo->cNumNCs);
            if (iNc == -1) {
                // This means that we found a partition that wasn't instantiated
                // in any the servers we loaded to create our original NC list.
                // So we need to add an NC entry to hang this CRINFO off of.
                pDsInfo->pNCs = GrowArrayBy(pDsInfo->pNCs, 1, sizeof(DC_DIAG_NCINFO));
                DcDiagChkNull(pDsInfo->pNCs);

                DcDiagFillNcInfo(pDsInfo,
                                 *ppszNCDn,
                                 &(pDsInfo->pNCs[pDsInfo->cNumNCs]));

                pDsInfo->cNumNCs++;

                iNc = DcDiagGetMemberOfNCList(*ppszNCDn,
                                            pDsInfo->pNCs, 
                                            pDsInfo->cNumNCs);
                if(iNc == -1){
                    Assert(!"How did this happen, figure out and fix");
                    DcDiagException (ERROR_INVALID_PARAMETER);
                }
            }

            // There should always be a first blank CRINFO entry in the list.
            Assert((pDsInfo->pNCs[iNc].cCrInfo == 1) && 
                   (pDsInfo->pNCs[iNc].aCrInfo != NULL) && 
                   ((pDsInfo->pNCs[iNc].aCrInfo[0].dwFlags & CRINFO_DATA_ALL) == 0));

            pCrInfo = &(pDsInfo->pNCs[iNc].aCrInfo[0]);
            pCrInfo->dwFlags |= CRINFO_SOURCE_HOME;
            pCrInfo->iSourceServer = pDsInfo->ulHomeServer;

            DcDiagPullLdapCrInfo(hld,
                                 pDsInfo,
                                 pldmEntry,
                                 CRINFO_DATA_BASIC,
                                 pCrInfo);

            // Clean up this entry
            ldap_value_freeW (ppszNCDn);
            ppszNCDn = NULL;

            pldmEntry = ldap_next_entry (hld, pldmEntry);
        }
        ldap_msgfree(pldmResult);
        pldmResult = NULL;

        dwLdapErr = ldap_get_next_page_s(hld,
                         pSearch,
                         0,
                         DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                         &ulTotalEstimate,
                         &pldmResult);
    } // end while there are more pages ...

    if(ppszNCDn != NULL){
        ldap_value_freeW (ppszNCDn);
    }
    if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
        DcDiagException(LdapMapErrorToWin32(dwLdapErr));
    }

    return(ERROR_SUCCESS);
}


DWORD
DcDiagGenerateNCsList(
    PDC_DIAG_DSINFO                     pDsInfo,
    LDAP *                              hld
    )
/*++

Routine Description:

    This generates and fills in the pNCs array via pulling all the NCs from
    the servers partial and master replica info.

Arguments:

    pDsInfo - hold the server info that comes in and contains that pNCs array
        on the way out.
	
    hld - the ldap binding to read nc info from

Return Value:

    Win32 error value ... could only be OUT_OF_MEMORY.

--*/
{
    ULONG                               ul, ulTemp, ulSize, ulRet;
    WCHAR *                             pszSchemaNc = NULL;
    LPWSTR *                            ppszzNCs = NULL;
    LPWSTR *                            ppTemp = NULL;
    PDC_DIAG_SERVERINFO                 pServer = NULL;

    ulSize = 0;

    for(ul = 0; ul < pDsInfo->ulNumServers; ul++){
        pServer = &(pDsInfo->pServers[ul]);
        if(pServer->ppszMasterNCs){
            for(ulTemp = 0; pServer->ppszMasterNCs[ulTemp] != NULL; ulTemp++){
                if(!DcDiagIsMemberOfStringList(pServer->ppszMasterNCs[ulTemp],
                                         ppszzNCs, ulSize)){
                    ulSize++;
                    ppTemp = ppszzNCs;
                    ppszzNCs = LocalAlloc(LMEM_FIXED, sizeof(LPWSTR) * ulSize);
                    if (ppszzNCs == NULL){
                        return(GetLastError());
                    }
                    memcpy(ppszzNCs, ppTemp, sizeof(LPWSTR) * (ulSize-1));
                    ppszzNCs[ulSize-1] = pServer->ppszMasterNCs[ulTemp];
                    if(ppTemp != NULL){
                        LocalFree(ppTemp);
                    }
                }
            }
        }
    }

    pDsInfo->pNCs = LocalAlloc(LMEM_FIXED, sizeof(DC_DIAG_NCINFO) * ulSize);
    if(pDsInfo->pNCs == NULL){
        return(GetLastError());
    }

    pDsInfo->iConfigNc = -1;
    pDsInfo->iSchemaNc = -1;
    Assert(pDsInfo->pszConfigNc);
    ulRet = GetRootAttr(hld, L"schemaNamingContext", &pszSchemaNc);
    if (ulRet){
        DcDiagException(ERROR_INVALID_PARAMETER);
    }
    Assert(pszSchemaNc);

    for(ul=0; ul < ulSize; ul++){
        Assert(ppszzNCs[ul] != NULL); // just a sanity check for self.

        DcDiagFillNcInfo(pDsInfo,
                         ppszzNCs[ul],
                         &(pDsInfo->pNCs[ul]));

        // Set the schema NC index
        if (_wcsicmp(pDsInfo->pszConfigNc, pDsInfo->pNCs[ul].pszDn) == 0) {
            pDsInfo->iConfigNc = ul;
        }

        // Set the config NC index
        if (_wcsicmp(pszSchemaNc, pDsInfo->pNCs[ul].pszDn) == 0) {
            pDsInfo->iSchemaNc = ul;
        }

    }
    pDsInfo->cNumNCs = ulSize;
    LocalFree(ppszzNCs);
    LocalFree(pszSchemaNc);
    if ( (pDsInfo->iConfigNc == -1) || (pDsInfo->iSchemaNc == -1) ) {
        Assert(!"What happened such that we didn't retrieve our config/schema NCs!?");
        DcDiagException(ERROR_INVALID_PARAMETER);
    }

    // Retreive and load cross ref info, add any new NCs we learn of from
    // the Partitions container that may not be instantiated on one of the
    // servers we reviewed, and cache various CR info like systemFlags,
    // and whether the CR is enabled, etc.
    DcDiagGenerateNCsListCrossRefInfo(pDsInfo, hld);

#if DBG
    gDsInfo_NcList_Initialized = TRUE;
#endif 

    return(ERROR_SUCCESS);
}


BOOL
fIsOldCrossRef(
    PDC_DIAG_CRINFO   pCrInfo,
    LONGLONG          llThreshold
    )
/*++

Description:

    This tells whether the cross-ref is older (was created before) than 
    the threshold.

Parameters:

    pCrInfo - A CRINFO structure with a filled in ftWhenCreated.
    llThreshold - How old is old.

Return Value:

    BOOL - TRUE if created before llThreshold ago, FALSE if not.

--*/
{
    SYSTEMTIME  systemTime;
    FILETIME    ftCurrent;
    LONGLONG    llCurrent, llCreated, llOldness;

    Assert((pCrInfo->dwFlags & CRINFO_DATA_EXTENDED) && "pCrInfo doesn't have ftWhenCreated initialized");
    GetSystemTime( &systemTime );
    SystemTimeToFileTime( &systemTime,  &ftCurrent );
    memcpy(&llCurrent, &ftCurrent, sizeof(LONGLONG));
    memcpy(&llCreated, &pCrInfo->ftWhenCreated, sizeof(LONGLONG));
    if(llCreated != 0){
        llOldness = llCurrent - llCreated;
    } else {
        Assert(!"The user probably wanted to call this with a pCrInfo with ftWhenCreated initialized");
        llOldness = 0;
    }

    return(llOldness > llThreshold);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\common\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dcdiag/common/main.c

ABSTRACT:

    Stand-alone application that calls several routines
    to test whether or not the DS is functioning properly.

DETAILS:

CREATED:

    09 Jul 98    Aaron Siegel (t-asiege)

REVISION HISTORY:

    01/26/1999    Brett Shirley (brettsh)

        Add support for command line credentials, explicitly specified NC's on the command line.

    08/21/1999   Dmitry Dukat (dmitrydu)

        Added support for test specific command line args

--*/
//#define DBG  0

#include <ntdspch.h>
#include <ntdsa.h>
#include <winsock2.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmapibuf.h> // NetApiBufferFree
#include <ntdsa.h>    // options
#include <wincon.h>
#include <winbase.h>
#include <dnsapi.h>
#include <locale.h>
#include <dsrole.h>  // for DsRoleGetPrimaryDomainInformation()

#define INCLUDE_ALLTESTS_DEFINITION
#include "dcdiag.h"
#include "repl.h"
#include "ldaputil.h"
#include "utils.h"
#include "ndnc.h"
#define DS_CON_LIB_CRT_VERSION
#include "dsconlib.h"
          

// Some global variables -------------------------------------------------------
    DC_DIAG_MAININFO        gMainInfo;

    // Global credentials.
    SEC_WINNT_AUTH_IDENTITY_W   gCreds = { 0 };
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds = NULL;

    ULONG ulSevToPrint = SEV_NORMAL;

// Some function declarations --------------------------------------------------
    VOID DcDiagMain (
        LPWSTR                      pszHomeServer,
        LPWSTR                      pszNC,
        ULONG                       ulFlags,
        LPWSTR *                    ppszOmitTests,
        SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
        WCHAR                     * ppszExtraCommandLineArgs[]
        );

    INT PreProcessGlobalParams(
        INT * pargc,
        LPWSTR** pargv
        );
    INT GetPassword(
        WCHAR * pwszBuf,
        DWORD cchBufMax,
        DWORD * pcchBufUsed
        );

    VOID PrintHelpScreen();

LPWSTR
findServerForDomain(
    LPWSTR pszDomainDn
    );

LPWSTR
findDefaultServer(BOOL fMustBeDC);

LPWSTR
convertDomainNcToDn(
    LPWSTR pwzIncomingDomainNc
    );

void DcDiagPrintCommandLine(int argc, LPWSTR * argv);

void
DoNonDcTests(
    LPWSTR pwzComputer,
    ULONG ulFlags,
    LPWSTR * ppszDoTests,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    WCHAR * ppszExtraCommandLineArgs[]);

/*++




--*/


INT __cdecl
wmain (
    INT                argc,
    LPWSTR *           argv,
    LPWSTR *           envp
    )
{
    static const LPWSTR pszInvalidCmdLine =
        L"Invalid command line; dcdiag.exe /h for help.\n";
    LPWSTR             pszHomeServer = NULL;
    LPWSTR             pszNC = NULL;
    LPWSTR             ppszOmitTests[DC_DIAG_ID_FINISHED+2];
    LPWSTR             ppszDoTests[DC_DIAG_ID_FINISHED+2];
    ULONG              ulFlags = 0L;

    ULONG              ulTest = 0L;
    ULONG              ulOmissionAt = 0L;
    ULONG              ulTestAt = 0L;
    ULONG              iTest = 0;
    ULONG              iDoTest = 0;
    INT                i = 0;
    INT                iTestArg = 0;
    INT                iArg;
    INT                iPos;
    BOOL               bDoNextFlag = FALSE;
    BOOL               bFound =FALSE;
    LPWSTR             pszTemp = NULL;
    BOOL               bComprehensiveTests = FALSE;
    WCHAR              *ppszExtraCommandLineArgs[MAX_NUM_OF_ARGS];
    BOOL               fNcMustBeFreed = FALSE;
    BOOL               fNonDcTests = FALSE;
    BOOL               fDcTests = FALSE;
    BOOL               fFound = FALSE;
    HANDLE                          hConsole = NULL;
    CONSOLE_SCREEN_BUFFER_INFO      ConInfo;

    // Sets the locale properly and initializes DsConLib
    DsConLibInit();

    //set the Commandlineargs all to NULL
    for(i=0;i<MAX_NUM_OF_ARGS;i++)
        ppszExtraCommandLineArgs[i]=NULL;

    // Initialize output package
    gMainInfo.streamOut = stdout;
    gMainInfo.streamErr = stderr;
    gMainInfo.ulSevToPrint = SEV_NORMAL;
    gMainInfo.iCurrIndent = 0;
    if(hConsole = GetStdHandle(STD_OUTPUT_HANDLE)){
        if(GetConsoleScreenBufferInfo(hConsole, &ConInfo)){
            gMainInfo.dwScreenWidth = ConInfo.dwSize.X;
        } else {
            gMainInfo.dwScreenWidth = 80;
        }
    } else {
        gMainInfo.dwScreenWidth = 80;
    }

    // Parse commandline arguments.
    PreProcessGlobalParams(&argc, &argv);

    for (iArg = 1; iArg < argc ; iArg++)
    {
        bFound = FALSE;
        if (*argv[iArg] == L'-')
        {
            *argv[iArg] = L'/';
        }
        if (*argv[iArg] != L'/')
        {
            // wprintf (L"Invalid Syntax: Use dcdiag.exe /h for help.\n");
            PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_BAD_OPTION, argv[iArg]);
            return -1;
        }
        else if (_wcsnicmp(argv[iArg],L"/f:",wcslen(L"/f:")) == 0)
        {
            pszTemp = &argv[iArg][3];
            if (*pszTemp == L'\0')
            {
                // wprintf(L"Syntax Error: must use /f:<logfile>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_F );
                return -1;
            }
            if((gMainInfo.streamOut = _wfopen (pszTemp, L"a+t")) == NULL){
                // wprintf(L"Could not open %s for writing.\n", pszTemp);
                gMainInfo.streamOut = stdout;
                PrintMsg( SEV_ALWAYS, DCDIAG_OPEN_FAIL_WRITE, pszTemp );
                return(-1);
            }
            if(gMainInfo.streamErr == stderr){
                gMainInfo.streamErr = gMainInfo.streamOut;
            }
        }
        else if (_wcsnicmp(argv[iArg],L"/ferr:",wcslen(L"/ferr:")) == 0)
        {
            pszTemp = &argv[iArg][6];
            if (*pszTemp == L'\0')
            {
                // wprintf(L"Syntax Error: must use /ferr:<errorlogfile>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_FERR );
                return -1;
            }
            if((gMainInfo.streamErr = _wfopen (pszTemp, L"a+t")) == NULL){
                // wprintf(L"Could not open %s for writing.\n", pszTemp);
                PrintMsg( SEV_ALWAYS, DCDIAG_OPEN_FAIL_WRITE, pszTemp );
                return(-1);
            }
        }
        else if (_wcsicmp(argv[iArg],L"/h") == 0|| _wcsicmp(argv[iArg],L"/?") == 0)
        {
            PrintHelpScreen();
                    return 0;
        }
        else if (_wcsnicmp(argv[iArg],L"/n:",wcslen(L"/n:")) == 0)
        {
            if (pszNC != NULL) {
                // wprintf(L"Cannot specify more than one naming context.\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_ONLY_ONE_NC );
                return -1;
            }
            pszTemp = &(argv[iArg][3]);
            if (*pszTemp == L'\0')
            {
                // wprintf(L"Syntax Error: must use /n:<naming context>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_N );
                return -1;
            }
            pszNC = pszTemp;
        }
        else if (_wcsnicmp(argv[iArg],L"/s:",wcslen(L"/s:")) == 0)
        {
            if (pszHomeServer != NULL) {
                // wprintf(L"Cannot specify more than one server.\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_ONLY_ONE_SERVER );
                return -1;
            }
            pszTemp = &(argv[iArg][3]);
            if (*pszTemp == L'\0')
            {
                // wprintf(L"Syntax Error: must use /s:<server>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_S );
                return -1;
            }
            pszHomeServer = pszTemp;
        }
        else if (_wcsnicmp(argv[iArg],L"/skip:",wcslen(L"/skip:")) == 0)
        {
            pszTemp = &argv[iArg][6];
            if (*pszTemp == L'\0')
            {
                // wprintf(L"Syntax Error: must use /skip:<test name>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_SKIP );
                return -1;
            }
            ppszOmitTests[ulOmissionAt++] = pszTemp;
        }
        else if (_wcsnicmp(argv[iArg],L"/test:",wcslen(L"/test:")) == 0)
        {
            pszTemp = &argv[iArg][6];
            if (*pszTemp == L'\0')
            {
                //wprintf(L"Syntax Error: must use /test:<test name>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_TEST );
                return -1;
            }
            ppszDoTests[ulTestAt++] = pszTemp;
            //
            // Check whether the test name is valid, and if so if it is a DC
            // test or not.
            //
            for (iTest = 0; allTests[iTest].testId != DC_DIAG_ID_FINISHED; iTest++)
            {
                if (_wcsicmp(allTests[iTest].pszTestName, pszTemp) == 0)
                {
                    fFound = TRUE;
                    if (allTests[iTest].ulTestFlags & NON_DC_TEST)
                    {
                        fNonDcTests = TRUE;
                    }
                    else
                    {
                        fDcTests = TRUE;
                    }
                }
            }
            if (!fFound)
            {
                PrintMsg(SEV_ALWAYS, DCDIAG_INVALID_TEST);
                return -1;
            }
        }
        else if (_wcsicmp(argv[iArg],L"/c") == 0)
        {
            ulTestAt = 0;
            for(iTest = 0; allTests[iTest].testId != DC_DIAG_ID_FINISHED; iTest++){
                ppszDoTests[ulTestAt++] = allTests[iTest].pszTestName;
            }
            bComprehensiveTests = TRUE;
        }
        else if (_wcsicmp(argv[iArg],L"/a") == 0)
        {
            ulFlags |= DC_DIAG_TEST_SCOPE_SITE;
        }
        else if (_wcsicmp(argv[iArg],L"/e") == 0)
        {
            ulFlags |= DC_DIAG_TEST_SCOPE_ENTERPRISE;
        }
        else if (_wcsicmp(argv[iArg],L"/v") == 0)
        {
            gMainInfo.ulSevToPrint = SEV_VERBOSE;
        }
        else if (_wcsicmp(argv[iArg],L"/d") == 0)
        {
            gMainInfo.ulSevToPrint = SEV_DEBUG;
        }
        else if (_wcsicmp(argv[iArg],L"/q") == 0)
        {
            gMainInfo.ulSevToPrint = SEV_ALWAYS;
        }
        else if (_wcsicmp(argv[iArg],L"/i") == 0)
        {
            ulFlags |= DC_DIAG_IGNORE;
        }
        else if (_wcsicmp(argv[iArg],L"/fix") == 0)
        {
            ulFlags |= DC_DIAG_FIX;
        }
        else
        {
            //look for test specific command line options
            for (i=0;clOptions[i] != NULL;i++)
            {
                DWORD Length = wcslen( argv[iArg] );
                if (clOptions[i][wcslen(clOptions[i])-1] == L':')
                {
                    if((_wcsnicmp(argv[iArg], clOptions[i], wcslen(clOptions[i])) == 0))
                    {
                        pszTemp = &argv[iArg][wcslen(clOptions[i])];
                        if (*pszTemp == L'\0')
                        {
                            // wprintf(L"Syntax Error: must use %s<parameter>\n",clOptions[i]);
                            PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_MISSING_PARAM,clOptions[i]);
                            return -1;
                        }
                        bFound = TRUE;
                        ppszExtraCommandLineArgs[iTestArg] = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        wcscpy(ppszExtraCommandLineArgs[iTestArg++], argv[iArg] );
                    }
                }
                else if((_wcsicmp(argv[iArg], clOptions[i]) == 0))
                {
                    bFound = TRUE;
                    ppszExtraCommandLineArgs[iTestArg] = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                    wcscpy(ppszExtraCommandLineArgs[iTestArg++], argv[iArg] );
                }
            }
            if(!bFound)
            {
                // wprintf (L"Invalid switch: %s.  Use dcdiag.exe /h for help.\n", argv[iArg]);
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_BAD_OPTION, argv[iArg]);
                return -1;
            }
        }
    }

    // Prints only in /d (debug) mode, so PSS can see the options the customer used.
    DcDiagPrintCommandLine(argc, argv);

    ppszDoTests[ulTestAt] = NULL;

    if (fNonDcTests)
    {
        if (fDcTests)
        {
            // Can't mix DC and non-DC tests.
            //
            PrintMsg(SEV_ALWAYS, DCDIAG_INVALID_TEST_MIX);
            return -1;
        }

        DoNonDcTests(pszHomeServer, ulFlags, ppszDoTests, gpCreds, ppszExtraCommandLineArgs);

        _fcloseall();
        return 0;
    }

    gMainInfo.ulFlags = ulFlags;
    gMainInfo.lTestAt = -1;
    gMainInfo.iCurrIndent = 0;

    // Make sure that the NC specified is in the proper form
    // Handle netbios and dns forms of the domain
    if (pszNC) {
        pszNC = convertDomainNcToDn( pszNC );
        fNcMustBeFreed = TRUE;
    }

    // Basically this uses ppszDoTests to construct ppszOmitTests as the
    //   inverse of ppszDoTests.
    if(ppszDoTests[0] != NULL && !bComprehensiveTests){
        // This means we are supposed to do only the tests in ppszDoTests, so
        //   we need to invert the tests in DoTests and put it in omit tests.
        ulOmissionAt = 0;
        for(iTest = 0; allTests[iTest].testId != DC_DIAG_ID_FINISHED; iTest++){
            for(iDoTest = 0; ppszDoTests[iDoTest] != NULL; iDoTest++){
                if(_wcsicmp(ppszDoTests[iDoTest], allTests[iTest].pszTestName) == 0){
                    break;
                }
            }
            if(ppszDoTests[iDoTest] == NULL){
                // This means this test (iTest) wasn't found in the do list, so omit.
                ppszOmitTests[ulOmissionAt++] = allTests[iTest].pszTestName;
            }
        }
    } else if(!bComprehensiveTests){
        // This means in addition to whatever was omitted on the command line
        //    we should omit the DO_NOT_RUN_TEST_BY_DEFAULT
        for(iTest = 0; allTests[iTest].testId != DC_DIAG_ID_FINISHED; iTest++){
            if(allTests[iTest].ulTestFlags & DO_NOT_RUN_TEST_BY_DEFAULT){
                if(ulOmissionAt >= DC_DIAG_ID_FINISHED){
                    // wprintf(L"Error: Do not omit tests that are not run by default. \nUse dcdiag /? for those tests\n");
                    PrintMsg( SEV_ALWAYS, DCDIAG_DO_NOT_OMIT_DEFAULT );
                    return(-1);
                }
                ppszOmitTests[ulOmissionAt++] = allTests[iTest].pszTestName;
            }
        }

    }

    ppszOmitTests[ulOmissionAt] = NULL;


    DcDiagMain (pszHomeServer, pszNC, ulFlags, ppszOmitTests, gpCreds, ppszExtraCommandLineArgs);

    _fcloseall ();

    if ( (fNcMustBeFreed) && (pszNC) ) {
        LocalFree( pszNC );
    }

    return 0;
} /* wmain  */


// ===================== Other Functions

VOID
PrintHelpScreen(){
    ULONG                  ulTest;
    //     "============================80 char ruler======================================="
    static const LPWSTR    pszHelpScreen =
        L"\n"
        DC_DIAG_VERSION_INFO
//      L"\ndcdiag.exe /s <Domain Controller> [/options]"  // Another format for help that I am debating
        L"\ndcdiag.exe /s:<Domain Controller> [/u:<Domain>\\<Username> /p:*|<Password>|\"\"]"
        L"\n           [/hqv] [/n:<Naming Context>] [/f:<Log>] [/ferr:<Errlog>]"
        L"\n           [/skip:<Test>] [/test:<Test>]"
        L"\n   /h: Display this help screen"
        L"\n   /s: Use <Domain Controller> as Home Server. Ignored for DcPromo and"
        L"\n       RegisterInDns tests which can only be run locally."
        L"\n   /n: Use <Naming Context> as the Naming Context to test"
        L"\n       Domains may be specified in Netbios, DNS or DN form."
        L"\n   /u: Use domain\\username credentials for binding."
        L"\n       Must also use the /p option"
        L"\n   /p: Use <Password> as the password.  Must also use the /u option"
        L"\n   /a: Test all the servers in this site"
        L"\n   /e: Test all the servers in the entire enterprise.  Overrides /a"
        L"\n   /q: Quiet - Only print error messages"
        L"\n   /v: Verbose - Print extended information"
        L"\n   /i: ignore - ignores superfluous error messages."
        L"\n   /fix: fix - Make safe repairs."
        L"\n   /f: Redirect all output to a file <Log>, /ferr will redirect error output"
        L"\n       seperately."
        L"\n   /ferr:<ErrLog> Redirect fatal error output to a seperate file <ErrLog>"
        L"\n   /c: Comprehensive, runs all tests, including non-default tests but excluding"
        L"\n       DcPromo and RegisterInDNS. Can use with /skip";
    static const LPWSTR    pszTestHelp =
        L"\n   /test:<TestName> - Test only this test.  Required tests will still"
        L"\n                      be run.  Do not mix with /skip."
        L"\n   Valid tests are:\n";
    static const LPWSTR    pszSkipHelp =
        L"\n   /skip:<TestName> - Skip the named test.  Required tests will still"
        L"\n                      be run.  Do not mix with /test."
        L"\n   Tests that can be skipped are:\n";
    static const LPWSTR    pszNotRunTestHelp =
        L"\n   The following tests are not run by default:\n";

    fputws(pszHelpScreen, stdout);
    fputws(pszTestHelp, stdout);
    for (ulTest = 0L; allTests[ulTest].testId != DC_DIAG_ID_FINISHED; ulTest++){
        wprintf (L"       %s  - %s\n", allTests[ulTest].pszTestName,
                 allTests[ulTest].pszTestDescription);
    }
    fputws(pszSkipHelp, stdout);
    for (ulTest = 0L; allTests[ulTest].testId != DC_DIAG_ID_FINISHED; ulTest++){
        if(!(allTests[ulTest].ulTestFlags & CAN_NOT_SKIP_TEST)){
            wprintf (L"       %s  - %s\n", allTests[ulTest].pszTestName,
                 allTests[ulTest].pszTestDescription);
        }
    }
    fputws(pszNotRunTestHelp, stdout);
    for (ulTest = 0L; allTests[ulTest].testId != DC_DIAG_ID_FINISHED; ulTest++){
        if((allTests[ulTest].ulTestFlags & DO_NOT_RUN_TEST_BY_DEFAULT)){
            wprintf (L"       %s  - %s\n", allTests[ulTest].pszTestName,
                 allTests[ulTest].pszTestDescription);
        }
    }
    
    fputws(L"\n\tAll tests except DcPromo and RegisterInDNS must be run on computers\n"
           L"\tafter they have been promoted to domain controller.\n\n", stdout);
    fputws(L"Note: Text (Naming Context names, server names, etc) with International or\n"
           L"      Unicode characters will only display correctly if appropriate fonts and\n"
           L"      language support are loaded\n", stdout);

} // End PrintHelpScreen()

void
DcDiagPrintCommandLine(
    int argc,
    LPWSTR * argv
)
/*++

   In debug mode, we want to know the command line options that the customer might've used
   so we're going to print out the command line so it gets captured in the output file.

--*/
{
    int i;

    PrintMessage(SEV_DEBUG, L"Command Line: \"dcdiag.exe ");
    
    for(i=1; i < argc; i++){

        PrintMessage(SEV_DEBUG, (i != (argc-1)) ? L"%s " : L"%s", argv[i]);
    }

    PrintMessage(SEV_DEBUG, L"\"\n");
}

ULONG
DcDiagExceptionHandler(
    IN const  EXCEPTION_POINTERS * prgExInfo,
    OUT PDWORD                     pdwWin32Err
    )
/*++

Routine Description:

    This function is used in the __except (<insert here>) part of the except
    clause.  This will hand back the win 32 error if this is a dcdiag
    exception.

Arguments:

    prgExInfo - This is the information returned by GetExceptioInformation()
        in the __except() clause.
    pdwWin32Err - This is the value handed back as the win 32 error.

Return Value:
    returns EXCEPTION_EXECUTE_HANDLER if the exception was thrown by dcdiag and
    EXCEPTION_CONTINUE_SEARCH otherwise.

--*/
{

    if(prgExInfo->ExceptionRecord->ExceptionCode == DC_DIAG_EXCEPTION){
        IF_DEBUG(PrintMessage(SEV_ALWAYS,
                              L"DcDiag: a dcdiag exception raised, handling error %d\n",
                              prgExInfo->ExceptionRecord->ExceptionInformation[0]));
        if(pdwWin32Err != NULL){
            *pdwWin32Err = (DWORD) prgExInfo->ExceptionRecord->ExceptionInformation[0];
        }
        return(EXCEPTION_EXECUTE_HANDLER);
    } else {
        IF_DEBUG(PrintMessage(SEV_ALWAYS,
                              L"DcDiag: uncaught exception raised, continuing search \n"));
        if(pdwWin32Err != NULL){
            *pdwWin32Err = ERROR_SUCCESS;
        }
        return(EXCEPTION_CONTINUE_SEARCH);
    }
}

VOID
DcDiagException (
    IN    DWORD            dwWin32Err
    )
/*++

Routine Description:

    This is called by the component tests to indicate that a fatal error
    has occurred.

Arguments:

    dwWin32Err        (IN ) -    The win32 error code.

Return Value:

--*/
{
    static ULONG_PTR              ulpErr[1];

    ulpErr[0] = dwWin32Err;

    if (dwWin32Err != NO_ERROR){
        RaiseException (DC_DIAG_EXCEPTION,
                        EXCEPTION_NONCONTINUABLE,
                        1,
                        ulpErr);
    }
}

LPWSTR
Win32ErrToString (
    IN    DWORD            dwWin32Err
    )
/*++

Routine Description:

    Converts a win32 error code to a string; useful for error reporting.
    This was basically stolen from repadmin.

Arguments:

    dwWin32Err        (IN ) -    The win32 error code.

Return Value:

    The converted string.  This is part of system memory and does not
    need to be freed.

--*/
{
    #define ERROR_BUF_LEN    4096
    static WCHAR        szError[ERROR_BUF_LEN];

    if (FormatMessageW (
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwWin32Err,
        GetSystemDefaultLangID (),
        szError,
        ERROR_BUF_LEN,
        NULL) != NO_ERROR)
    szError[wcslen (szError) - 2] = '\0';    // Remove \r\n

    else swprintf (szError, L"Win32 Error %d", dwWin32Err);

    return szError;
}

INT PrintIndentAdj (INT i)
{
    gMainInfo.iCurrIndent += i;
    if (0 > gMainInfo.iCurrIndent)
    {
       gMainInfo.iCurrIndent = 0;
    }
    return (gMainInfo.iCurrIndent);
}

INT PrintIndentSet (INT i)
{
    INT   iRet;
    iRet = gMainInfo.iCurrIndent;
    if (0 > i)
    {
       i = 0;
    }
    gMainInfo.iCurrIndent = i;
    return(iRet);
}


DWORD
DcDiagRunTest (
    PDC_DIAG_DSINFO             pDsInfo,
    ULONG                       ulTargetServer,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    const DC_DIAG_TESTINFO *    pTestInfo
    )
/*++

Routine Description:

    Runs a test and catches any exceptions.

Arguments:

    pTestInfo        (IN ) -    The test's info structure.

Return Value:

    If the test raises a DC_DIAG_EXCEPTION, this will be the error
    code passed as an argument to DcDiagException.  Otherwise this
    will be NO_ERROR.

--*/
{
    DWORD            dwWin32Err = NO_ERROR;
    ULONG ulCount;
    CHAR c;


    PrintIndentAdj(1);


    __try {

// This can be used to check for memory leaks with dh.exe and dhcmp.exe
//#define DEBUG_MEM
#ifdef DEBUG_MEM
        c = getchar();
        for(ulCount=0; ulCount < 124; ulCount++){
            dwWin32Err = pTestInfo->fnTest (pDsInfo, ulTargetServer, gpCreds);
        }
        c = getchar();
#else
          dwWin32Err = pTestInfo->fnTest(pDsInfo, ulTargetServer, gpCreds);
#endif
    } __except (DcDiagExceptionHandler(GetExceptionInformation(),
                                       &dwWin32Err)){
        // ... helpful to know when we died in an exception.
        IF_DEBUG(wprintf(L"JUMPED TO TEST EXCEPTION HANDLER(Err=%d): %s\n",
                         dwWin32Err,
                         Win32ErrToString(dwWin32Err)));
    }

    PrintIndentAdj(-1);
    return dwWin32Err;
}

VOID
DcDiagPrintTestsHeading(
    PDC_DIAG_DSINFO                   pDsInfo,
    ULONG                             iTarget,
    ULONG                             ulFlagSetType
    )
/*++

Routine Description:

    This prints a heading for the tests, it needed to be used about 3
    times so it became it's own function.

Arguments:

    pDsInfo - Global data
    iTarget - Specifies index of target.        
    ulFlagSetType - This is a constant of RUN_TEST_PER_* (* = SERVER |
        SITE | PARTITION | ENTERPRISE) to specify what context to 
        interprit iTarget in (pServers | pSites | pNCs respectively)

--*/
{
    PrintMessage(SEV_NORMAL, L"\n");                     
    if(ulFlagSetType == RUN_TEST_PER_SERVER){
        PrintMessage(SEV_NORMAL, L"Testing server: %s\\%s\n",
                     pDsInfo->pSites[pDsInfo->pServers[iTarget].iSite].pszName,
                     pDsInfo->pServers[iTarget].pszName);
    } else if(ulFlagSetType == RUN_TEST_PER_SITE){
        PrintMessage(SEV_NORMAL, L"Testing site: %s\n",
                     pDsInfo->pSites[iTarget].pszName);
    } else if(ulFlagSetType == RUN_TEST_PER_PARTITION){
        PrintMessage(SEV_NORMAL, L"Running partition tests on : %s\n",
                     pDsInfo->pNCs[iTarget].pszName);
    } else if(ulFlagSetType == RUN_TEST_PER_ENTERPRISE){
        PrintMessage(SEV_NORMAL, L"Running enterprise tests on : %s\n",
                     pDsInfo->pszRootDomain);
    }

}

VOID
DcDiagRunAllTests (
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN  LPWSTR *                    ppszOmitTests,
    IN  BOOL                        bDoRequired,
    IN  ULONG                       ulFlagSetType, // server, site, enterprise, nc
    IN  ULONG                       iTarget
    )
/*++

Routine Description:

    Runs the tests in alltests.h in sequence, if they match the
    ulFlagSetType and the bDoRequired type.

Arguments:

    ppszOmitTests    (IN ) -    A null-terminated list of tests to skip.

Return Value:

--*/
{
    DWORD   dwWin32Err = ERROR_SUCCESS;
    DWORD   dwTotalErr = ERROR_SUCCESS;
    ULONG   ulOmissionAt;
    BOOL    bPerform;
    CHAR    c;
    BOOL    bPrintedHeading = FALSE;
    LPWSTR  pszTarget = NULL;

    PrintIndentAdj(1);

    // Try running All the tests.
    for (gMainInfo.lTestAt = 0L; allTests[gMainInfo.lTestAt].testId != DC_DIAG_ID_FINISHED; gMainInfo.lTestAt++) {

        // Checking if test is the right kind of test: server, site, enterp...
        if(ulFlagSetType & allTests[gMainInfo.lTestAt].ulTestFlags){
            // The right kind of test ... server indexs must
            //    be matched with server tests, site indexs with
            //    site tests, etc.
            if(!bDoRequired
               && !(allTests[gMainInfo.lTestAt].ulTestFlags & CAN_NOT_SKIP_TEST)){
                // Running a non-required test ... This section will give
                //     all three reasons to or not do this optional test.
                bPerform = TRUE;

                // Checking if the user Specified not to do this test.
                for (ulOmissionAt = 0L; ppszOmitTests[ulOmissionAt] != NULL; ulOmissionAt++){
                    if (_wcsicmp (ppszOmitTests[ulOmissionAt],
                                  allTests[gMainInfo.lTestAt].pszTestName) == 0){
                        bPerform = FALSE;

                        if(!bPrintedHeading){
                            // Need to print heading for this test type before
                            //   printing out any errors
                            DcDiagPrintTestsHeading(pDsInfo, iTarget,
                                                    ulFlagSetType);
                            bPrintedHeading = TRUE;
                        }

                        PrintIndentAdj(1);
                        PrintMessage(SEV_VERBOSE,
                                     L"Test omitted by user request: %s\n",
                                     allTests[gMainInfo.lTestAt].pszTestName);
                        PrintIndentAdj(-1);
                    }
                }

                // Checking if the server failed the Up Check.
                if( (ulFlagSetType & RUN_TEST_PER_SERVER)
                    && ! (pDsInfo->pServers[iTarget].bDsResponding
                       && pDsInfo->pServers[iTarget].bLdapResponding) ){
                    bPerform = FALSE;

                    if(!bPrintedHeading){
                        // Need to print heading for this test type before
                        //    printing out any errors
                        DcDiagPrintTestsHeading(pDsInfo, iTarget,
                                                ulFlagSetType);
                        bPrintedHeading = TRUE;

                        PrintIndentAdj(1);
                        PrintMessage(SEV_NORMAL,
                                     L"Skipping all tests, because server %s is\n",
                                     pDsInfo->pServers[iTarget].pszName);
                        PrintMessage(SEV_NORMAL,
                                     L"not responding to directory service requests\n");
                        PrintIndentAdj(-1);
                    }
                }

            } else if(bDoRequired
                      && (allTests[gMainInfo.lTestAt].ulTestFlags & CAN_NOT_SKIP_TEST)){
                // Running a required test
                bPerform = TRUE;
            } else {
                bPerform = FALSE;
            } // end if/elseif/else if required/non-required
        } else {
            bPerform = FALSE;
        } // end if/else right kind of test set (server, site, enterprise, nc

        if(!bPrintedHeading && bPerform){
            // Need to print out heading for this type of test, before printing
            //   out any test output
            DcDiagPrintTestsHeading(pDsInfo, iTarget, ulFlagSetType);
            bPrintedHeading = TRUE;
        }

        // Perform the test if appropriate ------------------------------------
        if (bPerform) {
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"Starting test: %s\n",
                         allTests[gMainInfo.lTestAt].pszTestName);

            dwWin32Err = DcDiagRunTest (pDsInfo,
                                        iTarget,
                                        gpCreds,
                                        &allTests[gMainInfo.lTestAt]);
           PrintIndentAdj(1);

            if(ulFlagSetType & RUN_TEST_PER_SERVER){
                pszTarget = pDsInfo->pServers[iTarget].pszName;
           } else if(ulFlagSetType & RUN_TEST_PER_SITE){
                pszTarget = pDsInfo->pSites[iTarget].pszName;
            } else if(ulFlagSetType & RUN_TEST_PER_PARTITION){
                pszTarget = pDsInfo->pNCs[iTarget].pszName;
            } else if(ulFlagSetType & RUN_TEST_PER_ENTERPRISE){
                pszTarget = pDsInfo->pszRootDomain;
            } else {
                Assert(!"New set type fron alltests.h that hasn't been updated in main.c/DcDiagRunAllTests\n");
                pszTarget = L"";
            }
            if(dwWin32Err == NO_ERROR){
                PrintMessage(SEV_NORMAL,
                             L"......................... %s passed test %s\n",
                             pszTarget, allTests[gMainInfo.lTestAt].pszTestName);
            } else {
                PrintMessage(SEV_ALWAYS,
                             L"......................... %s failed test %s\n",
                             pszTarget, allTests[gMainInfo.lTestAt].pszTestName);
            }
            PrintIndentAdj(-1);
            PrintIndentAdj(-1);
        } // end bPeform ...

    } // end for each test

    PrintIndentAdj(-1);
}

VOID
DcDiagRunTestSet (
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN  LPWSTR *                    ppszOmitTests,
    IN  BOOL                        bDoRequired,
    IN  ULONG                       ulFlagSetType // Server, Site, or Enterprise
    )
/*++

Routine Description:

    This calles the DcDiagRunAllTests one per server, site, or enterprise
    dependant on the what ulFlagSetType is set to.

Arguments:

    pDsInfo - the enterprise info (passed through)
    gpCreds - the alternate credentails if any (passed through)
    ppszOmitTests - a list of tests to not perform (passed through)
    bDoRequired - whether to do the required tests (passed through)
    ulFlagSetType - only important parameter, this tells wether we should be
        doing the tests per server, per site, or per enterprise.

--*/
{
    ULONG                           iTarget;

    if(ulFlagSetType == RUN_TEST_PER_SERVER){
        for(iTarget = 0; iTarget < pDsInfo->ulNumTargets; iTarget++){
             DcDiagRunAllTests(pDsInfo, gpCreds, ppszOmitTests,
                               bDoRequired, ulFlagSetType,
                               pDsInfo->pulTargets[iTarget]);
        }
    } else if(ulFlagSetType == RUN_TEST_PER_SITE){
        for(iTarget = 0; iTarget < pDsInfo->cNumSites; iTarget++){
            DcDiagRunAllTests(pDsInfo, gpCreds, ppszOmitTests,
                              bDoRequired, ulFlagSetType,
                              iTarget);
        }
    } else if(ulFlagSetType == RUN_TEST_PER_PARTITION){
        for(iTarget = 0; iTarget < pDsInfo->cNumNcTargets; iTarget++){
            DcDiagRunAllTests(pDsInfo, gpCreds, ppszOmitTests,
                              bDoRequired, ulFlagSetType,
                              pDsInfo->pulNcTargets[iTarget]);
        }
    } else if(ulFlagSetType == RUN_TEST_PER_ENTERPRISE){
         DcDiagRunAllTests(pDsInfo, gpCreds, ppszOmitTests,
                           bDoRequired, ulFlagSetType,
                           0);
    } else {
        Assert(!"Programmer error, called DcDiagRunTestSet() w/ bad param\n");
    }
}

VOID
DcDiagMain (
    IN   LPWSTR                          pszHomeServer,
    IN   LPWSTR                          pszNC,
    IN   ULONG                           ulFlags,
    IN   LPWSTR *                        ppszOmitTests,
    IN   SEC_WINNT_AUTH_IDENTITY_W *     gpCreds,
    IN   WCHAR  *                        ppszExtraCommandLineArgs[]
    )
/*++

Routine Description:
whether server
    Runs the tests in alltests.h in sequence.

Arguments:

    ppszOmitTests    (IN ) -    A null-terminated list of tests to skip.
    pszSourceName = pNeighbor->pszSourceDsaAddress;


Return Value:

--*/
{
    DC_DIAG_DSINFO              dsInfo;
    DWORD                       dwWin32Err;
    ULONG                       ulTargetServer;
    WSADATA                     wsaData;
    INT                         iRet;
    CHAR                        c;

    INT i=0;
    // Set the Extra Command parameters
    dsInfo.ppszCommandLine = ppszExtraCommandLineArgs;

    // Print out general version info ------------------------------------------
    PrintMessage(SEV_NORMAL, L"\n");
    PrintMessage(SEV_NORMAL, DC_DIAG_VERSION_INFO);
    PrintMessage(SEV_NORMAL, L"\n");


    // Initialization of WinSock, and Gathering Initial Info -------------------
    PrintMessage(SEV_NORMAL, L"Performing initial setup:\n");
    PrintIndentAdj(1);

    // Init WinSock
    dwWin32Err = WSAStartup(MAKEWORD(1,1),&wsaData);
    if (dwWin32Err != 0) {
        PrintMessage(SEV_ALWAYS,
                     L"Couldn't initialize WinSock with error: %s\n",
                     Win32ErrToString(dwWin32Err));
    }

    // Gather Initial Info
    // Note: We expect DcDiagGatherInfo to print as many informative errors as it
    //   needs to.
    dwWin32Err = DcDiagGatherInfo (pszHomeServer, pszNC, ulFlags, gpCreds,
                                   &dsInfo);
    dsInfo.gpCreds = gpCreds;
    if(dwWin32Err != ERROR_SUCCESS){
        // Expect that DdDiagGatherInfo printed out appropriate errors, just bail.
        return;
    }
    PrintIndentAdj(-1);
    PrintMessage(SEV_NORMAL, L"\n");

    if(gMainInfo.ulSevToPrint >= SEV_DEBUG){
        DcDiagPrintDsInfo(&dsInfo);
    }

    // Actually Running Tests --------------------------------------------------
    //
    //   Do required Tests
    //
    PrintMessage(SEV_NORMAL, L"Doing initial required tests\n");
    // Do per server tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     TRUE, RUN_TEST_PER_SERVER);
    // Do per site tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     TRUE, RUN_TEST_PER_SITE);
    // Do per NC/parition tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     TRUE, RUN_TEST_PER_PARTITION);
   // Do per enterprise tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     TRUE, RUN_TEST_PER_ENTERPRISE);

    //
    //   Do non-required Tests
    //
    PrintMessage(SEV_NORMAL, L"\nDoing primary tests\n");
    // Do per server tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     FALSE, RUN_TEST_PER_SERVER);
    // Do per site tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     FALSE, RUN_TEST_PER_SITE);
    // Do per NC/partition tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     FALSE, RUN_TEST_PER_PARTITION);
   // Do per enterprise tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     FALSE, RUN_TEST_PER_ENTERPRISE);

    // Clean up and leave ------------------------------------------------------
    WSACleanup();
    DcDiagFreeDsInfo (&dsInfo);
}

int
PreProcessGlobalParams(
    IN OUT    INT *    pargc,
    IN OUT    LPWSTR** pargv
    )
/*++

Routine Description:

    Scan command arguments for user-supplied credentials of the form
        [/-](u|user):({domain\username}|{username})
        [/-](p|pw|pass|password):{password}
    Set credentials used for future DRS RPC calls and LDAP binds appropriately.
    A password of * will prompt the user for a secure password from the console.

    Also scan args for /async, which adds the DRS_ASYNC_OP flag to all DRS RPC
    calls.

    CODE.IMPROVEMENT: The code to build a credential is also available in
    ntdsapi.dll\DsMakePasswordCredential().

Arguments:

    pargc
    pargv


Return Values:

    ERROR_SUCCESS - success
    other - failure

--*/
{
    INT     ret = 0;
    INT     iArg;
    LPWSTR  pszOption;

    DWORD   cchOption;
    LPWSTR  pszDelim;
    LPWSTR  pszValue;
    DWORD   cchValue;

    for (iArg = 1; iArg < *pargc; ) {
        if (((*pargv)[iArg][0] != L'/') && ((*pargv)[iArg][0] != L'-')) {
            // Not an argument we care about -- next!
            iArg++;
        } else {
            pszOption = &(*pargv)[iArg][1];
            pszDelim = wcschr(pszOption, L':');

            cchOption = (DWORD)(pszDelim - (*pargv)[iArg]);

            if (    (0 == _wcsnicmp(L"p:",        pszOption, cchOption))
                    || (0 == _wcsnicmp(L"pw:",       pszOption, cchOption))
                    || (0 == _wcsnicmp(L"pass:",     pszOption, cchOption))
                    || (0 == _wcsnicmp(L"password:", pszOption, cchOption)) ) {
                // User-supplied password.
                //            char szValue[ 64 ] = { '\0' };

                pszValue = pszDelim + 1;
                cchValue = 1 + wcslen(pszValue);

                if ((2 == cchValue) && (L'*' == pszValue[0])) {
                    // Get hidden password from console.
                    cchValue = 64;

                    gCreds.Password = malloc(sizeof(WCHAR) * cchValue);

                    if (NULL == gCreds.Password) {
                        PrintMessage(SEV_ALWAYS, L"No memory.\n" );
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    PrintMessage(SEV_ALWAYS, L"Password: ");

                    ret = GetPassword(gCreds.Password, cchValue, &cchValue);
                } else {
                    // Get password specified on command line.
                    gCreds.Password = malloc(sizeof(WCHAR) * cchValue);

                    if (NULL == gCreds.Password) {
                        PrintMessage(SEV_ALWAYS, L"No memory.\n");
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }
                    wcscpy(gCreds.Password, pszValue); //, cchValue);

                }

                // Next!
                memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                        sizeof(**pargv)*(*pargc-(iArg+1)));
                --(*pargc);
            } else if (    (0 == _wcsnicmp(L"u:",    pszOption, cchOption))
                           || (0 == _wcsnicmp(L"user:", pszOption, cchOption)) ) {


                // User-supplied user name (and perhaps domain name).
                pszValue = pszDelim + 1;
                cchValue = 1 + wcslen(pszValue);

                pszDelim = wcschr(pszValue, L'\\');

                if (NULL == pszDelim) {
                    // No domain name, only user name supplied.
                    PrintMessage(SEV_ALWAYS, L"User name must be prefixed by domain name.\n");
                    return ERROR_INVALID_PARAMETER;
                }

                gCreds.Domain = malloc(sizeof(WCHAR) * cchValue);
                gCreds.User = gCreds.Domain + (int)(pszDelim+1 - pszValue);

                if (NULL == gCreds.Domain) {
                    PrintMessage(SEV_ALWAYS, L"No memory.\n");
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                wcsncpy(gCreds.Domain, pszValue, cchValue);
                // wcscpy(gCreds.Domain, pszValue); //, cchValue);
                gCreds.Domain[ pszDelim - pszValue ] = L'\0';

                // Next!
                memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                        sizeof(**pargv)*(*pargc-(iArg+1)));
                --(*pargc);
            } else {
                iArg++;
            }

        }
    }

    if (NULL == gCreds.User){
        if (NULL != gCreds.Password){
        // Password supplied w/o user name.
        PrintMessage(SEV_ALWAYS, L"Password must be accompanied by user name.\n" );
            ret = ERROR_INVALID_PARAMETER;
        } else {
        // No credentials supplied; use default credentials.
        ret = ERROR_SUCCESS;
        }
        gpCreds = NULL;
    } else {
        gCreds.PasswordLength = gCreds.Password ? wcslen(gCreds.Password) : 0;
        gCreds.UserLength   = wcslen(gCreds.User);
        gCreds.DomainLength = gCreds.Domain ? wcslen(gCreds.Domain) : 0;
        gCreds.Flags        = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        // CODE.IMP: The code to build a SEC_WINNT_AUTH structure also exists
        // in DsMakePasswordCredentials.  Someday use it

        // Use credentials in DsBind and LDAP binds
        gpCreds = &gCreds;
    }

    return ret;
}



#define CR        0xD
#define BACKSPACE 0x8

INT
GetPassword(
    WCHAR *     pwszBuf,
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    )
/*++

Routine Description:

    Retrieve password from command line (without echo).
    Code stolen from LUI_GetPasswdStr (net\netcmd\common\lui.c).

Arguments:

    pwszBuf - buffer to fill with password
    cchBufMax - buffer size (incl. space for terminating null)
    pcchBufUsed - on return holds number of characters used in password

Return Values:

    DRAERR_Success - success
    other - failure

--*/
{
    WCHAR   ch;
    WCHAR * bufPtr = pwszBuf;
    DWORD   c;
    INT     err;
    INT     mode;

    cchBufMax -= 1;    /* make space for null terminator */
    *pcchBufUsed = 0;               /* GP fault probe (a la API's) */
    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode)) {
        return GetLastError();
    }
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
        if (!err || c != 1)
            ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) {  /* back up one or two */
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != pwszBuf) {
                bufPtr--;
                (*pcchBufUsed)--;
            }
        }
        else {

            *bufPtr = ch;

            if (*pcchBufUsed < cchBufMax)
                bufPtr++ ;                   /* don't overflow buf */
            (*pcchBufUsed)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = L'\0';         /* null terminate the string */
    putchar('\n');

    if (*pcchBufUsed > cchBufMax)
    {
        PrintMessage(SEV_ALWAYS, L"Password too long!\n");
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}


//---------------------------------------------------------------------------
//
//  Function:       ConvertToWide
//
//  Description:    converts a single byte string to a double byte string
//
//  Arguments:      lpszDestination - destination string
//                  lpszSource - source string
//                  iDestSize - maximum # of chars to be converted
//                             (= destination size)
//
//  Returns:        none
//
//  History:        01/22/98 - gabrielh created
//
//---------------------------------------------------------------------------
void
ConvertToWide (LPWSTR lpszDestination,
               LPCSTR lpszSource,
               const int iDestSize)
{
    if (lpszSource){
        //
        //just convert the 1 character string to wide-character string
        MultiByteToWideChar (
                 CP_ACP,
                 0,
                 lpszSource,
                 -1,
                 lpszDestination,
                 iDestSize
                 );
    } else {
        lpszDestination[0] = L'\0';
    }
}


LPWSTR
findServerForDomain(
    LPWSTR pszDomainDn
    )

/*++

Routine Description:

    Locate a DC that holds the given domain.

    This routine runs before pDsInfo is allocated.  We don't know who our
    home server is. We can only use knowledge from the Locator.

    The incoming name is checked to be a Dn. Ncs such as CN=Configuration and
    CN=Schema are not allowed.

Arguments:

    pszDomainDn - DN of domain

Return Value:

    LPWSTR - DNS name of server. Allocated using LocalAlloc. Caller must
    free.

--*/

{
    DWORD status;
    LPWSTR pszServer = NULL;
    PDS_NAME_RESULTW pResult = NULL;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;

    // Check for valid DN syntax
    if (_wcsnicmp( pszDomainDn, L"dc=", 3 ) != 0) {
        PrintMessage( SEV_ALWAYS,
                      L"The syntax of domain distinguished name %ws is incorrect.\n",
                      pszDomainDn );
        return NULL;
    }

    // Convert the DN of domain to DNS name
    status = DsCrackNamesW(
        NULL,
        DS_NAME_FLAG_SYNTACTICAL_ONLY,
        DS_FQDN_1779_NAME,
        DS_CANONICAL_NAME_EX,
        1,
        &pszDomainDn,
        &pResult);
    if ( (status != ERROR_SUCCESS) ||
         (pResult->rItems[0].pDomain == NULL) ) {
        PrintMessage( SEV_ALWAYS,
                      L"The syntax of domain distinguished name %ws is incorrect.\n",
                      pszDomainDn );
        PrintMessage( SEV_ALWAYS,
                      L"Translation failed with error: %s.\n",
                      Win32ErrToString(status) );
        return NULL;
    }

    // Use DsGetDcName to find the server with the domain

    // Get active domain controller information
    status = DsGetDcName(
        NULL, // computer name
        pResult->rItems[0].pDomain, // domain name
        NULL, // domain guid,
        NULL, // site name,
        DS_DIRECTORY_SERVICE_REQUIRED |
        DS_IP_REQUIRED |
        DS_IS_DNS_NAME |
        DS_RETURN_DNS_NAME,
        &pDcInfo );
    if (status != ERROR_SUCCESS) {
        PrintMessage(SEV_ALWAYS,
                     L"A domain controller holding %ws could not be located.\n",
                     pResult->rItems[0].pDomain );
        PrintMessage(SEV_ALWAYS, L"The error is %s\n", Win32ErrToString(status) );
        PrintMessage(SEV_ALWAYS, L"Try specifying a server with the /s option.\n" );
        goto cleanup;
    }

    pszServer = LocalAlloc( LMEM_FIXED,
                            (wcslen( pDcInfo->DomainControllerName + 2 ) + 1) *
                            sizeof( WCHAR ) );
    if (pszServer == NULL) {
        PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
        goto cleanup;
    }
    wcscpy( pszServer, pDcInfo->DomainControllerName + 2 );

    PrintMessage( SEV_VERBOSE, L"* The home server picked is %ws in site %ws.\n",
                  pszServer,
                  pDcInfo->DcSiteName );
cleanup:

    if (pResult != NULL) {
        DsFreeNameResultW(pResult);
    }
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
    }

    return pszServer;

} /* findServerForDomain */



LPWSTR
findDefaultServer(BOOL fMustBeDC)

/*++

Routine Description:

    Get the DNS name of the default computer, which would be the local machine.

Return Value:

    LPWSTR - DNS name of server. Allocated using LocalAlloc. Caller must
    free.

--*/

{
    LPWSTR             pwszServer = NULL;
    DWORD              ulSizeReq = 0;
    DWORD              dwErr = 0;
    HANDLE             hDs = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC    pBuffer = NULL;

    __try{

        // Call GetComputerNameEx() once to get size of buffer, then allocate the buffer.
        GetComputerNameEx(ComputerNameDnsHostname, pwszServer, &ulSizeReq);
        pwszServer = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulSizeReq);
        if(pwszServer == NULL){
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        // Now actually get the computer name.
        if(GetComputerNameEx(ComputerNameDnsHostname, pwszServer, &ulSizeReq) == 0){
            dwErr = GetLastError();
            Assert(dwErr != ERROR_BUFFER_OVERFLOW);
            PrintMsg(SEV_ALWAYS, DCDIAG_GATHERINFO_CANT_GET_LOCAL_COMPUTERNAME,
                     Win32ErrToString(dwErr));
            __leave;
        }

        if (fMustBeDC)
        {
            PrintMsg(SEV_VERBOSE,
                     DCDIAG_GATHERINFO_VERIFYING_LOCAL_MACHINE_IS_DC,
                     pwszServer);
        }

        dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                                  DsRolePrimaryDomainInfoBasic,
                                                  (CHAR **) &pBuffer);
        if(dwErr != ERROR_SUCCESS){
            Assert(dwErr != ERROR_INVALID_PARAMETER);
            Assert(dwErr == ERROR_NOT_ENOUGH_MEMORY && "It wouldn't surprise me if"
                   " this fires, but MSDN documentation claims there are only 2 valid"
                   " error codes");
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }
        Assert(pBuffer != NULL);
        if(!(pBuffer->MachineRole == DsRole_RolePrimaryDomainController
             || pBuffer->MachineRole == DsRole_RoleBackupDomainController)){
            if (fMustBeDC)
            {
                // This machine is NOT a DC.  Signal any error.
                PrintMsg(SEV_ALWAYS, DCDIAG_MUST_SPECIFY_S_OR_N,
                         pwszServer);
                dwErr = ERROR_DS_NOT_SUPPORTED;
            }
            __leave;
        }
/*        else
        {
            if (!fMustBeDC)
            {
                // This machine is a DC. Signal any error. BUGBUG need error
                PrintMsg(SEV_ALWAYS, DCDIAG_MUST_SPECIFY_S_OR_N,
                         pwszServer);
                dwErr = ERROR_DS_NOT_SUPPORTED;
            }
            __leave;
        }
*/

    } __finally {
        if(dwErr){
            if(pwszServer){
                LocalFree(pwszServer);
            }
            pwszServer = NULL;
        }
        if(pBuffer){
            DsRoleFreeMemory(pBuffer);
        }
    }

    return(pwszServer);
} /* findDefaultServer */


LPWSTR
convertDomainNcToDn(
    LPWSTR pwzIncomingDomainNc
    )

/*++

Routine Description:

This routine converts a domain in shorthand form into the standard
Distinguished Name form.

If the name is a dn we return it.
If the name is not a dns name, we use dsgetdcname to convert the netbios domain
to a dns domain.
Given a dns domain, we use crack names to generate the dn for the domain.

If a name looks like a DN, we return it without further validation.  That
will be performed later.

Note that CN=Schema and CN=Configuration have no convenient shorthand's like
domains that have a DNS and netbios name.  That is because they are not
domains, but only Ncs.

Note that at the time this routine runs, pDsInfo is not initialized, so we
cannot depend on it.  In fact, we have no bindings to any DC's yet. We don't
even know our home server at this point. The only knowledge I rely on is that
of the locator (DsGetDcName).

Arguments:

    pwzIncomingDomainNc - Naming context.

Return Value:

    LPWSTR - Naming context in Dn form. This is always allocated using
    LocalAlloc. Caller must free.

--*/

{
    DWORD status;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    LPWSTR pwzOutgoingDomainDn = NULL, pwzTempDnsName = NULL;
    PDS_NAME_RESULTW pResult = NULL;

    // Check if already a Dn
    // Looks like a DN, return it for now
    if (wcschr( pwzIncomingDomainNc, L'=' ) != NULL) {
        LPWSTR pwzNewDn = LocalAlloc( LMEM_FIXED,
                                      (wcslen( pwzIncomingDomainNc ) + 1) *
                                      sizeof( WCHAR ) );
        if (pwzNewDn == NULL) {
            PrintMessage( SEV_ALWAYS, L"Memory allocation failure\n" );
            goto cleanup;
        }
        wcscpy( pwzNewDn, pwzIncomingDomainNc );
        return pwzNewDn;
    }

    // If not a dns name, assume a netbios name and use the locator
    if (wcschr( pwzIncomingDomainNc, L'.' ) == NULL) {

        status = DsGetDcName(
            NULL, // computer name
            pwzIncomingDomainNc, // domain name
            NULL, // domain guid,
            NULL, // site name,
            DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED |
            DS_RETURN_DNS_NAME,
            &pDcInfo );
        if (status != ERROR_SUCCESS) {
            PrintMessage(SEV_ALWAYS,
                         L"A domain named %ws could not be located.\n",
                         pwzIncomingDomainNc );
            PrintMessage(SEV_ALWAYS, L"The error is %s\n", Win32ErrToString(status) );
            PrintMessage(SEV_ALWAYS, L"Check syntax and validity of specified name.\n" );
            goto cleanup;
        }
        PrintMessage( SEV_ALWAYS, L"The domain name is %ws.\n",
                      pDcInfo->DomainName );
        pwzIncomingDomainNc = pDcInfo->DomainName;
    }

    // Copy name and terminate in special way to make crack names happy
    // DNS name must be newline terminated. Don't ask me.
    pwzTempDnsName = LocalAlloc( LMEM_FIXED,
                                 (wcslen( pwzIncomingDomainNc ) + 2) *
                                 sizeof( WCHAR ) );
    if (pwzTempDnsName == NULL) {
        PrintMessage( SEV_ALWAYS, L"Memory allocation failure\n" );
        goto cleanup;
    }
    wcscpy( pwzTempDnsName, pwzIncomingDomainNc );
    wcscat( pwzTempDnsName, L"\n" );

    // Convert the dns name to Dn format

    status = DsCrackNamesW(
        NULL,
        DS_NAME_FLAG_SYNTACTICAL_ONLY,
        DS_CANONICAL_NAME_EX,
        DS_FQDN_1779_NAME,
        1,
        &pwzTempDnsName,
        &pResult);
    if ( (status != ERROR_SUCCESS) ||
         ( pResult->rItems[0].pName == NULL) ) {
        PrintMessage( SEV_ALWAYS,
                      L"The syntax of DNS domain name %ws is incorrect.\n",
                      pwzIncomingDomainNc );
        PrintMessage( SEV_ALWAYS,
                      L"Translation failed with error: %s.\n",
                      Win32ErrToString(status) );
        goto cleanup;
    }

    // Return new Dn
    pwzOutgoingDomainDn = LocalAlloc( LMEM_FIXED,
                                      (wcslen( pResult->rItems[0].pName ) + 1) *
                                      sizeof( WCHAR ) );
    if (pwzOutgoingDomainDn == NULL) {
        PrintMessage( SEV_ALWAYS, L"Memory allocation failure\n" );
        goto cleanup;
    }
    wcscpy( pwzOutgoingDomainDn, pResult->rItems[0].pName );

    PrintMessage( SEV_ALWAYS, L"The distinguished name of the domain is %s.\n",
                  pwzOutgoingDomainDn );

cleanup:

    if (pwzTempDnsName != NULL) {
        LocalFree( pwzTempDnsName );
    }
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
    }
    if (pResult != NULL) {
        DsFreeNameResultW(pResult);
    }

    if (pwzOutgoingDomainDn == NULL) {
        PrintMessage( SEV_ALWAYS,
                      L"The specified naming context is incorrect and will be ignored.\n" );
    }

    return pwzOutgoingDomainDn;

} /* convertDomainNcToDN */

void
DoNonDcTests(
    PWSTR pwzComputer,
    ULONG ulFlags, // currently ignored, the DC_DIAG_FIX value may be needed later
    PWSTR * ppszDoTests,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    WCHAR * ppszExtraCommandLineArgs[])
/*++

Routine Description:

Runs the tests that are designed for machines that are not DCs.

Arguments:

--*/
{
    DC_DIAG_DSINFO dsInfo;
    BOOL fPerform;
    ULONG iTest = 0L;
    DWORD dwWin32Err = ERROR_SUCCESS;

    if (pwzComputer)
    {
        PrintMsg(SEV_ALWAYS, DCDIAG_DONT_USE_SERVER_PARAM);
        return;
    }

    pwzComputer = findDefaultServer(FALSE);

    if (!pwzComputer)
    {
        return;
    }

    dsInfo.pszNC = pwzComputer; // pass the computer name into the test function.
    // Set the Extra Command parameters
    dsInfo.ppszCommandLine = ppszExtraCommandLineArgs;

    for (gMainInfo.lTestAt = 0L; allTests[gMainInfo.lTestAt].testId != DC_DIAG_ID_FINISHED; gMainInfo.lTestAt++)
    {
        Assert(ppszDoTests);

        fPerform = FALSE;

        for (iTest = 0L; ppszDoTests[iTest] != NULL; iTest++)
        {
            if (_wcsicmp(ppszDoTests[iTest],
                         allTests[gMainInfo.lTestAt].pszTestName) == 0)
            {
                Assert(NON_DC_TEST & allTests[gMainInfo.lTestAt].ulTestFlags);
                fPerform = TRUE;
            }
        }

        // Perform the test if appropriate ------------------------------------
        if (fPerform)
        {
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"Starting test: %s\n",
                         allTests[gMainInfo.lTestAt].pszTestName);

            dwWin32Err = DcDiagRunTest(&dsInfo,
                                       0,
                                       gpCreds,
                                       &allTests[gMainInfo.lTestAt]);
            PrintIndentAdj(1);

            if(dwWin32Err == NO_ERROR){
                PrintMessage(SEV_NORMAL,
                             L"......................... %s passed test %s\n",
                             pwzComputer, allTests[gMainInfo.lTestAt].pszTestName);
            } else {
                PrintMessage(SEV_ALWAYS,
                             L"......................... %s failed test %s\n",
                             pwzComputer, allTests[gMainInfo.lTestAt].pszTestName);
            }
            PrintIndentAdj(-1);
            PrintIndentAdj(-1);
        } // end fPeform ...
    }

    LocalFree(pwzComputer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\common\print.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    print.c

ABSTRACT:

DETAILS:

CREATED:

    1999 May 6  JeffParh
        Lifted from netdiag\results.c.

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include "dcdiag.h"
#include "debug.h"

static WCHAR s_szBuffer[4096];
static WCHAR s_szFormat[4096];
static WCHAR s_szSpaces[] = L"                                                                                               ";

#ifndef DimensionOf
#define DimensionOf(x) (sizeof(x)/sizeof((x)[0]))
#endif

void
PrintMessage(
    IN  ULONG   ulSev,
    IN  LPCWSTR pszFormat,
    IN  ...
    )

/*++

Routine Description:

Print a message with a printf-style format 

Arguments:

    ulSev - 
    pszFormat - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    va_list args;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    va_start(args, pszFormat);
    
    nBuf = vswprintf(s_szBuffer, pszFormat, args);
    Assert(nBuf < DimensionOf(s_szBuffer));
    
    va_end(args);
    
    PrintMessageSz(ulSev, s_szBuffer);
} /* PrintMessage */

void
PrintMessageID(
    IN  ULONG   ulSev,
    IN  ULONG   uMessageID,
    IN  ...
    )

/*++

Routine Description:

Print a message, where a printf-style format string comes from a resource file

Arguments:

    ulSev - 
    uMessageID - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    va_list args;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    va_start(args, uMessageID);
    
    LoadStringW(NULL, uMessageID, s_szFormat, DimensionOf(s_szFormat));
    
    nBuf = vswprintf(s_szBuffer, s_szFormat, args);
    Assert(nBuf < DimensionOf(s_szBuffer));
    
    va_end(args);
    
    PrintMessageSz(ulSev, s_szBuffer);
} /* PrintMessageID */

void
PrintMessageMultiLine(
    IN  ULONG    ulSev,
    IN  LPWSTR   pszMessage,
    IN  BOOL     bTrailingLineReturn
    )
/*++

Routine Description:

Take a multi-line buffer such as
line\nline\nline\n\0
and call PrintMessageSz on each line

Arguments:

    ulSev - 
    pszMessage - 

Return Value:

--*/

{
    LPWSTR start, end;
    WCHAR wchSave;

    start = end = pszMessage;
    while (1) {
        while ( (*end != L'\n') && (*end != L'\0') ) {
            end++;
        }

        if (*end == L'\0') {
            // Line ends prematurely, give it a nl
            if(bTrailingLineReturn){
                *end++ = L'\n';
                *end = L'\0';
            }
            PrintMessageSz(ulSev, start);
            break;
        }

        // Line has newline at end
        end++;
        if (*end == L'\0') {
            // Is the last line
            PrintMessageSz(ulSev, start);
            break;
        }

        // Next line follows
        // Simulate line termination temporarily
        wchSave = *end;
        *end = L'\0';
        PrintMessageSz(ulSev, start);
        *end = wchSave;

        start = end;
    }
} /* PrintMessageMultiLine */

void
formatMsgHelp(
    IN  ULONG   ulSev,
    IN  DWORD   dwWidth,
    IN  DWORD   dwMessageCode,
    IN  va_list *vaArgList
    )

/*++

Routine Description:

Print a message where the format comes from a message file. The message in the
message file does not use printf-style formatting. Use %1, %2, etc for each
argument. Use %<arg>!printf-format! for non string inserts.

Note that this routine also forces each line to be the current indention width.
Also, each line is printed at the right indentation.

Arguments:

    ulSev - 
    dwWidth - 
    dwMessageCode - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    // Format message will store a multi-line message in the buffer
    nBuf = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | (FORMAT_MESSAGE_MAX_WIDTH_MASK & dwWidth),
        0,
        dwMessageCode,
        0,
        s_szBuffer,
        DimensionOf(s_szBuffer),
        vaArgList );
    if (nBuf == 0) {
        nBuf = wsprintf( s_szBuffer, L"Message 0x%x not found.\n",
                         dwMessageCode );
        Assert(!"There is a message constant being used in the code"
               "that isn't in the message file dcdiag\\common\\msg.mc"
               "Take a stack trace and send to owner of dcdiag.");
    }
    Assert(nBuf < DimensionOf(s_szBuffer));
} /* PrintMsgHelp */

void
PrintMsg(
    IN  ULONG   ulSev,
    IN  DWORD   dwMessageCode,
    IN  ...
    )

/*++

Routine Description:

Wrapper around PrintMsgHelp with width restrictions.
This is the usual routine to use.

Arguments:

    ulSev - 
    dwMessageCode - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    DWORD cNumSpaces, width;
    va_list args;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    cNumSpaces = gMainInfo.iCurrIndent * 3;
    width = gMainInfo.dwScreenWidth - cNumSpaces;

    va_start(args, dwMessageCode);

    formatMsgHelp( ulSev, width, dwMessageCode, &args );

    va_end(args);
    
    PrintMessageMultiLine(ulSev, s_szBuffer, TRUE);
} /* PrintMsg */

void
PrintMsg0(
    IN  ULONG   ulSev,
    IN  DWORD   dwMessageCode,
    IN  ...
    )

/*++

Routine Description:

Wrapper around PrintMsgHelp with no width restrictions nor
indentation.

Arguments:

    ulSev - 
    dwMessageCode - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    int iSaveIndent;
    va_list args;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    va_start(args, dwMessageCode);

    formatMsgHelp( ulSev, 0, dwMessageCode, &args );

    va_end(args);
    
    // Suppress indentation
    iSaveIndent = gMainInfo.iCurrIndent;
    gMainInfo.iCurrIndent = 0;

    PrintMessageMultiLine(ulSev, s_szBuffer, FALSE);

    // Restore indentation
    gMainInfo.iCurrIndent = iSaveIndent;

} /* PrintMsg0 */

void
PrintMessageSz(
    IN  ULONG   ulSev,
    IN  LPCTSTR pszMessage
    )

/*++

Routine Description:

Print a single indented line from a buffer to the output stream

Arguments:

    ulSev - 
    pszMessage - 

Return Value:

--*/

{
    DWORD cNumSpaces;
    DWORD iSpace;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    // Include indentation.
    cNumSpaces = gMainInfo.iCurrIndent * 3;
    Assert(cNumSpaces < DimensionOf(s_szSpaces));

    iSpace = DimensionOf(s_szSpaces) - cNumSpaces - 1;

    if (stdout == gMainInfo.streamOut) {
        wprintf(L"%s%s", &s_szSpaces[iSpace], pszMessage);
        fflush(stdout);
    }
    else {
        fwprintf(gMainInfo.streamOut, 
                 L"%s%s", &s_szSpaces[iSpace], pszMessage);
    }
} /* PrintMessageSz */

BOOL IsRPCError(DWORD dwErr)

/*++

Routine Description:

Checks if the error code is in the range of Win32 RPC errors as defined in winerror.h.
This is a discontiguous range, thus the several comparisons.
Does not check HRESULTs.

--*/

{
   if (RPC_S_INVALID_STRING_BINDING <= dwErr &&
       RPC_X_BAD_STUB_DATA >= dwErr)
   {
      return TRUE;
   }
   if (RPC_S_CALL_IN_PROGRESS == dwErr ||
       RPC_S_NO_MORE_BINDINGS == dwErr)
   {
      return TRUE;
   }
   if (RPC_S_NO_INTERFACES <= dwErr &&
       RPC_S_INVALID_OBJECT >= dwErr)
   {
      return TRUE;
   }
   if (RPC_S_SEND_INCOMPLETE <= dwErr &&
       RPC_X_PIPE_EMPTY >= dwErr)
   {
      return TRUE;
   }
   if (RPC_S_ENTRY_TYPE_MISMATCH <= dwErr &&
       RPC_S_GRP_ELT_NOT_REMOVED >= dwErr)
   {
      return TRUE;
   }

   return FALSE;
}


void
PrintRpcExtendedInfo(
    IN  ULONG   ulSev,
    IN  DWORD   dwMessageCode
    )

/*++

Routine Description:

If dwMessageCode is an RPC error, check to see if there is RPC extended error
information and if so print it.

Arguments:

    ulSev - 
    dwMessageCode - 

Return Value: none

--*/

{
    RPC_STATUS Status2;
    RPC_ERROR_ENUM_HANDLE EnumHandle;

    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    if (!IsRPCError(dwMessageCode))
    {
        return;
    }

    Status2 = RpcErrorStartEnumeration(&EnumHandle);

    if (Status2 == RPC_S_ENTRY_NOT_FOUND)
    {
        // there is no extended error information.
        //
        PrintMessage(ulSev, L"RPC Extended Error Info not available. Use group policy on the local machine at \"Computer Configuration/Administrative Templates/System/Remote Procedure Call\" to enable it.\n");
    }
    else if (Status2 != RPC_S_OK)
    {
        PrintMessage(ulSev, L"Couldn't get RPC Extended Error Info: %d\n", Status2);
    }
    else
    {
        RPC_EXTENDED_ERROR_INFO ErrorInfo = {0};
        BOOL Result = FALSE;
        SYSTEMTIME SystemTimeBuffer = {0};
        int nRec = 0;

        PrintMessage(ulSev, L"Printing RPC Extended Error Info:\n");

        while (Status2 == RPC_S_OK)
        {
            ErrorInfo.Version = RPC_EEINFO_VERSION;
            ErrorInfo.Flags = EEInfoUseFileTime;
            ErrorInfo.NumberOfParameters = 4;

            Status2 = RpcErrorGetNextRecord(&EnumHandle, TRUE, &ErrorInfo);
            if (Status2 == RPC_S_ENTRY_NOT_FOUND)
            {
                break;
            }
            else if (Status2 != RPC_S_OK)
            {
                PrintMessage(ulSev, L"Couldn't finish RPC extended error enumeration: %d\n", Status2);
                break;
            }
            else
            {
                PWSTR pwz = NULL;
                BOOL fFreeString = FALSE;
                int i = 0;

                PrintMessage(ulSev, L"Error Record %d, ProcessID is %d", ++nRec,
                             ErrorInfo.ProcessID);
                if (GetCurrentProcessId() == ErrorInfo.ProcessID)
                {
                   int iOld = PrintIndentSet(0);
                   PrintMessage(ulSev, L" (DcDiag)");
                   PrintIndentSet(iOld);
                }
                PrintMessage(ulSev, L"\n");
                if (ErrorInfo.ComputerName)
                {
                    PrintMessage(ulSev, L"ComputerName is %S\n", ErrorInfo.ComputerName);
                    Result = HeapFree(GetProcessHeap(), 0, ErrorInfo.ComputerName);
                    ASSERT(Result);
                }

                PrintIndentAdj(1);

                Result = FileTimeToSystemTime(&ErrorInfo.u.FileTime, 
                                              &SystemTimeBuffer);
                ASSERT(Result);

                PrintMessage(ulSev, L"System Time is: %d/%d/%d %d:%d:%d:%d\n", 
                    SystemTimeBuffer.wMonth,
                    SystemTimeBuffer.wDay,
                    SystemTimeBuffer.wYear,
                    SystemTimeBuffer.wHour,
                    SystemTimeBuffer.wMinute,
                    SystemTimeBuffer.wSecond,
                    SystemTimeBuffer.wMilliseconds);
                switch (ErrorInfo.GeneratingComponent)
                {
                case 1:
                   pwz = L"this application";
                   break;
                case 2:
                   pwz = L"RPC runtime";
                   break;
                case 3:
                   pwz = L"security provider";
                   break;
                case 4:
                   pwz = L"NPFS file system";
                   break;
                case 5:
                   pwz = L"redirector";
                   break;
                case 6:
                   pwz = L"named pipe system";
                   break;
                case 7:
                   pwz = L"IO system or driver";
                   break;
                case 8:
                   pwz = L"winsock";
                   break;
                case 9:
                   pwz = L"authorization API";
                   break;
                case 10:
                   pwz = L"LPC facility";
                   break;
                default:
                   pwz = L"unknown";
                   break;
                }
                PrintMessage(ulSev, L"Generating component is %d (%s)\n",
                    ErrorInfo.GeneratingComponent, pwz);
                fFreeString = FALSE;
                if (ErrorInfo.Status)
                {
                    pwz = NULL;
                    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                  FORMAT_MESSAGE_FROM_SYSTEM,
                                  NULL,
                                  ErrorInfo.Status,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  (PWSTR)&pwz,
                                  0,
                                  NULL);
                    if (!pwz)
                    {
                       pwz = L"unknown\n";
                    }
                    else
                    {
                       fFreeString = TRUE;
                    }
                }
                else
                {
                   pwz = L"no error\n";
                }
                PrintMessage(ulSev, L"Status is %d: %s", ErrorInfo.Status, pwz);
                if (ErrorInfo.Status && fFreeString)
                {
                    LocalFree(pwz);
                }
                PrintMessage(ulSev, L"Detection location is %d\n", 
                    (int)ErrorInfo.DetectionLocation);
                if (ErrorInfo.Flags)
                {
                   PrintMessage(ulSev, L"Flags is %d\n", ErrorInfo.Flags);
                   if (ErrorInfo.Flags & EEInfoPreviousRecordsMissing)
                      PrintMessage(ulSev, L"1: previous EE info records are missing\n");
                   if (ErrorInfo.Flags & EEInfoNextRecordsMissing)
                      PrintMessage(ulSev, L"2: next EE info records are missing\n");
                   if (ErrorInfo.Flags & EEInfoUseFileTime)
                      PrintMessage(ulSev, L"4: use file time\n");
                }
                if (ErrorInfo.NumberOfParameters)
                {
                    PrintMessage(ulSev, L"NumberOfParameters is %d\n", 
                        ErrorInfo.NumberOfParameters);
                    for (i = 0; i < ErrorInfo.NumberOfParameters; i ++)
                    {
                        switch(ErrorInfo.Parameters[i].ParameterType)
                        {
                            case eeptAnsiString:
                                PrintMessage(ulSev, L"Ansi string: %S\n", 
                                    ErrorInfo.Parameters[i].u.AnsiString);
                                Result = HeapFree(GetProcessHeap(), 0, 
                                    ErrorInfo.Parameters[i].u.AnsiString);
                                ASSERT(Result);
                                break;
 
                            case eeptUnicodeString:
                                PrintMessage(ulSev, L"Unicode string: %s\n", 
                                    ErrorInfo.Parameters[i].u.UnicodeString);
                                Result = HeapFree(GetProcessHeap(), 0, 
                                    ErrorInfo.Parameters[i].u.UnicodeString);
                                ASSERT(Result);
                                break;
 
                            case eeptLongVal:
                                PrintMessage(ulSev, L"Long val: %d\n", 
                                    ErrorInfo.Parameters[i].u.LVal);
                                break;
 
                            case eeptShortVal:
                                PrintMessage(ulSev, L"Short val: %d\n", 
                                    (int)ErrorInfo.Parameters[i].u.SVal);
                                break;
 
                            case eeptPointerVal:
                                PrintMessage(ulSev, L"Pointer val: %d\n", 
                                    ErrorInfo.Parameters[i].u.PVal);
                                break;
 
                            case eeptNone:
                                PrintMessage(ulSev, L"Truncated\n");
                                break;
 
                            default:
                                PrintMessage(ulSev, L"Invalid type: %d\n", 
                                    ErrorInfo.Parameters[i].ParameterType);
                        }
                    }
                }

                PrintIndentAdj(-1);
            }
        }

        RpcErrorEndEnumeration(&EnumHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\common\references.c ===
/*++

Copyright (c) 2001 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dcdiag/common/references.c

ABSTRACT:

    This is file implements the references library/API which gives the
    programmer a standard table driven way to drive a refernces check.
    The first example of useage is dcdiag/frs/frsref.c

DETAILS:

CREATED:

    11/15/2001    Brett Shirley (brettsh)
    
        Created file, wrote API.

REVISION HISTORY:


--*/

#include <ntdspch.h>
#include <objids.h>
#include <ntldap.h>

#include "dcdiag.h"

#include "ndnc.h"
#include "utils.h"
#include "ldaputil.h"
#include "references.h"

#ifdef DBG
extern BOOL  gDsInfo_NcList_Initialized;
#endif

// Since these controls are all constant, better to define them here, 
// rather than set them up in EngineHelperDoSearch() which is executed
// many times.
LDAPControlW   ExtDNControl = {LDAP_SERVER_EXTENDED_DN_OID_W, {0, NULL}, TRUE};
PLDAPControlW  apExtDNControls [] = {&ExtDNControl, NULL};

DWORD
EngineHelperDoSearch(
    LDAP *               hLdap,
    LPWSTR               szSource,
    LPWSTR               szAttr,
    BOOL                 fRetrieveGuidAndSid,
    LPWSTR **            ppszValues
    )
/*++

Routine Description:
    
    This does a simple base search of szSource and returns the values of szAttr
    in ppszValues.
    
Arguments:

    hLdap - Open LDAP binding.
    szSource - DN of Base search
    szAttr - Attribute we're looking for.
    ppszValues - Where to return the values.

Return Value:

    An LDAP Error, if we failed to get the search results.  Note, we
    return success if 

--*/
{
    DWORD                dwLdapErr;
    LPWSTR               aszAttrs[2];
    LDAPMessage *        pldmResults = NULL;
    LDAPMessage *        pldmEntry;

    Assert(ppszValues && (*ppszValues == NULL));
    *ppszValues = NULL;

    aszAttrs[0] = szAttr;
    aszAttrs[1] = NULL;

    dwLdapErr = ldap_search_ext_sW(hLdap,
                                   szSource,
                                   LDAP_SCOPE_BASE,
                                   L"(objectCategory=*)",
                                   aszAttrs,
                                   FALSE,
                                   (fRetrieveGuidAndSid) ? 
                                       (PLDAPControlW *) &apExtDNControls :
                                       NULL ,
                                   NULL,
                                   NULL,
                                   0,
                                   &pldmResults);

    if (dwLdapErr == LDAP_SUCCESS) {

        pldmEntry = ldap_first_entry(hLdap, pldmResults);
        if (pldmEntry != NULL) {

            *ppszValues = ldap_get_valuesW(hLdap, pldmEntry, szAttr);
            if (*ppszValues == NULL) {
                dwLdapErr = LDAP_NO_SUCH_ATTRIBUTE;
            }
        } else {
            dwLdapErr = LDAP_NO_RESULTS_RETURNED;
        }
    }

    if (pldmResults != NULL) {
        ldap_msgfree(pldmResults);
    }

    return(dwLdapErr);
}


void
ReferentialIntegrityEngineCleanTable(
    ULONG                cLinks,
    REF_INT_LNK_TABLE    aLink
    )
/*++

Routine Description:

    This routine takes a table that has been filled in by 
    ReferentialIntegrityEngine(), and cleans it by deallocated
    any allocated memory and resetting all result codes.
    
Arguments:

    cLinks - Number of entries in the table.
    aLink - Table

Return Value:

    None.

--*/
{
    ULONG iLink;

    for (iLink = 0; iLink < cLinks; iLink++) {

        // Clean the entry.
        if (aLink[iLink].pszValues) {
            ldap_value_freeW(aLink[iLink].pszValues);
            aLink[iLink].pszValues = NULL;
        }
        aLink[iLink].dwResultFlags = 0;
        if (aLink[iLink].szExtra) {
            LocalFree(aLink[iLink].szExtra);
            aLink[iLink].szExtra = NULL;
        }

    }
}

DWORD
ReferentialIntegrityEngine(
    PDC_DIAG_SERVERINFO  pServer,
    LDAP *               hLdap,
    BOOL                 bIsGc,
    ULONG                cLinks,
    REF_INT_LNK_TABLE    aLink
    )
/*++

Routine Description:

    This is the main function for this API.  The user generates a table
    of tests this function (The Engine) is supposed to run.  The Engine
    runs the test and accumulates the results in the table.  The function
    VerifySystemReferences() in dcdiag\frs\frsref.c is an excellent
    example of how to use this Engine.
    
Arguments:

    pServer - The server we're bound to
    hLdap - LDAP Binding to the server
    bIsGc - Whether the server is a GC.
    cLinks - Number of entries in the table
    aLink - The table itself


Return Value:

    A Win32 Error if there was a critical failure that the Engine couldn't fill
    out the rest of the table.  Note, that irrelevant of what is returned, the
    caller should free any memory allocated in the aLink table with
    ReferentialIntegrityEngineCleanTable().

--*/
{
    ULONG        iLink, iValue, iResultValue, iBackLinkValue;
    ULONG        cbSize;
    ULONG        dwLdapErr = LDAP_SUCCESS;
    LPWSTR       szTrueSource = NULL;
    LPWSTR       szTrueAttr   = NULL;
    LPWSTR       szTemp;
    LPWSTR       szCurrentValue;
    // LPWSTR  szTemp; Don't think we need this anymore
    LPWSTR *     pszBackLinkValues = NULL;
    BOOL         fSourceAllocated = FALSE;
    DWORD        bMangled;
    MANGLE_FOR   eMangle;


    for (iLink = 0; iLink < cLinks; iLink++) {

        //
        // A little validation of the entry.
        //
        Assert((aLink[iLink].dwFlags & REF_INT_TEST_FORWARD_LINK) ||
               (aLink[iLink].dwFlags & REF_INT_TEST_BACKWARD_LINK));
        Assert(aLink[iLink].pszValues == NULL); // if this fires, we'll be leaking memory
        Assert(aLink[iLink].szExtra == NULL);

        //
        // Ensure, nulled out the return parameters
        //
        aLink[iLink].dwResultFlags = 0;
        aLink[iLink].pszValues = NULL;
        aLink[iLink].szExtra = NULL;

        // Setup, the loop properly.
        fSourceAllocated = FALSE;

        for (iValue = 0; TRUE; iValue++) {

            // -------------------------------------------------------------
            //
            //    I  -  figure out base source DN.
            //

            if (aLink[iLink].dwFlags & REF_INT_TEST_SRC_BASE) {
                if (iValue > 0) {
                    // If we're pulling this from the rootDSE, there's only one 
                    // value (the rootDSE).  This is first of three normal exit
                    // paths.
                    break;
                }
                szTrueSource = NULL;
            } else if (aLink[iLink].dwFlags & REF_INT_TEST_SRC_STRING) {
                if (iValue > 0) {
                    // If we're pulling this from the string, there's only one 
                    // value.  This is second normal exit path.
                    break;
                }
                szTrueSource = aLink[iLink].szSource;
            } else { // must be REF_INT_TEST_SRC_INDEX
                Assert(aLink[iLink].dwFlags & REF_INT_TEST_SRC_INDEX);

                Assert(iLink < cLinks);
                if (aLink[iLink].iSource < iLink) {
                    if (aLink[aLink[iLink].iSource].dwResultFlags & REF_INT_RES_ERROR_RETRIEVING) {
                        aLink[iLink].dwResultFlags |= REF_INT_RES_DEPENDENCY_FAILURE;
                        break;
                    }
                    if (aLink[aLink[iLink].iSource].pszValues == NULL) {
                        Assert(!"The Engine should have caught this, and set ERROR_RETRIEVING in dwResultFlags");
                        aLink[iLink].dwResultFlags |= REF_INT_RES_DEPENDENCY_FAILURE;
                        break;
                    }
                    szTrueSource = aLink[aLink[iLink].iSource].pszValues[iValue];
                    if (szTrueSource == NULL) {
                        // End of values so quit inner loop, and try next 
                        // entry in aLink.  This is the third and last normal 
                        // exit path.
                        break;
                    }
                } else {
                    Assert(!"Invalid parameter, No forwarding point iSources. We can't use an entry for a source that we haven't even filled in yet.");
                    return(ERROR_INVALID_PARAMETER);
                }
            }
            
            // Code.Improvement or BUGBUG you decide...
            // So this code, does deal correctly with multiple values, but not 
            // very cleanly.  The problem comes from the fact that we have a 
            // single aLink[iLink].dwResultFlags for possibly many values in 
            // aLink[aLink[iLink].iSource].pszValues which we're checking the
            // back links of.  If this is acceptable then remove this assert() 
            // and use this code, if not then one should add an array 
            // .adwResultFlags and array a results (.pszValues) for each value.
            Assert(iValue == 0);
            
            // -------------------------------------------------------------
            //
            //    II  -  modify base source DN.
            //

            __try {

                // If we need to modify this source DN let do so.
                aLink[iLink].szExtra = NULL;
                if (aLink[iLink].cTrimBy || aLink[iLink].szSrcAddl) {

                    if (szTrueSource == NULL) {
                        Assert(!"You can't trim to the root DN, if you want to add RDNs to the base, just use .szExtra");
                        DcDiagException(ERROR_INVALID_PARAMETER);
                    }

                    // First, allocate enough memory, for worst case
                    cbSize = sizeof(WCHAR) * (wcslen(szTrueSource) + 
                               ((aLink[iLink].szSrcAddl) ? wcslen(aLink[iLink].szSrcAddl) : 0) +
                               1);
                    aLink[iLink].szExtra = LocalAlloc(LMEM_FIXED, cbSize);
                    if (aLink[iLink].szExtra == NULL) {
                        DcDiagException(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    fSourceAllocated = TRUE;

                    szTemp = NULL;
                    // Optionally trim some RDNs off the DN, put in szTemp
                    if (aLink[iLink].cTrimBy) {
                        // We rely on DcDiagTrimStringDnBy() to not actually 
                        // modify the original string, but allocate a new one,
                        // which it seems to do.
                        szTemp = DcDiagTrimStringDnBy(szTrueSource, aLink[iLink].cTrimBy);
                        if (szTemp == NULL) {
                            DcDiagException(ERROR_NOT_ENOUGH_MEMORY); // Or maybe invalid DN
                        }
                    } else {
                        // If nothing to trim, use original source.
                        szTemp = szTrueSource;
                    }
                    Assert(szTemp);

                    // Optionally add some fixed DN to the DN.
                    if (aLink[iLink].szSrcAddl) {
                        wcscpy(aLink[iLink].szExtra, aLink[iLink].szSrcAddl);
                        wcscat(aLink[iLink].szExtra, szTemp);
                        if (aLink[iLink].cTrimBy) {
                            LocalFree(szTemp);
                        }
                    } else {
                        Assert(aLink[iLink].cTrimBy);
                        wcscpy(aLink[iLink].szExtra, szTemp);
                        LocalFree(szTemp);
                    }

                    // Finally, move the new modified source to szTrueSource.
                    szTrueSource = aLink[iLink].szExtra;
                }
                Assert( (aLink[iLink].dwFlags & REF_INT_TEST_SRC_BASE) || szTrueSource);


                // -------------------------------------------------------------
                //
                //    III  -  get some information from LDAP
                //

                Assert( (aLink[iLink].dwFlags & REF_INT_TEST_FORWARD_LINK && 
                         aLink[iLink].szFwdDnAttr) ||
                        (aLink[iLink].dwFlags & REF_INT_TEST_BACKWARD_LINK &&
                         aLink[iLink].szBwdDnAttr) );
                Assert( !(aLink[iLink].dwFlags & REF_INT_TEST_BOTH_LINKS) ||
                        (aLink[iLink].szFwdDnAttr && aLink[iLink].szBwdDnAttr) );

                // Do a search of szTrueSource for the attribute
                dwLdapErr = EngineHelperDoSearch(hLdap,
                                                 szTrueSource,
                                                 ((aLink[iLink].dwFlags & REF_INT_TEST_FORWARD_LINK) ?
                                                     aLink[iLink].szFwdDnAttr :
                                                     aLink[iLink].szBwdDnAttr),
                                                 (aLink[iLink].dwFlags & REF_INT_TEST_GUID_AND_SID),
                                                 &(aLink[iLink].pszValues));
                if (dwLdapErr || 
                    (aLink[iLink].pszValues == NULL)) {
                    Assert(dwLdapErr); // Shouldn't return unless we returned via error.

                    if (dwLdapErr == LDAP_NO_SUCH_ATTRIBUTE ||
                        dwLdapErr == LDAP_NO_SUCH_OBJECT
                        // We may need to add the LDAP_REFERRALS errors
                        ) {

                        // These are not critical errors, but expected failures.
                        dwLdapErr = LDAP_SUCCESS;
                    }
                    aLink[iLink].dwResultFlags |= REF_INT_RES_ERROR_RETRIEVING;
                    __leave;
                }

                // -------------------------------------------------------------
                //
                //    III  -  analyse LDAP data
                //

                if (aLink[iLink].pszValues[0] == NULL) {
                    aLink[iLink].dwResultFlags |= REF_INT_RES_ERROR_RETRIEVING; 
                    __leave;
                }
                //
                // Walk results values.
                for(iResultValue = 0; aLink[iLink].pszValues[iResultValue]; iResultValue++){

                    // Check three things:
                    //      Is the DN delete mangled.
                    //      Is the DN conflict mangled.
                    //      Does the DN have a matching backlink value.

                    // Code.Improvement these only checks the top most RDN, whereas 
                    // we really want to check the whole DN or each RDN.

                    if (aLink[iLink].dwFlags & REF_INT_TEST_GUID_AND_SID) {
                        szCurrentValue = NULL;
                        LdapGetStringDSNameComponents(aLink[iLink].pszValues[iResultValue],
                                                      NULL, NULL, &szCurrentValue);
                        Assert(szCurrentValue);
                    } else {
                        szCurrentValue = aLink[iLink].pszValues[iResultValue];
                    }

                    bMangled = DcDiagIsStringDnMangled(szCurrentValue, &eMangle);

                    if (bMangled) {
                        if (eMangle == MANGLE_OBJECT_RDN_FOR_DELETION ||
                            eMangle == MANGLE_PHANTOM_RDN_FOR_DELETION) {
                            aLink[iLink].dwResultFlags |= REF_INT_RES_DELETE_MANGLED;
                        } else if (eMangle == MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT ||
                                   eMangle == MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT) {
                            aLink[iLink].dwResultFlags |= REF_INT_RES_CONFLICT_MANGLED;
                        } else {
                            Assert(!"Hmmm, unknown mangle type.");
                        }
                    }
                    if(aLink[iLink].dwFlags & REF_INT_TEST_BOTH_LINKS){

                        // Do base ldap search for the value in szCurrentValue
                        // and for the opposite link we picked for the primary search.
                        pszBackLinkValues = NULL;
                        dwLdapErr = EngineHelperDoSearch(hLdap,
                                                         szCurrentValue,
                                                         ((aLink[iLink].dwFlags & REF_INT_TEST_FORWARD_LINK) ?
                                                             aLink[iLink].szBwdDnAttr :
                                                             aLink[iLink].szFwdDnAttr),
                                                         FALSE,
                                                         &pszBackLinkValues);
                        if (dwLdapErr ||
                            (pszBackLinkValues == NULL) ) {
                            
                            aLink[iLink].dwResultFlags |= REF_INT_RES_BACK_LINK_NOT_MATCHED;
                        } else {
                            // If there was no error, search through the back link 
                            // values making sure there is a match.
                            for (iBackLinkValue = 0; pszBackLinkValues[iBackLinkValue]; iBackLinkValue++) {
                                if (DcDiagEqualDNs(szTrueSource,
                                                   pszBackLinkValues[iBackLinkValue]) ) {
                                    break; // Break early we found a matching back link.
                                }
                            }
                            if (pszBackLinkValues[iBackLinkValue] == NULL) {
                                // We know we walked all the pszBackLinkValues without
                                // finding a match.
                                aLink[iLink].dwResultFlags |= REF_INT_RES_BACK_LINK_NOT_MATCHED;
                            }
                        }
                        dwLdapErr = LDAP_SUCCESS;
                        if (pszBackLinkValues != NULL) { 
                            ldap_value_freeW(pszBackLinkValues);
                        }
                        pszBackLinkValues = NULL;

                    } // End if check back link as well

                }  // End iResultValue loop
            
            } __finally {

                if (fSourceAllocated) {
                    Assert(aLink[iLink].szExtra &&
                           szTrueSource == aLink[iLink].szExtra);
                    if (aLink[iLink].szExtra) {
                        LocalFree(aLink[iLink].szExtra);
                        aLink[iLink].szExtra = NULL;
                        szTrueSource = NULL;
                        fSourceAllocated = FALSE;
                    }
                }

            }

        } // End iValue for loop

    } // For each link table entry

    return(LdapMapErrorToWin32(dwLdapErr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\common\registry.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    common\registry.c

ABSTRACT:

    This gives a library of functions to quickly grab registry
    values from remote machines.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <dsconfig.h>

#include "dcdiag.h"
#include "utils.h"

DWORD
GetRegistryDword(
    PDC_DIAG_SERVERINFO             pServer,
    SEC_WINNT_AUTH_IDENTITY_W *     pCreds,
    LPWSTR                          pszRegLocation,
    LPWSTR                          pszRegParameter,
    PDWORD                          pdwResult
    )
/*++

Routine Description:

    This function will give us a registry dword from the place specified.

Arguments:

    pServer - The server to grab the reg value off of.
    pszRegLocation - The location in the registry.
    pszRegParameter - The parameter in this location of the registry
    pdwResult - The return parameter, will not be set if there is an error.

Return Value:

    A win 32 Error, if it is ERROR_SUCCESS, then pdwResult will have been set.

--*/
{
    DWORD                           dwRet;
    HKEY                            hkMachine = NULL;
    HKEY                            hk = NULL;
    DWORD                           dwType;
    DWORD                           dwSize = sizeof(DWORD);
    ULONG                           ulTemp;
    LPWSTR                          pszMachine = NULL;

    __try {

        dwRet = DcDiagGetNetConnection(pServer, pCreds);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }

        // 2 for "\\", 1 for null, and 1 extra
        ulTemp = wcslen(pServer->pszName) + 4;

        pszMachine = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulTemp);
        if(pszMachine == NULL){
            dwRet = GetLastError();
            __leave;
        }

        wcscpy(pszMachine, L"\\\\");
        wcscat(pszMachine, pServer->pszName);
        dwRet = RegConnectRegistry(pszMachine, HKEY_LOCAL_MACHINE, &hkMachine);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }

        dwRet = RegOpenKey(hkMachine, pszRegLocation, &hk);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }

        dwRet = RegQueryValueEx(hk,    // handle of key to query        
                                pszRegParameter,   // value name            
                                NULL,                 // must be NULL          
                                &dwType,              // address of type value 
                                (LPBYTE) pdwResult,     // address of value data 
                                &dwSize);           // length of value data
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }
        if(dwType != REG_DWORD){
            dwRet = ERROR_INVALID_PARAMETER;
            __leave;
        }

        // finally success ... pdwResult should be set.
        
    } __finally {
        if(hkMachine) { RegCloseKey(hkMachine); }
        if(hk) { RegCloseKey(hk); }
        if(pszMachine) { LocalFree(pszMachine); }
    }

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\dns\dnsmain.c ===
//+----------------------------------------------------------------------------  
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dnsmain.c

ABSTRACT:

    DNS tests for dcdiag.exe.

DETAILS:

    DrDNS tests as specified by LevonE

CREATED:

    20-Apr-2000 EricB

--*/
//-----------------------------------------------------------------------------  

#include <ntdspch.h>
#include <iphlpapi.h>
#include <dsrole.h>
#include <windns.h>
#include "dcdiag.h"
#include "alltests.h"

// From dnsapi.h; don't want to include the whole header since there are conflicts
// with windns.h on 2195.
//
typedef IP4_ARRAY   IP_ARRAY, *PIP_ARRAY;

DNS_STATUS
WINAPI
DnsUpdateTest_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  LPWSTR      pszName,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

// globals and constants.
//
const int DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8 = 155; // from dcpromo\exe\headers.hxx
const PWSTR g_pwzSrvRecordPrefix = L"_ldap._tcp.dc._msdcs.";
const PWSTR g_pwzMSDCS = L"_msdcs.";
const PWSTR g_pwzSites = L"_sites.";
const PWSTR g_pwzTcp = L"_tcp.";
const PWSTR g_pwzUdp = L"_udp.";
const PWSTR g_pwzTcpIpParams = L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters";

#define DCDIAG_MAX_ADDR 4 // arbitrary, but not likely to find a machine with more
#define DCDIAG_LOOPBACK_ADDR 0x100007f

BOOL g_fUpgradedNT4DC = FALSE;
BOOL g_fDC = FALSE;
BOOL g_fDNSserver = FALSE;
DWORD g_rgIpAddr[DCDIAG_MAX_ADDR] = {0};

// extract IP octects from a DWORD
#define FIRST_IPADDRESS(x)  ((x>>24) & 0xff)
#define SECOND_IPADDRESS(x) ((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)  ((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x) (x & 0xff)

#define IP_STRING_FMT_ARGS(x) \
  FOURTH_IPADDRESS(x), THIRD_IPADDRESS(x), SECOND_IPADDRESS(x), FIRST_IPADDRESS(x)

WCHAR g_wzIpAddr[IP4_ADDRESS_STRING_LENGTH + 1];

DWORD ValidateNames(PWSTR pwzComputer, PWSTR pwzDnsDomain);
DWORD CheckAdapterDnsConfig(PWSTR pwzComputer);
PWSTR ConcatonateStrings(PWSTR pwzFirst, PWSTR pwzSecond);
PWSTR AllocString(PWSTR pwz);
BOOL AddToList(PWSTR * ppwzList, PWSTR pwz);
BOOL BuildList(PWSTR * ppwzList, PWSTR pwzDnsDomain);
DWORD NewTreeSrvCheck(PWSTR pwzForestRoot, PWSTR pwzDnsDomain);
DWORD ChildDomainSrvCheck(PWSTR pwzDnsDomain);
DWORD ReplicaDcSrvCheck(PWSTR pwzDnsDomain);
DWORD DcLocatorRegisterCheck(PWSTR pwzDnsDomain);
DWORD RCodeNotImplTest(PWSTR pwzDnsDomain);
DWORD RCodeSrvFailTest(PWSTR pwzDnsDomain);
DWORD ARecordRegisterCheck(PWSTR pwzComputerLabel, PWSTR pwzComputerDnsSuffix,
                           PWSTR pwzDnsDomain);
DWORD GetComputerDnsSuffix(PWSTR * ppwzComputerDnsDomainName, PWSTR pwzDnsDomain);
void GetMachineInfo(void);

//+----------------------------------------------------------------------------
//
// Function:   PrePromoDnsCheck
//
// Synopsis:   Check a machine's DNS configuration before it is converted to a
//             domain controller.
//
// Note:       pDsInfo->pszNC is used to pass the computer name into this
//             function.
//
//-----------------------------------------------------------------------------
DWORD 
PrePromoDnsCheck(
   IN PDC_DIAG_DSINFO             pDsInfo,
   IN ULONG                       ulCurrTargetServer,
   IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds)
{
   size_t cchDomainArgPrefix = wcslen(DNS_DOMAIN_ARG);
   size_t cchRootArgPrefix = wcslen(FOREST_ROOT_DOMAIN_ARG);
   int i;
   PWSTR pwzComputerDnsSuffix, pwzCmdLineDnsDomain = NULL;
   PWSTR pwzParent, pwzForestRoot = NULL;
   DNS_STATUS status;
   DWORD dwErr = ERROR_SUCCESS;
   enum {None, NewForest, NewTree, ChildDomain, ReplicaDC} Operation = None;

   //
   // Gather parameters.
   //
   if (!pDsInfo->ppszCommandLine)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   for (i = 0; pDsInfo->ppszCommandLine[i]; i++)
   {
      if (_wcsnicmp(pDsInfo->ppszCommandLine[i], DNS_DOMAIN_ARG, cchDomainArgPrefix) == 0)
      {
         pwzCmdLineDnsDomain = &pDsInfo->ppszCommandLine[i][cchDomainArgPrefix];
         continue;
      }
      if (_wcsicmp(pDsInfo->ppszCommandLine[i], NEW_FOREST_ARG) == 0)
      {
         if (None != Operation)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
            PrintMessage(SEV_ALWAYS, L"\n");
            return ERROR_INVALID_PARAMETER;
         }
         Operation = NewForest;
         continue;
      }
      if (_wcsicmp(pDsInfo->ppszCommandLine[i], NEW_TREE_ARG) == 0)
      {
         if (None != Operation)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
            PrintMessage(SEV_ALWAYS, L"\n");
            return ERROR_INVALID_PARAMETER;
         }
         Operation = NewTree;
         continue;
      }
      if (_wcsicmp(pDsInfo->ppszCommandLine[i], CHILD_DOMAIN_ARG) == 0)
      {
         if (None != Operation)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
            PrintMessage(SEV_ALWAYS, L"\n");
            return ERROR_INVALID_PARAMETER;
         }
         Operation = ChildDomain;
         continue;
      }
      if (_wcsicmp(pDsInfo->ppszCommandLine[i], REPLICA_DC_ARG) == 0)
      {
         if (None != Operation)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
            PrintMessage(SEV_ALWAYS, L"\n");
            return ERROR_INVALID_PARAMETER;
         }
         Operation = ReplicaDC;
         continue;
      }
      if (_wcsnicmp(pDsInfo->ppszCommandLine[i], FOREST_ROOT_DOMAIN_ARG, cchRootArgPrefix) == 0)
      {
         pwzForestRoot = &pDsInfo->ppszCommandLine[i][cchRootArgPrefix];
         continue;
      }
      // If here, then somethine unrecognized is on the command line.
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   if (!pwzCmdLineDnsDomain || (None == Operation) ||
       (NewTree == Operation && NULL == pwzForestRoot))
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   PrintMessage(SEV_DEBUG,
                L"\nTemporary message: Can computer %s be promoted to a DC for\n\tdomain %s, Op %d\n\n",
                pDsInfo->pszNC, pwzCmdLineDnsDomain, Operation);

   GetMachineInfo();

   status = GetComputerDnsSuffix(&pwzComputerDnsSuffix, pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Validate the names. (step 1)
   //

   status = ValidateNames(pDsInfo->pszNC, pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Check whether the computer's DNS suffix is going to be different than the
   // AD domain after the promotion. The below won't work if remoting to a
   // different computer is to be added. (step 2)
   //

   PrintMessage(SEV_DEBUG,
                L"\nComparing the computer name suffix %s with the DNS domain name.\n\n",
                pwzComputerDnsSuffix);

   if (_wcsicmp(pwzComputerDnsSuffix, pwzCmdLineDnsDomain) != 0)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_SUFFIX_MISMATCH, pwzComputerDnsSuffix);
      PrintMessage(SEV_ALWAYS, L"\n");
   }

   //
   // Check whether at least one enabled adapter/connection is configured
   // with preferred DNS server. (step 3)
   //

   status = CheckAdapterDnsConfig(pDsInfo->pszNC);

   if (ERROR_SUCCESS != status)
   {
      LocalFree(pwzComputerDnsSuffix);
      return status;
   }

   //
   // Check whether the SRV DNS record for
   // _ldap._tcp.dc._msdcs.<DNS name of Active Directory Domain>
   // is in place. (step 4)
   //
   switch (Operation)
   {
   case NewForest:
      //
      // Skip for new forest.
      //
      break;

   case ReplicaDC:
      status = ReplicaDcSrvCheck(pwzCmdLineDnsDomain);
      break;

   case NewTree:
      status = NewTreeSrvCheck(pwzForestRoot, pwzCmdLineDnsDomain);
      break;

   case ChildDomain:
      status = ChildDomainSrvCheck(pwzCmdLineDnsDomain);
      break;

   default:
      Assert(FALSE);
   }

   if (ERROR_SUCCESS != status)
   {
      dwErr = status;
   }

   PrintMsg(SEV_ALWAYS, DCDIAG_WARN_MISCONFIGURE);
   PrintMessage(SEV_ALWAYS, L"\n");

   //
   // Verify that the server will be able to register DC locator records after
   // successful promotion to a DC. (step 5)
   //

   status = DcLocatorRegisterCheck(pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      LocalFree(pwzComputerDnsSuffix);
      return status;
   }

   //
   // Verify that the server will be able to register A record for its computer
   // name after successful promotion to a DC. (step 6)
   //

   status = ARecordRegisterCheck(pDsInfo->pszNC, pwzComputerDnsSuffix, pwzCmdLineDnsDomain);

   LocalFree(pwzComputerDnsSuffix);

   return (ERROR_SUCCESS != status) ? status : dwErr;
}

//+----------------------------------------------------------------------------
//
// Function:   RegisterLocatorDnsCheck
//
// Synopsis:   Tests whether this domain controller can register the Domain
//             Controller Locator DNS records. These records must be present in
//             DNS in order for other computers to locate this domain controller
//             for the pwzCmdLineDnsDomain domain. Reports whether any modifications to
//             the existing DNS infrastructure are required.
//
// Note:       pDsInfo->pszNC is used to pass the computer name into this
//             function.
//
//-----------------------------------------------------------------------------
DWORD 
RegisterLocatorDnsCheck(
   IN PDC_DIAG_DSINFO             pDsInfo,
   IN ULONG                       ulCurrTargetServer,
   IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds)
{
   DNS_STATUS status;
   PWSTR pwzCmdLineDnsDomain = NULL, pwzComputerDnsSuffix;
   int i;
   size_t cchDomainArgPrefix = wcslen(DNS_DOMAIN_ARG);

   //
   // Gather parameters.
   //
   if (!pDsInfo->ppszCommandLine)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   for (i = 0; pDsInfo->ppszCommandLine[i]; i++)
   {
      if (_wcsnicmp(pDsInfo->ppszCommandLine[i], DNS_DOMAIN_ARG, cchDomainArgPrefix) == 0)
      {
         pwzCmdLineDnsDomain = &pDsInfo->ppszCommandLine[i][cchDomainArgPrefix];
         continue;
      }
   }

   if (!pwzCmdLineDnsDomain)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   GetMachineInfo();

   status = GetComputerDnsSuffix(&pwzComputerDnsSuffix, pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Validate the names. (step 1)
   //

   status = ValidateNames(pDsInfo->pszNC, pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Check whether at least one enabled adapter/connection is configured
   // with preferred DNS server. (step 3)
   //

   status = CheckAdapterDnsConfig(pDsInfo->pszNC);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Verify that the server will be able to register DC locator records after
   // successful promotion to a DC. (step 5)
   //

   status = DcLocatorRegisterCheck(pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Verify that the server will be able to register A record for its computer
   // name after successful promotion to a DC. (step 6)
   //

   status = ARecordRegisterCheck(pDsInfo->pszNC, pwzComputerDnsSuffix, pwzCmdLineDnsDomain);

   LocalFree(pwzComputerDnsSuffix);

   return status;
}

/* DWORD 
JoinDomainDnsCheck(
   IN PDC_DIAG_DSINFO             pDsInfo,
   IN ULONG                       ulCurrTargetServer,
   IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds)
{
   PrintMessage(SEV_ALWAYS, L"Running test: \n");
    
   return ERROR_SUCCESS;
} */

//+----------------------------------------------------------------------------
//
// string helpers.
//
//-----------------------------------------------------------------------------

PWSTR AllocString(PWSTR pwz)
{
   PWSTR pwzTmp;

   pwzTmp = (PWSTR)LocalAlloc(LMEM_FIXED, ((int)wcslen(pwz) + 1) * sizeof(WCHAR));

   if (!pwzTmp)
   {
      return NULL;
   }

   wcscpy(pwzTmp, pwz);

   return pwzTmp;
}

PWSTR ConcatonateStrings(PWSTR pwzFirst, PWSTR pwzSecond)
{
   PWSTR pwz;

   pwz = (PWSTR)LocalAlloc(LMEM_FIXED,
                           ((int)wcslen(pwzFirst) + (int)wcslen(pwzSecond) + 1) * sizeof(WCHAR));

   if (!pwz)
   {
      return NULL;
   }

   wcscpy(pwz, pwzFirst);
   wcscat(pwz, pwzSecond);

   return pwz;
}

BOOL AddToList(PWSTR * ppwzList, PWSTR pwz)
{
   PWSTR pwzTmp;

   if (*ppwzList)
   {
      pwzTmp = (PWSTR)LocalAlloc(LMEM_FIXED,
                                 ((int)wcslen(*ppwzList) + (int)wcslen(pwz) + 3) * sizeof(WCHAR));
      if (!pwzTmp)
      {
         return FALSE;
      }

      wcscpy(pwzTmp, *ppwzList);
      wcscat(pwzTmp, L", ");
      wcscat(pwzTmp, pwz);

      LocalFree(*ppwzList);

      *ppwzList = pwzTmp;
   }
   else
   {
      pwzTmp = AllocString(pwz);

      if (!pwzTmp)
      {
         return FALSE;
      }

      *ppwzList = pwzTmp;
   }
   return TRUE;
}

BOOL BuildList(PWSTR * ppwzList, PWSTR pwzItem)
{
   PWSTR pwzDot = NULL, pwzTmp = NULL;

   pwzTmp = AllocString(pwzItem);

   if (!pwzTmp)
   {
      return FALSE;
   }

   pwzDot = pwzItem;

   while (pwzDot = wcschr(pwzDot, L'.'))
   {
      pwzDot++;
      if (!pwzDot)
      {
         break;
      }

      if (!AddToList(&pwzTmp, pwzDot))
      {
         return FALSE;
      }
   }

   *ppwzList = pwzTmp;

   return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:   ValidateNames
//
// Synopsis:   Validate the names. (step 1)
//
//-----------------------------------------------------------------------------
DWORD
ValidateNames(PWSTR pwzComputer, PWSTR pwzDnsDomain)
{
   DNS_STATUS status;
   int cchName, cchDnsDomain;

   //
   // Validate the DNS domain name (logic same as DcPromo).
   //

   cchDnsDomain = (int)wcslen(pwzDnsDomain);

   if (DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8 < cchDnsDomain)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_DNS_DOMAIN_TOO_LONG, pwzDnsDomain,
                DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   cchName = WideCharToMultiByte(CP_UTF8,
                                 0,
                                 pwzDnsDomain,
                                 cchDnsDomain,
                                 0,
                                 0,
                                 0,
                                 0);

   if (DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8 < cchName)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_DNS_DOMAIN_TOO_LONG, pwzDnsDomain,
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   status = DnsValidateName(pwzDnsDomain, DnsNameDomain);

   switch (status)
   {
   case ERROR_INVALID_NAME:
   case DNS_ERROR_INVALID_NAME_CHAR:
   case DNS_ERROR_NUMERIC_NAME:
      PrintMsg(SEV_ALWAYS, DCDIAG_DNS_DOMAIN_SYNTAX, pwzDnsDomain,
               DNS_MAX_LABEL_LENGTH);
      PrintMessage(SEV_ALWAYS, L"\n");
      return status;

   case DNS_ERROR_NON_RFC_NAME:
      //
      // Not an error, print warning message.
      //
      PrintMsg(SEV_ALWAYS, DCDIAG_DNS_DOMAIN_WARN_RFC, pwzDnsDomain);
      PrintMessage(SEV_ALWAYS, L"\n");
      status = NO_ERROR;
      break;

   case ERROR_SUCCESS:
      break;
   }

   //
   // Verify that the first label of the Full DNS name of the computer
   // doesn't contain any invalid characters. pwzComputer is assumed to be just
   // the first label since it was obtained via a call to GetComputerNameEx
   // with a level of ComputerNameDnsHostname in main.c. If the code is changed
   // to allow command line specification of remote computer names, then the
   // name will have to be checked to see what form it is.
   //

   status = DnsValidateName(pwzComputer, DnsNameHostnameLabel);

   switch (status)
   {
   case ERROR_INVALID_NAME:
      if (g_fUpgradedNT4DC)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_UPGR_DC1);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_UPGR_DC2);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_UPGR_DC3);
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME);
      }
      PrintMessage(SEV_ALWAYS, L"\n");
      break;

   case DNS_ERROR_INVALID_NAME_CHAR:
      if (g_fUpgradedNT4DC)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_CHAR_UPGR_DC1);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_CHAR_UPGR_DC2);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_CHAR_UPGR_DC3);
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_CHAR);
      }
      PrintMessage(SEV_ALWAYS, L"\n");
      break;

   case DNS_ERROR_NON_RFC_NAME:
      if (g_fUpgradedNT4DC)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC_UPGR_DC1);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC_NOTE);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC_UPGR_DC2);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC_UPGR_DC3);
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC_NOTE);
      }
      PrintMessage(SEV_ALWAYS, L"\n");
      break;

   case ERROR_SUCCESS:
      break;

   default:
      PrintMsg(SEV_ALWAYS, DCDIAG_DNS_DOMAIN_SYNTAX, pwzDnsDomain,
               DNS_MAX_LABEL_LENGTH);
      PrintMessage(SEV_ALWAYS, L"\n");
      break;
   }

   return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:   CheckAdapterDnsConfig
//
// Synopsis:   Check whether at least one enabled adapter/connection is
//             configured with a DNS server. (step 3)
//
//-----------------------------------------------------------------------------
DWORD
CheckAdapterDnsConfig(PWSTR pwzComputer)
{
   // IpConfig reads the registry and I can't find a good alternative way to do
   // this remotely. For now using DnsQueryConfig which is not remoteable nor
   // does it return per-adapter listings.
   //
   PIP4_ARRAY pipArray;
   DNS_STATUS status;
   DWORD i, dwBufSize = sizeof(IP4_ARRAY);
   BOOL fFound = FALSE;
   UNREFERENCED_PARAMETER(pwzComputer);

   status = DnsQueryConfig(DnsConfigDnsServerList, DNS_CONFIG_FLAG_ALLOC, NULL,
                           NULL, &pipArray, &dwBufSize);

   if (ERROR_SUCCESS != status || !pipArray)
   {
      PrintMessage(SEV_ALWAYS, L"Attempt to obtain DNS name server info failed with error %d\n", status);
      return status;
   }

   for (i = 0; i < pipArray->AddrCount; i++)
   {
      fFound = TRUE;
      PrintMessage(SEV_DEBUG, L"\nName server IP address: %d.%d.%d.%d\n",
                   IP_STRING_FMT_ARGS(pipArray->AddrArray[i]));
   }

   LocalFree(pipArray);

   if (!fFound)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_NAME_SERVERS1);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_NAME_SERVERS2);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_NAME_SERVERS3);
      PrintMessage(SEV_ALWAYS, L"\n");
      return DNS_INFO_NO_RECORDS;
   }

   return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:   ReplicaDcSrvCheck
//
// Synopsis:   Check whether the SRV DNS record for
//             _ldap._tcp.dc._msdcs.<DNS name of Active Directory Domain>
//             is in place.
//
//-----------------------------------------------------------------------------
DWORD
ReplicaDcSrvCheck(PWSTR pwzDnsDomain)
{
   PDNS_RECORD rgDnsRecs, pDnsRec;
   DNS_STATUS status;
   BOOL fSuccess;
   PWSTR pwzFullSrvRecord = NULL, pwzSrvList = NULL;

   pwzFullSrvRecord = ConcatonateStrings(g_pwzSrvRecordPrefix, pwzDnsDomain);

   if (!pwzFullSrvRecord)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   // First query for the SRV records for this 
   status = DnsQuery_W(pwzFullSrvRecord, DNS_TYPE_SRV, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   LocalFree(pwzFullSrvRecord);

   pDnsRec = rgDnsRecs;

   if (ERROR_SUCCESS == status)
   {
      if (!pDnsRec)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_NO_SRV, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
      }
      else
      {
         PDNS_RECORD rgARecs;
         fSuccess = FALSE;

         while (pDnsRec)
         {
            if (DNS_TYPE_SRV == pDnsRec->wType)
            {
               status = DnsQuery_W(pDnsRec->Data.Srv.pNameTarget, DNS_TYPE_A,
                                   DNS_QUERY_BYPASS_CACHE,
                                   NULL, &rgARecs, NULL);

               if (ERROR_SUCCESS != status || !rgARecs)
               {
                  // failure.
                  if (!AddToList(&pwzSrvList, pDnsRec->Data.Srv.pNameTarget))
                  {
                     PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
                     return ERROR_NOT_ENOUGH_MEMORY;
                  }
               }
               else
               {
                  fSuccess = TRUE;
                  PrintMessage(SEV_DEBUG, L"\nSRV name: %s, A addr: %d.%d.%d.%d\n",
                               pDnsRec->Data.Srv.pNameTarget,
                               IP_STRING_FMT_ARGS(rgARecs->Data.A.IpAddress));
                  DnsRecordListFree(rgARecs, DnsFreeRecordListDeep);
               }
            }
            pDnsRec = pDnsRec->pNext;
         }

         DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

         if (fSuccess)
         {
            // Success message
            PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_SUCCESS, pwzDnsDomain);
            PrintMessage(SEV_ALWAYS, L"\n");
            status = NO_ERROR;
         }
         else
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_A_RECORD, pwzDnsDomain, pwzSrvList);
            PrintMessage(SEV_ALWAYS, L"\n");
            LocalFree(pwzSrvList);
         }
      }
   }
   else
   {
      PWSTR pwzDomainList;

      switch (status)
      {
      case DNS_ERROR_RCODE_FORMAT_ERROR:
      case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_FORMAT, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      case DNS_ERROR_RCODE_SERVER_FAILURE:
         if (!BuildList(&pwzDomainList, pwzDnsDomain))
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_SERVER1, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_SERVER2, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_SERVER3);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_SERVER4, pwzDnsDomain, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_NAME_ERROR:
         if (!BuildList(&pwzDomainList, pwzDnsDomain))
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_NAME, pwzDnsDomain, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_REFUSED:
         if (!BuildList(&pwzDomainList, pwzDnsDomain))
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_REFUSED, pwzDnsDomain, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_INFO_NO_RECORDS:
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_NO_RECORDS, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      case ERROR_TIMEOUT:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_TIMEOUT);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      default:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;
      }
   }

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   NewTreeSrvCheck
//
// Synopsis:   Check whether the SRV DNS record for
//             _ldap._tcp.dc._msdcs.<DNS name of Active Directory Domain>
//             is in place.
//
//-----------------------------------------------------------------------------
DWORD
NewTreeSrvCheck(PWSTR pwzForestRoot, PWSTR pwzDnsDomain)
{
   PDNS_RECORD rgDnsRecs, pDnsRec;
   DNS_STATUS status;
   BOOL fSuccess;
   PWSTR pwzFullSrvRecord = NULL, pwzSrvList = NULL, pwzDomainList = NULL;

   pwzFullSrvRecord = ConcatonateStrings(g_pwzSrvRecordPrefix, pwzForestRoot);

   if (!pwzFullSrvRecord)
   {
       return ERROR_NOT_ENOUGH_MEMORY;
   }

   // First query for the SRV records for this 
   status = DnsQuery_W(pwzFullSrvRecord, DNS_TYPE_SRV, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   LocalFree(pwzFullSrvRecord);

   pDnsRec = rgDnsRecs;

   if (ERROR_SUCCESS == status)
   {
      if (!pDnsRec)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_NO_RECORDS, pwzDnsDomain, pwzForestRoot);
         PrintMessage(SEV_ALWAYS, L"\n");
      }
      else
      {
         PDNS_RECORD rgARecs;
         fSuccess = FALSE;

         while (pDnsRec)
         {
            if (DNS_TYPE_SRV == pDnsRec->wType)
            {
               status = DnsQuery_W(pDnsRec->Data.Srv.pNameTarget, DNS_TYPE_A,
                                   DNS_QUERY_BYPASS_CACHE,
                                   NULL, &rgARecs, NULL);

               if (ERROR_SUCCESS != status || !rgARecs)
               {
                  // failure.
                  if (!AddToList(&pwzSrvList, pDnsRec->Data.Srv.pNameTarget))
                  {
                     return ERROR_NOT_ENOUGH_MEMORY;
                  }
               }
               else
               {
                  fSuccess = TRUE;
                  PrintMessage(SEV_DEBUG, L"\nSRV name: %s, A addr: %d.%d.%d.%d\n",
                               pDnsRec->Data.Srv.pNameTarget,
                               IP_STRING_FMT_ARGS(rgARecs->Data.A.IpAddress));
                  DnsRecordListFree(rgARecs, DnsFreeRecordListDeep);
               }
            }
            pDnsRec = pDnsRec->pNext;
         }

         DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

         if (fSuccess)
         {
            // Success message
            PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_SUCCESS, pwzDnsDomain);
            PrintMessage(SEV_ALWAYS, L"\n");
            status = NO_ERROR;
         }
         else
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_A_RECORD, pwzDnsDomain, pwzSrvList);
            PrintMessage(SEV_ALWAYS, L"\n");
            LocalFree(pwzSrvList);
         }
      }
   }
   else
   {
      switch (status)
      {
      case DNS_ERROR_RCODE_FORMAT_ERROR:
      case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_FORMAT, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      case DNS_ERROR_RCODE_SERVER_FAILURE:
         if (!BuildList(&pwzDomainList, pwzForestRoot))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_SERVER1, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_SERVER2, pwzForestRoot);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_SERVER3);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_SERVER4, pwzForestRoot, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_NAME_ERROR:
         if (!BuildList(&pwzDomainList, pwzForestRoot))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_NAME1, pwzDnsDomain, pwzForestRoot, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_NAME2, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_REFUSED:
         if (!BuildList(&pwzDomainList, pwzForestRoot))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_REFUSED, pwzDnsDomain, pwzForestRoot, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_INFO_NO_RECORDS:
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_NO_RECORDS, pwzDnsDomain, pwzForestRoot);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      case ERROR_TIMEOUT:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_TIMEOUT);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      default:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;
      }
   }

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   ChildDomainSrvCheck
//
// Synopsis:   Check whether the SRV DNS record for
//             _ldap._tcp.dc._msdcs.<DNS name of Active Directory Domain>
//             is in place.
//
//-----------------------------------------------------------------------------
DWORD
ChildDomainSrvCheck(PWSTR pwzDnsDomain)
{
   PDNS_RECORD rgDnsRecs = NULL, pDnsRec = NULL;
   DNS_STATUS status;
   BOOL fSuccess;
   PWSTR pwzParent = NULL, pwzFullSrvRecord = NULL,
         pwzSrvList = NULL, pwzDomainList = NULL;

   pwzParent = wcschr(pwzDnsDomain, L'.');

   if (!pwzParent || !(pwzParent + 1))
   {
      // TODO: new message?
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   pwzParent++;

   pwzFullSrvRecord = ConcatonateStrings(g_pwzSrvRecordPrefix, pwzParent);

   if (!pwzFullSrvRecord)
   {
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   // First query for the SRV records for this 
   status = DnsQuery_W(pwzFullSrvRecord, DNS_TYPE_SRV, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   LocalFree(pwzFullSrvRecord);

   pDnsRec = rgDnsRecs;

   if (ERROR_SUCCESS == status)
   {
      if (!pDnsRec)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_NO_SRV, pwzDnsDomain, pwzParent);
         PrintMessage(SEV_ALWAYS, L"\n");
      }
      else
      {
         PDNS_RECORD rgARecs;
         fSuccess = FALSE;

         while (pDnsRec)
         {
            if (DNS_TYPE_SRV == pDnsRec->wType)
            {
               status = DnsQuery_W(pDnsRec->Data.Srv.pNameTarget, DNS_TYPE_A,
                                   DNS_QUERY_BYPASS_CACHE,
                                   NULL, &rgARecs, NULL);

               if (ERROR_SUCCESS != status || !rgARecs)
               {
                  // failure.
                  if (!AddToList(&pwzSrvList, pDnsRec->Data.Srv.pNameTarget))
                  {
                     return ERROR_NOT_ENOUGH_MEMORY;
                  }
               }
               else
               {
                  fSuccess = TRUE;
                  PrintMessage(SEV_DEBUG, L"\nSRV name: %s, A addr: %d.%d.%d.%d\n",
                               pDnsRec->Data.Srv.pNameTarget,
                               IP_STRING_FMT_ARGS(rgARecs->Data.A.IpAddress));
                  DnsRecordListFree(rgARecs, DnsFreeRecordListDeep);
               }
            }
            pDnsRec = pDnsRec->pNext;
         }

         DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

         if (fSuccess)
         {
            // Success message
            PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_SUCCESS, pwzDnsDomain);
            PrintMessage(SEV_ALWAYS, L"\n");
            status = NO_ERROR;
         }
         else
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_A_RECORD, pwzDnsDomain, pwzSrvList);
            PrintMessage(SEV_ALWAYS, L"\n");
            LocalFree(pwzSrvList);
         }
      }
   }
   else
   {
      switch (status)
      {
      case DNS_ERROR_RCODE_FORMAT_ERROR:
      case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_FORMAT, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      case DNS_ERROR_RCODE_SERVER_FAILURE:
         if (!BuildList(&pwzDomainList, pwzParent))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_SERVER1, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_SERVER2, pwzParent);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_SERVER3);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_SERVER4, pwzParent, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_NAME_ERROR:
         if (!BuildList(&pwzDomainList, pwzParent))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_NAME1, pwzDnsDomain, pwzParent);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_NAME2, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_NAME3, pwzParent);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_REFUSED:
         if (!BuildList(&pwzDomainList, pwzParent))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_REFUSED1, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_REFUSED2, pwzParent, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case ERROR_TIMEOUT:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_TIMEOUT);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      default:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;
      }
   }

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   DcLocatorRegisterCheck
//
// Synopsis:   Verify that the server will be able to register DC locator
//             records after successful promotion to a DC. (step 5)
//
//-----------------------------------------------------------------------------
DWORD
DcLocatorRegisterCheck(PWSTR pwzDnsDomain)
{
#define DCDIAG_GUID_BUF_SIZE 64
   const PWSTR pwzAdapters = L"Adapters";
   const PWSTR pwzInterfaces = L"Interfaces";
   const PWSTR pwzDisableUpdate = L"DisableDynamicUpdate";
   const PWSTR pwzNetLogParams = L"System\\CurrentControlSet\\Services\\Netlogon\\Parameters";
   const PWSTR pwzUpdateOnAll = L"DnsUpdateOnAllAdapters";
   WCHAR wzGuidBuf[DCDIAG_GUID_BUF_SIZE];
   HKEY hTcpIpKey = NULL, hKey = NULL, hItfKey = NULL;
   LONG lRet = 0;
   DWORD dwType = 0, dwSize = 0, dwDisable = 0, dwUpdate = 0, i = 0;
   FILETIME ft = {0};
   BOOL fDisabledOnAll = TRUE;
   DNS_STATUS status = 0;

   //
   // Verify that the client is configured to attempt dynamic updates of the
   // DNS records
   //

   // If ((HKLM/System/CCS/Services/Tcpip/Paramaters/DisableDynamicUpdate == 0x1)
   // && (HKLM/System/CCS/Services/Netlogon/Parameters/DnsUpdateOnAllAdapters != 0x1))

   lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_pwzTcpIpParams, 0, KEY_READ, &hTcpIpKey);

   if (ERROR_SUCCESS != lRet)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
      return lRet;
   }

   // NTRAID#NTBUG9 171194-2002/12/08-ericb: prefix: using unitialized memory dwSize
   dwSize = sizeof(dwDisable);

   lRet = RegQueryValueEx(hTcpIpKey, pwzDisableUpdate, 0, &dwType, (PBYTE)&dwDisable, &dwSize);

   if (ERROR_SUCCESS != lRet)
   {
      if (ERROR_FILE_NOT_FOUND == lRet)
      {
         dwDisable = 0;
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
         RegCloseKey(hTcpIpKey);
         return lRet;
      }
   }

   lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pwzNetLogParams, 0, KEY_READ, &hKey);

   if (ERROR_SUCCESS != lRet)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
      RegCloseKey(hTcpIpKey);
      return lRet;
   }

   // NTRAID#NTBUG9 171194-2002/12/08-ericb: prefix: using unitialized memory dwSize
   dwSize = sizeof(dwUpdate);

   lRet = RegQueryValueEx(hKey, pwzUpdateOnAll, 0, &dwType, (PBYTE)&dwUpdate, &dwSize);

   RegCloseKey(hKey);

   if (ERROR_SUCCESS != lRet)
   {
      if (ERROR_FILE_NOT_FOUND == lRet)
      {
         dwUpdate = 1;
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
         RegCloseKey(hTcpIpKey);
         return lRet;
      }
   }

   if (1 == dwDisable)
   {
      if (1 != dwUpdate)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_ALL_UPDATE_OFF);
         RegCloseKey(hTcpIpKey);
         return DNS_ERROR_RECORD_DOES_NOT_EXIST;
      }
   }
   else // DisableDynamicUpdate != 1
   {
      // if ((HKLM/System/CCS/Services/Tcpip/Paramaters/DisableDynamicUpdate != 0x1)
      // && (for all enabled connections HKLM/System/CCS/Services/Tcpip/Paramaters/Interfaces/<Interface GUID>/DisableDynamicUpdate == 0x1)
      // && (HKLM/CCS/Services/Netlogon/Parameters/DnsUpdateOnAllAdapters != 0x1))

      if (1 != dwUpdate)
      {
         /*
         PMIB_IFTABLE pIfTable;

         dwSize = 0;

         status = GetIfTable(NULL, &dwSize, FALSE);

         if (ERROR_INSUFFICIENT_BUFFER != status)
         {
            PrintMessage(SEV_ALWAYS, L"Reading the adapter interfaces failed with error %d\n", status);
            return status;
         }

         pIfTable = LocalAlloc(LMEM_FIXED, dwSize);
                               //sizeof(MIB_IFTABLE) + (sizeof(MIB_IFROW) * dwSize));
         if (!pIfTable)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
         }

         status = GetIfTable(pIfTable, &dwSize, FALSE);

         if (NO_ERROR != status)
         {
            PrintMessage(SEV_ALWAYS, L"Reading the adapter interfaces failed with error %d\n", status);
            LocalFree(pIfTable);
            return status;
         }

         for (i = 0; i < pIfTable->dwNumEntries; i++)
         {
            PrintMessage(SEV_DEBUG, L"Interface name %s, description %S.\n",
                         pIfTable->table[i].wszName, pIfTable->table[i].bDescr);
            if (pIfTable->table[i].dwOperStatus >= IF_OPER_STATUS_CONNECTING)
            {
               PrintMessage(SEV_DEBUG, L"Interface %s enabled.\n",
                            pIfTable->table[i].wszName);
            }
         }

         LocalFree(pIfTable);
         */

         lRet = RegOpenKeyEx(hTcpIpKey, pwzInterfaces, 0, KEY_READ, &hItfKey);

         if (ERROR_SUCCESS != lRet)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
            RegCloseKey(hTcpIpKey);
            return lRet;
         }

         i = 0;

         do
         {
            dwSize = DCDIAG_GUID_BUF_SIZE;

            lRet = RegEnumKeyEx(hItfKey, i, wzGuidBuf, &dwSize, NULL, NULL, NULL, &ft);

            if (ERROR_SUCCESS != lRet)
            {
               if (ERROR_NO_MORE_ITEMS == lRet)
               {
                  break;
               }
               else
               {
                  PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
                  RegCloseKey(hTcpIpKey);
                  return lRet;
               }
            }

            lRet = RegOpenKeyEx(hItfKey, wzGuidBuf, 0, KEY_READ, &hKey);

            if (ERROR_SUCCESS != lRet)
            {
               PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
               RegCloseKey(hTcpIpKey);
               RegCloseKey(hItfKey);
               return lRet;
            }

            // NTRAID#NTBUG9 171194-2002/12/08-ericb: prefix: using unitialized memory dwSize
            dwSize = sizeof(dwUpdate);

            lRet = RegQueryValueEx(hKey, pwzDisableUpdate, NULL, &dwType, (PBYTE)&dwUpdate, &dwSize);

            RegCloseKey(hKey);

            if (ERROR_SUCCESS != lRet)
            {
               if (ERROR_FILE_NOT_FOUND == lRet)
               {
                  dwUpdate = 0;
                  lRet = ERROR_SUCCESS;
               }
               else
               {
                  PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
                  RegCloseKey(hTcpIpKey);
                  RegCloseKey(hItfKey);
                  return lRet;
               }
            }

            if (1 != dwUpdate)
            {
               // BUGBUG: need to determine what constitutes an enabled interface/connection
               fDisabledOnAll = FALSE;
            }

            i++;

         } while (ERROR_SUCCESS == lRet);

         RegCloseKey(hTcpIpKey);
         RegCloseKey(hItfKey);

         if (fDisabledOnAll)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ADAPTER_UPDATE_OFF);
            PrintMessage(SEV_ALWAYS, L"\n");
            return DNS_ERROR_RECORD_DOES_NOT_EXIST;
         }
      }
   }

   //
   // Verify that the zone(s) authoritative for the records to be registered
   // can be discovered and that it can be dynamically updated.
   //

   status = DnsUpdateTest_W(0, pwzDnsDomain, 0, 0);

   switch (status)
   {
   case NO_ERROR:
   case DNS_ERROR_RCODE_NXRRSET:
   case DNS_ERROR_RCODE_YXDOMAIN:
      PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_UPDATE_OK);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_SUCCESS;

   case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
      return RCodeNotImplTest(pwzDnsDomain);

   case ERROR_TIMEOUT:
      PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_TIMEOUT);
      PrintMessage(SEV_ALWAYS, L"\n");
      if (!g_fDC)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_TIMEOUT_NOT_DC);
         PrintMessage(SEV_ALWAYS, L"\n");
      }
      return ERROR_SUCCESS;

   case DNS_ERROR_RCODE_SERVER_FAILURE:
      return RCodeSrvFailTest(pwzDnsDomain);
   }

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   RCodeNotImplTest
//
// Synopsis:   
//
//-----------------------------------------------------------------------------
DWORD
RCodeNotImplTest(PWSTR pwzDnsDomain)
{
   DNS_STATUS status, stMsd, stSit, stTcp, stUdp;
   PDNS_RECORD rgDomainRecs, rgDnsRecs, pDnsRec;
   PWSTR pwzAuthZone = NULL;
   PWSTR pwzMsDcs = NULL, pwzSites = NULL, pwzTcp = NULL, pwzUdp = NULL;

   status = DnsQuery_W(pwzDnsDomain, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDomainRecs, NULL);

   if (DNS_ERROR_RCODE_NO_ERROR != status)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
      PrintMessage(SEV_ALWAYS, L"\n");
      return status;
   }

   g_wzIpAddr[0] = L'\0';

   pDnsRec = rgDomainRecs;

   while (pDnsRec)
   {
      PrintMessage(SEV_DEBUG, L"\nSOA query returned record type %d\n", pDnsRec->wType);
      switch (pDnsRec->wType)
      {
      case DNS_TYPE_A:
         PrintMessage(SEV_DEBUG, L"\nA record, name: %s, IP address:  %d.%d.%d.%d\n",
                      pDnsRec->pName, IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));

         wsprintf(g_wzIpAddr, L"%d.%d.%d.%d", IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));

         break;

      case DNS_TYPE_SOA:
         PrintMessage(SEV_DEBUG, L"\nSOA name: %s, zone primary server: %s\n",
                      pDnsRec->pName, pDnsRec->Data.SOA.pNamePrimaryServer);
         pwzAuthZone = AllocString(pDnsRec->pName);
         break;

      default:
         break;
      }

      pDnsRec = pDnsRec->pNext;
   }

   if (!g_wzIpAddr)
   {
      wcscpy(g_wzIpAddr, L"unknown");
   }

   if (!pwzAuthZone)
   {
      pwzAuthZone = AllocString(L"zone_unknown");
   }

   //
   // Build up the four prefix strings.
   //
   pwzMsDcs = ConcatonateStrings(g_pwzMSDCS, pwzDnsDomain);

   if (!pwzMsDcs)
   {
      status = ERROR_NOT_ENOUGH_MEMORY;
      goto Cleanup;
   }

   pwzSites = ConcatonateStrings(g_pwzSites, pwzDnsDomain);

   if (!pwzSites)
   {
      status = ERROR_NOT_ENOUGH_MEMORY;
      goto Cleanup;
   }

   pwzTcp = ConcatonateStrings(g_pwzTcp, pwzDnsDomain);

   if (!pwzTcp)
   {
      status = ERROR_NOT_ENOUGH_MEMORY;
      goto Cleanup;
   }

   pwzUdp = ConcatonateStrings(g_pwzUdp, pwzDnsDomain);

   if (!pwzUdp)
   {
      status = ERROR_NOT_ENOUGH_MEMORY;
      goto Cleanup;
   }

   //
   // Query the four prefixes.
   //
   rgDnsRecs = NULL;

   stMsd = DnsQuery_W(pwzMsDcs, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                      NULL, &rgDnsRecs, NULL);

   if (rgDnsRecs)
   {
      DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);
   }
   rgDnsRecs = NULL;

   stSit = DnsQuery_W(pwzSites, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                      NULL, &rgDnsRecs, NULL);

   if (rgDnsRecs)
   {
      DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);
   }
   rgDnsRecs = NULL;

   stTcp = DnsQuery_W(pwzTcp, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                      NULL, &rgDnsRecs, NULL);

   if (rgDnsRecs)
   {
      DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);
   }
   rgDnsRecs = NULL;

   stUdp = DnsQuery_W(pwzUdp, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                      NULL, &rgDnsRecs, NULL);

   if (rgDnsRecs)
   {
      DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);
   }

   //
   // If all 4 queries report DNS_ERROR_RCODE_NAME_ERROR...
   //
   if (DNS_ERROR_RCODE_NAME_ERROR == stMsd &&
       DNS_ERROR_RCODE_NAME_ERROR == stSit &&
       DNS_ERROR_RCODE_NAME_ERROR == stTcp &&
       DNS_ERROR_RCODE_NAME_ERROR == stUdp)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_DYNAMIC_UPDATE0, g_wzIpAddr, pwzAuthZone);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_DYNAMIC_UPDATE00);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_DYNAMIC_UPDATE1, pwzAuthZone, g_wzIpAddr);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, (_wcsicmp(pwzDnsDomain, pwzAuthZone) == 0) ?
               DCDIAG_NO_DYNAMIC_UPDATE2A : DCDIAG_NO_DYNAMIC_UPDATE2B,
               pwzAuthZone);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_DYNAMIC_UPDATE3, pwzMsDcs, pwzSites, pwzTcp, pwzUdp);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_DYNAMIC_UPDATE4);
      PrintMessage(SEV_ALWAYS, L"\n");
      goto Cleanup;
   }

   //
   // If all four queries are successfull
   //
   if (NO_ERROR == (stMsd + stSit + stTcp + stUdp))
   {
      stMsd = DnsUpdateTest_W(0, pwzMsDcs, 0, 0);
      stSit = DnsUpdateTest_W(0, pwzSites, 0, 0);
      stTcp = DnsUpdateTest_W(0, pwzTcp, 0, 0);
      stUdp = DnsUpdateTest_W(0, pwzUdp, 0, 0);

      if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stMsd ||
          DNS_ERROR_RCODE_NOT_IMPLEMENTED == stSit ||
          DNS_ERROR_RCODE_NOT_IMPLEMENTED == stTcp ||
          DNS_ERROR_RCODE_NOT_IMPLEMENTED == stUdp)
      {
         PWSTR pwzFailList = NULL;

         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stMsd)
         {
            if (!BuildList(&pwzFailList, pwzMsDcs))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stSit)
         {
            if (!BuildList(&pwzFailList, pwzSites))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stTcp)
         {
            if (!BuildList(&pwzFailList, pwzTcp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stUdp)
         {
            if (!BuildList(&pwzFailList, pwzUdp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }

         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_NI_ALL,
                  pwzMsDcs, pwzSites, pwzTcp, pwzUdp, pwzFailList);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzFailList);
      }
      else
      {
         if ((NO_ERROR == stMsd ||
              DNS_ERROR_RCODE_NXRRSET == stMsd ||
              DNS_ERROR_RCODE_YXDOMAIN == stMsd) &&
             (NO_ERROR == stSit ||
              DNS_ERROR_RCODE_NXRRSET == stSit ||
              DNS_ERROR_RCODE_YXDOMAIN == stSit)  &&
             (NO_ERROR == stTcp ||
              DNS_ERROR_RCODE_NXRRSET == stTcp ||
              DNS_ERROR_RCODE_YXDOMAIN == stTcp)  &&
             (NO_ERROR == stUdp ||
              DNS_ERROR_RCODE_NXRRSET == stUdp ||
              DNS_ERROR_RCODE_YXDOMAIN == stUdp))
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_UPDATE_OK);
            PrintMessage(SEV_ALWAYS, L"\n");
         }
      }
      goto Cleanup;
   }

   //
   // If some of the queries returned DNS_ERROR_RCODE_NAME_ERROR
   //
   if (DNS_ERROR_RCODE_NAME_ERROR == stMsd ||
       DNS_ERROR_RCODE_NAME_ERROR == stSit ||
       DNS_ERROR_RCODE_NAME_ERROR == stTcp ||
       DNS_ERROR_RCODE_NAME_ERROR == stUdp)
   {
      PWSTR pwzSuccessList = NULL, pwzFailList = NULL;

      if (NO_ERROR == stMsd)
      {
         if (!BuildList(&pwzSuccessList, pwzMsDcs))
         {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
         }

         stMsd = DnsUpdateTest_W(0, pwzMsDcs, 0, 0);

         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stMsd)
         {
            if (!BuildList(&pwzFailList, pwzMsDcs))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
      }

      if (NO_ERROR == stSit)
      {
         if (!BuildList(&pwzSuccessList, pwzSites))
         {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
         }

         stSit = DnsUpdateTest_W(0, pwzSites, 0, 0);

         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stSit)
         {
            if (!BuildList(&pwzFailList, pwzSites))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
      }

      if (NO_ERROR == stTcp)
      {
         if (!BuildList(&pwzSuccessList, pwzTcp))
         {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
         }

         stTcp = DnsUpdateTest_W(0, pwzTcp, 0, 0);

         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stTcp)
         {
            if (!BuildList(&pwzFailList, pwzTcp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
      }

      if (NO_ERROR == stUdp)
      {
         if (!BuildList(&pwzSuccessList, pwzUdp))
         {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
         }

         stUdp = DnsUpdateTest_W(0, pwzUdp, 0, 0);

         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stUdp)
         {
            if (!BuildList(&pwzFailList, pwzUdp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
      }

      if (!pwzSuccessList)
      {
         // Nothing to report.
         //
         goto Cleanup;
      }

      if (pwzFailList)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_NI1, pwzSuccessList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_NI2, pwzFailList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_NI3);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzSuccessList);
         LocalFree(pwzFailList);
      }
      else
      {
         if (NO_ERROR != stMsd)
         {
            if (!BuildList(&pwzFailList, pwzMsDcs))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (NO_ERROR != stSit)
         {
            if (!BuildList(&pwzFailList, pwzSites))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (NO_ERROR != stTcp)
         {
            if (!BuildList(&pwzFailList, pwzTcp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (NO_ERROR != stUdp)
         {
            if (!BuildList(&pwzFailList, pwzUdp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }

         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_OK1, pwzSuccessList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_OK2, pwzFailList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_OK3);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzSuccessList);
         LocalFree(pwzFailList);
      }
   }

Cleanup:
   if (ERROR_NOT_ENOUGH_MEMORY == status)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
   }
   if (pwzMsDcs)
      LocalFree(pwzMsDcs);
   if (pwzSites)
      LocalFree(pwzSites);
   if (pwzTcp)
      LocalFree(pwzTcp);
   if (pwzUdp)
      LocalFree(pwzUdp);
   DnsRecordListFree(rgDomainRecs, DnsFreeRecordListDeep);

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   RCodeSrvFailTest
//
// Synopsis:   
//
//-----------------------------------------------------------------------------
DWORD
RCodeSrvFailTest(PWSTR pwzDnsDomain)
{
   DNS_STATUS status = NO_ERROR;
   PDNS_RECORD rgDnsRecs, pDnsRec;
   IP4_ARRAY ipServer = {0};
   DWORD i;
   BOOL fNSfound = FALSE;
   PWSTR pwzDomainList;

   /* Skip the SOA test as per LevonE's 6/16/00 spec revision
   status = DnsQuery_W(pwzDnsDomain, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   if (DNS_ERROR_RCODE_NO_ERROR != status)
   {
      switch (status)
      {
      case DNS_ERROR_RCODE_NAME_ERROR:
      case DNS_INFO_NO_RECORDS:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_NAME_ERROR, pwzDnsDomain);
         break;

      default:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
         break;
      }
      PrintMessage(SEV_ALWAYS, L"\n");
      return status;
   }

   pDnsRec = rgDnsRecs;

   while (pDnsRec)
   {
      PrintMessage(SEV_DEBUG, L"\nSOA query returned record type %d\n", pDnsRec->wType);
      switch (pDnsRec->wType)
      {
      case DNS_TYPE_A:
         PrintMessage(SEV_DEBUG, L"\nA record, name: %s, IP address:  %d.%d.%d.%d\n",
                      pDnsRec->pName, IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));
         ipServer.AddrArray[0] = pDnsRec->Data.A.IpAddress;
         ipServer.AddrCount = 1;
         break;

      case DNS_TYPE_SOA:
         PrintMessage(SEV_DEBUG, L"\nSOA zone name: %s, zone primary server: %s\n",
                      pDnsRec->pName, pDnsRec->Data.SOA.pNamePrimaryServer);
         break;

      default:
         break;
      }

      pDnsRec = pDnsRec->pNext;
   }

   DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

   if (!ipServer.AddrCount)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, NO_ERROR); // Better message maybe?
      PrintMessage(SEV_ALWAYS, L"\n");
      return NO_ERROR;
   }
   */

   status = DnsQuery_W(pwzDnsDomain, DNS_TYPE_NS, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   if (DNS_ERROR_RCODE_NO_ERROR != status)
   {
      switch (status)
      {
      case DNS_ERROR_RCODE_NAME_ERROR:
      case DNS_INFO_NO_RECORDS:
         if (!BuildList(&pwzDomainList, pwzDnsDomain))
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
         }

         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_NS_REC_RCODE1, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL2, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL3);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL4, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_NS_REC_RCODE5);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_NS_REC_RCODE6);
         PrintMessage(SEV_ALWAYS, L"\n");

         LocalFree(pwzDomainList);
         break;

      default:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
         break;
      }
      PrintMessage(SEV_ALWAYS, L"\n");
      return status;
   }

   ipServer.AddrArray[0] = 0;
   ipServer.AddrCount = 0;

   pDnsRec = rgDnsRecs;

   while (pDnsRec)
   {
      PrintMessage(SEV_DEBUG, L"\nNS query returned record type %d\n", pDnsRec->wType);
      switch (pDnsRec->wType)
      {
      case DNS_TYPE_A:
         PrintMessage(SEV_DEBUG, L"\nA record, name: %s, IP address:  %d.%d.%d.%d\n",
                      pDnsRec->pName, IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));
         ipServer.AddrArray[0] = pDnsRec->Data.A.IpAddress;
         ipServer.AddrCount = 1;
         break;

      case DNS_TYPE_NS:
         fNSfound = TRUE;
         PrintMessage(SEV_DEBUG, L"\nNS name: %s, host: %s\n",
                      pDnsRec->pName, pDnsRec->Data.NS.pNameHost);
         break;

      default:
         break;
      }

      pDnsRec = pDnsRec->pNext;
   }

   DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

   i = 0;

   if (fNSfound && !g_fDNSserver)
   {
      while (g_rgIpAddr[i])
      {
         if (ipServer.AddrArray[0] == g_rgIpAddr[i])
         {
            // if the DNS server is not locally installed, print success.
            //
            PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_UPDATE_OK);
            PrintMessage(SEV_ALWAYS, L"\n");
            return NO_ERROR;
         }
         i++;
      }
   }

   if (!BuildList(&pwzDomainList, pwzDnsDomain))
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   PrintMsg(SEV_ALWAYS, DCDIAG_ERR_RCODE_SRV1, pwzDnsDomain);
   PrintMessage(SEV_ALWAYS, L"\n");
   PrintMsg(SEV_ALWAYS, DCDIAG_ERR_RCODE_SRV2, pwzDnsDomain);
   PrintMessage(SEV_ALWAYS, L"\n");
   PrintMsg(SEV_ALWAYS, DCDIAG_ERR_RCODE_SRV3);
   PrintMessage(SEV_ALWAYS, L"\n");
   PrintMsg(SEV_ALWAYS, DCDIAG_ERR_RCODE_SRV4, pwzDomainList);
   PrintMessage(SEV_ALWAYS, L"\n");
   PrintMsg(SEV_ALWAYS, DCDIAG_ERR_RCODE_SRV5);
   PrintMessage(SEV_ALWAYS, L"\n");

   LocalFree(pwzDomainList);

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
// Function:   ARecordRegisterCheck
//
// Synopsis:   Verify that the server will be able to register A record for
//             its computer name after successful promotion to a DC. (step 6)
//
//-----------------------------------------------------------------------------
DWORD
ARecordRegisterCheck(PWSTR pwzComputerLabel, PWSTR pwzComputerDnsSuffix,
                     PWSTR pwzDnsDomain)
{
   DNS_STATUS status = NO_ERROR, status2;
   PDNS_RECORD rgDnsRecs, pDnsRec, pDnsRec1;
   PWSTR pwzTmp, pwzFullComputerName, pwzAuthZone = NULL, pwzDomainList;
   IP4_ARRAY ipServer = {0};
   BOOL fMatched = FALSE;

   pwzTmp = ConcatonateStrings(pwzComputerLabel, L".");

   if (!pwzTmp)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   pwzFullComputerName = ConcatonateStrings(pwzTmp, pwzComputerDnsSuffix);

   if (!pwzFullComputerName)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      LocalFree(pwzTmp);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   LocalFree(pwzTmp);

   //
   // Verify that the zone(s) authoritative for the records to be registered
   // can be discovered and that it can be dynamically updated.
   //

   status = DnsUpdateTest_W(0, pwzFullComputerName, 0, 0);

   switch (status)
   {
   case NO_ERROR:
   case DNS_ERROR_RCODE_NXRRSET:
   case DNS_ERROR_RCODE_YXDOMAIN:
      PrintMsg(SEV_ALWAYS, DCDIAG_A_RECORD_OK);
      PrintMessage(SEV_ALWAYS, L"\n");
      status = NO_ERROR;
      break;

   case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
   case DNS_ERROR_RCODE_SERVER_FAILURE:

      status2 = DnsQuery_W(pwzFullComputerName, DNS_TYPE_SOA,
                           DNS_QUERY_BYPASS_CACHE, NULL, &rgDnsRecs, NULL);

      if (DNS_ERROR_RCODE_NO_ERROR != status2)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status2);
         PrintMessage(SEV_ALWAYS, L"\n");
         return status2;
      }

      g_wzIpAddr[0] = L'\0';

      pDnsRec = rgDnsRecs;

      while (pDnsRec)
      {
         PrintMessage(SEV_DEBUG, L"\nSOA query returned record type %d\n", pDnsRec->wType);
         switch (pDnsRec->wType)
         {
         case DNS_TYPE_A:
            PrintMessage(SEV_DEBUG, L"\nA record, name: %s, IP address:  %d.%d.%d.%d\n",
                         pDnsRec->pName, IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));

            wsprintf(g_wzIpAddr, L"%d.%d.%d.%d", IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));

            ipServer.AddrArray[0] = pDnsRec->Data.A.IpAddress;
            ipServer.AddrCount = 1;

            break;

         case DNS_TYPE_SOA:
            PrintMessage(SEV_DEBUG, L"\nSOA zone name: %s, zone primary server: %s\n",
                         pDnsRec->pName, pDnsRec->Data.SOA.pNamePrimaryServer);
            pwzAuthZone = AllocString(pDnsRec->pName);
            break;

         default:
            break;
         }

         pDnsRec = pDnsRec->pNext;
      }

      DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

      if (!g_wzIpAddr)
      {
         wcscpy(g_wzIpAddr, L"unknown");
      }

      if (!pwzAuthZone)
      {
         pwzAuthZone = AllocString(L"zone_unknown");
      }

      if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == status)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_NI1, g_wzIpAddr, pwzAuthZone);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_NI2);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_NI3, pwzAuthZone, g_wzIpAddr);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_NI4, pwzAuthZone);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_NI5);
         PrintMessage(SEV_ALWAYS, L"\n");
      }
      else // DNS_ERROR_RCODE_SERVER_FAILURE
      {
         if (pwzComputerDnsSuffix == pwzDnsDomain && !g_fDNSserver)
         {
            if (!ipServer.AddrCount)
            {
               PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, NO_ERROR); // Better message maybe?
               LocalFree(pwzFullComputerName);
               LocalFree(pwzAuthZone);
               PrintMessage(SEV_ALWAYS, L"\n");
               return NO_ERROR;
            }

            status2 = DnsQuery_W(pwzDnsDomain, DNS_TYPE_NS,
                                 DNS_QUERY_NO_RECURSION | DNS_QUERY_BYPASS_CACHE,
                                 &ipServer, &rgDnsRecs, NULL);

            if (NO_ERROR != status2)
            {
               LocalFree(pwzFullComputerName);
               LocalFree(pwzAuthZone);
               return NO_ERROR;
            }

            // See if at least one of the A record computer names matches the
            // local computer's name.
            //

            pDnsRec = rgDnsRecs;

            while (pDnsRec)
            {
               PrintMessage(SEV_DEBUG, L"\nNS query returned record type %d\n", pDnsRec->wType);
               if (DNS_TYPE_A == pDnsRec->wType)
               {
                  PrintMessage(SEV_DEBUG, L"\nA record, name: %s, IP address:  %d.%d.%d.%d\n",
                               pDnsRec->pName, IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));

                  if (_wcsicmp(pDnsRec->pName, pwzFullComputerName) == 0)
                  {
                     fMatched = TRUE;
                     break;
                  }
               }

               pDnsRec = pDnsRec->pNext;
            }

            DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);
         }

         if (fMatched)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_UPDATE_OK);
            PrintMessage(SEV_ALWAYS, L"\n");
         }
         else
         {
            if (!BuildList(&pwzDomainList, pwzFullComputerName))
            {
               PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
               LocalFree(pwzFullComputerName);
               LocalFree(pwzAuthZone);
               return ERROR_NOT_ENOUGH_MEMORY;
            }

            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL1, pwzFullComputerName);
            PrintMessage(SEV_ALWAYS, L"\n");
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL2, pwzFullComputerName);
            PrintMessage(SEV_ALWAYS, L"\n");
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL3);
            PrintMessage(SEV_ALWAYS, L"\n");
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL4, pwzDomainList);
            PrintMessage(SEV_ALWAYS, L"\n");
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL5);
            PrintMessage(SEV_ALWAYS, L"\n");

            LocalFree(pwzDomainList);
         }
      }

      LocalFree(pwzAuthZone);
      break;

   default:
      PrintMsg(SEV_ALWAYS, DCDIAG_ERR_DNS_UPDATE_PARAM, status);
      PrintMessage(SEV_ALWAYS, L"\n");
      status = NO_ERROR;
      break;
   }

   LocalFree(pwzFullComputerName);

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   GetMachineInfo
//
// Synopsis:   Get info on the target (local) machine such as IP address,
//             servers status, etc.
//
//-----------------------------------------------------------------------------
void
GetMachineInfo(void)
{
   PDSROLE_UPGRADE_STATUS_INFO pUpgradeInfo = NULL;
   PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBasicInfo = NULL;
   PMIB_IPADDRTABLE pAddrTable = NULL;
   DWORD dwErr, dwSize = 0, i, j = 0;
   SC_HANDLE hSC, hDNSsvc;
   SERVICE_STATUS SvcStatus;

   // What is the machine's IP address(s)
   //

   dwErr = GetIpAddrTable(NULL, &dwSize, FALSE);

   if (ERROR_INSUFFICIENT_BUFFER != dwErr)
   {
      PrintMessage(SEV_ALWAYS, L"Reading the size of the adapter address data failed with error %d\n", dwErr);
      return;
   }

   pAddrTable = LocalAlloc(LMEM_FIXED, dwSize);

   if (!pAddrTable)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return;
   }

   dwErr = GetIpAddrTable(pAddrTable, &dwSize, FALSE);

   if (NO_ERROR != dwErr)
   {
      PrintMessage(SEV_ALWAYS, L"Reading the adapter addresses failed with error %d\n", dwErr);
      LocalFree(pAddrTable);
      return;
   }

   for (i = 0; i < pAddrTable->dwNumEntries; i++)
   {
      if (pAddrTable->table[i].dwAddr && DCDIAG_LOOPBACK_ADDR != pAddrTable->table[i].dwAddr)
      {
         g_rgIpAddr[j] = pAddrTable->table[i].dwAddr;
         PrintMessage(SEV_DEBUG, L"\nServer IP address: %d.%d.%d.%d (0x%08x)\n",
                      IP_STRING_FMT_ARGS(g_rgIpAddr[j]), g_rgIpAddr[j]);
         j++;
         if (DCDIAG_MAX_ADDR <= j)
         {
            break;
         }
      }
   }
   LocalFree(pAddrTable);

   // Is this machine upgraded from an NT4 DC but DCPromo has not yet run?
   //

   DsRoleGetPrimaryDomainInformation(NULL, // server name, change if remoting implemented.
                                     DsRoleUpgradeStatus,
                                     (PBYTE *)&pUpgradeInfo);

   if (pUpgradeInfo)
   {
      if (DSROLE_UPGRADE_IN_PROGRESS == pUpgradeInfo->OperationState)
      {
         g_fUpgradedNT4DC = TRUE;
      }
      DsRoleFreeMemory(pUpgradeInfo);
   }

   // Is this machine a domain controller?
   //

   DsRoleGetPrimaryDomainInformation(NULL, // server name, change if remoting implemented.
                                     DsRolePrimaryDomainInfoBasic,
                                     (PBYTE *)&pBasicInfo);

   if (pBasicInfo)
   {
      if (DsRole_RoleBackupDomainController == pBasicInfo->MachineRole ||
          DsRole_RolePrimaryDomainController == pBasicInfo->MachineRole)
      {
         g_fDC = TRUE;
      }
      DsRoleFreeMemory(pBasicInfo);
   }

   //
   // Is this machine running the DNS server?
   //
   hSC = OpenSCManager(NULL,  // local machine
                       NULL,
                       SC_MANAGER_CONNECT | GENERIC_READ);
   if (!hSC)
   {
      PrintMessage(SEV_ALWAYS, L"Opening the service controller failed with error %d\n", GetLastError());
      return;
   }

   hDNSsvc = OpenService(hSC, L"dns", SERVICE_INTERROGATE);

   CloseServiceHandle(hSC);

   if (hDNSsvc)
   {
      if (ControlService(hDNSsvc, SERVICE_CONTROL_INTERROGATE, &SvcStatus))
      {
         // If we have gotten this far, the service is installed. It doesn't have
         // to be running to set the flag to true.
         //
         g_fDNSserver = TRUE;
      }
      CloseServiceHandle(hDNSsvc);
   }

   return;
}

//+----------------------------------------------------------------------------
//
// Function:   GetComputerDnsSuffix
//
// Synopsis:   Gets the computer DNS domain suffix.
//
//-----------------------------------------------------------------------------
DWORD
GetComputerDnsSuffix(PWSTR * ppwzComputerDnsDomain, PWSTR pwzDnsDomain)
{
   HKEY hKey;
   LONG lRet;
   DWORD dwType, dwSize, dwSync = 0;
   PWSTR pwzComputerDnsSuffix;
   PWSTR pwzSyncDomain = L"SyncDomainWithMembership";
   PWSTR pwzNVDomain = L"NV Domain";
   PWSTR pwzNVSuffix = L"NV PrimaryDnsSuffix";
   PWSTR pwzDnsPolicy = L"Software\\Policies\\Microsoft\\System\\DNSclient";

#if WINVER > 0x0500

   // Additional preliminary step to calculate the primary DNS suffix of the
   // DC for Whistler (the difference is that contrary to W2K's behavior DCs
   // can be renamed in Whistler)
   //

   lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pwzDnsPolicy, 0, KEY_READ, &hKey);

   if (ERROR_SUCCESS != lRet &&
       ERROR_FILE_NOT_FOUND != lRet)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
      return lRet;
   }

   if (NO_ERROR == lRet)
   {
      dwSize = 0;

      lRet = RegQueryValueEx(hKey, pwzNVSuffix, 0, &dwType, NULL, &dwSize);

      if (ERROR_SUCCESS == lRet)
      {

         pwzComputerDnsSuffix = LocalAlloc(LMEM_FIXED, ++dwSize * sizeof(WCHAR));

         if (!pwzComputerDnsSuffix)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            RegCloseKey(hKey);
            return ERROR_NOT_ENOUGH_MEMORY;
         }

         lRet = RegQueryValueEx(hKey, pwzNVSuffix, 0, &dwType, (PBYTE)pwzComputerDnsSuffix, &dwSize);

         RegCloseKey(hKey);

         if (ERROR_SUCCESS != lRet)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
            return lRet;
         }

         *ppwzComputerDnsDomain = pwzComputerDnsSuffix;

         return NO_ERROR;
      }
   }

#endif // Whistler-only step

   // Common steps for Whistler and for QFE.
   //

   lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_pwzTcpIpParams, 0, KEY_READ, &hKey);

   if (ERROR_SUCCESS != lRet)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
      return lRet;
   }

   dwSize = sizeof(dwSync);

   lRet = RegQueryValueEx(hKey, pwzSyncDomain, 0, &dwType, (PBYTE)&dwSync, &dwSize);

   if (ERROR_SUCCESS != lRet)
   {
      if (ERROR_FILE_NOT_FOUND == lRet)
      {
         dwSync = 1;
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
         RegCloseKey(hKey);
         return lRet;
      }
   }

   if (0 != dwSync)
   {
      // Use the DNS domain name specified on the command line.
      //
      pwzComputerDnsSuffix = pwzDnsDomain;
   }
   else
   {
      dwSize = 0;

      lRet = RegQueryValueEx(hKey, pwzNVDomain, 0, &dwType, NULL, &dwSize);

      if (ERROR_SUCCESS != lRet)
      {
         RegCloseKey(hKey);

         if (ERROR_FILE_NOT_FOUND == lRet)
         {
            // Use the DNS domain name specified on the command line.
            //
            pwzComputerDnsSuffix = pwzDnsDomain;
            goto Done;
         }
         else
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
            return lRet;
         }
      }

      pwzComputerDnsSuffix = LocalAlloc(LMEM_FIXED, ++dwSize * sizeof(WCHAR));

      if (!pwzComputerDnsSuffix)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
         RegCloseKey(hKey);
         return ERROR_NOT_ENOUGH_MEMORY;
      }

      // Use the NV Domain value.
      //
      lRet = RegQueryValueEx(hKey, pwzNVDomain, 0, &dwType, (PBYTE)pwzComputerDnsSuffix, &dwSize);

      RegCloseKey(hKey);

      if (ERROR_SUCCESS != lRet)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
         return lRet;
      }

      *ppwzComputerDnsDomain = pwzComputerDnsSuffix;

      return NO_ERROR;
   }

Done:

   *ppwzComputerDnsDomain = AllocString(pwzComputerDnsSuffix);

   if (!*ppwzComputerDnsDomain)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   return NO_ERROR;

/*
   GetComputerNameEx(ComputerNameDnsDomain, NULL, &dwSize);

   if (!dwSize)
   {
      return GetLastError();
   }

   pwzComputerDnsSuffix = LocalAlloc(LMEM_FIXED, ++dwSize * sizeof(WCHAR));

   if (!pwzComputerDnsSuffix)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   if (!GetComputerNameEx(ComputerNameDnsDomain, pwzComputerDnsSuffix, &dwSize))
   {
      dwRet = GetLastError();
      PrintMsg(SEV_ALWAYS, DCDIAG_GATHERINFO_CANT_GET_LOCAL_COMPUTERNAME,
               Win32ErrToString(dwRet));
      LocalFree(pwzComputerDnsSuffix);
      return dwRet;
   }
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\ds\dcma.c ===
/*++                

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dcma.c

ABSTRACT:

    Contains tests related to the domain controller's machine account.  
    
DETAILS:

CREATED:

    8 July 1999  Dmitry Dukat (dmitrydu)

REVISION HISTORY:
        

--*/

//defines for the SPN's
#define sLDAP L"LDAP"
#define sHOST L"HOST"
#define sGC   L"GC"
#define sREP  L"E3514235-4B06-11D1-AB04-00C04FC2DCD2"
#define NUM_OF_SPN 11

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include <lmaccess.h>

#include <dsconfig.h>                   // Definition of mask for visible
// containers

#include <lmcons.h>                     // CNLEN
#include <lsarpc.h>                     // PLSAPR_foo
#include <lmerr.h>
#include <lsaisrv.h>

#include <winldap.h>
#include <dns.h>
#include <ntdsapip.h>


#include "dcdiag.h"
#include "dstest.h"

// forward from repair.c
DWORD
RepairDCWithoutMachineAccount(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    );


//local prototypes
DWORD
CDCMA_CheckDomainOU(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext);

DWORD
CDCMA_CheckForExistence(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext);


DWORD
CDCMA_CheckServerFlags(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext,
                   OUT DWORD *                     pdwUserAccountControl,
                   OUT WCHAR **                    ppwzCompDN);

DWORD
CDCMA_FixServerFlags(
                   IN  LDAP  *                     hLdap,
                   IN  DWORD                       dwUserAccountControl,
                   IN  WCHAR *                     pwzCompObjDN);

DWORD
CDCMA_CheckServerReference(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext);

DWORD
CDCMA_CheckSPNs(
               IN  PDC_DIAG_DSINFO             pDsInfo,
               IN  ULONG                       ulCurrTargetServer,
               IN  LDAP  *                     hLdap,
               IN  WCHAR *                     name,
               IN  WCHAR *                     defaultNamingContext,
               SEC_WINNT_AUTH_IDENTITY_W *     gpCreds);

DWORD
CS_CheckSPNs(
    IN  LDAP  *                     hLdap,
    IN  HANDLE                      hDsBinding,
    IN  WCHAR **                    SPNs,
    IN  DWORD                       dwReplSpnIndex,
    IN  WCHAR *                     name,
    IN  WCHAR *                     defaultNamingContext
    );

BOOL
GetNetBIOSDomainName(
                    WCHAR                     **DomainName,
                    WCHAR                      *wComputerName,
                    SEC_WINNT_AUTH_IDENTITY_W  *gpCreds);

BOOL
GetdnsMachine(LDAP *hLdap,
              WCHAR **ReturnString);


DWORD
getGUID(
       PDC_DIAG_DSINFO                     pDsInfo,
       IN  ULONG                           ulCurrTargetServer,
       WCHAR **                            ppszServerGuid);


DWORD
WrappedMakeSpnW(
               WCHAR   *ServiceClass,
               WCHAR   *ServiceName,
               WCHAR   *InstanceName,
               USHORT  InstancePort,
               WCHAR   *Referrer,
               DWORD   *pcbSpnLength, // Note this is somewhat different that DsMakeSPN
               WCHAR   **ppszSpn);



DWORD 
CheckDCMachineAccount(
                     PDC_DIAG_DSINFO                     pDsInfo,
                     ULONG                               ulCurrTargetServer,
                     SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
                     )

/*++

Routine Description:

    This is a test called from the dcdiag framework.  This test  
    Does sanity checks on the Domain Controller Machine Account in the ds
    Check to see if Current DC is in the domain controller's OU
    Check that useraccountcontrol has UF_SERVER_TRUST_ACCOUNT
    Check to see if the machine account is trusted for delegation
    Check's to see if the minimum SPN's are there
    Makes sure that that the server reference is set up correctly.  
    Helper functions of this function all begin with "CDCMA_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    NO_ERROR, if all NCs checked out.
    A Win32 Error if any NC failed to check out.

--*/
{
    DWORD  dwRet = ERROR_SUCCESS, dwErr = ERROR_SUCCESS;
    LDAP   *hLdap = NULL;
    WCHAR  *defaultNamingContext=NULL;
    WCHAR  *pwzCompObjDN = NULL;
    HANDLE phDsBinding=NULL;
    DWORD dwUserAccountControl = 0;

    //Assert(gpCreds);
    Assert(pDsInfo);

    
    //create a connection with the DS using LDAP
    dwErr = DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                 gpCreds,
                                 FALSE,
                                 &hLdap);

    if ( dwErr != LDAP_SUCCESS )
    {
        dwErr = LdapMapErrorToWin32(dwErr);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP bind failed with error %d. %s\n",
                     pDsInfo->pServers[ulCurrTargetServer].pszName,
                     dwErr,
                     Win32ErrToString(dwErr));
        return dwErr;
    }

    //find the defaultNamingContext
    dwErr=FinddefaultNamingContext(hLdap,&defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    //
    // Check to see if machine account exists locally, if not, call into
    // the repair code 
    //
    dwErr=CDCMA_CheckForExistence(hLdap,
                                  pDsInfo->pServers[ulCurrTargetServer].pszName,
                                  defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        DWORD RepairStatus = dwErr;

        if ( (dwErr == ERROR_NO_TRUST_SAM_ACCOUNT)
          && (pDsInfo->ulHomeServer == ulCurrTargetServer) ) {

            BOOL fRepairMachineAccount = FALSE;
            ULONG i;

            for(i=0; pDsInfo->ppszCommandLine[i] != NULL ; i++) {

                if (!_wcsnicmp(pDsInfo->ppszCommandLine[i],
                               RECREATE_MACHINE_ACCT_ARG,
                               wcslen(RECREATE_MACHINE_ACCT_ARG)) ) {

                    fRepairMachineAccount = TRUE;
                    break;

                }
            }

            if ( fRepairMachineAccount ) {
                  
                //
                // If the local machine does not have a machine account and
                // the user has asked us to try and repair this condition,
                // then we'll try.
                //
    
                PrintMsg(SEV_ALWAYS,
                         DCDIAG_DCMA_REPAIR_ATTEMPT,
                         pDsInfo->pServers[ulCurrTargetServer].pszName );
    
                RepairStatus =  RepairDCWithoutMachineAccount( pDsInfo,
                                                               ulCurrTargetServer,
                                                           gpCreds );

            } else  {

                PrintMsg(SEV_ALWAYS,
                         DCDIAG_DCMA_REPAIR_TRY_REPAIR,
                         pDsInfo->pServers[ulCurrTargetServer].pszName );

            }
        }

        dwRet = RepairStatus;

    }


    dwErr=CDCMA_CheckDomainOU(hLdap,
                              pDsInfo->pServers[ulCurrTargetServer].pszName,
                              defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        dwRet = dwErr;
    }

    dwErr=CDCMA_CheckServerFlags(hLdap,
                                 pDsInfo->pServers[ulCurrTargetServer].pszName,
                                 defaultNamingContext,
                                 &dwUserAccountControl,
                                 &pwzCompObjDN);
    if ( dwErr != NO_ERROR )
    {
        if (ERROR_INVALID_FLAGS == dwErr)
        {
            BOOL fFixMachineAcctFlags = FALSE;
            int i;

            for (i = 0; pDsInfo->ppszCommandLine[i] != NULL ; i++)
            {
                if (!_wcsnicmp(pDsInfo->ppszCommandLine[i],
                               FIX_MACHINE_ACCT_ARG,
                               wcslen(FIX_MACHINE_ACCT_ARG)))
                {
                    fFixMachineAcctFlags = TRUE;
                    break;
                }
            }

            if (fFixMachineAcctFlags && pwzCompObjDN)
            {
                dwErr = CDCMA_FixServerFlags(hLdap,
                                             dwUserAccountControl,
                                             pwzCompObjDN);
                if (NO_ERROR == dwErr)
                {
                    PrintMsg(SEV_ALWAYS, DCDIAG_DCMA_FLAGS_FIXED);
                }
                else
                {
                    PrintMsg(SEV_ALWAYS, DCDIAG_DCMA_CANT_FIX, dwErr);
                }
            }
            else
            {
                PrintMsg(SEV_ALWAYS, DCDIAG_DCMA_FLAGS_TRY_FIX);
            }
        }

        dwRet = dwErr;
    }

    if (pwzCompObjDN)
    {
        LocalFree(pwzCompObjDN);
    }


    dwErr=CDCMA_CheckServerReference(hLdap,
                                     pDsInfo->pServers[ulCurrTargetServer].pszName,
                                     defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        dwRet = dwErr;
    }

    dwErr=CDCMA_CheckSPNs(pDsInfo,
                          ulCurrTargetServer,
                          hLdap,
                          pDsInfo->pServers[ulCurrTargetServer].pszName,
                          defaultNamingContext,
                          gpCreds);
    if ( dwErr != NO_ERROR )
    {
        dwRet = dwErr;
    }

    return dwRet;
}


DWORD
CDCMA_CheckDomainOU(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext)
/*++

Routine Description:

    This function will check to see if the current DC is
    in the domain controller's OU

Arguments:

    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    ReturnString - The defaultNamingContext

Return Value:

    A WinError is return to indicate if there were any problems.

--*/

{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *Base=NULL;

    WCHAR        *filter=NULL;

    WCHAR        *sname=NULL;

    DWORD        WinError=NO_ERROR;

    ULONG        Length;


    //check parameters
    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"sAMAccountName";
    AttrsToSearch[1]=NULL;

    #pragma prefast(disable: 255, "alloca can throw, but Prefast doesn't see the exception block in main.c::DcDiagRunTest")
    //sam account name
    Length = wcslen (name) + 1;
    sname = (WCHAR*) alloca( (Length + 1) * sizeof(WCHAR) );
    wcscpy(sname,name);
    wcscat(sname,L"$");

    //built the filter
    Length = wcslen (sname) + wcslen (L"sAMAccountName=") + 1;
    filter = (WCHAR*) alloca( (Length + 1) * sizeof(WCHAR) );
    wsprintf(filter,L"sAMAccountName=%s",sname);


    //built the Base
    Length= wcslen( L"OU=Domain Controllers," ) +
            wcslen( defaultNamingContext );

    Base=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );

    wsprintf(Base,L"OU=Domain Controllers,%s",defaultNamingContext);


    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_ONELEVEL,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        if (SearchResult)
        {
           ldap_msgfree( SearchResult );
        }
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        if ( !_wcsicmp( sname, Values[0] ) )
                        {
                            ldap_msgfree( SearchResult );
                            return NO_ERROR;
                        }
                    }
                }
            }
        }
    }

    //clean up
    ldap_msgfree( SearchResult );

    PrintMessage(SEV_ALWAYS,
                 L"* The current DC is not in the domain controller's OU\n");
    return ERROR_DS_CANT_RETRIEVE_ATTS;
}



DWORD
CDCMA_CheckServerFlags(
                      IN  LDAP  *                     hLdap,
                      IN  WCHAR *                     name,
                      IN  WCHAR *                     defaultNamingContext,
                      OUT DWORD *                     pdwUserAccountControl,
                      OUT WCHAR **                    ppwzCompDN)
/*++

Routine Description:

    This function will check to see if the current DC has
    UF_SERVER_TRUST_ACCOUNT and UF_TRUSTED_FOR _DELEGATION
    set.  Also will check to see if objectClass includes
    computer.
    
Arguments:

    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    ReturnString - The defaultNamingContext

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[4];

    WCHAR        *filter=NULL;

    DWORD        WinError=NO_ERROR;

    DWORD        userAccountControl=0;

    ULONG        Length;

    BOOL         isComputer=FALSE;                     //assume false until test
    BOOL         isTrust=TRUE;                         //assume true  until test
    BOOL         isTrustedDelegation=TRUE;             //assume true  until test


    //check parameters
    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"userAccountControl";
    AttrsToSearch[1]=L"objectClass";
    AttrsToSearch[2]=L"distinguishedName";
    AttrsToSearch[3]=NULL;


    //built the filter
    Length= wcslen( L"sAMAccountName=$" ) +
            wcslen( name );

    filter=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(filter,L"sAMAccountName=%s$",name);

    LdapError = ldap_search_sW( hLdap,
                                defaultNamingContext,
                                LDAP_SCOPE_SUBTREE,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        if (SearchResult)
        {
           ldap_msgfree( SearchResult );
        }
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found userAccountControl
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        userAccountControl=_wtoi(Values[0]);
                        //check to see if the UF_TRUSTED_FOR_DELEGATION is set
                        if ( !(( userAccountControl & UF_SERVER_TRUST_ACCOUNT ) == 
                               UF_SERVER_TRUST_ACCOUNT) )
                        {
                            isTrust=FALSE;
                        }
                        if ( !(( userAccountControl & UF_TRUSTED_FOR_DELEGATION ) == 
                               UF_TRUSTED_FOR_DELEGATION) )
                        {
                            isTrustedDelegation=FALSE;
                        }
                        if (pdwUserAccountControl)
                        {
                            *pdwUserAccountControl = userAccountControl;
                        }
                    }
                    ldap_value_freeW(Values);
                    continue;
                }
                if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                {
                    DWORD       i = 0;
                    //
                    // Found objectClass - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    while ( Values && Values[i] )
                    {
                        if ( _wcsicmp( Values[i], L"computer" ) == 0)
                        {
                            isComputer=TRUE;
                            break;
                        }
                        i++;
                    }
                    ldap_value_freeW(Values);
                    continue;
                }
                if (!_wcsicmp(Attr, AttrsToSearch[2]) && ppwzCompDN)
                {
                    Values = ldap_get_valuesW(hLdap, Entry, Attr);
                    ASSERT(Values[0]);
                    *ppwzCompDN = LocalAlloc(LPTR, (wcslen(Values[0]) + 1) * sizeof(WCHAR));
                    if (!*ppwzCompDN)
                    {
                        WinError = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                    else
                    {
                        wcscpy(*ppwzCompDN, Values[0]);
                    }
                    ldap_value_freeW(Values);
                }
            }
        }
    }


    //clean up
    ldap_msgfree( SearchResult );


    //Display errors
    if ( !isTrust )
    {
        PrintMsg(SEV_ALWAYS, DCDIAG_DCMA_FLAG_TRUST_MISSING, name);
        WinError = ERROR_INVALID_FLAGS;
    }

    if ( !isTrustedDelegation )
    {
        PrintMsg(SEV_ALWAYS, DCDIAG_DCMA_FLAG_DELEG_MISSING, name);
        WinError = ERROR_INVALID_FLAGS;
    }

    if ( !isComputer )
    {
        PrintMsg(SEV_ALWAYS, DCDIAG_DCMA_WRONG_CLASS, name);
        return ERROR_OBJECT_NOT_FOUND;    
    }

    return WinError;
}


DWORD
CDCMA_CheckServerReference(
                          IN  LDAP  *                     hLdap,
                          IN  WCHAR *                     name,
                          IN  WCHAR *                     defaultNamingContext)
/*++

Routine Description:

    This function will check to see if the server
    reference's are set up correctly
        
Arguments:

    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    ReturnString - The defaultNamingContext

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[3];

    WCHAR        *Base=NULL;

    DWORD        WinError=NO_ERROR;

    WCHAR        *serverReference=NULL;

    ULONG        Length;
    BOOL         found=FALSE;


    //check parameters
    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"serverReference";
    AttrsToSearch[1]=NULL;

    WinError=FindServerRef(hLdap,&Base);
    if ( WinError != NO_ERROR )
    {
        goto cleanup;
    }

    WinError=GetMachineReference(hLdap,name,defaultNamingContext,&serverReference);
    if ( WinError != NO_ERROR )
    {
        goto cleanup;
    }


    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                L"objectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    if ( LDAP_SUCCESS != LdapError )
    {
        if (SearchResult)
        {
           ldap_msgfree( SearchResult );
        }
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        if ( _wcsicmp( Values[0], serverReference ) )
                        {
                            ldap_msgfree( SearchResult );
                            PrintMessage(SEV_ALWAYS,
                                         L"* %s Server Reference is incorrect\n"
                                         ,name);
                            return ERROR_DS_NO_ATTRIBUTE_OR_VALUE;    
                        }
                    }
                }
            }
        }
    }

    cleanup:
    //clean up
    if ( SearchResult )
        ldap_msgfree( SearchResult );
    if ( Base )
        free(Base);
    if ( serverReference )
        free(serverReference);

    return NO_ERROR;

}

DWORD
CDCMA_CheckSPNs(
               IN  PDC_DIAG_DSINFO             pDsInfo,
               IN  ULONG                       ulCurrTargetServer,
               IN  LDAP  *                     hLdap,
               IN  WCHAR *                     name,
               IN  WCHAR *                     defaultNamingContext,
               SEC_WINNT_AUTH_IDENTITY_W *     gpCreds)
/*++

Routine Description:

    This function will check to see if the proper
    SPN are published and that the minimum ones are
    there.
        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    ReturnString - The defaultNamingContext
    gpCreds - The command line credentials if any that were passed in.

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{  
    WCHAR           *NetBiosDomainName=NULL;
    WCHAR           *SPNs[14];
    ULONG           Length=0;
    ULONG           i=0;
    WCHAR           *pszServerGuid;
    WCHAR           *ppszServerGuid;
    DWORD           dwErr=NO_ERROR;
    WCHAR           *dnsMachine=NULL;
    WCHAR           *dnsDomain=NULL;
    DWORD           c;
    BOOL            gotDNSMname=FALSE;
    BOOL            gotNBDname=FALSE;
    HANDLE          hDsBinding=NULL;
    WCHAR           **NameToConvert;
    PDS_NAME_RESULT ppResult=NULL;
    DWORD           dwReplSpnIndex = 0;

    //init
    for ( i=0;i<NUM_OF_SPN;i++ )
        SPNs[i]=0;

    //set up useful vars for SPNs
    
    if ( !GetNetBIOSDomainName(&NetBiosDomainName,name,gpCreds) )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not get NetBIOSDomainName\n");
    }

    //construct the dnsMachine name
    if ( !GetdnsMachine(hLdap,&dnsMachine) )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not get dnsHost\n");
    }

    //construct the dnsDomain name
    dwErr=DcDiagGetDsBinding(
                        &pDsInfo->pServers[ulCurrTargetServer],
                        gpCreds,
                        &hDsBinding
                        );
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Error: %d: [%s].  Could not perform DsBind() with [%s].  Some SPN's Will not be checked\n",
                     dwErr,
                     Win32ErrToString(dwErr),
                     pDsInfo->pServers[ulCurrTargetServer].pszName);
        PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
    }


    //convert DN name to DNS name
    if (dwErr == NO_ERROR)
    {
        dwErr=DsCrackNames(
                            hDsBinding,
                            DS_NAME_NO_FLAGS,
                            DS_FQDN_1779_NAME,
                            DS_CANONICAL_NAME,
                            1,
                            &defaultNamingContext,
                            &ppResult);
        if ( dwErr != NO_ERROR && ppResult->rItems->status != NO_ERROR)
        {
            PrintMessage(SEV_ALWAYS,
                         L"Error: %d: [%s].  Could not perform DsCrackNames() with [%s].  Some SPN's Will not be checked\n",
                         dwErr,
                         Win32ErrToString(dwErr),
                         pDsInfo->pServers[ulCurrTargetServer].pszName);
            PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        }
        else
        {
            //place name in dnsDomain variable
            ASSERT( ppResult->rItems->pName );
            Length = wcslen( ppResult->rItems->pName );

            dnsDomain = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
            wcscpy(dnsDomain, ppResult->rItems->pName);
            //free results
            DsFreeNameResult(ppResult);
            //remove trailing slash
            dnsDomain[wcslen(dnsDomain)-1]=L'\0';
        }
    }

    
    



    //prepare the spn's to search for

    // Make the first LDAP SPN
    // This is of the format
    //   LDAP/host.dns.name/domain.dns.name
    //
    dwErr = WrappedMakeSpnW(sLDAP,
                            dnsDomain,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[0]);
    if ( dwErr != NO_ERROR || !dnsMachine || !dnsDomain)
    {
        if ( dnsMachine && dnsDomain)
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for LDAP SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
            PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for LDAP SPN\n");
        }
        if ( SPNs[0] )
        {
            free(SPNs[0]);
        }
        SPNs[0]=NULL;
    }

    // Make the second LDAP SPN
    // This is of the format
    //   LDAP/host.dns.name
    //
    dwErr = WrappedMakeSpnW(sLDAP,
                            dnsMachine,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[1]);
    if ( dwErr != NO_ERROR || !dnsMachine )
    {
        if ( dnsMachine )
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for LDAP SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
            PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for LDAP SPN\n");
        }
        if ( SPNs[1] )
        {
            free(SPNs[1]);
        }
        SPNs[1]=NULL;
    }

    // Make the third LDAP SPN
    // This is of the format
    //   LDAP/machinename
    //
    dwErr = WrappedMakeSpnW(sLDAP,
                            name,
                            name,
                            0,
                            NULL,
                            &c,
                            &SPNs[2]);
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\nCan not test for LDAP SPN\n",
                     dwErr,
                     Win32ErrToString(dwErr));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        if ( SPNs[2] )
        {
            free(SPNs[2]);
        }
        SPNs[2]=NULL;
    }


    // Make the fourth LDAP SPN
    // This is of the format
    //   LDAP/host.dns.name/netbiosDomainName
    //
    dwErr = WrappedMakeSpnW(sLDAP,
                            NetBiosDomainName,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[3]);
    if ( dwErr != NO_ERROR || !dnsMachine || !NetBiosDomainName )
    {
        if ( dnsMachine && NetBiosDomainName )
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for HOST SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
            PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for HOST SPN\n");
        }
        if ( SPNs[3] )
        {
            free(SPNs[3]);
        }
        SPNs[3]=NULL;
    }

    // Make the fifth LDAP SPN
    // This is of the format
    //   LDAP/guid-based-dns-name
    //
    dwErr = WrappedMakeSpnW(sLDAP,
                            pDsInfo->pServers[ulCurrTargetServer].pszGuidDNSName,
                            pDsInfo->pServers[ulCurrTargetServer].pszGuidDNSName,
                            0,
                            NULL,
                            &c,
                            &SPNs[4]);
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\nCan not test for LDAP SPN\n",
                     dwErr,
                     Win32ErrToString(dwErr));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        if ( SPNs[4] )
        {
            free(SPNs[4]);
        }
        SPNs[4]=NULL;    
    }



    // Make the DRS RPC SPN (for dc to dc replication)
    // This is of the format
    //   E3514235-4B06-11D1-AB04-00C04FC2DCD2/ntdsa-guid/
    //                      domain.dns.name
    //
    dwErr = getGUID(pDsInfo,ulCurrTargetServer,&pszServerGuid);
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\nCan not test for replication SPN\n",
                     dwErr,
                     Win32ErrToString(dwErr));
    }

    if ( dwErr == NO_ERROR )
    {
        dwReplSpnIndex = 5;
        dwErr = WrappedMakeSpnW(sREP,
                                dnsDomain,
                                pszServerGuid,
                                0,
                                NULL,
                                &c,
                                &SPNs[dwReplSpnIndex]);

        if ( dwErr != NO_ERROR || !dnsDomain)
        {
            if (!dnsDomain)
            {
                PrintMessage(SEV_ALWAYS,
                         L"Can not test for replication SPN\n");
            }
            else
            {
                PrintMessage(SEV_ALWAYS,
                             L"Failed with %d: %s\nCan not test for replication SPN\n",
                             dwErr,
                             Win32ErrToString(dwErr));
                PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
            }
            if ( SPNs[dwReplSpnIndex] )
            {
                free(SPNs[dwReplSpnIndex]);
            }
            SPNs[dwReplSpnIndex]=NULL;
        }
    }

    // Make the default host SPN
    // This is of the format
    //   HOST/host.dns.name/domain.dns.name
    //
    dwErr = WrappedMakeSpnW(sHOST,
                            dnsDomain,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[6]);
    if ( dwErr != NO_ERROR || !dnsMachine || !dnsDomain)
    {
        if ( dnsMachine && dnsDomain)
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for HOST SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
            PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for HOST SPN\n");
        }
        if ( SPNs[6] )
        {
            free(SPNs[6]);
        }
        SPNs[6]=NULL;
    }

    // Make the second host SPN - hostDnsName-only HOST SPN
    // This is of the format
    //   HOST/host.dns.name
    //
    dwErr = WrappedMakeSpnW(sHOST,
                            dnsMachine,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[7]);
    if ( dwErr != NO_ERROR || !dnsMachine )
    {
        if ( dnsMachine )
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for HOST SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
            PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for HOST SPN\n");
        }
        if ( SPNs[7] )
        {
            free(SPNs[7]);
        }
        SPNs[7]=NULL;
    }


    // Make the third host SPN - 
    // This is of the format
    //   HOST/machinename
    //
    dwErr = WrappedMakeSpnW(sHOST,
                            name,
                            name,
                            0,
                            NULL,
                            &c,
                            &SPNs[8]);
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\nCan not test for HOST SPN\n",
                     dwErr,
                     Win32ErrToString(dwErr));
        PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        if ( SPNs[8] )
        {
            free(SPNs[8]);
        }
        SPNs[8]=NULL;return dwErr;
    }


    // Make the fourth host SPN - 
    // This is of the format
    //   HOST/host.dns.name/netbiosDoamainName
    //
    dwErr = WrappedMakeSpnW(sHOST,
                            NetBiosDomainName,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[9]);
    if ( dwErr != NO_ERROR || !dnsMachine || !NetBiosDomainName )
    {
        if ( dnsMachine && NetBiosDomainName )
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for HOST SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
            PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for HOST SPN\n");
        }
        if ( SPNs[9] )
        {
            free(SPNs[9]);
        }
        SPNs[9]=NULL;
    }


    // Make the GC SPN. This is done on all systems, even non-GC.
    // results in an SPN of HOST/dot.delimited.dns.host.name form.
    // This is of the format
    //   HOST/host.dns.name/root.domain.dns.name
    //
    dwErr = WrappedMakeSpnW(sGC,
                            pDsInfo->pszRootDomain,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[10]);
    if ( dwErr != NO_ERROR || !dnsMachine )
    {
        if ( dnsMachine )
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for GC SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
            PrintRpcExtendedInfo(SEV_VERBOSE, dwErr);
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for GC SPN\n");
        }
        if ( SPNs[10] )
        {
            free(SPNs[10]);
        }
        SPNs[10]=NULL;
    }


    dwErr=CS_CheckSPNs(hLdap,hDsBinding,SPNs,dwReplSpnIndex,name,defaultNamingContext);

    for ( i=0;i<NUM_OF_SPN;i++ )
    {
        if ( SPNs[i] )
            free(SPNs[i]);
    }

    //clean up
    if ( defaultNamingContext )
        free(defaultNamingContext);
    if ( pszServerGuid )
        free(pszServerGuid);
    if ( NetBiosDomainName )
        free(NetBiosDomainName);
    if ( dnsMachine )
        free(dnsMachine);

    return dwErr;

}

DWORD
CS_CheckSPNs(
    IN  LDAP  *                     hLdap,
    IN  HANDLE                      hDsBinding,
    IN  WCHAR **                    SPNs,
    IN  DWORD                       dwReplSpnIndex,
    IN  WCHAR *                     name,
    IN  WCHAR *                     defaultNamingContext
    )
/*++

Routine Description:

    This is a helper of CS_CheckSPNs
    This function will check to see if the proper
    SPN are published and that the minimum ones are
    there.

    I can also correct a missing replication SPN if so directed.
        
Arguments:

    hLdap - handle to the LDAP server
    hDsBinding - handle to DS server
    SPNs - The constructed SPNs to check                                                  
    dwReplSpnIndex - Index of the replication spn in the SPN array
    name - The NetBIOS name of the current server
    ReturnString - The defaultNamingContext
    
Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;
    ULONG        found[NUM_OF_SPN];
    ULONG        i=0;
    ULONG        j=0;
    ULONG        Length=0;

    WCHAR        *AttrsToSearch[3];

    WCHAR        *Base=NULL;

    DWORD        WinError=NO_ERROR;


    for ( i=0;i<NUM_OF_SPN;i++ )
    {
        found[i]=0;
    }

    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"servicePrincipalName";
    AttrsToSearch[1]=NULL;


    //built the Base
    WinError=GetMachineReference(hLdap,name,defaultNamingContext,&Base);
    if ( WinError != NO_ERROR )
        goto cleanup;


    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                L"objectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        j=0;
                        while ( Values[j] != NULL )
                        {
                            for ( i=0;i<NUM_OF_SPN;i++ )
                            {
                                if ( SPNs[i] && !_wcsicmp(SPNs[i],Values[j]) )
                                {
                                    found[i]=1;
                                }
                            }
                            j++;
                        }
                    }
                }
            }
        }
    }

    // Fix up replication spn if necessary
    if (SPNs[dwReplSpnIndex] &&
        (!found[dwReplSpnIndex]) &&
        (gMainInfo.ulFlags & DC_DIAG_FIX)) {
        DWORD status;

        status = DsWriteAccountSpn( hDsBinding,
                                    DS_SPN_ADD_SPN_OP,
                                    Base,
                                    1,
                                    &(SPNs[dwReplSpnIndex])
                                    );
        if (status != ERROR_SUCCESS) {
            PrintMessage(SEV_ALWAYS,
                         L"Failed to fix computer account object %s by writing missing replication spn %s : error %s\n",
                         Base,
                         SPNs[dwReplSpnIndex],
                         Win32ErrToString(status));
            PrintRpcExtendedInfo(SEV_VERBOSE, status);
        } else {
            PrintMessage(SEV_VERBOSE,
                         L"Fixed computer account object %s by writing missing replication spn %s.\n",
                         Base,
                         SPNs[dwReplSpnIndex] );
            found[dwReplSpnIndex] = TRUE;
        }
    }


    for ( i=0;i<NUM_OF_SPN;i++ )
    {
        if ( found[i] !=1 )
        {
            PrintMessage(SEV_ALWAYS,
                         L"* Missing SPN :%s\n",SPNs[i]);
            WinError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        } else
        {
            PrintMessage(SEV_VERBOSE,
                         L"* SPN found :%s\n",SPNs[i]);
        }

    }

    cleanup:
    if (SearchResult)
    {
        ldap_msgfree( SearchResult );
    }
    if ( Base )
        free(Base);

    return WinError;

}




BOOL
GetNetBIOSDomainName(
                    OUT WCHAR                               **DomainName,
                    IN  WCHAR                               *ServerName,
                    IN  SEC_WINNT_AUTH_IDENTITY_W *         gpCreds)
/*++
 Code taken from Cliff Van Dyke
--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus = NERR_UnknownServer;

    PLSAPR_POLICY_INFORMATION PrimaryDomainInfo = NULL;
    LSAPR_HANDLE PolicyHandle = NULL;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;
    NETRESOURCE NetResource;
    WCHAR *remotename=NULL;
    WCHAR *lpPassword=NULL;
    WCHAR *lpUsername=NULL;
    DWORD dwErr=NO_ERROR;
    BOOL  connected=FALSE;

    *DomainName = NULL;

    if(!gpCreds)
    {
        lpUsername=NULL;
        lpPassword=NULL;

    }
    else
    {
        lpUsername=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Domain)+wcslen(gpCreds->User)+2));
        wsprintf(lpUsername,L"%s\\%s",gpCreds->Domain,gpCreds->User);
        
        lpPassword=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Password)+1));
        wcscpy(lpPassword,gpCreds->Password);
    }

    remotename=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(L"\\\\\\ipc$")+wcslen(ServerName)+1));
    wsprintf(remotename,L"\\\\%s\\ipc$",ServerName);

    NetResource.dwType=RESOURCETYPE_ANY;
    NetResource.lpLocalName=NULL;
    NetResource.lpRemoteName=remotename;
    NetResource.lpProvider=NULL;

    //get permission to access the server
    dwErr=WNetAddConnection2(&NetResource,
                             lpPassword,
                             lpUsername,
                             0);
    if ( dwErr == NO_ERROR )
    {
        connected=TRUE;
    }
    else
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not open pipe with [%s]:failed with %d: %s\n",
                     ServerName,
                     dwErr,
                     Win32ErrToString(dwErr));
        goto cleanup;
    }
    


    //
    // Open the LSA policy
    //

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));



    if ( ServerName != NULL )
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        DInitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    } else
    {
        Server = NULL; // default to local machine
    }

    // Open a Policy
    Status = LsaOpenPolicy(
                          Server,
                          &ObjectAttributes,
                          POLICY_VIEW_LOCAL_INFORMATION,
                          &PolicyHandle
                          );

    //Assert(PolicyHandle);
    if ( !NT_SUCCESS(Status) )
    {
        WNetCancelConnection2(remotename,
                              0,
                              TRUE);
        PrintMessage(SEV_ALWAYS,
                     L"Could not open Lsa Policy\n"
                     );
        goto cleanup;
    }
    *DomainName = NULL;
    
    //
    // Get the Primary Domain info from the LSA.
    //
    Status = LsaQueryInformationPolicy(
                                      PolicyHandle,
                                      PolicyDnsDomainInformation,
                                      &PrimaryDomainInfo );

    if ( !NT_SUCCESS(Status) )
    {
        goto cleanup;
    }

    *DomainName = malloc(
                        (PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Length +
                         sizeof(WCHAR) ));
    if ( !*DomainName )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\n",
                     ERROR_NOT_ENOUGH_MEMORY,
                     Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
        goto cleanup;
    }

    memcpy(*DomainName,
           PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Buffer,
           PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Length );

    (*DomainName)[
                 PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Length /
                 sizeof(WCHAR)] = L'\0';


    NetStatus = NERR_Success;

    
    //
    // Return
    //
cleanup:
    if ( NetStatus != NERR_Success )
    {
        if ( *DomainName != NULL )
        {
            *DomainName = NULL;
        }
    }

    if ( PrimaryDomainInfo != NULL )
    {
        LsaFreeMemory( PrimaryDomainInfo );
    }

    if ( PolicyHandle != NULL )
    {
        Status = LsaClose( PolicyHandle );
        Assert( NT_SUCCESS(Status) );
    }
    if (connected)
    {
        WNetCancelConnection2(remotename,
                          0,
                          TRUE);
    }
    
    return(NetStatus == NERR_Success);
}    


DWORD
WrappedMakeSpnW(
               WCHAR   *ServiceClass,
               WCHAR   *ServiceName,
               WCHAR   *InstanceName,
               USHORT  InstancePort,
               WCHAR   *Referrer,
               DWORD   *pcbSpnLength, // Note this is somewhat different that DsMakeSPN
               WCHAR  **ppszSpn
               )
//this function wraps DsMakeSpnW for the purpose of memory
{
    DWORD cSpnLength=128;
    WCHAR SpnBuff[128];
    DWORD err;

    cSpnLength = 128;
    err = DsMakeSpnW(ServiceClass,
                     ServiceName,
                     InstanceName,
                     InstancePort,
                     Referrer,
                     &cSpnLength,
                     SpnBuff);

    if ( err && err != ERROR_BUFFER_OVERFLOW )
    {
        return err;
    }

    *ppszSpn = malloc(cSpnLength * sizeof(WCHAR));
    if ( !*ppszSpn )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\n",
                     ERROR_NOT_ENOUGH_MEMORY,
                     Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    *pcbSpnLength = cSpnLength * sizeof(WCHAR);

    if ( err == ERROR_BUFFER_OVERFLOW )
    {
        err = DsMakeSpnW(ServiceClass,
                         ServiceName,
                         InstanceName,
                         InstancePort,
                         Referrer,
                         &cSpnLength,
                         *ppszSpn);
        if ( err )
        {
            if ( *ppszSpn )
                free(*ppszSpn);
            return err;
        }
    } else
    {
        memcpy(*ppszSpn, SpnBuff, *pcbSpnLength);
    }
    Assert(*pcbSpnLength == (sizeof(WCHAR) * (1 + wcslen(*ppszSpn))));
    // Drop the null off.
    *pcbSpnLength -= sizeof(WCHAR);
    return 0;
}


DWORD
getGUID(
       IN  PDC_DIAG_DSINFO                 pDsInfo,
       IN  ULONG                           ulCurrTargetServer,
       OUT WCHAR **                        pszServerGuid
       )
/*++

Routine Description:

    Will return the GUID of the current server
        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    pszServerGuid - the returning GUID
    
Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD Length=0;
    WCHAR *ppszServerGuid=NULL;

    Length = wcslen( pDsInfo->pServers[ulCurrTargetServer].pszGuidDNSName);
    *pszServerGuid = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
    if ( !*pszServerGuid )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\n",
                     ERROR_NOT_ENOUGH_MEMORY,
                     Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*pszServerGuid,pDsInfo->pServers[ulCurrTargetServer].pszGuidDNSName);

    ppszServerGuid=*pszServerGuid;

    while ( *ppszServerGuid != L'.' )
    {
        ppszServerGuid++;
    }
    *ppszServerGuid=L'\0';


    return NO_ERROR;
}


BOOL
GetdnsMachine(LDAP *hLdap,
              WCHAR **ReturnString
             )
/*++

Routine Description:

    Will return the dnsName of the machine
        
Arguments:

   
    hLdap - handle to the LDAP server
    ReturnString - The dnsName of the machine
        
Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *DefaultFilter = L"objectClass=*";
    WCHAR        *Base=NULL;

    ULONG        Length;

    // Parameter check
    Assert( hLdap );

    // The default return
    *ReturnString=NULL;

    //
    // Read the reference to the fSMORoleOwner
    //
    AttrsToSearch[0] = L"dnsHostName";
    AttrsToSearch[1] = NULL;

    //get the Base
    WinError = FindServerRef (hLdap,&Base);
    if ( WinError != NO_ERROR )
    {
        return FALSE;   
    }

    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    if ( Base )
        free(Base);
    if ( LDAP_SUCCESS != LdapError )
    {
        if (SearchResult)
        {
           ldap_msgfree( SearchResult );
        }
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return FALSE;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return FALSE;
                        }
                        wcscpy( *ReturnString, Values[0] );
                        return TRUE;
                    }
                }
            }
        }
    }

    ldap_msgfree( SearchResult );
    PrintMessage(SEV_ALWAYS,
                 L"Failed with %d: %s\n",
                 ERROR_DS_CANT_RETRIEVE_ATTS,
                 Win32ErrToString(ERROR_DS_CANT_RETRIEVE_ATTS));
    return FALSE;   
}




DWORD
CDCMA_CheckForExistence(
    IN  LDAP  * hLdap,
    IN  WCHAR * name,
    IN  WCHAR * defaultNamingContext
    )
/*++

Routine Description:

    Checks if the hLdap connection has an object with the samaccountname of
    "name".
        
Arguments:

    hLdap - handle to the LDAP server
    
    name -  the sam account name to check for
    
    defaultNamingContext - the domain to search under
        
Return Value:

    ERROR_SUCCESS  -- account exists
    ERROR_NO_TRUST_SAM_ACCOUNT
    Operational errors otherwise.

--*/
{

    DWORD        WinError = ERROR_SUCCESS;
    ULONG        LdapError;
    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;
    WCHAR        BaseFilter[] = L"samaccountname=$";
    ULONG        Size;
    LPWSTR       Filter = NULL;
    WCHAR        *AttrArray[2] = {0, 0};

    AttrArray[0] = L"objectclass";

    Size = ( (wcslen( name )+1) * sizeof(WCHAR) ) + sizeof(BaseFilter);
    Filter = LocalAlloc( 0, Size );
    if ( Filter ) {
        wcscpy( Filter, L"samaccountname=" );
        wcscat( Filter, name );
        wcscat( Filter, L"$" );
    
        LdapError = ldap_search_sW(hLdap,
                                   defaultNamingContext,
                                   LDAP_SCOPE_SUBTREE,
                                   Filter,
                                   AttrArray,   // attrs
                                   FALSE,  // attrsonly
                                   &SearchResult);
    
    
        if (LdapError == LDAP_SUCCESS) {
    
            NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
            if (NumberOfEntries == 0) {
    
                WinError = ERROR_NO_TRUST_SAM_ACCOUNT;
            }
    
        } else {
    
            WinError = LdapMapErrorToWin32(LdapError);
        }

        LocalFree( Filter );

        if (SearchResult)
        {
           ldap_msgfree( SearchResult );
        }

    } else {

        WinError = ERROR_NOT_ENOUGH_MEMORY;

    }

    return WinError;

}

DWORD
CDCMA_FixServerFlags(
                   IN  LDAP  *                     hLdap,
                   IN  DWORD                       dwUserAccountControl,
                   IN  WCHAR *                     pwzCompObjDN
                   )
/*++

Routine Description:

    Writes out userAccountControl with the UF_SERVER_TRUST_ACCOUNT and
    UF_TRUSTED_FOR_DELEGATION bits set.
        
Arguments:

    hLdap - handle to the LDAP server
    
    dwUserAccountControl - the original value. The new bits are OR'd in.
    
    pwzCompObjDN - the DN of the computer object

Return Value:

    Operational errors.

--*/
{
    ULONG LdapError = LDAP_SUCCESS;
    PWSTR UserAccountControlValues[] = {0, 0};
    LDAPModW UserAccountControlMod = {LDAP_MOD_ADD, L"userAccountControl", UserAccountControlValues};
    LDAPModW *Attrs[] =
    {
        &UserAccountControlMod,
        0
    };
    WCHAR Buffer[11];  // enough to hold a string representing a 32 bit number

    dwUserAccountControl &= ~UF_NORMAL_ACCOUNT;
    dwUserAccountControl |= UF_SERVER_TRUST_ACCOUNT | UF_TRUSTED_FOR_DELEGATION;

    RtlZeroMemory(Buffer, sizeof(Buffer));
    _ltow(dwUserAccountControl, Buffer, 10);
    UserAccountControlValues[0] = Buffer;

    LdapError = ldap_modify_sW(hLdap,
                               pwzCompObjDN,
                               Attrs);

    if (LDAP_ATTRIBUTE_OR_VALUE_EXISTS == LdapError )
    {
        // The value already exists; replace the value then
        UserAccountControlMod.mod_op = LDAP_MOD_REPLACE;

        LdapError = ldap_modify_sW(hLdap,
                                   pwzCompObjDN,
                                   Attrs);
    }

    return LdapMapErrorToWin32(LdapError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\ds\dstestcm.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dstestcommon.c

ABSTRACT:

    Contains common functions for various ds tests in
    dcdiag

DETAILS:

CREATED:

    8 July 1999  Dmitry Dukat (dmitrydu)

REVISION HISTORY:
        

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include "dcdiag.h"
#include "dstest.h"


DWORD
FinddefaultNamingContext (
                         IN  LDAP *                      hLdap,
                         OUT WCHAR**                     ReturnString
                         )
/*++

Routine Description:

    This function will return the defaultNamingContext attrib so the it can
    be used for future searches.

Arguments:

    hLdap - handle to the LDAP server
    ReturnString - The defaultNamingContext

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *DefaultFilter = L"objectClass=*";

    ULONG         Length;

    // Parameter check
    Assert( hLdap );

    // The default return
    *ReturnString=NULL;

    //
    // Read the reference to the fSMORoleOwner
    //
    AttrsToSearch[0] = L"defaultNamingContext";
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( hLdap,
                                NULL,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        if (SearchResult)
        {
           ldap_msgfree( SearchResult );
        }
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of RootDSE for default NC failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        wcscpy( *ReturnString, Values[0] );
                        return NO_ERROR;
                    }
                }
            }
        }
    }

    ldap_msgfree( SearchResult );
    return ERROR_DS_CANT_RETRIEVE_ATTS;

}

DWORD
FindServerRef (
              IN  LDAP *                      hLdap,
              OUT WCHAR**                     ReturnString
              )
/*++

Routine Description:

    This function will return the serverName attrib so the it can
    be used for future searches.

Arguments:

    hLdap - handle to the LDAP server
    ReturnString - The serverName

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *DefaultFilter = L"objectClass=*";

    ULONG         Length;

    // Parameter check
    Assert( hLdap );

    // The default return
    *ReturnString=NULL;

    //
    // Read the reference to the fSMORoleOwner
    //
    AttrsToSearch[0] = L"serverName";
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( hLdap,
                                NULL,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        if (SearchResult)
        {
           ldap_msgfree( SearchResult );
        }
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of RootDSE for serverName failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        wcscpy( *ReturnString, Values[0] );
                        return NO_ERROR;
                    }
                }
            }
        }
    }

    ldap_msgfree( SearchResult );
    PrintMessage(SEV_ALWAYS,
                 L"Failed with %d: %s\n",
                 ERROR_DS_CANT_RETRIEVE_ATTS,
                 Win32ErrToString(ERROR_DS_CANT_RETRIEVE_ATTS));
    return ERROR_DS_CANT_RETRIEVE_ATTS;

}



DWORD
GetMachineReference(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext,
                   OUT WCHAR **                    ReturnString
                   )
/*++

Routine Description:

    This function will check to see if the current DC is
    in the domain controller's OU

Arguments:

    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    defaultNamingContext - the Base of the search
    ReturnString - The Machine Reference in DN form

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *filter = NULL;

    ULONG         Length;

    //check parameters
    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"distinguishedName";
    AttrsToSearch[1]=NULL;

    //build the filter
    Length= wcslen( L"sAMAccountName=$" ) +
            wcslen( name );

    #pragma prefast(disable: 255, "alloca can throw, but Prefast doesn't see the exception block in main.c::DcDiagRunTest")
    filter=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(filter,L"sAMAccountName=%s$",name);

    LdapError = ldap_search_sW( hLdap,
                                defaultNamingContext,
                                LDAP_SCOPE_SUBTREE,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        if (SearchResult)
        {
           ldap_msgfree( SearchResult );
        }
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW subtree of %s for sam account failed with %d: %s\n",
                     defaultNamingContext,
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        wcscpy( *ReturnString, Values[0] );
                        return NO_ERROR;
                    }
                }
            }
        }
    }

    ldap_msgfree( SearchResult );
    PrintMessage(SEV_ALWAYS,
                 L"Failed with %d: %s\n",
                 ERROR_DS_CANT_RETRIEVE_ATTS,
                 Win32ErrToString(ERROR_DS_CANT_RETRIEVE_ATTS));
    return ERROR_DS_CANT_RETRIEVE_ATTS;



}

DWORD
WrappedTrimDSNameBy(
           IN  WCHAR *                          InString,
           IN  DWORD                            NumbertoCut,
           OUT WCHAR **                         OutString
           )
/*++

Routine Description:

    This Function is wrapping TrimDSNameBy to hanndle the
    DSNAME struct.  Usage is the same as TrimDSNameBy except
    that you send WCHAR instead of DSNAME.  
    
    Callers: make sure that you send InString as a DN
             make sure to free OutString when done
    
Arguments:

    InString - A WCHAR that is a DN that we need to trim
    NumbertoCut - The number of parts to take off the front of the DN
    OutString - The Machine Reference in DN form

Return Value:

    A WinError is return to indicate if there were any problems.

--*/

{
    ULONG  Size;
    DSNAME *src, *dst, *QuotedSite;
    DWORD  WinErr=NO_ERROR;

    if ( *InString == L'\0' )
    {
        *OutString=NULL;
        return ERROR_INVALID_PARAMETER;
    }

    Size = (ULONG)DSNameSizeFromLen( wcslen(InString) );

    src = alloca(Size);
    RtlZeroMemory(src, Size);
    src->structLen = Size;

    dst = alloca(Size);
    RtlZeroMemory(dst, Size);
    dst->structLen = Size;

    src->NameLen = wcslen(InString);
    wcscpy(src->StringName, InString);

    WinErr = TrimDSNameBy(src, NumbertoCut, dst); 
    if ( WinErr != NO_ERROR )
    {
        *OutString=NULL;
        return WinErr;
    }

    *OutString = malloc((dst->NameLen+1)*sizeof(WCHAR));
    wcscpy(*OutString,dst->StringName);

    return NO_ERROR;


}

void
DInitLsaString(
              PLSA_UNICODE_STRING LsaString,
              LPWSTR String
              )
/*++

Routine Description:

    converts a PLSA_UNICODE_STRING to a LPWSTR.
        
Arguments:

                                 
    LsaString - a PLSA_UNICODE_STRING
    String - the returning LPWSTR
    
--*/
{
    DWORD StringLength;

    if ( String == NULL )
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;

        return;
    }

    StringLength = lstrlenW(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength = (USHORT) (StringLength + 1) *
                               sizeof(WCHAR);
}


DWORD
FindschemaNamingContext (
                         IN  LDAP *                      hLdap,
                         OUT WCHAR**                     ReturnString
                         )
/*++

Routine Description:

    This function will return the schemaNamingContext attrib so the it can
    be used for future searches.

Arguments:

    hLdap - handle to the LDAP server
    ReturnString - The defaultNamingContext

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *DefaultFilter = L"objectClass=*";

    ULONG         Length;

    // Parameter check
    Assert( hLdap );

    // The default return
    *ReturnString=NULL;

    //
    // Read the reference to the fSMORoleOwner
    //
    AttrsToSearch[0] = L"schemaNamingContext";
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( hLdap,
                                NULL,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        if (SearchResult)
        {
           ldap_msgfree( SearchResult );
        }
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of RootDSE for schemaNC failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        wcscpy( *ReturnString, Values[0] );
                        return NO_ERROR;
                    }
                }
            }
        }
    }

    ldap_msgfree( SearchResult );
    return ERROR_DS_CANT_RETRIEVE_ATTS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\ds\repair.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    repair.c

ABSTRACT:

    Contains routines to help recover from a deleted machine account.
    
DETAILS:

                       
CREATED:

    24 October 1999  Colin Brace (ColinBr)

REVISION HISTORY:
        

--*/

#define REPL_SPN_PREFIX  L"E3514235-4B06-11D1-AB04-00C04FC2DCD2"

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmsname.h>

#include <dsconfig.h>  // Definition of mask for visible containers

#include <lmcons.h>    // CNLEN
#include <lsarpc.h>    // PLSAPR_foo
#include <lmerr.h>
#include <lsaisrv.h>

#include <winldap.h>
#include <dns.h>
#include <ntdsapip.h>


#include "dcdiag.h"
#include "dstest.h"


/*

Theory of Operation for Deleted Domain Controller Machine Account Recovery
==========================================================================


The scenario that this code address is specifically the following:

1) DCPROMO is run to install a replica domain controller
2) during the non-critical portion, the deletion of the machine account
   replicates in
3) on startup, the system will start but will not function properly
4) in this case, this recovery code should be run to recreate the DC's 
   machine account.
   
There are a couple of issues that makes this a non trivial task

1) because of how win2k replication works, the security context of a replication
is always the machine itself (ie the security context of the RPC calls to 
perform repliation is the DC's machine account).                                                   
2) because of how kerberos works, if a DC wishes to perform an authenticated RPC
to another machine, the local KDC _must_ have both machine accounts locally in
order to construct the tickets necessary to perform an authentication.

As such, simply creating the machine account on the broken DC does not work 
since no other DC will be able to replicate it off.  Simply creating the 
machine account on other DC doesn't work since the local DC won't be able
to replicate it in.  However, not all is lost.  The trick is to create the
machine account on another DC, *turn off the KDC on the local machine*, and then
replicate in our machine account.

Here are the specifics steps this code does to recover from a deleted DC
machine account:

1) find a DC in our domain to help us (see function for specifics)
2) create a machine account for us with a replication SPN and a known password
3) set the local $MACHINE.ACC password
4) stop the KDC
5) force a replication from our helper DC to us
   

Caveats:

For the steady state case, restoring the machine account (and children) from 
backup is by far the best option.

If this option is not available, the above code will work, but will not 
reconstruct service state that was stored under the machine account object (
for example, FRS objects).  In this case, repairing the account and then
demoting and repromoting is probably the best thing to do.

*/


typedef struct _REPAIR_DC_ACCOUNT_INFO
{
    BOOL fRestartKDC;

    LPWSTR SamAccountName;
    LPWSTR DomainDnsName;
    LPWSTR AccountDn;
    LPWSTR DomainDn;
    LPWSTR Password;
    LPWSTR ReplSpn;
    LPWSTR LocalServerDn;
    LPWSTR RemoteDc;
    ULONG  RemoteDcIndex;

} REPAIR_DC_ACCOUNT_INFO, *PREPAIR_DC_ACCOUNT_INFO;

VOID
InitRepairDcAccountInfo(
    IN PREPAIR_DC_ACCOUNT_INFO pInfo
    )
{
    RtlZeroMemory( pInfo, sizeof(REPAIR_DC_ACCOUNT_INFO));
    pInfo->RemoteDcIndex = NO_SERVER;
}

DWORD
RepairStartService(
    LPWSTR ServiceName
    );

DWORD
RepairStopService(
    LPWSTR ServiceName
    );

VOID
ReleaseRepairDcAccountInfo(
    IN PREPAIR_DC_ACCOUNT_INFO pInfo
    )
//
// Release and undo state recorded by a REPAIR_DC_ACCOUNT_INFO
//
{
    if ( pInfo ) {

        if ( pInfo->fRestartKDC) {

            RepairStartService( SERVICE_KDC );

        }

        if ( pInfo->SamAccountName ) LocalFree( pInfo->SamAccountName );
        if ( pInfo->DomainDnsName ) LocalFree( pInfo->DomainDnsName );
        if ( pInfo->AccountDn ) LocalFree( pInfo->AccountDn );
        if ( pInfo->DomainDn ) LocalFree( pInfo->DomainDn );
        if ( pInfo->Password ) LocalFree( pInfo->Password );
        if ( pInfo->ReplSpn ) free( pInfo->ReplSpn );
        if ( pInfo->LocalServerDn ) LocalFree( pInfo->LocalServerDn );
        if ( pInfo->RemoteDc ) LocalFree( pInfo->RemoteDc );
        
    }
}


DWORD
RepairGetLocalDCInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    );

DWORD
RepairGetRemoteDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    );

DWORD
RepairSetRemoteDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    );

DWORD
RepairSetLocalDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    );

DWORD
RepairReplicateInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    );


DWORD
GetOperationalAttribute(
    IN LDAP *hLdap,
    IN LPWSTR OpAtt,
    OUT LPWSTR *OpAttValue
    );

// Forward from elsewhere ...
DWORD
WrappedMakeSpnW(
               WCHAR   *ServiceClass,
               WCHAR   *ServiceName,
               WCHAR   *InstanceName,
               USHORT  InstancePort,
               WCHAR   *Referrer,
               DWORD   *pcbSpnLength,
               WCHAR   **ppszSpn);

DWORD
RepairDCWithoutMachineAccount(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    )
/*++

Routine Description:

    This routine attempts to recover a DC whose machine account has
    been deleted.  See Theory of Operation above for details.
        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.

Return Value:

    ERROR_SUCCESS if DC has been recovered.
    otherwise a a failure approxiamating the last error hit.

--*/

{
    DWORD WinError = ERROR_SUCCESS;
    REPAIR_DC_ACCOUNT_INFO RepairInfo;
    WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+1];
    ULONG Length = sizeof(ComputerName)/sizeof(ComputerName[0]);
    BOOL fLocalMachineMissingAccount = FALSE;


    //
    // Init
    //
    InitRepairDcAccountInfo( &RepairInfo );

    //
    // This only works when the tool is run from the DC that needs repairing
    //
    if ( GetComputerName( ComputerName, &Length ) ) {

        if ((CSTR_EQUAL == CompareString(DS_DEFAULT_LOCALE,
                                         DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                         ComputerName,
                                         Length,
                                         pDsInfo->pServers[ulCurrTargetServer].pszName,
                                         wcslen(pDsInfo->pServers[ulCurrTargetServer].pszName) ))) {

            fLocalMachineMissingAccount = TRUE;
        }
    }

    if ( !fLocalMachineMissingAccount ) {
        //
        // We need to be running on the machine with the problem
        //
        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_RUN_LOCAL,
                 ComputerName );

        WinError = ERROR_CALL_NOT_IMPLEMENTED;

        goto Exit;

    }

    //
    // Get some local information
    //
    WinError = RepairGetLocalDCInfo( pDsInfo,
                                     ulCurrTargetServer,
                                     gpCreds,
                                     &RepairInfo );

    if ( ERROR_SUCCESS != WinError ) {

        goto Exit;
        
    }

    //
    // Find a DC to help us
    //
    WinError = RepairGetRemoteDcInfo ( pDsInfo,
                                       ulCurrTargetServer,
                                       gpCreds,
                                       &RepairInfo );
    if ( ERROR_SUCCESS != WinError ) {

        goto Exit;
        
    }

    //
    // Set the remote info  (create the machine, etc ...)
    //
    WinError = RepairSetRemoteDcInfo ( pDsInfo,
                                       ulCurrTargetServer,
                                       gpCreds,
                                       &RepairInfo );
    if ( ERROR_SUCCESS != WinError ) {

        goto Exit;
        
    }

    //
    // Set the local info (the local secret, etc ...)
    //
    WinError = RepairSetLocalDcInfo ( pDsInfo,
                                      ulCurrTargetServer,
                                      gpCreds,
                                      &RepairInfo );
    if ( ERROR_SUCCESS != WinError ) {

        goto Exit;
        
    }

    //
    // Attempt to bring over the information
    //
    WinError = RepairReplicateInfo ( pDsInfo,
                                     ulCurrTargetServer,
                                     gpCreds,
                                     &RepairInfo );
    if ( ERROR_SUCCESS != WinError ) {

        goto Exit;
        
    }

    //
    // That's it
    //

Exit:

    if ( ERROR_SUCCESS == WinError ) {

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_SUCCESS );

    } else {

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_ERROR,
                 Win32ErrToString(WinError) );

    }

    ReleaseRepairDcAccountInfo( &RepairInfo );

    return WinError;

}


DWORD
RepairGetLocalDCInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    )
/*++

Routine Description:

    This purpose of this routine is to fill in the following fields
    
    LPWSTR DomainDnsName;
    GUID   DomainGuid;
    LPWSTR LocalServerDn;
    LPWSTR LocalNtdsSettingsDn;

        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.
    
    pInfo - the repair DC account state

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    LSA_HANDLE hLsa = 0;
    LDAP * hLdap;
    LPWSTR UuidString = NULL;
    WCHAR RDN[MAX_COMPUTERNAME_LENGTH+1];
    ULONG size;
    PPOLICY_DNS_DOMAIN_INFO DnsInfo = NULL;
    WCHAR *pc;

    //
    // Construct our SAM account name
    //
    size = (wcslen(pDsInfo->pServers[ulCurrTargetServer].pszName)+2) * sizeof(WCHAR);
    pInfo->SamAccountName = LocalAlloc( LMEM_ZEROINIT, size );
    if ( !pInfo->SamAccountName ) {

        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
        
    }
    wcscpy( pInfo->SamAccountName, pDsInfo->pServers[ulCurrTargetServer].pszName );
    pc = &pInfo->SamAccountName[0];
    while ( *pc != L'\0' ) {
        towupper( *pc );
        pc++;
    }
    wcscat( pInfo->SamAccountName, L"$");

    //
    // Construct our password
    //
    size = (wcslen(pDsInfo->pServers[ulCurrTargetServer].pszName)+2) * sizeof(WCHAR);
    pInfo->Password = LocalAlloc( LMEM_ZEROINIT, size );
    if ( !pInfo->Password ) {

        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
        
    }
    wcscpy( pInfo->Password, pDsInfo->pServers[ulCurrTargetServer].pszName );
    pc = &pInfo->SamAccountName[0];
    while ( *pc != L'\0' ) {
        towlower( *pc );
        pc++;
    }


    //
    // Construct our REPL SPN
    //
    RtlZeroMemory( &oa, sizeof(oa) );
    Status = LsaOpenPolicy( NULL,
                            &oa,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &hLsa );
    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy( hLsa,
                                            PolicyDnsDomainInformation,
                                            (PVOID) &DnsInfo);
        
    }

    if ( !NT_SUCCESS( Status ) ) {
        WinError = RtlNtStatusToDosError( Status );
        goto Exit;
    }

    size = DnsInfo->DnsDomainName.Length + sizeof(WCHAR);
    pInfo->DomainDnsName = LocalAlloc( LMEM_ZEROINIT, size );
    if ( !pInfo->DomainDnsName ) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    RtlCopyMemory( pInfo->DomainDnsName, 
                   DnsInfo->DnsDomainName.Buffer, 
                   DnsInfo->DnsDomainName.Length );

    //
    // Setup the service principal name
    //
    WinError = UuidToStringW( &pDsInfo->pServers[ulCurrTargetServer].uuid, &UuidString );

    if ( WinError != RPC_S_OK ) {
        goto Exit;
    }

    size = 0;
    WinError = WrappedMakeSpnW(REPL_SPN_PREFIX,
                               pInfo->DomainDnsName,
                               UuidString,
                               0,
                               NULL,
                               &size,
                               &pInfo->ReplSpn );

    RpcStringFreeW(&UuidString);

    if ( WinError != ERROR_SUCCESS ) {
        goto Exit;
    }


    //
    // Get our ServerDn
    //
    WinError = DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                    gpCreds,
                                    FALSE,
                                    &hLdap);

    if ( ERROR_SUCCESS == WinError ) {
        
        WinError = GetOperationalAttribute( hLdap,
                                            LDAP_OPATT_SERVER_NAME_W,
                                            &pInfo->LocalServerDn );

        if ( ERROR_SUCCESS == WinError ) {

            WinError = GetOperationalAttribute( hLdap,
                                                LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W,
                                                &pInfo->DomainDn );
            
        }
    }

    if ( WinError != ERROR_SUCCESS ) {
        goto Exit;
    }

    //
    // Construct what our new machine account DN will be
    //
    wcscpy( RDN, pDsInfo->pServers[ulCurrTargetServer].pszName );
    pc = &(RDN[0]);
    while ( *pc != L'\0' ) {
        towupper( *pc );
        pc++;
    }

    size =  (wcslen( L"CN=,OU=Domain Controllers,")
          + wcslen( pInfo->DomainDn )
          + wcslen( RDN )
          + 1) * sizeof(WCHAR);

    pInfo->AccountDn = LocalAlloc( LMEM_ZEROINIT, size );
    if ( !pInfo->AccountDn ) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    wsprintf(pInfo->AccountDn, L"CN=%s,OU=Domain Controllers,%s",RDN, pInfo->DomainDn);



Exit:

    if ( DnsInfo ) {
        LsaFreeMemory( DnsInfo );
    }

    if ( hLsa ) {
        LsaClose( hLsa );
    }

    return WinError;
}


DWORD
RepairGetRemoteDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    )
/*++

Routine Description:

    The purpose of this routine is to find a DC to help us recover from our
    lost machine account.
        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.
    
    pInfo - the repair DC account state

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFOW DcInfo = NULL;

    //
    // N.B.  Review algorithm below before changing default values
    //
    ULONG Flags =   (DS_DIRECTORY_SERVICE_REQUIRED | 
                     DS_AVOID_SELF |
                     DS_RETURN_DNS_NAME);
      

    ASSERT( NO_SERVER == pInfo->RemoteDcIndex );

    while (   (WinError == ERROR_SUCCESS)
           && (NO_SERVER == pInfo->RemoteDcIndex) ) {

        WinError = DsGetDcName( NULL,
                                NULL,
                                NULL,
                                NULL,
                                Flags,
                                &DcInfo  );
    
        if ( (WinError == ERROR_NO_SUCH_DOMAIN)
          && ((Flags & DS_FORCE_REDISCOVERY) == 0) ) {

              //
              // Retry harder
              //
              WinError = ERROR_SUCCESS;
              Flags |= DS_FORCE_REDISCOVERY;
              continue;
        }

        // Make sure to turn this flag off
        Flags |= ~DS_FORCE_REDISCOVERY;

        if ( ERROR_SUCCESS == WinError ) {

            pInfo->RemoteDc = LocalAlloc( LMEM_ZEROINIT, (wcslen( DcInfo->DomainControllerName )+1) * sizeof(WCHAR) );
            if ( !pInfo->RemoteDc ) {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Exit;
            }
    
            if ( *DcInfo->DomainControllerName == L'\\' ) {
                wcscpy( pInfo->RemoteDc, DcInfo->DomainControllerName+2 );
            } else {
                wcscpy( pInfo->RemoteDc, DcInfo->DomainControllerName );
            }
    
            NetApiBufferFree(DcInfo);
    
            //
            // Now, find the server in the index
            //
            pInfo->RemoteDcIndex = DcDiagGetServerNum( pDsInfo,
                                                       ((Flags & DS_RETURN_FLAT_NAME) ? pInfo->RemoteDc : NULL),
                                                       NULL,
                                                       NULL,
                                                       ((Flags & DS_RETURN_DNS_NAME) ? pInfo->RemoteDc : NULL),
                                                       NULL
						       );
    
            if ( (NO_SERVER == pInfo->RemoteDcIndex)
              && ((Flags & DS_RETURN_FLAT_NAME) == 0)  ) {
    
                //
                // Couldn't find it?  DNS names can be finicky; try netbios
                //
                LocalFree( pInfo->RemoteDc );
                Flags |= ~DS_RETURN_DNS_NAME;
                Flags |= DS_RETURN_FLAT_NAME;

                continue;

            } else {

                // Can't match by flat or dns name; set an error so we bail out
                WinError = ERROR_DOMAIN_CONTROLLER_NOT_FOUND;
            }
        }
    }

    if ( NO_SERVER == pInfo->RemoteDcIndex ) {

        WinError = ERROR_DOMAIN_CONTROLLER_NOT_FOUND;

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_FIND_DC_ERROR);
        
    } else {

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_FIND_DC,
                 pInfo->RemoteDc );
        
        WinError = ERROR_SUCCESS;
    }

Exit:

    return WinError;
}

DWORD
RepairSetRemoteDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    )
/*++

Routine Description:

        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.
    
    pInfo - the repair DC account state

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{

    DWORD WinError  = ERROR_SUCCESS;
    ULONG LdapError = LDAP_SUCCESS;

    //
    // The add values
    //
    LPWSTR ObjectClassValues[] = {0, 0};
    LDAPModW ClassMod = {LDAP_MOD_ADD, L"objectclass", ObjectClassValues};

    LPWSTR UserAccountControlValues[] = {0, 0};
    LDAPModW UserAccountControlMod = {LDAP_MOD_ADD, L"useraccountcontrol", UserAccountControlValues};

    LPWSTR ServicePrincipalNameValues[] = {0, 0};
    LDAPModW ServicePrincipalNameMod = {LDAP_MOD_ADD, L"serviceprincipalname", ServicePrincipalNameValues};

    LPWSTR SamAccountNameValues[] = {0, 0};
    LDAPModW SamAccountNameMod = {LDAP_MOD_ADD, L"samaccountname", SamAccountNameValues};

    LDAPModW *Attrs[] =
    {
        &ClassMod,
        &UserAccountControlMod,
        &ServicePrincipalNameMod, 
        &SamAccountNameMod, 
        0
    };

    WCHAR    Buffer[11];  // enough to hold a string representing a 32 bit number
    ULONG    UserAccountControl = UF_SERVER_TRUST_ACCOUNT | UF_TRUSTED_FOR_DELEGATION;


    //
    // The modify values
    //
    LPWSTR ServerReferenceValues[] = {0, 0};
    LDAPModW ServerReferenceMod = {LDAP_MOD_ADD, L"serverReference", ServerReferenceValues};

    LDAPModW *ModAttrs[] =
    {
        &ServerReferenceMod,
        0
    };

    LDAP *hLdap = NULL;

    //
    // Setup the object class
    //
    ObjectClassValues[0] = L"computer";

    //
    // Setup the useraccountcontrol
    //
    RtlZeroMemory(Buffer, sizeof(Buffer));
    _ltow( UserAccountControl, Buffer, 10 );
    UserAccountControlValues[0] = Buffer;


    //
    // Setup the serviceprincipalname
    //
    ServicePrincipalNameValues[0] = pInfo->ReplSpn;

    //
    // Setup the samaccountname
    //
    SamAccountNameValues[0] = pInfo->SamAccountName;


    WinError = DcDiagGetLdapBinding(&pDsInfo->pServers[pInfo->RemoteDcIndex],
                                    gpCreds,
                                    FALSE,
                                    &hLdap);

    if ( WinError != ERROR_SUCCESS ) {

        goto Exit;
        
    }


    LdapError = ldap_add_sW( hLdap,
                             pInfo->AccountDn,
                             Attrs );

    WinError = LdapMapErrorToWin32( LdapError );

    if ( ERROR_ACCESS_DENIED == WinError ) {

        //
        // For various reasons, the UF_TRUSTED_FOR_DELEGATION field may cause 
        // an access denied if policy has not been properly set on the machine
        //

        UserAccountControl &= ~UF_TRUSTED_FOR_DELEGATION;
        _ltow( UserAccountControl, Buffer, 10 );

        LdapError = ldap_add_sW( hLdap,
                                 pInfo->AccountDn,
                                 Attrs );
    
        WinError = LdapMapErrorToWin32( LdapError );

    }

    if ( LdapError == LDAP_ALREADY_EXISTS ) {

        //
        // The object is there ... assume it is good
        //
        WinError = ERROR_SUCCESS;

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_ALREADY_EXISTS,
                 pInfo->AccountDn,
                 pInfo->RemoteDc );
        
    } else {

        if ( ERROR_SUCCESS == WinError ) {
    
            PrintMsg(SEV_ALWAYS,
                     DCDIAG_DCMA_REPAIR_CREATED_MA_SUCCESS,
                     pInfo->AccountDn,
                     pInfo->RemoteDc );
            
        } else {
    
            PrintMsg(SEV_ALWAYS,
                     DCDIAG_DCMA_REPAIR_CREATED_MA_ERROR,
                     pInfo->AccountDn,
                     pInfo->RemoteDc,
                     Win32ErrToString(WinError) );
    
        }

    }

    //
    // Now set the password	
    //
    if ( ERROR_SUCCESS == WinError ) {

        PUSER_INFO_3 Info = NULL;
        DWORD       ParmErr;

        WinError = NetUserGetInfo( pInfo->RemoteDc,
                                   pInfo->SamAccountName,
                                   3,
                                   (PBYTE*) &Info);

        if ( ERROR_SUCCESS == WinError ) {

            Info->usri3_password = pInfo->Password;

            WinError = NetUserSetInfo( pInfo->RemoteDc,
                                       pInfo->SamAccountName,
                                       3,
                                       (PVOID) Info,
                                       &ParmErr );

            NetApiBufferFree( Info );
            
        }

        if ( ERROR_SUCCESS != WinError ) {

            PrintMsg(SEV_ALWAYS,
                     DCDIAG_DCMA_REPAIR_CANNOT_SET_PASSWORD,
                     pInfo->AccountDn,
                     pInfo->RemoteDc,
                     Win32ErrToString(WinError) );

            WinError = ERROR_SUCCESS;
            
        }
                                         
    }


    if ( ERROR_SUCCESS == WinError ) {

        //
        // Now set the server backlink
        //
        ServerReferenceValues[0] = pInfo->AccountDn;
        LdapError = ldap_modify_sW( hLdap,
                                    pInfo->LocalServerDn,
                                    ModAttrs );
    
    
        if ( LDAP_ATTRIBUTE_OR_VALUE_EXISTS == LdapError ) {

            // The value already exists; replace the value then
            ServerReferenceMod.mod_op = LDAP_MOD_REPLACE;
    
            LdapError = ldap_modify_sW( hLdap,
                                        pInfo->LocalServerDn,
                                        ModAttrs );

    
        }

        //
        // Ignore this LDAP value -- is is not critical
        //
        
    }

    
Exit:

    return WinError;
}


DWORD
RepairSetLocalDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    )
/*++

Routine Description:

        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.
    
    pInfo - the repair DC account state

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{          
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS Status;
    LSA_HANDLE hLsa = NULL;
    LSA_HANDLE hSecret = NULL;
    UNICODE_STRING NewPassword;
    UNICODE_STRING SecretName;
    OBJECT_ATTRIBUTES oa;

    RtlInitUnicodeString( &SecretName, L"$MACHINE.ACC" );
    RtlInitUnicodeString( &NewPassword, pInfo->Password );
    RtlZeroMemory( &oa, sizeof(oa) );

    Status = LsaOpenPolicy( NULL,
                           &oa,
                           POLICY_CREATE_SECRET,
                           &hLsa );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaOpenSecret( hLsa,
                                &SecretName,
                                SECRET_WRITE,
                                &hSecret );

        if ( NT_SUCCESS( Status ) ) {
            
            Status = LsaSetSecret( hSecret,
                                   &NewPassword,
                                   NULL );

            LsaClose( hSecret );
        
        }

        LsaClose( hLsa );
    }

    if ( NT_SUCCESS( Status ) ) {

        WinError = RepairStopService( SERVICE_KDC );
        if ( WinError == ERROR_SUCCESS ) {
    
            pInfo->fRestartKDC = TRUE;

            PrintMsg(SEV_ALWAYS,
                     DCDIAG_DCMA_REPAIR_STOP_KDC_SUCCESS );
    
        } else {

            PrintMsg(SEV_ALWAYS,
                     DCDIAG_DCMA_REPAIR_STOP_KDC_ERROR,
                     Win32ErrToString(WinError) );
            PrintRpcExtendedInfo(SEV_VERBOSE, WinError);
        }
        
    } else {

        WinError = RtlNtStatusToDosError( Status );
    }

    return WinError;
}


DWORD
RepairReplicateInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    )
/*++

Routine Description:

        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.
    
    pInfo - the repair DC account state

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    HANDLE hDs;
    ULONG Options = 0;

    WinError = DcDiagGetDsBinding( &pDsInfo->pServers[ulCurrTargetServer],
                                   gpCreds,
                                   &hDs );

    if ( ERROR_SUCCESS == WinError ) {
        
        WinError = DsReplicaSync( hDs,
                                  pInfo->DomainDn,
                                  &pDsInfo->pServers[pInfo->RemoteDcIndex].uuid,
                                  Options );
    
        if ( ERROR_DS_DRA_NO_REPLICA == WinError )
        {
            //
            // Ok, we have to add this replica
            //
    
            // Schedule doesn't matter since this replica is going away
            ULONG     AddOptions = DS_REPSYNC_WRITEABLE;
            SCHEDULE  repltimes;
            memset(&repltimes, 0, sizeof(repltimes));
    
            WinError = DsReplicaAdd( hDs,
                                     pInfo->DomainDn,
                                     NULL, // SourceDsaDn not needed
                                     NULL, // transport not needed
                                     pDsInfo->pServers[pInfo->RemoteDcIndex].pszGuidDNSName,
                                     NULL, // no schedule
                                     AddOptions );
    
            if ( ERROR_SUCCESS == WinError  )
            {
                // Now try to sync it
                WinError = DsReplicaSync( hDs,
                                          pInfo->DomainDn,
                                          &pDsInfo->pServers[pInfo->RemoteDcIndex].uuid,
                                          Options );
            }
    
        }
    }

    if ( ERROR_SUCCESS == WinError ) {

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_REPL_SUCCESS,
                 pInfo->RemoteDc );

    } else {

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_REPL_ERROR,
                 pInfo->RemoteDc,
                 Win32ErrToString(WinError) );
        PrintRpcExtendedInfo(SEV_VERBOSE, WinError);
    }

    return WinError;
}

DWORD
GetOperationalAttribute(
    IN LDAP *hLdap,
    IN LPWSTR OpAtt,
    OUT LPWSTR *OpAttValue
    )
/*++

Routine Description:

        
Arguments:

    hLdap - an LDAP handle
    
    OpAtt - the ROOT DSE attribute to retrieve
    
    OpAttValue - the value of the attribute

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG LdapError;
    LDAPMessage  *SearchResult = NULL;
    ULONG NumberOfEntries;

    WCHAR       *attrs[] = {0, 0};

    *OpAttValue = NULL;

    attrs[0] = OpAtt;


    LdapError = ldap_search_sW(hLdap,
                               NULL,
                               LDAP_SCOPE_BASE,
                               L"objectClass=*",
                               attrs, 
                               FALSE,
                               &SearchResult);

    if (LdapError) {
        if (SearchResult)
        {
           ldap_msgfree( SearchResult );
        }
        return LdapMapErrorToWin32(LdapGetLastError());
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);

    if (NumberOfEntries > 0) {

        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        ULONG        NumberOfAttrs, NumberOfValues, i;

        //
        // Get entry
        //
        for (Entry = ldap_first_entry(hLdap, SearchResult), NumberOfEntries = 0;
                Entry != NULL;
                    Entry = ldap_next_entry(hLdap, Entry), NumberOfEntries++) {
            //
            // Get each attribute in the entry
            //
            for(Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement), NumberOfAttrs = 0;
                    Attr != NULL;
                        Attr = ldap_next_attributeW(hLdap, Entry, pBerElement), NumberOfAttrs++) {
                //
                // Get the value of the attribute
                //
                Values = ldap_get_valuesW(hLdap, Entry, Attr);
                if (!wcscmp(Attr, OpAtt)) {

                    ULONG Size;

                    Size = (wcslen( Values[0] ) + 1) * sizeof(WCHAR);
                    *OpAttValue = (WCHAR*) LocalAlloc( 0, Size );
                    if ( !*OpAttValue ) {
                        WinError = ERROR_NOT_ENOUGH_MEMORY;
                        goto Exit;
                    }
                    wcscpy( *OpAttValue, Values[0] );
                }

            }  // looping on the attributes

        } // looping on the entries

    }

    if ( NULL == (*OpAttValue) ) {

        WinError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;   

    }

Exit:
    if (SearchResult)
    {
       ldap_msgfree( SearchResult );
    }

    return WinError;
}


#define REPAIR_SERVICE_START 0x1
#define REPAIR_SERVICE_STOP  0x2

DWORD
RepairConfigureService(
    IN LPWSTR ServiceName,
    IN ULONG  ServiceOptions
    )
/*++

Routine Description:

    Starts or stops the configuration of a service.

Arguments:

    ServiceName - Service to configure

    ServiceOptions - Stop, start, dependency add/remove, or configure

    Dependency - a null terminated string identify a dependency

    ServiceWasRunning - Optional.  When stopping a service, the previous service state
                        is returned here

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad service option was given

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    SC_HANDLE hScMgr = NULL, hSvc = NULL;
    ULONG OpenMode = SERVICE_START | SERVICE_STOP | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_QUERY_STATUS;
    LPENUM_SERVICE_STATUS DependentServices = NULL;
    ULONG DependSvcSize = 0, DependSvcCount = 0, i;

    //
    // If the service doesn't stop within two minutes minute, continue on
    //
    ULONG AccumulatedSleepTime;
    ULONG MaxSleepTime = 120000;


    BOOLEAN ConfigChangeRequired = FALSE;
    BOOLEAN RunChangeRequired = FALSE;

    DWORD   PreviousStartType = SERVICE_NO_CHANGE;
    BOOLEAN fServiceWasRunning = FALSE;


    //
    // Open the service control manager
    //
    hScMgr = OpenSCManager( NULL,
                            SERVICES_ACTIVE_DATABASE,
                            GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE );

    if ( hScMgr == NULL ) {

        WinError = GetLastError();
        goto Cleanup;

    }

    //
    // Open the service
    //
    hSvc = OpenService( hScMgr,
                        ServiceName,
                        OpenMode );

    if ( hSvc == NULL ) {

        WinError = GetLastError();
        goto Cleanup;
    } 

    // Stop the service.
    if ( REPAIR_SERVICE_STOP == ServiceOptions ) {
    
        SERVICE_STATUS  SvcStatus;
    
        WinError = ERROR_SUCCESS;
    
        //
        // Enumerate all of the dependent services first
        //
        if(EnumDependentServices( hSvc,
                                  SERVICE_ACTIVE,
                                  NULL,
                                  0,
                                  &DependSvcSize,
                                  &DependSvcCount ) == FALSE ) {
    
            WinError = GetLastError();
        }
    
    
    
        if ( WinError == ERROR_MORE_DATA ) {
    
            DependentServices = RtlAllocateHeap( RtlProcessHeap(), 0, DependSvcSize );
    
            if ( DependentServices == NULL) {
    
                WinError = ERROR_OUTOFMEMORY;
    
            } else {
    
                if( EnumDependentServices( hSvc,
                                           SERVICE_ACTIVE,
                                           DependentServices,
                                           DependSvcSize,
                                           &DependSvcSize,
                                           &DependSvcCount ) == FALSE ) {
    
                    WinError = GetLastError();
    
                } else {
    
                    for ( i = 0; i < DependSvcCount; i++) {
    
                        WinError = RepairConfigureService(
                                         DependentServices[i].lpServiceName,
                                         REPAIR_SERVICE_STOP );
    
                        if ( WinError != ERROR_SUCCESS ) {
    
                            break;
                        }
    
                    }
                }
    
                RtlFreeHeap( RtlProcessHeap(), 0, DependentServices );
            }
    
        }
    
    
        if ( WinError == ERROR_SUCCESS ) {
    
            if ( ControlService( hSvc,
                                 SERVICE_CONTROL_STOP,
                                 &SvcStatus ) == FALSE ) {
    
                WinError = GetLastError();
    
                //
                // It's not an error if the service wasn't running
                //
                if ( WinError == ERROR_SERVICE_NOT_ACTIVE ) {
    
                    WinError = ERROR_SUCCESS;
                }
    
            } else {
    
                WinError = ERROR_SUCCESS;
    
                //
                // Wait for the service to stop
                //
                AccumulatedSleepTime = 0;
                while ( TRUE ) {
    
                    if( QueryServiceStatus( hSvc,&SvcStatus ) == FALSE ) {
    
                        WinError = GetLastError();
                    }
    
                    if ( WinError != ERROR_SUCCESS ||
                                        SvcStatus.dwCurrentState == SERVICE_STOPPED) {
    
                        break;
                    
                    }

                    if ( AccumulatedSleepTime < MaxSleepTime ) {

                        Sleep( SvcStatus.dwWaitHint );
                        AccumulatedSleepTime += SvcStatus.dwWaitHint;

                    } else {

                        //
                        // Give up and return an error
                        //
                        WinError = WAIT_TIMEOUT;
                        break;
                    }
                }
            }
        }

        if ( ERROR_SUCCESS != WinError ) {
            goto Cleanup;
        }
    
    }

    if ( REPAIR_SERVICE_START == ServiceOptions ) {

        //
        // See about changing its state
        //
        if ( StartService( hSvc, 0, NULL ) == FALSE ) {

            WinError = GetLastError();

        } else {

            WinError = ERROR_SUCCESS;
        }

        if ( ERROR_SUCCESS != WinError ) {
            goto Cleanup;
        }

    }

Cleanup:

    if ( hSvc ) {

        CloseServiceHandle( hSvc );

    }

    if ( hScMgr ) {
        
        CloseServiceHandle( hScMgr );

    }

    return( WinError );
}


DWORD
RepairStartService(
    LPWSTR ServiceName
    )
{
    return RepairConfigureService( ServiceName, REPAIR_SERVICE_START );
}

DWORD
RepairStopService(
    LPWSTR ServiceName
    )
{
    return RepairConfigureService( ServiceName, REPAIR_SERVICE_STOP );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\example\example.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    example.c

ABSTRACT:

    Example for adding new tests to dcdiag.exe.

DETAILS:

CREATED:

    05-May-1999 JeffParh

--*/

#include <ntdspch.h>
#include "dcdiag.h"

DWORD 
ExampleMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    )
{
    ULONG ul;

    PrintMessage(SEV_NORMAL, L"GLOBAL:\n");
    
    PrintIndentAdj(1);
    PrintMessage(SEV_NORMAL, _T("ulNumServers=%u\n"     ), pDsInfo->ulNumServers                           );
    PrintMessage(SEV_NORMAL, _T("pszRootDomain=%s\n"    ), pDsInfo->pszRootDomain                          );
    PrintMessage(SEV_NORMAL, _T("pszNC=%s\n"            ), pDsInfo->pszNC                                  );
    PrintMessage(SEV_NORMAL, _T("pszRootDomainFQDN=%s\n"), pDsInfo->pszRootDomainFQDN                      );
    PrintMessage(SEV_NORMAL, _T("iSiteOptions=0x%x\n"   ), pDsInfo->iSiteOptions                           );
    PrintMessage(SEV_NORMAL, _T("HomeServer=%s\n"       ), pDsInfo->pServers[pDsInfo->ulHomeServer].pszName);
    PrintIndentAdj(-1);

    for (ul=0; ul < pDsInfo->ulNumServers; ul++) {
        PrintMessage(SEV_NORMAL, _T("\n"));
        PrintMessage(SEV_NORMAL, _T("SERVER[%d]:\n"), ul);
        
        PrintIndentAdj(1);
        PrintMessage(SEV_NORMAL, _T("pszName=%s\n"       ), pDsInfo->pServers[ul].pszName       );
        PrintMessage(SEV_NORMAL, _T("pszGuidDNSName=%s\n"), pDsInfo->pServers[ul].pszGuidDNSName);
        PrintMessage(SEV_NORMAL, _T("pszDn=%s\n"         ), pDsInfo->pServers[ul].pszDn         );
        PrintMessage(SEV_NORMAL, _T("iOptions=%x\n"      ), pDsInfo->pServers[ul].iOptions      ); 
        PrintIndentAdj(-1);
    }

    for (ul=0; ul < pDsInfo->ulNumTargets; ul++) {
        PrintMessage(SEV_NORMAL, _T("\n"));
        PrintMessage(SEV_NORMAL, _T("TARGET[%d]:\n"), ul);
        
        PrintIndentAdj(1);
        PrintMessage(SEV_NORMAL, _T("%s\n"), pDsInfo->pServers[pDsInfo->pulTargets[ul]].pszName);
        PrintIndentAdj(-1);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\ds\rid.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    rid.c

ABSTRACT:

    Contains tests related to the rid master.  Tests to see if rid master is up and does
    sanity checks on it.

DETAILS:

CREATED:

    8 July 1999  Dmitry Dukat (dmitrydu)

REVISION HISTORY:
        

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include "dcdiag.h"
#include "dstest.h"

//the threshold before the rid master allocate a new
//rid pool
#define CURRENTTHRESHOLD 20


//local prototypes
DWORD
CRM_GetDNSfor (
              IN  LDAP  *                     hLdap,
              IN  WCHAR *                     DN,
              OUT WCHAR **                    ReturnString);

DWORD
CRM_CheckLocalRIDSanity(
                       IN  LDAP  *                     hLdap,
                       IN  WCHAR *                     pszName,
                       IN  WCHAR *                     defaultNamingContext);

DWORD
GetRIDReference(
               IN  LDAP  *                      hLdap,
               IN  WCHAR *                     name,
               IN  WCHAR *                     defaultNamingContext,
               OUT WCHAR **                    ReturnString);


DWORD
CheckRidManager (
                PDC_DIAG_DSINFO                     pDsInfo,
                ULONG                               ulCurrTargetServer,
                SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
                )
/*++

Routine Description:

    This is a test called from the dcdiag framework.  This test will determine if the 
    Rid Master can be reached and will make sure that values in the rid master are
    sane.  Helper functions of this function all begin with "CRM_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    NO_ERROR, if all NCs checked out.
    A Win32 Error if any NC failed to check out.

--*/
{
    DWORD  dwRet = ERROR_SUCCESS, dwErr = ERROR_SUCCESS;
    LDAP   *hLdap = NULL;
    WCHAR  *defaultNamingContext=NULL;
    WCHAR  *RIDMasterDNS=NULL;
    ULONG  iRidMaster;
    HANDLE hDsBinding=NULL;

    //Assert(gpCreds);
    Assert(pDsInfo);

    //create a connection with the DS using LDAP
    dwErr = DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                 gpCreds,
                                 FALSE,
                                 &hLdap);

    if ( dwErr != LDAP_SUCCESS )
    {
        dwErr = LdapMapErrorToWin32(dwErr);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP bind failed with error %d. %s\n",
                     pDsInfo->pServers[ulCurrTargetServer].pszName,
                     dwErr,
                     Win32ErrToString(dwErr));
        goto cleanup;
    }

    //find the defaultNamingContext
    dwErr=FinddefaultNamingContext(hLdap,&defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        goto cleanup;
    }



    //find the DNS of the rid master
    dwErr=CRM_GetDNSfor(hLdap,defaultNamingContext,&RIDMasterDNS);
    if ( dwErr != NO_ERROR )
    {
        goto cleanup;
    }

    iRidMaster = DcDiagGetServerNum(pDsInfo, NULL, NULL, NULL, RIDMasterDNS, NULL);
    if(iRidMaster == NO_SERVER){
        PrintMsg(SEV_ALWAYS, DCDIAG_GET_SERVER_NUM_FAILURE, RIDMasterDNS);
        dwErr = ERROR_DS_CANT_FIND_DSA_OBJ;
        goto cleanup;
    }
        
    PrintMessage(SEV_VERBOSE,
                 L"* %s is the RID Master\n",RIDMasterDNS);

    //Attempt to get DS binding to the rid master
    dwErr = DcDiagGetDsBinding(&(pDsInfo->pServers[iRidMaster]), gpCreds, &hDsBinding);
    if ( dwErr != NO_ERROR )
    {
        // Error printed by DcDiagGetDsBinding().
        goto cleanup;
    }
    PrintMessage(SEV_VERBOSE,
                 L"* DsBind with RID Master was successful\n");

    dwErr=CRM_CheckLocalRIDSanity(hLdap,pDsInfo->pServers[ulCurrTargetServer].pszName,
                                  defaultNamingContext);



    //final cleanup
    cleanup:
    if ( defaultNamingContext )
        free(defaultNamingContext);
    if ( RIDMasterDNS )
        free(RIDMasterDNS);
    return dwErr;


}




DWORD
CRM_GetDNSfor (
              IN  LDAP *                      hLdap,
              IN  WCHAR*                      Base,
              OUT WCHAR**                     ReturnString
              )

/*++

Routine Description:

    This function will return the FSMORoleMaster in DNS form so the it can
    be used for future searches.  It will also check the sanity of the available
    rid pool

Arguments:

    hLdap - handle to the LDAP server
    Base - The DefaultNamingContext
    ReturnString - The FSMORoleMaster in DNS form

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[3];

    WCHAR        *DefaultFilter = L"objectClass=*";

    WCHAR        *rIDManagerReference=NULL;
    WCHAR        *fSMORoleOwner=NULL;
    WCHAR        *fSMORoleOwnerOffset=NULL;

    ULONG        Length;

    // Parameter check
    Assert( hLdap );

    // The default return
    *ReturnString=NULL;

    //
    // Read the reference to the rIDManagerReference
    //
    AttrsToSearch[0] = L"rIDManagerReference";
    AttrsToSearch[1] = NULL;


    //Find the rIDManagerReference
    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of %s for rid manager reference failed with %d: %s\n",
                     Base,
                     WinError,
                     Win32ErrToString(WinError));
        PrintMsg( SEV_ALWAYS, DCDIAG_RID_MANAGER_NO_REF, Base );
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        #pragma prefast(disable: 255 263, "alloca can throw, but Prefast doesn't see the exception block in main.c::DcDiagRunTest; and Using alloca in a loop; this is a small loop and these are small allocations")
                        rIDManagerReference = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy(rIDManagerReference, Values[0] );
                        ldap_value_free(Values);
                        break;
                    }
                }
            }
        }
    }

    if (rIDManagerReference == NULL) {
        PrintMsg( SEV_ALWAYS, DCDIAG_RID_MANAGER_NO_REF, Base );
    } else if (IsDeletedRDNW( rIDManagerReference )) {
        PrintMsg( SEV_ALWAYS, DCDIAG_RID_MANAGER_DELETED, Base );
        PrintMsg( SEV_ALWAYS, DCDIAG_RID_MANAGER_NO_REF, Base );
    } else {
        PrintMessage( SEV_DEBUG, L"ridManagerReference = %s\n", rIDManagerReference );
    }

    if ( SearchResult )
        ldap_msgfree( SearchResult );
    if ( WinError != NO_ERROR )
    {
        goto cleanup;
    }

    AttrsToSearch[0] = L"fSMORoleOwner";
    AttrsToSearch[1] = L"rIDAvailablePool";
    AttrsToSearch[2] = NULL;

    //find the fSMORoleOwner
    LdapError = ldap_search_sW( hLdap,
                                rIDManagerReference,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of %s for FSMO Role Owner failed with %d: %s\n",
                     rIDManagerReference,
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        fSMORoleOwner = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy(fSMORoleOwner, Values[0] );
                        ldap_value_free(Values);
                    }
                }
                //sanity check while here
                if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //A LARGE_INTERGER in string format
                        ULONGLONG Lvalue=0;
                        ULONGLONG Hvalue=0;
                        //convert to a binary
                        Hvalue=Lvalue=_wtoi64(Values[0]);
                        ldap_value_free(Values);
                        //LowPart
                        Lvalue<<=32;
                        Lvalue>>=32;
                        //Highpart
                        Hvalue>>=32;
                        //sanity checks
                        if ( Hvalue - Lvalue <= 0 )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"The DS has corrupt data: %s value is not valid\n",
                                         AttrsToSearch[1]);
                            WinError = ERROR_DS_CODE_INCONSISTENCY;
                            goto cleanup;
                        }
                        PrintMessage(SEV_VERBOSE,
                                     L"* Available RID Pool for the Domain is %I64d to %I64d\n",
                                     Lvalue,
                                     Hvalue);
                     }
                }
            }
        }
    }

    if (fSMORoleOwner == NULL) {
        PrintMessage( SEV_ALWAYS, L"Warning: attribute FSMORoleOwner missing from %s\n",
                      rIDManagerReference );
        WinError = ERROR_DS_CODE_INCONSISTENCY;
        goto cleanup;
    } else if (IsDeletedRDNW( fSMORoleOwner )) {
        PrintMessage( SEV_ALWAYS, L"Warning: FSMO Role Owner is deleted.\n" );
    } else {
        PrintMessage( SEV_DEBUG, L"fSMORoleOwner = %s\n", fSMORoleOwner );
    }

    //clean up
    if ( SearchResult )
        ldap_msgfree( SearchResult );

    //Finally find and return the DNS of the rid master.


    //Point past the first part of the fSMORoleOwner DN
    WrappedTrimDSNameBy(fSMORoleOwner,1,&fSMORoleOwnerOffset);


    AttrsToSearch[0] = L"dNSHostName";
    AttrsToSearch[1] = NULL;



    LdapError = ldap_search_sW( hLdap,
                                fSMORoleOwnerOffset,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of %s for hostname failed with %d: %s\n",
                     fSMORoleOwnerOffset,
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            WinError = ERROR_NOT_ENOUGH_MEMORY;
                            goto cleanup;
                        }

                        wcscpy(*ReturnString, Values[0] );
                        break;
                    }
                }
            }
        }
    }

    //clean up
    cleanup:
    if ( fSMORoleOwnerOffset )
        free(fSMORoleOwnerOffset);
    if ( SearchResult )
        ldap_msgfree( SearchResult );

    return WinError;
}

DWORD
CRM_CheckLocalRIDSanity(
                       IN  LDAP  *                     hLdap,
                       IN  WCHAR *                     pszName,
                       IN  WCHAR *                     defaultNamingContext)
/*++

Routine Description:

    This function will check the sanity of the information that is found
    in the rid set

Arguments:

    hLdap - handle to the LDAP server 
    pszName - A wchar string that will be used to build the base for a ldap search
    ReturnString - A wchar string that will be used to build the base for a ldap search

Return Value:

    A WinError is return to indicate if there were any problems.

--*/

{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[4];

    WCHAR        *DefaultFilter = L"objectClass=*";
    WCHAR        *Base=NULL;

    DWORD        rIDNextRID=0;
    ULONGLONG    rIDPreviousAllocationPool=0;
    ULONGLONG    rIDAllocationPool=0;

    ULONGLONG    Lvalue=0;
    ULONGLONG    Hvalue=0;
    DWORD        PercentRemaining=0;
    ULONG        TotalRidsInPool;

    //check parameters
    Assert(pszName);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"rIDNextRID";
    AttrsToSearch[1]=L"rIDPreviousAllocationPool";
    AttrsToSearch[2]=L"rIDAllocationPool";
    AttrsToSearch[3]=NULL;

    //built the Base
    WinError=GetRIDReference(hLdap,pszName,defaultNamingContext,&Base);
    if ( WinError == ERROR_DS_CANT_RETRIEVE_ATTS )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not get Rid set Reference :failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    //find the attributes and do sanity checks on them

    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of %s for rid info failed with %d: %s\n",
                     Base,
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //A LARGE_INTERGER in string format
                        //convert to a binary
                        rIDNextRID=_wtoi(Values[0]);
                        ldap_value_free(Values);

                        PrintMessage(SEV_VERBOSE,L"* rIDNextRID: %ld\n",rIDNextRID);

                    }
                }
                if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //A LARGE_INTERGER in string format
                        //convert to a binary
                        Hvalue=Lvalue=rIDPreviousAllocationPool=_wtoi64(Values[0]);
                        ldap_value_free(Values);
                        //LowPart
                        Lvalue<<=32;
                        Lvalue>>=32;
                        //Highpart
                        Hvalue>>=32;
                        //sanity checks
                        if ( Hvalue - Lvalue <= 0 )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"The DS has corrupt data: %s value is not valid\n",
                                         AttrsToSearch[1]);
                            WinError = ERROR_DS_CODE_INCONSISTENCY;
                        }
                        PrintMessage(SEV_VERBOSE,
                                     L"* rIDPreviousAllocationPool is %I64d to %I64d\n",
                                     Lvalue,
                                     Hvalue);
                    }
                }
                if ( !_wcsicmp( Attr, AttrsToSearch[2] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //A ULONGLONG in string format
                        //convert to a binary
                        Hvalue=Lvalue=rIDAllocationPool=_wtoi64(Values[0]);
                        ldap_value_free(Values);
                        //LowPart
                        Lvalue<<=32;
                        Lvalue>>=32;
                        //Highpart
                        Hvalue>>=32;
                        //sanity checks
                        if ( Hvalue - Lvalue <= 0 )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"The DS has corrupt data: %s value is not valid\n",
                                         AttrsToSearch[1]);
                            WinError = ERROR_DS_CODE_INCONSISTENCY;
                        }
                        PrintMessage(SEV_VERBOSE,
                                     L"* rIDAllocationPool is %I64d to %I64d\n",
                                     Lvalue,
                                     Hvalue);
                    }
                }

            }
        }

    }

    //sanity checks
    Hvalue=Lvalue=rIDPreviousAllocationPool;
    //LowPart
    Lvalue<<=32;
    Lvalue>>=32;
    //Highpart
    Hvalue>>=32;
    //sanity checks
    TotalRidsInPool = (ULONG)(Hvalue-Lvalue);
    if ( TotalRidsInPool != 0 )
    {
        PercentRemaining = (ULONG)(100-((rIDNextRID-Lvalue)*100/TotalRidsInPool));
        if ( PercentRemaining < CURRENTTHRESHOLD )
        {
            if ( rIDPreviousAllocationPool == rIDAllocationPool )
            {
                PrintMessage(SEV_VERBOSE,
                             L"* Warning :Next rid pool not allocated\n");
            }
            PrintMessage(SEV_VERBOSE,
                         L"* Warning :There is less than %ld%% available RIDs in the current pool\n",
                         PercentRemaining);
        }

    }
    else
    {

        PrintMessage(SEV_ALWAYS,
                     L"No rids allocated -- please check eventlog.\n");


    }
    if ( rIDNextRID < Lvalue || rIDNextRID > Hvalue )
    {
        PrintMessage(SEV_ALWAYS,
                     L"The DS has corrupt data: rIDNextRID value is not valid\n");
        WinError = ERROR_DS_CODE_INCONSISTENCY;
    }

    cleanup:
    if ( SearchResult )
        ldap_msgfree( SearchResult );
    if ( Base )
        free(Base);

    return WinError;


}

DWORD
GetRIDReference(
               IN  LDAP  *                     hLdap,
               IN  WCHAR *                     name,
               IN  WCHAR *                     defaultNamingContext,
               OUT WCHAR **                    ReturnString
               )
/*++

Routine Description:

    This function will return the RID set reference

Arguments:

    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    defaultNamingContext - the Base of the search
    ReturnString - The RID set reference in DN form

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *filter = NULL;
    WCHAR        *Base = NULL;

    ULONG         Length;

    //check parameters
    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"rIDSetReferences";
    AttrsToSearch[1]=NULL;

    //built the filter
    filter=L"objectClass=*";


    WinError = GetMachineReference(hLdap,name,defaultNamingContext,&Base);
    if ( WinError != NO_ERROR )
    {
        return WinError;
    }


    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    if ( LDAP_SUCCESS != LdapError )
    {
        if (SearchResult)
        {
           ldap_msgfree( SearchResult );
        }
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of %s for rid set references failed with %d: %s\n",
                     Base,
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        wcscpy( *ReturnString, Values[0] );

                        if (IsDeletedRDNW( *ReturnString )) {
                            PrintMessage( SEV_ALWAYS, L"Warning: rid set reference is deleted.\n" );
                        } else {
                            PrintMessage( SEV_DEBUG, L"rIDSetReferences = %s\n", *ReturnString );
                        }

                        return NO_ERROR;
                    }
                }
            }
        }
    }

    PrintMessage( SEV_ALWAYS,
                  L"Warning: attribute rIdSetReferences missing from %s\n",
                  Base );
    
    if ( SearchResult )
        ldap_msgfree( SearchResult );
    return ERROR_DS_CANT_RETRIEVE_ATTS;



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\dcdiag\ds\obsc.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    obsc.c

ABSTRACT:

    Contains tests related to outbound secure channels.  CheckOutboundSecureChannels()
    is called from DcDiag.c
    
DETAILS:

CREATED:

    8 July 1999  Dmitry Dukat (dmitrydu)

REVISION HISTORY:
        

--*/


#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include <lmsname.h>
#include <lsarpc.h>                     // PLSAPR_foo

#include <lmaccess.h>

#include "dcdiag.h"
#include "dstest.h"

//local prototypes
                                                                   
DWORD 
COSC_CheckOutboundTrusts(
                    IN  LDAP                              *hLdap,
                    IN  WCHAR                             *ServerName,
                    IN  WCHAR                             *Domain,
                    IN  WCHAR                             *defaultNamingContext,
                    IN  WCHAR                             *targetdefaultNamingContext,
                    IN  SEC_WINNT_AUTH_IDENTITY_W *       gpCreds
                    );

DWORD
COT_FindDownLevelTrustObjects(
                    IN  LDAP                              *hLdap,
                    IN  WCHAR                             *ServerName,
                    IN  WCHAR                             *DomainName,
                    IN  WCHAR                             *defaultNamingContext
                    );

DWORD
COT_FindUpLevelTrustObjects(
                    IN  LDAP                              *hLdap,
                    IN  WCHAR                             *ServerName,
                    IN  WCHAR                             *DomainName,
                    IN  WCHAR                             *defaultNamingContext,
                    IN  WCHAR                             *targetdefaultNamingContext
                    );

DWORD 
CheckOutboundSecureChannels (
                     PDC_DIAG_DSINFO                      pDsInfo,
                     ULONG                                ulCurrTargetServer,
                     SEC_WINNT_AUTH_IDENTITY_W *          gpCreds
                     );

DWORD
COT_CheckSercureChannel(
                     WCHAR *                              server,
                     WCHAR *                              domain
                     );


DWORD 
CheckOutboundSecureChannels (
                    PDC_DIAG_DSINFO                       pDsInfo,            
                    ULONG                                 ulCurrTargetServer,
                    SEC_WINNT_AUTH_IDENTITY_W *           gpCreds
                    )
/*++

Routine Description:

    will display all domain that current domain has outbound trusts with
    Will check to see if domain has secure channels with all domains that
    it has an outbound trust with.  Will give reason why a secure channel is not present
    Will see if the trust is uplevel and if both a trust object and an interdomain trust
    object exists.  Helper functions of this function all begin with "COSC_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    NO_ERROR, if all tests checked out.
    A Win32 Error if any tests failed to check out.

--*/
{
    DWORD dwErr=NO_ERROR, RetErr=NO_ERROR;
    BOOL  bFoundDomain = FALSE;
    BOOL  LimitToSite = TRUE;
    WCHAR *Domain=NULL;
    WCHAR *defaultNamingContext=NULL;
    WCHAR *targetdefaultNamingContext=NULL;
    LDAP  *hLdap=NULL;
    LDAP  *targethLdap=NULL;
    ULONG i=0,j=0;

    PrintMessage(SEV_VERBOSE, 
                 L"* The Outbound Secure Channels test\n");

    //do test specific parsing
    for(i=0; pDsInfo->ppszCommandLine[i] != NULL ;i++)
    {
        if(_wcsnicmp(pDsInfo->ppszCommandLine[i],L"/testdomain:",wcslen(L"/testdomain:")) == 0)
        {
            Domain = &pDsInfo->ppszCommandLine[i][wcslen(L"/testdomain:")];
            bFoundDomain = TRUE;
        }
        else if (_wcsnicmp(pDsInfo->ppszCommandLine[i],L"/nositerestriction",wcslen(L"/nositerestriction")) == 0)
        {
            LimitToSite = FALSE;   
        }

    }
    
    if(!bFoundDomain)
    {
        PrintMessage(SEV_ALWAYS,
                     L"** Did not run Outbound Secure Channels test\n" );
        PrintMessage(SEV_ALWAYS,
                     L"because /testdomain: was not entered\n");
        return NO_ERROR;
    }

    
    //create a connection with the DS using LDAP
    dwErr = DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                 gpCreds,
                                 FALSE,
                                 &hLdap);
    if ( dwErr != LDAP_SUCCESS )
    {
        dwErr = LdapMapErrorToWin32(dwErr);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP bind failed with error %d. %s\n",
                     pDsInfo->pServers[ulCurrTargetServer].pszName,
                     dwErr,
                     Win32ErrToString(dwErr));
        goto cleanup;
    }
    

    //find the defaultNamingContext
    dwErr=FinddefaultNamingContext(hLdap,&defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        goto cleanup;
    }

    for (i=0;i<pDsInfo->ulNumServers;i++)
    {
        //create a connection with the DS using LDAP
        dwErr = DcDiagGetLdapBinding(&pDsInfo->pServers[i],
                                     gpCreds,
                                     FALSE,
                                     &targethLdap);
        if ( dwErr != LDAP_SUCCESS )
        {
            dwEr